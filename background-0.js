LavaPack.loadBundle([
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\metametrics.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\constants\metametrics.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REJECT_NOTFICIATION_CLOSE_SIG = exports.REJECT_NOTFICIATION_CLOSE = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = void 0;
// Type Imports

/**
 * @typedef {__import__('../../shared/constants/app').EnvironmentType} EnvironmentType
 */
// Type Declarations

/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 *
 * @typedef {Object} MetaMetricsPageObject
 * @property {string} [path] - the path of the current page (e.g /home)
 * @property {string} [title] - the title of the current page (e.g 'home')
 * @property {string} [url] - the fully qualified url of the current page
 */

/**
 * For metamask, this is the dapp that triggered an interaction
 *
 * @typedef {Object} MetaMetricsReferrerObject
 * @property {string} [url] - the origin of the dapp issuing the
 *  notification
 */

/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 *
 * @typedef {Object} MetaMetricsContext
 * @property {Object} app - Application metadata.
 * @property {string} app.name - the name of the application tracking the event
 * @property {string} app.version - the version of the application
 * @property {string} userAgent - the useragent string of the user
 * @property {MetaMetricsPageObject} [page] - an object representing details of
 *  the current page
 * @property {MetaMetricsReferrerObject} [referrer] - for metamask, this is the
 *  dapp that triggered an interaction
 */

/**
 * @typedef {Object} MetaMetricsEventPayload
 * @property {string} event - event name to track
 * @property {string} category - category to associate event to
 * @property {string} [environmentType] - The type of environment this event
 *  occurred in. Defaults to the background process type
 * @property {object} [properties] - object of custom values to track, keys
 *  in this object must be in snake_case
 * @property {object} [sensitiveProperties] - Object of sensitive values to
 *  track. Keys in this object must be in snake_case. These properties will be
 *  sent in an additional event that excludes the user's metaMetricsId
 * @property {number} [revenue] - amount of currency that event creates in
 *  revenue for MetaMask
 * @property {string} [currency] - ISO 4127 format currency for events with
 *  revenue, defaults to US dollars
 * @property {number} [value] - Abstract business "value" attributable to
 *  customers who trigger this event
 * @property {MetaMetricsPageObject} [page] - the page/route that the event
 *  occurred on
 * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
 *  that triggered the event
 */

/**
 * @typedef {Object} MetaMetricsEventOptions
 * @property {boolean} [isOptIn] - happened during opt in/out workflow
 * @property {boolean} [flushImmediately] - When true will automatically flush
 *  the segment queue after tracking the event. Recommended if the result of
 *  tracking the event must be known before UI transition or update
 * @property {boolean} [excludeMetaMetricsId] - whether to exclude the user's
 *  metametrics id for anonymity
 * @property {string} [metaMetricsId] - an override for the metaMetricsId in
 *  the event one is created as part of an asynchronous workflow, such as
 *  awaiting the result of the metametrics opt-in function that generates the
 *  user's metametrics id
 * @property {boolean} [matomoEvent] - is this event a holdover from matomo
 *  that needs further migration? when true, sends the data to a special
 *  segment source that marks the event data as not conforming to our schema
 */

/**
 * @typedef {Object} MetaMetricsEventFragment
 * @property {string} successEvent - The event name to fire when the fragment
 *  is closed in an affirmative action.
 * @property {string} [failureEvent] - The event name to fire when the fragment
 *  is closed with a rejection.
 * @property {string} [initialEvent] - An event name to fire immediately upon
 *  fragment creation. This is useful for building funnels in mixpanel and for
 *  reduction of code duplication.
 * @property {string} category - the event category to use for both the success
 *  and failure events
 * @property {boolean} [persist] - Should this fragment be persisted in
 *  state and progressed after the extension is locked and unlocked.
 * @property {number} [timeout] - Time in seconds the event should be persisted
 *  for. After the timeout the fragment will be closed as abandoned. if not
 *  supplied the fragment is stored indefinitely.
 * @property {number} [lastUpdated] - Date.now() when the fragment was last
 *  updated. Used to determine if the timeout has expired and the fragment
 *  should be closed.
 * @property {object} [properties] - Object of custom values to track, keys in
 *  this object must be in snake_case.
 * @property {object} [sensitiveProperties] - Object of sensitive values to
 *  track. Keys in this object must be in snake_case. These properties will be
 *  sent in an additional event that excludes the user's metaMetricsId
 * @property {number} [revenue] - amount of currency that event creates in
 *  revenue for MetaMask if fragment is successful.
 * @property {string} [currency] - ISO 4127 format currency for events with
 *  revenue, defaults to US dollars
 * @property {number} [value] - Abstract business "value" attributable to
 *  customers who successfully complete this fragment
 * @property {MetaMetricsPageObject} [page] - the page/route that the event
 *  occurred on
 * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
 *  that initiated the event fragment.
 * @property {string} [uniqueIdentifier] - optional argument to override the
 *  automatic generation of UUID for the event fragment. This is useful when
 *  tracking events for subsystems that already generate UUIDs so to avoid
 *  unnecessary lookups and reduce accidental duplication.
 */

/**
 * Represents the shape of data sent to the segment.track method.
 *
 * @typedef {Object} SegmentEventPayload
 * @property {string} [userId] - The metametrics id for the user
 * @property {string} [anonymousId] - An anonymousId that is used to track
 *  sensitive data while preserving anonymity.
 * @property {string} event - name of the event to track
 * @property {Object} properties - properties to attach to the event
 * @property {MetaMetricsContext} context - the context the event occurred in
 */

/**
 * @typedef {Object} MetaMetricsPagePayload
 * @property {string} name - The name of the page that was viewed
 * @property {Object} [params] - The variadic parts of the page url
 *  example (route: `/asset/:asset`, path: `/asset/ETH`)
 *  params: { asset: 'ETH' }
 * @property {EnvironmentType} environmentType - the environment type that the
 *  page was viewed in
 * @property {MetaMetricsPageObject} [page] - the details of the page
 * @property {MetaMetricsReferrerObject} [referrer] - dapp that triggered the page
 *  view
 */

/**
 * @typedef {Object} MetaMetricsPageOptions
 * @property {boolean} [isOptInPath] - is the current path one of the pages in
 *  the onboarding workflow? If true and participateInMetaMetrics is null track
 *  the page view
 */
// Mixpanel converts the zero address value to a truly anonymous event, which
// speeds up reporting
const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';
/**
 * This object is used to identify events that are triggered by the background
 * process.
 *
 * @type {MetaMetricsPageObject}
 */

exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
/**
 * @typedef {Object} SegmentInterface
 * @property {SegmentEventPayload[]} queue - A queue of events to be sent when
 *  the flushAt limit has been reached, or flushInterval occurs
 * @property {() => void} flush - Immediately flush the queue, resetting it to
 *  an empty array and sending the pending events to Segment
 * @property {(
 *  payload: SegmentEventPayload,
 *  callback: (err?: Error) => void
 * ) => void} track - Track an event with Segment, using the internal batching
 *  mechanism to optimize network requests
 * @property {(payload: Object) => void} page - Track a page view with Segment
 * @property {() => void} identify - Identify an anonymous user. We do not
 *  currently use this method.
 */

exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTFICIATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTFICIATION_CLOSE = REJECT_NOTFICIATION_CLOSE;
const REJECT_NOTFICIATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
exports.REJECT_NOTFICIATION_CLOSE_SIG = REJECT_NOTFICIATION_CLOSE_SIG;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\metametrics.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\first-time-state.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\first-time-state.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @typedef {Object} FirstTimeState
 * @property {Object} config Initial configuration parameters
 * @property {Object} NetworkController Network controller state
 */

/**
 * @type {FirstTimeState}
 */
const initialState = {
  config: {},
  PreferencesController: {
    frequentRpcListDetail: [{
      rpcUrl: 'http://localhost:8545',
      chainId: '0x539',
      ticker: 'ETH',
      nickname: 'Localhost 8545',
      rpcPrefs: {}
    }]
  }
};
var _default = initialState;
exports.default = _default;


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\first-time-state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\getObjStructure.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\getObjStructure.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getObjStructure;

var _lodash = require("lodash");

// This will create an object that represents the structure of the given object
// it replaces all values with the result of their type
// {
//   "data": {
//     "CurrencyController": {
//       "conversionDate": "number",
//       "conversionRate": "number",
//       "currentCurrency": "string"
//     }
// }

/**
 * Creates an object that represents the structure of the given object. It replaces all values with the result of their
 * type.
 *
 * @param {Object} obj - The object for which a 'structure' will be returned. Usually a plain object and not a class.
 * @returns {Object} The "mapped" version of a deep clone of the passed object, with each non-object property value
 * replaced with the javascript type of that value.
 */
function getObjStructure(obj) {
  const structure = (0, _lodash.cloneDeep)(obj);
  return deepMap(structure, value => {
    return value === null ? 'null' : typeof value;
  });
}
/**
 * Modifies all the properties and deeply nested of a passed object. Iterates recursively over all nested objects and
 * their properties, and covers the entire depth of the object. At each property value which is not an object is modified.
 *
 * @param {Object} target - The object to modify
 * @param {Function} visit - The modifier to apply to each non-object property value
 * @returns {Object} The modified object
 */


function deepMap(target = {}, visit) {
  Object.entries(target).forEach(([key, value]) => {
    if (typeof value === 'object' && value !== null) {
      target[key] = deepMap(value, visit);
    } else {
      target[key] = visit(value);
    }
  });
  return target;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\getObjStructure.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce-stream\\index.js", {"debounce":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce\\index.js","duplexer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\duplexer\\index.js","through":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\through\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\debounce-stream\index.js
      return function (require, module, exports) {
var through = require('through')
  , duplexer = require('duplexer')
  , debounce = require('debounce')

module.exports = debounceStream

function debounceStream(_ms, immediate) {
  var ms = _ms || 100
    , input = through(debounce(write, ms, immediate))
    , output = through()

  return duplexer(input, output)

  function write(data) {
    output.queue(data)
  }
}

      };
    };
  }
}, {package:"debounce-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce-stream\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\network-store.js", {"../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../shared/modules/fetch-with-timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\fetch-with-timeout.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\network-store.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _time = require("../../../shared/constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
const FIXTURE_SERVER_HOST = 'localhost';
const FIXTURE_SERVER_PORT = 12345;
const FIXTURE_SERVER_URL = `http://${FIXTURE_SERVER_HOST}:${FIXTURE_SERVER_PORT}/state.json`;
/**
 * A read-only network-based storage wrapper
 */

class ReadOnlyNetworkStore {
  constructor() {
    (0, _defineProperty2.default)(this, "isSupported", true);
    this._initialized = false;
    this._initializing = this._init();
    this._state = undefined;
  }
  /**
   * Declares this store as compatible with the current browser
   */


  /**
   * Initializes by loading state from the network
   */
  async _init() {
    try {
      const response = await fetchWithTimeout(FIXTURE_SERVER_URL);

      if (response.ok) {
        this._state = await response.json();
      }
    } catch (error) {
      _loglevel.default.debug(`Error loading network state: '${error.message}'`);
    } finally {
      this._initialized = true;
    }
  }
  /**
   * Returns state
   *
   * @returns {Promise<object>}
   */


  async get() {
    if (!this._initialized) {
      await this._initializing;
    }

    return this._state;
  }
  /**
   * Set state
   *
   * @param {Object} state - The state to set
   * @returns {Promise<void>}
   */


  async set(state) {
    if (!this._initialized) {
      await this._initializing;
    }

    this._state = state;
  }

}

exports.default = ReadOnlyNetworkStore;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\network-store.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\notification-manager.js", {"../platforms/extension":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\platforms\\extension.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\notification-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NOTIFICATION_MANAGER_EVENTS = void 0;

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _extension = _interopRequireDefault(require("../platforms/extension"));

const NOTIFICATION_HEIGHT = 620;
const NOTIFICATION_WIDTH = 360;
const NOTIFICATION_MANAGER_EVENTS = {
  POPUP_CLOSED: 'onPopupClosed'
};
/**
 * A collection of methods for controlling the showing and hiding of the notification popup.
 */

exports.NOTIFICATION_MANAGER_EVENTS = NOTIFICATION_MANAGER_EVENTS;

class NotificationManager extends _safeEventEmitter.default {
  constructor() {
    super();
    this.platform = new _extension.default();
    this.platform.addOnRemovedListener(this._onWindowClosed.bind(this));
  }
  /**
   * Mark the notification popup as having been automatically closed.
   *
   * This lets us differentiate between the cases where we close the
   * notification popup v.s. when the user closes the popup window directly.
   */


  markAsAutomaticallyClosed() {
    this._popupAutomaticallyClosed = true;
  }
  /**
   * Either brings an existing MetaMask notification window into focus, or creates a new notification window. New
   * notification windows are given a 'popup' type.
   *
   */


  async showPopup() {
    const popup = await this._getPopup(); // Bring focus to chrome popup

    if (popup) {
      // bring focus to existing chrome popup
      await this.platform.focusWindow(popup.id);
    } else {
      let left = 0;
      let top = 0;

      try {
        const lastFocused = await this.platform.getLastFocusedWindow(); // Position window in top right corner of lastFocused window.

        top = lastFocused.top;
        left = lastFocused.left + (lastFocused.width - NOTIFICATION_WIDTH);
      } catch (_) {
        // The following properties are more than likely 0, due to being
        // opened from the background chrome process for the extension that
        // has no physical dimensions
        const {
          screenX,
          screenY,
          outerWidth
        } = window;
        top = Math.max(screenY, 0);
        left = Math.max(screenX + (outerWidth - NOTIFICATION_WIDTH), 0);
      } // create new notification popup


      const popupWindow = await this.platform.openWindow({
        url: 'notification.html',
        type: 'popup',
        width: NOTIFICATION_WIDTH,
        height: NOTIFICATION_HEIGHT,
        left,
        top
      }); // Firefox currently ignores left/top for create, but it works for update

      if (popupWindow.left !== left && popupWindow.state !== 'fullscreen') {
        await this.platform.updateWindowPosition(popupWindow.id, left, top);
      }

      this._popupId = popupWindow.id;
    }
  }

  _onWindowClosed(windowId) {
    if (windowId === this._popupId) {
      this._popupId = undefined;
      this.emit(NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED, {
        automaticallyClosed: this._popupAutomaticallyClosed
      });
      this._popupAutomaticallyClosed = undefined;
    }
  }
  /**
   * Checks all open MetaMask windows, and returns the first one it finds that is a notification window (i.e. has the
   * type 'popup')
   *
   * @private
   */


  async _getPopup() {
    const windows = await this.platform.getAllWindows();
    return this._getPopupIn(windows);
  }
  /**
   * Given an array of windows, returns the 'popup' that has been opened by MetaMask, or null if no such window exists.
   *
   * @private
   * @param {Array} windows - An array of objects containing data about the open MetaMask extension windows.
   */


  _getPopupIn(windows) {
    return windows ? windows.find(win => {
      // Returns notification popup
      return win && win.type === 'popup' && win.id === this._popupId;
    }) : null;
  }

}

exports.default = NotificationManager;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\notification-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createStreamSink.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createStreamSink.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createStreamSink;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _readableStream = require("readable-stream");

var _promiseToCallback = _interopRequireDefault(require("promise-to-callback"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class AsyncWritableStream extends _readableStream.Writable {
  constructor(asyncWriteFn, _opts) {
    const opts = _objectSpread({
      objectMode: true
    }, _opts);

    super(opts);
    this._asyncWriteFn = asyncWriteFn;
  } // write from incoming stream to state


  _write(chunk, encoding, callback) {
    (0, _promiseToCallback.default)(this._asyncWriteFn(chunk, encoding))(callback);
  }

}

function createStreamSink(asyncWriteFn, _opts) {
  return new AsyncWritableStream(asyncWriteFn, _opts);
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createStreamSink.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\local-store.js", {"./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","extensionizer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extensionizer\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\local-store.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _util = require("./util");

/**
 * A wrapper around the extension's storage local API
 */
class ExtensionStore {
  constructor() {
    this.isSupported = Boolean(_extensionizer.default.storage.local);

    if (!this.isSupported) {
      _loglevel.default.error('Storage local API not available.');
    }
  }
  /**
   * Returns all of the keys currently saved
   *
   * @returns {Promise<*>}
   */


  async get() {
    if (!this.isSupported) {
      return undefined;
    }

    const result = await this._get(); // extension.storage.local always returns an obj
    // if the object is empty, treat it as undefined

    if (isEmpty(result)) {
      return undefined;
    }

    return result;
  }
  /**
   * Sets the key in local state
   *
   * @param {Object} state - The state to set
   * @returns {Promise<void>}
   */


  async set(state) {
    return this._set(state);
  }
  /**
   * Returns all of the keys currently saved
   *
   * @private
   * @returns {Object} the key-value map from local storage
   */


  _get() {
    const {
      local
    } = _extensionizer.default.storage;
    return new Promise((resolve, reject) => {
      local.get(null, (
      /** @type {any} */
      result) => {
        const err = (0, _util.checkForError)();

        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  }
  /**
   * Sets the key in local state
   *
   * @param {Object} obj - The key to set
   * @returns {Promise<void>}
   * @private
   */


  _set(obj) {
    const {
      local
    } = _extensionizer.default.storage;
    return new Promise((resolve, reject) => {
      local.set(obj, () => {
        const err = (0, _util.checkForError)();

        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

}
/**
 * Returns whether or not the given object contains no keys
 *
 * @param {Object} obj - The object to check
 * @returns {boolean}
 */


exports.default = ExtensionStore;

function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\local-store.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\get-first-preferred-lang-code.js", {"../../_locales/index.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\_locales\\index.json","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","extensionizer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extensionizer\\index.js","pify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\get-first-preferred-lang-code.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFirstPreferredLangCode;

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _pify = _interopRequireDefault(require("pify"));

var _index = _interopRequireDefault(require("../../_locales/index.json"));

const getPreferredLocales = _extensionizer.default.i18n ? (0, _pify.default)(_extensionizer.default.i18n.getAcceptLanguages, {
  errorFirst: false
}) : async () => []; // mapping some browsers return hyphen instead underscore in locale codes (e.g. zh_TW -> zh-tw)

const existingLocaleCodes = {};

_index.default.forEach(locale => {
  if (locale && locale.code) {
    existingLocaleCodes[locale.code.toLowerCase().replace('_', '-')] = locale.code;
  }
});
/**
 * Returns a preferred language code, based on settings within the user's browser. If we have no translations for the
 * users preferred locales, 'en' is returned.
 *
 * @returns {Promise<string>} Promises a locale code, either one from the user's preferred list that we have a translation for, or 'en'
 */


async function getFirstPreferredLangCode() {
  let userPreferredLocaleCodes;

  try {
    userPreferredLocaleCodes = await getPreferredLocales();
  } catch (e) {
    // Brave currently throws when calling getAcceptLanguages, so this handles that.
    userPreferredLocaleCodes = [];
  } // safeguard for Brave Browser until they implement chrome.i18n.getAcceptLanguages
  // https://github.com/MetaMask/metamask-extension/issues/4270


  if (!userPreferredLocaleCodes) {
    userPreferredLocaleCodes = [];
  }

  let firstPreferredLangCode = userPreferredLocaleCodes.map(code => code.toLowerCase().replace('_', '-')).find(code => existingLocaleCodes[code] !== undefined || existingLocaleCodes[code.split('-')[0]] !== undefined); // if we have matched against a code with a '-' present, meaning its a regional
  // code for which we have a non-regioned locale, we need to set firstPreferredLangCode
  // to the correct non-regional code.

  if (firstPreferredLangCode !== undefined && existingLocaleCodes[firstPreferredLangCode] === undefined) {
    firstPreferredLangCode = firstPreferredLangCode.split('-')[0];
  }

  return existingLocaleCodes[firstPreferredLangCode] || 'en';
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\get-first-preferred-lang-code.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./LocalStorageStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\LocalStorageStore.js","./MergedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./LocalStorageStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\migrator\\index.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\migrator\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

/**
 * @typedef {Object} Migration
 * @property {number} version - The migration version
 * @property {Function} migrate - Returns a promise of the migrated data
 */

/**
 * @typedef {Object} MigratorOptions
 * @property {Array<Migration>} [migrations] - The list of migrations to apply
 * @property {number} [defaultVersion] - The version to use in the initial state
 */
class Migrator extends _events.default {
  /**
   * @param {MigratorOptions} opts
   */
  constructor(opts = {}) {
    super();
    const migrations = opts.migrations || []; // sort migrations by version

    this.migrations = migrations.sort((a, b) => a.version - b.version); // grab migration with highest version

    const lastMigration = this.migrations.slice(-1)[0]; // use specified defaultVersion or highest migration version

    this.defaultVersion = opts.defaultVersion || lastMigration && lastMigration.version || 0;
  } // run all pending migrations on meta in place


  async migrateData(versionedData = this.generateInitialState()) {
    // get all migrations that have not yet been run
    const pendingMigrations = this.migrations.filter(migrationIsPending); // perform each migration

    for (const migration of pendingMigrations) {
      try {
        // attempt migration and validate
        const migratedData = await migration.migrate(versionedData);

        if (!migratedData.data) {
          throw new Error('Migrator - migration returned empty data');
        }

        if (migratedData.version !== undefined && migratedData.meta.version !== migration.version) {
          throw new Error('Migrator - Migration did not update version number correctly');
        } // accept the migration as good
        // eslint-disable-next-line no-param-reassign


        versionedData = migratedData;
      } catch (err) {
        // rewrite error message to add context without clobbering stack
        const originalErrorMessage = err.message;
        err.message = `MetaMask Migration Error #${migration.version}: ${originalErrorMessage}`; // emit error instead of throw so as to not break the run (gracefully fail)

        this.emit('error', err); // stop migrating and use state as is

        return versionedData;
      }
    }

    return versionedData;
    /**
     * Returns whether or not the migration is pending
     *
     * A migration is considered "pending" if it has a higher
     * version number than the current version.
     *
     * @param {Migration} migration
     * @returns {boolean}
     */

    function migrationIsPending(migration) {
      return migration.version > versionedData.meta.version;
    }
  }
  /**
   * Returns the initial state for the migrator
   *
   * @param {Object} [data] - The data for the initial state
   * @returns {{meta: {version: number}, data: any}}
   */


  generateInitialState(data) {
    return {
      meta: {
        version: this.defaultVersion
      },
      data
    };
  }

}

exports.default = Migrator;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\migrator\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\index.js", {"./002":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\002.js","./003":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\003.js","./004":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\004.js","./005":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\005.js","./006":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\006.js","./007":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\007.js","./008":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\008.js","./009":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\009.js","./010":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\010.js","./011":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\011.js","./012":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\012.js","./013":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\013.js","./014":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\014.js","./015":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\015.js","./016":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\016.js","./017":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\017.js","./018":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\018.js","./019":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\019.js","./020":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\020.js","./021":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\021.js","./022":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\022.js","./023":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\023.js","./024":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\024.js","./025":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\025.js","./026":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\026.js","./027":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\027.js","./028":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\028.js","./029":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\029.js","./030":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\030.js","./031":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\031.js","./032":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\032.js","./033":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\033.js","./034":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\034.js","./035":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\035.js","./036":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\036.js","./037":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\037.js","./038":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\038.js","./039":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\039.js","./040":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\040.js","./041":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\041.js","./042":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\042.js","./043":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\043.js","./044":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\044.js","./045":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\045.js","./046":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\046.js","./047":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\047.js","./048":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\048.js","./049":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\049.js","./050":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\050.js","./051":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\051.js","./052":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\052.js","./053":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\053.js","./054":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\054.js","./055":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\055.js","./056":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\056.js","./057":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\057.js","./058":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\058.js","./059":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\059.js","./060":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\060.js","./061":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\061.js","./062":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\062.js","./063":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\063.js","./064":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\064.js","./065":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\065.js","./066":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\066.js","./067":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\067.js","./068":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\068.js","./069":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\069.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ = _interopRequireDefault(require("./002"));

var _2 = _interopRequireDefault(require("./003"));

var _3 = _interopRequireDefault(require("./004"));

var _4 = _interopRequireDefault(require("./005"));

var _5 = _interopRequireDefault(require("./006"));

var _6 = _interopRequireDefault(require("./007"));

var _7 = _interopRequireDefault(require("./008"));

var _8 = _interopRequireDefault(require("./009"));

var _9 = _interopRequireDefault(require("./010"));

var _10 = _interopRequireDefault(require("./011"));

var _11 = _interopRequireDefault(require("./012"));

var _12 = _interopRequireDefault(require("./013"));

var _13 = _interopRequireDefault(require("./014"));

var _14 = _interopRequireDefault(require("./015"));

var _15 = _interopRequireDefault(require("./016"));

var _16 = _interopRequireDefault(require("./017"));

var _17 = _interopRequireDefault(require("./018"));

var _18 = _interopRequireDefault(require("./019"));

var _19 = _interopRequireDefault(require("./020"));

var _20 = _interopRequireDefault(require("./021"));

var _21 = _interopRequireDefault(require("./022"));

var _22 = _interopRequireDefault(require("./023"));

var _23 = _interopRequireDefault(require("./024"));

var _24 = _interopRequireDefault(require("./025"));

var _25 = _interopRequireDefault(require("./026"));

var _26 = _interopRequireDefault(require("./027"));

var _27 = _interopRequireDefault(require("./028"));

var _28 = _interopRequireDefault(require("./029"));

var _29 = _interopRequireDefault(require("./030"));

var _30 = _interopRequireDefault(require("./031"));

var _31 = _interopRequireDefault(require("./032"));

var _32 = _interopRequireDefault(require("./033"));

var _33 = _interopRequireDefault(require("./034"));

var _34 = _interopRequireDefault(require("./035"));

var _35 = _interopRequireDefault(require("./036"));

var _36 = _interopRequireDefault(require("./037"));

var _37 = _interopRequireDefault(require("./038"));

var _38 = _interopRequireDefault(require("./039"));

var _39 = _interopRequireDefault(require("./040"));

var _40 = _interopRequireDefault(require("./041"));

var _41 = _interopRequireDefault(require("./042"));

var _42 = _interopRequireDefault(require("./043"));

var _43 = _interopRequireDefault(require("./044"));

var _44 = _interopRequireDefault(require("./045"));

var _45 = _interopRequireDefault(require("./046"));

var _46 = _interopRequireDefault(require("./047"));

var _47 = _interopRequireDefault(require("./048"));

var _48 = _interopRequireDefault(require("./049"));

var _49 = _interopRequireDefault(require("./050"));

var _50 = _interopRequireDefault(require("./051"));

var _51 = _interopRequireDefault(require("./052"));

var _52 = _interopRequireDefault(require("./053"));

var _53 = _interopRequireDefault(require("./054"));

var _54 = _interopRequireDefault(require("./055"));

var _55 = _interopRequireDefault(require("./056"));

var _56 = _interopRequireDefault(require("./057"));

var _57 = _interopRequireDefault(require("./058"));

var _58 = _interopRequireDefault(require("./059"));

var _59 = _interopRequireDefault(require("./060"));

var _60 = _interopRequireDefault(require("./061"));

var _61 = _interopRequireDefault(require("./062"));

var _62 = _interopRequireDefault(require("./063"));

var _63 = _interopRequireDefault(require("./064"));

var _64 = _interopRequireDefault(require("./065"));

var _65 = _interopRequireDefault(require("./066"));

var _66 = _interopRequireDefault(require("./067"));

var _67 = _interopRequireDefault(require("./068"));

var _68 = _interopRequireDefault(require("./069"));

// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.
const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default];
var _default = migrations;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\setup.js", {"../../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../../shared/modules/fetch-with-timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\fetch-with-timeout.js","./resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\resolver.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","base32-encode":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base32-encode\\index.js","base64-js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64-js\\index.js","extensionizer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extensionizer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\ens-ipfs\setup.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupEnsIpfsResolver;

var _base32Encode = _interopRequireDefault(require("base32-encode"));

var _base64Js = _interopRequireDefault(require("base64-js"));

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _time = require("../../../../shared/constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../../../../shared/modules/fetch-with-timeout"));

var _resolver = _interopRequireDefault(require("./resolver"));

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
const supportedTopLevelDomains = ['eth'];

function setupEnsIpfsResolver({
  provider,
  getCurrentChainId,
  getIpfsGateway
}) {
  // install listener
  const urlPatterns = supportedTopLevelDomains.map(tld => `*://*.${tld}/*`);

  _extensionizer.default.webRequest.onErrorOccurred.addListener(webRequestDidFail, {
    urls: urlPatterns,
    types: ['main_frame']
  }); // return api object


  return {
    // uninstall listener
    remove() {
      _extensionizer.default.webRequest.onErrorOccurred.removeListener(webRequestDidFail);
    }

  };

  async function webRequestDidFail(details) {
    const {
      tabId,
      url
    } = details; // ignore requests that are not associated with tabs
    // only attempt ENS resolution on mainnet

    if (tabId === -1 || getCurrentChainId() !== '0x1') {
      return;
    } // parse ens name


    const {
      hostname: name,
      pathname,
      search,
      hash: fragment
    } = new URL(url);
    const domainParts = name.split('.');
    const topLevelDomain = domainParts[domainParts.length - 1]; // if unsupported TLD, abort

    if (!supportedTopLevelDomains.includes(topLevelDomain)) {
      return;
    } // otherwise attempt resolve


    attemptResolve({
      tabId,
      name,
      pathname,
      search,
      fragment
    });
  }

  async function attemptResolve({
    tabId,
    name,
    pathname,
    search,
    fragment
  }) {
    const ipfsGateway = getIpfsGateway();

    _extensionizer.default.tabs.update(tabId, {
      url: `loading.html`
    });

    let url = `https://app.ens.domains/name/${name}`;

    try {
      const {
        type,
        hash
      } = await (0, _resolver.default)({
        provider,
        name
      });

      if (type === 'ipfs-ns' || type === 'ipns-ns') {
        const resolvedUrl = `https://${hash}.${type.slice(0, 4)}.${ipfsGateway}${pathname}${search || ''}${fragment || ''}`;

        try {
          // check if ipfs gateway has result
          const response = await fetchWithTimeout(resolvedUrl, {
            method: 'HEAD'
          });

          if (response.status === 200) {
            url = resolvedUrl;
          }
        } catch (err) {
          console.warn(err);
        }
      } else if (type === 'swarm-ns') {
        url = `https://swarm-gateways.net/bzz:/${hash}${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'onion' || type === 'onion3') {
        url = `http://${hash}.onion${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'zeronet') {
        url = `http://127.0.0.1:43110/${hash}${pathname}${search || ''}${fragment || ''}`;
      } else if (type === 'skynet-ns') {
        const padded = hash.padEnd(hash.length + 4 - hash.length % 4, '=');

        const decoded = _base64Js.default.toByteArray(padded);

        const options = {
          padding: false
        };
        const base32EncodedSkylink = (0, _base32Encode.default)(decoded, 'RFC4648-HEX', options).toLowerCase();
        url = `https://${base32EncodedSkylink}.siasky.net${pathname}${search || ''}${fragment || ''}`;
      }
    } catch (err) {
      console.warn(err);
    } finally {
      _extensionizer.default.tabs.update(tabId, {
        url
      });
    }
  }
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\setup.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js", {"../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../shared/constants/hardware-wallets":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\hardware-wallets.js","../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","../../shared/constants/swaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\swaps.js","../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","../../shared/notifications":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\notifications\\index.js","../../ui/helpers/utils/conversions.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\conversions.util.js","../../ui/helpers/utils/token-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\token-util.js","../../ui/helpers/utils/transactions.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\transactions.util.js","../../ui/helpers/utils/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\util.js","./account-import-strategies":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\account-import-strategies\\index.js","./controllers/alert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\alert.js","./controllers/app-state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\app-state.js","./controllers/cached-balances":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\cached-balances.js","./controllers/detect-tokens":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\detect-tokens.js","./controllers/ens":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\index.js","./controllers/incoming-transactions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\incoming-transactions.js","./controllers/metametrics":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\metametrics.js","./controllers/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\index.js","./controllers/onboarding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\onboarding.js","./controllers/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\index.js","./controllers/preferences":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\preferences.js","./controllers/swaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\swaps.js","./controllers/threebox":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\threebox.js","./controllers/transactions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\index.js","./lib/ComposableObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ComposableObservableStore.js","./lib/account-tracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\account-tracker.js","./lib/createLoggerMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createLoggerMiddleware.js","./lib/createMetaRPCHandler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createMetaRPCHandler.js","./lib/createOnboardingMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOnboardingMiddleware.js","./lib/createOriginMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOriginMiddleware.js","./lib/createTabIdMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createTabIdMiddleware.js","./lib/decrypt-message-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\decrypt-message-manager.js","./lib/encryption-public-key-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\encryption-public-key-manager.js","./lib/message-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\message-manager.js","./lib/personal-message-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\personal-message-manager.js","./lib/rpc-method-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\index.js","./lib/seed-phrase-verifier":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\seed-phrase-verifier.js","./lib/segment":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\segment.js","./lib/stream-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\stream-utils.js","./lib/typed-message-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\typed-message-manager.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@keystonehq/metamask-airgapped-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js","@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","@metamask/eth-ledger-bridge-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/obs-store/dist/asStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","@metamask/smart-transactions-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","@sentry/browser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\index.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","await-semaphore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\await-semaphore\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-json-rpc-filters":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\index.js","eth-json-rpc-filters/subscriptionManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","eth-keyring-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-keyring-controller\\index.js","eth-lattice-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\index.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-trezor-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","json-rpc-middleware-stream/engineStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-middleware-stream\\engineStream.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\index.browser.js","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\metamask-controller.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METAMASK_CONTROLLER_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _pump = _interopRequireDefault(require("pump"));

var _obsStore = require("@metamask/obs-store");

var _asStream = require("@metamask/obs-store/dist/asStream");

var _jsonRpcEngine = require("json-rpc-engine");

var _lodash = require("lodash");

var _engineStream = _interopRequireDefault(require("json-rpc-middleware-stream/engineStream"));

var _ethJsonRpcFilters = _interopRequireDefault(require("eth-json-rpc-filters"));

var _subscriptionManager = _interopRequireDefault(require("eth-json-rpc-filters/subscriptionManager"));

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethKeyringController = _interopRequireDefault(require("eth-keyring-controller"));

var _ethRpcErrors = require("eth-rpc-errors");

var _awaitSemaphore = require("await-semaphore");

var _ethereumjsUtil = require("ethereumjs-util");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethTrezorKeyring = _interopRequireDefault(require("eth-trezor-keyring"));

var _ethLedgerBridgeKeyring = _interopRequireDefault(require("@metamask/eth-ledger-bridge-keyring"));

var _ethLatticeKeyring = _interopRequireDefault(require("eth-lattice-keyring"));

var _metamaskAirgappedKeyring = require("@keystonehq/metamask-airgapped-keyring");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _nanoid = _interopRequireDefault(require("nanoid"));

var _browser = require("@sentry/browser");

var _controllers = require("@metamask/controllers");

var _smartTransactionsController = _interopRequireDefault(require("@metamask/smart-transactions-controller"));

var _snapControllers = require("@metamask/snap-controllers");

var _transaction = require("../../shared/constants/transaction");

var _swaps = require("../../shared/constants/swaps");

var _network = require("../../shared/constants/network");

var _hardwareWallets = require("../../shared/constants/hardware-wallets");

var _permissions = require("../../shared/constants/permissions");

var _notifications = require("../../shared/notifications");

var _hexstringUtils = require("../../shared/modules/hexstring-utils");

var _time = require("../../shared/constants/time");

var _app = require("../../shared/constants/app");

var _conversions = require("../../ui/helpers/utils/conversions.util");

var _tokenUtil = require("../../ui/helpers/utils/token-util");

var _transactions = require("../../ui/helpers/utils/transactions.util");

var _util = require("../../ui/helpers/utils/util");

var _ComposableObservableStore = _interopRequireDefault(require("./lib/ComposableObservableStore"));

var _accountTracker = _interopRequireDefault(require("./lib/account-tracker"));

var _createLoggerMiddleware = _interopRequireDefault(require("./lib/createLoggerMiddleware"));

var _rpcMethodMiddleware = require("./lib/rpc-method-middleware");

var _createOriginMiddleware = _interopRequireDefault(require("./lib/createOriginMiddleware"));

var _createTabIdMiddleware = _interopRequireDefault(require("./lib/createTabIdMiddleware"));

var _createOnboardingMiddleware = _interopRequireDefault(require("./lib/createOnboardingMiddleware"));

var _streamUtils = require("./lib/stream-utils");

var _ens = _interopRequireDefault(require("./controllers/ens"));

var _network2 = _interopRequireWildcard(require("./controllers/network"));

var _preferences = _interopRequireDefault(require("./controllers/preferences"));

var _appState = _interopRequireDefault(require("./controllers/app-state"));

var _cachedBalances = _interopRequireDefault(require("./controllers/cached-balances"));

var _alert = _interopRequireDefault(require("./controllers/alert"));

var _onboarding = _interopRequireDefault(require("./controllers/onboarding"));

var _threebox = _interopRequireDefault(require("./controllers/threebox"));

var _incomingTransactions = _interopRequireDefault(require("./controllers/incoming-transactions"));

var _messageManager = _interopRequireWildcard(require("./lib/message-manager"));

var _decryptMessageManager = _interopRequireDefault(require("./lib/decrypt-message-manager"));

var _encryptionPublicKeyManager = _interopRequireDefault(require("./lib/encryption-public-key-manager"));

var _personalMessageManager = _interopRequireDefault(require("./lib/personal-message-manager"));

var _typedMessageManager = _interopRequireDefault(require("./lib/typed-message-manager"));

var _transactions2 = _interopRequireDefault(require("./controllers/transactions"));

var _detectTokens = _interopRequireDefault(require("./controllers/detect-tokens"));

var _swaps2 = _interopRequireDefault(require("./controllers/swaps"));

var _accountImportStrategies = _interopRequireDefault(require("./account-import-strategies"));

var _seedPhraseVerifier = _interopRequireDefault(require("./lib/seed-phrase-verifier"));

var _metametrics = _interopRequireDefault(require("./controllers/metametrics"));

var _segment = require("./lib/segment");

var _createMetaRPCHandler = _interopRequireDefault(require("./lib/createMetaRPCHandler"));

var _permissions2 = require("./controllers/permissions");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const METAMASK_CONTROLLER_EVENTS = {
  // Fired after state changes that impact the extension badge (unapproved msg count)
  // The process of updating the badge happens in app/scripts/background.js.
  UPDATE_BADGE: 'updateBadge',
  // TODO: Add this and similar enums to @metamask/controllers and export them
  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange'
};
exports.METAMASK_CONTROLLER_EVENTS = METAMASK_CONTROLLER_EVENTS;

class MetamaskController extends _events.default {
  /**
   * @param {Object} opts
   */
  constructor(opts) {
    var _process$env$CONF;

    super();
    this.defaultMaxListeners = 20;
    this.sendUpdate = (0, _lodash.debounce)(this.privateSendUpdate.bind(this), _time.MILLISECOND * 200);
    this.opts = opts;
    this.extension = opts.extension;
    this.platform = opts.platform;
    this.notificationManager = opts.notificationManager;
    const initState = opts.initState || {};
    const version = this.platform.getVersion();
    this.recordFirstTimeInfo(initState); // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances

    this.activeControllerConnections = 0;
    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;
    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;
    this.controllerMessenger = new _controllers.ControllerMessenger(); // observable state store

    this.store = new _ComposableObservableStore.default({
      state: initState,
      controllerMessenger: this.controllerMessenger,
      persist: true
    }); // external connections by origin
    // Do not modify directly. Use the associated methods.

    this.connections = {}; // lock to ensure only one vault created at once

    this.createVaultMutex = new _awaitSemaphore.Mutex();
    this.extension.runtime.onInstalled.addListener(details => {
      if (details.reason === 'update' && version === '8.1.0') {
        this.platform.openExtensionInBrowser();
      }
    }); // next, we will initialize the controllers
    // controller initialization order matters

    this.approvalController = new _controllers.ApprovalController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'ApprovalController'
      }),
      showApprovalRequest: opts.showUserConfirmation
    });
    this.networkController = new _network2.default(initState.NetworkController);
    this.networkController.setInfuraProjectId(opts.infuraProjectId); // now we can initialize the RPC provider, which other controllers require

    this.initializeProvider();
    this.provider = this.networkController.getProviderAndBlockTracker().provider;
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;
    this.preferencesController = new _preferences.default({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      openPopup: opts.openPopup,
      network: this.networkController,
      provider: this.provider,
      migrateAddressBookState: this.migrateAddressBookState.bind(this)
    });
    this.tokensController = new _controllers.TokensController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      config: {
        provider: this.provider
      },
      state: initState.TokensController
    });
    this.assetsContractController = new _controllers.AssetsContractController({
      provider: this.provider
    });
    this.collectiblesController = new _controllers.CollectiblesController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getERC721AssetName: this.assetsContractController.getERC721AssetName.bind(this.assetsContractController),
      getERC721AssetSymbol: this.assetsContractController.getERC721AssetSymbol.bind(this.assetsContractController),
      getERC721TokenURI: this.assetsContractController.getERC721TokenURI.bind(this.assetsContractController),
      getERC721OwnerOf: this.assetsContractController.getERC721OwnerOf.bind(this.assetsContractController),
      getERC1155BalanceOf: this.assetsContractController.getERC1155BalanceOf.bind(this.assetsContractController),
      getERC1155TokenURI: this.assetsContractController.getERC1155TokenURI.bind(this.assetsContractController)
    }, {}, initState.CollectiblesController);
    this.collectiblesController.setApiKey(process.env.OPENSEA_KEY);
    false && (this.collectibleDetectionController = new _controllers.CollectibleDetectionController({
      onCollectiblesStateChange: listener => this.collectiblesController.subscribe(listener),
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getOpenSeaApiKey: () => this.collectiblesController.openSeaApiKey,
      getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(this.assetsContractController),
      addCollectible: this.collectiblesController.addCollectible.bind(this.collectiblesController),
      getCollectiblesState: () => this.collectiblesController.state
    }));
    this.metaMetricsController = new _metametrics.default({
      segment: _segment.segment,
      preferencesStore: this.preferencesController.store,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getNetworkIdentifier: this.networkController.getNetworkIdentifier.bind(this.networkController),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      version: this.platform.getVersion(),
      environment: "development",
      initState: initState.MetaMetricsController,
      captureException: _browser.captureException
    });
    const gasFeeMessenger = this.controllerMessenger.getRestricted({
      name: 'GasFeeController'
    });
    const gasApiBaseUrl = false ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
    this.gasFeeController = new _controllers.GasFeeController({
      interval: 10000,
      messenger: gasFeeMessenger,
      clientId: _swaps.SWAPS_CLIENT_ID,
      getProvider: () => this.networkController.getProviderAndBlockTracker().provider,
      onNetworkStateChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,
      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,
      getCurrentNetworkLegacyGasAPICompatibility: () => {
        const chainId = this.networkController.getCurrentChainId();
        return process.env.IN_TEST || chainId === _network.MAINNET_CHAIN_ID;
      },
      getChainId: () => {
        return process.env.IN_TEST ? _network.MAINNET_CHAIN_ID : this.networkController.getCurrentChainId();
      }
    });
    this.qrHardwareKeyring = new _metamaskAirgappedKeyring.MetaMaskKeyring();
    this.appStateController = new _appState.default({
      addUnlockListener: this.on.bind(this, 'unlock'),
      isUnlocked: this.isUnlocked.bind(this),
      initState: initState.AppStateController,
      onInactiveTimeout: () => this.setLocked(),
      showUnlockRequest: opts.showUserConfirmation,
      preferencesStore: this.preferencesController.store,
      qrHardwareStore: this.qrHardwareKeyring.getMemStore()
    });
    const currencyRateMessenger = this.controllerMessenger.getRestricted({
      name: 'CurrencyRateController'
    });
    this.currencyRateController = new _controllers.CurrencyRateController({
      includeUSDRate: true,
      messenger: currencyRateMessenger,
      state: initState.CurrencyController
    });
    const tokenListMessenger = this.controllerMessenger.getRestricted({
      name: 'TokenListController'
    });
    this.tokenListController = new _controllers.TokenListController({
      chainId: (0, _conversions.hexToDecimal)(this.networkController.getCurrentChainId()),
      useStaticTokenList: !this.preferencesController.store.getState().useTokenDetection,
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = _objectSpread(_objectSpread({}, networkState), {}, {
          provider: _objectSpread(_objectSpread({}, networkState.provider), {}, {
            chainId: (0, _conversions.hexToDecimal)(networkState.provider.chainId)
          })
        });

        return cb(modifiedNetworkState);
      }),
      onPreferencesStateChange: cb => this.preferencesController.store.subscribe(preferencesState => {
        const modifiedPreferencesState = _objectSpread(_objectSpread({}, preferencesState), {}, {
          useStaticTokenList: !this.preferencesController.store.getState().useTokenDetection
        });

        return cb(modifiedPreferencesState);
      }),
      messenger: tokenListMessenger,
      state: initState.TokenListController
    });
    this.phishingController = new _controllers.PhishingController();
    this.notificationController = new _controllers.NotificationController({
      allNotifications: _notifications.UI_NOTIFICATIONS
    }, initState.NotificationController); // token exchange rate tracker

    this.tokenRatesController = new _controllers.TokenRatesController({
      onTokensStateChange: listener => this.tokensController.subscribe(listener),
      onCurrencyRateStateChange: listener => this.controllerMessenger.subscribe(`${this.currencyRateController.name}:stateChange`, listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = _objectSpread(_objectSpread({}, networkState), {}, {
          provider: _objectSpread(_objectSpread({}, networkState.provider), {}, {
            chainId: (0, _conversions.hexToDecimal)(networkState.provider.chainId)
          })
        });

        return cb(modifiedNetworkState);
      })
    });
    this.ensController = new _ens.default({
      provider: this.provider,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE)
    });
    this.incomingTransactionsController = new _incomingTransactions.default({
      blockTracker: this.blockTracker,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesController: this.preferencesController,
      initState: initState.IncomingTransactionsController
    }); // account tracker watches balances, nonces, and any code at their address

    this.accountTracker = new _accountTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController)
    }); // start and stop polling for balances based on activeControllerConnections

    this.on('controllerConnectionChanged', activeControllerConnections => {
      if (activeControllerConnections > 0) {
        this.accountTracker.start();
        this.incomingTransactionsController.start();
        this.currencyRateController.start();
        this.tokenListController.start();
      } else {
        this.accountTracker.stop();
        this.incomingTransactionsController.stop();
        this.currencyRateController.stop();
        this.tokenListController.stop();
      }
    });
    this.cachedBalancesController = new _cachedBalances.default({
      accountTracker: this.accountTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      initState: initState.CachedBalancesController
    });
    this.onboardingController = new _onboarding.default({
      initState: initState.OnboardingController
    });
    this.tokensController.hub.on('pendingSuggestedAsset', async () => {
      await opts.openPopup();
    });
    const additionalKeyrings = [_ethTrezorKeyring.default, _ethLedgerBridgeKeyring.default, _ethLatticeKeyring.default, _metamaskAirgappedKeyring.MetaMaskKeyring];
    this.keyringController = new _ethKeyringController.default({
      keyringTypes: additionalKeyrings,
      initState: initState.KeyringController,
      encryptor: opts.encryptor || undefined
    });
    this.keyringController.memStore.subscribe(state => this._onKeyringControllerUpdate(state));
    this.keyringController.on('unlock', () => this._onUnlock());
    this.keyringController.on('lock', () => this._onLock());

    const getIdentities = () => this.preferencesController.store.getState().identities;

    this.permissionController = new _snapControllers.PermissionController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'PermissionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:hasRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      state: initState.PermissionController,
      caveatSpecifications: (0, _permissions2.getCaveatSpecifications)({
        getIdentities
      }),
      permissionSpecifications: _objectSpread({}, (0, _permissions2.getPermissionSpecifications)({
        getIdentities,
        getAllAccounts: this.keyringController.getAccounts.bind(this.keyringController),
        captureKeyringTypesWithMissingIdentities: (identities = {}, accounts = []) => {
          const accountsMissingIdentities = accounts.filter(address => !identities[address]);
          const keyringTypesWithMissingIdentities = accountsMissingIdentities.map(address => {
            var _this$keyringControll;

            return (_this$keyringControll = this.keyringController.getKeyringForAccount(address)) === null || _this$keyringControll === void 0 ? void 0 : _this$keyringControll.type;
          });
          const identitiesCount = Object.keys(identities || {}).length;
          const accountTrackerCount = Object.keys(this.accountTracker.store.getState().accounts || {}).length;
          (0, _browser.captureException)(new Error(`Attempt to get permission specifications failed because their were ${accounts.length} accounts, but ${identitiesCount} identities, and the ${keyringTypesWithMissingIdentities} keyrings included accounts with missing identities. Meanwhile, there are ${accountTrackerCount} accounts in the account tracker.`));
        }
      })),
      unrestrictedMethods: _permissions2.unrestrictedMethods
    });
    this.permissionLogController = new _permissions2.PermissionLogController({
      restrictedMethods: new Set(Object.keys(_permissions.RestrictedMethods)),
      initState: initState.PermissionLogController
    });
    this.subjectMetadataController = new _snapControllers.SubjectMetadataController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SubjectMetadataController',
        allowedActions: [`${this.permissionController.name}:hasPermissions`]
      }),
      state: initState.SubjectMetadataController,
      subjectCacheLimit: 100
    });
    this.detectTokensController = new _detectTokens.default({
      preferences: this.preferencesController,
      tokensController: this.tokensController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
      tokenList: this.tokenListController
    });
    this.addressBookController = new _controllers.AddressBookController(undefined, initState.AddressBookController);
    this.alertController = new _alert.default({
      initState: initState.AlertController,
      preferencesStore: this.preferencesController.store
    });
    this.threeBoxController = new _threebox.default({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      keyringController: this.keyringController,
      initState: initState.ThreeBoxController,
      getKeyringControllerState: this.keyringController.memStore.getState.bind(this.keyringController.memStore),
      version,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.txController = new _transactions2.default({
      initState: initState.TransactionController || initState.TransactionManager,
      getPermittedAccounts: this.getPermittedAccounts.bind(this),
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      networkStore: this.networkController.networkStore,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 60,
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      createEventFragment: this.metaMetricsController.createEventFragment.bind(this.metaMetricsController),
      updateEventFragment: this.metaMetricsController.updateEventFragment.bind(this.metaMetricsController),
      finalizeEventFragment: this.metaMetricsController.finalizeEventFragment.bind(this.metaMetricsController),
      getEventFragmentById: this.metaMetricsController.getEventFragmentById.bind(this.metaMetricsController),
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getParticipateInMetrics: () => this.metaMetricsController.state.participateInMetaMetrics,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController),
      getExternalPendingTransactions: this.getExternalPendingTransactions.bind(this)
    });
    this.txController.on('newUnapprovedTx', () => opts.showUserConfirmation());
    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === _transaction.TRANSACTION_STATUSES.CONFIRMED || status === _transaction.TRANSACTION_STATUSES.FAILED) {
        const txMeta = this.txController.txStateManager.getTransaction(txId);
        const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
        let rpcPrefs = {};

        if (txMeta.chainId) {
          var _rpcSettings$rpcPrefs;

          const rpcSettings = frequentRpcListDetail.find(rpc => txMeta.chainId === rpc.chainId);
          rpcPrefs = (_rpcSettings$rpcPrefs = rpcSettings === null || rpcSettings === void 0 ? void 0 : rpcSettings.rpcPrefs) !== null && _rpcSettings$rpcPrefs !== void 0 ? _rpcSettings$rpcPrefs : {};
        }

        this.platform.showTransactionNotification(txMeta, rpcPrefs);
        const {
          txReceipt
        } = txMeta; // if this is a transferFrom method generated from within the app it may be a collectible transfer transaction
        // in which case we will want to check and update ownership status of the transferred collectible.

        if (txMeta.type === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM && txMeta.txParams !== undefined) {
          var _allCollectibles$user;

          const {
            data,
            to: contractAddress,
            from: userAddress
          } = txMeta.txParams;
          const {
            chainId
          } = txMeta;
          const transactionData = (0, _transactions.getTransactionData)(data);
          const tokenAmountOrTokenId = (0, _tokenUtil.getTokenValueParam)(transactionData);
          const {
            allCollectibles
          } = this.collectiblesController.state; // check if its a known collectible

          const knownCollectible = allCollectibles === null || allCollectibles === void 0 ? void 0 : (_allCollectibles$user = allCollectibles[userAddress]) === null || _allCollectibles$user === void 0 ? void 0 : _allCollectibles$user[chainId].find(({
            address,
            tokenId
          }) => (0, _util.isEqualCaseInsensitive)(address, contractAddress) && tokenId === tokenAmountOrTokenId); // if it is we check and update ownership status.

          if (knownCollectible) {
            this.collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus(knownCollectible, false, {
              userAddress,
              chainId
            });
          }
        }

        const metamaskState = await this.getState();

        if (txReceipt && txReceipt.status === '0x0') {
          var _txMeta$simulationFai;

          this.metaMetricsController.trackEvent({
            event: 'Tx Status Update: On-Chain Failure',
            category: 'Background',
            properties: {
              action: 'Transactions',
              errorMessage: (_txMeta$simulationFai = txMeta.simulationFails) === null || _txMeta$simulationFai === void 0 ? void 0 : _txMeta$simulationFai.reason,
              numberOfTokens: metamaskState.tokens.length,
              numberOfAccounts: Object.keys(metamaskState.accounts).length
            }
          }, {
            matomoEvent: true
          });
        }
      }
    });
    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, async () => {
      const {
        ticker
      } = this.networkController.getProviderConfig();

      try {
        await this.currencyRateController.setNativeCurrency(ticker);
      } catch (error) {
        // TODO: Handle failure to get conversion rate more gracefully
        console.error(error);
      }
    });
    this.networkController.lookupNetwork();
    this.messageManager = new _messageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.personalMessageManager = new _personalMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.decryptMessageManager = new _decryptMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.encryptionPublicKeyManager = new _encryptionPublicKeyManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.typedMessageManager = new _typedMessageManager.default({
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.swapsController = new _swaps2.default({
      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(this.txController.txGasUtil),
      networkController: this.networkController,
      provider: this.provider,
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getTokenRatesState: () => this.tokenRatesController.state,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    });
    this.smartTransactionsController = new _smartTransactionsController.default({
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getNetwork: this.networkController.getNetworkState.bind(this.networkController),
      getNonceLock: this.txController.nonceTracker.getNonceLock.bind(this.txController.nonceTracker),
      confirmExternalTransaction: this.txController.confirmExternalTransaction.bind(this.txController),
      provider: this.provider,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    }, undefined, initState.SmartTransactionsController); // ensure accountTracker updates balances after network change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      this.accountTracker._updateAccounts();
    }); // clear unapproved transactions and messages when the network will change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_WILL_CHANGE, () => {
      this.txController.txStateManager.clearUnapprovedTxs();
      this.encryptionPublicKeyManager.clearUnapproved();
      this.personalMessageManager.clearUnapproved();
      this.typedMessageManager.clearUnapproved();
      this.decryptMessageManager.clearUnapproved();
      this.messageManager.clearUnapproved();
    }); // ensure isClientOpenAndUnlocked is updated when memState updates

    this.on('update', memState => this._onStateUpdate(memState));
    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      MetaMetricsController: this.metaMetricsController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      NetworkController: this.networkController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      AlertController: this.alertController.store,
      OnboardingController: this.onboardingController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      PermissionController: this.permissionController,
      PermissionLogController: this.permissionLogController.store,
      SubjectMetadataController: this.subjectMetadataController,
      ThreeBoxController: this.threeBoxController.store,
      NotificationController: this.notificationController,
      GasFeeController: this.gasFeeController,
      TokenListController: this.tokenListController,
      TokensController: this.tokensController,
      SmartTransactionsController: this.smartTransactionsController,
      CollectiblesController: this.collectiblesController
    });
    this.memStore = new _ComposableObservableStore.default({
      config: {
        AppStateController: this.appStateController.store,
        NetworkController: this.networkController.store,
        AccountTracker: this.accountTracker.store,
        TxController: this.txController.memStore,
        CachedBalancesController: this.cachedBalancesController.store,
        TokenRatesController: this.tokenRatesController,
        MessageManager: this.messageManager.memStore,
        PersonalMessageManager: this.personalMessageManager.memStore,
        DecryptMessageManager: this.decryptMessageManager.memStore,
        EncryptionPublicKeyManager: this.encryptionPublicKeyManager.memStore,
        TypesMessageManager: this.typedMessageManager.memStore,
        KeyringController: this.keyringController.memStore,
        PreferencesController: this.preferencesController.store,
        MetaMetricsController: this.metaMetricsController.store,
        AddressBookController: this.addressBookController,
        CurrencyController: this.currencyRateController,
        AlertController: this.alertController.store,
        OnboardingController: this.onboardingController.store,
        IncomingTransactionsController: this.incomingTransactionsController.store,
        PermissionController: this.permissionController,
        PermissionLogController: this.permissionLogController.store,
        SubjectMetadataController: this.subjectMetadataController,
        ThreeBoxController: this.threeBoxController.store,
        SwapsController: this.swapsController.store,
        EnsController: this.ensController.store,
        ApprovalController: this.approvalController,
        NotificationController: this.notificationController,
        GasFeeController: this.gasFeeController,
        TokenListController: this.tokenListController,
        TokensController: this.tokensController,
        SmartTransactionsController: this.smartTransactionsController,
        CollectiblesController: this.collectiblesController
      },
      controllerMessenger: this.controllerMessenger
    });
    this.memStore.subscribe(this.sendUpdate.bind(this));
    const password = (_process$env$CONF = {"SENTRY_DSN_DEV":"https://f59f3dd640d2429d9d0e2445a87ea8e1@sentry.io/273496","_":["scripts:core:dev:standardEntryPoints"],"build-type":"main","lint-fence-files":"false","skip-stats":true}) === null || _process$env$CONF === void 0 ? void 0 : _process$env$CONF.PASSWORD;

    if (password && !this.isUnlocked() && this.onboardingController.store.getState().completedOnboarding) {
      this.submitPassword(password);
    } // Lazily update the store with the current extension environment


    this.extension.runtime.getPlatformInfo(({
      os
    }) => {
      this.appStateController.setBrowserEnvironment(os, // This method is presently only supported by Firefox
      this.extension.runtime.getBrowserInfo === undefined ? 'chrome' : 'firefox');
    });
    this.setupControllerEventSubscriptions(); // TODO:LegacyProvider: Delete

    this.publicConfigStore = this.createPublicConfigStore();
  }
  /**
   * Sets up BaseController V2 event subscriptions. Currently, this includes
   * the subscriptions necessary to notify permission subjects of account
   * changes.
   *
   * Some of the subscriptions in this method are ControllerMessenger selector
   * event subscriptions. See the relevant @metamask/controllers documentation
   * for more information.
   *
   * Note that account-related notifications emitted when the extension
   * becomes unlocked are handled in MetaMaskController._onUnlock.
   */


  setupControllerEventSubscriptions() {
    const handleAccountsChange = async (origin, newAccounts) => {
      if (this.isUnlocked()) {
        this.notifyConnections(origin, {
          method: _permissions2.NOTIFICATION_NAMES.accountsChanged,
          // This should be the same as the return value of `eth_accounts`,
          // namely an array of the current / most recently selected Ethereum
          // account.
          params: newAccounts.length < 2 ? // If the length is 1 or 0, the accounts are sorted by definition.
          newAccounts : // If the length is 2 or greater, we have to execute
          // `eth_accounts` vi this method.
          await this.getPermittedAccounts(origin)
        });
      }

      this.permissionLogController.updateAccountsHistory(origin, newAccounts);
    }; // This handles account changes whenever the selected address changes.


    let lastSelectedAddress;
    this.preferencesController.store.subscribe(async ({
      selectedAddress
    }) => {
      if (selectedAddress && selectedAddress !== lastSelectedAddress) {
        lastSelectedAddress = selectedAddress;
        const permittedAccountsMap = (0, _permissions2.getPermittedAccountsByOrigin)(this.permissionController.state);

        for (const [origin, accounts] of permittedAccountsMap.entries()) {
          if (accounts.includes(selectedAddress)) {
            handleAccountsChange(origin, accounts);
          }
        }
      }
    }); // This handles account changes every time relevant permission state
    // changes, for any reason.

    this.controllerMessenger.subscribe(`${this.permissionController.name}:stateChange`, async (currentValue, previousValue) => {
      const changedAccounts = (0, _permissions2.getChangedAccounts)(currentValue, previousValue);

      for (const [origin, accounts] of changedAccounts.entries()) {
        handleAccountsChange(origin, accounts);
      }
    }, _permissions2.getPermittedAccountsByOrigin);
  }
  /**
   * Constructor helper: initialize a provider.
   */


  initializeProvider() {
    const version = this.platform.getVersion();
    const providerOpts = {
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`
      },
      version,
      // account mgmt
      getAccounts: async ({
        origin
      }) => {
        if (origin === 'metamask') {
          const selectedAddress = this.preferencesController.getSelectedAddress();
          return selectedAddress ? [selectedAddress] : [];
        } else if (this.isUnlocked()) {
          return await this.getPermittedAccounts(origin);
        }

        return []; // changing this is a breaking change
      },
      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.newUnsignedMessage.bind(this),
      processTypedMessage: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV3: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV4: this.newUnsignedTypedMessage.bind(this),
      processPersonalMessage: this.newUnsignedPersonalMessage.bind(this),
      processDecryptMessage: this.newRequestDecryptMessage.bind(this),
      processEncryptionPublicKey: this.newRequestEncryptionPublicKey.bind(this),
      getPendingNonce: this.getPendingNonce.bind(this),
      getPendingTransactionByHash: hash => this.txController.getTransactions({
        searchCriteria: {
          hash,
          status: _transaction.TRANSACTION_STATUSES.SUBMITTED
        }
      })[0]
    };
    const providerProxy = this.networkController.initializeProvider(providerOpts);
    return providerProxy;
  }
  /**
   * TODO:LegacyProvider: Delete
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */


  createPublicConfigStore() {
    // subset of state for metamask inpage provider
    const publicConfigStore = new _obsStore.ObservableStore();
    const {
      networkController
    } = this; // setup memStore subscription hooks

    this.on('update', updatePublicConfigStore);
    updatePublicConfigStore(this.getState());

    function updatePublicConfigStore(memState) {
      const chainId = networkController.getCurrentChainId();

      if (memState.network !== 'loading') {
        publicConfigStore.putState(selectPublicState(chainId, memState));
      }
    }

    function selectPublicState(chainId, {
      isUnlocked,
      network
    }) {
      return {
        isUnlocked,
        chainId,
        networkVersion: network
      };
    }

    return publicConfigStore;
  }
  /**
   * Gets relevant state for the provider of an external origin.
   *
   * @param {string} origin - The origin to get the provider state for.
   * @returns {Promise<{
   *  isUnlocked: boolean,
   *  networkVersion: string,
   *  chainId: string,
   *  accounts: string[],
   * }>} An object with relevant state properties.
   */


  async getProviderState(origin) {
    return _objectSpread(_objectSpread({
      isUnlocked: this.isUnlocked()
    }, this.getProviderNetworkState()), {}, {
      accounts: await this.getPermittedAccounts(origin)
    });
  }
  /**
   * Gets network state relevant for external providers.
   *
   * @param {Object} [memState] - The MetaMask memState. If not provided,
   * this function will retrieve the most recent state.
   * @returns {Object} An object with relevant network state properties.
   */


  getProviderNetworkState(memState) {
    const {
      network
    } = memState || this.getState();
    return {
      chainId: this.networkController.getCurrentChainId(),
      networkVersion: network
    };
  } //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {Object} status
   */


  getState() {
    const {
      vault
    } = this.keyringController.store.getState();
    const isInitialized = Boolean(vault);
    return _objectSpread({
      isInitialized
    }, this.memStore.getFlatState());
  }
  /**
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream via JSON-RPC.
   *
   * @returns {Object} Object containing API functions.
   */


  getApi() {
    const {
      addressBookController,
      alertController,
      approvalController,
      appStateController,
      collectiblesController,
      collectibleDetectionController,
      assetsContractController,
      currencyRateController,
      detectTokensController,
      ensController,
      gasFeeController,
      keyringController,
      metaMetricsController,
      networkController,
      notificationController,
      onboardingController,
      permissionController,
      preferencesController,
      qrHardwareKeyring,
      swapsController,
      threeBoxController,
      tokensController,
      smartTransactionsController,
      txController
    } = this;
    return _objectSpread(_objectSpread({
      // etc
      getState: this.getState.bind(this),
      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(currencyRateController),
      setUseBlockie: preferencesController.setUseBlockie.bind(preferencesController),
      setUseNonceField: preferencesController.setUseNonceField.bind(preferencesController),
      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(preferencesController),
      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(preferencesController),
      setUseCollectibleDetection: preferencesController.setUseCollectibleDetection.bind(preferencesController),
      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(preferencesController),
      setIpfsGateway: preferencesController.setIpfsGateway.bind(preferencesController),
      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(metaMetricsController),
      setCurrentLocale: preferencesController.setCurrentLocale.bind(preferencesController),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      safelistPhishingDomain: this.safelistPhishingDomain.bind(this),
      getRequestAccountTabIds: this.getRequestAccountTabIds,
      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
      markNotificationPopupAsAutomaticallyClosed: () => this.notificationManager.markAsAutomaticallyClosed(),
      // primary HD keyring management
      addNewAccount: this.addNewAccount.bind(this),
      verifySeedPhrase: this.verifySeedPhrase.bind(this),
      resetAccount: this.resetAccount.bind(this),
      removeAccount: this.removeAccount.bind(this),
      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
      // hardware wallets
      connectHardware: this.connectHardware.bind(this),
      forgetDevice: this.forgetDevice.bind(this),
      checkHardwareStatus: this.checkHardwareStatus.bind(this),
      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(this),
      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(this),
      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(this),
      // qr hardware devices
      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(qrHardwareKeyring),
      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(qrHardwareKeyring),
      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(qrHardwareKeyring),
      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(qrHardwareKeyring),
      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(qrHardwareKeyring),
      // mobile
      fetchInfoToSync: this.fetchInfoToSync.bind(this),
      // vault management
      submitPassword: this.submitPassword.bind(this),
      verifyPassword: this.verifyPassword.bind(this),
      // network management
      setProviderType: networkController.setProviderType.bind(networkController),
      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(networkController),
      setCustomRpc: this.setCustomRpc.bind(this),
      updateAndSetCustomRpc: this.updateAndSetCustomRpc.bind(this),
      delCustomRpc: this.delCustomRpc.bind(this),
      // PreferencesController
      setSelectedAddress: preferencesController.setSelectedAddress.bind(preferencesController),
      addToken: tokensController.addToken.bind(tokensController),
      rejectWatchAsset: tokensController.rejectWatchAsset.bind(tokensController),
      acceptWatchAsset: tokensController.acceptWatchAsset.bind(tokensController),
      updateTokenType: tokensController.updateTokenType.bind(tokensController),
      removeToken: tokensController.removeAndIgnoreToken.bind(tokensController),
      setAccountLabel: preferencesController.setAccountLabel.bind(preferencesController),
      setFeatureFlag: preferencesController.setFeatureFlag.bind(preferencesController),
      setPreference: preferencesController.setPreference.bind(preferencesController),
      addKnownMethodData: preferencesController.addKnownMethodData.bind(preferencesController),
      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(preferencesController),
      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(preferencesController),
      setEIP1559V2Enabled: preferencesController.setEIP1559V2Enabled.bind(preferencesController),
      // AssetsContractController
      getTokenStandardAndDetails: assetsContractController.getTokenStandardAndDetails.bind(assetsContractController),
      // CollectiblesController
      addCollectible: collectiblesController.addCollectible.bind(collectiblesController),
      addCollectibleVerifyOwnership: collectiblesController.addCollectibleVerifyOwnership.bind(collectiblesController),
      removeAndIgnoreCollectible: collectiblesController.removeAndIgnoreCollectible.bind(collectiblesController),
      removeCollectible: collectiblesController.removeCollectible.bind(collectiblesController),
      checkAndUpdateAllCollectiblesOwnershipStatus: collectiblesController.checkAndUpdateAllCollectiblesOwnershipStatus.bind(collectiblesController),
      checkAndUpdateSingleCollectibleOwnershipStatus: collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus.bind(collectiblesController),
      isCollectibleOwner: collectiblesController.isCollectibleOwner.bind(collectiblesController),
      // AddressController
      setAddressBook: addressBookController.set.bind(addressBookController),
      removeFromAddressBook: addressBookController.delete.bind(addressBookController),
      // AppStateController
      setLastActiveTime: appStateController.setLastActiveTime.bind(appStateController),
      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(appStateController),
      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(appStateController),
      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(appStateController),
      setCollectiblesDetectionNoticeDismissed: appStateController.setCollectiblesDetectionNoticeDismissed.bind(appStateController),
      setEnableEIP1559V2NoticeDismissed: appStateController.setEnableEIP1559V2NoticeDismissed.bind(appStateController),
      updateCollectibleDropDownState: appStateController.updateCollectibleDropDownState.bind(appStateController),
      // EnsController
      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(ensController),
      // KeyringController
      setLocked: this.setLocked.bind(this),
      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
      exportAccount: keyringController.exportAccount.bind(keyringController),
      // txController
      cancelTransaction: txController.cancelTransaction.bind(txController),
      updateTransaction: txController.updateTransaction.bind(txController),
      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(txController),
      approveTransactionsWithSameNonce: txController.approveTransactionsWithSameNonce.bind(txController),
      createCancelTransaction: this.createCancelTransaction.bind(this),
      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
      estimateGas: this.estimateGas.bind(this),
      getNextNonce: this.getNextNonce.bind(this),
      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(txController),
      createTransactionEventFragment: txController.createTransactionEventFragment.bind(txController),
      getTransactions: txController.getTransactions.bind(txController),
      // messageManager
      signMessage: this.signMessage.bind(this),
      cancelMessage: this.cancelMessage.bind(this),
      // personalMessageManager
      signPersonalMessage: this.signPersonalMessage.bind(this),
      cancelPersonalMessage: this.cancelPersonalMessage.bind(this),
      // typedMessageManager
      signTypedMessage: this.signTypedMessage.bind(this),
      cancelTypedMessage: this.cancelTypedMessage.bind(this),
      // decryptMessageManager
      decryptMessage: this.decryptMessage.bind(this),
      decryptMessageInline: this.decryptMessageInline.bind(this),
      cancelDecryptMessage: this.cancelDecryptMessage.bind(this),
      // EncryptionPublicKeyManager
      encryptionPublicKey: this.encryptionPublicKey.bind(this),
      cancelEncryptionPublicKey: this.cancelEncryptionPublicKey.bind(this),
      // onboarding controller
      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(onboardingController),
      completeOnboarding: onboardingController.completeOnboarding.bind(onboardingController),
      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(onboardingController),
      // alert controller
      setAlertEnabledness: alertController.setAlertEnabledness.bind(alertController),
      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(alertController),
      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(alertController),
      // 3Box
      setThreeBoxSyncingPermission: threeBoxController.setThreeBoxSyncingPermission.bind(threeBoxController),
      restoreFromThreeBox: threeBoxController.restoreFromThreeBox.bind(threeBoxController),
      setShowRestorePromptToFalse: threeBoxController.setShowRestorePromptToFalse.bind(threeBoxController),
      getThreeBoxLastUpdated: threeBoxController.getLastUpdated.bind(threeBoxController),
      turnThreeBoxSyncingOn: threeBoxController.turnThreeBoxSyncingOn.bind(threeBoxController),
      initializeThreeBox: this.initializeThreeBox.bind(this),
      // permissions
      removePermissionsFor: permissionController.revokePermissions.bind(permissionController),
      approvePermissionsRequest: permissionController.acceptPermissionsRequest.bind(permissionController),
      rejectPermissionsRequest: permissionController.rejectPermissionsRequest.bind(permissionController)
    }, (0, _permissions2.getPermissionBackgroundApiMethods)(permissionController)), {}, {
      // swaps
      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(swapsController),
      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(swapsController),
      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),
      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),
      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),
      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),
      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),
      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(swapsController),
      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(swapsController),
      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(swapsController),
      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(swapsController),
      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(swapsController),
      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(swapsController),
      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(swapsController),
      resetPostFetchState: swapsController.resetPostFetchState.bind(swapsController),
      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),
      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(swapsController),
      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(swapsController),
      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),
      setSwapsFeatureFlags: swapsController.setSwapsFeatureFlags.bind(swapsController),
      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(swapsController),
      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(swapsController),
      // Smart Transactions
      setSmartTransactionsOptInStatus: smartTransactionsController.setOptInState.bind(smartTransactionsController),
      fetchSmartTransactionFees: smartTransactionsController.getFees.bind(smartTransactionsController),
      estimateSmartTransactionsGas: smartTransactionsController.estimateGas.bind(smartTransactionsController),
      submitSignedTransactions: smartTransactionsController.submitSignedTransactions.bind(smartTransactionsController),
      cancelSmartTransaction: smartTransactionsController.cancelSmartTransaction.bind(smartTransactionsController),
      fetchSmartTransactionsLiveness: smartTransactionsController.fetchLiveness.bind(smartTransactionsController),
      updateSmartTransaction: smartTransactionsController.updateSmartTransaction.bind(smartTransactionsController),
      setStatusRefreshInterval: smartTransactionsController.setStatusRefreshInterval.bind(smartTransactionsController),
      // MetaMetrics
      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(metaMetricsController),
      trackMetaMetricsPage: metaMetricsController.trackPage.bind(metaMetricsController),
      createEventFragment: metaMetricsController.createEventFragment.bind(metaMetricsController),
      updateEventFragment: metaMetricsController.updateEventFragment.bind(metaMetricsController),
      finalizeEventFragment: metaMetricsController.finalizeEventFragment.bind(metaMetricsController),
      // approval controller
      resolvePendingApproval: approvalController.accept.bind(approvalController),
      rejectPendingApproval: approvalController.reject.bind(approvalController),
      // Notifications
      updateViewedNotifications: notificationController.updateViewed.bind(notificationController),
      // GasFeeController
      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(gasFeeController),
      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(gasFeeController),
      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(gasFeeController),
      addPollingTokenToAppState: appStateController.addPollingToken.bind(appStateController),
      removePollingTokenFromAppState: appStateController.removePollingToken.bind(appStateController),
      // DetectTokenController
      detectNewTokens: detectTokensController.detectNewTokens.bind(detectTokensController),
      // DetectCollectibleController
      detectCollectibles: false ? collectibleDetectionController.detectCollectibles.bind(collectibleDetectionController) : null
    });
  } //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param {string} password
   * @returns {Object} vault
   */


  async createNewVaultAndKeychain(password) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let vault;
      const accounts = await this.keyringController.getAccounts();

      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate();
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password);
        const addresses = await this.keyringController.getAccounts();
        this.preferencesController.setAddresses(addresses);
        this.selectFirstIdentity();
      }

      return vault;
    } finally {
      releaseLock();
    }
  }
  /**
   * Create a new Vault and restore an existent keyring.
   *
   * @param {string} password
   * @param {number[]} encodedSeedPhrase - The seed phrase, encoded as an array
   * of UTF-8 bytes.
   */


  async createNewVaultAndRestore(password, encodedSeedPhrase) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let accounts, lastBalance;
      const seedPhraseAsBuffer = Buffer.from(encodedSeedPhrase);
      const {
        keyringController
      } = this; // clear known identities

      this.preferencesController.setAddresses([]); // clear permissions

      this.permissionController.clearState(); // clear accounts in accountTracker

      this.accountTracker.clearAccounts(); // clear cachedBalances

      this.cachedBalancesController.clearCachedBalances(); // clear unapproved transactions

      this.txController.txStateManager.clearUnapprovedTxs(); // create new vault

      const vault = await keyringController.createNewVaultAndRestore(password, seedPhraseAsBuffer);
      const ethQuery = new _ethQuery.default(this.provider);
      accounts = await keyringController.getAccounts();
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      const primaryKeyring = keyringController.getKeyringsByType('HD Key Tree')[0];

      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found');
      } // seek out the first zero balance


      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring);
        accounts = await keyringController.getAccounts();
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      } // remove extra zero balance account potentially created from seeking ahead


      if (accounts.length > 1 && lastBalance === '0x0') {
        await this.removeAccount(accounts[accounts.length - 1]);
        accounts = await keyringController.getAccounts();
      } // This must be set as soon as possible to communicate to the
      // keyring's iframe and have the setting initialized properly
      // Optimistically called to not block Metamask login due to
      // Ledger Keyring GitHub downtime


      const transportPreference = this.preferencesController.getLedgerTransportPreference();
      this.setLedgerTransportPreference(transportPreference); // set new identities

      this.preferencesController.setAddresses(accounts);
      this.selectFirstIdentity();
      return vault;
    } finally {
      releaseLock();
    }
  }
  /**
   * Get an account balance from the AccountTracker or request it directly from the network.
   *
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */


  getBalance(address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address];

      if (cached && cached.balance) {
        resolve(cached.balance);
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error);

            _loglevel.default.error(error);
          } else {
            resolve(balance || '0x0');
          }
        });
      }
    });
  }
  /**
   * Collects all the information that we want to share
   * with the mobile client for syncing purposes
   *
   * @returns {Promise<Object>} Parts of the state that we want to syncx
   */


  async fetchInfoToSync() {
    // Preferences
    const {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress,
      useTokenDetection
    } = this.preferencesController.store.getState();
    const {
      tokenList
    } = this.tokenListController.state;
    const preferences = {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress
    }; // Tokens

    const {
      allTokens,
      allIgnoredTokens
    } = this.tokensController.state; // Filter ERC20 tokens

    const allERC20Tokens = {};
    Object.keys(allTokens).forEach(chainId => {
      allERC20Tokens[chainId] = {};
      Object.keys(allTokens[chainId]).forEach(accountAddress => {
        const checksummedAccountAddress = (0, _hexstringUtils.toChecksumHexAddress)(accountAddress);
        allERC20Tokens[chainId][checksummedAccountAddress] = allTokens[chainId][checksummedAccountAddress].filter(asset => {
          if (asset.isERC721 === undefined) {
            // since the token.address from allTokens is checksumaddress
            // asset.address have to be changed to lowercase when we are using dynamic list
            const address = useTokenDetection ? asset.address.toLowerCase() : asset.address; // the tokenList will be holding only erc20 tokens

            if (tokenList[address] !== undefined) {
              return true;
            }
          } else if (asset.isERC721 === false) {
            return true;
          }

          return false;
        });
      });
    }); // Accounts

    const hdKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];
    const simpleKeyPairKeyrings = this.keyringController.getKeyringsByType('Simple Key Pair');
    const hdAccounts = await hdKeyring.getAccounts();
    const simpleKeyPairKeyringAccounts = await Promise.all(simpleKeyPairKeyrings.map(keyring => keyring.getAccounts()));
    const simpleKeyPairAccounts = simpleKeyPairKeyringAccounts.reduce((acc, accounts) => [...acc, ...accounts], []);
    const accounts = {
      hd: hdAccounts.filter((item, pos) => hdAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      simpleKeyPair: simpleKeyPairAccounts.filter((item, pos) => simpleKeyPairAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      ledger: [],
      trezor: [],
      lattice: []
    }; // transactions

    let {
      transactions
    } = this.txController.store.getState(); // delete tx for other accounts that we're not importing

    transactions = Object.values(transactions).filter(tx => {
      const checksummedTxFrom = (0, _hexstringUtils.toChecksumHexAddress)(tx.txParams.from);
      return accounts.hd.includes(checksummedTxFrom);
    });
    return {
      accounts,
      preferences,
      transactions,
      tokens: {
        allTokens: allERC20Tokens,
        allIgnoredTokens
      },
      network: this.networkController.store.getState()
    };
  }
  /**
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} The keyringController update.
   */


  async submitPassword(password) {
    await this.keyringController.submitPassword(password);

    try {
      await this.blockTracker.checkForLatestBlock();
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    }

    try {
      const threeBoxSyncingAllowed = this.threeBoxController.getThreeBoxSyncingState();

      if (threeBoxSyncingAllowed && !this.threeBoxController.box) {
        // 'await' intentionally omitted to avoid waiting for initialization
        this.threeBoxController.init();
        this.threeBoxController.turnThreeBoxSyncingOn();
      } else if (threeBoxSyncingAllowed && this.threeBoxController.box) {
        this.threeBoxController.turnThreeBoxSyncingOn();
      }
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    } // This must be set as soon as possible to communicate to the
    // keyring's iframe and have the setting initialized properly
    // Optimistically called to not block Metamask login due to
    // Ledger Keyring GitHub downtime


    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    this.setLedgerTransportPreference(transportPreference);
    return this.keyringController.fullUpdate();
  }
  /**
   * Submits a user's password to check its validity.
   *
   * @param {string} password - The user's password
   */


  async verifyPassword(password) {
    await this.keyringController.verifyPassword(password);
  }
  /**
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * @property {boolean} mayBeFauceting - Whether this account is currently
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * Sets the first address in the state to the selected address
   */


  selectFirstIdentity() {
    const {
      identities
    } = this.preferencesController.store.getState();
    const address = Object.keys(identities)[0];
    this.preferencesController.setSelectedAddress(address);
  }
  /**
   * Gets the mnemonic of the user's primary keyring.
   */


  getPrimaryKeyringMnemonic() {
    const keyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];

    if (!keyring.mnemonic) {
      throw new Error('Primary keyring mnemonic unavailable.');
    }

    return keyring.mnemonic;
  } //
  // Hardware
  //


  async getKeyringForDevice(deviceName, hdPath = null) {
    let keyringName = null;

    switch (deviceName) {
      case _hardwareWallets.DEVICE_NAMES.TREZOR:
        keyringName = _ethTrezorKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LEDGER:
        keyringName = _ethLedgerBridgeKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.QR:
        keyringName = _metamaskAirgappedKeyring.MetaMaskKeyring.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LATTICE:
        keyringName = _ethLatticeKeyring.default.type;
        break;

      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device');
    }

    let keyring = await this.keyringController.getKeyringsByType(keyringName)[0];

    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName);
    }

    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath);
    }

    if (deviceName === _hardwareWallets.DEVICE_NAMES.LATTICE) {
      keyring.appName = 'MetaMask';
    }

    if (deviceName === _hardwareWallets.DEVICE_NAMES.TREZOR) {
      const model = keyring.getModel();
      this.appStateController.setTrezorModel(model);
    }

    keyring.network = this.networkController.getProviderConfig().type;
    return keyring;
  }

  async attemptLedgerTransportCreation() {
    const keyring = await this.getKeyringForDevice(_hardwareWallets.DEVICE_NAMES.LEDGER);
    return await keyring.attemptMakeApp();
  }

  async establishLedgerTransportPreference() {
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    return await this.setLedgerTransportPreference(transportPreference);
  }
  /**
   * Fetch account list from a trezor device.
   *
   * @param deviceName
   * @param page
   * @param hdPath
   * @returns [] accounts
   */


  async connectHardware(deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    let accounts = [];

    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage();
        break;

      case 1:
        accounts = await keyring.getNextPage();
        break;

      default:
        accounts = await keyring.getFirstPage();
    } // Merge with existing accounts
    // and make sure addresses are not repeated


    const oldAccounts = await this.keyringController.getAccounts();
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];
    this.accountTracker.syncWithAddresses(accountsToTrack);
    return accounts;
  }
  /**
   * Check if the device is unlocked
   *
   * @param deviceName
   * @param hdPath
   * @returns {Promise<boolean>}
   */


  async checkHardwareStatus(deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    return keyring.isUnlocked();
  }
  /**
   * Clear
   *
   * @param deviceName
   * @returns {Promise<boolean>}
   */


  async forgetDevice(deviceName) {
    const keyring = await this.getKeyringForDevice(deviceName);
    keyring.forgetDevice();
    return true;
  }
  /**
   * get hardware account label
   *
   * @returns string label
   */


  getAccountLabel(name, index, hdPathDescription) {
    return `${name[0].toUpperCase()}${name.slice(1)} ${parseInt(index, 10) + 1} ${hdPathDescription || ''}`.trim();
  }
  /**
   * Imports an account from a Trezor or Ledger device.
   *
   * @param index
   * @param deviceName
   * @param hdPath
   * @param hdPathDescription
   * @returns {} keyState
   */


  async unlockHardwareWalletAccount(index, deviceName, hdPath, hdPathDescription) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    keyring.setAccountToUnlock(index);
    const oldAccounts = await this.keyringController.getAccounts();
    const keyState = await this.keyringController.addNewAccount(keyring);
    const newAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        const label = this.getAccountLabel(deviceName === _hardwareWallets.DEVICE_NAMES.QR ? keyring.getName() : deviceName, index, hdPathDescription); // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc

        this.preferencesController.setAccountLabel(address, label); // Select the account

        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return _objectSpread(_objectSpread({}, keyState), {}, {
      identities
    });
  } //
  // Account Management
  //

  /**
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @returns {} keyState
   */


  async addNewAccount() {
    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const {
      keyringController
    } = this;
    const oldAccounts = await keyringController.getAccounts();
    const keyState = await keyringController.addNewAccount(primaryKeyring);
    const newAccounts = await keyringController.getAccounts();
    await this.verifySeedPhrase();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return _objectSpread(_objectSpread({}, keyState), {}, {
      identities
    });
  }
  /**
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<number[]>} The seed phrase to be confirmed by the user,
   * encoded as an array of UTF-8 bytes.
   */


  async verifySeedPhrase() {
    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0];

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const serialized = await primaryKeyring.serialize();
    const seedPhraseAsBuffer = Buffer.from(serialized.mnemonic);
    const accounts = await primaryKeyring.getAccounts();

    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found');
    }

    try {
      await _seedPhraseVerifier.default.verifyAccounts(accounts, seedPhraseAsBuffer);
      return Array.from(seedPhraseAsBuffer.values());
    } catch (err) {
      _loglevel.default.error(err.message);

      throw err;
    }
  }
  /**
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns {Promise<string>} The current selected address.
   */


  async resetAccount() {
    const selectedAddress = this.preferencesController.getSelectedAddress();
    this.txController.wipeTransactions(selectedAddress);
    this.networkController.resetConnection();
    return selectedAddress;
  }
  /**
   * Gets the permitted accounts for the specified origin. Returns an empty
   * array if no accounts are permitted.
   *
   * @param {string} origin - The origin whose exposed accounts to retrieve.
   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty
   * array.
   */


  async getPermittedAccounts(origin) {
    try {
      return await this.permissionController.executeRestrictedMethod(origin, _permissions.RestrictedMethods.eth_accounts);
    } catch (error) {
      if (error.code === _ethRpcErrors.errorCodes.provider.unauthorized) {
        return [];
      }

      throw error;
    }
  }
  /**
   * Stops exposing the account with the specified address to all third parties.
   * Exposed accounts are stored in caveats of the eth_accounts permission. This
   * method uses `PermissionController.updatePermissionsByCaveat` to
   * remove the specified address from every eth_accounts permission. If a
   * permission only included this address, the permission is revoked entirely.
   *
   * @param {string} targetAccount - The address of the account to stop exposing
   * to third parties.
   */


  removeAllAccountPermissions(targetAccount) {
    this.permissionController.updatePermissionsByCaveat(_permissions.CaveatTypes.restrictReturnedAccounts, existingAccounts => _permissions2.CaveatMutatorFactories[_permissions.CaveatTypes.restrictReturnedAccounts].removeAccount(targetAccount, existingAccounts));
  }
  /**
   * Removes an account from state / storage.
   *
   * @param {string[]} address - A hex address
   */


  async removeAccount(address) {
    // Remove all associated permissions
    this.removeAllAccountPermissions(address); // Remove account from the preferences controller

    this.preferencesController.removeAddress(address); // Remove account from the account tracker controller

    this.accountTracker.removeAccount([address]); // Remove account from the keyring

    await this.keyringController.removeAccount(address);
    return address;
  }
  /**
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param {string} strategy - A unique identifier for an account import strategy.
   * @param {any} args - The data required by that strategy to import an account.
   */


  async importAccountWithStrategy(strategy, args) {
    const privateKey = await _accountImportStrategies.default.importAccount(strategy, args);
    const keyring = await this.keyringController.addNewKeyring('Simple Key Pair', [privateKey]);
    const accounts = await keyring.getAccounts(); // update accounts in preferences controller

    const allAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(allAccounts); // set new account as selected

    await this.preferencesController.setSelectedAddress(accounts[0]);
  } // ---------------------------------------------------------------------------
  // Identity Management (signature operations)

  /**
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {Object} txParams - The transaction parameters.
   * @param {Object} [req] - The original request, containing the origin.
   */


  async newUnapprovedTransaction(txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req);
  } // eth_sign methods:

  /**
   * Called when a Dapp uses the eth_sign method, to request user approval.
   * eth_sign is a pure signature of arbitrary data. It is on a deprecation
   * path, since this data can be a transaction, or can leak private key
   * information.
   *
   * @param {Object} msgParams - The params passed to eth_sign.
   * @param {Object} [req] - The original request, containing the origin.
   */


  async newUnsignedMessage(msgParams, req) {
    const data = (0, _messageManager.normalizeMsgData)(msgParams.data);
    let promise; // 64 hex + "0x" at the beginning
    // This is needed because Ethereum's EcSign works only on 32 byte numbers
    // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607

    if (data.length === 66 || data.length === 67) {
      promise = this.messageManager.addUnapprovedMessageAsync(msgParams, req);
      this.sendUpdate();
      this.opts.showUserConfirmation();
    } else {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('eth_sign requires 32 byte message hash');
    }

    return await promise;
  }
  /**
   * Signifies user intent to complete an eth_sign method.
   *
   * @param {Object} msgParams - The params passed to eth_call.
   * @returns {Promise<Object>} Full state update.
   */


  async signMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signMessage');

    const msgId = msgParams.metamaskId;

    try {
      // sets the status op the message to 'approved'
      // and removes the metamaskId for signing
      const cleanMsgParams = await this.messageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signMessage(cleanMsgParams);
      this.messageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_sign failed', error);

      this.messageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a message submitted via eth_sign.
   *
   * @param {string} msgId - The id of the message to cancel.
   */


  cancelMessage(msgId) {
    const {
      messageManager
    } = this;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // personal_sign methods:

  /**
   * Called when a dapp uses the personal_sign method.
   * This is identical to the Geth eth_sign method, and may eventually replace
   * eth_sign.
   *
   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Object} [req] - The original request, containing the origin.
   */


  async newUnsignedPersonalMessage(msgParams, req) {
    const promise = this.personalMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Signifies a user's approval to sign a personal_sign message in queue.
   * Triggers signing, and the callback function from newUnsignedPersonalMessage.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async signPersonalMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signPersonalMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for signing

    try {
      const cleanMsgParams = await this.personalMessageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signPersonalMessage(cleanMsgParams); // tells the listener that the message has been signed
      // and can be returned to the dapp

      this.personalMessageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_personalSign failed', error);

      this.personalMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a personal_sign type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelPersonalMessage(msgId) {
    const messageManager = this.personalMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_decrypt methods

  /**
   * Called when a dapp uses the eth_decrypt method.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestDecryptMessage(msgParams, req) {
    const promise = this.decryptMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Only decrypt message and don't touch transaction state
   *
   * @param {Object} msgParams - The params of the message to decrypt.
   * @returns {Promise<Object>} A full state update.
   */


  async decryptMessageInline(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessageInline'); // decrypt the message inline


    const msgId = msgParams.metamaskId;
    const msg = this.decryptMessageManager.getMsg(msgId);

    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(msgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      msgParams.data = JSON.parse(buff.toString('utf8'));
      msg.rawData = await this.keyringController.decryptMessage(msgParams);
    } catch (e) {
      msg.error = e.message;
    }

    this.decryptMessageManager._updateMsg(msg);

    return this.getState();
  }
  /**
   * Signifies a user's approval to decrypt a message in queue.
   * Triggers decrypt, and the callback function from newUnsignedDecryptMessage.
   *
   * @param {Object} msgParams - The params of the message to decrypt & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async decryptMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const cleanMsgParams = await this.decryptMessageManager.approveMessage(msgParams);
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(cleanMsgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      cleanMsgParams.data = JSON.parse(buff.toString('utf8')); // decrypt the message

      const rawMess = await this.keyringController.decryptMessage(cleanMsgParams); // tells the listener that the message has been decrypted and can be returned to the dapp

      this.decryptMessageManager.setMsgStatusDecrypted(msgId, rawMess);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_decrypt failed.', error);

      this.decryptMessageManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_decrypt type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelDecryptMessage(msgId) {
    const messageManager = this.decryptMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_getEncryptionPublicKey methods

  /**
   * Called when a dapp uses the eth_getEncryptionPublicKey method.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestEncryptionPublicKey(msgParams, req) {
    const address = msgParams;
    const keyring = await this.keyringController.getKeyringForAccount(address);

    switch (keyring.type) {
      case _hardwareWallets.KEYRING_TYPES.LEDGER:
        {
          return new Promise((_, reject) => {
            reject(new Error('Ledger does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.TREZOR:
        {
          return new Promise((_, reject) => {
            reject(new Error('Trezor does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.LATTICE:
        {
          return new Promise((_, reject) => {
            reject(new Error('Lattice does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.QR:
        {
          return Promise.reject(new Error('QR hardware does not support eth_getEncryptionPublicKey.'));
        }

      default:
        {
          const promise = this.encryptionPublicKeyManager.addUnapprovedMessageAsync(msgParams, req);
          this.sendUpdate();
          this.opts.showUserConfirmation();
          return promise;
        }
    }
  }
  /**
   * Signifies a user's approval to receiving encryption public key in queue.
   * Triggers receiving, and the callback function from newUnsignedEncryptionPublicKey.
   *
   * @param {Object} msgParams - The params of the message to receive & return to the Dapp.
   * @returns {Promise<Object>} A full state update.
   */


  async encryptionPublicKey(msgParams) {
    _loglevel.default.info('MetaMaskController - encryptionPublicKey');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const params = await this.encryptionPublicKeyManager.approveMessage(msgParams); // EncryptionPublicKey message

      const publicKey = await this.keyringController.getEncryptionPublicKey(params.data); // tells the listener that the message has been processed
      // and can be returned to the dapp

      this.encryptionPublicKeyManager.setMsgStatusReceived(msgId, publicKey);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_getEncryptionPublicKey failed.', error);

      this.encryptionPublicKeyManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_getEncryptionPublicKey type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelEncryptionPublicKey(msgId) {
    const messageManager = this.encryptionPublicKeyManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_signTypedData methods

  /**
   * Called when a dapp uses the eth_signTypedData method, per EIP 712.
   *
   * @param {Object} msgParams - The params passed to eth_signTypedData.
   * @param {Object} [req] - The original request, containing the origin.
   * @param version
   */


  newUnsignedTypedMessage(msgParams, req, version) {
    const promise = this.typedMessageManager.addUnapprovedMessageAsync(msgParams, req, version);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * The method for a user approving a call to eth_signTypedData, per EIP 712.
   * Triggers the callback in newUnsignedTypedMessage.
   *
   * @param {Object} msgParams - The params passed to eth_signTypedData.
   * @returns {Object} Full state update.
   */


  async signTypedMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - eth_signTypedData');

    const msgId = msgParams.metamaskId;
    const {
      version
    } = msgParams;

    try {
      const cleanMsgParams = await this.typedMessageManager.approveMessage(msgParams); // For some reason every version after V1 used stringified params.

      if (version !== 'V1') {
        // But we don't have to require that. We can stop suggesting it now:
        if (typeof cleanMsgParams.data === 'string') {
          cleanMsgParams.data = JSON.parse(cleanMsgParams.data);
        }
      }

      const signature = await this.keyringController.signTypedMessage(cleanMsgParams, {
        version
      });
      this.typedMessageManager.setMsgStatusSigned(msgId, signature);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_signTypedData failed.', error);

      this.typedMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a eth_signTypedData type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelTypedMessage(msgId) {
    const messageManager = this.typedMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  }
  /**
   * @returns {boolean} true if the keyring type supports EIP-1559
   */


  async getCurrentAccountEIP1559Compatibility() {
    return true;
  } //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * Allows a user to attempt to cancel a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to cancel
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param newTxMetaProps
   * @returns {Object} MetaMask state
   */


  async createCancelTransaction(originalTxId, customGasSettings, newTxMetaProps) {
    await this.txController.createCancelTransaction(originalTxId, customGasSettings, newTxMetaProps);
    const state = await this.getState();
    return state;
  }
  /**
   * Allows a user to attempt to speed up a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to speed up
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param newTxMetaProps
   * @returns {Object} MetaMask state
   */


  async createSpeedUpTransaction(originalTxId, customGasSettings, newTxMetaProps) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasSettings, newTxMetaProps);
    const state = await this.getState();
    return state;
  }

  estimateGas(estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err);
        }

        return resolve(res.toString(16));
      });
    });
  } //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * Allows a user to begin the seed phrase recovery process.
   */


  markPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(true);
    this.sendUpdate();
  }
  /**
   * Allows a user to end the seed phrase recovery process.
   */


  unMarkPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(false);
    this.sendUpdate();
  } //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * A runtime.MessageSender object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender
   * @typedef {Object} MessageSender
   * @property {string} - The URL of the page or frame hosting the script that sent the message.
   */

  /**
   * A Snap sender object.
   *
   * @typedef {Object} SnapSender
   * @property {string} snapId - The ID of the snap.
   */

  /**
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   * @param {MessageSender | SnapSender} options.sender - The sender of the messages on this stream.
   * @param {string} [options.subjectType] - The type of the sender, i.e. subject.
   */


  setupUntrustedCommunication({
    connectionStream,
    sender,
    subjectType
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();

    let _subjectType;

    if (subjectType) {
      _subjectType = subjectType;
    } else if (sender.id && sender.id !== this.extension.runtime.id) {
      _subjectType = _app.SUBJECT_TYPES.EXTENSION;
    } else {
      _subjectType = _app.SUBJECT_TYPES.WEBSITE;
    }

    if (sender.url) {
      const {
        hostname
      } = new URL(sender.url); // Check if new connection is blocked if phishing detection is on

      if (usePhishDetect && this.phishingController.test(hostname)) {
        _loglevel.default.debug('MetaMask - sending phishing warning for', hostname);

        this.sendPhishingWarning(connectionStream, hostname);
        return;
      }
    } // setup multiplexing


    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // messages between inpage and background

    this.setupProviderConnection(mux.createStream('metamask-provider'), sender, _subjectType); // TODO:LegacyProvider: Delete

    if (sender.url) {
      // legacy streams
      this.setupPublicConfig(mux.createStream('publicConfig'));
    }
  }
  /**
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */


  setupTrustedCommunication(connectionStream, sender) {
    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // connect features

    this.setupControllerConnection(mux.createStream('controller'));
    this.setupProviderConnection(mux.createStream('provider'), sender, _app.SUBJECT_TYPES.INTERNAL);
  }
  /**
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The hostname that triggered the suspicion.
   */


  sendPhishingWarning(connectionStream, hostname) {
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream('phishing');
    phishingStream.write({
      hostname
    });
  }
  /**
   * A method for providing our API over a stream using JSON-RPC.
   *
   * @param {*} outStream - The stream to provide our API over.
   */


  setupControllerConnection(outStream) {
    const api = this.getApi(); // report new active controller connection

    this.activeControllerConnections += 1;
    this.emit('controllerConnectionChanged', this.activeControllerConnections); // set up postStream transport

    outStream.on('data', (0, _createMetaRPCHandler.default)(api, outStream));

    const handleUpdate = update => {
      if (outStream._writableState.ended) {
        return;
      } // send notification to client-side


      outStream.write({
        jsonrpc: '2.0',
        method: 'sendUpdate',
        params: [update]
      });
    };

    this.on('update', handleUpdate);
    outStream.on('end', () => {
      this.activeControllerConnections -= 1;
      this.emit('controllerConnectionChanged', this.activeControllerConnections);
      this.removeListener('update', handleUpdate);
    });
  }
  /**
   * A method for serving our ethereum provider over a given stream.
   *
   * @param {*} outStream - The stream to provide over.
   * @param {MessageSender | SnapSender} sender - The sender of the messages on this stream
   * @param {string} subjectType - The type of the sender, i.e. subject.
   */


  setupProviderConnection(outStream, sender, subjectType) {
    let origin;

    if (subjectType === _app.SUBJECT_TYPES.INTERNAL) {
      origin = 'metamask';
    } else {
      origin = new URL(sender.url).origin;
    }

    if (sender.id && sender.id !== this.extension.runtime.id) {
      this.subjectMetadataController.addSubjectMetadata({
        origin,
        extensionId: sender.id,
        subjectType: _app.SUBJECT_TYPES.EXTENSION
      });
    }

    let tabId;

    if (sender.tab && sender.tab.id) {
      tabId = sender.tab.id;
    }

    const engine = this.setupProviderEngine({
      origin,
      sender,
      subjectType,
      tabId
    }); // setup connection

    const providerStream = (0, _engineStream.default)({
      engine
    });
    const connectionId = this.addConnection(origin, {
      engine
    });
    (0, _pump.default)(outStream, providerStream, outStream, err => {
      // handle any middleware cleanup
      engine._middleware.forEach(mid => {
        if (mid.destroy && typeof mid.destroy === 'function') {
          mid.destroy();
        }
      });

      connectionId && this.removeConnection(origin, connectionId);

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * A method for creating a provider that is safely restricted for the requesting subject.
   *
   * @param {Object} options - Provider engine options
   * @param {string} options.origin - The origin of the sender
   * @param {MessageSender | SnapSender} options.sender - The sender object.
   * @param {string} options.subjectType - The type of the sender subject.
   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab
   */


  setupProviderEngine({
    origin,
    subjectType,
    sender,
    tabId
  }) {
    // setup json rpc engine stack
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    const {
      blockTracker,
      provider
    } = this; // create filter polyfill middleware

    const filterMiddleware = (0, _ethJsonRpcFilters.default)({
      provider,
      blockTracker
    }); // create subscription polyfill middleware

    const subscriptionManager = (0, _subscriptionManager.default)({
      provider,
      blockTracker
    });
    subscriptionManager.events.on('notification', message => engine.emit('notification', message)); // append origin to each request

    engine.push((0, _createOriginMiddleware.default)({
      origin
    })); // append tabId to each request if it exists

    if (tabId) {
      engine.push((0, _createTabIdMiddleware.default)({
        tabId
      }));
    } // logging


    engine.push((0, _createLoggerMiddleware.default)({
      origin
    }));
    engine.push(this.permissionLogController.createMiddleware()); // onboarding

    if (subjectType === _app.SUBJECT_TYPES.WEBSITE) {
      engine.push((0, _createOnboardingMiddleware.default)({
        location: sender.url,
        registerOnboarding: this.onboardingController.registerOnboarding
      }));
    } // Unrestricted/permissionless RPC method implementations


    engine.push((0, _rpcMethodMiddleware.createMethodMiddleware)({
      origin,
      subjectType,
      // Miscellaneous
      addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(this.subjectMetadataController),
      getProviderState: this.getProviderState.bind(this),
      getUnlockPromise: this.appStateController.getUnlockPromise.bind(this.appStateController),
      handleWatchAssetRequest: this.tokensController.watchAsset.bind(this.tokensController),
      requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(this.approvalController),
      sendMetrics: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      // Permission-related
      getAccounts: this.getPermittedAccounts.bind(this, origin),
      getPermissionsForOrigin: this.permissionController.getPermissions.bind(this.permissionController, origin),
      hasPermission: this.permissionController.hasPermission.bind(this.permissionController, origin),
      requestAccountsPermission: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }, {
        eth_accounts: {}
      }),
      requestPermissionsForOrigin: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }),
      // Custom RPC-related
      addCustomRpc: async ({
        chainId,
        blockExplorerUrl,
        ticker,
        chainName,
        rpcUrl
      } = {}) => {
        await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, chainName, {
          blockExplorerUrl
        });
      },
      findCustomRpcBy: this.findCustomRpcBy.bind(this),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      setProviderType: this.networkController.setProviderType.bind(this.networkController),
      updateRpcTarget: ({
        rpcUrl,
        chainId,
        ticker,
        nickname
      }) => {
        this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname);
      },
      // Web3 shim-related
      getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(this.alertController),
      setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(this.alertController)
    })); // filter and subscription polyfills

    engine.push(filterMiddleware);
    engine.push(subscriptionManager.middleware);

    if (subjectType !== _app.SUBJECT_TYPES.INTERNAL) {
      // permissions
      engine.push(this.permissionController.createPermissionMiddleware({
        origin
      }));
    } // forward to metamask primary provider


    engine.push((0, _ethJsonRpcMiddleware.providerAsMiddleware)(provider));
    return engine;
  }
  /**
   * TODO:LegacyProvider: Delete
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   */


  setupPublicConfig(outStream) {
    const configStream = (0, _asStream.storeAsStream)(this.publicConfigStore);
    (0, _pump.default)(configStream, outStream, err => {
      configStream.destroy();

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.
   * Caller must ensure that the returned id is stored such that the reference
   * can be deleted later.
   *
   * @param {string} origin - The connection's origin string.
   * @param {Object} options - Data associated with the connection
   * @param {Object} options.engine - The connection's JSON Rpc Engine
   * @returns {string} The connection's id (so that it can be deleted later)
   */


  addConnection(origin, {
    engine
  }) {
    if (origin === 'metamask') {
      return null;
    }

    if (!this.connections[origin]) {
      this.connections[origin] = {};
    }

    const id = (0, _nanoid.default)();
    this.connections[origin][id] = {
      engine
    };
    return id;
  }
  /**
   * Deletes a reference to a connection, by origin and id.
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {string} id - The connection's id, as returned from addConnection.
   */


  removeConnection(origin, id) {
    const connections = this.connections[origin];

    if (!connections) {
      return;
    }

    delete connections[id];

    if (Object.keys(connections).length === 0) {
      delete this.connections[origin];
    }
  }
  /**
   * Closes all connections for the given origin, and removes the references
   * to them.
   * Ignores unknown origins.
   *
   * @param {string} origin - The origin string.
   */


  removeAllConnections(origin) {
    const connections = this.connections[origin];

    if (!connections) {
      return;
    }

    Object.keys(connections).forEach(id => {
      this.removeConnection(origin, id);
    });
  }
  /**
   * Causes the RPC engines associated with the connections to the given origin
   * to emit a notification event with the given payload.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {unknown} payload - The event payload.
   */


  notifyConnections(origin, payload) {
    const connections = this.connections[origin];

    if (connections) {
      Object.values(connections).forEach(conn => {
        if (conn.engine) {
          conn.engine.emit('notification', payload);
        }
      });
    }
  }
  /**
   * Causes the RPC engines associated with all connections to emit a
   * notification event with the given payload.
   *
   * If the "payload" parameter is a function, the payload for each connection
   * will be the return value of that function called with the connection's
   * origin.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * @param {unknown} payload - The event payload, or payload getter function.
   */


  notifyAllConnections(payload) {
    const getPayload = typeof payload === 'function' ? origin => payload(origin) : () => payload;
    Object.keys(this.connections).forEach(origin => {
      Object.values(this.connections[origin]).forEach(async conn => {
        if (conn.engine) {
          conn.engine.emit('notification', await getPayload(origin));
        }
      });
    });
  } // handlers

  /**
   * Handle a KeyringController update
   *
   * @param {Object} state - the KC state
   * @returns {Promise<void>}
   * @private
   */


  async _onKeyringControllerUpdate(state) {
    const {
      keyrings
    } = state;
    const addresses = keyrings.reduce((acc, {
      accounts
    }) => acc.concat(accounts), []);

    if (!addresses.length) {
      return;
    } // Ensure preferences + identities controller know about all addresses


    this.preferencesController.syncAddresses(addresses);
    this.accountTracker.syncWithAddresses(addresses);
  }
  /**
   * Handle global application unlock.
   * Notifies all connections that the extension is unlocked, and which
   * account(s) are currently accessible, if any.
   */


  _onUnlock() {
    this.notifyAllConnections(async origin => {
      return {
        method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
        params: {
          isUnlocked: true,
          accounts: await this.getPermittedAccounts(origin)
        }
      };
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'unlock'
    // event of the MetaMaskController itself.

    this.emit('unlock');
  }
  /**
   * Handle global application lock.
   * Notifies all connections that the extension is locked.
   */


  _onLock() {
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
      params: {
        isUnlocked: false
      }
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'lock'
    // event of the MetaMaskController itself.

    this.emit('lock');
  }
  /**
   * Handle memory state updates.
   * - Ensure isClientOpenAndUnlocked is updated
   * - Notifies all connections with the new provider network state
   *   - The external providers handle diffing the state
   *
   * @param newState
   */


  _onStateUpdate(newState) {
    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.chainChanged,
      params: this.getProviderNetworkState(newState)
    });
  } // misc

  /**
   * A method for emitting the full MetaMask state to all registered listeners.
   *
   * @private
   */


  privateSendUpdate() {
    this.emit('update', this.getState());
  }
  /**
   * @returns {boolean} Whether the extension is unlocked.
   */


  isUnlocked() {
    return this.keyringController.memStore.getState().isUnlocked;
  } //=============================================================================
  // MISCELLANEOUS
  //=============================================================================


  getExternalPendingTransactions(address) {
    return this.smartTransactionsController.getTransactions({
      addressFrom: address,
      status: 'pending'
    });
  }
  /**
   * Returns the nonce that will be associated with a transaction once approved
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getPendingNonce(address) {
    const {
      nonceDetails,
      releaseLock
    } = await this.txController.nonceTracker.getNonceLock(address);
    const pendingNonce = nonceDetails.params.highestSuggested;
    releaseLock();
    return pendingNonce;
  }
  /**
   * Returns the next nonce according to the nonce-tracker
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getNextNonce(address) {
    const nonceLock = await this.txController.nonceTracker.getNonceLock(address);
    nonceLock.releaseLock();
    return nonceLock.nextNonce;
  }
  /**
   * Migrate address book state from old to new chainId.
   *
   * Address book state is keyed by the `networkStore` state from the network controller. This value is set to the
   * `networkId` for our built-in Infura networks, but it's set to the `chainId` for custom networks.
   * When this `chainId` value is changed for custom RPC endpoints, we need to migrate any contacts stored under the
   * old key to the new key.
   *
   * The `duplicate` parameter is used to specify that the contacts under the old key should not be removed. This is
   * useful in the case where two RPC endpoints shared the same set of contacts, and we're not sure which one each
   * contact belongs under. Duplicating the contacts under both keys is the only way to ensure they are not lost.
   *
   * @param {string} oldChainId - The old chainId
   * @param {string} newChainId - The new chainId
   * @param {boolean} [duplicate] - Whether to duplicate the addresses on both chainIds (default: false)
   */


  async migrateAddressBookState(oldChainId, newChainId, duplicate = false) {
    const {
      addressBook
    } = this.addressBookController.state;

    if (!addressBook[oldChainId]) {
      return;
    }

    for (const address of Object.keys(addressBook[oldChainId])) {
      const entry = addressBook[oldChainId][address];
      this.addressBookController.set(address, entry.name, newChainId, entry.memo);

      if (!duplicate) {
        this.addressBookController.delete(oldChainId, address);
      }
    }
  } //=============================================================================
  // CONFIG
  //=============================================================================
  // Log blocks

  /**
   * A method for selecting a custom URL for an ethereum RPC provider and updating it
   *
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} [nickname] - Nickname of the selected network.
   * @param {Object} [rpcPrefs] - RPC preferences.
   * @param {string} [rpcPrefs.blockExplorerUrl] - URL of block explorer for the chain.
   * @returns {Promise<string>} The RPC Target URL confirmed.
   */


  async updateAndSetCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname, rpcPrefs) {
    this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    await this.preferencesController.updateRpc({
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
    return rpcUrl;
  }
  /**
   * A method for selecting a custom URL for an ethereum RPC provider.
   *
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} nickname - Optional nickname of the selected network.
   * @param rpcPrefs
   * @returns {Promise<string>} The RPC Target URL confirmed.
   */


  async setCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
    const rpcSettings = frequentRpcListDetail.find(rpc => rpcUrl === rpc.rpcUrl);

    if (rpcSettings) {
      this.networkController.setRpcTarget(rpcSettings.rpcUrl, rpcSettings.chainId, rpcSettings.ticker, rpcSettings.nickname, rpcPrefs);
    } else {
      this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
      await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    }

    return rpcUrl;
  }
  /**
   * A method for deleting a selected custom URL.
   *
   * @param {string} rpcUrl - A RPC URL to delete.
   */


  async delCustomRpc(rpcUrl) {
    await this.preferencesController.removeFromFrequentRpcList(rpcUrl);
  }
  /**
   * Returns the first RPC info object that matches at least one field of the
   * provided search criteria. Returns null if no match is found
   *
   * @param {Object} rpcInfo - The RPC endpoint properties and values to check.
   * @returns {Object} rpcInfo found in the frequentRpcList
   */


  findCustomRpcBy(rpcInfo) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();

    for (const existingRpcInfo of frequentRpcListDetail) {
      for (const key of Object.keys(rpcInfo)) {
        if (existingRpcInfo[key] === rpcInfo[key]) {
          return existingRpcInfo;
        }
      }
    }

    return null;
  }

  async initializeThreeBox() {
    await this.threeBoxController.init();
  }
  /**
   * Sets the Ledger Live preference to use for Ledger hardware wallet support
   *
   * @param {string} transportType - The Ledger transport type.
   */


  async setLedgerTransportPreference(transportType) {
    const currentValue = this.preferencesController.getLedgerTransportPreference();
    const newValue = this.preferencesController.setLedgerTransportPreference(transportType);
    const keyring = await this.getKeyringForDevice(_hardwareWallets.DEVICE_NAMES.LEDGER);

    if (keyring !== null && keyring !== void 0 && keyring.updateTransportMethod) {
      return keyring.updateTransportMethod(newValue).catch(e => {
        // If there was an error updating the transport, we should
        // fall back to the original value
        this.preferencesController.setLedgerTransportPreference(currentValue);
        throw e;
      });
    }

    return undefined;
  }
  /**
   * A method for initializing storage the first time.
   *
   * @param {Object} initState - The default state to initialize with.
   * @private
   */


  recordFirstTimeInfo(initState) {
    if (!('firstTimeInfo' in initState)) {
      const version = this.platform.getVersion();
      initState.firstTimeInfo = {
        version,
        date: Date.now()
      };
    }
  } // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.

  /* eslint-disable accessor-pairs */

  /**
   * A method for recording whether the MetaMask user interface is open or not.
   *
   * @param {boolean} open
   */


  set isClientOpen(open) {
    this._isClientOpen = open;
    this.detectTokensController.isOpen = open;
  }
  /* eslint-enable accessor-pairs */

  /**
   * A method that is called by the background when all instances of metamask are closed.
   * Currently used to stop polling in the gasFeeController.
   */


  onClientClosed() {
    try {
      this.gasFeeController.stopPolling();
      this.appStateController.clearPollingTokens();
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).
   * Currently used to stop polling in the gasFeeController for only that environement type
   *
   * @param environmentType
   */


  onEnvironmentTypeClosed(environmentType) {
    const appStatePollingTokenType = _app.POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];
    const pollingTokensToDisconnect = this.appStateController.store.getState()[appStatePollingTokenType];
    pollingTokensToDisconnect.forEach(pollingToken => {
      this.gasFeeController.disconnectPoller(pollingToken);
      this.appStateController.removePollingToken(pollingToken, appStatePollingTokenType);
    });
  }
  /**
   * Adds a domain to the PhishingController safelist
   *
   * @param {string} hostname - the domain to safelist
   */


  safelistPhishingDomain(hostname) {
    return this.phishingController.bypass(hostname);
  }
  /**
   * Locks MetaMask
   */


  setLocked() {
    const [trezorKeyring] = this.keyringController.getKeyringsByType(_hardwareWallets.KEYRING_TYPES.TREZOR);

    if (trezorKeyring) {
      trezorKeyring.dispose();
    }

    return this.keyringController.setLocked();
  }

}

exports.default = MetamaskController;


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\debounce\index.js
      return function (require, module, exports) {
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

      };
    };
  }
}, {package:"debounce",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\through\\index.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\through\index.js
      return function (require, module, exports) {
(function (process){(function (){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\through\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\duplexer\\index.js", {"stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\duplexer\index.js
      return function (require, module, exports) {
var Stream = require("stream")
var writeMethods = ["write", "end", "destroy"]
var readMethods = ["resume", "pause"]
var readEvents = ["data", "close"]
var slice = Array.prototype.slice

module.exports = duplex

function forEach (arr, fn) {
    if (arr.forEach) {
        return arr.forEach(fn)
    }

    for (var i = 0; i < arr.length; i++) {
        fn(arr[i], i)
    }
}

function duplex(writer, reader) {
    var stream = new Stream()
    var ended = false

    forEach(writeMethods, proxyWriter)

    forEach(readMethods, proxyReader)

    forEach(readEvents, proxyStream)

    reader.on("end", handleEnd)

    writer.on("drain", function() {
      stream.emit("drain")
    })

    writer.on("error", reemit)
    reader.on("error", reemit)

    stream.writable = writer.writable
    stream.readable = reader.readable

    return stream

    function proxyWriter(methodName) {
        stream[methodName] = method

        function method() {
            return writer[methodName].apply(writer, arguments)
        }
    }

    function proxyReader(methodName) {
        stream[methodName] = method

        function method() {
            stream.emit(methodName)
            var func = reader[methodName]
            if (func) {
                return func.apply(reader, arguments)
            }
            reader.emit(methodName)
        }
    }

    function proxyStream(methodName) {
        reader.on(methodName, reemit)

        function reemit() {
            var args = slice.call(arguments)
            args.unshift(methodName)
            stream.emit.apply(stream, args)
        }
    }

    function handleEnd() {
        if (ended) {
            return
        }
        ended = true
        var args = slice.call(arguments)
        args.unshift("end")
        stream.emit.apply(stream, args)
    }

    function reemit(err) {
        stream.emit("error", err)
    }
}

      };
    };
  }
}, {package:"duplexer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\duplexer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\LocalStorageStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\LocalStorageStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class LocalStorageStore extends ObservableStore_1.ObservableStore {
    constructor(opts = {}) {
        if (!global.localStorage) {
            throw new Error('LocalStorageStore - can\'t find localStorage.');
        }
        super();
        if (!opts.storageKey) {
            throw new Error('LocalStorageStore - no storageKey specified.');
        }
        this._storageKey = opts.storageKey;
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        const serialized = global.localStorage.getItem(this._storageKey);
        return serialized ? JSON.parse(serialized) : undefined;
    }
    // write to persistence
    _putState(newState) {
        const serialized = JSON.stringify(newState);
        return global.localStorage.setItem(this._storageKey, serialized);
    }
}
exports.LocalStorageStore = LocalStorageStore;
//# sourceMappingURL=LocalStorageStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\LocalStorageStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState = {}) {
        super();
        // set init state
        this._state = initState;
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            const newState = Object.assign({}, state, partialState);
            this.putState(newState);
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\dist\transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\002.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\002.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 2;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.type === 'etherscan') {
        versionedData.data.config.provider.type = 'rpc';
        versionedData.data.config.provider.rpcTarget = 'https://rpc.metamask.io/';
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\002.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\003.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\003.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 3;
const oldTestRpc = 'https://rawtestrpc.metamask.io/';
const newTestRpc = 'https://testrpc.metamask.io/';
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {
        versionedData.data.config.provider.rpcTarget = newTestRpc;
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\003.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\004.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 4;
var _default = {
  version,

  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;

    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }

      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;

        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {// empty
    }

    return Promise.resolve(safeVersionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\004.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\012.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies our notices to delete their body after being read.

*/
const version = 12;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\012.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\019.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions as failed
whos nonce is too high

*/
const version = 19;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED) {
        return txMeta;
      }

      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.CONFIRMED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.SUBMITTED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);

      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }

      return txMeta;
    });
  }

  return newState;
}

function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;

  while (nonces.includes(highest)) {
    highest += 1;
  }

  return highest;
}

function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\019.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\011.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/
const version = 11;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\011.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\016.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 16;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }

      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\016.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\015.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 15;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\015.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\010.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the ShapeShiftController substate

*/
const version = 10;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\010.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\014.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes provider from config and moves it too NetworkController.

*/
const version = 14;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\014.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\020.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/
const version = 20;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\020.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\021.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the BlackListController from disk state

*/
const version = 21;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\021.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\009.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the CurrencyController substate

*/
const version = 9;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\009.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\027.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 27;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TRANSACTION_STATUSES.REJECTED);
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\027.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\022.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration adds submittedTime to the txMeta if it is not their

*/
const version = 22;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED || txMeta.submittedTime) {
        return txMeta;
      }

      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\022.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\026.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/
const version = 26;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }

  if (!state.KeyringController.walletNicknames) {
    return state;
  }

  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\026.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\023.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration removes transactions that are no longer usefull down to 40 total

*/
const version = 23;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;

    if (transactions.length <= 40) {
      return newState;
    }

    const reverseTxList = transactions.reverse();
    let stripping = true;

    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED || txMeta.status === _transaction.TRANSACTION_STATUSES.REJECTED || txMeta.status === _transaction.TRANSACTION_STATUSES.CONFIRMED || txMeta.status === _transaction.TRANSACTION_STATUSES.DROPPED;
      });

      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }

    newState.TransactionController.transactions = reverseTxList.reverse();
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\023.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\025.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _util = require("../lib/util");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 25;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TRANSACTION_STATUSES.UNAPPROVED) {
          return txMeta;
        }

        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }

  return newState;
}

function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  }; // apply only keys in the whiteList

  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\025.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\017.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions who were retried and marked as failed to submitted

*/
const version = 17;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED) {
        return txMeta;
      }

      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\017.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\024.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/
const version = 24;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.TransactionController) {
    return newState;
  }

  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }

    return txMeta;
  });
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\024.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\035.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Removes the deprecated 'seedWords' state

*/
const version = 35;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\035.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\034.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 34;
/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\034.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\030.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

removes invalid chaids from preferences and networkController for custom rpcs

*/
const version = 30;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;

    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }

  if (state.NetworkController) {
    if (newState.NetworkController.network && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }

    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\030.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\036.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 36;
/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\036.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\033.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Cleans up notices and assocated notice controller code

*/
const version = 33;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state; // transform state here

  if (state.NoticeController) {
    delete newState.NoticeController;
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\033.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\032.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 32;
/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {}; // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version

    PreferencesController.completedUiMigration = betaUI;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\032.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\044.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 44;
/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\044.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\039.js", {"../../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';

function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}
/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];

    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }

    const accountTokens = PreferencesController.accountTokens || {};

    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];

        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];

            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }

  return state;
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\039.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\046.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 46;
/**
 * Delete {@code ABTestController} state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\046.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\028.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 28;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\028.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\041.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 41;
/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\041.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\040.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 40;
/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\040.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\042.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 42;
/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\042.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\013.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/
const version = 13;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;

  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\013.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\047.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 47;
/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\047.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\045.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 45;
/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];

function transformState(state) {
  var _state$PreferencesCon;

  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }

  return state;
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\045.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\049.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 49;
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    var _state$MetaMetricsCon;

    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = (_state$MetaMetricsCon = state.MetaMetricsController) !== null && _state$MetaMetricsCon !== void 0 ? _state$MetaMetricsCon : {};

    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }

    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }

    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\049.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\051.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 51;
/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NetworkControl, _NETWORK_TYPE_TO_ID_M;

  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_NETWORK_TYPE_TO_ID_M = _network.NETWORK_TYPE_TO_ID_MAP[type]) === null || _NETWORK_TYPE_TO_ID_M === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M.chainId;

  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\051.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\052.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 52;
/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};

    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};

        if (accountTokens[address][_network.NETWORK_TYPE_RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPE_RPC];
          });
        }

        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.MAINNET:
              newAccountTokens[address][_network.MAINNET_CHAIN_ID] = accountTokens[address][_network.MAINNET];
              break;

            case _network.ROPSTEN:
              newAccountTokens[address][_network.ROPSTEN_CHAIN_ID] = accountTokens[address][_network.ROPSTEN];
              break;

            case _network.RINKEBY:
              newAccountTokens[address][_network.RINKEBY_CHAIN_ID] = accountTokens[address][_network.RINKEBY];
              break;

            case _network.GOERLI:
              newAccountTokens[address][_network.GOERLI_CHAIN_ID] = accountTokens[address][_network.GOERLI];
              break;

            case _network.KOVAN:
              newAccountTokens[address][_network.KOVAN_CHAIN_ID] = accountTokens[address][_network.KOVAN];
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountTokens = newAccountTokens;
    }

    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};

        if (accountHiddenTokens[address][_network.NETWORK_TYPE_RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPE_RPC];
          });
        }

        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.MAINNET:
              newAccountHiddenTokens[address][_network.MAINNET_CHAIN_ID] = accountHiddenTokens[address][_network.MAINNET];
              break;

            case _network.ROPSTEN:
              newAccountHiddenTokens[address][_network.ROPSTEN_CHAIN_ID] = accountHiddenTokens[address][_network.ROPSTEN];
              break;

            case _network.RINKEBY:
              newAccountHiddenTokens[address][_network.RINKEBY_CHAIN_ID] = accountHiddenTokens[address][_network.RINKEBY];
              break;

            case _network.GOERLI:
              newAccountHiddenTokens[address][_network.GOERLI_CHAIN_ID] = accountHiddenTokens[address][_network.GOERLI];
              break;

            case _network.KOVAN:
              newAccountHiddenTokens[address][_network.KOVAN_CHAIN_ID] = accountHiddenTokens[address][_network.KOVAN];
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\052.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\043.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 43;
/**
 * Remove unused 'currentAccountTab' state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\043.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\055.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 55;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';

function transformState(state) {
  var _state$IncomingTransa;

  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork, // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _NETWORK_TYPE_TO_ID_M, _NETWORK_TYPE_TO_ID_M2;

      return (_NETWORK_TYPE_TO_ID_M = (_NETWORK_TYPE_TO_ID_M2 = _network.NETWORK_TYPE_TO_ID_MAP[key]) === null || _NETWORK_TYPE_TO_ID_M2 === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M2.chainId) !== null && _NETWORK_TYPE_TO_ID_M !== void 0 ? _NETWORK_TYPE_TO_ID_M : UNKNOWN_CHAIN_ID_KEY;
    }); // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.

    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\055.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\050.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;

      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\050.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\054.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 54;

function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}
/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.PreferencesController) {
    return newState;
  }

  const tokens = newState.PreferencesController.tokens || []; // Filter out any tokens with corrupted decimal values

  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));

  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }

  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;

  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];

      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || []; // Filter out any tokens with corrupted decimal values

          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals)); // In the case of a decimal value type string, convert to a number.

          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }

          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }

  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\054.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\056.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 56;
/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;

    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }

    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\056.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\061.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 61;
/**
 * Initialize attributes related to recovery seed phrase reminder
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const currentTime = new Date().getTime();

  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\061.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\064.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TRANSACTION_TYPES.SIMPLE_SEND

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
      }

      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
          }

          return txEvent;
        });
      }
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\064.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\065.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 65;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController) {
    var _state$OnboardingCont;

    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = (_state$OnboardingCont = state.OnboardingController) !== null && _state$OnboardingCont !== void 0 ? _state$OnboardingCont : {};

    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }

    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\065.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\060.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';
/**
 * Removes the support survey notification
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NotificationCo;

  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;

  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;

    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\060.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\058.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 58;
/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\058.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\062.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 62;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;

    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\062.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\069.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _app = require("../../../shared/constants/app");

const version = 69;
/**
 * Adds the `subjectType` property to all subject metadata.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$SubjectMetadat;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state; // mutate SubjectMetadataController.subjectMetadata in place

    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _app.SUBJECT_TYPES.EXTENSION : _app.SUBJECT_TYPES.WEBSITE;
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\069.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\059.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 59;
/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams, _tx$chainId;

      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${(_tx$chainId = tx.chainId) !== null && _tx$chainId !== void 0 ? _tx$chainId : tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TRANSACTION_TYPES.CANCEL && tx.type !== _transaction.TRANSACTION_TYPES.RETRY);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\059.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\031.js", {"lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number
const version = 31;
/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;

  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\031.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\037.js", {"@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _controllers = require("@metamask/controllers");

const version = 37;
/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {}; // add all of the chainIds to a set

    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    }); // fill the chainId object with the entries with the matching chainId

    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};

      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;

          if (_controllers.util.normalizeEnsName(ab[address].name)) {
            ab[address].isEns = true;
          }

          newAddressBook[id][address] = ab[address];
        }
      }
    }

    state.AddressBookController.addressBook = newAddressBook;
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\037.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\008.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\008.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 8;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = _objectSpread(_objectSpread({}, state), {}, {
    NoticeController: {
      noticesList: state.noticesList || []
    }
  });

  delete newState.noticesList;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\008.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\006.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\006.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 6;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function migrateState(state) {
  const keyringSubstate = state.KeyringController; // add new state

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  }); // rm old state


  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\006.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\005.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\005.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 5;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  });

  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\005.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\007.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\007.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 7;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = _objectSpread(_objectSpread({}, state), {}, {
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  });

  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\007.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\029.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","./fail-tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\fail-tx.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\029.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transaction = require("../../../shared/constants/transaction");

var _failTx = _interopRequireDefault(require("./fail-tx"));

// next version number
const version = 29; // time

const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;
/*

normalizes txParams on unconfirmed txs

*/

var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TRANSACTION_STATUSES.APPROVED;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\029.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\038.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\038.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 38;
/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;

  if (abTests.fullScreenVsPopup) {
    return state;
  }

  return _objectSpread(_objectSpread({}, state), {}, {
    ABTestController: _objectSpread(_objectSpread({}, ABTestControllerState), {}, {
      abTests: _objectSpread(_objectSpread({}, abTests), {}, {
        fullScreenVsPopup: 'control'
      })
    })
  });
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\038.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\057.js", {"../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\057.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

const version = 57;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions, // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }

      return tx.id;
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\057.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\066.js", {"../../../shared/constants/hardware-wallets":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\hardware-wallets.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\066.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 66;
/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.WEBHID : _hardwareWallets.LEDGER_TRANSPORT_TYPES.U2F;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: _objectSpread(_objectSpread({}, state === null || state === void 0 ? void 0 : state.PreferencesController), {}, {
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.LIVE : defaultTransportType
    })
  });

  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\066.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\053.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\053.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 53;
/**
 * Deprecate transactionCategory and consolidate on 'type'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TRANSACTION_TYPES.RETRY && transaction.type !== _transaction.TRANSACTION_TYPES.CANCEL) {
          transaction.type = transaction.transactionCategory;
        }

        delete transaction.transactionCategory;
      }
    });
  }

  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = _objectSpread(_objectSpread({}, transaction), {}, {
          type: _transaction.TRANSACTION_TYPES.INCOMING
        });
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\053.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\048.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\048.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 48;
/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;

function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;

  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings; // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key

  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));

  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;

    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }

    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  } // 3.  Add localhost network to frequentRpcListDetail.


  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }

  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }

  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  }); // 4.  Delete CachedBalancesController.cachedBalances

  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances; // 5.  Convert transactions metamaskNetworkId to decimal if they are hex

  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;

      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  } // 6.  Convert address book keys from decimal to hex


  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);

      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }

      delete addressBook[networkKey];
    }
  }); // 7.  Delete localhost key in IncomingTransactionsController

  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost; // 8.  Merge 'localhost' tokens into 'rpc' tokens

  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;

  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;

      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];

      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];

        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }

      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }

  return state;
}
/**
 * Merges the two given keys for the given address book in place.
 *
 * @param addressBook
 * @param networkKey
 * @param chainIdKey
 */


function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {}; // For the new entries, start by copying the existing entries for the chainId

  const newEntries = _objectSpread({}, addressBook[chainIdKey]); // For each address of the old/networkId key entries


  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {}; // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry

      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;

        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}
/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @param networkEntries
 * @param chainId
 */


function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}
/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @param localhostTokens
 * @param rpcTokens
 * @returns {Array<Object>}
 */


function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push(_objectSpread(_objectSpread({}, localhostTokensMap[tokenAddress]), rpcTokensMap[tokenAddress]));
  });
  return mergedTokens;

  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }

      return map;
    }, {});
  }
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\048.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\063.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\063.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 63;
/**
 * Moves token state from preferences controller to TokensController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;

  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};

  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];

        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = _objectSpread(_objectSpread({}, newAllTokens[chainId]), {}, {
            [accountAddress]: tokensArray
          });
        }
      });
    });
  }

  const newAllIgnoredTokens = {};

  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];

        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = _objectSpread(_objectSpread({}, newAllIgnoredTokens[chainId]), {}, {
            [accountAddress]: ignoredTokensArray
          });
        }
      });
    });
  }

  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }

  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\063.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\068.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/objectWithoutProperties":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\objectWithoutProperties.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\068.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _lodash = require("lodash");

const _excluded = ["PermissionsController", "PermissionsMetadata"],
      _excluded2 = ["name", "icon", "extensionId"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const version = 68;
/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {}
  } = state,
        remainingState = (0, _objectWithoutProperties2.default)(state, _excluded);
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return _objectSpread(_objectSpread({}, remainingState), {}, {
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  });
}

function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;
  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry; // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.

    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);

    const newPermission = _objectSpread(_objectSpread({}, ethAccountsPermission), {}, {
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    }); // We never used this, and just omit it in the new system.


    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}

function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */
  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null
    } = metadata,
          other = (0, _objectWithoutProperties2.default)(metadata, _excluded2); // We're getting rid of these.

    delete other.lastUpdated;
    delete other.host;

    if (origin) {
      transformed[origin] = _objectSpread(_objectSpread({
        name,
        iconUrl: icon,
        extensionId
      }, other), {}, {
        origin
      });
    }

    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\068.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\067.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bignumber.js\\bignumber.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\067.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _network = require("../../../shared/constants/network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);

const version = 67;
/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;

  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};

  if (preferences.showTestNetworks) {
    return state;
  }

  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};

  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);

  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));

  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });

  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;

  const newState = _objectSpread(_objectSpread({}, state), {}, {
    PreferencesController: _objectSpread(_objectSpread({}, PreferencesController), {}, {
      preferences: _objectSpread(_objectSpread({}, preferences), {}, {
        showTestNetworks: userHasUsedATestnet
      })
    })
  });

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\067.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");

/*

This migration updates "transaction state history" to diffs style

*/
const version = 18;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      } // has history: migrate


      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history) // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }

  return newState;
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\018.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base32-encode\\index.js", {"to-data-view":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\to-data-view\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\base32-encode\index.js
      return function (require, module, exports) {
var toDataView = require('to-data-view')

var RFC4648 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
var RFC4648_HEX = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
var CROCKFORD = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'

module.exports = function base32Encode (data, variant, options) {
  options = options || {}
  var alphabet, defaultPadding

  switch (variant) {
    case 'RFC3548':
    case 'RFC4648':
      alphabet = RFC4648
      defaultPadding = true
      break
    case 'RFC4648-HEX':
      alphabet = RFC4648_HEX
      defaultPadding = true
      break
    case 'Crockford':
      alphabet = CROCKFORD
      defaultPadding = false
      break
    default:
      throw new Error('Unknown base32 variant: ' + variant)
  }

  var padding = (options.padding !== undefined ? options.padding : defaultPadding)
  var view = toDataView(data)

  var bits = 0
  var value = 0
  var output = ''

  for (var i = 0; i < view.byteLength; i++) {
    value = (value << 8) | view.getUint8(i)
    bits += 8

    while (bits >= 5) {
      output += alphabet[(value >>> (bits - 5)) & 31]
      bits -= 5
    }
  }

  if (bits > 0) {
    output += alphabet[(value << (5 - bits)) & 31]
  }

  if (padding) {
    while ((output.length % 8) !== 0) {
      output += '='
    }
  }

  return output
}

      };
    };
  }
}, {package:"base32-encode",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base32-encode\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\resolver.js", {"./contracts/registry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\registry.js","./contracts/resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\resolver.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@ensdomains/content-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\index.js","eth-ens-namehash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-ens-namehash\\index.js","ethjs-contract":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\ens-ipfs\resolver.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveEnsToIpfsContentId;

var _ethEnsNamehash = _interopRequireDefault(require("eth-ens-namehash"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethjsContract = _interopRequireDefault(require("ethjs-contract"));

var _contentHash = _interopRequireDefault(require("@ensdomains/content-hash"));

var _registry = _interopRequireDefault(require("./contracts/registry"));

var _resolver = _interopRequireDefault(require("./contracts/resolver"));

async function resolveEnsToIpfsContentId({
  provider,
  name
}) {
  const eth = new _ethjsQuery.default(provider);

  const hash = _ethEnsNamehash.default.hash(name);

  const contract = new _ethjsContract.default(eth); // lookup registry

  const chainId = Number.parseInt(await eth.net_version(), 10);
  const registryAddress = getRegistryForChainId(chainId);

  if (!registryAddress) {
    throw new Error(`EnsIpfsResolver - no known ens-ipfs registry for chainId "${chainId}"`);
  }

  const Registry = contract(_registry.default).at(registryAddress); // lookup resolver

  const resolverLookupResult = await Registry.resolver(hash);
  const resolverAddress = resolverLookupResult[0];

  if (hexValueIsEmpty(resolverAddress)) {
    throw new Error(`EnsIpfsResolver - no resolver found for name "${name}"`);
  }

  const Resolver = contract(_resolver.default).at(resolverAddress);
  const isEIP1577Compliant = await Resolver.supportsInterface('0xbc1c58d1');
  const isLegacyResolver = await Resolver.supportsInterface('0xd8389dc5');

  if (isEIP1577Compliant[0]) {
    const contentLookupResult = await Resolver.contenthash(hash);
    const rawContentHash = contentLookupResult[0];

    let decodedContentHash = _contentHash.default.decode(rawContentHash);

    const type = _contentHash.default.getCodec(rawContentHash);

    if (type === 'ipfs-ns' || type === 'ipns-ns') {
      decodedContentHash = _contentHash.default.helpers.cidV0ToV1Base32(decodedContentHash);
    }

    return {
      type,
      hash: decodedContentHash
    };
  }

  if (isLegacyResolver[0]) {
    // lookup content id
    const contentLookupResult = await Resolver.content(hash);
    const content = contentLookupResult[0];

    if (hexValueIsEmpty(content)) {
      throw new Error(`EnsIpfsResolver - no content ID found for name "${name}"`);
    }

    return {
      type: 'swarm-ns',
      hash: content.slice(2)
    };
  }

  throw new Error(`EnsIpfsResolver - the resolver for name "${name}" is not standard, it should either supports contenthash() or content()`);
}

function hexValueIsEmpty(value) {
  return [undefined, null, '0x', '0x0', '0x0000000000000000000000000000000000000000000000000000000000000000'].includes(value);
}
/**
 * Returns the registry address for the given chain ID
 *
 * @param {number} chainId - the chain ID
 * @returns {string|null} the registry address if known, null otherwise
 */


function getRegistryForChainId(chainId) {
  switch (chainId) {
    case 1:
    case 3:
    case 4:
    case 5:
      // Mainnet, Ropsten, Rinkeby, and Goerli, respectively, use the same address
      return '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';

    default:
      return null;
  }
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\resolver.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOriginMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createOriginMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOriginMiddleware;

/**
 * Returns a middleware that appends the DApp origin to request
 *
 * @param {{ origin: string }} opts - The middleware options
 * @returns {Function}
 */
function createOriginMiddleware(opts) {
  return function originMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  _,
  /** @type {Function} */
  next) {
    req.origin = opts.origin;
    next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOriginMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createTabIdMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createTabIdMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTabIdMiddleware;

/**
 * Returns a middleware that appends the DApp TabId to the request
 *
 * @param {{ tabId: number }} opts - The middleware options
 * @returns {Function}
 */
function createTabIdMiddleware(opts) {
  return function tabIdMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  _,
  /** @type {Function} */
  next) {
    req.tabId = opts.tabId;
    next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createTabIdMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\index.browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\nanoid\index.browser.js
      return function (require, module, exports) {
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

if ("development" !== 'production') {
  // All bundlers will remove this block in production bundle
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
      'If you don’t need unpredictable IDs, you can use `nanoid/non-secure`. ' +
      'For secure ID install `expo-random` locally and use `nanoid/async`.'
    )
  }
  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {
    throw new Error(
      'Your browser does not have secure random generator. ' +
      'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}

var crypto = self.crypto || self.msCrypto

// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

module.exports = function (size) {
  var id = ''
  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))
  i = size || 21

  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // We can’t use bytes bigger than the alphabet. 63 is 00111111 bitmask.
    // This mask reduces random byte 0-255 to 0-63 values.
    // There is no need in `|| ''` and `* 1.6` hacks in here,
    // because bitmask trim bytes exact to alphabet size.
    id += url[bytes[i] & 63]
  }
  return id
}

      };
    };
  }
}, {package:"nanoid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\index.browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createMetaRPCHandler.js", {"eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createMetaRPCHandler.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

const createMetaRPCHandler = (api, outStream) => {
  return async data => {
    if (outStream._writableState.ended) {
      return;
    }

    if (!api[data.method]) {
      outStream.write({
        jsonrpc: '2.0',
        error: _ethRpcErrors.ethErrors.rpc.methodNotFound({
          message: `${data.method} not found`
        }),
        id: data.id
      });
      return;
    }

    let result;
    let error;

    try {
      result = await api[data.method](...data.params);
    } catch (err) {
      error = err;
    }

    if (outStream._writableState.ended) {
      if (error) {
        console.error(error);
      }

      return;
    }

    if (error) {
      outStream.write({
        jsonrpc: '2.0',
        error: (0, _ethRpcErrors.serializeError)(error, {
          shouldIncludeStack: true
        }),
        id: data.id
      });
    } else {
      outStream.write({
        jsonrpc: '2.0',
        result,
        id: data.id
      });
    }
  };
};

var _default = createMetaRPCHandler;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createMetaRPCHandler.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-middleware-stream\\engineStream.js", {"readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-middleware-stream\engineStream.js
      return function (require, module, exports) {
const DuplexStream = require('readable-stream').Duplex

module.exports = createEngineStream

function createEngineStream({ engine }) {
  if (!engine) throw new Error('Missing engine parameter!')
  const stream = new DuplexStream({ objectMode: true, read, write })
  // forward notifications
  if (engine.on) {
    engine.on('notification', (message) => {
      stream.push(message)
    })
  }
  return stream

  function read () {
    return false
  }
  function write (req, encoding, cb) {
    engine.handle(req, (err, res) => {
      this.push(res)
    })
    cb()
  }
}

      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-middleware-stream\\engineStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ComposableObservableStore.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\ComposableObservableStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _controllers = require("@metamask/controllers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {__import__('@metamask/controllers').ControllerMessenger} ControllerMessenger
 */

/**
 * An ObservableStore that can composes a flat
 * structure of child stores based on configuration
 */
class ComposableObservableStore extends _obsStore.ObservableStore {
  /**
   * Describes which stores are being composed. The key is the name of the
   * store, and the value is either an ObserableStore, or a controller that
   * extends one of the two base controllers in the `@metamask/controllers`
   * package.
   *
   * @type {Record<string, Object>}
   */

  /**
   * Create a new store
   *
   * @param {Object} options
   * @param {Object} [options.config] - Map of internal state keys to child stores
   * @param {ControllerMessenger} options.controllerMessenger - The controller
   *   messenger, used for subscribing to events from BaseControllerV2-based
   *   controllers.
   * @param {Object} [options.state] - The initial store state
   * @param {boolean} [options.persist] - Whether or not to apply the persistence for v2 controllers
   */
  constructor({
    config,
    controllerMessenger,
    state,
    persist
  }) {
    super(state);
    (0, _defineProperty2.default)(this, "config", {});
    this.persist = persist;
    this.controllerMessenger = controllerMessenger;

    if (config) {
      this.updateStructure(config);
    }
  }
  /**
   * Composes a new internal store subscription structure
   *
   * @param {Record<string, Object>} config - Describes which stores are being
   *   composed. The key is the name of the store, and the value is either an
   *   ObserableStore, or a controller that extends one of the two base
   *   controllers in the `@metamask/controllers` package.
   */


  updateStructure(config) {
    this.config = config;
    this.removeAllListeners();

    for (const key of Object.keys(config)) {
      if (!config[key]) {
        throw new Error(`Undefined '${key}'`);
      }

      const store = config[key];

      if (store.subscribe) {
        config[key].subscribe(state => {
          this.updateState({
            [key]: state
          });
        });
      } else {
        this.controllerMessenger.subscribe(`${store.name}:stateChange`, state => {
          let updatedState = state;

          if (this.persist) {
            updatedState = (0, _controllers.getPersistentState)(state, config[key].metadata);
          }

          this.updateState({
            [key]: updatedState
          });
        });
      }
    }
  }
  /**
   * Merges all child store state into a single object rather than
   * returning an object keyed by child store class name
   *
   * @returns {Object} Object containing merged child store state
   */


  getFlatState() {
    if (!this.config) {
      return {};
    }

    let flatState = {};

    for (const key of Object.keys(this.config)) {
      const controller = this.config[key];
      const state = controller.getState ? controller.getState() : controller.state;
      flatState = _objectSpread(_objectSpread({}, flatState), state);
    }

    return flatState;
  }

}

exports.default = ComposableObservableStore;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ComposableObservableStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createLoggerMiddleware.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createLoggerMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createLoggerMiddleware;

var _loglevel = _interopRequireDefault(require("loglevel"));

/**
 * Returns a middleware that logs RPC activity
 *
 * @param {{ origin: string }} opts - The middleware options
 * @returns {Function}
 */
function createLoggerMiddleware(opts) {
  return function loggerMiddleware(
  /** @type {any} */
  req,
  /** @type {any} */
  res,
  /** @type {Function} */
  next) {
    next((
    /** @type {Function} */
    cb) => {
      if (res.error) {
        _loglevel.default.error('Error in RPC response:\n', res);
      }

      if (req.isMetamaskInternal) {
        return;
      }

      _loglevel.default.info(`RPC (${opts.origin}):`, req, '->', res);

      cb();
    });
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createLoggerMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOnboardingMiddleware.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","extensionizer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extensionizer\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\createOnboardingMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnboardingMiddleware;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _extensionizer = _interopRequireDefault(require("extensionizer"));

/**
 * Returns a middleware that intercepts `wallet_registerOnboarding` messages
 *
 * @param {{ location: string, registerOnboarding: Function }} opts - The middleware options
 * @returns {(req: any, res: any, next: Function, end: Function) => void}
 */
function createOnboardingMiddleware({
  location,
  registerOnboarding
}) {
  return async function originMiddleware(req, res, next, end) {
    try {
      if (req.method !== 'wallet_registerOnboarding') {
        next();
        return;
      }

      if (req.tabId && req.tabId !== _extensionizer.default.tabs.TAB_ID_NONE) {
        await registerOnboarding(location, req.tabId);
      } else {
        _loglevel.default.debug(`'wallet_registerOnboarding' message from ${location} ignored due to missing tabId`);
      }

      res.result = true;
      end();
    } catch (error) {
      end(error);
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOnboardingMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\onboarding.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\onboarding.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} InitState
 * @property {boolean} seedPhraseBackedUp Indicates whether the user has completed the seed phrase backup challenge
 * @property {boolean} completedOnboarding Indicates whether the user has completed the onboarding flow
 */

/**
 * @typedef {Object} OnboardingOptions
 * @property {InitState} initState The initial controller state
 */

/**
 * Controller responsible for maintaining
 * state related to onboarding
 */
class OnboardingController {
  /**
   * Creates a new controller instance
   *
   * @param {OnboardingOptions} [opts] - Controller configuration parameters
   */
  constructor(opts = {}) {
    (0, _defineProperty2.default)(this, "registerOnboarding", async (location, tabId) => {
      if (this.completedOnboarding) {
        _loglevel.default.debug('Ignoring registerOnboarding; user already onboarded');

        return;
      }

      const onboardingTabs = _objectSpread({}, this.store.getState().onboardingTabs);

      if (!onboardingTabs[location] || onboardingTabs[location] !== tabId) {
        _loglevel.default.debug(`Registering onboarding tab at location '${location}' with tabId '${tabId}'`);

        onboardingTabs[location] = tabId;
        this.store.updateState({
          onboardingTabs
        });
      }
    });
    const initialTransientState = {
      onboardingTabs: {}
    };

    const initState = _objectSpread(_objectSpread({
      seedPhraseBackedUp: null,
      firstTimeFlowType: null,
      completedOnboarding: false
    }, opts.initState), initialTransientState);

    this.store = new _obsStore.ObservableStore(initState);
  }

  setSeedPhraseBackedUp(newSeedPhraseBackUpState) {
    this.store.updateState({
      seedPhraseBackedUp: newSeedPhraseBackUpState
    });
  } // /**
  //  * Sets the completedOnboarding state to true, indicating that the user has completed the
  //  * onboarding process.
  //  */


  completeOnboarding() {
    this.store.updateState({
      completedOnboarding: true
    });
    return Promise.resolve(true);
  }
  /**
   * Setter for the `firstTimeFlowType` property
   *
   * @param {string} type - Indicates the type of first time flow - create or import - the user wishes to follow
   */


  setFirstTimeFlowType(type) {
    this.store.updateState({
      firstTimeFlowType: type
    });
  }
  /**
   * Registering a site as having initiated onboarding
   *
   * @param {string} location - The location of the site registering
   * @param {string} tabId - The id of the tab registering
   */


}

exports.default = OnboardingController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\onboarding.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\app-state.js", {"../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\app-state.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _metamaskController = require("../metamask-controller");

var _time = require("../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class AppStateController extends _events.default {
  /**
   * @param {Object} opts
   */
  constructor(opts = {}) {
    const {
      addUnlockListener,
      isUnlocked,
      initState,
      onInactiveTimeout,
      showUnlockRequest,
      preferencesStore,
      qrHardwareStore
    } = opts;
    super();

    this.onInactiveTimeout = onInactiveTimeout || (() => undefined);

    this.store = new _obsStore.ObservableStore(_objectSpread(_objectSpread({
      timeoutMinutes: 0,
      connectedStatusPopoverHasBeenShown: true,
      defaultHomeActiveTabName: null,
      browserEnvironment: {},
      popupGasPollTokens: [],
      notificationGasPollTokens: [],
      fullScreenGasPollTokens: [],
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: new Date().getTime(),
      collectiblesDetectionNoticeDismissed: false,
      enableEIP1559V2NoticeDismissed: false,
      showTestnetMessageInDropdown: true,
      trezorModel: null
    }, initState), {}, {
      qrHardware: {},
      collectiblesDropdownState: {}
    }));
    this.timer = null;
    this.isUnlocked = isUnlocked;
    this.waitingForUnlock = [];
    addUnlockListener(this.handleUnlock.bind(this));
    this._showUnlockRequest = showUnlockRequest;
    preferencesStore.subscribe(({
      preferences
    }) => {
      const currentState = this.store.getState();

      if (currentState.timeoutMinutes !== preferences.autoLockTimeLimit) {
        this._setInactiveTimeout(preferences.autoLockTimeLimit);
      }
    });
    qrHardwareStore.subscribe(state => {
      this.store.updateState({
        qrHardware: state
      });
    });
    const {
      preferences
    } = preferencesStore.getState();

    this._setInactiveTimeout(preferences.autoLockTimeLimit);
  }
  /**
   * Get a Promise that resolves when the extension is unlocked.
   * This Promise will never reject.
   *
   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification
   * popup should be opened.
   * @returns {Promise<void>} A promise that resolves when the extension is
   * unlocked, or immediately if the extension is already unlocked.
   */


  getUnlockPromise(shouldShowUnlockRequest) {
    return new Promise(resolve => {
      if (this.isUnlocked()) {
        resolve();
      } else {
        this.waitForUnlock(resolve, shouldShowUnlockRequest);
      }
    });
  }
  /**
   * Adds a Promise's resolve function to the waitingForUnlock queue.
   * Also opens the extension popup if specified.
   *
   * @param {Promise.resolve} resolve - A Promise's resolve function that will
   * be called when the extension is unlocked.
   * @param {boolean} shouldShowUnlockRequest - Whether the extension notification
   * popup should be opened.
   */


  waitForUnlock(resolve, shouldShowUnlockRequest) {
    this.waitingForUnlock.push({
      resolve
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);

    if (shouldShowUnlockRequest) {
      this._showUnlockRequest();
    }
  }
  /**
   * Drains the waitingForUnlock queue, resolving all the related Promises.
   */


  handleUnlock() {
    if (this.waitingForUnlock.length > 0) {
      while (this.waitingForUnlock.length > 0) {
        this.waitingForUnlock.shift().resolve();
      }

      this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
    }
  }
  /**
   * Sets the default home tab
   *
   * @param {string} [defaultHomeActiveTabName] - the tab name
   */


  setDefaultHomeActiveTabName(defaultHomeActiveTabName) {
    this.store.updateState({
      defaultHomeActiveTabName
    });
  }
  /**
   * Record that the user has seen the connected status info popover
   */


  setConnectedStatusPopoverHasBeenShown() {
    this.store.updateState({
      connectedStatusPopoverHasBeenShown: true
    });
  }
  /**
   * Record that the user has been shown the recovery phrase reminder.
   */


  setRecoveryPhraseReminderHasBeenShown() {
    this.store.updateState({
      recoveryPhraseReminderHasBeenShown: true
    });
  }
  /**
   * Record the timestamp of the last time the user has seen the recovery phrase reminder
   *
   * @param {number} lastShown - timestamp when user was last shown the reminder.
   */


  setRecoveryPhraseReminderLastShown(lastShown) {
    this.store.updateState({
      recoveryPhraseReminderLastShown: lastShown
    });
  }
  /**
   * Sets the last active time to the current time.
   */


  setLastActiveTime() {
    this._resetTimer();
  }
  /**
   * Sets the inactive timeout for the app
   *
   * @private
   * @param {number} timeoutMinutes - The inactive timeout in minutes.
   */


  _setInactiveTimeout(timeoutMinutes) {
    this.store.updateState({
      timeoutMinutes
    });

    this._resetTimer();
  }
  /**
   * Resets the internal inactive timer
   *
   * If the {@code timeoutMinutes} state is falsy (i.e., zero) then a new
   * timer will not be created.
   *
   * @private
   */


  _resetTimer() {
    const {
      timeoutMinutes
    } = this.store.getState();

    if (this.timer) {
      clearTimeout(this.timer);
    }

    if (!timeoutMinutes) {
      return;
    }

    this.timer = setTimeout(() => this.onInactiveTimeout(), timeoutMinutes * _time.MINUTE);
  }
  /**
   * Sets the current browser and OS environment
   *
   * @param os
   * @param browser
   */


  setBrowserEnvironment(os, browser) {
    this.store.updateState({
      browserEnvironment: {
        os,
        browser
      }
    });
  }
  /**
   * Adds a pollingToken for a given environmentType
   *
   * @param pollingToken
   * @param pollingTokenType
   */


  addPollingToken(pollingToken, pollingTokenType) {
    const prevState = this.store.getState()[pollingTokenType];
    this.store.updateState({
      [pollingTokenType]: [...prevState, pollingToken]
    });
  }
  /**
   * removes a pollingToken for a given environmentType
   *
   * @param pollingToken
   * @param pollingTokenType
   */


  removePollingToken(pollingToken, pollingTokenType) {
    const prevState = this.store.getState()[pollingTokenType];
    this.store.updateState({
      [pollingTokenType]: prevState.filter(token => token !== pollingToken)
    });
  }
  /**
   * clears all pollingTokens
   */


  clearPollingTokens() {
    this.store.updateState({
      popupGasPollTokens: [],
      notificationGasPollTokens: [],
      fullScreenGasPollTokens: []
    });
  }
  /**
   * Sets whether the testnet dismissal link should be shown in the network dropdown
   *
   * @param showTestnetMessageInDropdown
   */


  setShowTestnetMessageInDropdown(showTestnetMessageInDropdown) {
    this.store.updateState({
      showTestnetMessageInDropdown
    });
  }
  /**
   * Sets a property indicating the model of the user's Trezor hardware wallet
   *
   * @param trezorModel - The Trezor model.
   */


  setTrezorModel(trezorModel) {
    this.store.updateState({
      trezorModel
    });
  }
  /**
   * A setter for the `collectiblesDetectionNoticeDismissed` property
   *
   * @param collectiblesDetectionNoticeDismissed
   */


  setCollectiblesDetectionNoticeDismissed(collectiblesDetectionNoticeDismissed) {
    this.store.updateState({
      collectiblesDetectionNoticeDismissed
    });
  }
  /**
   * A setter for the `enableEIP1559V2NoticeDismissed` property
   *
   * @param enableEIP1559V2NoticeDismissed
   */


  setEnableEIP1559V2NoticeDismissed(enableEIP1559V2NoticeDismissed) {
    this.store.updateState({
      enableEIP1559V2NoticeDismissed
    });
  }
  /**
   * A setter for the `collectiblesDropdownState` property
   *
   * @param collectiblesDropdownState
   */


  updateCollectibleDropDownState(collectiblesDropdownState) {
    this.store.updateState({
      collectiblesDropdownState
    });
  }

}

exports.default = AppStateController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\app-state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\alert.js", {"../../../shared/constants/alerts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\alerts.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\alert.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _alerts = require("../../../shared/constants/alerts");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} AlertControllerInitState
 * @property {Object} alertEnabledness - A map of alerts IDs to booleans, where
 * `true` indicates that the alert is enabled and shown, and `false` the opposite.
 * @property {Object} unconnectedAccountAlertShownOrigins - A map of origin
 * strings to booleans indicating whether the "switch to connected" alert has
 * been shown (`true`) or otherwise (`false`).
 */

/**
 * @typedef {Object} AlertControllerOptions
 * @property {AlertControllerInitState} initState - The initial controller state
 */
const defaultState = {
  alertEnabledness: _alerts.TOGGLEABLE_ALERT_TYPES.reduce((alertEnabledness, alertType) => {
    alertEnabledness[alertType] = true;
    return alertEnabledness;
  }, {}),
  unconnectedAccountAlertShownOrigins: {},
  web3ShimUsageOrigins: {}
};
/**
 * Controller responsible for maintaining alert-related state.
 */

class AlertController {
  /**
   * @param {AlertControllerOptions} [opts] - Controller configuration parameters
   */
  constructor(opts = {}) {
    const {
      initState = {},
      preferencesStore
    } = opts;

    const state = _objectSpread(_objectSpread({}, defaultState), {}, {
      alertEnabledness: _objectSpread(_objectSpread({}, defaultState.alertEnabledness), initState.alertEnabledness)
    });

    this.store = new _obsStore.ObservableStore(state);
    this.selectedAddress = preferencesStore.getState().selectedAddress;
    preferencesStore.subscribe(({
      selectedAddress
    }) => {
      const currentState = this.store.getState();

      if (currentState.unconnectedAccountAlertShownOrigins && this.selectedAddress !== selectedAddress) {
        this.selectedAddress = selectedAddress;
        this.store.updateState({
          unconnectedAccountAlertShownOrigins: {}
        });
      }
    });
  }

  setAlertEnabledness(alertId, enabledness) {
    let {
      alertEnabledness
    } = this.store.getState();
    alertEnabledness = _objectSpread({}, alertEnabledness);
    alertEnabledness[alertId] = enabledness;
    this.store.updateState({
      alertEnabledness
    });
  }
  /**
   * Sets the "switch to connected" alert as shown for the given origin
   *
   * @param {string} origin - The origin the alert has been shown for
   */


  setUnconnectedAccountAlertShown(origin) {
    let {
      unconnectedAccountAlertShownOrigins
    } = this.store.getState();
    unconnectedAccountAlertShownOrigins = _objectSpread({}, unconnectedAccountAlertShownOrigins);
    unconnectedAccountAlertShownOrigins[origin] = true;
    this.store.updateState({
      unconnectedAccountAlertShownOrigins
    });
  }
  /**
   * Gets the web3 shim usage state for the given origin.
   *
   * @param {string} origin - The origin to get the web3 shim usage state for.
   * @returns {undefined | 1 | 2} The web3 shim usage state for the given
   * origin, or undefined.
   */


  getWeb3ShimUsageState(origin) {
    return this.store.getState().web3ShimUsageOrigins[origin];
  }
  /**
   * Sets the web3 shim usage state for the given origin to RECORDED.
   *
   * @param {string} origin - The origin the that used the web3 shim.
   */


  setWeb3ShimUsageRecorded(origin) {
    this._setWeb3ShimUsageState(origin, _alerts.WEB3_SHIM_USAGE_ALERT_STATES.RECORDED);
  }
  /**
   * Sets the web3 shim usage state for the given origin to DISMISSED.
   *
   * @param {string} origin - The origin that the web3 shim notification was
   * dismissed for.
   */


  setWeb3ShimUsageAlertDismissed(origin) {
    this._setWeb3ShimUsageState(origin, _alerts.WEB3_SHIM_USAGE_ALERT_STATES.DISMISSED);
  }
  /**
   * @private
   * @param {string} origin - The origin to set the state for.
   * @param {number} value - The state value to set.
   */


  _setWeb3ShimUsageState(origin, value) {
    let {
      web3ShimUsageOrigins
    } = this.store.getState();
    web3ShimUsageOrigins = _objectSpread({}, web3ShimUsageOrigins);
    web3ShimUsageOrigins[origin] = value;
    this.store.updateState({
      web3ShimUsageOrigins
    });
  }

}

exports.default = AlertController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\alert.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\decrypt-message-manager.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\decrypt-message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("./util");

const hexRe = /^[0-9A-Fa-f]+$/gu;
/**
 * Represents, and contains data about, an 'eth_decrypt' type decryption request. These are created when a
 * decryption for an eth_decrypt call is requested.
 *
 * @typedef {Object} DecryptMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the decryptMessage method once the decryption request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the decryption request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the decryption request is 'unapproved', 'approved', 'decrypted' or 'rejected'
 * @property {string} type The json-prc decryption method for which a decryption request has been made. A 'Message' will
 * always have a 'eth_decrypt' type.
 */

class DecryptMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - DecryptMessage.
   *
   * @param {object} opts - Controller options
   * @param {Function} opts.metricEvent - A function for emitting a metric event.
   */
  constructor(opts) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedDecryptMsgs: {},
      unapprovedDecryptMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = opts.metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' DecryptMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' DecryptMessages in this.messages
   */


  get unapprovedDecryptMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' DecryptMessages in this.messages
   *
   * @returns {Object} An index of DecryptMessage ids to DecryptMessages, for all 'unapproved' DecryptMessages in
   * this.messages
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_decrypt call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {Promise<Buffer>} The raw decrypted message contents
   */


  addUnapprovedMessageAsync(msgParams, req) {
    return new Promise((resolve, reject) => {
      if (!msgParams.from) {
        reject(new Error('MetaMask Decryption: from field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(msgParams, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'decrypted':
            resolve(data.rawData);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Decryption: User denied message decryption.'));
            return;

          case 'errored':
            reject(new Error('This message cannot be decrypted'));
            return;

          default:
            reject(new Error(`MetaMask Decryption: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new DecryptMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new DecryptMessage to this.messages, and to save the unapproved DecryptMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_decryptMsg call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created DecryptMessage.
   */


  addUnapprovedMessage(msgParams, req) {
    _loglevel.default.debug(`DecryptMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // add origin from request


    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = this.normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_DECRYPT
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed DecryptMessage to this.messages, and calls this._saveMsgList() to save the unapproved DecryptMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The DecryptMessage to add to this.messages
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified DecryptMessage.
   *
   * @param {number} msgId - The id of the DecryptMessage to get
   * @returns {DecryptMessage|undefined} The DecryptMessage with the id that matches the passed msgId, or undefined
   * if no DecryptMessage has that id.
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a DecryptMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with the message params modified for proper decryption.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_decryptMsg is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForDecryption(msgParams);
  }
  /**
   * Sets a DecryptMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the DecryptMessage to approve.
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a DecryptMessage status to 'decrypted' via a call to this._setMsgStatus and updates that DecryptMessage in
   * this.messages by adding the raw decryption data of the decryption request to the DecryptMessage
   *
   * @param {number} msgId - The id of the DecryptMessage to decrypt.
   * @param {buffer} rawData - The raw data of the message request
   */


  setMsgStatusDecrypted(msgId, rawData) {
    const msg = this.getMsg(msgId);
    msg.rawData = rawData;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'decrypted');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   */


  prepMsgForDecryption(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a DecryptMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the DecryptMessage to reject.
   * @param reason
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      this.metricsEvent({
        event: reason,
        category: 'Messages',
        properties: {
          action: 'Decrypt Message Request'
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to error
   * @param error
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a DecryptMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the DecryptMessage to update.
   * @param {string} status - The new status of the DecryptMessage.
   * @throws A 'DecryptMessageManager - DecryptMessage not found for id: "${msgId}".' if there is no DecryptMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The DecryptMessage is also fired.
   * @fires If status is 'rejected' or 'decrypted', an event with a name equal to `${msgId}:finished` is fired along
   * with the DecryptMessage
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`DecryptMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'decrypted' || status === 'errored') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a DecryptMessage in this.messages to the passed DecryptMessage if the ids are equal. Then saves the
   * unapprovedDecryptMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {DecryptMessage} msg - A DecryptMessage that will replace an existing DecryptMessage (with the same
   * id) in this.messages
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved DecryptMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   */


  _saveMsgList() {
    const unapprovedDecryptMsgs = this.getUnapprovedMsgs();
    const unapprovedDecryptMsgCount = Object.keys(unapprovedDecryptMsgs).length;
    this.memStore.updateState({
      unapprovedDecryptMsgs,
      unapprovedDecryptMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }
  /**
   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
   *
   * @param {any} data - The buffer data to convert to a hex
   * @returns {string} A hex string conversion of the buffer data
   */


  normalizeMsgData(data) {
    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(data);

      if (stripped.match(hexRe)) {
        return (0, _util.addHexPrefix)(stripped);
      }
    } catch (e) {
      _loglevel.default.debug(`Message was not hex encoded, interpreting as utf8.`);
    }

    return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
  }

}

exports.default = DecryptMessageManager;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\decrypt-message-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\encryption-public-key-manager.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\encryption-public-key-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

/**
 * Represents, and contains data about, an 'eth_getEncryptionPublicKey' type request. These are created when
 * an eth_getEncryptionPublicKey call is requested.
 *
 * @typedef {Object} EncryptionPublicKey
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the encryptionPublicKey method once the request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the request is 'unapproved', 'approved', 'received' or 'rejected'
 * @property {string} type The json-prc method for which a request has been made. A 'Message' will
 * always have a 'eth_getEncryptionPublicKey' type.
 */
class EncryptionPublicKeyManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - EncryptionPublicKey.
   *
   * @param {object} opts - Controller options
   * @param {Function} opts.metricEvent - A function for emitting a metric event.
   */
  constructor(opts) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedEncryptionPublicKeyMsgs: {},
      unapprovedEncryptionPublicKeyMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = opts.metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' EncryptionPublicKeys in this.messages
   *
   * @returns {number} The number of 'unapproved' EncryptionPublicKeys in this.messages
   */


  get unapprovedEncryptionPublicKeyMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' EncryptionPublicKeys in this.messages
   *
   * @returns {Object} An index of EncryptionPublicKey ids to EncryptionPublicKeys, for all 'unapproved' EncryptionPublicKeys in
   * this.messages
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to
   * this.memStore.
   *
   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {Promise<Buffer>} The raw public key contents
   */


  addUnapprovedMessageAsync(address, req) {
    return new Promise((resolve, reject) => {
      if (!address) {
        reject(new Error('MetaMask Message: address field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(address, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'received':
            resolve(data.rawData);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.'));
            return;

          default:
            reject(new Error(`MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(address)}`));
        }
      });
    });
  }
  /**
   * Creates a new EncryptionPublicKey with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new EncryptionPublicKey to this.messages, and to save the unapproved EncryptionPublicKeys from that list to
   * this.memStore.
   *
   * @param {Object} address - The param for the eth_getEncryptionPublicKey call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created EncryptionPublicKey.
   */


  addUnapprovedMessage(address, req) {
    _loglevel.default.debug(`EncryptionPublicKeyManager addUnapprovedMessage: address`); // create txData obj with parameters and meta data


    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams: address,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_GET_ENCRYPTION_PUBLIC_KEY
    };

    if (req) {
      msgData.origin = req.origin;
    }

    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed EncryptionPublicKey to this.messages, and calls this._saveMsgList() to save the unapproved EncryptionPublicKeys from that
   * list to this.memStore.
   *
   * @param {Message} msg - The EncryptionPublicKey to add to this.messages
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified EncryptionPublicKey.
   *
   * @param {number} msgId - The id of the EncryptionPublicKey to get
   * @returns {EncryptionPublicKey|undefined} The EncryptionPublicKey with the id that matches the passed msgId, or undefined
   * if no EncryptionPublicKey has that id.
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a EncryptionPublicKey. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper providing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_getEncryptionPublicKey is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForEncryptionPublicKey(msgParams);
  }
  /**
   * Sets a EncryptionPublicKey status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the EncryptionPublicKey to approve.
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a EncryptionPublicKey status to 'received' via a call to this._setMsgStatus and updates that EncryptionPublicKey in
   * this.messages by adding the raw data of request to the EncryptionPublicKey
   *
   * @param {number} msgId - The id of the EncryptionPublicKey.
   * @param {buffer} rawData - The raw data of the message request
   */


  setMsgStatusReceived(msgId, rawData) {
    const msg = this.getMsg(msgId);
    msg.rawData = rawData;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'received');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   */


  prepMsgForEncryptionPublicKey(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a EncryptionPublicKey status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the EncryptionPublicKey to reject.
   * @param reason
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      this.metricsEvent({
        event: reason,
        category: 'Messages',
        properties: {
          action: 'Encryption public key Request'
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to error
   * @param error
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a EncryptionPublicKey in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the EncryptionPublicKey to update.
   * @param {string} status - The new status of the EncryptionPublicKey.
   * @throws A 'EncryptionPublicKeyManager - EncryptionPublicKey not found for id: "${msgId}".' if there is no EncryptionPublicKey
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The EncryptionPublicKey is also fired.
   * @fires If status is 'rejected' or 'received', an event with a name equal to `${msgId}:finished` is fired along
   * with the EncryptionPublicKey
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`EncryptionPublicKeyManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'received') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a EncryptionPublicKey in this.messages to the passed EncryptionPublicKey if the ids are equal. Then saves the
   * unapprovedEncryptionPublicKeyMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {EncryptionPublicKey} msg - A EncryptionPublicKey that will replace an existing EncryptionPublicKey (with the same
   * id) in this.messages
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved EncryptionPublicKeys, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   */


  _saveMsgList() {
    const unapprovedEncryptionPublicKeyMsgs = this.getUnapprovedMsgs();
    const unapprovedEncryptionPublicKeyMsgCount = Object.keys(unapprovedEncryptionPublicKeyMsgs).length;
    this.memStore.updateState({
      unapprovedEncryptionPublicKeyMsgs,
      unapprovedEncryptionPublicKeyMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}

exports.default = EncryptionPublicKeyManager;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\encryption-public-key-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\cached-balances.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\cached-balances.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {Object} CachedBalancesOptions
 * @property {Object} accountTracker An {@code AccountTracker} reference
 * @property {Function} getCurrentChainId A function to get the current chain id
 * @property {Object} initState The initial controller state
 */

/**
 * Background controller responsible for maintaining
 * a cache of account balances in local storage
 */
class CachedBalancesController {
  /**
   * Creates a new controller instance
   *
   * @param {CachedBalancesOptions} [opts] - Controller configuration parameters
   */
  constructor(opts = {}) {
    const {
      accountTracker,
      getCurrentChainId
    } = opts;
    this.accountTracker = accountTracker;
    this.getCurrentChainId = getCurrentChainId;

    const initState = _objectSpread({
      cachedBalances: {}
    }, opts.initState);

    this.store = new _obsStore.ObservableStore(initState);

    this._registerUpdates();
  }
  /**
   * Updates the cachedBalances property for the current chain. Cached balances will be updated to those in the passed accounts
   * if balances in the passed accounts are truthy.
   *
   * @param {Object} obj - The the recently updated accounts object for the current chain
   * @param obj.accounts
   * @returns {Promise<void>}
   */


  async updateCachedBalances({
    accounts
  }) {
    const chainId = this.getCurrentChainId();
    const balancesToCache = await this._generateBalancesToCache(accounts, chainId);
    this.store.updateState({
      cachedBalances: balancesToCache
    });
  }

  _generateBalancesToCache(newAccounts, chainId) {
    const {
      cachedBalances
    } = this.store.getState();

    const currentChainBalancesToCache = _objectSpread({}, cachedBalances[chainId]);

    Object.keys(newAccounts).forEach(accountID => {
      const account = newAccounts[accountID];

      if (account.balance) {
        currentChainBalancesToCache[accountID] = account.balance;
      }
    });

    const balancesToCache = _objectSpread(_objectSpread({}, cachedBalances), {}, {
      [chainId]: currentChainBalancesToCache
    });

    return balancesToCache;
  }
  /**
   * Removes cachedBalances
   */


  clearCachedBalances() {
    this.store.updateState({
      cachedBalances: {}
    });
  }
  /**
   * Sets up listeners and subscriptions which should trigger an update of cached balances. These updates will
   * happen when the current account changes. Which happens on block updates, as well as on network and account
   * selections.
   *
   * @private
   */


  _registerUpdates() {
    const update = this.updateCachedBalances.bind(this);
    this.accountTracker.store.subscribe(update);
  }

}

exports.default = CachedBalancesController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\cached-balances.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\personal-message-manager.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\personal-message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("./util");

const hexRe = /^[0-9A-Fa-f]+$/gu;
/**
 * Represents, and contains data about, an 'personal_sign' type signature request. These are created when a
 * signature for an personal_sign call is requested.
 *
 * @see {@link https://web3js.readthedocs.io/en/1.0/web3-eth-personal.html#sign}
 * @typedef {Object} PersonalMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the personal_sign method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'personal_sign' type.
 */

class PersonalMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - PersonalMessage.
   *
   * @param options
   * @param options.metricsEvent
   */
  constructor({
    metricsEvent
  }) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedPersonalMsgs: {},
      unapprovedPersonalMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' PersonalMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' PersonalMessages in this.messages
   */


  get unapprovedPersonalMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' PersonalMessages in this.messages
   *
   * @returns {Object} An index of PersonalMessage ids to PersonalMessages, for all 'unapproved' PersonalMessages in
   * this.messages
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {promise} When the message has been signed or rejected
   */


  addUnapprovedMessageAsync(msgParams, req) {
    return new Promise((resolve, reject) => {
      if (!msgParams.from) {
        reject(new Error('MetaMask Message Signature: from field is required.'));
        return;
      }

      const msgId = this.addUnapprovedMessage(msgParams, req);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            resolve(data.rawSig);
            return;

          case 'rejected':
            reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));
            return;

          case 'errored':
            reject(new Error(`MetaMask Message Signature: ${data.error}`));
            return;

          default:
            reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {number} The id of the newly created PersonalMessage.
   */


  addUnapprovedMessage(msgParams, req) {
    _loglevel.default.debug(`PersonalMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // add origin from request


    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = this.normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.PERSONAL_SIGN
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed PersonalMessage to this.messages, and calls this._saveMsgList() to save the unapproved PersonalMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The PersonalMessage to add to this.messages
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified PersonalMessage.
   *
   * @param {number} msgId - The id of the PersonalMessage to get
   * @returns {PersonalMessage|undefined} The PersonalMessage with the id that matches the passed msgId, or undefined
   * if no PersonalMessage has that id.
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a PersonalMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a PersonalMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the PersonalMessage to approve.
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a PersonalMessage status to 'signed' via a call to this._setMsgStatus and updates that PersonalMessage in
   * this.messages by adding the raw signature data of the signature request to the PersonalMessage
   *
   * @param {number} msgId - The id of the PersonalMessage to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a PersonalMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the PersonalMessage to reject.
   * @param reason
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a Message status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to error
   * @param error
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a PersonalMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the PersonalMessage to update.
   * @param {string} status - The new status of the PersonalMessage.
   * @throws A 'PersonalMessageManager - PersonalMessage not found for id: "${msgId}".' if there is no PersonalMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The PersonalMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the PersonalMessage
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`PersonalMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a PersonalMessage in this.messages to the passed PersonalMessage if the ids are equal. Then saves the
   * unapprovedPersonalMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {PersonalMessage} msg - A PersonalMessage that will replace an existing PersonalMessage (with the same
   * id) in this.messages
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved PersonalMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   */


  _saveMsgList() {
    const unapprovedPersonalMsgs = this.getUnapprovedMsgs();
    const unapprovedPersonalMsgCount = Object.keys(unapprovedPersonalMsgs).length;
    this.memStore.updateState({
      unapprovedPersonalMsgs,
      unapprovedPersonalMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }
  /**
   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
   *
   * @param {any} data - The buffer data to convert to a hex
   * @returns {string} A hex string conversion of the buffer data
   */


  normalizeMsgData(data) {
    try {
      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(data);

      if (stripped.match(hexRe)) {
        return (0, _util.addHexPrefix)(stripped);
      }
    } catch (e) {
      _loglevel.default.debug(`Message was not hex encoded, interpreting as utf8.`);
    }

    return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
  }

}

exports.default = PersonalMessageManager;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\personal-message-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\seed-phrase-verifier.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","eth-keyring-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-keyring-controller\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\seed-phrase-verifier.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethKeyringController = _interopRequireDefault(require("eth-keyring-controller"));

var _loglevel = _interopRequireDefault(require("loglevel"));

const seedPhraseVerifier = {
  /**
   * Verifies if the seed words can restore the accounts.
   *
   * Key notes:
   * - The seed words can recreate the primary keyring and the accounts belonging to it.
   * - The created accounts in the primary keyring are always the same.
   * - The keyring always creates the accounts in the same sequence.
   *
   * @param {Array} createdAccounts - The accounts to restore
   * @param {Buffer} seedPhrase - The seed words to verify, encoded as a Buffer
   * @returns {Promise<void>}
   */
  async verifyAccounts(createdAccounts, seedPhrase) {
    if (!createdAccounts || createdAccounts.length < 1) {
      throw new Error('No created accounts defined.');
    }

    const keyringController = new _ethKeyringController.default({});
    const Keyring = keyringController.getKeyringClassForType('HD Key Tree');
    const opts = {
      mnemonic: seedPhrase,
      numberOfAccounts: createdAccounts.length
    };
    const keyring = new Keyring(opts);
    const restoredAccounts = await keyring.getAccounts();

    _loglevel.default.debug(`Created accounts: ${JSON.stringify(createdAccounts)}`);

    _loglevel.default.debug(`Restored accounts: ${JSON.stringify(restoredAccounts)}`);

    if (restoredAccounts.length !== createdAccounts.length) {
      // this should not happen...
      throw new Error('Wrong number of accounts');
    }

    for (let i = 0; i < restoredAccounts.length; i++) {
      if (restoredAccounts[i].toLowerCase() !== createdAccounts[i].toLowerCase()) {
        throw new Error(`Not identical accounts! Original: ${createdAccounts[i]}, Restored: ${restoredAccounts[i]}`);
      }
    }
  }

};
var _default = seedPhraseVerifier;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\seed-phrase-verifier.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\message-manager.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\message-manager.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeMsgData = normalizeMsgData;

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

/**
 * Represents, and contains data about, an 'eth_sign' type signature request. These are created when a signature for
 * an eth_sign call is requested.
 *
 * @see {@link https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign}
 * @typedef {Object} Message
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_sign method once the signature request is approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' with
 * always have a 'eth_sign' type.
 */
class MessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   * @param {object} opts - Controller options
   * @param {Function} opts.metricsEvent - A function for emitting a metric event.
   */
  constructor({
    metricsEvent
  }) {
    super();
    this.memStore = new _obsStore.ObservableStore({
      unapprovedMsgs: {},
      unapprovedMsgCount: 0
    });
    this.messages = [];
    this.metricsEvent = metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' Messages in this.messages
   *
   * @returns {number} The number of 'unapproved' Messages in this.messages
   */


  get unapprovedMsgCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' Messages in this.messages
   *
   * @returns {Object} An index of Message ids to Messages, for all 'unapproved' Messages in this.messages
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @returns {promise} after signature has been
   */


  async addUnapprovedMessageAsync(msgParams, req) {
    const msgId = this.addUnapprovedMessage(msgParams, req);
    return await new Promise((resolve, reject) => {
      // await finished
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig);

          case 'rejected':
            return reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));

          case 'errored':
            return reject(new Error(`MetaMask Message Signature: ${data.error}`));

          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object where the origin may be specified
   * @returns {number} The id of the newly created message.
   */


  addUnapprovedMessage(msgParams, req) {
    // add origin from request
    if (req) {
      msgParams.origin = req.origin;
    }

    msgParams.data = normalizeMsgData(msgParams.data); // create txData obj with parameters and meta data

    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_SIGN
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Adds a passed Message to this.messages, and calls this._saveMsgList() to save the unapproved Messages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The Message to add to this.messages
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified Message.
   *
   * @param {number} msgId - The id of the Message to get
   * @returns {Message|undefined} The Message with the id that matches the passed msgId, or undefined if no Message has that id.
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a Message. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise with
   * any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a Message status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to approve.
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a Message status to 'signed' via a call to this._setMsgStatus and updates that Message in this.messages by
   * adding the raw signature data of the signature request to the Message
   *
   * @param {number} msgId - The id of the Message to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a Message status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to reject.
   * @param reason
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a Message status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the Message to error
   * @param error
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  }
  /**
   * Updates the status of a Message in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the Message to update.
   * @param {string} status - The new status of the Message.
   * @throws A 'MessageManager - Message not found for id: "${msgId}".' if there is no Message in this.messages with an
   * id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The Message is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along with the message
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`MessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a Message in this.messages to the passed Message if the ids are equal. Then saves the unapprovedMsg list to
   * storage via this._saveMsgList
   *
   * @private
   * @param {Message} msg - A Message that will replace an existing Message (with the same id) in this.messages
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved messages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   */


  _saveMsgList() {
    const unapprovedMsgs = this.getUnapprovedMsgs();
    const unapprovedMsgCount = Object.keys(unapprovedMsgs).length;
    this.memStore.updateState({
      unapprovedMsgs,
      unapprovedMsgCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}
/**
 * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
 *
 * @param {any} data - The buffer data to convert to a hex
 * @returns {string} A hex string conversion of the buffer data
 */


exports.default = MessageManager;

function normalizeMsgData(data) {
  if (data.slice(0, 2) === '0x') {
    // data is already hex
    return data;
  } // data is unicode, convert to hex


  return (0, _ethereumjsUtil.bufferToHex)(Buffer.from(data, 'utf8'));
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\message-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\metametrics.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/constants/metametrics":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\metametrics.js","../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","pubnub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pubnub\\dist\\web\\pubnub.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\metametrics.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _pubnub = require("pubnub");

var _app = require("../../../shared/constants/app");

var _metametrics = require("../../../shared/constants/metametrics");

var _time = require("../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const defaultCaptureException = err => {
  // throw error on clean stack so its captured by platform integrations (eg sentry)
  // but does not interrupt the call stack
  setTimeout(() => {
    throw err;
  });
};

const exceptionsToFilter = {
  [`You must pass either an "anonymousId" or a "userId".`]: true
};
/**
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsContext} MetaMetricsContext
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsEventPayload} MetaMetricsEventPayload
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsEventOptions} MetaMetricsEventOptions
 * @typedef {__import__('../../../shared/constants/metametrics').SegmentEventPayload} SegmentEventPayload
 * @typedef {__import__('../../../shared/constants/metametrics').SegmentInterface} SegmentInterface
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsPagePayload} MetaMetricsPagePayload
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsPageOptions} MetaMetricsPageOptions
 * @typedef {__import__('../../../shared/constants/metametrics').MetaMetricsEventFragment} MetaMetricsEventFragment
 */

/**
 * @typedef {Object} MetaMetricsControllerState
 * @property {string} [metaMetricsId] - The user's metaMetricsId that will be
 *  attached to all non-anonymized event payloads
 * @property {boolean} [participateInMetaMetrics] - The user's preference for
 *  participating in the MetaMetrics analytics program. This setting controls
 *  whether or not events are tracked
 * @property {{[string]: MetaMetricsEventFragment}} [fragments] - Object keyed
 *  by UUID with stored fragments as values.
 */

class MetaMetricsController {
  /**
   * @param {object} options
   * @param {Object} options.segment - an instance of analytics-node for tracking
   *  events that conform to the new MetaMetrics tracking plan.
   * @param {Object} options.preferencesStore - The preferences controller store, used
   *  to access and subscribe to preferences that will be attached to events
   * @param {Function} options.onNetworkDidChange - Used to attach a listener to the
   *  networkDidChange event emitted by the networkController
   * @param {Function} options.getCurrentChainId - Gets the current chain id from the
   *  network controller
   * @param {Function} options.getNetworkIdentifier - Gets the current network
   *  identifier from the network controller
   * @param {string} options.version - The version of the extension
   * @param {string} options.environment - The environment the extension is running in
   * @param {MetaMetricsControllerState} options.initState - State to initialized with
   * @param options.captureException
   */
  constructor({
    segment,
    preferencesStore,
    onNetworkDidChange,
    getCurrentChainId,
    getNetworkIdentifier,
    version,
    environment,
    initState,
    captureException = defaultCaptureException
  }) {
    this._captureException = err => {
      // This is a temporary measure. Currently there are errors flooding sentry due to a problem in how we are tracking anonymousId
      // We intend on removing this as soon as we understand how to correctly solve that problem.
      if (!exceptionsToFilter[err.message]) {
        captureException(err);
      }
    };

    const prefState = preferencesStore.getState();
    this.chainId = getCurrentChainId();
    this.network = getNetworkIdentifier();
    this.locale = prefState.currentLocale.replace('_', '-');
    this.version = environment === 'production' ? version : `${version}-${environment}`;
    const abandonedFragments = (0, _lodash.omitBy)(initState === null || initState === void 0 ? void 0 : initState.fragments, 'persist');
    this.store = new _obsStore.ObservableStore(_objectSpread(_objectSpread({
      participateInMetaMetrics: null,
      metaMetricsId: null
    }, initState), {}, {
      fragments: _objectSpread({}, initState === null || initState === void 0 ? void 0 : initState.fragments)
    }));
    preferencesStore.subscribe(({
      currentLocale
    }) => {
      this.locale = currentLocale.replace('_', '-');
    });
    onNetworkDidChange(() => {
      this.chainId = getCurrentChainId();
      this.network = getNetworkIdentifier();
    });
    this.segment = segment; // Track abandoned fragments that weren't properly cleaned up.
    // Abandoned fragments are those that were stored in persistent memory
    // and are available at controller instance creation, but do not have the
    // 'persist' flag set. This means anytime the extension is unlocked, any
    // fragments that are not marked as persistent will be purged and the
    // failure event will be emitted.

    Object.values(abandonedFragments).forEach(fragment => {
      this.finalizeEventFragment(fragment.id, {
        abandoned: true
      });
    }); // Close out event fragments that were created but not progressed. An
    // interval is used to routinely check if a fragment has not been updated
    // within the fragment's timeout window. When creating a new event fragment
    // a timeout can be specified that will cause an abandoned event to be
    // tracked if the event isn't progressed within that amount of time.

    setInterval(() => {
      Object.values(this.store.getState().fragments).forEach(fragment => {
        if (fragment.timeout && Date.now() - fragment.lastUpdated / 1000 > fragment.timeout) {
          this.finalizeEventFragment(fragment.id, {
            abandoned: true
          });
        }
      });
    }, _time.SECOND * 30);
  }

  generateMetaMetricsId() {
    return (0, _ethereumjsUtil.bufferToHex)((0, _ethereumjsUtil.keccak)(Buffer.from(String(Date.now()) + String(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)))));
  }
  /**
   * Create an event fragment in state and returns the event fragment object.
   *
   * @param {MetaMetricsEventFragment} options - Fragment settings and properties
   *  to initiate the fragment with.
   * @returns {MetaMetricsEventFragment}
   */


  createEventFragment(options) {
    var _options$uniqueIdenti;

    if (!options.successEvent || !options.category) {
      throw new Error(`Must specify success event and category. Success event was: ${options.event}. Category was: ${options.category}. Payload keys were: ${Object.keys(options)}. ${typeof options.properties === 'object' ? `Payload property keys were: ${Object.keys(options.properties)}` : ''}`);
    }

    const {
      fragments
    } = this.store.getState();
    const id = (_options$uniqueIdenti = options.uniqueIdentifier) !== null && _options$uniqueIdenti !== void 0 ? _options$uniqueIdenti : (0, _pubnub.generateUUID)();

    const fragment = _objectSpread(_objectSpread({
      id
    }, options), {}, {
      lastUpdated: Date.now()
    });

    this.store.updateState({
      fragments: _objectSpread(_objectSpread({}, fragments), {}, {
        [id]: fragment
      })
    });

    if (options.initialEvent) {
      this.trackEvent({
        event: fragment.initialEvent,
        category: fragment.category,
        properties: fragment.properties,
        sensitiveProperties: fragment.sensitiveProperties,
        page: fragment.page,
        referrer: fragment.referrer,
        revenue: fragment.revenue,
        value: fragment.value,
        currency: fragment.currency,
        environmentType: fragment.environmentType
      });
    }

    return fragment;
  }
  /**
   * Returns the fragment stored in memory with provided id or undefined if it
   * does not exist.
   *
   * @param {string} id - id of fragment to retrieve
   * @returns {[MetaMetricsEventFragment]}
   */


  getEventFragmentById(id) {
    const {
      fragments
    } = this.store.getState();
    const fragment = fragments[id];
    return fragment;
  }
  /**
   * Updates an event fragment in state
   *
   * @param {string} id - The fragment id to update
   * @param {MetaMetricsEventFragment} payload - Fragment settings and
   *  properties to initiate the fragment with.
   */


  updateEventFragment(id, payload) {
    const {
      fragments
    } = this.store.getState();
    const fragment = fragments[id];

    if (!fragment) {
      throw new Error(`Event fragment with id ${id} does not exist.`);
    }

    this.store.updateState({
      fragments: _objectSpread(_objectSpread({}, fragments), {}, {
        [id]: (0, _lodash.merge)(fragments[id], _objectSpread(_objectSpread({}, payload), {}, {
          lastUpdated: Date.now()
        }))
      })
    });
  }
  /**
   * Finalizes a fragment, tracking either a success event or failure Event
   * and then removes the fragment from state.
   *
   * @param {string} id - UUID of the event fragment to be closed
   * @param {object} options
   * @param {boolean} [options.abandoned] - if true track the failure
   *  event instead of the success event
   * @param {MetaMetricsContext.page} [options.page] - page the final event
   *  occurred on. This will override whatever is set on the fragment
   * @param {MetaMetricsContext.referrer} [options.referrer] - Dapp that
   *  originated the fragment. This is for fallback only, the fragment referrer
   *  property will take precedence.
   */


  finalizeEventFragment(id, {
    abandoned = false,
    page,
    referrer
  } = {}) {
    var _fragment$referrer;

    const fragment = this.store.getState().fragments[id];

    if (!fragment) {
      throw new Error(`Funnel with id ${id} does not exist.`);
    }

    const eventName = abandoned ? fragment.failureEvent : fragment.successEvent;
    this.trackEvent({
      event: eventName,
      category: fragment.category,
      properties: fragment.properties,
      sensitiveProperties: fragment.sensitiveProperties,
      page: page !== null && page !== void 0 ? page : fragment.page,
      referrer: (_fragment$referrer = fragment.referrer) !== null && _fragment$referrer !== void 0 ? _fragment$referrer : referrer,
      revenue: fragment.revenue,
      value: fragment.value,
      currency: fragment.currency,
      environmentType: fragment.environmentType
    });
    const {
      fragments
    } = this.store.getState();
    delete fragments[id];
    this.store.updateState({
      fragments
    });
  }
  /**
   * Setter for the `participateInMetaMetrics` property
   *
   * @param {boolean} participateInMetaMetrics - Whether or not the user wants
   *  to participate in MetaMetrics
   * @returns {string|null} the string of the new metametrics id, or null
   *  if not set
   */


  setParticipateInMetaMetrics(participateInMetaMetrics) {
    let {
      metaMetricsId
    } = this.state;

    if (participateInMetaMetrics && !metaMetricsId) {
      metaMetricsId = this.generateMetaMetricsId();
    } else if (participateInMetaMetrics === false) {
      metaMetricsId = null;
    }

    this.store.updateState({
      participateInMetaMetrics,
      metaMetricsId
    });
    return metaMetricsId;
  }

  get state() {
    return this.store.getState();
  }
  /**
   * Build the context object to attach to page and track events.
   *
   * @private
   * @param {Pick<MetaMetricsContext, 'referrer'>} [referrer] - dapp origin that initialized
   *  the notification window.
   * @param {Pick<MetaMetricsContext, 'page'>} [page] - page object describing the current
   *  view of the extension. Defaults to the background-process object.
   * @returns {MetaMetricsContext}
   */


  _buildContext(referrer, page = _metametrics.METAMETRICS_BACKGROUND_PAGE_OBJECT) {
    return {
      app: {
        name: 'MetaMask Extension',
        version: this.version
      },
      userAgent: window.navigator.userAgent,
      page,
      referrer
    };
  }
  /**
   * Build's the event payload, processing all fields into a format that can be
   * fed to Segment's track method
   *
   * @private
   * @param {
   *  Omit<MetaMetricsEventPayload, 'sensitiveProperties'>
   * } rawPayload - raw payload provided to trackEvent
   * @returns {SegmentEventPayload} formatted event payload for segment
   */


  _buildEventPayload(rawPayload) {
    var _properties$network, _properties$chain_id;

    const {
      event,
      properties,
      revenue,
      value,
      currency,
      category,
      page,
      referrer,
      environmentType = _app.ENVIRONMENT_TYPE_BACKGROUND
    } = rawPayload;
    return {
      event,
      properties: _objectSpread(_objectSpread({}, (0, _lodash.omit)(properties, ['revenue', 'locale', 'currency', 'value'])), {}, {
        revenue,
        value,
        currency,
        category,
        network: (_properties$network = properties === null || properties === void 0 ? void 0 : properties.network) !== null && _properties$network !== void 0 ? _properties$network : this.network,
        locale: this.locale,
        chain_id: (_properties$chain_id = properties === null || properties === void 0 ? void 0 : properties.chain_id) !== null && _properties$chain_id !== void 0 ? _properties$chain_id : this.chainId,
        environment_type: environmentType
      }),
      context: this._buildContext(referrer, page)
    };
  }
  /**
   * Perform validation on the payload and update the id type to use before
   * sending to Segment. Also examines the options to route and handle the
   * event appropriately.
   *
   * @private
   * @param {SegmentEventPayload} payload - properties to attach to event
   * @param {MetaMetricsEventOptions} [options] - options for routing and
   *  handling the event
   * @returns {Promise<void>}
   */


  _track(payload, options) {
    var _options$excludeMetaM;

    const {
      isOptIn,
      metaMetricsId: metaMetricsIdOverride,
      matomoEvent,
      flushImmediately
    } = options || {};
    let idType = 'userId';
    let idValue = this.state.metaMetricsId;
    let excludeMetaMetricsId = (_options$excludeMetaM = options === null || options === void 0 ? void 0 : options.excludeMetaMetricsId) !== null && _options$excludeMetaM !== void 0 ? _options$excludeMetaM : false; // This is carried over from the old implementation, and will likely need
    // to be updated to work with the new tracking plan. I think we should use
    // a config setting for this instead of trying to match the event name

    const isSendFlow = Boolean(payload.event.match(/^send|^confirm/iu));

    if (isSendFlow) {
      excludeMetaMetricsId = true;
    } // If we are tracking sensitive data we will always use the anonymousId
    // property as well as our METAMETRICS_ANONYMOUS_ID. This prevents us from
    // associating potentially identifiable information with a specific id.
    // During the opt in flow we will track all events, but do so with the
    // anonymous id. The one exception to that rule is after the user opts in
    // to MetaMetrics. When that happens we receive back the user's new
    // MetaMetrics id before it is fully persisted to state. To avoid a race
    // condition we explicitly pass the new id to the track method. In that
    // case we will track the opt in event to the user's id. In all other cases
    // we use the metaMetricsId from state.


    if (excludeMetaMetricsId || isOptIn && !metaMetricsIdOverride) {
      idType = 'anonymousId';
      idValue = _metametrics.METAMETRICS_ANONYMOUS_ID;
    } else if (isOptIn && metaMetricsIdOverride) {
      idValue = metaMetricsIdOverride;
    }

    payload[idType] = idValue; // If this is an event on the old matomo schema, add a key to the payload
    // to designate it as such

    if (matomoEvent === true) {
      payload.properties.legacy_event = true;
    } // Promises will only resolve when the event is sent to segment. For any
    // event that relies on this promise being fulfilled before performing UI
    // updates, or otherwise delaying user interaction, supply the
    // 'flushImmediately' flag to the trackEvent method.


    return new Promise((resolve, reject) => {
      const callback = err => {
        if (err) {
          // The error that segment gives us has some manipulation done to it
          // that seemingly breaks with lockdown enabled. Creating a new error
          // here prevents the system from freezing when the network request to
          // segment fails for any reason.
          const safeError = new Error(err.message);
          safeError.stack = err.stack;
          return reject(safeError);
        }

        return resolve();
      };

      this.segment.track(payload, callback);

      if (flushImmediately) {
        this.segment.flush();
      }
    });
  }
  /**
   * track a page view with Segment
   *
   * @param {MetaMetricsPagePayload} payload - details of the page viewed
   * @param {MetaMetricsPageOptions} [options] - options for handling the page
   *  view
   */


  trackPage({
    name,
    params,
    environmentType,
    page,
    referrer
  }, options) {
    try {
      if (this.state.participateInMetaMetrics === false) {
        return;
      }

      if (this.state.participateInMetaMetrics === null && !(options !== null && options !== void 0 && options.isOptInPath)) {
        return;
      }

      const {
        metaMetricsId
      } = this.state;
      const idTrait = metaMetricsId ? 'userId' : 'anonymousId';
      const idValue = metaMetricsId !== null && metaMetricsId !== void 0 ? metaMetricsId : _metametrics.METAMETRICS_ANONYMOUS_ID;
      this.segment.page({
        [idTrait]: idValue,
        name,
        properties: {
          params,
          locale: this.locale,
          network: this.network,
          chain_id: this.chainId,
          environment_type: environmentType
        },
        context: this._buildContext(referrer, page)
      });
    } catch (err) {
      this._captureException(err);
    }
  }
  /**
   * submits a metametrics event, not waiting for it to complete or allowing its error to bubble up
   *
   * @param {MetaMetricsEventPayload} payload - details of the event
   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event
   */


  trackEvent(payload, options) {
    // validation is not caught and handled
    this.validatePayload(payload);
    this.submitEvent(payload, options).catch(err => this._captureException(err));
  }
  /**
   * submits (or queues for submission) a metametrics event, performing necessary payload manipulation and
   * routing the event to the appropriate segment source. Will split events
   * with sensitiveProperties into two events, tracking the sensitiveProperties
   * with the anonymousId only.
   *
   * @param {MetaMetricsEventPayload} payload - details of the event
   * @param {MetaMetricsEventOptions} [options] - options for handling/routing the event
   * @returns {Promise<void>}
   */


  async submitEvent(payload, options) {
    this.validatePayload(payload);

    if (!this.state.participateInMetaMetrics && !(options !== null && options !== void 0 && options.isOptIn)) {
      return;
    } // We might track multiple events if sensitiveProperties is included, this array will hold
    // the promises returned from this._track.


    const events = [];

    if (payload.sensitiveProperties) {
      // sensitiveProperties will only be tracked using the anonymousId property and generic id
      // If the event options already specify to exclude the metaMetricsId we throw an error as
      // a signal to the developer that the event was implemented incorrectly
      if ((options === null || options === void 0 ? void 0 : options.excludeMetaMetricsId) === true) {
        throw new Error('sensitiveProperties was specified in an event payload that also set the excludeMetaMetricsId flag');
      }

      const combinedProperties = (0, _lodash.merge)(payload.sensitiveProperties, payload.properties);
      events.push(this._track(this._buildEventPayload(_objectSpread(_objectSpread({}, payload), {}, {
        properties: combinedProperties
      })), _objectSpread(_objectSpread({}, options), {}, {
        excludeMetaMetricsId: true
      })));
    }

    events.push(this._track(this._buildEventPayload(payload), options));
    await Promise.all(events);
  }
  /**
   * validates a metametrics event
   *
   * @param {MetaMetricsEventPayload} payload - details of the event
   */


  validatePayload(payload) {
    // event and category are required fields for all payloads
    if (!payload.event || !payload.category) {
      throw new Error(`Must specify event and category. Event was: ${payload.event}. Category was: ${payload.category}. Payload keys were: ${Object.keys(payload)}. ${typeof payload.properties === 'object' ? `Payload property keys were: ${Object.keys(payload.properties)}` : ''}`);
    }
  }

}

exports.default = MetaMetricsController;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\metametrics.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\account-tracker.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../constants/contracts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\constants\\contracts.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","pify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pify\\index.js","single-call-balance-checker-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\single-call-balance-checker-abi\\index.js","web3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\account-tracker.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _pify = _interopRequireDefault(require("pify"));

var _web = _interopRequireDefault(require("web3"));

var _singleCallBalanceCheckerAbi = _interopRequireDefault(require("single-call-balance-checker-abi"));

var _network = require("../../../shared/constants/network");

var _contracts = require("../constants/contracts");

var _util = require("./util");

/* Account Tracker
 *
 * This module is responsible for tracking any number of accounts
 * and caching their current balances & transaction counts.
 *
 * It also tracks transaction hashes, and checks their inclusion status
 * on each new block.
 */

/**
 * This module is responsible for tracking any number of accounts and caching their current balances & transaction
 * counts.
 *
 * It also tracks transaction hashes, and checks their inclusion status on each new block.
 *
 * @typedef {Object} AccountTracker
 * @property {Object} store The stored object containing all accounts to track, as well as the current block's gas limit.
 * @property {Object} store.accounts The accounts currently stored in this AccountTracker
 * @property {string} store.currentBlockGasLimit A hex string indicating the gas limit of the current block
 * @property {Object} _provider A provider needed to create the EthQuery instance used within this AccountTracker.
 * @property {EthQuery} _query An EthQuery instance used to access account information from the blockchain
 * @property {BlockTracker} _blockTracker A BlockTracker instance. Needed to ensure that accounts and their info updates
 * when a new block is created.
 * @property {Object} _currentBlockNumber Reference to a property on the _blockTracker: the number (i.e. an id) of the the current block
 */
class AccountTracker {
  /**
   * @param {Object} opts - Options for initializing the controller
   * @param {Object} opts.provider - An EIP-1193 provider instance that uses the current global network
   * @param {Object} opts.blockTracker - A block tracker, which emits events for each new block
   * @param {Function} opts.getCurrentChainId - A function that returns the `chainId` for the current global network
   */
  constructor(opts = {}) {
    const initState = {
      accounts: {},
      currentBlockGasLimit: ''
    };
    this.store = new _obsStore.ObservableStore(initState);
    this._provider = opts.provider;
    this._query = (0, _pify.default)(new _ethQuery.default(this._provider));
    this._blockTracker = opts.blockTracker; // blockTracker.currentBlock may be null

    this._currentBlockNumber = this._blockTracker.getCurrentBlock();

    this._blockTracker.once('latest', blockNumber => {
      this._currentBlockNumber = blockNumber;
    }); // bind function for easier listener syntax


    this._updateForBlock = this._updateForBlock.bind(this);
    this.getCurrentChainId = opts.getCurrentChainId;
    this.web3 = new _web.default(this._provider);
  }

  start() {
    // remove first to avoid double add
    this._blockTracker.removeListener('latest', this._updateForBlock); // add listener


    this._blockTracker.addListener('latest', this._updateForBlock); // fetch account balances


    this._updateAccounts();
  }

  stop() {
    // remove listener
    this._blockTracker.removeListener('latest', this._updateForBlock);
  }
  /**
   * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this
   * AccountTracker.
   *
   * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each
   * of these accounts are given an updated balance via EthQuery.
   *
   * @param {Array} addresses - The array of hex addresses for accounts with which this AccountTracker's accounts should be
   * in sync
   */


  syncWithAddresses(addresses) {
    const {
      accounts
    } = this.store.getState();
    const locals = Object.keys(accounts);
    const accountsToAdd = [];
    addresses.forEach(upstream => {
      if (!locals.includes(upstream)) {
        accountsToAdd.push(upstream);
      }
    });
    const accountsToRemove = [];
    locals.forEach(local => {
      if (!addresses.includes(local)) {
        accountsToRemove.push(local);
      }
    });
    this.addAccounts(accountsToAdd);
    this.removeAccount(accountsToRemove);
  }
  /**
   * Adds new addresses to track the balances of
   * given a balance as long this._currentBlockNumber is defined.
   *
   * @param {Array} addresses - An array of hex addresses of new accounts to track
   */


  addAccounts(addresses) {
    const {
      accounts
    } = this.store.getState(); // add initial state for addresses

    addresses.forEach(address => {
      accounts[address] = {};
    }); // save accounts state

    this.store.updateState({
      accounts
    }); // fetch balances for the accounts if there is block number ready

    if (!this._currentBlockNumber) {
      return;
    }

    this._updateAccounts();
  }
  /**
   * Removes accounts from being tracked
   *
   * @param {Array} addresses - An array of hex addresses to stop tracking.
   */


  removeAccount(addresses) {
    const {
      accounts
    } = this.store.getState(); // remove each state object

    addresses.forEach(address => {
      delete accounts[address];
    }); // save accounts state

    this.store.updateState({
      accounts
    });
  }
  /**
   * Removes all addresses and associated balances
   */


  clearAccounts() {
    this.store.updateState({
      accounts: {}
    });
  }
  /**
   * Given a block, updates this AccountTracker's currentBlockGasLimit, and then updates each local account's balance
   * via EthQuery
   *
   * @private
   * @param {number} blockNumber - the block number to update to.
   * @fires 'block' The updated state, if all account updates are successful
   */


  async _updateForBlock(blockNumber) {
    this._currentBlockNumber = blockNumber; // block gasLimit polling shouldn't be in account-tracker shouldn't be here...

    const currentBlock = await this._query.getBlockByNumber(blockNumber, false);

    if (!currentBlock) {
      return;
    }

    const currentBlockGasLimit = currentBlock.gasLimit;
    this.store.updateState({
      currentBlockGasLimit
    });

    try {
      await this._updateAccounts();
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * balanceChecker is deployed on main eth (test)nets and requires a single call
   * for all other networks, calls this._updateAccount for each account in this.store
   *
   * @returns {Promise} after all account balances updated
   */


  async _updateAccounts() {
    const {
      accounts
    } = this.store.getState();
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();

    switch (chainId) {
      case _network.MAINNET_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS);
        break;

      case _network.RINKEBY_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY);
        break;

      case _network.ROPSTEN_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN);
        break;

      case _network.KOVAN_CHAIN_ID:
        await this._updateAccountsViaBalanceChecker(addresses, _contracts.SINGLE_CALL_BALANCES_ADDRESS_KOVAN);
        break;

      default:
        await Promise.all(addresses.map(this._updateAccount.bind(this)));
    }
  }
  /**
   * Updates the current balance of an account.
   *
   * @private
   * @param {string} address - A hex address of a the account to be updated
   * @returns {Promise} after the account balance is updated
   */


  async _updateAccount(address) {
    // query balance
    const balance = await this._query.getBalance(address);
    const result = {
      address,
      balance
    }; // update accounts state

    const {
      accounts
    } = this.store.getState(); // only populate if the entry is still present

    if (!accounts[address]) {
      return;
    }

    accounts[address] = result;
    this.store.updateState({
      accounts
    });
  }
  /**
   * Updates current address balances from balanceChecker deployed contract instance
   *
   * @param {*} addresses
   * @param {*} deployedContractAddress
   */


  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {
    const {
      accounts
    } = this.store.getState();
    this.web3.setProvider(this._provider);
    const ethContract = this.web3.eth.contract(_singleCallBalanceCheckerAbi.default).at(deployedContractAddress);
    const ethBalance = ['0x0'];
    ethContract.balances(addresses, ethBalance, (error, result) => {
      if (error) {
        _loglevel.default.warn(`MetaMask - Account Tracker single call balance fetch failed`, error);

        Promise.all(addresses.map(this._updateAccount.bind(this)));
        return;
      }

      addresses.forEach((address, index) => {
        const balance = result[index] ? (0, _util.bnToHex)(result[index]) : '0x0';
        accounts[address] = {
          address,
          balance
        };
      });
      this.store.updateState({
        accounts
      });
    });
  }

}

exports.default = AccountTracker;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\account-tracker.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\incoming-transactions.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../../shared/modules/fetch-with-timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\fetch-with-timeout.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\incoming-transactions.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bn = _interopRequireDefault(require("bn.js"));

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _util = require("../lib/util");

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

var _transaction = require("../../../shared/constants/transaction");

var _network = require("../../../shared/constants/network");

var _time = require("../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
/**
 * @typedef {__import__('../../../shared/constants/transaction').TransactionMeta} TransactionMeta
 */

/**
 * A transaction object in the format returned by the Etherscan API.
 *
 * Note that this is not an exhaustive type definiton; only the properties we use are defined
 *
 * @typedef {Object} EtherscanTransaction
 * @property {string} blockNumber - The number of the block this transaction was found in, in decimal
 * @property {string} from - The hex-prefixed address of the sender
 * @property {string} gas - The gas limit, in decimal GWEI
 * @property {string} [gasPrice] - The gas price, in decimal WEI
 * @property {string} [maxFeePerGas] - The maximum fee per gas, inclusive of tip, in decimal WEI
 * @property {string} [maxPriorityFeePerGas] - The maximum tip per gas in decimal WEI
 * @property {string} hash - The hex-prefixed transaction hash
 * @property {string} isError - Whether the transaction was confirmed or failed (0 for confirmed, 1 for failed)
 * @property {string} nonce - The transaction nonce, in decimal
 * @property {string} timeStamp - The timestamp for the transaction, in seconds
 * @property {string} to - The hex-prefixed address of the recipient
 * @property {string} value - The amount of ETH sent in this transaction, in decimal WEI
 */

/**
 * This controller is responsible for retrieving incoming transactions. Etherscan is polled once every block to check
 * for new incoming transactions for the current selected account on the current network
 *
 * Note that only the built-in Infura networks are supported (i.e. anything in `INFURA_PROVIDER_TYPES`). We will not
 * attempt to retrieve incoming transactions on any custom RPC endpoints.
 */

const etherscanSupportedNetworks = [_network.GOERLI_CHAIN_ID, _network.KOVAN_CHAIN_ID, _network.MAINNET_CHAIN_ID, _network.RINKEBY_CHAIN_ID, _network.ROPSTEN_CHAIN_ID];

class IncomingTransactionsController {
  constructor(opts = {}) {
    const {
      blockTracker,
      onNetworkDidChange,
      getCurrentChainId,
      preferencesController
    } = opts;
    this.blockTracker = blockTracker;
    this.getCurrentChainId = getCurrentChainId;
    this.preferencesController = preferencesController;

    this._onLatestBlock = async newBlockNumberHex => {
      const selectedAddress = this.preferencesController.getSelectedAddress();
      const newBlockNumberDec = parseInt(newBlockNumberHex, 16);
      await this._update(selectedAddress, newBlockNumberDec);
    };

    const initState = _objectSpread({
      incomingTransactions: {},
      incomingTxLastFetchedBlockByChainId: {
        [_network.GOERLI_CHAIN_ID]: null,
        [_network.KOVAN_CHAIN_ID]: null,
        [_network.MAINNET_CHAIN_ID]: null,
        [_network.RINKEBY_CHAIN_ID]: null,
        [_network.ROPSTEN_CHAIN_ID]: null
      }
    }, opts.initState);

    this.store = new _obsStore.ObservableStore(initState);
    this.preferencesController.store.subscribe(previousValueComparator((prevState, currState) => {
      const {
        featureFlags: {
          showIncomingTransactions: prevShowIncomingTransactions
        } = {}
      } = prevState;
      const {
        featureFlags: {
          showIncomingTransactions: currShowIncomingTransactions
        } = {}
      } = currState;

      if (currShowIncomingTransactions === prevShowIncomingTransactions) {
        return;
      }

      if (prevShowIncomingTransactions && !currShowIncomingTransactions) {
        this.stop();
        return;
      }

      this.start();
    }, this.preferencesController.store.getState()));
    this.preferencesController.store.subscribe(previousValueComparator(async (prevState, currState) => {
      const {
        selectedAddress: prevSelectedAddress
      } = prevState;
      const {
        selectedAddress: currSelectedAddress
      } = currState;

      if (currSelectedAddress === prevSelectedAddress) {
        return;
      }

      await this._update(currSelectedAddress);
    }, this.preferencesController.store.getState()));
    onNetworkDidChange(async () => {
      const address = this.preferencesController.getSelectedAddress();
      await this._update(address);
    });
  }

  start() {
    const {
      featureFlags = {}
    } = this.preferencesController.store.getState();
    const {
      showIncomingTransactions
    } = featureFlags;

    if (!showIncomingTransactions) {
      return;
    }

    this.blockTracker.removeListener('latest', this._onLatestBlock);
    this.blockTracker.addListener('latest', this._onLatestBlock);
  }

  stop() {
    this.blockTracker.removeListener('latest', this._onLatestBlock);
  }
  /**
   * Determines the correct block number to begin looking for new transactions
   * from, fetches the transactions and then saves them and the next block
   * number to begin fetching from in state. Block numbers and transactions are
   * stored per chainId.
   *
   * @private
   * @param {string} address - address to lookup transactions for
   * @param {number} [newBlockNumberDec] - block number to begin fetching from
   */


  async _update(address, newBlockNumberDec) {
    const chainId = this.getCurrentChainId();

    if (!etherscanSupportedNetworks.includes(chainId) || !address) {
      return;
    }

    try {
      var _ref;

      const currentState = this.store.getState();
      const currentBlock = parseInt(this.blockTracker.getCurrentBlock(), 16);
      const mostRecentlyFetchedBlock = currentState.incomingTxLastFetchedBlockByChainId[chainId];
      const blockToFetchFrom = (_ref = mostRecentlyFetchedBlock !== null && mostRecentlyFetchedBlock !== void 0 ? mostRecentlyFetchedBlock : newBlockNumberDec) !== null && _ref !== void 0 ? _ref : currentBlock;
      const newIncomingTxs = await this._getNewIncomingTransactions(address, blockToFetchFrom, chainId);
      let newMostRecentlyFetchedBlock = blockToFetchFrom;
      newIncomingTxs.forEach(tx => {
        if (tx.blockNumber && parseInt(newMostRecentlyFetchedBlock, 10) < parseInt(tx.blockNumber, 10)) {
          newMostRecentlyFetchedBlock = parseInt(tx.blockNumber, 10);
        }
      });
      this.store.updateState({
        incomingTxLastFetchedBlockByChainId: _objectSpread(_objectSpread({}, currentState.incomingTxLastFetchedBlockByChainId), {}, {
          [chainId]: newMostRecentlyFetchedBlock + 1
        }),
        incomingTransactions: newIncomingTxs.reduce((transactions, tx) => {
          transactions[tx.hash] = tx;
          return transactions;
        }, _objectSpread({}, currentState.incomingTransactions))
      });
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * fetches transactions for the given address and chain, via etherscan, then
   * processes the data into the necessary shape for usage in this controller.
   *
   * @private
   * @param {string} [address] - Address to fetch transactions for
   * @param {number} [fromBlock] - Block to look for transactions at
   * @param {string} [chainId] - The chainId for the current network
   * @returns {TransactionMeta[]}
   */


  async _getNewIncomingTransactions(address, fromBlock, chainId) {
    const etherscanSubdomain = chainId === _network.MAINNET_CHAIN_ID ? 'api' : `api-${_network.CHAIN_ID_TO_TYPE_MAP[chainId]}`;
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1`;

    if (fromBlock) {
      url += `&startBlock=${parseInt(fromBlock, 10)}`;
    }

    const response = await fetchWithTimeout(url);
    const {
      status,
      result
    } = await response.json();
    let newIncomingTxs = [];

    if (status === '1' && Array.isArray(result) && result.length > 0) {
      const remoteTxList = {};
      const remoteTxs = [];
      result.forEach(tx => {
        if (!remoteTxList[tx.hash]) {
          remoteTxs.push(this._normalizeTxFromEtherscan(tx, chainId));
          remoteTxList[tx.hash] = 1;
        }
      });
      newIncomingTxs = remoteTxs.filter(tx => {
        var _tx$txParams, _tx$txParams$to;

        return ((_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : (_tx$txParams$to = _tx$txParams.to) === null || _tx$txParams$to === void 0 ? void 0 : _tx$txParams$to.toLowerCase()) === address.toLowerCase();
      });
      newIncomingTxs.sort((a, b) => a.time < b.time ? -1 : 1);
    }

    return newIncomingTxs;
  }
  /**
   * Transmutes a EtherscanTransaction into a TransactionMeta
   *
   * @param {EtherscanTransaction} etherscanTransaction - the transaction to normalize
   * @param {string} chainId - The chainId of the current network
   * @returns {TransactionMeta}
   */


  _normalizeTxFromEtherscan(etherscanTransaction, chainId) {
    const time = parseInt(etherscanTransaction.timeStamp, 10) * 1000;
    const status = etherscanTransaction.isError === '0' ? _transaction.TRANSACTION_STATUSES.CONFIRMED : _transaction.TRANSACTION_STATUSES.FAILED;
    const txParams = {
      from: etherscanTransaction.from,
      gas: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.gas)),
      nonce: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.nonce)),
      to: etherscanTransaction.to,
      value: (0, _util.bnToHex)(new _bn.default(etherscanTransaction.value))
    };

    if (etherscanTransaction.gasPrice) {
      txParams.gasPrice = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.gasPrice));
    } else if (etherscanTransaction.maxFeePerGas) {
      txParams.maxFeePerGas = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.maxFeePerGas));
      txParams.maxPriorityFeePerGas = (0, _util.bnToHex)(new _bn.default(etherscanTransaction.maxPriorityFeePerGas));
    }

    return {
      blockNumber: etherscanTransaction.blockNumber,
      id: (0, _randomId.default)(),
      chainId,
      metamaskNetworkId: _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId],
      status,
      time,
      txParams,
      hash: etherscanTransaction.hash,
      type: _transaction.TRANSACTION_TYPES.INCOMING
    };
  }

}
/**
 * Returns a function with arity 1 that caches the argument that the function
 * is called with and invokes the comparator with both the cached, previous,
 * value and the current value. If specified, the initialValue will be passed
 * in as the previous value on the first invocation of the returned method.
 *
 * @template A - The type of the compared value.
 * @param {(prevValue: A, nextValue: A) => void} comparator - A method to compare
 * the previous and next values.
 * @param {A} [initialValue] - The initial value to supply to prevValue
 * on first call of the method.
 */


exports.default = IncomingTransactionsController;

function previousValueComparator(comparator, initialValue) {
  let first = true;
  let cache;
  return value => {
    try {
      if (first) {
        first = false;
        return comparator(initialValue !== null && initialValue !== void 0 ? initialValue : value, value);
      }

      return comparator(cache, value);
    } finally {
      cache = value;
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\incoming-transactions.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js", {"./JsonRpcEngine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\JsonRpcEngine.js","./createAsyncMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createAsyncMiddleware.js","./createScaffoldMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createScaffoldMiddleware.js","./getUniqueId":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\getUniqueId.js","./idRemapMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\idRemapMiddleware.js","./mergeMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\mergeMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./idRemapMiddleware"), exports);
__exportStar(require("./createAsyncMiddleware"), exports);
__exportStar(require("./createScaffoldMiddleware"), exports);
__exportStar(require("./getUniqueId"), exports);
__exportStar(require("./JsonRpcEngine"), exports);
__exportStar(require("./mergeMiddleware"), exports);

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\typed-message-manager.js", {"../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","jsonschema":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\typed-message-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _assert = require("assert");

var _obsStore = require("@metamask/obs-store");

var _ethRpcErrors = require("eth-rpc-errors");

var _ethSigUtil = require("eth-sig-util");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _jsonschema = _interopRequireDefault(require("jsonschema"));

var _app = require("../../../shared/constants/app");

var _metamaskController = require("../metamask-controller");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

/**
 * Represents, and contains data about, an 'eth_signTypedData' type signature request. These are created when a
 * signature for an eth_signTypedData call is requested.
 *
 * @typedef {Object} TypedMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_signTypedData method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {Object} msgParams.from The address that is making the signature request.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed', 'rejected', or 'errored'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'eth_signTypedData' type.
 */
class TypedMessageManager extends _events.default {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - TypedMessage.
   *
   * @param options
   * @param options.getCurrentChainId
   * @param options.metricsEvent
   */
  constructor({
    getCurrentChainId,
    metricsEvent
  }) {
    super();
    this._getCurrentChainId = getCurrentChainId;
    this.memStore = new _obsStore.ObservableStore({
      unapprovedTypedMessages: {},
      unapprovedTypedMessagesCount: 0
    });
    this.messages = [];
    this.metricsEvent = metricsEvent;
  }
  /**
   * A getter for the number of 'unapproved' TypedMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' TypedMessages in this.messages
   */


  get unapprovedTypedMessagesCount() {
    return Object.keys(this.getUnapprovedMsgs()).length;
  }
  /**
   * A getter for the 'unapproved' TypedMessages in this.messages
   *
   * @returns {Object} An index of TypedMessage ids to TypedMessages, for all 'unapproved' TypedMessages in
   * this.messages
   */


  getUnapprovedMsgs() {
    return this.messages.filter(msg => msg.status === 'unapproved').reduce((result, msg) => {
      result[msg.id] = msg;
      return result;
    }, {});
  }
  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @param version
   * @returns {promise} When the message has been signed or rejected
   */


  addUnapprovedMessageAsync(msgParams, req, version) {
    return new Promise((resolve, reject) => {
      const msgId = this.addUnapprovedMessage(msgParams, req, version);
      this.once(`${msgId}:finished`, data => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig);

          case 'rejected':
            return reject(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Message Signature: User denied message signature.'));

          case 'errored':
            return reject(new Error(`MetaMask Message Signature: ${data.error}`));

          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
        }
      });
    });
  }
  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams - The params for the eth_sign call to be made after the message is approved.
   * @param {Object} [req] - The original request object possibly containing the origin
   * @param version
   * @returns {number} The id of the newly created TypedMessage.
   */


  addUnapprovedMessage(msgParams, req, version) {
    msgParams.version = version;

    if (req) {
      msgParams.origin = req.origin;
    }

    this.validateParams(msgParams);

    _loglevel.default.debug(`TypedMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`); // create txData obj with parameters and meta data


    const time = new Date().getTime();
    const msgId = (0, _randomId.default)();
    const msgData = {
      id: msgId,
      msgParams,
      time,
      status: 'unapproved',
      type: _app.MESSAGE_TYPE.ETH_SIGN_TYPED_DATA
    };
    this.addMsg(msgData); // signal update

    this.emit('update');
    return msgId;
  }
  /**
   * Helper method for this.addUnapprovedMessage. Validates that the passed params have the required properties.
   *
   * @param {Object} params - The params to validate
   */


  validateParams(params) {
    _assert.strict.ok(params && typeof params === 'object', 'Params must be an object.');

    _assert.strict.ok('data' in params, 'Params must include a "data" field.');

    _assert.strict.ok('from' in params, 'Params must include a "from" field.');

    _assert.strict.ok(typeof params.from === 'string' && (0, _hexstringUtils.isValidHexAddress)(params.from, {
      allowNonPrefixed: false
    }), '"from" field must be a valid, lowercase, hexadecimal Ethereum address string.');

    switch (params.version) {
      case 'V1':
        _assert.strict.ok(Array.isArray(params.data), '"params.data" must be an array.');

        _assert.strict.doesNotThrow(() => {
          (0, _ethSigUtil.typedSignatureHash)(params.data);
        }, 'Signing data must be valid EIP-712 typed data.');

        break;

      case 'V3':
      case 'V4':
        {
          _assert.strict.equal(typeof params.data, 'string', '"params.data" must be a string.');

          let data;

          _assert.strict.doesNotThrow(() => {
            data = JSON.parse(params.data);
          }, '"data" must be a valid JSON string.');

          const validation = _jsonschema.default.validate(data, _ethSigUtil.TYPED_MESSAGE_SCHEMA);

          _assert.strict.ok(data.primaryType in data.types, `Primary type of "${data.primaryType}" has no type definition.`);

          _assert.strict.equal(validation.errors.length, 0, 'Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.');

          let {
            chainId
          } = data.domain;

          if (chainId) {
            const activeChainId = parseInt(this._getCurrentChainId(), 16);

            _assert.strict.ok(!Number.isNaN(activeChainId), `Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);

            if (typeof chainId === 'string') {
              chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);
            }

            _assert.strict.equal(chainId, activeChainId, `Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
          }

          break;
        }

      default:
        _assert.strict.fail(`Unknown typed data version "${params.version}"`);

    }
  }
  /**
   * Adds a passed TypedMessage to this.messages, and calls this._saveMsgList() to save the unapproved TypedMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg - The TypedMessage to add to this.messages
   */


  addMsg(msg) {
    this.messages.push(msg);

    this._saveMsgList();
  }
  /**
   * Returns a specified TypedMessage.
   *
   * @param {number} msgId - The id of the TypedMessage to get
   * @returns {TypedMessage|undefined} The TypedMessage with the id that matches the passed msgId, or undefined
   * if no TypedMessage has that id.
   */


  getMsg(msgId) {
    return this.messages.find(msg => msg.id === msgId);
  }
  /**
   * Approves a TypedMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams - The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId - Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   */


  approveMessage(msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId);
    return this.prepMsgForSigning(msgParams);
  }
  /**
   * Sets a TypedMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to approve.
   */


  setMsgStatusApproved(msgId) {
    this._setMsgStatus(msgId, 'approved');
  }
  /**
   * Sets a TypedMessage status to 'signed' via a call to this._setMsgStatus and updates that TypedMessage in
   * this.messages by adding the raw signature data of the signature request to the TypedMessage
   *
   * @param {number} msgId - The id of the TypedMessage to sign.
   * @param {buffer} rawSig - The raw data of the signature request
   */


  setMsgStatusSigned(msgId, rawSig) {
    const msg = this.getMsg(msgId);
    msg.rawSig = rawSig;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'signed');
  }
  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams - The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   */


  prepMsgForSigning(msgParams) {
    delete msgParams.metamaskId;
    delete msgParams.version;
    return Promise.resolve(msgParams);
  }
  /**
   * Sets a TypedMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to reject.
   * @param reason
   */


  rejectMsg(msgId, reason = undefined) {
    if (reason) {
      const msg = this.getMsg(msgId);
      this.metricsEvent({
        event: reason,
        category: 'Transactions',
        properties: {
          action: 'Sign Request',
          version: msg.msgParams.version,
          type: msg.type
        }
      });
    }

    this._setMsgStatus(msgId, 'rejected');
  }
  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId - The id of the TypedMessage to error
   * @param error
   */


  errorMessage(msgId, error) {
    const msg = this.getMsg(msgId);
    msg.error = error;

    this._updateMsg(msg);

    this._setMsgStatus(msgId, 'errored');
  }
  /**
   * Clears all unapproved messages from memory.
   */


  clearUnapproved() {
    this.messages = this.messages.filter(msg => msg.status !== 'unapproved');

    this._saveMsgList();
  } //
  // PRIVATE METHODS
  //

  /**
   * Updates the status of a TypedMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId - The id of the TypedMessage to update.
   * @param {string} status - The new status of the TypedMessage.
   * @throws A 'TypedMessageManager - TypedMessage not found for id: "${msgId}".' if there is no TypedMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The TypedMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the TypedMessage
   */


  _setMsgStatus(msgId, status) {
    const msg = this.getMsg(msgId);

    if (!msg) {
      throw new Error(`TypedMessageManager - Message not found for id: "${msgId}".`);
    }

    msg.status = status;

    this._updateMsg(msg);

    this.emit(`${msgId}:${status}`, msg);

    if (status === 'rejected' || status === 'signed' || status === 'errored') {
      this.emit(`${msgId}:finished`, msg);
    }
  }
  /**
   * Sets a TypedMessage in this.messages to the passed TypedMessage if the ids are equal. Then saves the
   * unapprovedTypedMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {TypedMessage} msg - A TypedMessage that will replace an existing TypedMessage (with the same
   * id) in this.messages
   */


  _updateMsg(msg) {
    const index = this.messages.findIndex(message => message.id === msg.id);

    if (index !== -1) {
      this.messages[index] = msg;
    }

    this._saveMsgList();
  }
  /**
   * Saves the unapproved TypedMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   */


  _saveMsgList() {
    const unapprovedTypedMessages = this.getUnapprovedMsgs();
    const unapprovedTypedMessagesCount = Object.keys(unapprovedTypedMessages).length;
    this.memStore.updateState({
      unapprovedTypedMessages,
      unapprovedTypedMessagesCount
    });
    this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
  }

}

exports.default = TypedMessageManager;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\typed-message-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\index.js", {"../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","./ens":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\ens.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","punycode/punycode":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\punycode\\punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\ens\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _punycode = _interopRequireDefault(require("punycode/punycode"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _network = require("../../../../shared/constants/network");

var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");

var _ens = _interopRequireDefault(require("./ens"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const ZERO_X_ERROR_ADDRESS = '0x';

class EnsController {
  constructor({
    ens,
    provider,
    onNetworkDidChange,
    getCurrentChainId
  } = {}) {
    const initState = {
      ensResolutionsByAddress: {}
    };
    this._ens = ens;

    if (!this._ens) {
      const chainId = getCurrentChainId();
      const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];

      if (_ens.default.getNetworkEnsSupport(network)) {
        this._ens = new _ens.default({
          network,
          provider
        });
      }
    }

    this.store = new _obsStore.ObservableStore(initState);
    onNetworkDidChange(() => {
      this.store.putState(initState);
      const chainId = getCurrentChainId();
      const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];

      if (_ens.default.getNetworkEnsSupport(network)) {
        this._ens = new _ens.default({
          network,
          provider
        });
      } else {
        delete this._ens;
      }
    });
  }

  reverseResolveAddress(address) {
    return this._reverseResolveAddress((0, _hexstringUtils.toChecksumHexAddress)(address));
  }

  async _reverseResolveAddress(address) {
    if (!this._ens) {
      return undefined;
    }

    const state = this.store.getState();

    if (state.ensResolutionsByAddress[address]) {
      return state.ensResolutionsByAddress[address];
    }

    let domain;

    try {
      domain = await this._ens.reverse(address);
    } catch (error) {
      _loglevel.default.debug(error);

      return undefined;
    }

    let registeredAddress;

    try {
      registeredAddress = await this._ens.lookup(domain);
    } catch (error) {
      _loglevel.default.debug(error);

      return undefined;
    }

    if (registeredAddress === ZERO_ADDRESS || registeredAddress === ZERO_X_ERROR_ADDRESS) {
      return undefined;
    }

    if ((0, _hexstringUtils.toChecksumHexAddress)(registeredAddress) !== address) {
      return undefined;
    }

    this._updateResolutionsByAddress(address, _punycode.default.toASCII(domain));

    return domain;
  }

  _updateResolutionsByAddress(address, domain) {
    const oldState = this.store.getState();
    this.store.putState({
      ensResolutionsByAddress: _objectSpread(_objectSpread({}, oldState.ensResolutionsByAddress), {}, {
        [address]: domain
      })
    });
  }

}

exports.default = EnsController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\index.js", {"./background-api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\background-api.js","./caveat-mutators":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\caveat-mutators.js","./enums":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\enums.js","./permission-log":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\permission-log.js","./selectors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\selectors.js","./specifications":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\specifications.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _caveatMutators = require("./caveat-mutators");

Object.keys(_caveatMutators).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _caveatMutators[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _caveatMutators[key];
    }
  });
});

var _backgroundApi = require("./background-api");

Object.keys(_backgroundApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _backgroundApi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _backgroundApi[key];
    }
  });
});

var _enums = require("./enums");

Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _enums[key];
    }
  });
});

var _permissionLog = require("./permission-log");

Object.keys(_permissionLog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _permissionLog[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _permissionLog[key];
    }
  });
});

var _specifications = require("./specifications");

Object.keys(_specifications).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _specifications[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _specifications[key];
    }
  });
});

var _selectors = require("./selectors");

Object.keys(_selectors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _selectors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _selectors[key];
    }
  });
});

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\index.js", {"../../../../shared/constants/gas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\gas.js","../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../../../shared/modules/contract-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\contract-utils.js","../../../../shared/modules/conversion.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\conversion.utils.js","../../../../shared/modules/transaction.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\transaction.utils.js","../../../../ui/helpers/constants/error-keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\error-keys.js","../../../../ui/helpers/constants/transactions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\transactions.js","../../../../ui/helpers/utils/conversions.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\conversions.util.js","../../../../ui/helpers/utils/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\util.js","../../../../ui/pages/swaps/swaps.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\swaps\\swaps.util.js","../../lib/cleanErrorStack":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\cleanErrorStack.js","../../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","../../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","./lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\util.js","./pending-tx-tracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\pending-tx-tracker.js","./tx-gas-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-gas-utils.js","./tx-state-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-state-manager.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@ethereumjs/common":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js","@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bignumber.js\\bignumber.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js","human-standard-token-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\human-standard-token-abi\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","nonce-tracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nonce-tracker\\index.js","safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _obsStore = require("@metamask/obs-store");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethRpcErrors = require("eth-rpc-errors");

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _common = _interopRequireDefault(require("@ethereumjs/common"));

var _tx = require("@ethereumjs/tx");

var _ethers = require("ethers");

var _nonceTracker = _interopRequireDefault(require("nonce-tracker"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _cleanErrorStack = _interopRequireDefault(require("../../lib/cleanErrorStack"));

var _util = require("../../lib/util");

var _errorKeys = require("../../../../ui/helpers/constants/error-keys");

var _swaps = require("../../../../ui/pages/swaps/swaps.util");

var _conversions = require("../../../../ui/helpers/utils/conversions.util");

var _transaction = require("../../../../shared/constants/transaction");

var _transactions = require("../../../../ui/helpers/constants/transactions");

var _metamaskController = require("../../metamask-controller");

var _gas = require("../../../../shared/constants/gas");

var _conversion = require("../../../../shared/modules/conversion.utils");

var _network = require("../../../../shared/constants/network");

var _transaction2 = require("../../../../shared/modules/transaction.utils");

var _contractUtils = require("../../../../shared/modules/contract-utils");

var _util2 = require("../../../../ui/helpers/utils/util");

var _txStateManager = _interopRequireDefault(require("./tx-state-manager"));

var _txGasUtils = _interopRequireDefault(require("./tx-gas-utils"));

var _pendingTxTracker = _interopRequireDefault(require("./pending-tx-tracker"));

var txUtils = _interopRequireWildcard(require("./lib/util"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const hstInterface = new _ethers.ethers.utils.Interface(_humanStandardTokenAbi.default);
const MAX_MEMSTORE_TX_LIST_SIZE = 100; // Number of transactions (by unique nonces) to keep in memory

const SWAP_TRANSACTION_TYPES = [_transaction.TRANSACTION_TYPES.SWAP, _transaction.TRANSACTION_TYPES.SWAP_APPROVAL];
/**
 * @typedef {__import__('../../../../shared/constants/transaction').TransactionMeta} TransactionMeta
 * @typedef {__import__('../../../../shared/constants/transaction').TransactionMetaMetricsEventString} TransactionMetaMetricsEventString
 */

const METRICS_STATUS_FAILED = 'failed on-chain';
/**
 * @typedef {Object} CustomGasSettings
 * @property {string} [gas] - The gas limit to use for the transaction
 * @property {string} [gasPrice] - The gasPrice to use for a legacy transaction
 * @property {string} [maxFeePerGas] - The maximum amount to pay per gas on a
 *  EIP-1559 transaction
 * @property {string} [maxPriorityFeePerGas] - The maximum amount of paid fee
 *  to be distributed to miner in an EIP-1559 transaction
 */

/**
 * Transaction Controller is an aggregate of sub-controllers and trackers
 * composing them in a way to be exposed to the metamask controller
 *
 * - `txStateManager
 * responsible for the state of a transaction and
 * storing the transaction
 * - pendingTxTracker
 * watching blocks for transactions to be include
 * and emitting confirmed events
 * - txGasUtil
 * gas calculations and safety buffering
 * - nonceTracker
 * calculating nonces
 *
 * @param {Object} opts
 * @param {Object} opts.initState - initial transaction list default is an empty array
 * @param {Object} opts.networkStore - an observable store for network number
 * @param {Object} opts.blockTracker - An instance of eth-blocktracker
 * @param {Object} opts.provider - A network provider.
 * @param {Function} opts.signTransaction - function the signs an @ethereumjs/tx
 * @param {Object} opts.getPermittedAccounts - get accounts that an origin has permissions for
 * @param {Function} opts.signTransaction - ethTx signer that returns a rawTx
 * @param {number} [opts.txHistoryLimit] - number *optional* for limiting how many transactions are in state
 * @param {Object} opts.preferencesStore
 */

class TransactionController extends _safeEventEmitter.default {
  constructor(opts) {
    super();
    this.networkStore = opts.networkStore || new _obsStore.ObservableStore({});
    this._getCurrentChainId = opts.getCurrentChainId;
    this.getProviderConfig = opts.getProviderConfig;
    this._getCurrentNetworkEIP1559Compatibility = opts.getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = opts.getCurrentAccountEIP1559Compatibility;
    this.preferencesStore = opts.preferencesStore || new _obsStore.ObservableStore({});
    this.provider = opts.provider;
    this.getPermittedAccounts = opts.getPermittedAccounts;
    this.blockTracker = opts.blockTracker;
    this.signEthTx = opts.signTransaction;
    this.inProcessOfSigning = new Set();
    this._trackMetaMetricsEvent = opts.trackMetaMetricsEvent;
    this._getParticipateInMetrics = opts.getParticipateInMetrics;
    this._getEIP1559GasFeeEstimates = opts.getEIP1559GasFeeEstimates;
    this.createEventFragment = opts.createEventFragment;
    this.updateEventFragment = opts.updateEventFragment;
    this.finalizeEventFragment = opts.finalizeEventFragment;
    this.getEventFragmentById = opts.getEventFragmentById;
    this.memStore = new _obsStore.ObservableStore({});
    this.query = new _ethjsQuery.default(this.provider);
    this.txGasUtil = new _txGasUtils.default(this.provider);

    this._mapMethods();

    this.txStateManager = new _txStateManager.default({
      initState: opts.initState,
      txHistoryLimit: opts.txHistoryLimit,
      getNetwork: this.getNetwork.bind(this),
      getCurrentChainId: opts.getCurrentChainId
    });

    this._onBootCleanUp();

    this.store = this.txStateManager.store;
    this.nonceTracker = new _nonceTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getPendingTransactions: (...args) => {
        const pendingTransactions = this.txStateManager.getPendingTransactions(...args);
        const externalPendingTransactions = opts.getExternalPendingTransactions(...args);
        return [...pendingTransactions, ...externalPendingTransactions];
      },
      getConfirmedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager)
    });
    this.pendingTxTracker = new _pendingTxTracker.default({
      provider: this.provider,
      nonceTracker: this.nonceTracker,
      publishTransaction: rawTx => this.query.sendRawTransaction(rawTx),
      getPendingTransactions: () => {
        const pending = this.txStateManager.getPendingTransactions();
        const approved = this.txStateManager.getApprovedTransactions();
        return [...pending, ...approved];
      },
      approveTransaction: this.approveTransaction.bind(this),
      getCompletedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager)
    });
    this.txStateManager.store.subscribe(() => this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE));

    this._setupListeners(); // memstore is computed from a few different stores


    this._updateMemstore();

    this.txStateManager.store.subscribe(() => this._updateMemstore());
    this.networkStore.subscribe(() => {
      this._onBootCleanUp();

      this._updateMemstore();
    }); // request state update to finalize initialization

    this._updatePendingTxsAfterFirstBlock();
  }
  /**
   * Gets the current chainId in the network store as a number, returning 0 if
   * the chainId parses to NaN.
   *
   * @returns {number} The numerical chainId.
   */


  getChainId() {
    const networkState = this.networkStore.getState();

    const chainId = this._getCurrentChainId();

    const integerChainId = parseInt(chainId, 16);

    if (networkState === 'loading' || Number.isNaN(integerChainId)) {
      return 0;
    }

    return integerChainId;
  }

  async getEIP1559Compatibility(fromAddress) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }
  /**
   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
   * specifying which chain, network, hardfork and EIPs to support for
   * a transaction. By referencing this configuration, and analyzing the fields
   * specified in txParams, `@ethereumjs/tx` is able to determine which EIP-2718
   * transaction type to use.
   *
   * @param fromAddress
   * @returns {Common} common configuration object
   */


  async getCommonConfiguration(fromAddress) {
    const {
      type,
      nickname: name
    } = this.getProviderConfig();
    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress); // This logic below will have to be updated each time a hardfork happens
    // that carries with it a new Transaction type. It is inconsequential for
    // hardforks that do not include new types.

    const hardfork = supportsEIP1559 ? _network.HARDFORKS.LONDON : _network.HARDFORKS.BERLIN; // type will be one of our default network names or 'rpc'. the default
    // network names are sufficient configuration, simply pass the name as the
    // chain argument in the constructor.

    if (type !== _network.NETWORK_TYPE_RPC) {
      return new _common.default({
        chain: type,
        hardfork
      });
    } // For 'rpc' we need to use the same basic configuration as mainnet,
    // since we only support EVM compatible chains, and then override the
    // name, chainId and networkId properties. This is done using the
    // `forCustomChain` static method on the Common class.


    const chainId = parseInt(this._getCurrentChainId(), 16);
    const networkId = this.networkStore.getState();
    const customChainParams = {
      name,
      chainId,
      // It is improbable for a transaction to be signed while the network
      // is loading for two reasons.
      // 1. Pending, unconfirmed transactions are wiped on network change
      // 2. The UI is unusable (loading indicator) when network is loading.
      // setting the networkId to 0 is for type safety and to explicity lead
      // the transaction to failing if a user is able to get to this branch
      // on a custom network that requires valid network id. I have not ran
      // into this limitation on any network I have attempted, even when
      // hardcoding networkId to 'loading'.
      networkId: networkId === 'loading' ? 0 : parseInt(networkId, 10)
    };
    return _common.default.forCustomChain(_network.MAINNET, customChainParams, hardfork);
  }
  /**
   * Adds a tx to the txlist
   *
   * @param txMeta
   * @fires ${txMeta.id}:unapproved
   */


  addTransaction(txMeta) {
    this.txStateManager.addTransaction(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);

    this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.ADDED);
  }
  /**
   * Wipes the transactions for a given account
   *
   * @param {string} address - hex string of the from address for txs being removed
   */


  wipeTransactions(address) {
    this.txStateManager.wipeTransactions(address);
  }
  /**
   * Add a new unapproved transaction to the pipeline
   *
   * @returns {Promise<string>} the hash of the transaction after being submitted to the network
   * @param {Object} txParams - txParams for the transaction
   * @param {Object} opts - with the key origin to put the origin on the txMeta
   */


  async newUnapprovedTransaction(txParams, opts = {}) {
    _loglevel.default.debug(`MetaMaskController newUnapprovedTransaction ${JSON.stringify(txParams)}`);

    const initialTxMeta = await this.addUnapprovedTransaction(txParams, opts.origin); // listen for tx completion (success, fail)

    return new Promise((resolve, reject) => {
      this.txStateManager.once(`${initialTxMeta.id}:finished`, finishedTxMeta => {
        switch (finishedTxMeta.status) {
          case _transaction.TRANSACTION_STATUSES.SUBMITTED:
            return resolve(finishedTxMeta.hash);

          case _transaction.TRANSACTION_STATUSES.REJECTED:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.provider.userRejectedRequest('MetaMask Tx Signature: User denied transaction signature.')));

          case _transaction.TRANSACTION_STATUSES.FAILED:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.rpc.internal(finishedTxMeta.err.message)));

          default:
            return reject((0, _cleanErrorStack.default)(_ethRpcErrors.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(finishedTxMeta.txParams)}`)));
        }
      });
    });
  }
  /**
   * Validates and generates a txMeta with defaults and puts it in txStateManager
   * store.
   *
   * @param txParams
   * @param origin
   * @param transactionType
   * @returns {txMeta}
   */


  async addUnapprovedTransaction(txParams, origin, transactionType) {
    if (transactionType !== undefined && !SWAP_TRANSACTION_TYPES.includes(transactionType)) {
      throw new Error(`TransactionController - invalid transactionType value: ${transactionType}`);
    } // validate


    const normalizedTxParams = txUtils.normalizeTxParams(txParams);
    const eip1559Compatibility = await this.getEIP1559Compatibility();
    txUtils.validateTxParams(normalizedTxParams, eip1559Compatibility);
    /**
     * `generateTxMeta` adds the default txMeta properties to the passed object.
     * These include the tx's `id`. As we use the id for determining order of
     * txes in the tx-state-manager, it is necessary to call the asynchronous
     * method `this._determineTransactionType` after `generateTxMeta`.
     */

    let txMeta = this.txStateManager.generateTxMeta({
      txParams: normalizedTxParams,
      origin
    });

    if (origin === 'metamask') {
      // Assert the from address is the selected address
      if (normalizedTxParams.from !== this.getSelectedAddress()) {
        throw _ethRpcErrors.ethErrors.rpc.internal({
          message: `Internally initiated transaction is using invalid account.`,
          data: {
            origin,
            fromAddress: normalizedTxParams.from,
            selectedAddress: this.getSelectedAddress()
          }
        });
      }
    } else {
      // Assert that the origin has permissions to initiate transactions from
      // the specified address
      const permittedAddresses = await this.getPermittedAccounts(origin);

      if (!permittedAddresses.includes(normalizedTxParams.from)) {
        throw _ethRpcErrors.ethErrors.provider.unauthorized({
          data: {
            origin
          }
        });
      }
    }

    const {
      type,
      getCodeResponse
    } = await this._determineTransactionType(txParams);
    txMeta.type = transactionType || type; // ensure value

    txMeta.txParams.value = txMeta.txParams.value ? (0, _util.addHexPrefix)(txMeta.txParams.value) : '0x0';
    this.addTransaction(txMeta);
    this.emit('newUnapprovedTx', txMeta);

    try {
      txMeta = await this.addTxGasDefaults(txMeta, getCodeResponse);
    } catch (error) {
      _loglevel.default.warn(error);

      txMeta = this.txStateManager.getTransaction(txMeta.id);
      txMeta.loadingDefaults = false;
      this.txStateManager.updateTransaction(txMeta, 'Failed to calculate gas defaults.');
      throw error;
    }

    txMeta.loadingDefaults = false; // save txMeta

    this.txStateManager.updateTransaction(txMeta, 'Added new unapproved transaction.');
    return txMeta;
  }
  /**
   * Adds the tx gas defaults: gas && gasPrice
   *
   * @param {Object} txMeta - the txMeta object
   * @param getCodeResponse
   * @returns {Promise<object>} resolves with txMeta
   */


  async addTxGasDefaults(txMeta, getCodeResponse) {
    const eip1559Compatibility = txMeta.txParams.type !== _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this._getDefaultGasFees(txMeta, eip1559Compatibility);
    const {
      gasLimit: defaultGasLimit,
      simulationFails
    } = await this._getDefaultGasLimit(txMeta, getCodeResponse); // eslint-disable-next-line no-param-reassign

    txMeta = this.txStateManager.getTransaction(txMeta.id);

    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }

    if (eip1559Compatibility) {
      const {
        eip1559V2Enabled
      } = this.preferencesStore.getState();
      const advancedGasFeeDefaultValues = this.getAdvancedGasFee();

      if (eip1559V2Enabled && Boolean(advancedGasFeeDefaultValues) && !SWAP_TRANSACTION_TYPES.includes(txMeta.type)) {
        txMeta.userFeeLevel = _gas.CUSTOM_GAS_ESTIMATE;
        txMeta.txParams.maxFeePerGas = (0, _conversion.decGWEIToHexWEI)(advancedGasFeeDefaultValues.maxBaseFee);
        txMeta.txParams.maxPriorityFeePerGas = (0, _conversion.decGWEIToHexWEI)(advancedGasFeeDefaultValues.priorityFee);
      } else if (txMeta.txParams.gasPrice && !txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
        //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
        txMeta.txParams.maxFeePerGas = txMeta.txParams.gasPrice;
        txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.gasPrice;

        if (eip1559V2Enabled && txMeta.origin !== 'metamask') {
          txMeta.userFeeLevel = _gas.PRIORITY_LEVELS.DAPP_SUGGESTED;
        } else {
          txMeta.userFeeLevel = _gas.CUSTOM_GAS_ESTIMATE;
        }
      } else {
        if (defaultMaxFeePerGas && defaultMaxPriorityFeePerGas && !txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas || txMeta.origin === 'metamask') {
          txMeta.userFeeLevel = _gas.GAS_RECOMMENDATIONS.MEDIUM;
        } else if (eip1559V2Enabled) {
          txMeta.userFeeLevel = _gas.PRIORITY_LEVELS.DAPP_SUGGESTED;
        } else {
          txMeta.userFeeLevel = _gas.CUSTOM_GAS_ESTIMATE;
        }

        if (defaultMaxFeePerGas && !txMeta.txParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.txParams.maxFeePerGas = defaultMaxFeePerGas;
        }

        if (defaultMaxPriorityFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.txParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }

        if (defaultGasPrice && !txMeta.txParams.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.txParams.maxFeePerGas = defaultGasPrice;
        }

        if (txMeta.txParams.maxFeePerGas && !txMeta.txParams.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.txParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.txParams.maxPriorityFeePerGas = txMeta.txParams.maxFeePerGas;
        }
      } // We remove the gasPrice param entirely when on an eip1559 compatible network


      delete txMeta.txParams.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network
      delete txMeta.txParams.maxPriorityFeePerGas;
      delete txMeta.txParams.maxFeePerGas;
    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.


    if (defaultGasPrice && !txMeta.txParams.gasPrice && !txMeta.txParams.maxPriorityFeePerGas && !txMeta.txParams.maxFeePerGas) {
      txMeta.txParams.gasPrice = defaultGasPrice;
    }

    if (defaultGasLimit && !txMeta.txParams.gas) {
      txMeta.txParams.gas = defaultGasLimit;
      txMeta.originalGasEstimate = defaultGasLimit;
    }

    txMeta.defaultGasEstimates = {
      estimateType: txMeta.userFeeLevel,
      gas: txMeta.txParams.gas,
      gasPrice: txMeta.txParams.gasPrice,
      maxFeePerGas: txMeta.txParams.maxFeePerGas,
      maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas
    };
    return txMeta;
  }
  /**
   * Gets default gas fees, or returns `undefined` if gas fees are already set
   *
   * @param {Object} txMeta - The txMeta object
   * @param eip1559Compatibility
   * @returns {Promise<string|undefined>} The default gas price
   */


  async _getDefaultGasFees(txMeta, eip1559Compatibility) {
    if (!eip1559Compatibility && txMeta.txParams.gasPrice || eip1559Compatibility && txMeta.txParams.maxFeePerGas && txMeta.txParams.maxPriorityFeePerGas) {
      return {};
    }

    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this._getEIP1559GasFeeEstimates();

      if (eip1559Compatibility && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;

        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            maxFeePerGas: (0, _conversion.decGWEIToHexWEI)(suggestedMaxFeePerGas),
            maxPriorityFeePerGas: (0, _conversion.decGWEIToHexWEI)(suggestedMaxPriorityFeePerGas)
          };
        }
      } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.medium)
        };
      } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.gasPrice)
        };
      }
    } catch (e) {
      console.error(e);
    }

    const gasPrice = await this.query.gasPrice();
    return {
      gasPrice: gasPrice && (0, _util.addHexPrefix)(gasPrice.toString(16))
    };
  }
  /**
   * Gets default gas limit, or debug information about why gas estimate failed.
   *
   * @param {Object} txMeta - The txMeta object
   * @param {string} getCodeResponse - The transaction category code response, used for debugging purposes
   * @returns {Promise<Object>} Object containing the default gas limit, or the simulation failure object
   */


  async _getDefaultGasLimit(txMeta, getCodeResponse) {
    const chainId = this._getCurrentChainId();

    const customNetworkGasBuffer = _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = (0, _util.getChainType)(chainId);

    if (txMeta.txParams.gas) {
      return {};
    } else if (txMeta.txParams.to && txMeta.type === _transaction.TRANSACTION_TYPES.SIMPLE_SEND && chainType !== 'custom') {
      // if there's data in the params, but there's no contract code, it's not a valid transaction
      if (txMeta.txParams.data) {
        const err = new Error('TxGasUtil - Trying to call a function on a non-contract address'); // set error key so ui can display localized error message

        err.errorKey = _errorKeys.TRANSACTION_NO_CONTRACT_ERROR_KEY; // set the response on the error so that we can see in logs what the actual response was

        err.getCodeResponse = getCodeResponse;
        throw err;
      } // This is a standard ether simple send, gas requirement is exactly 21k


      return {
        gasLimit: _gas.GAS_LIMITS.SIMPLE
      };
    }

    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.txGasUtil.analyzeGasUsage(txMeta); // add additional gas buffer to our estimation for safety

    const gasLimit = this.txGasUtil.addGasBuffer((0, _util.addHexPrefix)(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return {
      gasLimit,
      simulationFails
    };
  }
  /**
   * Given a TransactionMeta object, generate new gas params such that if the
   * transaction was an EIP1559 transaction, it only has EIP1559 gas fields,
   * otherwise it only has gasPrice. Will use whatever custom values are
   * specified in customGasSettings, or falls back to incrementing by a percent
   * which is defined by specifying a numerator. 11 is a 10% bump, 12 would be
   * a 20% bump, and so on.
   *
   * @param {TransactionMeta} originalTxMeta - Original transaction to use as
   *  base
   * @param {CustomGasSettings} [customGasSettings] - overrides for the gas
   *  fields to use instead of the multiplier
   * @param {number} [incrementNumerator] - Numerator from which to generate a
   *  percentage bump of gas price. E.g 11 would be a 10% bump over base.
   * @returns {{ newGasParams: CustomGasSettings, previousGasParams: CustomGasSettings }}
   */


  generateNewGasParams(originalTxMeta, customGasSettings = {}, incrementNumerator = 11) {
    const {
      txParams
    } = originalTxMeta;
    const previousGasParams = {};
    const newGasParams = {};

    if (customGasSettings.gasLimit) {
      var _customGasSettings$ga;

      newGasParams.gas = (_customGasSettings$ga = customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.gas) !== null && _customGasSettings$ga !== void 0 ? _customGasSettings$ga : _gas.GAS_LIMITS.SIMPLE;
    }

    if (customGasSettings.estimateSuggested) {
      newGasParams.estimateSuggested = customGasSettings.estimateSuggested;
    }

    if (customGasSettings.estimateUsed) {
      newGasParams.estimateUsed = customGasSettings.estimateUsed;
    }

    if ((0, _transaction2.isEIP1559Transaction)(originalTxMeta)) {
      previousGasParams.maxFeePerGas = txParams.maxFeePerGas;
      previousGasParams.maxPriorityFeePerGas = txParams.maxPriorityFeePerGas;
      newGasParams.maxFeePerGas = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.maxFeePerGas) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.maxFeePerGas), incrementNumerator, 10));
      newGasParams.maxPriorityFeePerGas = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.maxPriorityFeePerGas) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.maxPriorityFeePerGas), incrementNumerator, 10));
    } else {
      previousGasParams.gasPrice = txParams.gasPrice;
      newGasParams.gasPrice = (customGasSettings === null || customGasSettings === void 0 ? void 0 : customGasSettings.gasPrice) || (0, _util.bnToHex)((0, _util.BnMultiplyByFraction)((0, _util.hexToBn)(txParams.gasPrice), incrementNumerator, 10));
    }

    return {
      previousGasParams,
      newGasParams
    };
  }
  /**
   * Creates a new approved transaction to attempt to cancel a previously submitted transaction. The
   * new transaction contains the same nonce as the previous, is a basic ETH transfer of 0x value to
   * the sender's address, and has a higher gasPrice than that of the previous transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to attempt to cancel
   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas
   *  params instead of allowing this method to generate them
   * @param options
   * @param options.estimatedBaseFee
   * @returns {txMeta}
   */


  async createCancelTransaction(originalTxId, customGasSettings, {
    estimatedBaseFee
  } = {}) {
    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);
    const {
      txParams
    } = originalTxMeta;
    const {
      from,
      nonce
    } = txParams;
    const {
      previousGasParams,
      newGasParams
    } = this.generateNewGasParams(originalTxMeta, _objectSpread(_objectSpread({}, customGasSettings), {}, {
      // We want to override the previous transactions gasLimit because it
      // will now be a simple send instead of whatever it was before such
      // as a token transfer or contract call.
      gasLimit: customGasSettings.gasLimit || _gas.GAS_LIMITS.SIMPLE
    }));
    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: _objectSpread({
        from,
        to: from,
        nonce,
        value: '0x0'
      }, newGasParams),
      previousGasParams,
      loadingDefaults: false,
      status: _transaction.TRANSACTION_STATUSES.APPROVED,
      type: _transaction.TRANSACTION_TYPES.CANCEL
    });

    if (estimatedBaseFee) {
      newTxMeta.estimatedBaseFee = estimatedBaseFee;
    }

    this.addTransaction(newTxMeta);
    await this.approveTransaction(newTxMeta.id);
    return newTxMeta;
  }
  /**
   * Creates a new approved transaction to attempt to speed up a previously submitted transaction. The
   * new transaction contains the same nonce as the previous. By default, the new transaction will use
   * the same gas limit and a 10% higher gas price, though it is possible to set a custom value for
   * each instead.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to speed up
   * @param {CustomGasSettings} [customGasSettings] - overrides to use for gas
   *  params instead of allowing this method to generate them
   * @param options
   * @param options.estimatedBaseFee
   * @returns {txMeta}
   */


  async createSpeedUpTransaction(originalTxId, customGasSettings, {
    estimatedBaseFee
  } = {}) {
    const originalTxMeta = this.txStateManager.getTransaction(originalTxId);
    const {
      txParams
    } = originalTxMeta;
    const {
      previousGasParams,
      newGasParams
    } = this.generateNewGasParams(originalTxMeta, customGasSettings);
    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: _objectSpread(_objectSpread({}, txParams), newGasParams),
      previousGasParams,
      loadingDefaults: false,
      status: _transaction.TRANSACTION_STATUSES.APPROVED,
      type: _transaction.TRANSACTION_TYPES.RETRY
    });

    if (estimatedBaseFee) {
      newTxMeta.estimatedBaseFee = estimatedBaseFee;
    }

    this.addTransaction(newTxMeta);
    await this.approveTransaction(newTxMeta.id);
    return newTxMeta;
  }
  /**
   * updates the txMeta in the txStateManager
   *
   * @param {Object} txMeta - the updated txMeta
   */


  async updateTransaction(txMeta) {
    this.txStateManager.updateTransaction(txMeta, 'confTx: user updated transaction');
  }
  /**
   * updates and approves the transaction
   *
   * @param {Object} txMeta
   */


  async updateAndApproveTransaction(txMeta) {
    this.txStateManager.updateTransaction(txMeta, 'confTx: user approved transaction');
    await this.approveTransaction(txMeta.id);
  }
  /**
   * sets the tx status to approved
   * auto fills the nonce
   * signs the transaction
   * publishes the transaction
   * if any of these steps fails the tx status will be set to failed
   *
   * @param {number} txId - the tx's Id
   */


  async approveTransaction(txId) {
    // TODO: Move this safety out of this function.
    // Since this transaction is async,
    // we need to keep track of what is currently being signed,
    // So that we do not increment nonce + resubmit something
    // that is already being incremented & signed.
    if (this.inProcessOfSigning.has(txId)) {
      return;
    }

    this.inProcessOfSigning.add(txId);
    let nonceLock;

    try {
      // approve
      this.txStateManager.setTxStatusApproved(txId); // get next nonce

      const txMeta = this.txStateManager.getTransaction(txId);
      const fromAddress = txMeta.txParams.from; // wait for a nonce

      let {
        customNonceValue
      } = txMeta;
      customNonceValue = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress); // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated

      const nonce = txMeta.previousGasParams ? txMeta.txParams.nonce : nonceLock.nextNonce;
      const customOrNonce = customNonceValue === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.txParams.nonce = (0, _util.addHexPrefix)(customOrNonce.toString(16)); // add nonce debugging information to txMeta

      txMeta.nonceDetails = nonceLock.nonceDetails;

      if (customNonceValue) {
        txMeta.nonceDetails.customNonceValue = customNonceValue;
      }

      this.txStateManager.updateTransaction(txMeta, 'transactions#approveTransaction'); // sign transaction

      const rawTx = await this.signTransaction(txId);
      await this.publishTransaction(txId, rawTx);

      this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.APPROVED); // must set transaction to submitted/failed before releasing lock


      nonceLock.releaseLock();
    } catch (err) {
      // this is try-catch wrapped so that we can guarantee that the nonceLock is released
      try {
        this._failTransaction(txId, err);
      } catch (err2) {
        _loglevel.default.error(err2);
      } // must set transaction to submitted/failed before releasing lock


      if (nonceLock) {
        nonceLock.releaseLock();
      } // continue with error chain


      throw err;
    } finally {
      this.inProcessOfSigning.delete(txId);
    }
  }

  async approveTransactionsWithSameNonce(listOfTxParams = []) {
    if (listOfTxParams.length === 0) {
      return '';
    }

    const initialTx = listOfTxParams[0];
    const common = await this.getCommonConfiguration(initialTx.from);

    const initialTxAsEthTx = _tx.TransactionFactory.fromTxData(initialTx, {
      common
    });

    const initialTxAsSerializedHex = (0, _ethereumjsUtil.bufferToHex)(initialTxAsEthTx.serialize());

    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
      return '';
    }

    this.inProcessOfSigning.add(initialTxAsSerializedHex);
    let rawTxes, nonceLock;

    try {
      // TODO: we should add a check to verify that all transactions have the same from address
      const fromAddress = initialTx.from;
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);
      const nonce = nonceLock.nextNonce;
      rawTxes = await Promise.all(listOfTxParams.map(txParams => {
        txParams.nonce = (0, _util.addHexPrefix)(nonce.toString(16));
        return this.signExternalTransaction(txParams);
      }));
    } catch (err) {
      _loglevel.default.error(err); // must set transaction to submitted/failed before releasing lock
      // continue with error chain


      throw err;
    } finally {
      if (nonceLock) {
        nonceLock.releaseLock();
      }

      this.inProcessOfSigning.delete(initialTxAsSerializedHex);
    }

    return rawTxes;
  }

  async signExternalTransaction(_txParams) {
    const normalizedTxParams = txUtils.normalizeTxParams(_txParams); // add network/chain id

    const chainId = this.getChainId();
    const type = (0, _transaction2.isEIP1559Transaction)({
      txParams: normalizedTxParams
    }) ? _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;

    const txParams = _objectSpread(_objectSpread({}, normalizedTxParams), {}, {
      type,
      gasLimit: normalizedTxParams.gas,
      chainId: (0, _util.addHexPrefix)((0, _conversions.decimalToHex)(chainId))
    }); // sign tx


    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(fromAddress);

    const unsignedEthTx = _tx.TransactionFactory.fromTxData(txParams, {
      common
    });

    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);
    const rawTx = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.serialize());
    return rawTx;
  }
  /**
   * adds the chain id and signs the transaction and set the status to signed
   *
   * @param {number} txId - the tx's Id
   * @returns {string} rawTx
   */


  async signTransaction(txId) {
    const txMeta = this.txStateManager.getTransaction(txId); // add network/chain id

    const chainId = this.getChainId();
    const type = (0, _transaction2.isEIP1559Transaction)(txMeta) ? _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;

    const txParams = _objectSpread(_objectSpread({}, txMeta.txParams), {}, {
      type,
      chainId,
      gasLimit: txMeta.txParams.gas
    }); // sign tx


    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(txParams.from);

    const unsignedEthTx = _tx.TransactionFactory.fromTxData(txParams, {
      common
    });

    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress); // add r,s,v values for provider request purposes see createMetamaskMiddleware
    // and JSON rpc standard for further explanation

    txMeta.r = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.r);
    txMeta.s = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.s);
    txMeta.v = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.v);
    this.txStateManager.updateTransaction(txMeta, 'transactions#signTransaction: add r, s, v values'); // set state to signed

    this.txStateManager.setTxStatusSigned(txMeta.id);
    const rawTx = (0, _ethereumjsUtil.bufferToHex)(signedEthTx.serialize());
    return rawTx;
  }
  /**
   * publishes the raw tx and sets the txMeta to submitted
   *
   * @param {number} txId - the tx's Id
   * @param {string} rawTx - the hex string of the serialized signed transaction
   * @returns {Promise<void>}
   */


  async publishTransaction(txId, rawTx) {
    const txMeta = this.txStateManager.getTransaction(txId);
    txMeta.rawTx = rawTx;

    if (txMeta.type === _transaction.TRANSACTION_TYPES.SWAP) {
      const preTxBalance = await this.query.getBalance(txMeta.txParams.from);
      txMeta.preTxBalance = preTxBalance.toString(16);
    }

    this.txStateManager.updateTransaction(txMeta, 'transactions#publishTransaction');
    let txHash;

    try {
      txHash = await this.query.sendRawTransaction(rawTx);
    } catch (error) {
      if (error.message.toLowerCase().includes('known transaction')) {
        txHash = (0, _ethereumjsUtil.keccak)((0, _ethereumjsUtil.toBuffer)((0, _util.addHexPrefix)(rawTx), 'hex')).toString('hex');
        txHash = (0, _util.addHexPrefix)(txHash);
      } else {
        throw error;
      }
    }

    this.setTxHash(txId, txHash);
    this.txStateManager.setTxStatusSubmitted(txId);

    this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.SUBMITTED);
  }
  /**
   * Sets the status of the transaction to confirmed and sets the status of nonce duplicates as
   * dropped if the txParams have data it will fetch the txReceipt
   *
   * @param {number} txId - The tx's ID
   * @param txReceipt
   * @param baseFeePerGas
   * @param blockTimestamp
   * @returns {Promise<void>}
   */


  async confirmTransaction(txId, txReceipt, baseFeePerGas, blockTimestamp) {
    // get the txReceipt before marking the transaction confirmed
    // to ensure the receipt is gotten before the ui revives the tx
    const txMeta = this.txStateManager.getTransaction(txId);

    if (!txMeta) {
      return;
    }

    try {
      const gasUsed = txUtils.normalizeTxReceiptGasUsed(txReceipt.gasUsed);
      txMeta.txReceipt = _objectSpread(_objectSpread({}, txReceipt), {}, {
        gasUsed
      });

      if (baseFeePerGas) {
        txMeta.baseFeePerGas = baseFeePerGas;
      }

      if (blockTimestamp) {
        txMeta.blockTimestamp = blockTimestamp;
      }

      this.txStateManager.setTxStatusConfirmed(txId);

      this._markNonceDuplicatesDropped(txId);

      const {
        submittedTime
      } = txMeta;
      const metricsParams = {
        gas_used: gasUsed
      };

      if (submittedTime) {
        metricsParams.completion_time = this._getTransactionCompletionTime(submittedTime);
      }

      if (txReceipt.status === '0x0') {
        metricsParams.status = METRICS_STATUS_FAILED; // metricsParams.error = TODO: figure out a way to get the on-chain failure reason
      }

      this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.FINALIZED, metricsParams);

      this.txStateManager.updateTransaction(txMeta, 'transactions#confirmTransaction - add txReceipt');

      if (txMeta.type === _transaction.TRANSACTION_TYPES.SWAP) {
        const postTxBalance = await this.query.getBalance(txMeta.txParams.from);
        const latestTxMeta = this.txStateManager.getTransaction(txId);
        const approvalTxMeta = latestTxMeta.approvalTxId ? this.txStateManager.getTransaction(latestTxMeta.approvalTxId) : null;
        latestTxMeta.postTxBalance = postTxBalance.toString(16);
        this.txStateManager.updateTransaction(latestTxMeta, 'transactions#confirmTransaction - add postTxBalance');

        this._trackSwapsMetrics(latestTxMeta, approvalTxMeta);
      }
    } catch (err) {
      _loglevel.default.error(err);
    }
  }

  async confirmExternalTransaction(txMeta, txReceipt, baseFeePerGas) {
    // add external transaction
    await this.txStateManager.addExternalTransaction(txMeta);

    if (!txMeta) {
      return;
    }

    const txId = txMeta.id;

    try {
      const gasUsed = txUtils.normalizeTxReceiptGasUsed(txReceipt.gasUsed);
      txMeta.txReceipt = _objectSpread(_objectSpread({}, txReceipt), {}, {
        gasUsed
      });

      if (baseFeePerGas) {
        txMeta.baseFeePerGas = baseFeePerGas;
      }

      this.txStateManager.setTxStatusConfirmed(txId);

      this._markNonceDuplicatesDropped(txId);

      const {
        submittedTime
      } = txMeta;
      const metricsParams = {
        gas_used: gasUsed
      };

      if (submittedTime) {
        metricsParams.completion_time = this._getTransactionCompletionTime(submittedTime);
      }

      if (txReceipt.status === '0x0') {
        metricsParams.status = METRICS_STATUS_FAILED; // metricsParams.error = TODO: figure out a way to get the on-chain failure reason
      }

      this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.FINALIZED, metricsParams);

      this.txStateManager.updateTransaction(txMeta, 'transactions#confirmTransaction - add txReceipt');

      if (txMeta.type === _transaction.TRANSACTION_TYPES.SWAP) {
        const postTxBalance = await this.query.getBalance(txMeta.txParams.from);
        const latestTxMeta = this.txStateManager.getTransaction(txId);
        const approvalTxMeta = latestTxMeta.approvalTxId ? this.txStateManager.getTransaction(latestTxMeta.approvalTxId) : null;
        latestTxMeta.postTxBalance = postTxBalance.toString(16);
        this.txStateManager.updateTransaction(latestTxMeta, 'transactions#confirmTransaction - add postTxBalance');

        this._trackSwapsMetrics(latestTxMeta, approvalTxMeta);
      }
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * Convenience method for the ui thats sets the transaction to rejected
   *
   * @param {number} txId - the tx's Id
   * @returns {Promise<void>}
   */


  async cancelTransaction(txId) {
    const txMeta = this.txStateManager.getTransaction(txId);
    this.txStateManager.setTxStatusRejected(txId);

    this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.REJECTED);
  }
  /**
   * Sets the txHas on the txMeta
   *
   * @param {number} txId - the tx's Id
   * @param {string} txHash - the hash for the txMeta
   */


  setTxHash(txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.txStateManager.getTransaction(txId);
    txMeta.hash = txHash;
    this.txStateManager.updateTransaction(txMeta, 'transactions#setTxHash');
  }
  /**
   * Convenience method for the UI to easily create event fragments when the
   * fragment does not exist in state.
   *
   * @param {number} transactionId - The transaction id to create the event
   *  fragment for
   * @param {valueOf<TRANSACTION_EVENTS>} event - event type to create
   */


  async createTransactionEventFragment(transactionId, event) {
    const txMeta = this.txStateManager.getTransaction(transactionId);
    const {
      properties,
      sensitiveProperties
    } = await this._buildEventFragmentProperties(txMeta);

    this._createTransactionEventFragment(txMeta, event, properties, sensitiveProperties);
  } //
  //           PRIVATE METHODS
  //

  /** maps methods for convenience*/


  _mapMethods() {
    /** @returns {Object} the state in transaction controller */
    this.getState = () => this.memStore.getState();
    /** @returns {string|number} the network number stored in networkStore */


    this.getNetwork = () => this.networkStore.getState();
    /** @returns {string} the user selected address */


    this.getSelectedAddress = () => this.preferencesStore.getState().selectedAddress;
    /** @returns {Array} transactions whos status is unapproved */


    this.getUnapprovedTxCount = () => Object.keys(this.txStateManager.getUnapprovedTxList()).length;
    /**
     * @returns {number} number of transactions that have the status submitted
     * @param {string} account - hex prefixed account
     */


    this.getPendingTxCount = account => this.txStateManager.getPendingTransactions(account).length;
    /**
     * see txStateManager
     *
     * @param opts
     */


    this.getTransactions = opts => this.txStateManager.getTransactions(opts);
    /** @returns {object} the saved default values for advancedGasFee */


    this.getAdvancedGasFee = () => this.preferencesStore.getState().advancedGasFee;
  } // called once on startup


  async _updatePendingTxsAfterFirstBlock() {
    // wait for first block so we know we're ready
    await this.blockTracker.getLatestBlock(); // get status update for all pending transactions (for the current network)

    await this.pendingTxTracker.updatePendingTxs();
  }
  /**
   * If transaction controller was rebooted with transactions that are uncompleted
   * in steps of the transaction signing or user confirmation process it will either
   * transition txMetas to a failed state or try to redo those tasks.
   */


  _onBootCleanUp() {
    this.txStateManager.getTransactions({
      searchCriteria: {
        status: _transaction.TRANSACTION_STATUSES.UNAPPROVED,
        loadingDefaults: true
      }
    }).forEach(tx => {
      this.addTxGasDefaults(tx).then(txMeta => {
        txMeta.loadingDefaults = false;
        this.txStateManager.updateTransaction(txMeta, 'transactions: gas estimation for tx on boot');
      }).catch(error => {
        const txMeta = this.txStateManager.getTransaction(tx.id);
        txMeta.loadingDefaults = false;
        this.txStateManager.updateTransaction(txMeta, 'failed to estimate gas during boot cleanup.');

        this._failTransaction(txMeta.id, error);
      });
    });
    this.txStateManager.getTransactions({
      searchCriteria: {
        status: _transaction.TRANSACTION_STATUSES.APPROVED
      }
    }).forEach(txMeta => {
      const txSignError = new Error('Transaction found as "approved" during boot - possibly stuck during signing');

      this._failTransaction(txMeta.id, txSignError);
    });
  }
  /**
   * is called in constructor applies the listeners for pendingTxTracker txStateManager
   * and blockTracker
   */


  _setupListeners() {
    this.txStateManager.on('tx:status-update', this.emit.bind(this, 'tx:status-update'));

    this._setupBlockTrackerListener();

    this.pendingTxTracker.on('tx:warning', txMeta => {
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:warning');
    });
    this.pendingTxTracker.on('tx:failed', (txId, error) => {
      this._failTransaction(txId, error);
    });
    this.pendingTxTracker.on('tx:confirmed', (txId, transactionReceipt, baseFeePerGas, blockTimestamp) => this.confirmTransaction(txId, transactionReceipt, baseFeePerGas, blockTimestamp));
    this.pendingTxTracker.on('tx:dropped', txId => {
      this._dropTransaction(txId);
    });
    this.pendingTxTracker.on('tx:block-update', (txMeta, latestBlockNumber) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber;
        this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:block-update');
      }
    });
    this.pendingTxTracker.on('tx:retry', txMeta => {
      if (!('retryCount' in txMeta)) {
        txMeta.retryCount = 0;
      }

      txMeta.retryCount += 1;
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:retry');
    });
  }
  /**
   * @typedef { 'transfer' | 'approve' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
   */

  /**
   * @typedef {Object} InferTransactionTypeResult
   * @property {InferrableTransactionTypes} type - The type of transaction
   * @property {string} getCodeResponse - The contract code, in hex format if
   *  it exists. '0x0' or '0x' are also indicators of non-existent contract
   *  code
   */

  /**
   * Determines the type of the transaction by analyzing the txParams.
   * This method will return one of the types defined in shared/constants/transactions
   * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
   * represent specific events that we control from the extension and are added manually
   * at transaction creation.
   *
   * @param {Object} txParams - Parameters for the transaction
   * @returns {InferTransactionTypeResult}
   */


  async _determineTransactionType(txParams) {
    const {
      data,
      to
    } = txParams;
    let name;

    try {
      name = data && hstInterface.parseTransaction({
        data
      }).name;
    } catch (error) {
      _loglevel.default.debug('Failed to parse transaction data.', error, data);
    }

    const tokenMethodName = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM].find(methodName => (0, _util2.isEqualCaseInsensitive)(methodName, name));
    let result;

    if (data && tokenMethodName) {
      result = tokenMethodName;
    } else if (data && !to) {
      result = _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT;
    }

    let contractCode;

    if (!result) {
      const {
        contractCode: resultCode,
        isContractAddress
      } = await (0, _contractUtils.readAddressAsContract)(this.query, to);
      contractCode = resultCode;
      result = isContractAddress ? _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION : _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
    }

    return {
      type: result,
      getCodeResponse: contractCode
    };
  }
  /**
   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
   * in the list have the same nonce
   *
   * @param {number} txId - the txId of the transaction that has been confirmed in a block
   */


  _markNonceDuplicatesDropped(txId) {
    // get the confirmed transactions nonce and from address
    const txMeta = this.txStateManager.getTransaction(txId);
    const {
      nonce,
      from
    } = txMeta.txParams;
    const sameNonceTxs = this.txStateManager.getTransactions({
      searchCriteria: {
        nonce,
        from
      }
    });

    if (!sameNonceTxs.length) {
      return;
    } // mark all same nonce transactions as dropped and give i a replacedBy hash


    sameNonceTxs.forEach(otherTxMeta => {
      if (otherTxMeta.id === txId) {
        return;
      }

      otherTxMeta.replacedBy = txMeta.hash;
      this.txStateManager.updateTransaction(txMeta, 'transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce');

      this._dropTransaction(otherTxMeta.id);
    });
  }

  _setupBlockTrackerListener() {
    let listenersAreActive = false;

    const latestBlockHandler = this._onLatestBlock.bind(this);

    const {
      blockTracker,
      txStateManager
    } = this;
    txStateManager.on('tx:status-update', updateSubscription);
    updateSubscription();

    function updateSubscription() {
      const pendingTxs = txStateManager.getPendingTransactions();

      if (!listenersAreActive && pendingTxs.length > 0) {
        blockTracker.on('latest', latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        blockTracker.removeListener('latest', latestBlockHandler);
        listenersAreActive = false;
      }
    }
  }

  async _onLatestBlock(blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (err) {
      _loglevel.default.error(err);
    }

    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (err) {
      _loglevel.default.error(err);
    }
  }
  /**
   * Updates the memStore in transaction controller
   */


  _updateMemstore() {
    const unapprovedTxs = this.txStateManager.getUnapprovedTxList();
    const currentNetworkTxList = this.txStateManager.getTransactions({
      limit: MAX_MEMSTORE_TX_LIST_SIZE
    });
    this.memStore.updateState({
      unapprovedTxs,
      currentNetworkTxList
    });
  }

  _trackSwapsMetrics(txMeta, approvalTxMeta) {
    if (this._getParticipateInMetrics() && txMeta.swapMetaData) {
      if (txMeta.txReceipt.status === '0x0') {
        this._trackMetaMetricsEvent({
          event: 'Swap Failed',
          sensitiveProperties: _objectSpread({}, txMeta.swapMetaData),
          category: 'swaps'
        });
      } else {
        const tokensReceived = (0, _swaps.getSwapsTokensReceivedFromTxMeta)(txMeta.destinationTokenSymbol, txMeta, txMeta.destinationTokenAddress, txMeta.txParams.from, txMeta.destinationTokenDecimals, approvalTxMeta, txMeta.chainId);
        const quoteVsExecutionRatio = tokensReceived ? `${new _bignumber.default(tokensReceived, 10).div(txMeta.swapMetaData.token_to_amount, 10).times(100).round(2)}%` : null;
        const estimatedVsUsedGasRatio = txMeta.txReceipt.gasUsed && txMeta.swapMetaData.estimated_gas ? `${new _bignumber.default(txMeta.txReceipt.gasUsed, 16).div(txMeta.swapMetaData.estimated_gas, 10).times(100).round(2)}%` : null;

        this._trackMetaMetricsEvent({
          event: 'Swap Completed',
          category: 'swaps',
          sensitiveProperties: _objectSpread(_objectSpread({}, txMeta.swapMetaData), {}, {
            token_to_amount_received: tokensReceived,
            quote_vs_executionRatio: quoteVsExecutionRatio,
            estimated_vs_used_gasRatio: estimatedVsUsedGasRatio
          })
        });
      }
    }
  }

  async _buildEventFragmentProperties(txMeta, extraParams) {
    const {
      type,
      time,
      status,
      chainId,
      origin: referrer,
      txParams: {
        gasPrice,
        gas: gasLimit,
        maxFeePerGas,
        maxPriorityFeePerGas,
        estimateSuggested,
        estimateUsed
      },
      defaultGasEstimates,
      metamaskNetworkId: network
    } = txMeta;
    const source = referrer === 'metamask' ? 'user' : 'dapp';
    const gasParams = {};

    if ((0, _transaction2.isEIP1559Transaction)(txMeta)) {
      gasParams.max_fee_per_gas = maxFeePerGas;
      gasParams.max_priority_fee_per_gas = maxPriorityFeePerGas;
    } else {
      gasParams.gas_price = gasPrice;
    }

    if (defaultGasEstimates) {
      const {
        estimateType
      } = defaultGasEstimates;

      if (estimateType) {
        gasParams.default_estimate = estimateType;
        let defaultMaxFeePerGas = txMeta.defaultGasEstimates.maxFeePerGas;
        let defaultMaxPriorityFeePerGas = txMeta.defaultGasEstimates.maxPriorityFeePerGas;

        if ([_gas.GAS_RECOMMENDATIONS.LOW, _gas.GAS_RECOMMENDATIONS.MEDIUM, _gas.GAS_RECOMMENDATIONS.MEDIUM.HIGH].includes(estimateType)) {
          var _gasFeeEstimates$esti, _gasFeeEstimates$esti3;

          const {
            gasFeeEstimates
          } = await this._getEIP1559GasFeeEstimates();

          if (gasFeeEstimates !== null && gasFeeEstimates !== void 0 && (_gasFeeEstimates$esti = gasFeeEstimates[estimateType]) !== null && _gasFeeEstimates$esti !== void 0 && _gasFeeEstimates$esti.suggestedMaxFeePerGas) {
            var _gasFeeEstimates$esti2;

            defaultMaxFeePerGas = (_gasFeeEstimates$esti2 = gasFeeEstimates[estimateType]) === null || _gasFeeEstimates$esti2 === void 0 ? void 0 : _gasFeeEstimates$esti2.suggestedMaxFeePerGas;
            gasParams.default_max_fee_per_gas = defaultMaxFeePerGas;
          }

          if (gasFeeEstimates !== null && gasFeeEstimates !== void 0 && (_gasFeeEstimates$esti3 = gasFeeEstimates[estimateType]) !== null && _gasFeeEstimates$esti3 !== void 0 && _gasFeeEstimates$esti3.suggestedMaxPriorityFeePerGas) {
            var _gasFeeEstimates$esti4;

            defaultMaxPriorityFeePerGas = (_gasFeeEstimates$esti4 = gasFeeEstimates[estimateType]) === null || _gasFeeEstimates$esti4 === void 0 ? void 0 : _gasFeeEstimates$esti4.suggestedMaxPriorityFeePerGas;
            gasParams.default_max_priority_fee_per_gas = defaultMaxPriorityFeePerGas;
          }
        }
      }

      if (txMeta.defaultGasEstimates.gas) {
        gasParams.default_gas = txMeta.defaultGasEstimates.gas;
      }

      if (txMeta.defaultGasEstimates.gasPrice) {
        gasParams.default_gas_price = txMeta.defaultGasEstimates.gasPrice;
      }
    }

    if (estimateSuggested) {
      gasParams.estimate_suggested = estimateSuggested;
    }

    if (estimateUsed) {
      gasParams.estimate_used = estimateUsed;
    }

    const gasParamsInGwei = this._getGasValuesInGWEI(gasParams);

    let eip1559Version = '0';

    if (txMeta.txParams.maxFeePerGas) {
      const {
        eip1559V2Enabled
      } = this.preferencesStore.getState();
      eip1559Version = eip1559V2Enabled ? '2' : '1';
    }

    const properties = {
      chain_id: chainId,
      referrer,
      source,
      network,
      type,
      eip_1559_version: eip1559Version,
      gas_edit_type: 'none',
      gas_edit_attempted: 'none'
    };

    const sensitiveProperties = _objectSpread(_objectSpread({
      status,
      transaction_envelope_type: (0, _transaction2.isEIP1559Transaction)(txMeta) ? _transactions.TRANSACTION_ENVELOPE_TYPE_NAMES.FEE_MARKET : _transactions.TRANSACTION_ENVELOPE_TYPE_NAMES.LEGACY,
      first_seen: time,
      gas_limit: gasLimit
    }, gasParamsInGwei), extraParams);

    return {
      properties,
      sensitiveProperties
    };
  }
  /**
   * Helper method that checks for the presence of an existing fragment by id
   * appropriate for the type of event that triggered fragment creation. If the
   * appropriate fragment exists, then nothing is done. If it does not exist a
   * new event fragment is created with the appropriate payload.
   *
   * @param {TransactionMeta} txMeta - Transaction meta object
   * @param {TransactionMetaMetricsEventString} event - The event type that
   *  triggered fragment creation
   * @param {Object} properties - properties to include in the fragment
   * @param {Object} [sensitiveProperties] - sensitive properties to include in
   *  the fragment
   */


  _createTransactionEventFragment(txMeta, event, properties, sensitiveProperties) {
    const isSubmitted = [_transaction.TRANSACTION_EVENTS.FINALIZED, _transaction.TRANSACTION_EVENTS.SUBMITTED].includes(event);
    const uniqueIdentifier = `transaction-${isSubmitted ? 'submitted' : 'added'}-${txMeta.id}`;
    const fragment = this.getEventFragmentById(uniqueIdentifier);

    if (typeof fragment !== 'undefined') {
      return;
    }

    switch (event) {
      // When a transaction is added to the controller, we know that the user
      // will be presented with a confirmation screen. The user will then
      // either confirm or reject that transaction. Each has an associated
      // event we want to track. While we don't necessarily need an event
      // fragment to model this, having one allows us to record additional
      // properties onto the event from the UI. For example, when the user
      // edits the transactions gas params we can record that property and
      // then get analytics on the number of transactions in which gas edits
      // occur.
      case _transaction.TRANSACTION_EVENTS.ADDED:
        this.createEventFragment({
          category: 'Transactions',
          initialEvent: _transaction.TRANSACTION_EVENTS.ADDED,
          successEvent: _transaction.TRANSACTION_EVENTS.APPROVED,
          failureEvent: _transaction.TRANSACTION_EVENTS.REJECTED,
          properties,
          sensitiveProperties,
          persist: true,
          uniqueIdentifier
        });
        break;
      // If for some reason an approval or rejection occurs without the added
      // fragment existing in memory, we create the added fragment but without
      // the initialEvent firing. This is to prevent possible duplication of
      // events. A good example why this might occur is if the user had
      // unapproved transactions in memory when updating to the version that
      // includes this change. A migration would have also helped here but this
      // implementation hardens against other possible bugs where a fragment
      // does not exist.

      case _transaction.TRANSACTION_EVENTS.APPROVED:
      case _transaction.TRANSACTION_EVENTS.REJECTED:
        this.createEventFragment({
          category: 'Transactions',
          successEvent: _transaction.TRANSACTION_EVENTS.APPROVED,
          failureEvent: _transaction.TRANSACTION_EVENTS.REJECTED,
          properties,
          sensitiveProperties,
          persist: true,
          uniqueIdentifier
        });
        break;
      // When a transaction is submitted it will always result in updating
      // to a finalized state (dropped, failed, confirmed) -- eventually.
      // However having a fragment started at this stage allows augmenting
      // analytics data with user interactions such as speeding up and
      // canceling the transactions. From this controllers perspective a new
      // transaction with a new id is generated for speed up and cancel
      // transactions, but from the UI we could augment the previous ID with
      // supplemental data to show user intent. Such as when they open the
      // cancel UI but don't submit. We can record that this happened and add
      // properties to the transaction event.

      case _transaction.TRANSACTION_EVENTS.SUBMITTED:
        this.createEventFragment({
          category: 'Transactions',
          initialEvent: _transaction.TRANSACTION_EVENTS.SUBMITTED,
          successEvent: _transaction.TRANSACTION_EVENTS.FINALIZED,
          properties,
          sensitiveProperties,
          persist: true,
          uniqueIdentifier
        });
        break;
      // If for some reason a transaction is finalized without the submitted
      // fragment existing in memory, we create the submitted fragment but
      // without the initialEvent firing. This is to prevent possible
      // duplication of events. A good example why this might occur is if th
      // user had pending transactions in memory when updating to the version
      // that includes this change. A migration would have also helped here but
      // this implementation hardens against other possible bugs where a
      // fragment does not exist.

      case _transaction.TRANSACTION_EVENTS.FINALIZED:
        this.createEventFragment({
          category: 'Transactions',
          successEvent: _transaction.TRANSACTION_EVENTS.FINALIZED,
          properties,
          sensitiveProperties,
          persist: true,
          uniqueIdentifier
        });
        break;

      default:
        break;
    }
  }
  /**
   * Extracts relevant properties from a transaction meta
   * object and uses them to create and send metrics for various transaction
   * events.
   *
   * @param {Object} txMeta - the txMeta object
   * @param {TransactionMetaMetricsEventString} event - the name of the transaction event
   * @param {Object} extraParams - optional props and values to include in sensitiveProperties
   */


  async _trackTransactionMetricsEvent(txMeta, event, extraParams = {}) {
    if (!txMeta) {
      return;
    }

    const {
      properties,
      sensitiveProperties
    } = await this._buildEventFragmentProperties(txMeta, extraParams); // Create event fragments for event types that spawn fragments, and ensure
    // existence of fragments for event types that act upon them.

    this._createTransactionEventFragment(txMeta, event, properties, sensitiveProperties);

    let id;

    switch (event) {
      // If the user approves a transaction, finalize the transaction added
      // event fragment.
      case _transaction.TRANSACTION_EVENTS.APPROVED:
        id = `transaction-added-${txMeta.id}`;
        this.updateEventFragment(id, {
          properties,
          sensitiveProperties
        });
        this.finalizeEventFragment(id);
        break;
      // If the user rejects a transaction, finalize the transaction added
      // event fragment. with the abandoned flag set.

      case _transaction.TRANSACTION_EVENTS.REJECTED:
        id = `transaction-added-${txMeta.id}`;
        this.updateEventFragment(id, {
          properties,
          sensitiveProperties
        });
        this.finalizeEventFragment(id, {
          abandoned: true
        });
        break;
      // When a transaction is finalized, also finalize the transaction
      // submitted event fragment.

      case _transaction.TRANSACTION_EVENTS.FINALIZED:
        id = `transaction-submitted-${txMeta.id}`;
        this.updateEventFragment(id, {
          properties,
          sensitiveProperties
        });
        this.finalizeEventFragment(`transaction-submitted-${txMeta.id}`);
        break;

      default:
        break;
    }
  }

  _getTransactionCompletionTime(submittedTime) {
    return Math.round((Date.now() - submittedTime) / 1000).toString();
  }

  _getGasValuesInGWEI(gasParams) {
    const gasValuesInGwei = {};

    for (const param in gasParams) {
      if ((0, _ethereumjsUtil.isHexString)(gasParams[param])) {
        gasValuesInGwei[param] = (0, _conversions.hexWEIToDecGWEI)(gasParams[param]);
      } else {
        gasValuesInGwei[param] = gasParams[param];
      }
    }

    return gasValuesInGwei;
  }

  _failTransaction(txId, error) {
    this.txStateManager.setTxStatusFailed(txId, error);
    const txMeta = this.txStateManager.getTransaction(txId);

    this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.FINALIZED, {
      error: error.message
    });
  }

  _dropTransaction(txId) {
    this.txStateManager.setTxStatusDropped(txId);
    const txMeta = this.txStateManager.getTransaction(txId);

    this._trackTransactionMetricsEvent(txMeta, _transaction.TRANSACTION_EVENTS.FINALIZED);
  }

}

exports.default = TransactionController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\segment.js", {"../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","analytics-node":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\segment.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.segment = exports.createSegmentMock = void 0;

var _analyticsNode = _interopRequireDefault(require("analytics-node"));

var _time = require("../../../shared/constants/time");

var _process$env$SEGMENT_, _process$env$SEGMENT_2;

const isDevOrTestEnvironment = Boolean(true || process.env.IN_TEST);
const SEGMENT_WRITE_KEY = (_process$env$SEGMENT_ = process.env.SEGMENT_WRITE_KEY) !== null && _process$env$SEGMENT_ !== void 0 ? _process$env$SEGMENT_ : null;
const SEGMENT_HOST = (_process$env$SEGMENT_2 = process.env.SEGMENT_HOST) !== null && _process$env$SEGMENT_2 !== void 0 ? _process$env$SEGMENT_2 : null; // flushAt controls how many events are sent to segment at once. Segment will
// hold onto a queue of events until it hits this number, then it sends them as
// a batch. This setting defaults to 20, but in development we likely want to
// see events in real time for debugging, so this is set to 1 to disable the
// queueing mechanism.

const SEGMENT_FLUSH_AT = "development" === 'production' ? undefined : 1; // flushInterval controls how frequently the queue is flushed to segment.
// This happens regardless of the size of the queue. The default setting is
// 10,000ms (10 seconds). This default is rather high, though thankfully
// using the background process as our event handler means we don't have to
// deal with short lived sessions that happen faster than the interval
// e.g confirmations. This is set to 5,000ms (5 seconds) arbitrarily with the
// intent of having a value less than 10 seconds.

const SEGMENT_FLUSH_INTERVAL = _time.SECOND * 5;
/**
 * Creates a mock segment module for usage in test environments. This is used
 * when building the application in test mode to catch event calls and prevent
 * them from being sent to segment. It is also used in unit tests to mock and
 * spy on the methods to ensure proper behavior
 *
 * @param {number} flushAt - number of events to queue before sending to segment
 * @returns {SegmentInterface}
 */

const createSegmentMock = (flushAt = SEGMENT_FLUSH_AT) => {
  const segmentMock = {
    // Internal queue to keep track of events and properly mimic segment's
    // queueing behavior.
    queue: [],

    /**
     * Used to immediately send all queued events and reset the queue to zero.
     * For our purposes this simply triggers the callback method registered with
     * the event.
     */
    flush() {
      segmentMock.queue.forEach(([_, callback]) => {
        callback();
      });
      segmentMock.queue = [];
    },

    /**
     * Track an event and add it to the queue. If the queue size reaches the
     * flushAt threshold, flush the queue.
     *
     * @param payload
     * @param callback
     */
    track(payload, callback = () => undefined) {
      segmentMock.queue.push([payload, callback]);

      if (segmentMock.queue.length >= flushAt) {
        segmentMock.flush();
      }
    },

    /**
     * A true NOOP, these methods are either not used or do not await callback
     * and therefore require no functionality.
     */
    page() {// noop
    },

    identify() {// noop
    }

  };
  return segmentMock;
};

exports.createSegmentMock = createSegmentMock;
const segment = !SEGMENT_WRITE_KEY || isDevOrTestEnvironment && !SEGMENT_HOST ? createSegmentMock(SEGMENT_FLUSH_AT, SEGMENT_FLUSH_INTERVAL) : new _analyticsNode.default(SEGMENT_WRITE_KEY, {
  host: SEGMENT_HOST,
  flushAt: SEGMENT_FLUSH_AT,
  flushInterval: SEGMENT_FLUSH_INTERVAL
});
exports.segment = segment;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\segment.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\account-import-strategies\\index.js", {"../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethereumjs-wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\index.js","ethereumjs-wallet/thirdparty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\thirdparty.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\account-import-strategies\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethereumjsWallet = _interopRequireDefault(require("ethereumjs-wallet"));

var _thirdparty = _interopRequireDefault(require("ethereumjs-wallet/thirdparty"));

var _ethereumjsUtil = require("ethereumjs-util");

var _util = require("../lib/util");

const accountImporter = {
  importAccount(strategy, args) {
    try {
      const importer = this.strategies[strategy];
      const privateKeyHex = importer(...args);
      return Promise.resolve(privateKeyHex);
    } catch (e) {
      return Promise.reject(e);
    }
  },

  strategies: {
    'Private Key': privateKey => {
      if (!privateKey) {
        throw new Error('Cannot import an empty key.');
      }

      const prefixed = (0, _util.addHexPrefix)(privateKey);
      const buffer = (0, _ethereumjsUtil.toBuffer)(prefixed);

      if (!(0, _ethereumjsUtil.isValidPrivate)(buffer)) {
        throw new Error('Cannot import invalid private key.');
      }

      const stripped = (0, _ethereumjsUtil.stripHexPrefix)(prefixed);
      return stripped;
    },
    'JSON File': (input, password) => {
      let wallet;

      try {
        wallet = _thirdparty.default.fromEtherWallet(input, password);
      } catch (e) {
        _loglevel.default.debug('Attempt to import as EtherWallet format failed, trying V3');

        wallet = _ethereumjsWallet.default.fromV3(input, password, true);
      }

      return walletToPrivateKey(wallet);
    }
  }
};

function walletToPrivateKey(wallet) {
  const privateKeyBuffer = wallet.getPrivateKey();
  return (0, _ethereumjsUtil.bufferToHex)(privateKeyBuffer);
}

var _default = accountImporter;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\account-import-strategies\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\index.js", {"./network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\network.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "NETWORK_EVENTS", {
  enumerable: true,
  get: function () {
    return _network.NETWORK_EVENTS;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _network.default;
  }
});

var _network = _interopRequireWildcard(require("./network"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\swaps.js", {"../../../shared/constants/gas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\gas.js","../../../shared/constants/swaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\swaps.js","../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../shared/modules/conversion.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\conversion.utils.js","../../../shared/modules/swaps.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\swaps.utils.js","../../../ui/helpers/utils/fetch-with-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\fetch-with-cache.js","../../../ui/helpers/utils/token-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\token-util.js","../../../ui/helpers/utils/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\util.js","../../../ui/pages/send/send.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.utils.js","../../../ui/pages/swaps/swaps.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\swaps\\swaps.util.js","./network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\index.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bignumber.js\\bignumber.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js","human-standard-token-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\human-standard-token-abi\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\swaps.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _ethers = require("ethers");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _obsStore = require("@metamask/obs-store");

var _lodash = require("lodash");

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _tokenUtil = require("../../../ui/helpers/utils/token-util");

var _send = require("../../../ui/pages/send/send.utils");

var _conversion = require("../../../shared/modules/conversion.utils");

var _swaps = require("../../../shared/constants/swaps");

var _gas = require("../../../shared/constants/gas");

var _swaps2 = require("../../../shared/modules/swaps.utils");

var _swaps3 = require("../../../ui/pages/swaps/swaps.util");

var _fetchWithCache = _interopRequireDefault(require("../../../ui/helpers/utils/fetch-with-cache"));

var _time = require("../../../shared/constants/time");

var _util = require("../../../ui/helpers/utils/util");

var _network = require("./network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// The MAX_GAS_LIMIT is a number that is higher than the maximum gas costs we have observed on any aggregator
const MAX_GAS_LIMIT = 2500000; // To ensure that our serves are not spammed if MetaMask is left idle, we limit the number of fetches for quotes that are made on timed intervals.
// 3 seems to be an appropriate balance of giving users the time they need when MetaMask is not left idle, and turning polling off when it is.

const POLL_COUNT_LIMIT = 3; // If for any reason the MetaSwap API fails to provide a refresh time,
// provide a reasonable fallback to avoid further errors

const FALLBACK_QUOTE_REFRESH_TIME = _time.MINUTE;
const FALLBACK_SMART_TRANSACTION_REFRESH_TIME = _time.SECOND * 10;
const FALLBACK_SMART_TRANSACTIONS_DEADLINE = 180;

function calculateGasEstimateWithRefund(maxGas = MAX_GAS_LIMIT, estimatedRefund = 0, estimatedGas = 0) {
  const maxGasMinusRefund = new _bignumber.default(maxGas, 10).minus(estimatedRefund, 10);
  const isMaxGasMinusRefundNegative = maxGasMinusRefund.lt(0);
  const gasEstimateWithRefund = !isMaxGasMinusRefundNegative && maxGasMinusRefund.lt(estimatedGas, 16) ? `0x${maxGasMinusRefund.toString(16)}` : estimatedGas;
  return gasEstimateWithRefund;
}

const initialState = {
  swapsState: {
    quotes: {},
    quotesPollingLimitEnabled: false,
    fetchParams: null,
    tokens: null,
    tradeTxId: null,
    approveTxId: null,
    quotesLastFetched: null,
    customMaxGas: '',
    customGasPrice: null,
    customMaxFeePerGas: null,
    customMaxPriorityFeePerGas: null,
    swapsUserFeeLevel: '',
    selectedAggId: null,
    customApproveTxData: '',
    errorKey: '',
    topAggId: null,
    routeState: '',
    swapsFeatureIsLive: true,
    saveFetchedQuotes: false,
    swapsQuoteRefreshTime: FALLBACK_QUOTE_REFRESH_TIME,
    swapsQuotePrefetchingRefreshTime: FALLBACK_QUOTE_REFRESH_TIME,
    swapsStxBatchStatusRefreshTime: FALLBACK_SMART_TRANSACTION_REFRESH_TIME,
    swapsStxGetTransactionsRefreshTime: FALLBACK_SMART_TRANSACTION_REFRESH_TIME,
    swapsFeatureFlags: {}
  }
};

class SwapsController {
  constructor({
    getBufferedGasLimit,
    networkController,
    provider,
    getProviderConfig,
    getTokenRatesState,
    fetchTradesInfo = _swaps3.fetchTradesInfo,
    getCurrentChainId,
    getEIP1559GasFeeEstimates
  }) {
    this.store = new _obsStore.ObservableStore({
      swapsState: _objectSpread({}, initialState.swapsState)
    });
    this._fetchTradesInfo = fetchTradesInfo;
    this._getCurrentChainId = getCurrentChainId;
    this._getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.getBufferedGasLimit = getBufferedGasLimit;
    this.getTokenRatesState = getTokenRatesState;
    this.pollCount = 0;
    this.getProviderConfig = getProviderConfig;
    this.indexOfNewestCallInFlight = 0;
    this.ethersProvider = new _ethers.ethers.providers.Web3Provider(provider);
    this._currentNetwork = networkController.store.getState().network;
    networkController.on(_network.NETWORK_EVENTS.NETWORK_DID_CHANGE, network => {
      if (network !== 'loading' && network !== this._currentNetwork) {
        this._currentNetwork = network;
        this.ethersProvider = new _ethers.ethers.providers.Web3Provider(provider);
      }
    });
  }

  async fetchSwapsRefreshRates(chainId) {
    const response = await (0, _fetchWithCache.default)((0, _swaps3.getBaseApi)('network', chainId), {
      method: 'GET'
    }, {
      cacheRefreshTime: 600000
    });
    const {
      refreshRates
    } = response || {};

    if (!refreshRates || typeof refreshRates.quotes !== 'number' || typeof refreshRates.quotesPrefetching !== 'number' || typeof refreshRates.stxGetTransactions !== 'number' || typeof refreshRates.stxBatchStatus !== 'number') {
      throw new Error(`MetaMask - invalid response for refreshRates: ${response}`);
    } // We presently use milliseconds in the UI.


    return {
      quotes: refreshRates.quotes * 1000,
      quotesPrefetching: refreshRates.quotesPrefetching * 1000,
      stxGetTransactions: refreshRates.stxGetTransactions * 1000,
      stxBatchStatus: refreshRates.stxBatchStatus * 1000,
      stxStatusDeadline: refreshRates.stxStatusDeadline
    };
  } // Sets the refresh rate for quote updates from the MetaSwap API


  async _setSwapsRefreshRates() {
    var _swapsRefreshRates, _swapsRefreshRates2, _swapsRefreshRates3, _swapsRefreshRates4, _swapsRefreshRates5;

    const chainId = this._getCurrentChainId();

    let swapsRefreshRates;

    try {
      swapsRefreshRates = await this.fetchSwapsRefreshRates(chainId);
    } catch (e) {
      console.error('Request for swaps quote refresh time failed: ', e);
    }

    const {
      swapsState: latestSwapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, latestSwapsState), {}, {
        swapsQuoteRefreshTime: ((_swapsRefreshRates = swapsRefreshRates) === null || _swapsRefreshRates === void 0 ? void 0 : _swapsRefreshRates.quotes) || FALLBACK_QUOTE_REFRESH_TIME,
        swapsQuotePrefetchingRefreshTime: ((_swapsRefreshRates2 = swapsRefreshRates) === null || _swapsRefreshRates2 === void 0 ? void 0 : _swapsRefreshRates2.quotesPrefetching) || FALLBACK_QUOTE_REFRESH_TIME,
        swapsStxGetTransactionsRefreshTime: ((_swapsRefreshRates3 = swapsRefreshRates) === null || _swapsRefreshRates3 === void 0 ? void 0 : _swapsRefreshRates3.stxGetTransactions) || FALLBACK_SMART_TRANSACTION_REFRESH_TIME,
        swapsStxBatchStatusRefreshTime: ((_swapsRefreshRates4 = swapsRefreshRates) === null || _swapsRefreshRates4 === void 0 ? void 0 : _swapsRefreshRates4.stxBatchStatus) || FALLBACK_SMART_TRANSACTION_REFRESH_TIME,
        swapsStxStatusDeadline: ((_swapsRefreshRates5 = swapsRefreshRates) === null || _swapsRefreshRates5 === void 0 ? void 0 : _swapsRefreshRates5.stxStatusDeadline) || FALLBACK_SMART_TRANSACTIONS_DEADLINE
      })
    });
  } // Once quotes are fetched, we poll for new ones to keep the quotes up to date. Market and aggregator contract conditions can change fast enough
  // that quotes will no longer be available after 1 or 2 minutes. When fetchAndSetQuotes is first called, it receives fetch parameters that are stored in
  // state. These stored parameters are used on subsequent calls made during polling.
  // Note: we stop polling after 3 requests, until new quotes are explicitly asked for. The logic that enforces that maximum is in the body of fetchAndSetQuotes


  pollForNewQuotes() {
    const {
      swapsState: {
        swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime,
        quotesPollingLimitEnabled
      }
    } = this.store.getState(); // swapsQuoteRefreshTime is used on the View Quote page, swapsQuotePrefetchingRefreshTime is used on the Build Quote page.

    const quotesRefreshRateInMs = quotesPollingLimitEnabled ? swapsQuoteRefreshTime : swapsQuotePrefetchingRefreshTime;
    this.pollingTimeout = setTimeout(() => {
      var _swapsState$fetchPara;

      const {
        swapsState
      } = this.store.getState();
      this.fetchAndSetQuotes(swapsState.fetchParams, (_swapsState$fetchPara = swapsState.fetchParams) === null || _swapsState$fetchPara === void 0 ? void 0 : _swapsState$fetchPara.metaData, true);
    }, quotesRefreshRateInMs);
  }

  stopPollingForQuotes() {
    if (this.pollingTimeout) {
      clearTimeout(this.pollingTimeout);
    }
  }

  async fetchAndSetQuotes(fetchParams, fetchParamsMetaData = {}, isPolledRequest) {
    const {
      chainId
    } = fetchParamsMetaData;
    const {
      swapsState: {
        quotesPollingLimitEnabled,
        saveFetchedQuotes
      }
    } = this.store.getState();

    if (!fetchParams) {
      return null;
    } // Every time we get a new request that is not from the polling, we reset the poll count so we can poll for up to three more sets of quotes with these new params.


    if (!isPolledRequest) {
      this.pollCount = 0;
    } // If there are any pending poll requests, clear them so that they don't get call while this new fetch is in process


    clearTimeout(this.pollingTimeout);

    if (!isPolledRequest) {
      this.setSwapsErrorKey('');
    }

    const indexOfCurrentCall = this.indexOfNewestCallInFlight + 1;
    this.indexOfNewestCallInFlight = indexOfCurrentCall;

    if (!saveFetchedQuotes) {
      this.setSaveFetchedQuotes(true);
    }

    let [newQuotes] = await Promise.all([this._fetchTradesInfo(fetchParams, _objectSpread({}, fetchParamsMetaData)), this._setSwapsRefreshRates()]);
    const {
      swapsState: {
        saveFetchedQuotes: saveFetchedQuotesAfterResponse
      }
    } = this.store.getState(); // If saveFetchedQuotesAfterResponse is false, it means a user left Swaps (we cleaned the state)
    // and we don't want to set any API response with quotes into state.

    if (!saveFetchedQuotesAfterResponse) {
      return [{}, // quotes
      null // selectedAggId
      ];
    }

    newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
      sourceTokenInfo: fetchParamsMetaData.sourceTokenInfo,
      destinationTokenInfo: fetchParamsMetaData.destinationTokenInfo
    }));
    const quotesLastFetched = Date.now();
    let approvalRequired = false;

    if (!(0, _swaps2.isSwapsDefaultTokenAddress)(fetchParams.sourceToken, chainId) && Object.values(newQuotes).length) {
      const allowance = await this._getERC20Allowance(fetchParams.sourceToken, fetchParams.fromAddress, chainId);
      const [firstQuote] = Object.values(newQuotes); // For a user to be able to swap a token, they need to have approved the MetaSwap contract to withdraw that token.
      // _getERC20Allowance() returns the amount of the token they have approved for withdrawal. If that amount is greater
      // than 0, it means that approval has already occurred and is not needed. Otherwise, for tokens to be swapped, a new
      // call of the ERC-20 approve method is required.

      approvalRequired = firstQuote.approvalNeeded && allowance.eq(0) && firstQuote.aggregator !== 'wrappedNative';

      if (!approvalRequired) {
        newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
          approvalNeeded: null
        }));
      } else if (!isPolledRequest) {
        const {
          gasLimit: approvalGas
        } = await this.timedoutGasReturn(firstQuote.approvalNeeded);
        newQuotes = (0, _lodash.mapValues)(newQuotes, quote => _objectSpread(_objectSpread({}, quote), {}, {
          approvalNeeded: _objectSpread(_objectSpread({}, quote.approvalNeeded), {}, {
            gas: approvalGas || _swaps.DEFAULT_ERC20_APPROVE_GAS
          })
        }));
      }
    }

    let topAggId = null; // We can reduce time on the loading screen by only doing this after the
    // loading screen and best quote have rendered.

    if (!approvalRequired && !(fetchParams !== null && fetchParams !== void 0 && fetchParams.balanceError)) {
      newQuotes = await this.getAllQuotesWithGasEstimates(newQuotes);
    }

    if (Object.values(newQuotes).length === 0) {
      this.setSwapsErrorKey(_swaps.QUOTES_NOT_AVAILABLE_ERROR);
    } else {
      const [_topAggId, quotesWithSavingsAndFeeData] = await this._findTopQuoteAndCalculateSavings(newQuotes);
      topAggId = _topAggId;
      newQuotes = quotesWithSavingsAndFeeData;
    } // If a newer call has been made, don't update state with old information
    // Prevents timing conflicts between fetches


    if (this.indexOfNewestCallInFlight !== indexOfCurrentCall) {
      throw new Error(_swaps.SWAPS_FETCH_ORDER_CONFLICT);
    }

    const {
      swapsState
    } = this.store.getState();
    let {
      selectedAggId
    } = swapsState;

    if (!newQuotes[selectedAggId]) {
      selectedAggId = null;
    }

    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: newQuotes,
        fetchParams: _objectSpread(_objectSpread({}, fetchParams), {}, {
          metaData: fetchParamsMetaData
        }),
        quotesLastFetched,
        selectedAggId,
        topAggId
      })
    });

    if (quotesPollingLimitEnabled) {
      // We only want to do up to a maximum of three requests from polling if polling limit is enabled.
      // Otherwise we won't increase pollCount, so polling will run without a limit.
      this.pollCount += 1;
    }

    if (!quotesPollingLimitEnabled || this.pollCount < POLL_COUNT_LIMIT + 1) {
      this.pollForNewQuotes();
    } else {
      this.resetPostFetchState();
      this.setSwapsErrorKey(_swaps.QUOTES_EXPIRED_ERROR);
      return null;
    }

    return [newQuotes, topAggId];
  }

  safeRefetchQuotes() {
    const {
      swapsState
    } = this.store.getState();

    if (!this.pollingTimeout && swapsState.fetchParams) {
      this.fetchAndSetQuotes(swapsState.fetchParams);
    }
  }

  setSelectedQuoteAggId(selectedAggId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        selectedAggId
      })
    });
  }

  setSwapsTokens(tokens) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        tokens
      })
    });
  }

  clearSwapsQuotes() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: {}
      })
    });
  }

  setSwapsErrorKey(errorKey) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        errorKey
      })
    });
  }

  async getAllQuotesWithGasEstimates(quotes) {
    const quoteGasData = await Promise.all(Object.values(quotes).map(async quote => {
      const {
        gasLimit,
        simulationFails
      } = await this.timedoutGasReturn(quote.trade);
      return [gasLimit, simulationFails, quote.aggregator];
    }));
    const newQuotes = {};
    quoteGasData.forEach(([gasLimit, simulationFails, aggId]) => {
      if (gasLimit && !simulationFails) {
        const gasEstimateWithRefund = calculateGasEstimateWithRefund(quotes[aggId].maxGas, quotes[aggId].estimatedRefund, gasLimit);
        newQuotes[aggId] = _objectSpread(_objectSpread({}, quotes[aggId]), {}, {
          gasEstimate: gasLimit,
          gasEstimateWithRefund
        });
      } else if (quotes[aggId].approvalNeeded) {
        // If gas estimation fails, but an ERC-20 approve is needed, then we do not add any estimate property to the quote object
        // Such quotes will rely on the maxGas and averageGas properties from the api
        newQuotes[aggId] = quotes[aggId];
      } // If gas estimation fails and no approval is needed, then we filter that quote out, so that it is not shown to the user

    });
    return newQuotes;
  }

  timedoutGasReturn(tradeTxParams) {
    return new Promise(resolve => {
      let gasTimedOut = false;
      const gasTimeout = setTimeout(() => {
        gasTimedOut = true;
        resolve({
          gasLimit: null,
          simulationFails: true
        });
      }, _time.SECOND * 5); // Remove gas from params that will be passed to the `estimateGas` call
      // Including it can cause the estimate to fail if the actual gas needed
      // exceeds the passed gas

      const tradeTxParamsForGasEstimate = {
        data: tradeTxParams.data,
        from: tradeTxParams.from,
        to: tradeTxParams.to,
        value: tradeTxParams.value
      };
      this.getBufferedGasLimit({
        txParams: tradeTxParamsForGasEstimate
      }, 1).then(({
        gasLimit,
        simulationFails
      }) => {
        if (!gasTimedOut) {
          clearTimeout(gasTimeout);
          resolve({
            gasLimit,
            simulationFails
          });
        }
      }).catch(e => {
        _loglevel.default.error(e);

        if (!gasTimedOut) {
          clearTimeout(gasTimeout);
          resolve({
            gasLimit: null,
            simulationFails: true
          });
        }
      });
    });
  }

  async setInitialGasEstimate(initialAggId) {
    const {
      swapsState
    } = this.store.getState();

    const quoteToUpdate = _objectSpread({}, swapsState.quotes[initialAggId]);

    const {
      gasLimit: newGasEstimate,
      simulationFails
    } = await this.timedoutGasReturn(quoteToUpdate.trade);

    if (newGasEstimate && !simulationFails) {
      const gasEstimateWithRefund = calculateGasEstimateWithRefund(quoteToUpdate.maxGas, quoteToUpdate.estimatedRefund, newGasEstimate);
      quoteToUpdate.gasEstimate = newGasEstimate;
      quoteToUpdate.gasEstimateWithRefund = gasEstimateWithRefund;
    }

    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotes: _objectSpread(_objectSpread({}, swapsState.quotes), {}, {
          [initialAggId]: quoteToUpdate
        })
      })
    });
  }

  setApproveTxId(approveTxId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        approveTxId
      })
    });
  }

  setTradeTxId(tradeTxId) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        tradeTxId
      })
    });
  }

  setQuotesLastFetched(quotesLastFetched) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotesLastFetched
      })
    });
  }

  setSwapsTxGasPrice(gasPrice) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customGasPrice: gasPrice
      })
    });
  }

  setSwapsTxMaxFeePerGas(maxFeePerGas) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxFeePerGas: maxFeePerGas
      })
    });
  }

  setSwapsUserFeeLevel(swapsUserFeeLevel) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        swapsUserFeeLevel
      })
    });
  }

  setSwapsQuotesPollingLimitEnabled(quotesPollingLimitEnabled) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        quotesPollingLimitEnabled
      })
    });
  }

  setSwapsTxMaxFeePriorityPerGas(maxPriorityFeePerGas) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxPriorityFeePerGas: maxPriorityFeePerGas
      })
    });
  }

  setSwapsTxGasLimit(gasLimit) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customMaxGas: gasLimit
      })
    });
  }

  setCustomApproveTxData(data) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        customApproveTxData: data
      })
    });
  }

  setBackgroundSwapRouteState(routeState) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        routeState
      })
    });
  }

  setSaveFetchedQuotes(status) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        saveFetchedQuotes: status
      })
    });
  }

  setSwapsLiveness(swapsLiveness) {
    const {
      swapsState
    } = this.store.getState();
    const {
      swapsFeatureIsLive
    } = swapsLiveness;
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        swapsFeatureIsLive
      })
    });
  }

  setSwapsFeatureFlags(swapsFeatureFlags) {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, swapsState), {}, {
        swapsFeatureFlags
      })
    });
  }

  resetPostFetchState() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, initialState.swapsState), {}, {
        tokens: swapsState.tokens,
        fetchParams: swapsState.fetchParams,
        swapsFeatureIsLive: swapsState.swapsFeatureIsLive,
        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime: swapsState.swapsQuotePrefetchingRefreshTime,
        swapsFeatureFlags: swapsState.swapsFeatureFlags
      })
    });
    clearTimeout(this.pollingTimeout);
  }

  resetSwapsState() {
    const {
      swapsState
    } = this.store.getState();
    this.store.updateState({
      swapsState: _objectSpread(_objectSpread({}, initialState.swapsState), {}, {
        swapsQuoteRefreshTime: swapsState.swapsQuoteRefreshTime,
        swapsQuotePrefetchingRefreshTime: swapsState.swapsQuotePrefetchingRefreshTime
      })
    });
    clearTimeout(this.pollingTimeout);
  }

  async _findTopQuoteAndCalculateSavings(quotes = {}) {
    const {
      contractExchangeRates: tokenConversionRates
    } = this.getTokenRatesState();
    const {
      swapsState: {
        customGasPrice,
        customMaxPriorityFeePerGas
      }
    } = this.store.getState();

    const chainId = this._getCurrentChainId();

    const numQuotes = Object.keys(quotes).length;

    if (!numQuotes) {
      return {};
    }

    const newQuotes = (0, _lodash.cloneDeep)(quotes);
    const {
      gasFeeEstimates,
      gasEstimateType
    } = await this._getEIP1559GasFeeEstimates();
    let usedGasPrice = '0x0';

    if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
      const {
        high: {
          suggestedMaxPriorityFeePerGas
        },
        estimatedBaseFee
      } = gasFeeEstimates;
      usedGasPrice = (0, _conversion.addCurrencies)(customMaxPriorityFeePerGas || // Is already in hex WEI.
      (0, _conversion.decGWEIToHexWEI)(suggestedMaxPriorityFeePerGas), (0, _conversion.decGWEIToHexWEI)(estimatedBaseFee), {
        aBase: 16,
        bBase: 16,
        toNumericBase: 'hex',
        numberOfDecimals: 6
      });
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
      usedGasPrice = customGasPrice || (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.high);
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
      usedGasPrice = customGasPrice || (0, _conversion.decGWEIToHexWEI)(gasFeeEstimates.gasPrice);
    }

    let topAggId = null;
    let overallValueOfBestQuoteForSorting = null;
    Object.values(newQuotes).forEach(quote => {
      const {
        aggregator,
        approvalNeeded,
        averageGas,
        destinationAmount = 0,
        destinationToken,
        destinationTokenInfo,
        gasEstimate,
        sourceAmount,
        sourceToken,
        trade,
        fee: metaMaskFee
      } = quote;
      const tradeGasLimitForCalculation = gasEstimate ? new _bignumber.default(gasEstimate, 16) : new _bignumber.default(averageGas || MAX_GAS_LIMIT, 10);
      const totalGasLimitForCalculation = tradeGasLimitForCalculation.plus((approvalNeeded === null || approvalNeeded === void 0 ? void 0 : approvalNeeded.gas) || '0x0', 16).toString(16);
      const gasTotalInWeiHex = (0, _send.calcGasTotal)(totalGasLimitForCalculation, usedGasPrice); // trade.value is a sum of different values depending on the transaction.
      // It always includes any external fees charged by the quote source. In
      // addition, if the source asset is the selected chain's default token, trade.value
      // includes the amount of that token.

      const totalWeiCost = new _bignumber.default(gasTotalInWeiHex, 16).plus(trade.value, 16);
      const totalEthCost = (0, _conversion.conversionUtil)(totalWeiCost, {
        fromCurrency: 'ETH',
        fromDenomination: 'WEI',
        toDenomination: 'ETH',
        fromNumericBase: 'BN',
        numberOfDecimals: 6
      }); // The total fee is aggregator/exchange fees plus gas fees.
      // If the swap is from the selected chain's default token, subtract
      // the sourceAmount from the total cost. Otherwise, the total fee
      // is simply trade.value plus gas fees.

      const ethFee = (0, _swaps2.isSwapsDefaultTokenAddress)(sourceToken, chainId) ? (0, _conversion.conversionUtil)(totalWeiCost.minus(sourceAmount, 10), // sourceAmount is in wei
      {
        fromCurrency: 'ETH',
        fromDenomination: 'WEI',
        toDenomination: 'ETH',
        fromNumericBase: 'BN',
        numberOfDecimals: 6
      }) : totalEthCost;
      const decimalAdjustedDestinationAmount = (0, _tokenUtil.calcTokenAmount)(destinationAmount, destinationTokenInfo.decimals);
      const tokenPercentageOfPreFeeDestAmount = new _bignumber.default(100, 10).minus(metaMaskFee, 10).div(100);
      const destinationAmountBeforeMetaMaskFee = decimalAdjustedDestinationAmount.div(tokenPercentageOfPreFeeDestAmount);
      const metaMaskFeeInTokens = destinationAmountBeforeMetaMaskFee.minus(decimalAdjustedDestinationAmount);
      const tokenConversionRate = tokenConversionRates[Object.keys(tokenConversionRates).find(tokenAddress => (0, _util.isEqualCaseInsensitive)(tokenAddress, destinationToken))];
      const conversionRateForSorting = tokenConversionRate || 1;
      const ethValueOfTokens = decimalAdjustedDestinationAmount.times(conversionRateForSorting.toString(10), 10);
      const conversionRateForCalculations = (0, _swaps2.isSwapsDefaultTokenAddress)(destinationToken, chainId) ? 1 : tokenConversionRate;
      const overallValueOfQuoteForSorting = conversionRateForCalculations === undefined ? ethValueOfTokens : ethValueOfTokens.minus(ethFee, 10);
      quote.ethFee = ethFee.toString(10);

      if (conversionRateForCalculations !== undefined) {
        quote.ethValueOfTokens = ethValueOfTokens.toString(10);
        quote.overallValueOfQuote = overallValueOfQuoteForSorting.toString(10);
        quote.metaMaskFeeInEth = metaMaskFeeInTokens.times(conversionRateForCalculations.toString(10)).toString(10);
      }

      if (overallValueOfBestQuoteForSorting === null || overallValueOfQuoteForSorting.gt(overallValueOfBestQuoteForSorting)) {
        topAggId = aggregator;
        overallValueOfBestQuoteForSorting = overallValueOfQuoteForSorting;
      }
    });
    const isBest = (0, _swaps2.isSwapsDefaultTokenAddress)(newQuotes[topAggId].destinationToken, chainId) || Boolean(tokenConversionRates[Object.keys(tokenConversionRates).find(tokenAddress => {
      var _newQuotes$topAggId;

      return (0, _util.isEqualCaseInsensitive)(tokenAddress, (_newQuotes$topAggId = newQuotes[topAggId]) === null || _newQuotes$topAggId === void 0 ? void 0 : _newQuotes$topAggId.destinationToken);
    })]);
    let savings = null;

    if (isBest) {
      const bestQuote = newQuotes[topAggId];
      savings = {};
      const {
        ethFee: medianEthFee,
        metaMaskFeeInEth: medianMetaMaskFee,
        ethValueOfTokens: medianEthValueOfTokens
      } = getMedianEthValueQuote(Object.values(newQuotes)); // Performance savings are calculated as:
      //   (ethValueOfTokens for the best trade) - (ethValueOfTokens for the media trade)

      savings.performance = new _bignumber.default(bestQuote.ethValueOfTokens, 10).minus(medianEthValueOfTokens, 10); // Fee savings are calculated as:
      //   (fee for the median trade) - (fee for the best trade)

      savings.fee = new _bignumber.default(medianEthFee).minus(bestQuote.ethFee, 10);
      savings.metaMaskFee = bestQuote.metaMaskFeeInEth; // Total savings are calculated as:
      //   performance savings + fee savings - metamask fee

      savings.total = savings.performance.plus(savings.fee).minus(savings.metaMaskFee).toString(10);
      savings.performance = savings.performance.toString(10);
      savings.fee = savings.fee.toString(10);
      savings.medianMetaMaskFee = medianMetaMaskFee;
      newQuotes[topAggId].isBestQuote = true;
      newQuotes[topAggId].savings = savings;
    }

    return [topAggId, newQuotes];
  }

  async _getERC20Allowance(contractAddress, walletAddress, chainId) {
    const contract = new _ethers.ethers.Contract(contractAddress, _humanStandardTokenAbi.default, this.ethersProvider);
    return await contract.allowance(walletAddress, _swaps.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[chainId]);
  }

}
/**
 * Calculates the median overallValueOfQuote of a sample of quotes.
 *
 * @param {Array} _quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth, and ethValueOfTokens properties
 * @returns {Object} An object with the ethValueOfTokens, ethFee, and metaMaskFeeInEth of the quote with the median overallValueOfQuote
 */


exports.default = SwapsController;

function getMedianEthValueQuote(_quotes) {
  if (!Array.isArray(_quotes) || _quotes.length === 0) {
    throw new Error('Expected non-empty array param.');
  }

  const quotes = [..._quotes];
  quotes.sort((quoteA, quoteB) => {
    const overallValueOfQuoteA = new _bignumber.default(quoteA.overallValueOfQuote, 10);
    const overallValueOfQuoteB = new _bignumber.default(quoteB.overallValueOfQuote, 10);

    if (overallValueOfQuoteA.equals(overallValueOfQuoteB)) {
      return 0;
    }

    return overallValueOfQuoteA.lessThan(overallValueOfQuoteB) ? -1 : 1;
  });

  if (quotes.length % 2 === 1) {
    // return middle values
    const medianOverallValue = quotes[(quotes.length - 1) / 2].overallValueOfQuote;
    const quotesMatchingMedianQuoteValue = quotes.filter(quote => medianOverallValue === quote.overallValueOfQuote);
    return meansOfQuotesFeesAndValue(quotesMatchingMedianQuoteValue);
  } // return mean of middle two values


  const upperIndex = quotes.length / 2;
  const lowerIndex = upperIndex - 1;
  const overallValueAtUpperIndex = quotes[upperIndex].overallValueOfQuote;
  const overallValueAtLowerIndex = quotes[lowerIndex].overallValueOfQuote;
  const quotesMatchingUpperIndexValue = quotes.filter(quote => overallValueAtUpperIndex === quote.overallValueOfQuote);
  const quotesMatchingLowerIndexValue = quotes.filter(quote => overallValueAtLowerIndex === quote.overallValueOfQuote);
  const feesAndValueAtUpperIndex = meansOfQuotesFeesAndValue(quotesMatchingUpperIndexValue);
  const feesAndValueAtLowerIndex = meansOfQuotesFeesAndValue(quotesMatchingLowerIndexValue);
  return {
    ethFee: new _bignumber.default(feesAndValueAtUpperIndex.ethFee, 10).plus(feesAndValueAtLowerIndex.ethFee, 10).dividedBy(2).toString(10),
    metaMaskFeeInEth: new _bignumber.default(feesAndValueAtUpperIndex.metaMaskFeeInEth, 10).plus(feesAndValueAtLowerIndex.metaMaskFeeInEth, 10).dividedBy(2).toString(10),
    ethValueOfTokens: new _bignumber.default(feesAndValueAtUpperIndex.ethValueOfTokens, 10).plus(feesAndValueAtLowerIndex.ethValueOfTokens, 10).dividedBy(2).toString(10)
  };
}
/**
 * Calculates the arithmetic mean for each of three properties - ethFee, metaMaskFeeInEth and ethValueOfTokens - across
 * an array of objects containing those properties.
 *
 * @param {Array} quotes - A sample of quote objects with overallValueOfQuote, ethFee, metaMaskFeeInEth and
 * ethValueOfTokens properties
 * @returns {Object} An object with the arithmetic mean each of the ethFee, metaMaskFeeInEth and ethValueOfTokens of
 * the passed quote objects
 */


function meansOfQuotesFeesAndValue(quotes) {
  const feeAndValueSumsAsBigNumbers = quotes.reduce((feeAndValueSums, quote) => ({
    ethFee: feeAndValueSums.ethFee.plus(quote.ethFee, 10),
    metaMaskFeeInEth: feeAndValueSums.metaMaskFeeInEth.plus(quote.metaMaskFeeInEth, 10),
    ethValueOfTokens: feeAndValueSums.ethValueOfTokens.plus(quote.ethValueOfTokens, 10)
  }), {
    ethFee: new _bignumber.default(0, 10),
    metaMaskFeeInEth: new _bignumber.default(0, 10),
    ethValueOfTokens: new _bignumber.default(0, 10)
  });
  return {
    ethFee: feeAndValueSumsAsBigNumbers.ethFee.div(quotes.length, 10).toString(10),
    metaMaskFeeInEth: feeAndValueSumsAsBigNumbers.metaMaskFeeInEth.div(quotes.length, 10).toString(10),
    ethValueOfTokens: feeAndValueSumsAsBigNumbers.ethValueOfTokens.div(quotes.length, 10).toString(10)
  };
}

const utils = {
  getMedianEthValueQuote,
  meansOfQuotesFeesAndValue
};
exports.utils = utils;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\swaps.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
          this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = payload.v - 27
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = payload.v - 27
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'
    this.iframe.contentWindow.postMessage(msg, '*')
    const eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data && data.action && data.action === `${msg.action}-reply` && cb) {
        cb(data)
        return undefined
      }

      window.removeEventListener('message', eventListener)
      return undefined
    }
    window.addEventListener('message', eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\eth-ledger-bridge-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./providerFromEngine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","./providerFromMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js","./retryOnEmpty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js", {"./SmartTransactionsController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\SmartTransactionsController.js","isomorphic-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\dist\index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line import/no-unassigned-import
require("isomorphic-fetch");
const SmartTransactionsController_1 = __importDefault(require("./SmartTransactionsController"));
exports.default = SmartTransactionsController_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\smart-transactions-controller",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\index.js", {"@ethereumjs/common":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js","@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\node_modules\\bignumber.js\\bignumber.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","gridplus-sdk":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-lattice-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const crypto = require('crypto');
const EventEmitter = require('events').EventEmitter;
const BN = require('bignumber.js');
const SDK = require('gridplus-sdk');
const EthTx = require('@ethereumjs/tx');
const Common = require('@ethereumjs/common').default;
const Util = require('ethereumjs-util');
const keyringType = 'Lattice Hardware';
const HARDENED_OFFSET = 0x80000000;
const PER_PAGE = 5;
const CLOSE_CODE = -1000;
const STANDARD_HD_PATH = `m/44'/60'/0'/0/x`;
const SDK_TIMEOUT = 120000;
const CONNECT_TIMEOUT = 20000;

class LatticeKeyring extends EventEmitter {
  constructor (opts={}) {
    super()
    this.type = keyringType;
    this._resetDefaults();
    this.deserialize(opts);
  }

  //-------------------------------------------------------------------
  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)
  //-------------------------------------------------------------------
  deserialize (opts = {}) {
    if (opts.hdPath)
      this.hdPath = opts.hdPath;
    if (opts.creds)
      this.creds = opts.creds;
    if (opts.accounts)
      this.accounts = opts.accounts;
    if (opts.accountIndices)
      this.accountIndices = opts.accountIndices;
    if (opts.accountOpts)
      this.accountOpts = opts.accountOpts;
    if (opts.walletUID)
      this.walletUID = opts.walletUID;
    if (opts.name)  // Legacy; use is deprecated and appName is more descriptive
      this.appName = opts.name;
    if (opts.appName)
      this.appName = opts.appName;
    if (opts.network)
      this.network = opts.network;
    if (opts.page)
      this.page = opts.page;
    if (opts.sdkState)
      this.sdkState = opts.sdkState;
    return Promise.resolve()
  }

  setHdPath(hdPath) {
    this.hdPath = hdPath;
  }

  serialize() {
    return Promise.resolve({
      creds: this.creds,
      accounts: this.accounts,
      accountIndices: this.accountIndices,
      accountOpts: this.accountOpts,
      walletUID: this.walletUID,
      appName: this.appName,
      name: this.name,  // Legacy; use is deprecated
      network: this.network,
      page: this.page,
      hdPath: this.hdPath,
      sdkState: this.sdkSession ? 
                this.sdkSession.getStateData() :
                null
    })
  }

  // Deterimine if we have a connection to the Lattice and an existing wallet UID
  // against which to make requests.
  isUnlocked () {
    return !!this._getCurrentWalletUID() && !!this.sdkSession;
  }

  // Initialize a session with the Lattice1 device using the GridPlus SDK
  // NOTE: `bypassOnStateData=true` allows us to rehydrate a new SDK session without
  // reconnecting to the target Lattice. This is only currently used for signing 
  // because it eliminates the need for 2 connection requests and shaves off ~4-6sec.
  // We avoid passing `bypassOnStateData=true` for other calls on `unlock` to avoid
  // possible edge cases related to this new functionality (it's probably fine - just
  // being cautious). In the future we may remove `bypassOnStateData` entirely.
  unlock(bypassOnStateData=false) {
    return new Promise((resolve, reject) => {
      // Force compatability. `this.accountOpts` were added after other
      // state params and must be synced in order for this keyring to function.
      if ((!this.accountOpts) || 
          (this.accounts.length > 0 && this.accountOpts.length != this.accounts.length)) 
      {
        this.forgetDevice();
        return reject(new Error(
          'You can now add multiple Lattice and SafeCard accounts at the same time! ' +
          'Your accounts have been cleared. Please press Continue to add them back in.'
        ));
      }

      if (this.isUnlocked() && !this.forceReconnect) {
        return resolve('Unlocked');
      }
      
      this._getCreds()
      .then((creds) => {
        if (creds) {
          this.creds.deviceID = creds.deviceID;
          this.creds.password = creds.password;
          this.creds.endpoint = creds.endpoint || null;
        }
        return this._initSession();
      })
      .then((includedStateData) => {
        // If state data was provided and if we are authorized to 
        // bypass reconnecting, we can exit here.
        if (includedStateData && bypassOnStateData) {
          return resolve('Unlocked');
        }
        return this._connect();
      })
      .then(() => {
        return resolve('Unlocked');
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  // Add addresses to the local store and return the full result
  addAccounts(n=1) {
    return new Promise((resolve, reject) => {
      if (n === CLOSE_CODE) {
        // Special case: use a code to forget the device. 
        // (This function is overloaded due to constraints upstream)
        this.forgetDevice();
        return resolve([]);
      } else if (n <= 0) {
        // Avoid non-positive numbers.
        return reject('Number of accounts to add must be a positive number.');
      } else {
        // Normal behavior: establish the connection and fetch addresses.
        this.unlock()
        .then(() => {
          return this._fetchAddresses(n, this.unlockedAccount)
        })
        .then((addrs) => {
          const walletUID = this._getCurrentWalletUID();
          // Add these indices
          addrs.forEach((addr, i) => {
            let alreadySaved = false;
            for (let j = 0; j < this.accounts.length; j++) {
              if ((this.accounts[j] === addr) && 
                  (this.accountOpts[j].walletUID === walletUID) &&
                  (this.accountOpts[j].hdPath === this.hdPath))
                alreadySaved = true;
            }
            if (!alreadySaved) {
              this.accounts.push(addr);
              this.accountIndices.push(this.unlockedAccount+i);
              this.accountOpts.push({
                walletUID,
                hdPath: this.hdPath,
              })
            }
          })
          return resolve(this.accounts);
        })
        .catch((err) => {
          return reject(new Error(err));
        })
      }
    })
  }

  // Return the local store of addresses. This gets called when the extension unlocks.
  getAccounts() {
    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());
  }

  signTransaction (address, tx) {
    return new Promise((resolve, reject) => {
      this._findSignerIdx(address)
      .then((accountIdx) => {
        try {
          // Build the Lattice request data and make request
          // We expect `tx` to be an `ethereumjs-tx` object, meaning all fields are bufferized
          // To ensure everything plays nicely with gridplus-sdk, we convert everything to hex strings
          const addressIdx = this.accountIndices[accountIdx];
          const addressParentPath = this.accountOpts[accountIdx].hdPath;
          const txData = {
            chainId: `0x${this._getEthereumJsChainId(tx).toString('hex')}` || 1,
            nonce: `0x${tx.nonce.toString('hex')}` || 0,
            gasLimit: `0x${tx.gasLimit.toString('hex')}`,
            to: !!tx.to ? tx.to.toString('hex') : null, // null for contract deployments
            value: `0x${tx.value.toString('hex')}`,
            data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,
            signerPath: this._getHDPathIndices(addressParentPath, addressIdx),
          }
          switch (tx._type) {
            case 2: // eip1559
              if ((tx.maxPriorityFeePerGas === null || tx.maxFeePerGas === null) ||
                  (tx.maxPriorityFeePerGas === undefined || tx.maxFeePerGas === undefined))
                throw new Error('`maxPriorityFeePerGas` and `maxFeePerGas` must be included for EIP1559 transactions.');
              txData.maxPriorityFeePerGas = `0x${tx.maxPriorityFeePerGas.toString('hex')}`;
              txData.maxFeePerGas = `0x${tx.maxFeePerGas.toString('hex')}`;
              txData.accessList = tx.accessList || [];
              txData.type = 2;
              break;
            case 1: // eip2930
              txData.accessList = tx.accessList || [];
              txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
              txData.type = 1;
              break;
            default: // legacy
              txData.gasPrice = `0x${tx.gasPrice.toString('hex')}`;
              txData.type = null;
              break;
          }
          // Lattice firmware v0.11.0 implemented EIP1559 and EIP2930 so for previous verisons
          // we need to overwrite relevant params and revert to legacy type.
          // Note: `this.sdkSession.fwVersion is of format [fix, minor, major, reserved]
          const forceLegacyTx = this.sdkSession.fwVersion[2] < 1 && 
                                this.sdkSession.fwVersion[1] < 11;
          if (forceLegacyTx && txData.type === 2) {
            txData.gasPrice = txData.maxFeePerGas;
            txData.revertToLegacy = true;
            delete txData.type;
            delete txData.maxFeePerGas;
            delete txData.maxPriorityFeePerGas;
            delete txData.accessList;
          } else if (forceLegacyTx && txData.type === 1) {
            txData.revertToLegacy = true;
            delete txData.type;
            delete txData.accessList;
          }
          // Get the signature
          return this._signTxData(txData)
        } catch (err) {
          throw new Error(`Failed to build transaction.`)
        }
      })
      .then((signedTx) => {
        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`
        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s)
          return reject(new Error('No signature returned.'));
        const txToReturn = tx.toJSON();
        const v = signedTx.sig.v.length === 0 ? '0' : signedTx.sig.v.toString('hex')
        txToReturn.r = Util.addHexPrefix(signedTx.sig.r.toString('hex'));
        txToReturn.s = Util.addHexPrefix(signedTx.sig.s.toString('hex'));
        txToReturn.v = Util.addHexPrefix(v);

        if (signedTx.revertToLegacy === true) {
          // If firmware does not support an EIP1559/2930 transaction we revert to legacy
          txToReturn.type = 0;
          txToReturn.gasPrice = signedTx.gasPrice;
        } else {
          // Otherwise relay the tx type
          txToReturn.type = signedTx.type;
        }

        // Build the tx for export
        let validatingTx;
        const _chainId = `0x${this._getEthereumJsChainId(tx).toString('hex')}`;
        const chainId = new BN(_chainId).toNumber();
        const customNetwork = Common.forCustomChain('mainnet', {
          name: 'notMainnet',
          networkId: chainId,
          chainId: chainId,
        }, 'london')

        validatingTx = EthTx.TransactionFactory.fromTxData(txToReturn, {
          common: customNetwork, freeze: Object.isFrozen(tx)
        })
        return resolve(validatingTx);
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  signPersonalMessage(address, msg) {
    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });
  }

  signTypedData(address, msg, opts) {
    if (opts.version && (opts.version !== 'V4' && opts.version !== 'V3'))
      throw new Error(`Only signTypedData V3 and V4 messages (EIP712) are supported. Got version ${opts.version}`);
    return this.signMessage(address, { payload: msg, protocol: 'eip712' })
  }

  signMessage(address, msg) {
    return new Promise((resolve, reject) => {
      this._findSignerIdx(address)
      .then((accountIdx) => {
        let { payload, protocol } = msg;
        // If the message is not an object we assume it is a legacy signPersonal request
        if (!payload || !protocol) {
          payload = msg;
          protocol = 'signPersonal';
        }
        const addressIdx = this.accountIndices[accountIdx];
        const addressParentPath = this.accountOpts[accountIdx].hdPath;
        const req = {
          currency: 'ETH_MSG',
          data: {
            protocol,
            payload,
            signerPath: this._getHDPathIndices(addressParentPath, addressIdx),
          }
        }
        this.sdkSession.sign(req, (err, res) => {
          if (err) {
            return reject(new Error(err));
          }
          if (!this._syncCurrentWalletUID()) {
            return reject('No active wallet.');
          }
          if (!res.sig) {
            return reject(new Error('No signature returned'));
          }
          // Convert the `v` to a number. It should convert to 0 or 1
          try {
            let v = res.sig.v.toString('hex');
            if (v.length < 2) {
              v = `0${v}`;
            }
            return resolve(`0x${res.sig.r}${res.sig.s}${v}`);
          } catch (err) {
            return reject(new Error('Invalid signature format returned.'))
          }
        })
      })
      .catch((err) => {
        return reject(new Error(err));
      })
    })
  }

  exportAccount(address) {
    return Promise.reject(Error('exportAccount not supported by this device'))
  }

  removeAccount(address) {
    this.accounts.forEach((account, i) => {
      if (account.toLowerCase() === address.toLowerCase()) {
        this.accounts.splice(i, 1);
        this.accountIndices.splice(i, 1);
        this.accountOpts.splice(i, 1);
        return;
      }
    })
  }

  getFirstPage() {
    // This function gets called after the user has connected to the Lattice.
    // Update a state variable to force opening of the Lattice manager window.
    // If we don't do this, MetaMask will automatically start requesting addresses,
    // even if the device is not reachable.
    // This way the user can close the window and connect accounts from other
    // wallets instead of being forced into selecting Lattice accounts
    this.forceReconnect = true;
    this.page = 0;
    return this._getPage(0);
  }

  getNextPage () {
    return this._getPage(1);
  }

  getPreviousPage () {
    return this._getPage(-1);
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  forgetDevice () {
    this._resetDefaults();
  }

  //-------------------------------------------------------------------
  // Internal methods and interface to SDK
  //-------------------------------------------------------------------
  // Find the account index of the requested address.
  // Note that this is the BIP39 path index, not the index in the address cache.
  _findSignerIdx(address) {
    return new Promise((resolve, reject) => {
      // Unlock and get the wallet UID. We will bypass the reconnection
      // step if we are able to rehydrate an SDK session with state data.
      this.unlock(true)
      .then(() => {
        return this._ensureCurrentWalletUID();
      })
      .then(() => {
        return this.getAccounts();
      })
      .then((addrs) => {
        // Find the signer in our current set of accounts
        // If we can't find it, return an error
        let accountIdx = null;
        addrs.forEach((addr, i) => {
          if (address.toLowerCase() === addr.toLowerCase())
            accountIdx = i;
        })
        if (accountIdx === null) {
          return reject('Signer not present');
        }
        return resolve(accountIdx);
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }

  _getHDPathIndices(hdPath, insertIdx=0) {
    const path = hdPath.split('/').slice(1);
    const indices = [];
    let usedX = false;
    path.forEach((_idx) => {
      const isHardened = (_idx[_idx.length - 1] === "'");
      let idx = isHardened ? HARDENED_OFFSET : 0;
      // If there is an `x` in the path string, we will use it to insert our
      // index. This is useful for e.g. Ledger Live path. Most paths have the
      // changing index as the last one, so having an `x` in the path isn't
      // usually necessary.
      if (_idx.indexOf('x') > -1) {
        idx += insertIdx;
        usedX = true;
      } else if (isHardened) {
        idx += Number(_idx.slice(0, _idx.length - 1));
      } else {
        idx += Number(_idx);
      }
      indices.push(idx);
    })
    // If this path string does not include an `x`, we just append the index
    // to the end of the extracted set
    if (usedX === false) {
      indices.push(insertIdx);
    }
    // Sanity check -- Lattice firmware will throw an error for large paths
    if (indices.length > 5)
      throw new Error('Only HD paths with up to 5 indices are allowed.')
    return indices;
  }

  _resetDefaults() {
    this.accounts = [];
    this.accountIndices = [];
    this.accountOpts = [];
    this.isLocked = true;
    this.creds = {
      deviceID: null,
      password: null,
      endpoint: null,
    };
    this.walletUID = null;
    this.sdkSession = null;
    this.page = 0;
    this.unlockedAccount = 0;
    this.network = null;
    this.hdPath = STANDARD_HD_PATH;
  }

  _openConnectorTab(url) {
    return new Promise((resolve, reject) => {
      const browserTab = window.open(url);
      // Preferred option for Chromium browsers. This extension runs in a window
      // for Chromium so we can do window-based communication very easily.
      if (browserTab) {
        return resolve({ chromium: browserTab });
      } else if (browser && browser.tabs && browser.tabs.create) {
        // FireFox extensions do not run in windows, so it will return `null` from
        // `window.open`. Instead, we need to use the `browser` API to open a tab. 
        // We will surveille this tab to see if its URL parameters change, which 
        // will indicate that the user has logged in.
        browser.tabs.create({url})
        .then((tab) => {
          return resolve({ firefox: tab });
        })
        .catch((err) => {
          return reject(new Error('Failed to open Lattice connector.'))
        })
      } else {
        return reject(new Error('Unknown browser context. Cannot open Lattice connector.'))
      }

    })
  }

  _findTabById(id) {
    return new Promise((resolve, reject) => {
      browser.tabs.query({})
      .then((tabs) => {
        tabs.forEach((tab) => {
          if (tab.id === id) {
            return resolve(tab);
          }
        })
        return resolve(null);
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }
  
  _getCreds() {
    return new Promise((resolve, reject) => {
      // We only need to setup if we don't have a deviceID
      if (this._hasCreds() && !this.forceReconnect)
        return resolve();
      // Cancel the force reconnect, if applicable
      this.forceReconnect = false;
      // If we are not aware of what Lattice we should be talking to,
      // we need to open a window that lets the user go through the
      // pairing or connection process.
      const name = this.appName ? this.appName : 'Unknown'
      const base = 'https://lattice.gridplus.io';
      const url = `${base}?keyring=${name}&forceLogin=true`;
      let listenInterval;

      // PostMessage handler
      function receiveMessage(event) {
        // Ensure origin
        if (event.origin !== base)
          return;
        try {
          // Stop the listener
          clearInterval(listenInterval);
          // Parse and return creds
          const creds = JSON.parse(event.data);
          if (!creds.deviceID || !creds.password)
            return reject(new Error('Invalid credentials returned from Lattice.'));
          return resolve(creds);
        } catch (err) {
          return reject(err);
        }
      }

      // Open the tab
      this._openConnectorTab(url)
      .then((conn) => {
        if (conn.chromium) {
          // On a Chromium browser we can just listen for a window message
          window.addEventListener("message", receiveMessage, false);
          // Watch for the open window closing before creds are sent back
          listenInterval = setInterval(() => {
            if (conn.chromium.closed) {
              clearInterval(listenInterval);
              return reject(new Error('Lattice connector closed.'));
            }
          }, 500);
        } else if (conn.firefox) {
          // For Firefox we cannot use `window` in the extension and can't
          // directly communicate with the tabs very easily so we use a
          // workaround: listen for changes to the URL, which will contain
          // the login info.
          // NOTE: This will only work if have `https://lattice.gridplus.io/*`
          // host permissions in your manifest file (and also `activeTab` permission)
          const loginUrlParam = '&loginCache=';
          listenInterval = setInterval(() => {
            this._findTabById(conn.firefox.id)
            .then((tab) => {
              if (!tab || !tab.url) {
                return reject(new Error('Lattice connector closed.'));
              }
              // If the tab we opened contains a new URL param
              const paramLoc = tab.url.indexOf(loginUrlParam);
              if (paramLoc < 0) 
                return;
              const dataLoc = paramLoc + loginUrlParam.length;
              // Stop this interval
              clearInterval(listenInterval);
              try {
                // Parse the login data. It is a stringified JSON object 
                // encoded as a base64 string.
                const _creds = Buffer.from(tab.url.slice(dataLoc), 'base64').toString();
                // Close the tab and return the credentials
                browser.tabs.remove(tab.id)
                .then(() => {
                  const creds = JSON.parse(_creds);
                  if (!creds.deviceID || !creds.password)
                    return reject(new Error('Invalid credentials returned from Lattice.'));
                  return resolve(creds);
                })
              } catch (err) {
                return reject('Failed to get login data from Lattice. Please try again.')
              }
            })
          }, 500);
        }
      })
    })
  }

  // [re]connect to the Lattice. This should be done frequently to ensure
  // the expected wallet UID is still the one active in the Lattice.
  // This will handle SafeCard insertion/removal events.
  _connect() {
    return new Promise((resolve, reject) => {
      // Attempt to connect with a Lattice using a shorter timeout. If
      // the device is unplugged it will time out and we don't need to wait
      // 2 minutes for that to happen.
      this.sdkSession.timeout = CONNECT_TIMEOUT;
      this.sdkSession.connect(this.creds.deviceID, (err) => {
        this.sdkSession.timeout = SDK_TIMEOUT;
        if (err) {
          return reject(err);
        }
        if (!this._syncCurrentWalletUID()) {
          return reject('No active wallet.');
        }
        return resolve();
      });
    })
  }

  _initSession() {
    return new Promise((resolve, reject) => {
      if (this.isUnlocked()) {
        return resolve();
      }
      try {
        let url = 'https://signing.gridpl.us';
        if (this.creds.endpoint)
          url = this.creds.endpoint
        let setupData;
        if (this.sdkState) {
          // If we have state data we can fully rehydrate the session.
          setupData = {
            stateData: this.sdkState
          }
        } else {
          // If we have no state data, we need to create a session.
          // Its state will be saved once the connection is established.
          setupData = {
            name: this.appName,
            baseUrl: url,
            timeout: SDK_TIMEOUT,
            privKey: this._genSessionKey(),
            network: this.network,
          }
        }
        this.sdkSession = new SDK.Client(setupData);
        // Return a boolean indicating whether we provided state data.
        // If we have, we can skip `connect`.
        return resolve(!!setupData.stateData);
      } catch (err) {
        return reject(err);
      }
    })
  }

  _fetchAddresses(n=1, i=0, recursedAddrs=[]) {
    return new Promise((resolve, reject) => {
      if (!this.isUnlocked()) {
        return reject('No connection to Lattice. Cannot fetch addresses.')
      }
      this.__fetchAddresses(n, i, (err, addrs) => {
        if (err) {
          return reject(err);
        }
        return resolve(addrs);
      })
    })
  }

  __fetchAddresses(n=1, i=0, cb, recursedAddrs=[]) {
     // Determine if we need to do a recursive call here. We prefer not to
      // because they will be much slower, but Ledger paths require it since
      // they are non-standard.
      if (n === 0)
        return cb(null, recursedAddrs);
      const shouldRecurse = this._hdPathHasInternalVarIdx();

      // Make the request to get the requested address
      const addrData = { 
        currency: 'ETH', 
        startPath: this._getHDPathIndices(this.hdPath, i), 
        n: shouldRecurse ? 1 : n,
        skipCache: true,
      };
      this.sdkSession.getAddresses(addrData, (err, addrs) => {
        if (err)
          return cb(err);
        if (!this._syncCurrentWalletUID()) {
          return cb(new Error('No active wallet.'));
        }
        // Sanity check -- if this returned 0 addresses, handle the error
        if (addrs.length < 1) {
          return cb(new Error('No addresses returned'));
        }
        // Return the addresses we fetched *without* updating state
        if (shouldRecurse) {
          return this.__fetchAddresses(n-1, i+1, cb, recursedAddrs.concat(addrs));
        } else {
          return cb(null, addrs);
        }
      })
  }

  _signTxData(txData) {
    return new Promise((resolve, reject) => {
      this.sdkSession.sign({ currency: 'ETH', data: txData }, (err, res) => {
        if (err) {
          return reject(err);
        }
        if (!this._syncCurrentWalletUID()) {
          return reject('No active wallet.');
        }
        if (!res.tx) {
          return reject(new Error('No transaction payload returned.'));
        }
        // Here we catch an edge case where the requester is asking for an EIP1559
        // transaction but firmware is not updated to support it. We fallback to legacy.
        res.type = txData.type;
        if (txData.revertToLegacy) {
          res.revertToLegacy = true;
          res.gasPrice = txData.gasPrice;
        }
        // Return the signed tx
        return resolve(res)
      })
    })
  }

  _getPage(increment=0) {
    return new Promise((resolve, reject) => {
      this.page += increment;
      if (this.page < 0)
        this.page = 0;
      const start = PER_PAGE * this.page;
      // Otherwise unlock the device and fetch more addresses
      this.unlock()
      .then(() => {
        return this._fetchAddresses(PER_PAGE, start)
      })
      .then((addrs) => {
        const accounts = []
        addrs.forEach((address, i) => {
          accounts.push({
            address,
            balance: null,
            index: start + i,
          })
        })
        return resolve(accounts)
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }

  _hasCreds() {
    return this.creds.deviceID !== null && this.creds.password !== null && this.appName;
  }

  _genSessionKey() {
    if (this.name && !this.appName) // Migrate from legacy param if needed
      this.appName = this.name;
    if (!this._hasCreds())
      throw new Error('No credentials -- cannot create session key!');
    const buf = Buffer.concat([
      Buffer.from(this.creds.password), 
      Buffer.from(this.creds.deviceID), 
      Buffer.from(this.appName)
    ])
    return crypto.createHash('sha256').update(buf).digest();
  }

  // Determine if an HD path has a variable index internal to it.
  // e.g. m/44'/60'/x'/0/0 -> true, while m/44'/60'/0'/0/x -> false
  // This is just a hacky helper to avoid having to recursively call for non-ledger
  // derivation paths. Ledger is SO ANNOYING TO SUPPORT.
  _hdPathHasInternalVarIdx() {
    const path = this.hdPath.split('/').slice(1);
    for (let i = 0; i < path.length -1; i++) {
      if (path[i].indexOf('x') > -1)
        return true;
    }
    return false;
  }

  // Get the chainId for whatever object this is.
  // Returns a hex string without the 0x prefix
  _getEthereumJsChainId(tx) {
    if (typeof tx.getChainId === 'function')
      return tx.getChainId();
    else if (tx.common && typeof tx.common.chainIdBN === 'function')
      return tx.common.chainIdBN().toString(16);
    else if (typeof tx.chainId === 'number')
      return tx.chainId.toString(16);
    else if (typeof tx.chainId === 'string')
      return tx.chainId;
    return '1';
  }

  _getCurrentWalletUID() {
    return this.walletUID || null;
  }

  // The SDK has an auto-retry mechanism for all requests if a "wrong wallet"
  // error gets thrown. In such a case, the SDK will re-connect to the device to
  // find the new wallet UID and will then save that UID to memory and will retry
  // the original request with that new wallet UID.
  // Therefore, we should sync the walletUID with `this.walletUID` after each
  // SDK request. This is a synchronous and fast operation.
  _syncCurrentWalletUID() {
    if (!this.sdkSession) {
      return null;
    }
    const activeWallet = this.sdkSession.getActiveWallet();
    if (!activeWallet || !activeWallet.uid) {
      return null;
    }
    const newUID = activeWallet.uid.toString('hex');
    // If we fetched a walletUID that does not match our current one,
    // reset accounts and update the known UID
    if (newUID != this.walletUID) {
      this.walletUID = newUID;
    }
    return this.walletUID;
  }

  // Make sure we have an SDK connection and, therefore, an active wallet UID.
  // If we do not, force an unlock, which adds ~5 seconds to the request.
  _ensureCurrentWalletUID() {
    return new Promise((resolve, reject) => {
      if (!!this._getCurrentWalletUID()) {
        return resolve();
      }
      this.unlock()
      .then(() => {
        if (!!this._getCurrentWalletUID()) {
          return resolve()
        } else {
          return reject('Could not access Lattice wallet. Please re-connect.')
        }
      })
      .catch((err) => {
        return reject(err);
      })
    })
  }

}

LatticeKeyring.type = keyringType
module.exports = LatticeKeyring;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-lattice-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\preferences.js", {"../../../shared/constants/hardware-wallets":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\hardware-wallets.js","../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../shared/modules/network.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js","./network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\index.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\preferences.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("assert");

var _obsStore = require("@metamask/obs-store");

var _ethSigUtil = require("eth-sig-util");

var _ethers = require("ethers");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _network = require("../../../shared/constants/network");

var _network2 = require("../../../shared/modules/network.utils");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

var _network3 = require("./network");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class PreferencesController {
  /**
   *
   * @typedef {Object} PreferencesController
   * @param {Object} opts - Overrides the defaults for the initial state of this.store
   * @property {Object} store The stored object containing a users preferences, stored in local storage
   * @property {Array} store.frequentRpcList A list of custom rpcs to provide the user
   * @property {boolean} store.useBlockie The users preference for blockie identicons within the UI
   * @property {boolean} store.useNonceField The users preference for nonce field within the UI
   * @property {Object} store.featureFlags A key-boolean map, where keys refer to features and booleans to whether the
   * user wishes to see that feature.
   *
   * Feature flags can be set by the global function `setPreference(feature, enabled)`, and so should not expose any sensitive behavior.
   * @property {Object} store.knownMethodData Contains all data methods known by the user
   * @property {string} store.currentLocale The preferred language locale key
   * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app
   */
  constructor(opts = {}) {
    const initState = _objectSpread({
      frequentRpcListDetail: [],
      useBlockie: false,
      useNonceField: false,
      usePhishDetect: true,
      dismissSeedBackUpReminder: false,
      // set to true means the dynamic list from the API is being used
      // set to false will be using the static list from contract-metadata
      useTokenDetection: false,
      useCollectibleDetection: false,
      openSeaEnabled: false,
      advancedGasFee: null,
      // WARNING: Do not use feature flags for security-sensitive things.
      // Feature flag toggling is available in the global namespace
      // for convenient testing of pre-release features, and should never
      // perform sensitive operations.
      featureFlags: {
        showIncomingTransactions: true
      },
      knownMethodData: {},
      currentLocale: opts.initLangCode,
      identities: {},
      lostIdentities: {},
      forgottenPassword: false,
      preferences: {
        autoLockTimeLimit: undefined,
        showFiatInTestnets: false,
        showTestNetworks: false,
        useNativeCurrencyAsPrimaryCurrency: true,
        hideZeroBalanceTokens: false
      },
      // ENS decentralized website resolution
      ipfsGateway: _network.IPFS_DEFAULT_GATEWAY_URL,
      infuraBlocked: null,
      ledgerTransportType: window.navigator.hid ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.WEBHID : _hardwareWallets.LEDGER_TRANSPORT_TYPES.U2F
    }, opts.initState);

    this.network = opts.network;
    this.ethersProvider = new _ethers.ethers.providers.Web3Provider(opts.provider);
    this.store = new _obsStore.ObservableStore(initState);
    this.store.setMaxListeners(12);
    this.openPopup = opts.openPopup;
    this.migrateAddressBookState = opts.migrateAddressBookState;

    this._subscribeToInfuraAvailability();

    global.setPreference = (key, value) => {
      return this.setFeatureFlag(key, value);
    };
  } // PUBLIC METHODS

  /**
   * Sets the {@code forgottenPassword} state property
   *
   * @param {boolean} forgottenPassword - whether or not the user has forgotten their password
   */


  setPasswordForgotten(forgottenPassword) {
    this.store.updateState({
      forgottenPassword
    });
  }
  /**
   * Setter for the `useBlockie` property
   *
   * @param {boolean} val - Whether or not the user prefers blockie indicators
   */


  setUseBlockie(val) {
    this.store.updateState({
      useBlockie: val
    });
  }
  /**
   * Setter for the `useNonceField` property
   *
   * @param {boolean} val - Whether or not the user prefers to set nonce
   */


  setUseNonceField(val) {
    this.store.updateState({
      useNonceField: val
    });
  }
  /**
   * Setter for the `usePhishDetect` property
   *
   * @param {boolean} val - Whether or not the user prefers phishing domain protection
   */


  setUsePhishDetect(val) {
    this.store.updateState({
      usePhishDetect: val
    });
  }
  /**
   * Setter for the `useTokenDetection` property
   *
   * @param {boolean} val - Whether or not the user prefers to use the static token list or dynamic token list from the API
   */


  setUseTokenDetection(val) {
    this.store.updateState({
      useTokenDetection: val
    });
  }
  /**
   * Setter for the `useCollectibleDetection` property
   *
   * @param {boolean} useCollectibleDetection - Whether or not the user prefers to autodetect collectibles.
   */


  setUseCollectibleDetection(useCollectibleDetection) {
    this.store.updateState({
      useCollectibleDetection
    });
  }
  /**
   * Setter for the `openSeaEnabled` property
   *
   * @param {boolean} openSeaEnabled - Whether or not the user prefers to use the OpenSea API for collectibles data.
   */


  setOpenSeaEnabled(openSeaEnabled) {
    this.store.updateState({
      openSeaEnabled
    });
  }
  /**
   * Setter for the `advancedGasFee` property
   *
   * @param {object} val - holds the maxBaseFee and PriorityFee that the user set as default advanced settings.
   */


  setAdvancedGasFee(val) {
    this.store.updateState({
      advancedGasFee: val
    });
  }
  /**
   * Setter for the `eip1559V2Enabled` property
   *
   * @param {object} val - holds the eip1559V2Enabled that the user set as experimental settings.
   */


  setEIP1559V2Enabled(val) {
    this.store.updateState({
      eip1559V2Enabled: val
    });
  }
  /**
   * Add new methodData to state, to avoid requesting this information again through Infura
   *
   * @param {string} fourBytePrefix - Four-byte method signature
   * @param {string} methodData - Corresponding data method
   */


  addKnownMethodData(fourBytePrefix, methodData) {
    const {
      knownMethodData
    } = this.store.getState();
    knownMethodData[fourBytePrefix] = methodData;
    this.store.updateState({
      knownMethodData
    });
  }
  /**
   * Setter for the `currentLocale` property
   *
   * @param {string} key - he preferred language locale key
   */


  setCurrentLocale(key) {
    const textDirection = ['ar', 'dv', 'fa', 'he', 'ku'].includes(key) ? 'rtl' : 'auto';
    this.store.updateState({
      currentLocale: key,
      textDirection
    });
    return textDirection;
  }
  /**
   * Updates identities to only include specified addresses. Removes identities
   * not included in addresses array
   *
   * @param {string[]} addresses - An array of hex addresses
   */


  setAddresses(addresses) {
    const oldIdentities = this.store.getState().identities;
    const identities = addresses.reduce((ids, address, index) => {
      const oldId = oldIdentities[address] || {};
      ids[address] = _objectSpread({
        name: `Account ${index + 1}`,
        address
      }, oldId);
      return ids;
    }, {});
    this.store.updateState({
      identities
    });
  }
  /**
   * Removes an address from state
   *
   * @param {string} address - A hex address
   * @returns {string} the address that was removed
   */


  removeAddress(address) {
    const {
      identities
    } = this.store.getState();

    if (!identities[address]) {
      throw new Error(`${address} can't be deleted cause it was not found`);
    }

    delete identities[address];
    this.store.updateState({
      identities
    }); // If the selected account is no longer valid,
    // select an arbitrary other account:

    if (address === this.getSelectedAddress()) {
      const selected = Object.keys(identities)[0];
      this.setSelectedAddress(selected);
    }

    return address;
  }
  /**
   * Adds addresses to the identities object without removing identities
   *
   * @param {string[]} addresses - An array of hex addresses
   */


  addAddresses(addresses) {
    const {
      identities
    } = this.store.getState();
    addresses.forEach(address => {
      // skip if already exists
      if (identities[address]) {
        return;
      } // add missing identity


      const identityCount = Object.keys(identities).length;
      identities[address] = {
        name: `Account ${identityCount + 1}`,
        address
      };
    });
    this.store.updateState({
      identities
    });
  }
  /**
   * Synchronizes identity entries with known accounts.
   * Removes any unknown identities, and returns the resulting selected address.
   *
   * @param {Array<string>} addresses - known to the vault.
   * @returns {Promise<string>} selectedAddress the selected address.
   */


  syncAddresses(addresses) {
    if (!Array.isArray(addresses) || addresses.length === 0) {
      throw new Error('Expected non-empty array of addresses. Error #11201');
    }

    const {
      identities,
      lostIdentities
    } = this.store.getState();
    const newlyLost = {};
    Object.keys(identities).forEach(identity => {
      if (!addresses.includes(identity)) {
        newlyLost[identity] = identities[identity];
        delete identities[identity];
      }
    }); // Identities are no longer present.

    if (Object.keys(newlyLost).length > 0) {
      // store lost accounts
      Object.keys(newlyLost).forEach(key => {
        lostIdentities[key] = newlyLost[key];
      });
    }

    this.store.updateState({
      identities,
      lostIdentities
    });
    this.addAddresses(addresses); // If the selected account is no longer valid,
    // select an arbitrary other account:

    let selected = this.getSelectedAddress();

    if (!addresses.includes(selected)) {
      selected = addresses[0];
      this.setSelectedAddress(selected);
    }

    return selected;
  }
  /**
   * Setter for the `selectedAddress` property
   *
   * @param {string} _address - A new hex address for an account
   */


  setSelectedAddress(_address) {
    const address = (0, _ethSigUtil.normalize)(_address);
    const {
      identities
    } = this.store.getState();
    const selectedIdentity = identities[address];

    if (!selectedIdentity) {
      throw new Error(`Identity for '${address} not found`);
    }

    selectedIdentity.lastSelected = Date.now();
    this.store.updateState({
      identities,
      selectedAddress: address
    });
  }
  /**
   * Getter for the `selectedAddress` property
   *
   * @returns {string} The hex address for the currently selected account
   */


  getSelectedAddress() {
    return this.store.getState().selectedAddress;
  }
  /**
   * Sets a custom label for an account
   *
   * @param {string} account - the account to set a label for
   * @param {string} label - the custom label for the account
   * @returns {Promise<string>}
   */


  setAccountLabel(account, label) {
    if (!account) {
      throw new Error(`setAccountLabel requires a valid address, got ${String(account)}`);
    }

    const address = (0, _ethSigUtil.normalize)(account);
    const {
      identities
    } = this.store.getState();
    identities[address] = identities[address] || {};
    identities[address].name = label;
    this.store.updateState({
      identities
    });
    return Promise.resolve(label);
  }
  /**
   * updates custom RPC details
   *
   * @param {Object} newRpcDetails - Options bag.
   * @param {string} newRpcDetails.rpcUrl - The RPC url to add to frequentRpcList.
   * @param {string} newRpcDetails.chainId - The chainId of the selected network.
   * @param {string} [newRpcDetails.ticker] - Optional ticker symbol of the selected network.
   * @param {string} [newRpcDetails.nickname] - Optional nickname of the selected network.
   * @param {Object} [newRpcDetails.rpcPrefs] - Optional RPC preferences, such as the block explorer URL
   */


  async updateRpc(newRpcDetails) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === newRpcDetails.rpcUrl;
    });

    if (index > -1) {
      const rpcDetail = rpcList[index];

      const updatedRpc = _objectSpread(_objectSpread({}, rpcDetail), newRpcDetails);

      if (rpcDetail.chainId !== updatedRpc.chainId) {
        // When the chainId is changed, associated address book entries should
        // also be migrated. The address book entries are keyed by the `network` state,
        // which for custom networks is the chainId with a fallback to the networkId
        // if the chainId is not set.
        let addressBookKey = rpcDetail.chainId;

        if (!addressBookKey) {
          // We need to find the networkId to determine what these addresses were keyed by
          try {
            addressBookKey = await this.ethersProvider.send('net_version');
            (0, _assert.strict)(typeof addressBookKey === 'string');
          } catch (error) {
            _loglevel.default.debug(error);

            _loglevel.default.warn(`Failed to get networkId from ${rpcDetail.rpcUrl}; skipping address book migration`);
          }
        } // There is an edge case where two separate RPC endpoints are keyed by the same
        // value. In this case, the contact book entries are duplicated so that they remain
        // on both networks, since we don't know which network each contact is intended for.


        let duplicate = false;
        const builtInProviderNetworkIds = Object.values(_network.NETWORK_TYPE_TO_ID_MAP).map(ids => ids.networkId);
        const otherRpcEntries = rpcList.filter(entry => entry.rpcUrl !== newRpcDetails.rpcUrl);

        if (builtInProviderNetworkIds.includes(addressBookKey) || otherRpcEntries.some(entry => entry.chainId === addressBookKey)) {
          duplicate = true;
        }

        this.migrateAddressBookState(addressBookKey, updatedRpc.chainId, duplicate);
      }

      rpcList[index] = updatedRpc;
      this.store.updateState({
        frequentRpcListDetail: rpcList
      });
    } else {
      const {
        rpcUrl,
        chainId,
        ticker,
        nickname,
        rpcPrefs = {}
      } = newRpcDetails;
      this.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    }
  }
  /**
   * Adds custom RPC url to state.
   *
   * @param {string} rpcUrl - The RPC url to add to frequentRpcList.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} [ticker] - Ticker symbol of the selected network.
   * @param {string} [nickname] - Nickname of the selected network.
   * @param {Object} [rpcPrefs] - Optional RPC preferences, such as the block explorer URL
   */


  addToFrequentRpcList(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === rpcUrl;
    });

    if (index !== -1) {
      rpcList.splice(index, 1);
    }

    if (!(0, _network2.isPrefixedFormattedHexString)(chainId)) {
      throw new Error(`Invalid chainId: "${chainId}"`);
    }

    rpcList.push({
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
    this.store.updateState({
      frequentRpcListDetail: rpcList
    });
  }
  /**
   * Removes custom RPC url from state.
   *
   * @param {string} url - The RPC url to remove from frequentRpcList.
   * @returns {Promise<Array>} Promise resolving to updated frequentRpcList.
   */


  removeFromFrequentRpcList(url) {
    const rpcList = this.getFrequentRpcListDetail();
    const index = rpcList.findIndex(element => {
      return element.rpcUrl === url;
    });

    if (index !== -1) {
      rpcList.splice(index, 1);
    }

    this.store.updateState({
      frequentRpcListDetail: rpcList
    });
    return Promise.resolve(rpcList);
  }
  /**
   * Getter for the `frequentRpcListDetail` property.
   *
   * @returns {Array<Array>} An array of rpc urls.
   */


  getFrequentRpcListDetail() {
    return this.store.getState().frequentRpcListDetail;
  }
  /**
   * Updates the `featureFlags` property, which is an object. One property within that object will be set to a boolean.
   *
   * @param {string} feature - A key that corresponds to a UI feature.
   * @param {boolean} activated - Indicates whether or not the UI feature should be displayed
   * @returns {Promise<object>} Promises a new object; the updated featureFlags object.
   */


  setFeatureFlag(feature, activated) {
    const currentFeatureFlags = this.store.getState().featureFlags;

    const updatedFeatureFlags = _objectSpread(_objectSpread({}, currentFeatureFlags), {}, {
      [feature]: activated
    });

    this.store.updateState({
      featureFlags: updatedFeatureFlags
    });
    return Promise.resolve(updatedFeatureFlags);
  }
  /**
   * Updates the `preferences` property, which is an object. These are user-controlled features
   * found in the settings page.
   *
   * @param {string} preference - The preference to enable or disable.
   * @param {boolean} value - Indicates whether or not the preference should be enabled or disabled.
   * @returns {Promise<object>} Promises a new object; the updated preferences object.
   */


  setPreference(preference, value) {
    const currentPreferences = this.getPreferences();

    const updatedPreferences = _objectSpread(_objectSpread({}, currentPreferences), {}, {
      [preference]: value
    });

    this.store.updateState({
      preferences: updatedPreferences
    });
    return Promise.resolve(updatedPreferences);
  }
  /**
   * A getter for the `preferences` property
   *
   * @returns {Object} A key-boolean map of user-selected preferences.
   */


  getPreferences() {
    return this.store.getState().preferences;
  }
  /**
   * A getter for the `ipfsGateway` property
   *
   * @returns {string} The current IPFS gateway domain
   */


  getIpfsGateway() {
    return this.store.getState().ipfsGateway;
  }
  /**
   * A setter for the `ipfsGateway` property
   *
   * @param {string} domain - The new IPFS gateway domain
   * @returns {Promise<string>} A promise of the update IPFS gateway domain
   */


  setIpfsGateway(domain) {
    this.store.updateState({
      ipfsGateway: domain
    });
    return Promise.resolve(domain);
  }
  /**
   * A setter for the `ledgerTransportType` property.
   *
   * @param {string} ledgerTransportType - Either 'ledgerLive', 'webhid' or 'u2f'
   * @returns {string} The transport type that was set.
   */


  setLedgerTransportPreference(ledgerTransportType) {
    this.store.updateState({
      ledgerTransportType
    });
    return ledgerTransportType;
  }
  /**
   * A getter for the `ledgerTransportType` property.
   *
   * @returns {string} The current preferred Ledger transport type.
   */


  getLedgerTransportPreference() {
    return this.store.getState().ledgerTransportType;
  }
  /**
   * A setter for the user preference to dismiss the seed phrase backup reminder
   *
   * @param {bool} dismissSeedBackUpReminder - User preference for dismissing the back up reminder.
   */


  async setDismissSeedBackUpReminder(dismissSeedBackUpReminder) {
    await this.store.updateState({
      dismissSeedBackUpReminder
    });
  } //
  // PRIVATE METHODS
  //


  _subscribeToInfuraAvailability() {
    this.network.on(_network3.NETWORK_EVENTS.INFURA_IS_BLOCKED, () => {
      this._setInfuraBlocked(true);
    });
    this.network.on(_network3.NETWORK_EVENTS.INFURA_IS_UNBLOCKED, () => {
      this._setInfuraBlocked(false);
    });
  }
  /**
   *
   * A setter for the `infuraBlocked` property
   *
   * @param {boolean} isBlocked - Bool indicating whether Infura is blocked
   */


  _setInfuraBlocked(isBlocked) {
    const {
      infuraBlocked
    } = this.store.getState();

    if (infuraBlocked === isBlocked) {
      return;
    }

    this.store.updateState({
      infuraBlocked: isBlocked
    });
  }

}

exports.default = PreferencesController;


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\preferences.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\detect-tokens.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../ui/helpers/utils/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\util.js","../constants/contracts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\constants\\contracts.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","single-call-balance-checker-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\single-call-balance-checker-abi\\index.js","web3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\detect-tokens.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _web = _interopRequireDefault(require("web3"));

var _loglevel = require("loglevel");

var _singleCallBalanceCheckerAbi = _interopRequireDefault(require("single-call-balance-checker-abi"));

var _contracts = require("../constants/contracts");

var _time = require("../../../shared/constants/time");

var _util = require("../../../ui/helpers/utils/util");

var _network = require("../../../shared/constants/network");

// By default, poll every 3 minutes
const DEFAULT_INTERVAL = _time.MINUTE * 3;
/**
 * A controller that polls for token exchange
 * rates based on a user's current token list
 */

class DetectTokensController {
  /**
   * Creates a DetectTokensController
   *
   * @param {Object} [config] - Options to configure controller
   * @param config.interval
   * @param config.preferences
   * @param config.network
   * @param config.keyringMemStore
   * @param config.tokenList
   * @param config.tokensController
   */
  constructor({
    interval = DEFAULT_INTERVAL,
    preferences,
    network,
    keyringMemStore,
    tokenList,
    tokensController
  } = {}) {
    var _this$preferences, _this$tokensControlle, _this$tokensControlle2;

    this.tokensController = tokensController;
    this.preferences = preferences;
    this.interval = interval;
    this.network = network;
    this.keyringMemStore = keyringMemStore;
    this.tokenList = tokenList;
    this.selectedAddress = (_this$preferences = this.preferences) === null || _this$preferences === void 0 ? void 0 : _this$preferences.store.getState().selectedAddress;
    this.tokenAddresses = (_this$tokensControlle = this.tokensController) === null || _this$tokensControlle === void 0 ? void 0 : _this$tokensControlle.state.tokens.map(token => {
      return token.address;
    });
    this.hiddenTokens = (_this$tokensControlle2 = this.tokensController) === null || _this$tokensControlle2 === void 0 ? void 0 : _this$tokensControlle2.state.ignoredTokens;
    preferences === null || preferences === void 0 ? void 0 : preferences.store.subscribe(({
      selectedAddress,
      useTokenDetection
    }) => {
      if (this.selectedAddress !== selectedAddress || this.useTokenDetection !== useTokenDetection) {
        this.selectedAddress = selectedAddress;
        this.useTokenDetection = useTokenDetection;
        this.restartTokenDetection();
      }
    });
    tokensController === null || tokensController === void 0 ? void 0 : tokensController.subscribe(({
      tokens = [],
      ignoredTokens = []
    }) => {
      this.tokenAddresses = tokens.map(token => {
        return token.address;
      });
      this.hiddenTokens = ignoredTokens;
    });
  }

  async _getTokenBalances(tokens) {
    const ethContract = this.web3.eth.contract(_singleCallBalanceCheckerAbi.default).at(_contracts.SINGLE_CALL_BALANCES_ADDRESS);
    return new Promise((resolve, reject) => {
      ethContract.balances([this.selectedAddress], tokens, (error, result) => {
        if (error) {
          return reject(error);
        }

        return resolve(result);
      });
    });
  }
  /**
   * For each token in the tokenlist provided by the TokenListController, check selectedAddress balance.
   */


  async detectNewTokens() {
    if (!this.isActive) {
      return;
    }

    const {
      tokenList
    } = this._tokenList.state; // since the token detection is currently enabled only on Mainnet
    // we can use the chainId check to ensure token detection is not triggered for any other network
    // but once the balance check contract for other networks are deploayed and ready to use, we need to update this check.

    if (this._network.store.getState().provider.chainId !== _network.MAINNET_CHAIN_ID || Object.keys(tokenList).length === 0) {
      return;
    }

    const tokensToDetect = [];
    this.web3.setProvider(this._network._provider);

    for (const tokenAddress in tokenList) {
      if (!this.tokenAddresses.find(address => (0, _util.isEqualCaseInsensitive)(address, tokenAddress)) && !this.hiddenTokens.find(address => (0, _util.isEqualCaseInsensitive)(address, tokenAddress))) {
        tokensToDetect.push(tokenAddress);
      }
    }

    const sliceOfTokensToDetect = [tokensToDetect.slice(0, 1000), tokensToDetect.slice(1000, tokensToDetect.length - 1)];

    for (const tokensSlice of sliceOfTokensToDetect) {
      let result;

      try {
        result = await this._getTokenBalances(tokensSlice);
      } catch (error) {
        (0, _loglevel.warn)(`MetaMask - DetectTokensController single call balance fetch failed`, error);
        return;
      }

      const tokensWithBalance = tokensSlice.filter((_, index) => {
        const balance = result[index];
        return balance && !balance.isZero();
      });
      await Promise.all(tokensWithBalance.map(tokenAddress => {
        return this.tokensController.addToken(tokenAddress, tokenList[tokenAddress].symbol, tokenList[tokenAddress].decimals);
      }));
    }
  }
  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */


  restartTokenDetection() {
    if (!(this.isActive && this.selectedAddress)) {
      return;
    }

    this.detectNewTokens();
    this.interval = DEFAULT_INTERVAL;
  }
  /* eslint-disable accessor-pairs */

  /**
   * @type {number}
   */


  set interval(interval) {
    this._handle && clearInterval(this._handle);

    if (!interval) {
      return;
    }

    this._handle = setInterval(() => {
      this.detectNewTokens();
    }, interval);
  }
  /**
   * @type {Object}
   */


  set network(network) {
    if (!network) {
      return;
    }

    this._network = network;
    this.web3 = new _web.default(network._provider);
  }
  /**
   * In setter when isUnlocked is updated to true, detectNewTokens and restart polling
   *
   * @type {Object}
   */


  set keyringMemStore(keyringMemStore) {
    if (!keyringMemStore) {
      return;
    }

    this._keyringMemStore = keyringMemStore;

    this._keyringMemStore.subscribe(({
      isUnlocked
    }) => {
      if (this.isUnlocked !== isUnlocked) {
        this.isUnlocked = isUnlocked;

        if (isUnlocked) {
          this.restartTokenDetection();
        }
      }
    });
  }
  /**
   * @type {Object}
   */


  set tokenList(tokenList) {
    if (!tokenList) {
      return;
    }

    this._tokenList = tokenList;
  }
  /**
   * Internal isActive state
   *
   * @type {Object}
   */


  get isActive() {
    return this.isOpen && this.isUnlocked;
  }
  /* eslint-enable accessor-pairs */


}

exports.default = DetectTokensController;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\detect-tokens.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\index.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js","trezor-connect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\index.js","trezor-connect/lib/plugins/ethereum/typedData":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\plugins\\ethereum\\typedData.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events');
const ethUtil = require('ethereumjs-util');
const HDKey = require('hdkey');
const TrezorConnect = require('trezor-connect').default;
const { TransactionFactory } = require('@ethereumjs/tx');
const transformTypedData = require('trezor-connect/lib/plugins/ethereum/typedData');

const hdPathString = `m/44'/60'/0'/0`;
const SLIP0044TestnetPath = `m/44'/1'/0'/0`;

const ALLOWED_HD_PATHS = {
  [hdPathString]: true,
  [SLIP0044TestnetPath]: true,
};

const keyringType = 'Trezor Hardware';
const pathBase = 'm';
const MAX_INDEX = 1000;
const DELAY_BETWEEN_POPUPS = 1000;
const TREZOR_CONNECT_MANIFEST = {
  email: 'support@metamask.io',
  appUrl: 'https://metamask.io',
};

function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * @typedef {__import__('@ethereumjs/tx').TypedTransaction} TypedTransaction
 * @typedef {InstanceType<__import__("ethereumjs-tx")>} OldEthJsTransaction
 */

/**
 * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
 *
 * Transactions built with older versions of ethereumjs-tx have a
 * getChainId method that newer versions do not.
 * Older versions are mutable
 * while newer versions default to being immutable.
 * Expected shape and type
 * of data for v, r and s differ (Buffer (old) vs BN (new)).
 *
 * @param {TypedTransaction | OldEthJsTransaction} tx
 * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.
 */
function isOldStyleEthereumjsTx(tx) {
  return typeof tx.getChainId === 'function';
}

class TrezorKeyring extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.type = keyringType;
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.perPage = 5;
    this.unlockedAccount = 0;
    this.paths = {};
    this.deserialize(opts);

    TrezorConnect.on('DEVICE_EVENT', (event) => {
      if (event && event.payload && event.payload.features) {
        this.model = event.payload.features.model;
      }
    });
    TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST });
  }

  /**
   * Gets the model, if known.
   * This may be `undefined` if the model hasn't been loaded yet.
   *
   * @returns {"T" | "1" | undefined}
   */
  getModel() {
    return this.model;
  }

  dispose() {
    // This removes the Trezor Connect iframe from the DOM
    // This method is not well documented, but the code it calls can be seen
    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
    TrezorConnect.dispose();
  }

  serialize() {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      page: this.page,
      paths: this.paths,
      perPage: this.perPage,
      unlockedAccount: this.unlockedAccount,
    });
  }

  deserialize(opts = {}) {
    this.hdPath = opts.hdPath || hdPathString;
    this.accounts = opts.accounts || [];
    this.page = opts.page || 0;
    this.perPage = opts.perPage || 5;
    return Promise.resolve();
  }

  isUnlocked() {
    return Boolean(this.hdk && this.hdk.publicKey);
  }

  unlock() {
    if (this.isUnlocked()) {
      return Promise.resolve('already unlocked');
    }
    return new Promise((resolve, reject) => {
      TrezorConnect.getPublicKey({
        path: this.hdPath,
        coin: 'ETH',
      })
        .then((response) => {
          if (response.success) {
            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
            resolve('just unlocked');
          } else {
            reject(
              new Error(
                (response.payload && response.payload.error) || 'Unknown error',
              ),
            );
          }
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  setAccountToUnlock(index) {
    this.unlockedAccount = parseInt(index, 10);
  }

  addAccounts(n = 1) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = this.unlockedAccount;
          const to = from + n;

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            if (!this.accounts.includes(address)) {
              this.accounts.push(address);
            }
            this.page = 0;
          }
          resolve(this.accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  __getPage(increment) {
    this.page += increment;

    if (this.page <= 0) {
      this.page = 1;
    }

    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = (this.page - 1) * this.perPage;
          const to = from + this.perPage;

          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i,
            });
            this.paths[ethUtil.toChecksumAddress(address)] = i;
          }
          resolve(accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getAccounts() {
    return Promise.resolve(this.accounts.slice());
  }

  removeAccount(address) {
    if (
      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(
      (a) => a.toLowerCase() !== address.toLowerCase(),
    );
  }

  /**
   * Signs a transaction using Trezor.
   *
   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
   * the same type.
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  signTransaction(address, tx) {
    if (isOldStyleEthereumjsTx(tx)) {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex');
        tx.r = Buffer.from(payload.r, 'hex');
        tx.s = Buffer.from(payload.s, 'hex');
        return tx;
      });
    }
    return this._signTransaction(
      address,
      tx.common.chainIdBN().toNumber(),
      tx,
      (payload) => {
        // Because tx will be immutable, first get a plain javascript object that
        // represents the transaction. Using txData here as it aligns with the
        // nomenclature of ethereumjs/tx.
        const txData = tx.toJSON();
        // The fromTxData utility expects a type to support transactions with a type other than 0
        txData.type = tx.type;
        // The fromTxData utility expects v,r and s to be hex prefixed
        txData.v = ethUtil.addHexPrefix(payload.v);
        txData.r = ethUtil.addHexPrefix(payload.r);
        txData.s = ethUtil.addHexPrefix(payload.s);
        // Adopt the 'common' option from the original transaction and set the
        // returned object to be frozen if the original is frozen.
        return TransactionFactory.fromTxData(txData, {
          common: tx.common,
          freeze: Object.isFrozen(tx),
        });
      },
    );
  }

  /**
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {number} chainId - Chain ID
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @param {(__import__('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction
   * to the same new-style or old-style ethereumjs-tx.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  async _signTransaction(address, chainId, tx, handleSigning) {
    let transaction;
    if (isOldStyleEthereumjsTx(tx)) {
      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
      // so we need to convert to hex-strings manually manually
      transaction = {
        to: this._normalize(tx.to),
        value: this._normalize(tx.value),
        data: this._normalize(tx.data),
        chainId,
        nonce: this._normalize(tx.nonce),
        gasLimit: this._normalize(tx.gasLimit),
        gasPrice: this._normalize(tx.gasPrice),
      };
    } else {
      // new-style transaction from @ethereumjs/tx package
      // we can just copy tx.toJSON() for everything except chainId, which must be a number
      transaction = {
        ...tx.toJSON(),
        chainId,
        to: this._normalize(tx.to),
      };
    }

    try {
      const status = await this.unlock();
      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
      const response = await TrezorConnect.ethereumSignTransaction({
        path: this._pathFromAddress(address),
        transaction,
      });
      if (response.success) {
        const newOrMutatedTx = handleSigning(response.payload);

        const addressSignedWith = ethUtil.toChecksumAddress(
          ethUtil.addHexPrefix(
            newOrMutatedTx.getSenderAddress().toString('hex'),
          ),
        );
        const correctAddress = ethUtil.toChecksumAddress(address);
        if (addressSignedWith !== correctAddress) {
          throw new Error("signature doesn't match the right address");
        }

        return newOrMutatedTx;
      }
      throw new Error(
        (response.payload && response.payload.error) || 'Unknown error',
      );
    } catch (e) {
      throw new Error((e && e.toString()) || 'Unknown error');
    }
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage(withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((status) => {
          setTimeout(
            (_) => {
              TrezorConnect.ethereumSignMessage({
                path: this._pathFromAddress(withAccount),
                message: ethUtil.stripHexPrefix(message),
                hex: true,
              })
                .then((response) => {
                  if (response.success) {
                    if (
                      response.payload.address !==
                      ethUtil.toChecksumAddress(withAccount)
                    ) {
                      reject(
                        new Error('signature doesnt match the right address'),
                      );
                    }
                    const signature = `0x${response.payload.signature}`;
                    resolve(signature);
                  } else {
                    reject(
                      new Error(
                        (response.payload && response.payload.error) ||
                          'Unknown error',
                      ),
                    );
                  }
                })
                .catch((e) => {
                  reject(new Error((e && e.toString()) || 'Unknown error'));
                });
              // This is necessary to avoid popup collision
              // between the unlock & sign trezor popups
            },
            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
          );
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  /**
   * EIP-712 Sign Typed Data
   */
  async signTypedData(address, data, { version }) {
    const dataWithHashes = transformTypedData(data, version === 'V4');

    // set default values for signTypedData
    // Trezor is stricter than @metamask/eth-sig-util in what it accepts
    const {
      types: { EIP712Domain = [], ...otherTypes } = {},
      message = {},
      domain = {},
      primaryType,
      // snake_case since Trezor uses Protobuf naming conventions here
      domain_separator_hash, // eslint-disable-line camelcase
      message_hash, // eslint-disable-line camelcase
    } = dataWithHashes;

    // This is necessary to avoid popup collision
    // between the unlock & sign trezor popups
    const status = await this.unlock();
    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);

    const response = await TrezorConnect.ethereumSignTypedData({
      path: this._pathFromAddress(address),
      data: {
        types: { EIP712Domain, ...otherTypes },
        message,
        domain,
        primaryType,
      },
      metamask_v4_compat: true,
      // Trezor 1 only supports blindly signing hashes
      domain_separator_hash,
      message_hash,
    });

    if (response.success) {
      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
        throw new Error('signature doesnt match the right address');
      }
      return response.payload.signature;
    }

    throw new Error(
      (response.payload && response.payload.error) || 'Unknown error',
    );
  }

  exportAccount() {
    return Promise.reject(new Error('Not supported on this device'));
  }

  forgetDevice() {
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.unlockedAccount = 0;
    this.paths = {};
  }

  /**
   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
   *
   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
   * path is set, and the wallet state is completely reset.
   *
   * @throws {Error] Throws if the HD path is not supported.
   *
   * @param {string} hdPath - The HD path to set.
   */
  setHdPath(hdPath) {
    if (!ALLOWED_HD_PATHS[hdPath]) {
      throw new Error(
        `The setHdPath method does not support setting HD Path to ${hdPath}`,
      );
    }

    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey();
      this.accounts = [];
      this.page = 0;
      this.perPage = 5;
      this.unlockedAccount = 0;
      this.paths = {};
    }
    this.hdPath = hdPath;
  }

  /* PRIVATE METHODS */

  _normalize(buf) {
    return ethUtil.bufferToHex(buf).toString();
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex(pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`);
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex');
    return ethUtil.toChecksumAddress(`0x${address}`);
  }

  _pathFromAddress(address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address);
    let index = this.paths[checksummedAddress];
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i;
          break;
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address');
    }
    return `${this.hdPath}/${index}`;
  }
}

TrezorKeyring.type = keyringType;
module.exports = TrezorKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-trezor-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js", {"./permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\index.js","./resource":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\index.js","./services":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\index.js","./snaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\index.js","./subject-metadata":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./permissions"), exports);
__exportStar(require("./resource"), exports);
__exportStar(require("./services"), exports);
__exportStar(require("./snaps"), exports);
__exportStar(require("./subject-metadata"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\index.js", {"./createMethodMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\createMethodMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createMethodMiddleware = require("./createMethodMiddleware");

Object.keys(_createMethodMiddleware).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _createMethodMiddleware[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createMethodMiddleware[key];
    }
  });
});

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js", {"./metamask-airgapped-keyring.cjs.development.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq\\metamask-airgapped-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\threebox.js", {"../../../development/mock-3box":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\development\\mock-3box.js","../lib/createOriginMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createOriginMiddleware.js","../lib/migrator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\migrator\\index.js","../migrations":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\index.js","./network/createMetamaskMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createMetamaskMiddleware.js","3box":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3box.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\threebox.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _migrator = _interopRequireDefault(require("../lib/migrator"));

var _migrations = _interopRequireDefault(require("../migrations"));

var _createOriginMiddleware = _interopRequireDefault(require("../lib/createOriginMiddleware"));

var _createMetamaskMiddleware = _interopRequireDefault(require("./network/createMetamaskMiddleware"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable import/first,import/order */
const Box = process.env.IN_TEST ? require('../../../development/mock-3box') : require('3box');
/* eslint-enable import/order */

/* eslint-enable import/first */
const SYNC_TIMEOUT = 60 * 1000; // one minute

class ThreeBoxController {
  constructor(opts = {}) {
    const {
      preferencesController,
      keyringController,
      addressBookController,
      version,
      getKeyringControllerState,
      trackMetaMetricsEvent
    } = opts;
    this.preferencesController = preferencesController;
    this.addressBookController = addressBookController;
    this.keyringController = keyringController;
    this.provider = this._createProvider({
      version,
      getAccounts: async ({
        origin
      }) => {
        if (origin !== '3Box') {
          return [];
        }

        const {
          isUnlocked
        } = getKeyringControllerState();
        const accounts = await this.keyringController.getAccounts();

        if (isUnlocked && accounts[0]) {
          const appKeyAddress = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io');
          return [appKeyAddress];
        }

        return [];
      },
      processPersonalMessage: async msgParams => {
        const accounts = await this.keyringController.getAccounts();
        return keyringController.signPersonalMessage(_objectSpread(_objectSpread({}, msgParams), {}, {
          from: accounts[0]
        }), {
          withAppKeyOrigin: 'wallet://3box.metamask.io'
        });
      }
    });
    this._trackMetaMetricsEvent = trackMetaMetricsEvent;

    const initState = _objectSpread(_objectSpread({
      threeBoxSyncingAllowed: false,
      showRestorePrompt: true,
      threeBoxLastUpdated: 0
    }, opts.initState), {}, {
      threeBoxAddress: null,
      threeBoxSynced: false,
      threeBoxDisabled: false
    });

    this.store = new _obsStore.ObservableStore(initState);
    this.registeringUpdates = false;
    this.lastMigration = _migrations.default.sort((a, b) => a.version - b.version).slice(-1)[0];

    if (initState.threeBoxSyncingAllowed) {
      this.init();
    }
  }

  async init() {
    const accounts = await this.keyringController.getAccounts();
    this.address = accounts[0];

    this._trackMetaMetricsEvent({
      event: '3Box Initiated',
      category: '3Box'
    });

    if (this.address && !(this.box && this.store.getState().threeBoxSynced)) {
      await this.new3Box();
    }
  }

  async _update3Box() {
    try {
      const {
        threeBoxSyncingAllowed,
        threeBoxSynced
      } = this.store.getState();

      if (threeBoxSyncingAllowed && threeBoxSynced) {
        const newState = {
          preferences: this.preferencesController.store.getState(),
          addressBook: this.addressBookController.state,
          lastUpdated: Date.now(),
          lastMigration: this.lastMigration
        };
        await this.space.private.set('metamaskBackup', JSON.stringify(newState));
        await this.setShowRestorePromptToFalse();
      }
    } catch (error) {
      console.error(error);
    }
  }

  _createProvider(providerOpts) {
    const metamaskMiddleware = (0, _createMetamaskMiddleware.default)(providerOpts);
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    engine.push((0, _createOriginMiddleware.default)({
      origin: '3Box'
    }));
    engine.push(metamaskMiddleware);
    const provider = (0, _ethJsonRpcMiddleware.providerFromEngine)(engine);
    return provider;
  }

  _waitForOnSyncDone() {
    return new Promise(resolve => {
      this.box.onSyncDone(() => {
        _loglevel.default.debug('3Box box sync done');

        return resolve();
      });
    });
  }

  async new3Box() {
    const accounts = await this.keyringController.getAccounts();
    this.address = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io');
    let backupExists;

    try {
      const threeBoxConfig = await Box.getConfig(this.address);
      backupExists = threeBoxConfig.spaces && threeBoxConfig.spaces.metamask;
    } catch (e) {
      if (e.message.match(/^Error: Invalid response \(404\)/u)) {
        this._trackMetaMetricsEvent({
          event: '3Box Backup does not exist',
          category: '3Box'
        });

        backupExists = false;
      } else {
        this._trackMetaMetricsEvent({
          event: '3Box Config Error',
          category: '3Box'
        });

        throw e;
      }
    }

    if (this.getThreeBoxSyncingState() || backupExists) {
      this.store.updateState({
        threeBoxSynced: false
      });
      let timedOut = false;
      const syncTimeout = setTimeout(() => {
        _loglevel.default.error(`3Box sync timed out after ${SYNC_TIMEOUT} ms`);

        timedOut = true;
        this.store.updateState({
          threeBoxDisabled: true,
          threeBoxSyncingAllowed: false
        });
      }, SYNC_TIMEOUT);

      try {
        this.box = await Box.openBox(this.address, this.provider);
        await this._waitForOnSyncDone();
        this.space = await this.box.openSpace('metamask', {
          onSyncDone: async () => {
            const stateUpdate = {
              threeBoxSynced: true,
              threeBoxAddress: this.address
            };

            if (timedOut) {
              _loglevel.default.info(`3Box sync completed after timeout; no longer disabled`);

              stateUpdate.threeBoxDisabled = false;
            }

            clearTimeout(syncTimeout);
            this.store.updateState(stateUpdate);

            _loglevel.default.debug('3Box space sync done');

            this._trackMetaMetricsEvent({
              event: '3Box Synced',
              category: '3Box'
            });
          }
        });
      } catch (e) {
        this._trackMetaMetricsEvent({
          event: '3Box Initiation Error',
          category: '3Box'
        });

        console.error(e);
        throw e;
      }
    }
  }

  async getLastUpdated() {
    const res = await this.space.private.get('metamaskBackup');
    const parsedRes = JSON.parse(res || '{}');
    return parsedRes.lastUpdated;
  }

  async migrateBackedUpState(backedUpState) {
    const migrator = new _migrator.default({
      migrations: _migrations.default
    });
    const {
      preferences,
      addressBook
    } = JSON.parse(backedUpState);
    const formattedStateBackup = {
      PreferencesController: preferences,
      AddressBookController: addressBook
    };
    const initialMigrationState = migrator.generateInitialState(formattedStateBackup);
    const migratedState = await migrator.migrateData(initialMigrationState);
    return {
      preferences: migratedState.data.PreferencesController,
      addressBook: migratedState.data.AddressBookController
    };
  }

  async restoreFromThreeBox() {
    const backedUpState = await this.space.private.get('metamaskBackup');
    const {
      preferences,
      addressBook
    } = await this.migrateBackedUpState(backedUpState);
    this.store.updateState({
      threeBoxLastUpdated: backedUpState.lastUpdated
    });
    preferences && this.preferencesController.store.updateState(preferences);
    addressBook && this.addressBookController.update(addressBook, true);
    this.setShowRestorePromptToFalse();

    this._trackMetaMetricsEvent({
      event: '3Box Restored Data',
      category: '3Box'
    });
  }

  turnThreeBoxSyncingOn() {
    this._trackMetaMetricsEvent({
      event: '3Box Sync Turned On',
      category: '3Box'
    });

    this._registerUpdates();
  }

  turnThreeBoxSyncingOff() {
    this._trackMetaMetricsEvent({
      event: '3Box Sync Turned Off',
      category: '3Box'
    });

    this.box.logout();
  }

  setShowRestorePromptToFalse() {
    this.store.updateState({
      showRestorePrompt: false
    });
  }

  setThreeBoxSyncingPermission(newThreeboxSyncingState) {
    if (this.store.getState().threeBoxDisabled) {
      return;
    }

    this.store.updateState({
      threeBoxSyncingAllowed: newThreeboxSyncingState
    });

    if (newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOn();
    }

    if (!newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOff();
    }
  }

  getThreeBoxSyncingState() {
    return this.store.getState().threeBoxSyncingAllowed;
  }

  _registerUpdates() {
    if (!this.registeringUpdates) {
      const updatePreferences = this._update3Box.bind(this);

      this.preferencesController.store.subscribe(updatePreferences);

      const updateAddressBook = this._update3Box.bind(this);

      this.addressBookController.subscribe(updateAddressBook);
      this.registeringUpdates = true;
    }
  }

}

exports.default = ThreeBoxController;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\threebox.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\safe-event-emitter\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    }
    catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(() => {
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for (let i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends events_1.EventEmitter {
    emit(type, ...args) {
        let doError = type === 'error';
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        }
        else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            safeApply(handler, this, args);
        }
        else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for (let i = 0; i < len; i += 1) {
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
exports.default = SafeEventEmitter;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\safe-event-emitter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\node_modules\\through2\\through2.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\obs-store\node_modules\through2\through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\node_modules\\through2\\through2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\fail-tx.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\migrations\fail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  };
}

function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }

      txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\fail-tx.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","fast-json-patch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\duplex.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\lib\tx-state-history-helpers.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateHistoryEntry = generateHistoryEntry;
exports.migrateFromSnapshotsToDiffs = migrateFromSnapshotsToDiffs;
exports.replayHistory = replayHistory;
exports.snapshotFromTxMeta = snapshotFromTxMeta;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fastJsonPatch = _interopRequireDefault(require("fast-json-patch"));

var _lodash = require("lodash");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * converts non-initial history entries into diffs
 *
 * @param {Array} longHistory
 * @returns {Array}
 */
function migrateFromSnapshotsToDiffs(longHistory) {
  return longHistory // convert non-initial history entries into diffs
  .map((entry, index) => {
    if (index === 0) {
      return entry;
    }

    return generateHistoryEntry(longHistory[index - 1], entry);
  });
}
/**
 * Generates an array of history objects sense the previous state.
 * The object has the keys
 * op (the operation performed),
 * path (the key and if a nested object then each key will be separated with a `/`)
 * value
 * with the first entry having the note and a timestamp when the change took place
 *
 * @param {Object} previousState - the previous state of the object
 * @param {Object} newState - the update object
 * @param {string} [note] - a optional note for the state change
 * @returns {Array}
 */


function generateHistoryEntry(previousState, newState, note) {
  const entry = _fastJsonPatch.default.compare(previousState, newState); // Add a note to the first op, since it breaks if we append it to the entry


  if (entry[0]) {
    if (note) {
      entry[0].note = note;
    }

    entry[0].timestamp = Date.now();
  }

  return entry;
}
/**
 * Recovers previous txMeta state obj
 *
 * @param _shortHistory
 * @returns {Object}
 */


function replayHistory(_shortHistory) {
  const shortHistory = (0, _lodash.cloneDeep)(_shortHistory);
  return shortHistory.reduce((val, entry) => _fastJsonPatch.default.applyPatch(val, entry).newDocument);
}
/**
 * Snapshot {@code txMeta}
 *
 * @param {Object} txMeta - the tx metadata object
 * @returns {Object} a deep clone without history
 */


function snapshotFromTxMeta(txMeta) {
  const shallow = _objectSpread({}, txMeta);

  delete shallow.history;
  return (0, _lodash.cloneDeep)(shallow);
}


      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\to-data-view\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\to-data-view\index.js
      return function (require, module, exports) {
module.exports = function toDataView (data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength)
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data)
  }

  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
}

      };
    };
  }
}, {package:"to-data-view",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\to-data-view\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\registry.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\ens-ipfs\contracts\registry.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const abi = [{
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'resolver',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'owner',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'label',
    type: 'bytes32'
  }, {
    name: 'owner',
    type: 'address'
  }],
  name: 'setSubnodeOwner',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'ttl',
    type: 'uint64'
  }],
  name: 'setTTL',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'ttl',
  outputs: [{
    name: '',
    type: 'uint64'
  }],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'resolver',
    type: 'address'
  }],
  name: 'setResolver',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'owner',
    type: 'address'
  }],
  name: 'setOwner',
  outputs: [],
  payable: false,
  type: 'function'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'owner',
    type: 'address'
  }],
  name: 'Transfer',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: true,
    name: 'label',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'owner',
    type: 'address'
  }],
  name: 'NewOwner',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'resolver',
    type: 'address'
  }],
  name: 'NewResolver',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'ttl',
    type: 'uint64'
  }],
  name: 'NewTTL',
  type: 'event'
}];
var _default = abi;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\registry.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MuanMiLCJhcHAvc2NyaXB0cy9maXJzdC10aW1lLXN0YXRlLmpzIiwiYXBwL3NjcmlwdHMvbGliL2dldE9ialN0cnVjdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJvdW5jZS1zdHJlYW0vaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvbmV0d29yay1zdG9yZS5qcyIsImFwcC9zY3JpcHRzL2xpYi9ub3RpZmljYXRpb24tbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2xpYi9jcmVhdGVTdHJlYW1TaW5rLmpzIiwiYXBwL3NjcmlwdHMvbGliL2xvY2FsLXN0b3JlLmpzIiwiYXBwL3NjcmlwdHMvbGliL2dldC1maXJzdC1wcmVmZXJyZWQtbGFuZy1jb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2xpYi9taWdyYXRvci9pbmRleC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvZW5zLWlwZnMvc2V0dXAuanMiLCJhcHAvc2NyaXB0cy9tZXRhbWFzay1jb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZHVwbGV4ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2FzU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Mb2NhbFN0b3JhZ2VTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvdHJhbnNmb3JtLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDExLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxOC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlMzItZW5jb2RlL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL2Vucy1pcGZzL3Jlc29sdmVyLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZU9yaWdpbk1pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9saWIvY3JlYXRlVGFiSWRNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5icm93c2VyLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZU1ldGFSUENIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2VuZ2luZVN0cmVhbS5qcyIsImFwcC9zY3JpcHRzL2xpYi9Db21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlLmpzIiwiYXBwL3NjcmlwdHMvbGliL2NyZWF0ZUxvZ2dlck1pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9saWIvY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9vbmJvYXJkaW5nLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvYXBwLXN0YXRlLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvYWxlcnQuanMiLCJhcHAvc2NyaXB0cy9saWIvZGVjcnlwdC1tZXNzYWdlLW1hbmFnZXIuanMiLCJhcHAvc2NyaXB0cy9saWIvZW5jcnlwdGlvbi1wdWJsaWMta2V5LW1hbmFnZXIuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9jYWNoZWQtYmFsYW5jZXMuanMiLCJhcHAvc2NyaXB0cy9saWIvcGVyc29uYWwtbWVzc2FnZS1tYW5hZ2VyLmpzIiwiYXBwL3NjcmlwdHMvbGliL3NlZWQtcGhyYXNlLXZlcmlmaWVyLmpzIiwiYXBwL3NjcmlwdHMvbGliL21lc3NhZ2UtbWFuYWdlci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL21ldGFtZXRyaWNzLmpzIiwiYXBwL3NjcmlwdHMvbGliL2FjY291bnQtdHJhY2tlci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL2luY29taW5nLXRyYW5zYWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2xpYi90eXBlZC1tZXNzYWdlLW1hbmFnZXIuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9lbnMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2xpYi9zZWdtZW50LmpzIiwiYXBwL3NjcmlwdHMvYWNjb3VudC1pbXBvcnQtc3RyYXRlZ2llcy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL25ldHdvcmsvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9zd2Fwcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1sYXR0aWNlLWtleXJpbmcvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wcmVmZXJlbmNlcy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL2RldGVjdC10b2tlbnMuanMiLCJub2RlX21vZHVsZXMvZXRoLXRyZXpvci1rZXlyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy90aHJlZWJveC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvbm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9mYWlsLXR4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdG8tZGF0YS12aWV3L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL2Vucy1pcGZzL2NvbnRyYWN0cy9yZWdpc3RyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdz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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2puQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeDFCQSxJQUFBLFVBQUEsT0FBQSxDQUFBLFFBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsY0FBQSxPQUFBLENBQUEs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LFVBQUosRUFBZ0I7QUFDZCxlQUFLLHFCQUFMO0FBQ0Q7QUFDRjtBQUNGLEtBUEQ7QUFRRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ2UsTUFBVCxTQUFTLENBQUMsU0FBRCxFQUFZO0FBQ3ZCLFFBQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2Q7QUFDRDs7QUFDRCxTQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNjLE1BQVIsUUFBUSxHQUFHO0FBQ2IsV0FBTyxLQUFLLE1BQUwsSUFBZSxLQUFLLFVBQTNCO0FBQ0Q7QUFDRDs7O0FBOU0wQzs7Ozs7Ozs7Ozs7Ozs7O0FDZjVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEVBQUEsTUFBTSxFQUFFLENBQ047QUFBRSxJQUFBLE9BQU8sRUFBRSxJQUFYO0FBQWlCLElBQUEsSUFBSSxFQUFFLE1BQXZCO0FBQStCLElBQUEsSUFBSSxFQUFFO0FBQXJDLEdBRE0sRUFFTjtBQUFFLElBQUEsT0FBTyxFQUFFLEtBQVg7QUFBa0IsSUFBQSxJQUFJLEVBQUUsS0FBeEI7QUFBK0IsSUFBQSxJQUFJLEVBQUU7QUFBckMsR0FGTSxDQUZWO0FBTUUsRUFBQSxJQUFJLEVBQUUsUUFOUjtBQU9FLEVBQUEsSUFBSSxFQUFFO0FBUFIsQ0FsR1UsQ0FBWjtlQTRHZSxHIiwiZmlsZSI6ImJhY2tncm91bmQtMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFR5cGUgSW1wb3J0c1xuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCcpLkVudmlyb25tZW50VHlwZX0gRW52aXJvbm1lbnRUeXBlXG4gKi9cblxuLy8gVHlwZSBEZWNsYXJhdGlvbnNcbi8qKlxuICogVXNlZCB0byBhdHRhY2ggY29udGV4dCBvZiB3aGVyZSB0aGUgdXNlciB3YXMgYXQgaW4gdGhlIGFwcGxpY2F0aW9uIHdoZW4gdGhlXG4gKiBldmVudCB3YXMgdHJpZ2dlcmVkLiBBbHNvIGluY2x1ZGVkIGFzIGZ1bGwgZGV0YWlscyBvZiB0aGUgY3VycmVudCBwYWdlIGluXG4gKiBwYWdlIGV2ZW50cy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc1BhZ2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGF0aF0gLSB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcgL2hvbWUpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSAtIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBwYWdlIChlLmcgJ2hvbWUnKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIC0gdGhlIGZ1bGx5IHF1YWxpZmllZCB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZVxuICovXG5cbi8qKlxuICogRm9yIG1ldGFtYXNrLCB0aGlzIGlzIHRoZSBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIC0gdGhlIG9yaWdpbiBvZiB0aGUgZGFwcCBpc3N1aW5nIHRoZVxuICogIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogV2UgYXR0YWNoIGNvbnRleHQgdG8gZXZlcnkgbWV0YSBtZXRyaWNzIGV2ZW50IHRoYXQgaGVscCB0byBxdWFsaWZ5IG91clxuICogYW5hbHl0aWNzLiBUaGlzIHR5cGUgaGFzIGFsbCBvcHRpb25hbCB2YWx1ZXMgYmVjYXVzZSBpdCByZXByZXNlbnRzIGFcbiAqIHJldHVybmVkIG9iamVjdCBmcm9tIGEgbWV0aG9kIGNhbGwuIElkZWFsbHkgYXBwIGFuZCB1c2VyQWdlbnQgYXJlXG4gKiBkZWZpbmVkIG9uIGV2ZXJ5IGV2ZW50LiBUaGlzIGlzIGNvbmZpcm1lZCBpbiB0aGUgZ2V0VHJhY2tNZXRhTWV0cmljc0V2ZW50XG4gKiBmdW5jdGlvbiwgYnV0IHN0aWxsIHByb3ZpZGVzIHRoZSBjb25zdW1lciBhIHdheSB0byBvdmVycmlkZSB0aGVzZSB2YWx1ZXMgaWZcbiAqIG5lY2Vzc2FyeS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc0NvbnRleHRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcHAgLSBBcHBsaWNhdGlvbiBtZXRhZGF0YS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcHAubmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbiB0cmFja2luZyB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcHAudmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG9mIHRoZSBhcHBsaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVzZXJBZ2VudCAtIHRoZSB1c2VyYWdlbnQgc3RyaW5nIG9mIHRoZSB1c2VyXG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUGFnZU9iamVjdH0gW3BhZ2VdIC0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyBkZXRhaWxzIG9mXG4gKiAgdGhlIGN1cnJlbnQgcGFnZVxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0fSBbcmVmZXJyZXJdIC0gZm9yIG1ldGFtYXNrLCB0aGlzIGlzIHRoZVxuICogIGRhcHAgdGhhdCB0cmlnZ2VyZWQgYW4gaW50ZXJhY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFNZXRyaWNzRXZlbnRQYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lIHRvIHRyYWNrXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSBjYXRlZ29yeSB0byBhc3NvY2lhdGUgZXZlbnQgdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW52aXJvbm1lbnRUeXBlXSAtIFRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoaXMgZXZlbnRcbiAqICBvY2N1cnJlZCBpbi4gRGVmYXVsdHMgdG8gdGhlIGJhY2tncm91bmQgcHJvY2VzcyB0eXBlXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3Byb3BlcnRpZXNdIC0gb2JqZWN0IG9mIGN1c3RvbSB2YWx1ZXMgdG8gdHJhY2ssIGtleXNcbiAqICBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2VcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2Vuc2l0aXZlUHJvcGVydGllc10gLSBPYmplY3Qgb2Ygc2Vuc2l0aXZlIHZhbHVlcyB0b1xuICogIHRyYWNrLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmUgaW4gc25ha2VfY2FzZS4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlXG4gKiAgc2VudCBpbiBhbiBhZGRpdGlvbmFsIGV2ZW50IHRoYXQgZXhjbHVkZXMgdGhlIHVzZXIncyBtZXRhTWV0cmljc0lkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JldmVudWVdIC0gYW1vdW50IG9mIGN1cnJlbmN5IHRoYXQgZXZlbnQgY3JlYXRlcyBpblxuICogIHJldmVudWUgZm9yIE1ldGFNYXNrXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbmN5XSAtIElTTyA0MTI3IGZvcm1hdCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGhcbiAqICByZXZlbnVlLCBkZWZhdWx0cyB0byBVUyBkb2xsYXJzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXSAtIEFic3RyYWN0IGJ1c2luZXNzIFwidmFsdWVcIiBhdHRyaWJ1dGFibGUgdG9cbiAqICBjdXN0b21lcnMgd2hvIHRyaWdnZXIgdGhpcyBldmVudFxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIHRoZSBwYWdlL3JvdXRlIHRoYXQgdGhlIGV2ZW50XG4gKiAgb2NjdXJyZWQgb25cbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIHRoZSBvcmlnaW4gb2YgdGhlIGRhcHBcbiAqICB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFNZXRyaWNzRXZlbnRPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc09wdEluXSAtIGhhcHBlbmVkIGR1cmluZyBvcHQgaW4vb3V0IHdvcmtmbG93XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmbHVzaEltbWVkaWF0ZWx5XSAtIFdoZW4gdHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZmx1c2hcbiAqICB0aGUgc2VnbWVudCBxdWV1ZSBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuIFJlY29tbWVuZGVkIGlmIHRoZSByZXN1bHQgb2ZcbiAqICB0cmFja2luZyB0aGUgZXZlbnQgbXVzdCBiZSBrbm93biBiZWZvcmUgVUkgdHJhbnNpdGlvbiBvciB1cGRhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2V4Y2x1ZGVNZXRhTWV0cmljc0lkXSAtIHdoZXRoZXIgdG8gZXhjbHVkZSB0aGUgdXNlcidzXG4gKiAgbWV0YW1ldHJpY3MgaWQgZm9yIGFub255bWl0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXRhTWV0cmljc0lkXSAtIGFuIG92ZXJyaWRlIGZvciB0aGUgbWV0YU1ldHJpY3NJZCBpblxuICogIHRoZSBldmVudCBvbmUgaXMgY3JlYXRlZCBhcyBwYXJ0IG9mIGFuIGFzeW5jaHJvbm91cyB3b3JrZmxvdywgc3VjaCBhc1xuICogIGF3YWl0aW5nIHRoZSByZXN1bHQgb2YgdGhlIG1ldGFtZXRyaWNzIG9wdC1pbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGVcbiAqICB1c2VyJ3MgbWV0YW1ldHJpY3MgaWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21hdG9tb0V2ZW50XSAtIGlzIHRoaXMgZXZlbnQgYSBob2xkb3ZlciBmcm9tIG1hdG9tb1xuICogIHRoYXQgbmVlZHMgZnVydGhlciBtaWdyYXRpb24/IHdoZW4gdHJ1ZSwgc2VuZHMgdGhlIGRhdGEgdG8gYSBzcGVjaWFsXG4gKiAgc2VnbWVudCBzb3VyY2UgdGhhdCBtYXJrcyB0aGUgZXZlbnQgZGF0YSBhcyBub3QgY29uZm9ybWluZyB0byBvdXIgc2NoZW1hXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50RnJhZ21lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdWNjZXNzRXZlbnQgLSBUaGUgZXZlbnQgbmFtZSB0byBmaXJlIHdoZW4gdGhlIGZyYWdtZW50XG4gKiAgaXMgY2xvc2VkIGluIGFuIGFmZmlybWF0aXZlIGFjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmFpbHVyZUV2ZW50XSAtIFRoZSBldmVudCBuYW1lIHRvIGZpcmUgd2hlbiB0aGUgZnJhZ21lbnRcbiAqICBpcyBjbG9zZWQgd2l0aCBhIHJlamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaW5pdGlhbEV2ZW50XSAtIEFuIGV2ZW50IG5hbWUgdG8gZmlyZSBpbW1lZGlhdGVseSB1cG9uXG4gKiAgZnJhZ21lbnQgY3JlYXRpb24uIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZyBmdW5uZWxzIGluIG1peHBhbmVsIGFuZCBmb3JcbiAqICByZWR1Y3Rpb24gb2YgY29kZSBkdXBsaWNhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYXRlZ29yeSAtIHRoZSBldmVudCBjYXRlZ29yeSB0byB1c2UgZm9yIGJvdGggdGhlIHN1Y2Nlc3NcbiAqICBhbmQgZmFpbHVyZSBldmVudHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BlcnNpc3RdIC0gU2hvdWxkIHRoaXMgZnJhZ21lbnQgYmUgcGVyc2lzdGVkIGluXG4gKiAgc3RhdGUgYW5kIHByb2dyZXNzZWQgYWZ0ZXIgdGhlIGV4dGVuc2lvbiBpcyBsb2NrZWQgYW5kIHVubG9ja2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aW1lb3V0XSAtIFRpbWUgaW4gc2Vjb25kcyB0aGUgZXZlbnQgc2hvdWxkIGJlIHBlcnNpc3RlZFxuICogIGZvci4gQWZ0ZXIgdGhlIHRpbWVvdXQgdGhlIGZyYWdtZW50IHdpbGwgYmUgY2xvc2VkIGFzIGFiYW5kb25lZC4gaWYgbm90XG4gKiAgc3VwcGxpZWQgdGhlIGZyYWdtZW50IGlzIHN0b3JlZCBpbmRlZmluaXRlbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RVcGRhdGVkXSAtIERhdGUubm93KCkgd2hlbiB0aGUgZnJhZ21lbnQgd2FzIGxhc3RcbiAqICB1cGRhdGVkLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgdGltZW91dCBoYXMgZXhwaXJlZCBhbmQgdGhlIGZyYWdtZW50XG4gKiAgc2hvdWxkIGJlIGNsb3NlZC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcHJvcGVydGllc10gLSBPYmplY3Qgb2YgY3VzdG9tIHZhbHVlcyB0byB0cmFjaywga2V5cyBpblxuICogIHRoaXMgb2JqZWN0IG11c3QgYmUgaW4gc25ha2VfY2FzZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2Vuc2l0aXZlUHJvcGVydGllc10gLSBPYmplY3Qgb2Ygc2Vuc2l0aXZlIHZhbHVlcyB0b1xuICogIHRyYWNrLiBLZXlzIGluIHRoaXMgb2JqZWN0IG11c3QgYmUgaW4gc25ha2VfY2FzZS4gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlXG4gKiAgc2VudCBpbiBhbiBhZGRpdGlvbmFsIGV2ZW50IHRoYXQgZXhjbHVkZXMgdGhlIHVzZXIncyBtZXRhTWV0cmljc0lkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JldmVudWVdIC0gYW1vdW50IG9mIGN1cnJlbmN5IHRoYXQgZXZlbnQgY3JlYXRlcyBpblxuICogIHJldmVudWUgZm9yIE1ldGFNYXNrIGlmIGZyYWdtZW50IGlzIHN1Y2Nlc3NmdWwuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbmN5XSAtIElTTyA0MTI3IGZvcm1hdCBjdXJyZW5jeSBmb3IgZXZlbnRzIHdpdGhcbiAqICByZXZlbnVlLCBkZWZhdWx0cyB0byBVUyBkb2xsYXJzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXSAtIEFic3RyYWN0IGJ1c2luZXNzIFwidmFsdWVcIiBhdHRyaWJ1dGFibGUgdG9cbiAqICBjdXN0b21lcnMgd2hvIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZSB0aGlzIGZyYWdtZW50XG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUGFnZU9iamVjdH0gW3BhZ2VdIC0gdGhlIHBhZ2Uvcm91dGUgdGhhdCB0aGUgZXZlbnRcbiAqICBvY2N1cnJlZCBvblxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0fSBbcmVmZXJyZXJdIC0gdGhlIG9yaWdpbiBvZiB0aGUgZGFwcFxuICogIHRoYXQgaW5pdGlhdGVkIHRoZSBldmVudCBmcmFnbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdW5pcXVlSWRlbnRpZmllcl0gLSBvcHRpb25hbCBhcmd1bWVudCB0byBvdmVycmlkZSB0aGVcbiAqICBhdXRvbWF0aWMgZ2VuZXJhdGlvbiBvZiBVVUlEIGZvciB0aGUgZXZlbnQgZnJhZ21lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW5cbiAqICB0cmFja2luZyBldmVudHMgZm9yIHN1YnN5c3RlbXMgdGhhdCBhbHJlYWR5IGdlbmVyYXRlIFVVSURzIHNvIHRvIGF2b2lkXG4gKiAgdW5uZWNlc3NhcnkgbG9va3VwcyBhbmQgcmVkdWNlIGFjY2lkZW50YWwgZHVwbGljYXRpb24uXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzaGFwZSBvZiBkYXRhIHNlbnQgdG8gdGhlIHNlZ21lbnQudHJhY2sgbWV0aG9kLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnRFdmVudFBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXNlcklkXSAtIFRoZSBtZXRhbWV0cmljcyBpZCBmb3IgdGhlIHVzZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYW5vbnltb3VzSWRdIC0gQW4gYW5vbnltb3VzSWQgdGhhdCBpcyB1c2VkIHRvIHRyYWNrXG4gKiAgc2Vuc2l0aXZlIGRhdGEgd2hpbGUgcHJlc2VydmluZyBhbm9ueW1pdHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQgLSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnRpZXMgLSBwcm9wZXJ0aWVzIHRvIGF0dGFjaCB0byB0aGUgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NDb250ZXh0fSBjb250ZXh0IC0gdGhlIGNvbnRleHQgdGhlIGV2ZW50IG9jY3VycmVkIGluXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhTWV0cmljc1BhZ2VQYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYWdlIHRoYXQgd2FzIHZpZXdlZFxuICogQHByb3BlcnR5IHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHZhcmlhZGljIHBhcnRzIG9mIHRoZSBwYWdlIHVybFxuICogIGV4YW1wbGUgKHJvdXRlOiBgL2Fzc2V0Lzphc3NldGAsIHBhdGg6IGAvYXNzZXQvRVRIYClcbiAqICBwYXJhbXM6IHsgYXNzZXQ6ICdFVEgnIH1cbiAqIEBwcm9wZXJ0eSB7RW52aXJvbm1lbnRUeXBlfSBlbnZpcm9ubWVudFR5cGUgLSB0aGUgZW52aXJvbm1lbnQgdHlwZSB0aGF0IHRoZVxuICogIHBhZ2Ugd2FzIHZpZXdlZCBpblxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIHRoZSBkZXRhaWxzIG9mIHRoZSBwYWdlXG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3R9IFtyZWZlcnJlcl0gLSBkYXBwIHRoYXQgdHJpZ2dlcmVkIHRoZSBwYWdlXG4gKiAgdmlld1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NQYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNPcHRJblBhdGhdIC0gaXMgdGhlIGN1cnJlbnQgcGF0aCBvbmUgb2YgdGhlIHBhZ2VzIGluXG4gKiAgdGhlIG9uYm9hcmRpbmcgd29ya2Zsb3c/IElmIHRydWUgYW5kIHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyBpcyBudWxsIHRyYWNrXG4gKiAgdGhlIHBhZ2Ugdmlld1xuICovXG5cbi8vIE1peHBhbmVsIGNvbnZlcnRzIHRoZSB6ZXJvIGFkZHJlc3MgdmFsdWUgdG8gYSB0cnVseSBhbm9ueW1vdXMgZXZlbnQsIHdoaWNoXG4vLyBzcGVlZHMgdXAgcmVwb3J0aW5nXG5leHBvcnQgY29uc3QgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lEID0gJzB4MDAwMDAwMDAwMDAwMDAwMCc7XG5cbi8qKlxuICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBpZGVudGlmeSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IHRoZSBiYWNrZ3JvdW5kXG4gKiBwcm9jZXNzLlxuICpcbiAqIEB0eXBlIHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNUID0ge1xuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG4gIHRpdGxlOiAnQmFja2dyb3VuZCBQcm9jZXNzJyxcbiAgdXJsOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnRJbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7U2VnbWVudEV2ZW50UGF5bG9hZFtdfSBxdWV1ZSAtIEEgcXVldWUgb2YgZXZlbnRzIHRvIGJlIHNlbnQgd2hlblxuICogIHRoZSBmbHVzaEF0IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQsIG9yIGZsdXNoSW50ZXJ2YWwgb2NjdXJzXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGZsdXNoIC0gSW1tZWRpYXRlbHkgZmx1c2ggdGhlIHF1ZXVlLCByZXNldHRpbmcgaXQgdG9cbiAqICBhbiBlbXB0eSBhcnJheSBhbmQgc2VuZGluZyB0aGUgcGVuZGluZyBldmVudHMgdG8gU2VnbWVudFxuICogQHByb3BlcnR5IHsoXG4gKiAgcGF5bG9hZDogU2VnbWVudEV2ZW50UGF5bG9hZCxcbiAqICBjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkXG4gKiApID0+IHZvaWR9IHRyYWNrIC0gVHJhY2sgYW4gZXZlbnQgd2l0aCBTZWdtZW50LCB1c2luZyB0aGUgaW50ZXJuYWwgYmF0Y2hpbmdcbiAqICBtZWNoYW5pc20gdG8gb3B0aW1pemUgbmV0d29yayByZXF1ZXN0c1xuICogQHByb3BlcnR5IHsocGF5bG9hZDogT2JqZWN0KSA9PiB2b2lkfSBwYWdlIC0gVHJhY2sgYSBwYWdlIHZpZXcgd2l0aCBTZWdtZW50XG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGlkZW50aWZ5IC0gSWRlbnRpZnkgYW4gYW5vbnltb3VzIHVzZXIuIFdlIGRvIG5vdFxuICogIGN1cnJlbnRseSB1c2UgdGhpcyBtZXRob2QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHID1cbiAgJ0NhbmNlbCBTaWcgUmVxdWVzdCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcbiIsIi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlyc3RUaW1lU3RhdGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjb25maWcgSW5pdGlhbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBOZXR3b3JrQ29udHJvbGxlciBOZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtGaXJzdFRpbWVTdGF0ZX1cbiAqL1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBjb25maWc6IHt9LFxuICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICBmcmVxdWVudFJwY0xpc3REZXRhaWw6IFtcbiAgICAgIHtcbiAgICAgICAgcnBjVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JyxcbiAgICAgICAgY2hhaW5JZDogJzB4NTM5JyxcbiAgICAgICAgdGlja2VyOiAnRVRIJyxcbiAgICAgICAgbmlja25hbWU6ICdMb2NhbGhvc3QgODU0NScsXG4gICAgICAgIHJwY1ByZWZzOiB7fSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRpYWxTdGF0ZTtcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbi8vIFRoaXMgd2lsbCBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBvYmplY3Rcbi8vIGl0IHJlcGxhY2VzIGFsbCB2YWx1ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZWlyIHR5cGVcblxuLy8ge1xuLy8gICBcImRhdGFcIjoge1xuLy8gICAgIFwiQ3VycmVuY3lDb250cm9sbGVyXCI6IHtcbi8vICAgICAgIFwiY29udmVyc2lvbkRhdGVcIjogXCJudW1iZXJcIixcbi8vICAgICAgIFwiY29udmVyc2lvblJhdGVcIjogXCJudW1iZXJcIixcbi8vICAgICAgIFwiY3VycmVudEN1cnJlbmN5XCI6IFwic3RyaW5nXCJcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIG9iamVjdC4gSXQgcmVwbGFjZXMgYWxsIHZhbHVlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlaXJcbiAqIHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgZm9yIHdoaWNoIGEgJ3N0cnVjdHVyZScgd2lsbCBiZSByZXR1cm5lZC4gVXN1YWxseSBhIHBsYWluIG9iamVjdCBhbmQgbm90IGEgY2xhc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgXCJtYXBwZWRcIiB2ZXJzaW9uIG9mIGEgZGVlcCBjbG9uZSBvZiB0aGUgcGFzc2VkIG9iamVjdCwgd2l0aCBlYWNoIG5vbi1vYmplY3QgcHJvcGVydHkgdmFsdWVcbiAqIHJlcGxhY2VkIHdpdGggdGhlIGphdmFzY3JpcHQgdHlwZSBvZiB0aGF0IHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPYmpTdHJ1Y3R1cmUob2JqKSB7XG4gIGNvbnN0IHN0cnVjdHVyZSA9IGNsb25lRGVlcChvYmopO1xuICByZXR1cm4gZGVlcE1hcChzdHJ1Y3R1cmUsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBkZWVwbHkgbmVzdGVkIG9mIGEgcGFzc2VkIG9iamVjdC4gSXRlcmF0ZXMgcmVjdXJzaXZlbHkgb3ZlciBhbGwgbmVzdGVkIG9iamVjdHMgYW5kXG4gKiB0aGVpciBwcm9wZXJ0aWVzLCBhbmQgY292ZXJzIHRoZSBlbnRpcmUgZGVwdGggb2YgdGhlIG9iamVjdC4gQXQgZWFjaCBwcm9wZXJ0eSB2YWx1ZSB3aGljaCBpcyBub3QgYW4gb2JqZWN0IGlzIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdmlzaXQgLSBUaGUgbW9kaWZpZXIgdG8gYXBwbHkgdG8gZWFjaCBub24tb2JqZWN0IHByb3BlcnR5IHZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGRlZXBNYXAodGFyZ2V0ID0ge30sIHZpc2l0KSB7XG4gIE9iamVjdC5lbnRyaWVzKHRhcmdldCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVlcE1hcCh2YWx1ZSwgdmlzaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZpc2l0KHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwidmFyIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoJylcbiAgLCBkdXBsZXhlciA9IHJlcXVpcmUoJ2R1cGxleGVyJylcbiAgLCBkZWJvdW5jZSA9IHJlcXVpcmUoJ2RlYm91bmNlJylcblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZVN0cmVhbVxuXG5mdW5jdGlvbiBkZWJvdW5jZVN0cmVhbShfbXMsIGltbWVkaWF0ZSkge1xuICB2YXIgbXMgPSBfbXMgfHwgMTAwXG4gICAgLCBpbnB1dCA9IHRocm91Z2goZGVib3VuY2Uod3JpdGUsIG1zLCBpbW1lZGlhdGUpKVxuICAgICwgb3V0cHV0ID0gdGhyb3VnaCgpXG5cbiAgcmV0dXJuIGR1cGxleGVyKGlucHV0LCBvdXRwdXQpXG5cbiAgZnVuY3Rpb24gd3JpdGUoZGF0YSkge1xuICAgIG91dHB1dC5xdWV1ZShkYXRhKVxuICB9XG59XG4iLCJpbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5pbXBvcnQgZ2V0RmV0Y2hXaXRoVGltZW91dCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQnO1xuXG5jb25zdCBmZXRjaFdpdGhUaW1lb3V0ID0gZ2V0RmV0Y2hXaXRoVGltZW91dChTRUNPTkQgKiAzMCk7XG5cbmNvbnN0IEZJWFRVUkVfU0VSVkVSX0hPU1QgPSAnbG9jYWxob3N0JztcbmNvbnN0IEZJWFRVUkVfU0VSVkVSX1BPUlQgPSAxMjM0NTtcbmNvbnN0IEZJWFRVUkVfU0VSVkVSX1VSTCA9IGBodHRwOi8vJHtGSVhUVVJFX1NFUlZFUl9IT1NUfToke0ZJWFRVUkVfU0VSVkVSX1BPUlR9L3N0YXRlLmpzb25gO1xuXG4vKipcbiAqIEEgcmVhZC1vbmx5IG5ldHdvcmstYmFzZWQgc3RvcmFnZSB3cmFwcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWRPbmx5TmV0d29ya1N0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXppbmcgPSB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVjbGFyZXMgdGhpcyBzdG9yZSBhcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgYnJvd3NlclxuICAgKi9cbiAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBieSBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIG5ldHdvcmtcbiAgICovXG4gIGFzeW5jIF9pbml0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoRklYVFVSRV9TRVJWRVJfVVJMKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGBFcnJvciBsb2FkaW5nIG5ldHdvcmsgc3RhdGU6ICcke2Vycm9yLm1lc3NhZ2V9J2ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn1cbiAgICovXG4gIGFzeW5jIGdldCgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLl9pbml0aWFsaXppbmc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHNldChzdGF0ZSkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2luaXRpYWxpemluZztcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdzYWZlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IEV4dGVuc2lvblBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3Jtcy9leHRlbnNpb24nO1xuXG5jb25zdCBOT1RJRklDQVRJT05fSEVJR0hUID0gNjIwO1xuY29uc3QgTk9USUZJQ0FUSU9OX1dJRFRIID0gMzYwO1xuXG5leHBvcnQgY29uc3QgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTID0ge1xuICBQT1BVUF9DTE9TRUQ6ICdvblBvcHVwQ2xvc2VkJyxcbn07XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG1ldGhvZHMgZm9yIGNvbnRyb2xsaW5nIHRoZSBzaG93aW5nIGFuZCBoaWRpbmcgb2YgdGhlIG5vdGlmaWNhdGlvbiBwb3B1cC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm90aWZpY2F0aW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyBFeHRlbnNpb25QbGF0Zm9ybSgpO1xuICAgIHRoaXMucGxhdGZvcm0uYWRkT25SZW1vdmVkTGlzdGVuZXIodGhpcy5fb25XaW5kb3dDbG9zZWQuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGUgbm90aWZpY2F0aW9uIHBvcHVwIGFzIGhhdmluZyBiZWVuIGF1dG9tYXRpY2FsbHkgY2xvc2VkLlxuICAgKlxuICAgKiBUaGlzIGxldHMgdXMgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB3ZSBjbG9zZSB0aGVcbiAgICogbm90aWZpY2F0aW9uIHBvcHVwIHYucy4gd2hlbiB0aGUgdXNlciBjbG9zZXMgdGhlIHBvcHVwIHdpbmRvdyBkaXJlY3RseS5cbiAgICovXG4gIG1hcmtBc0F1dG9tYXRpY2FsbHlDbG9zZWQoKSB7XG4gICAgdGhpcy5fcG9wdXBBdXRvbWF0aWNhbGx5Q2xvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFaXRoZXIgYnJpbmdzIGFuIGV4aXN0aW5nIE1ldGFNYXNrIG5vdGlmaWNhdGlvbiB3aW5kb3cgaW50byBmb2N1cywgb3IgY3JlYXRlcyBhIG5ldyBub3RpZmljYXRpb24gd2luZG93LiBOZXdcbiAgICogbm90aWZpY2F0aW9uIHdpbmRvd3MgYXJlIGdpdmVuIGEgJ3BvcHVwJyB0eXBlLlxuICAgKlxuICAgKi9cbiAgYXN5bmMgc2hvd1BvcHVwKCkge1xuICAgIGNvbnN0IHBvcHVwID0gYXdhaXQgdGhpcy5fZ2V0UG9wdXAoKTtcblxuICAgIC8vIEJyaW5nIGZvY3VzIHRvIGNocm9tZSBwb3B1cFxuICAgIGlmIChwb3B1cCkge1xuICAgICAgLy8gYnJpbmcgZm9jdXMgdG8gZXhpc3RpbmcgY2hyb21lIHBvcHVwXG4gICAgICBhd2FpdCB0aGlzLnBsYXRmb3JtLmZvY3VzV2luZG93KHBvcHVwLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgbGV0IHRvcCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsYXN0Rm9jdXNlZCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0TGFzdEZvY3VzZWRXaW5kb3coKTtcbiAgICAgICAgLy8gUG9zaXRpb24gd2luZG93IGluIHRvcCByaWdodCBjb3JuZXIgb2YgbGFzdEZvY3VzZWQgd2luZG93LlxuICAgICAgICB0b3AgPSBsYXN0Rm9jdXNlZC50b3A7XG4gICAgICAgIGxlZnQgPSBsYXN0Rm9jdXNlZC5sZWZ0ICsgKGxhc3RGb2N1c2VkLndpZHRoIC0gTk9USUZJQ0FUSU9OX1dJRFRIKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBtb3JlIHRoYW4gbGlrZWx5IDAsIGR1ZSB0byBiZWluZ1xuICAgICAgICAvLyBvcGVuZWQgZnJvbSB0aGUgYmFja2dyb3VuZCBjaHJvbWUgcHJvY2VzcyBmb3IgdGhlIGV4dGVuc2lvbiB0aGF0XG4gICAgICAgIC8vIGhhcyBubyBwaHlzaWNhbCBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IHsgc2NyZWVuWCwgc2NyZWVuWSwgb3V0ZXJXaWR0aCB9ID0gd2luZG93O1xuICAgICAgICB0b3AgPSBNYXRoLm1heChzY3JlZW5ZLCAwKTtcbiAgICAgICAgbGVmdCA9IE1hdGgubWF4KHNjcmVlblggKyAob3V0ZXJXaWR0aCAtIE5PVElGSUNBVElPTl9XSURUSCksIDApO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgbmV3IG5vdGlmaWNhdGlvbiBwb3B1cFxuICAgICAgY29uc3QgcG9wdXBXaW5kb3cgPSBhd2FpdCB0aGlzLnBsYXRmb3JtLm9wZW5XaW5kb3coe1xuICAgICAgICB1cmw6ICdub3RpZmljYXRpb24uaHRtbCcsXG4gICAgICAgIHR5cGU6ICdwb3B1cCcsXG4gICAgICAgIHdpZHRoOiBOT1RJRklDQVRJT05fV0lEVEgsXG4gICAgICAgIGhlaWdodDogTk9USUZJQ0FUSU9OX0hFSUdIVCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpcmVmb3ggY3VycmVudGx5IGlnbm9yZXMgbGVmdC90b3AgZm9yIGNyZWF0ZSwgYnV0IGl0IHdvcmtzIGZvciB1cGRhdGVcbiAgICAgIGlmIChwb3B1cFdpbmRvdy5sZWZ0ICE9PSBsZWZ0ICYmIHBvcHVwV2luZG93LnN0YXRlICE9PSAnZnVsbHNjcmVlbicpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wbGF0Zm9ybS51cGRhdGVXaW5kb3dQb3NpdGlvbihwb3B1cFdpbmRvdy5pZCwgbGVmdCwgdG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHVwSWQgPSBwb3B1cFdpbmRvdy5pZDtcbiAgICB9XG4gIH1cblxuICBfb25XaW5kb3dDbG9zZWQod2luZG93SWQpIHtcbiAgICBpZiAod2luZG93SWQgPT09IHRoaXMuX3BvcHVwSWQpIHtcbiAgICAgIHRoaXMuX3BvcHVwSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVtaXQoTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLlBPUFVQX0NMT1NFRCwge1xuICAgICAgICBhdXRvbWF0aWNhbGx5Q2xvc2VkOiB0aGlzLl9wb3B1cEF1dG9tYXRpY2FsbHlDbG9zZWQsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3BvcHVwQXV0b21hdGljYWxseUNsb3NlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGFsbCBvcGVuIE1ldGFNYXNrIHdpbmRvd3MsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBvbmUgaXQgZmluZHMgdGhhdCBpcyBhIG5vdGlmaWNhdGlvbiB3aW5kb3cgKGkuZS4gaGFzIHRoZVxuICAgKiB0eXBlICdwb3B1cCcpXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfZ2V0UG9wdXAoKSB7XG4gICAgY29uc3Qgd2luZG93cyA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0QWxsV2luZG93cygpO1xuICAgIHJldHVybiB0aGlzLl9nZXRQb3B1cEluKHdpbmRvd3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGFycmF5IG9mIHdpbmRvd3MsIHJldHVybnMgdGhlICdwb3B1cCcgdGhhdCBoYXMgYmVlbiBvcGVuZWQgYnkgTWV0YU1hc2ssIG9yIG51bGwgaWYgbm8gc3VjaCB3aW5kb3cgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSB3aW5kb3dzIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGRhdGEgYWJvdXQgdGhlIG9wZW4gTWV0YU1hc2sgZXh0ZW5zaW9uIHdpbmRvd3MuXG4gICAqL1xuICBfZ2V0UG9wdXBJbih3aW5kb3dzKSB7XG4gICAgcmV0dXJuIHdpbmRvd3NcbiAgICAgID8gd2luZG93cy5maW5kKCh3aW4pID0+IHtcbiAgICAgICAgICAvLyBSZXR1cm5zIG5vdGlmaWNhdGlvbiBwb3B1cFxuICAgICAgICAgIHJldHVybiB3aW4gJiYgd2luLnR5cGUgPT09ICdwb3B1cCcgJiYgd2luLmlkID09PSB0aGlzLl9wb3B1cElkO1xuICAgICAgICB9KVxuICAgICAgOiBudWxsO1xuICB9XG59XG4iLCJpbXBvcnQgeyBXcml0YWJsZSBhcyBXcml0YWJsZVN0cmVhbSB9IGZyb20gJ3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgcHJvbWlzZVRvQ2FsbGJhY2sgZnJvbSAncHJvbWlzZS10by1jYWxsYmFjayc7XG5cbmNsYXNzIEFzeW5jV3JpdGFibGVTdHJlYW0gZXh0ZW5kcyBXcml0YWJsZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKGFzeW5jV3JpdGVGbiwgX29wdHMpIHtcbiAgICBjb25zdCBvcHRzID0geyBvYmplY3RNb2RlOiB0cnVlLCAuLi5fb3B0cyB9O1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMuX2FzeW5jV3JpdGVGbiA9IGFzeW5jV3JpdGVGbjtcbiAgfVxuXG4gIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5fYXN5bmNXcml0ZUZuKGNodW5rLCBlbmNvZGluZykpKGNhbGxiYWNrKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1TaW5rKGFzeW5jV3JpdGVGbiwgX29wdHMpIHtcbiAgcmV0dXJuIG5ldyBBc3luY1dyaXRhYmxlU3RyZWFtKGFzeW5jV3JpdGVGbiwgX29wdHMpO1xufVxuIiwiaW1wb3J0IGV4dGVuc2lvbiBmcm9tICdleHRlbnNpb25pemVyJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgY2hlY2tGb3JFcnJvciB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZW5zaW9uJ3Mgc3RvcmFnZSBsb2NhbCBBUElcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZW5zaW9uU3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gQm9vbGVhbihleHRlbnNpb24uc3RvcmFnZS5sb2NhbCk7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICBsb2cuZXJyb3IoJ1N0b3JhZ2UgbG9jYWwgQVBJIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBrZXlzIGN1cnJlbnRseSBzYXZlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICovXG4gIGFzeW5jIGdldCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2dldCgpO1xuICAgIC8vIGV4dGVuc2lvbi5zdG9yYWdlLmxvY2FsIGFsd2F5cyByZXR1cm5zIGFuIG9ialxuICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgZW1wdHksIHRyZWF0IGl0IGFzIHVuZGVmaW5lZFxuICAgIGlmIChpc0VtcHR5KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUga2V5IGluIGxvY2FsIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzZXQoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0KHN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUga2V5cyBjdXJyZW50bHkgc2F2ZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIGtleS12YWx1ZSBtYXAgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAqL1xuICBfZ2V0KCkge1xuICAgIGNvbnN0IHsgbG9jYWwgfSA9IGV4dGVuc2lvbi5zdG9yYWdlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsb2NhbC5nZXQobnVsbCwgKC8qKiBAdHlwZSB7YW55fSAqLyByZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgZXJyID0gY2hlY2tGb3JFcnJvcigpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBrZXkgaW4gbG9jYWwgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBrZXkgdG8gc2V0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldChvYmopIHtcbiAgICBjb25zdCB7IGxvY2FsIH0gPSBleHRlbnNpb24uc3RvcmFnZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9jYWwuc2V0KG9iaiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBjaGVja0ZvckVycm9yKCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnRhaW5zIG5vIGtleXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbiIsImltcG9ydCBleHRlbnNpb24gZnJvbSAnZXh0ZW5zaW9uaXplcic7XG5pbXBvcnQgcHJvbWlzaWZ5IGZyb20gJ3BpZnknO1xuaW1wb3J0IGFsbExvY2FsZXMgZnJvbSAnLi4vLi4vX2xvY2FsZXMvaW5kZXguanNvbic7XG5cbmNvbnN0IGdldFByZWZlcnJlZExvY2FsZXMgPSBleHRlbnNpb24uaTE4blxuICA/IHByb21pc2lmeShleHRlbnNpb24uaTE4bi5nZXRBY2NlcHRMYW5ndWFnZXMsIHsgZXJyb3JGaXJzdDogZmFsc2UgfSlcbiAgOiBhc3luYyAoKSA9PiBbXTtcblxuLy8gbWFwcGluZyBzb21lIGJyb3dzZXJzIHJldHVybiBoeXBoZW4gaW5zdGVhZCB1bmRlcnNjb3JlIGluIGxvY2FsZSBjb2RlcyAoZS5nLiB6aF9UVyAtPiB6aC10dylcbmNvbnN0IGV4aXN0aW5nTG9jYWxlQ29kZXMgPSB7fTtcbmFsbExvY2FsZXMuZm9yRWFjaCgobG9jYWxlKSA9PiB7XG4gIGlmIChsb2NhbGUgJiYgbG9jYWxlLmNvZGUpIHtcbiAgICBleGlzdGluZ0xvY2FsZUNvZGVzW2xvY2FsZS5jb2RlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJyldID1cbiAgICAgIGxvY2FsZS5jb2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZmVycmVkIGxhbmd1YWdlIGNvZGUsIGJhc2VkIG9uIHNldHRpbmdzIHdpdGhpbiB0aGUgdXNlcidzIGJyb3dzZXIuIElmIHdlIGhhdmUgbm8gdHJhbnNsYXRpb25zIGZvciB0aGVcbiAqIHVzZXJzIHByZWZlcnJlZCBsb2NhbGVzLCAnZW4nIGlzIHJldHVybmVkLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFByb21pc2VzIGEgbG9jYWxlIGNvZGUsIGVpdGhlciBvbmUgZnJvbSB0aGUgdXNlcidzIHByZWZlcnJlZCBsaXN0IHRoYXQgd2UgaGF2ZSBhIHRyYW5zbGF0aW9uIGZvciwgb3IgJ2VuJ1xuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBnZXRGaXJzdFByZWZlcnJlZExhbmdDb2RlKCkge1xuICBsZXQgdXNlclByZWZlcnJlZExvY2FsZUNvZGVzO1xuXG4gIHRyeSB7XG4gICAgdXNlclByZWZlcnJlZExvY2FsZUNvZGVzID0gYXdhaXQgZ2V0UHJlZmVycmVkTG9jYWxlcygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQnJhdmUgY3VycmVudGx5IHRocm93cyB3aGVuIGNhbGxpbmcgZ2V0QWNjZXB0TGFuZ3VhZ2VzLCBzbyB0aGlzIGhhbmRsZXMgdGhhdC5cbiAgICB1c2VyUHJlZmVycmVkTG9jYWxlQ29kZXMgPSBbXTtcbiAgfVxuXG4gIC8vIHNhZmVndWFyZCBmb3IgQnJhdmUgQnJvd3NlciB1bnRpbCB0aGV5IGltcGxlbWVudCBjaHJvbWUuaTE4bi5nZXRBY2NlcHRMYW5ndWFnZXNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9pc3N1ZXMvNDI3MFxuICBpZiAoIXVzZXJQcmVmZXJyZWRMb2NhbGVDb2Rlcykge1xuICAgIHVzZXJQcmVmZXJyZWRMb2NhbGVDb2RlcyA9IFtdO1xuICB9XG5cbiAgbGV0IGZpcnN0UHJlZmVycmVkTGFuZ0NvZGUgPSB1c2VyUHJlZmVycmVkTG9jYWxlQ29kZXNcbiAgICAubWFwKChjb2RlKSA9PiBjb2RlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykpXG4gICAgLmZpbmQoXG4gICAgICAoY29kZSkgPT5cbiAgICAgICAgZXhpc3RpbmdMb2NhbGVDb2Rlc1tjb2RlXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGV4aXN0aW5nTG9jYWxlQ29kZXNbY29kZS5zcGxpdCgnLScpWzBdXSAhPT0gdW5kZWZpbmVkLFxuICAgICk7XG5cbiAgLy8gaWYgd2UgaGF2ZSBtYXRjaGVkIGFnYWluc3QgYSBjb2RlIHdpdGggYSAnLScgcHJlc2VudCwgbWVhbmluZyBpdHMgYSByZWdpb25hbFxuICAvLyBjb2RlIGZvciB3aGljaCB3ZSBoYXZlIGEgbm9uLXJlZ2lvbmVkIGxvY2FsZSwgd2UgbmVlZCB0byBzZXQgZmlyc3RQcmVmZXJyZWRMYW5nQ29kZVxuICAvLyB0byB0aGUgY29ycmVjdCBub24tcmVnaW9uYWwgY29kZS5cbiAgaWYgKFxuICAgIGZpcnN0UHJlZmVycmVkTGFuZ0NvZGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIGV4aXN0aW5nTG9jYWxlQ29kZXNbZmlyc3RQcmVmZXJyZWRMYW5nQ29kZV0gPT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBmaXJzdFByZWZlcnJlZExhbmdDb2RlID0gZmlyc3RQcmVmZXJyZWRMYW5nQ29kZS5zcGxpdCgnLScpWzBdO1xuICB9XG5cbiAgcmV0dXJuIGV4aXN0aW5nTG9jYWxlQ29kZXNbZmlyc3RQcmVmZXJyZWRMYW5nQ29kZV0gfHwgJ2VuJztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNTdHJlYW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbXBvc2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0xvY2FsU3RvcmFnZVN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NZXJnZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1pZ3JhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHZlcnNpb24gLSBUaGUgbWlncmF0aW9uIHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG1pZ3JhdGUgLSBSZXR1cm5zIGEgcHJvbWlzZSBvZiB0aGUgbWlncmF0ZWQgZGF0YVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWlncmF0b3JPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PE1pZ3JhdGlvbj59IFttaWdyYXRpb25zXSAtIFRoZSBsaXN0IG9mIG1pZ3JhdGlvbnMgdG8gYXBwbHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVmYXVsdFZlcnNpb25dIC0gVGhlIHZlcnNpb24gdG8gdXNlIGluIHRoZSBpbml0aWFsIHN0YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWlncmF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtNaWdyYXRvck9wdGlvbnN9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgbWlncmF0aW9ucyA9IG9wdHMubWlncmF0aW9ucyB8fCBbXTtcbiAgICAvLyBzb3J0IG1pZ3JhdGlvbnMgYnkgdmVyc2lvblxuICAgIHRoaXMubWlncmF0aW9ucyA9IG1pZ3JhdGlvbnMuc29ydCgoYSwgYikgPT4gYS52ZXJzaW9uIC0gYi52ZXJzaW9uKTtcbiAgICAvLyBncmFiIG1pZ3JhdGlvbiB3aXRoIGhpZ2hlc3QgdmVyc2lvblxuICAgIGNvbnN0IGxhc3RNaWdyYXRpb24gPSB0aGlzLm1pZ3JhdGlvbnMuc2xpY2UoLTEpWzBdO1xuICAgIC8vIHVzZSBzcGVjaWZpZWQgZGVmYXVsdFZlcnNpb24gb3IgaGlnaGVzdCBtaWdyYXRpb24gdmVyc2lvblxuICAgIHRoaXMuZGVmYXVsdFZlcnNpb24gPVxuICAgICAgb3B0cy5kZWZhdWx0VmVyc2lvbiB8fCAobGFzdE1pZ3JhdGlvbiAmJiBsYXN0TWlncmF0aW9uLnZlcnNpb24pIHx8IDA7XG4gIH1cblxuICAvLyBydW4gYWxsIHBlbmRpbmcgbWlncmF0aW9ucyBvbiBtZXRhIGluIHBsYWNlXG4gIGFzeW5jIG1pZ3JhdGVEYXRhKHZlcnNpb25lZERhdGEgPSB0aGlzLmdlbmVyYXRlSW5pdGlhbFN0YXRlKCkpIHtcbiAgICAvLyBnZXQgYWxsIG1pZ3JhdGlvbnMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBydW5cbiAgICBjb25zdCBwZW5kaW5nTWlncmF0aW9ucyA9IHRoaXMubWlncmF0aW9ucy5maWx0ZXIobWlncmF0aW9uSXNQZW5kaW5nKTtcblxuICAgIC8vIHBlcmZvcm0gZWFjaCBtaWdyYXRpb25cbiAgICBmb3IgKGNvbnN0IG1pZ3JhdGlvbiBvZiBwZW5kaW5nTWlncmF0aW9ucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYXR0ZW1wdCBtaWdyYXRpb24gYW5kIHZhbGlkYXRlXG4gICAgICAgIGNvbnN0IG1pZ3JhdGVkRGF0YSA9IGF3YWl0IG1pZ3JhdGlvbi5taWdyYXRlKHZlcnNpb25lZERhdGEpO1xuICAgICAgICBpZiAoIW1pZ3JhdGVkRGF0YS5kYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaWdyYXRvciAtIG1pZ3JhdGlvbiByZXR1cm5lZCBlbXB0eSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1pZ3JhdGVkRGF0YS52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBtaWdyYXRlZERhdGEubWV0YS52ZXJzaW9uICE9PSBtaWdyYXRpb24udmVyc2lvblxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnTWlncmF0b3IgLSBNaWdyYXRpb24gZGlkIG5vdCB1cGRhdGUgdmVyc2lvbiBudW1iZXIgY29ycmVjdGx5JyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFjY2VwdCB0aGUgbWlncmF0aW9uIGFzIGdvb2RcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZlcnNpb25lZERhdGEgPSBtaWdyYXRlZERhdGE7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gcmV3cml0ZSBlcnJvciBtZXNzYWdlIHRvIGFkZCBjb250ZXh0IHdpdGhvdXQgY2xvYmJlcmluZyBzdGFja1xuICAgICAgICBjb25zdCBvcmlnaW5hbEVycm9yTWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICBlcnIubWVzc2FnZSA9IGBNZXRhTWFzayBNaWdyYXRpb24gRXJyb3IgIyR7bWlncmF0aW9uLnZlcnNpb259OiAke29yaWdpbmFsRXJyb3JNZXNzYWdlfWA7XG4gICAgICAgIC8vIGVtaXQgZXJyb3IgaW5zdGVhZCBvZiB0aHJvdyBzbyBhcyB0byBub3QgYnJlYWsgdGhlIHJ1biAoZ3JhY2VmdWxseSBmYWlsKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgLy8gc3RvcCBtaWdyYXRpbmcgYW5kIHVzZSBzdGF0ZSBhcyBpc1xuICAgICAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1pZ3JhdGlvbiBpcyBwZW5kaW5nXG4gICAgICpcbiAgICAgKiBBIG1pZ3JhdGlvbiBpcyBjb25zaWRlcmVkIFwicGVuZGluZ1wiIGlmIGl0IGhhcyBhIGhpZ2hlclxuICAgICAqIHZlcnNpb24gbnVtYmVyIHRoYW4gdGhlIGN1cnJlbnQgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWlncmF0aW9ufSBtaWdyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaWdyYXRpb25Jc1BlbmRpbmcobWlncmF0aW9uKSB7XG4gICAgICByZXR1cm4gbWlncmF0aW9uLnZlcnNpb24gPiB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIG1pZ3JhdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBUaGUgZGF0YSBmb3IgdGhlIGluaXRpYWwgc3RhdGVcbiAgICogQHJldHVybnMge3ttZXRhOiB7dmVyc2lvbjogbnVtYmVyfSwgZGF0YTogYW55fX1cbiAgICovXG4gIGdlbmVyYXRlSW5pdGlhbFN0YXRlKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YToge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLmRlZmF1bHRWZXJzaW9uLFxuICAgICAgfSxcbiAgICAgIGRhdGEsXG4gICAgfTtcbiAgfVxufVxuIiwiLy8gTWlncmF0aW9ucyBtdXN0IHN0YXJ0IGF0IHZlcnNpb24gMSBvciBsYXRlci5cbi8vIFRoZXkgYXJlIG9iamVjdHMgd2l0aCBhIGB2ZXJzaW9uYCBudW1iZXJcbi8vIGFuZCBhIGBtaWdyYXRlYCBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgYG1pZ3JhdGVgIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBwcmV2aW91c1xuLy8gY29uZmlnIGRhdGEgZm9ybWF0LCBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cblxuaW1wb3J0IG0wMDIgZnJvbSAnLi8wMDInO1xuaW1wb3J0IG0wMDMgZnJvbSAnLi8wMDMnO1xuaW1wb3J0IG0wMDQgZnJvbSAnLi8wMDQnO1xuaW1wb3J0IG0wMDUgZnJvbSAnLi8wMDUnO1xuaW1wb3J0IG0wMDYgZnJvbSAnLi8wMDYnO1xuaW1wb3J0IG0wMDcgZnJvbSAnLi8wMDcnO1xuaW1wb3J0IG0wMDggZnJvbSAnLi8wMDgnO1xuaW1wb3J0IG0wMDkgZnJvbSAnLi8wMDknO1xuaW1wb3J0IG0wMTAgZnJvbSAnLi8wMTAnO1xuaW1wb3J0IG0wMTEgZnJvbSAnLi8wMTEnO1xuaW1wb3J0IG0wMTIgZnJvbSAnLi8wMTInO1xuaW1wb3J0IG0wMTMgZnJvbSAnLi8wMTMnO1xuaW1wb3J0IG0wMTQgZnJvbSAnLi8wMTQnO1xuaW1wb3J0IG0wMTUgZnJvbSAnLi8wMTUnO1xuaW1wb3J0IG0wMTYgZnJvbSAnLi8wMTYnO1xuaW1wb3J0IG0wMTcgZnJvbSAnLi8wMTcnO1xuaW1wb3J0IG0wMTggZnJvbSAnLi8wMTgnO1xuaW1wb3J0IG0wMTkgZnJvbSAnLi8wMTknO1xuaW1wb3J0IG0wMjAgZnJvbSAnLi8wMjAnO1xuaW1wb3J0IG0wMjEgZnJvbSAnLi8wMjEnO1xuaW1wb3J0IG0wMjIgZnJvbSAnLi8wMjInO1xuaW1wb3J0IG0wMjMgZnJvbSAnLi8wMjMnO1xuaW1wb3J0IG0wMjQgZnJvbSAnLi8wMjQnO1xuaW1wb3J0IG0wMjUgZnJvbSAnLi8wMjUnO1xuaW1wb3J0IG0wMjYgZnJvbSAnLi8wMjYnO1xuaW1wb3J0IG0wMjcgZnJvbSAnLi8wMjcnO1xuaW1wb3J0IG0wMjggZnJvbSAnLi8wMjgnO1xuaW1wb3J0IG0wMjkgZnJvbSAnLi8wMjknO1xuaW1wb3J0IG0wMzAgZnJvbSAnLi8wMzAnO1xuaW1wb3J0IG0wMzEgZnJvbSAnLi8wMzEnO1xuaW1wb3J0IG0wMzIgZnJvbSAnLi8wMzInO1xuaW1wb3J0IG0wMzMgZnJvbSAnLi8wMzMnO1xuaW1wb3J0IG0wMzQgZnJvbSAnLi8wMzQnO1xuaW1wb3J0IG0wMzUgZnJvbSAnLi8wMzUnO1xuaW1wb3J0IG0wMzYgZnJvbSAnLi8wMzYnO1xuaW1wb3J0IG0wMzcgZnJvbSAnLi8wMzcnO1xuaW1wb3J0IG0wMzggZnJvbSAnLi8wMzgnO1xuaW1wb3J0IG0wMzkgZnJvbSAnLi8wMzknO1xuaW1wb3J0IG0wNDAgZnJvbSAnLi8wNDAnO1xuaW1wb3J0IG0wNDEgZnJvbSAnLi8wNDEnO1xuaW1wb3J0IG0wNDIgZnJvbSAnLi8wNDInO1xuaW1wb3J0IG0wNDMgZnJvbSAnLi8wNDMnO1xuaW1wb3J0IG0wNDQgZnJvbSAnLi8wNDQnO1xuaW1wb3J0IG0wNDUgZnJvbSAnLi8wNDUnO1xuaW1wb3J0IG0wNDYgZnJvbSAnLi8wNDYnO1xuaW1wb3J0IG0wNDcgZnJvbSAnLi8wNDcnO1xuaW1wb3J0IG0wNDggZnJvbSAnLi8wNDgnO1xuaW1wb3J0IG0wNDkgZnJvbSAnLi8wNDknO1xuaW1wb3J0IG0wNTAgZnJvbSAnLi8wNTAnO1xuaW1wb3J0IG0wNTEgZnJvbSAnLi8wNTEnO1xuaW1wb3J0IG0wNTIgZnJvbSAnLi8wNTInO1xuaW1wb3J0IG0wNTMgZnJvbSAnLi8wNTMnO1xuaW1wb3J0IG0wNTQgZnJvbSAnLi8wNTQnO1xuaW1wb3J0IG0wNTUgZnJvbSAnLi8wNTUnO1xuaW1wb3J0IG0wNTYgZnJvbSAnLi8wNTYnO1xuaW1wb3J0IG0wNTcgZnJvbSAnLi8wNTcnO1xuaW1wb3J0IG0wNTggZnJvbSAnLi8wNTgnO1xuaW1wb3J0IG0wNTkgZnJvbSAnLi8wNTknO1xuaW1wb3J0IG0wNjAgZnJvbSAnLi8wNjAnO1xuaW1wb3J0IG0wNjEgZnJvbSAnLi8wNjEnO1xuaW1wb3J0IG0wNjIgZnJvbSAnLi8wNjInO1xuaW1wb3J0IG0wNjMgZnJvbSAnLi8wNjMnO1xuaW1wb3J0IG0wNjQgZnJvbSAnLi8wNjQnO1xuaW1wb3J0IG0wNjUgZnJvbSAnLi8wNjUnO1xuaW1wb3J0IG0wNjYgZnJvbSAnLi8wNjYnO1xuaW1wb3J0IG0wNjcgZnJvbSAnLi8wNjcnO1xuaW1wb3J0IG0wNjggZnJvbSAnLi8wNjgnO1xuaW1wb3J0IG0wNjkgZnJvbSAnLi8wNjknO1xuXG5jb25zdCBtaWdyYXRpb25zID0gW1xuICBtMDAyLFxuICBtMDAzLFxuICBtMDA0LFxuICBtMDA1LFxuICBtMDA2LFxuICBtMDA3LFxuICBtMDA4LFxuICBtMDA5LFxuICBtMDEwLFxuICBtMDExLFxuICBtMDEyLFxuICBtMDEzLFxuICBtMDE0LFxuICBtMDE1LFxuICBtMDE2LFxuICBtMDE3LFxuICBtMDE4LFxuICBtMDE5LFxuICBtMDIwLFxuICBtMDIxLFxuICBtMDIyLFxuICBtMDIzLFxuICBtMDI0LFxuICBtMDI1LFxuICBtMDI2LFxuICBtMDI3LFxuICBtMDI4LFxuICBtMDI5LFxuICBtMDMwLFxuICBtMDMxLFxuICBtMDMyLFxuICBtMDMzLFxuICBtMDM0LFxuICBtMDM1LFxuICBtMDM2LFxuICBtMDM3LFxuICBtMDM4LFxuICBtMDM5LFxuICBtMDQwLFxuICBtMDQxLFxuICBtMDQyLFxuICBtMDQzLFxuICBtMDQ0LFxuICBtMDQ1LFxuICBtMDQ2LFxuICBtMDQ3LFxuICBtMDQ4LFxuICBtMDQ5LFxuICBtMDUwLFxuICBtMDUxLFxuICBtMDUyLFxuICBtMDUzLFxuICBtMDU0LFxuICBtMDU1LFxuICBtMDU2LFxuICBtMDU3LFxuICBtMDU4LFxuICBtMDU5LFxuICBtMDYwLFxuICBtMDYxLFxuICBtMDYyLFxuICBtMDYzLFxuICBtMDY0LFxuICBtMDY1LFxuICBtMDY2LFxuICBtMDY3LFxuICBtMDY4LFxuICBtMDY5LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgbWlncmF0aW9ucztcbiIsImltcG9ydCBiYXNlMzJFbmNvZGUgZnJvbSAnYmFzZTMyLWVuY29kZSc7XG5pbXBvcnQgYmFzZTY0IGZyb20gJ2Jhc2U2NC1qcyc7XG5pbXBvcnQgZXh0ZW5zaW9uIGZyb20gJ2V4dGVuc2lvbml6ZXInO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5pbXBvcnQgcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCBmcm9tICcuL3Jlc29sdmVyJztcblxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoU0VDT05EICogMzApO1xuXG5jb25zdCBzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMgPSBbJ2V0aCddO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEVuc0lwZnNSZXNvbHZlcih7XG4gIHByb3ZpZGVyLFxuICBnZXRDdXJyZW50Q2hhaW5JZCxcbiAgZ2V0SXBmc0dhdGV3YXksXG59KSB7XG4gIC8vIGluc3RhbGwgbGlzdGVuZXJcbiAgY29uc3QgdXJsUGF0dGVybnMgPSBzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMubWFwKCh0bGQpID0+IGAqOi8vKi4ke3RsZH0vKmApO1xuICBleHRlbnNpb24ud2ViUmVxdWVzdC5vbkVycm9yT2NjdXJyZWQuYWRkTGlzdGVuZXIod2ViUmVxdWVzdERpZEZhaWwsIHtcbiAgICB1cmxzOiB1cmxQYXR0ZXJucyxcbiAgICB0eXBlczogWydtYWluX2ZyYW1lJ10sXG4gIH0pO1xuXG4gIC8vIHJldHVybiBhcGkgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgLy8gdW5pbnN0YWxsIGxpc3RlbmVyXG4gICAgcmVtb3ZlKCkge1xuICAgICAgZXh0ZW5zaW9uLndlYlJlcXVlc3Qub25FcnJvck9jY3VycmVkLnJlbW92ZUxpc3RlbmVyKHdlYlJlcXVlc3REaWRGYWlsKTtcbiAgICB9LFxuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHdlYlJlcXVlc3REaWRGYWlsKGRldGFpbHMpIHtcbiAgICBjb25zdCB7IHRhYklkLCB1cmwgfSA9IGRldGFpbHM7XG4gICAgLy8gaWdub3JlIHJlcXVlc3RzIHRoYXQgYXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggdGFic1xuICAgIC8vIG9ubHkgYXR0ZW1wdCBFTlMgcmVzb2x1dGlvbiBvbiBtYWlubmV0XG4gICAgaWYgKHRhYklkID09PSAtMSB8fCBnZXRDdXJyZW50Q2hhaW5JZCgpICE9PSAnMHgxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwYXJzZSBlbnMgbmFtZVxuICAgIGNvbnN0IHsgaG9zdG5hbWU6IG5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2g6IGZyYWdtZW50IH0gPSBuZXcgVVJMKHVybCk7XG4gICAgY29uc3QgZG9tYWluUGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdG9wTGV2ZWxEb21haW4gPSBkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAvLyBpZiB1bnN1cHBvcnRlZCBUTEQsIGFib3J0XG4gICAgaWYgKCFzdXBwb3J0ZWRUb3BMZXZlbERvbWFpbnMuaW5jbHVkZXModG9wTGV2ZWxEb21haW4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBhdHRlbXB0IHJlc29sdmVcbiAgICBhdHRlbXB0UmVzb2x2ZSh7IHRhYklkLCBuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBmcmFnbWVudCB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRSZXNvbHZlKHsgdGFiSWQsIG5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGZyYWdtZW50IH0pIHtcbiAgICBjb25zdCBpcGZzR2F0ZXdheSA9IGdldElwZnNHYXRld2F5KCk7XG5cbiAgICBleHRlbnNpb24udGFicy51cGRhdGUodGFiSWQsIHsgdXJsOiBgbG9hZGluZy5odG1sYCB9KTtcbiAgICBsZXQgdXJsID0gYGh0dHBzOi8vYXBwLmVucy5kb21haW5zL25hbWUvJHtuYW1lfWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgaGFzaCB9ID0gYXdhaXQgcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCh7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBuYW1lLFxuICAgICAgfSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ2lwZnMtbnMnIHx8IHR5cGUgPT09ICdpcG5zLW5zJykge1xuICAgICAgICBjb25zdCByZXNvbHZlZFVybCA9IGBodHRwczovLyR7aGFzaH0uJHt0eXBlLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgNCxcbiAgICAgICAgKX0uJHtpcGZzR2F0ZXdheX0ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBpcGZzIGdhdGV3YXkgaGFzIHJlc3VsdFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChyZXNvbHZlZFVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB1cmwgPSByZXNvbHZlZFVybDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzd2FybS1ucycpIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vc3dhcm0tZ2F0ZXdheXMubmV0L2J6ejovJHtoYXNofSR7cGF0aG5hbWV9JHtcbiAgICAgICAgICBzZWFyY2ggfHwgJydcbiAgICAgICAgfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29uaW9uJyB8fCB0eXBlID09PSAnb25pb24zJykge1xuICAgICAgICB1cmwgPSBgaHR0cDovLyR7aGFzaH0ub25pb24ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3plcm9uZXQnKSB7XG4gICAgICAgIHVybCA9IGBodHRwOi8vMTI3LjAuMC4xOjQzMTEwLyR7aGFzaH0ke3BhdGhuYW1lfSR7c2VhcmNoIHx8ICcnfSR7XG4gICAgICAgICAgZnJhZ21lbnQgfHwgJydcbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdza3luZXQtbnMnKSB7XG4gICAgICAgIGNvbnN0IHBhZGRlZCA9IGhhc2gucGFkRW5kKGhhc2gubGVuZ3RoICsgNCAtIChoYXNoLmxlbmd0aCAlIDQpLCAnPScpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gYmFzZTY0LnRvQnl0ZUFycmF5KHBhZGRlZCk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgcGFkZGluZzogZmFsc2UgfTtcbiAgICAgICAgY29uc3QgYmFzZTMyRW5jb2RlZFNreWxpbmsgPSBiYXNlMzJFbmNvZGUoXG4gICAgICAgICAgZGVjb2RlZCxcbiAgICAgICAgICAnUkZDNDY0OC1IRVgnLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtiYXNlMzJFbmNvZGVkU2t5bGlua30uc2lhc2t5Lm5ldCR7cGF0aG5hbWV9JHtcbiAgICAgICAgICBzZWFyY2ggfHwgJydcbiAgICAgICAgfSR7ZnJhZ21lbnQgfHwgJyd9YDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHRlbnNpb24udGFicy51cGRhdGUodGFiSWQsIHsgdXJsIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHB1bXAgZnJvbSAncHVtcCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IHN0b3JlQXNTdHJlYW0gfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0nO1xuaW1wb3J0IHsgSnNvblJwY0VuZ2luZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgY3JlYXRlRW5naW5lU3RyZWFtIGZyb20gJ2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2VuZ2luZVN0cmVhbSc7XG5pbXBvcnQgY3JlYXRlRmlsdGVyTWlkZGxld2FyZSBmcm9tICdldGgtanNvbi1ycGMtZmlsdGVycyc7XG5pbXBvcnQgY3JlYXRlU3Vic2NyaXB0aW9uTWFuYWdlciBmcm9tICdldGgtanNvbi1ycGMtZmlsdGVycy9zdWJzY3JpcHRpb25NYW5hZ2VyJztcbmltcG9ydCB7IHByb3ZpZGVyQXNNaWRkbGV3YXJlIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IEtleXJpbmdDb250cm9sbGVyIGZyb20gJ2V0aC1rZXlyaW5nLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgZXJyb3JDb2RlcyBhcyBycGNFcnJvckNvZGVzLCBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2F3YWl0LXNlbWFwaG9yZSc7XG5pbXBvcnQgeyBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBUcmV6b3JLZXlyaW5nIGZyb20gJ2V0aC10cmV6b3Ita2V5cmluZyc7XG5pbXBvcnQgTGVkZ2VyQnJpZGdlS2V5cmluZyBmcm9tICdAbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZyc7XG5pbXBvcnQgTGF0dGljZUtleXJpbmcgZnJvbSAnZXRoLWxhdHRpY2Uta2V5cmluZyc7XG5pbXBvcnQgeyBNZXRhTWFza0tleXJpbmcgYXMgUVJIYXJkd2FyZUtleXJpbmcgfSBmcm9tICdAa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZyc7XG5pbXBvcnQgRXRoUXVlcnkgZnJvbSAnZXRoLXF1ZXJ5JztcbmltcG9ydCBuYW5vaWQgZnJvbSAnbmFub2lkJztcbmltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24gfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuaW1wb3J0IHtcbiAgQWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICBBcHByb3ZhbENvbnRyb2xsZXIsXG4gIENvbnRyb2xsZXJNZXNzZW5nZXIsXG4gIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gIFBoaXNoaW5nQ29udHJvbGxlcixcbiAgTm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgR2FzRmVlQ29udHJvbGxlcixcbiAgVG9rZW5MaXN0Q29udHJvbGxlcixcbiAgVG9rZW5zQ29udHJvbGxlcixcbiAgVG9rZW5SYXRlc0NvbnRyb2xsZXIsXG4gIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyLFxufSBmcm9tICdAbWV0YW1hc2svY29udHJvbGxlcnMnO1xuaW1wb3J0IFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlciBmcm9tICdAbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgUGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG59IGZyb20gJ0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzJztcblxuaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fU1RBVFVTRVMsXG4gIFRSQU5TQUNUSU9OX1RZUEVTLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19DTElFTlRfSUQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgTUFJTk5FVF9DSEFJTl9JRCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBERVZJQ0VfTkFNRVMsXG4gIEtFWVJJTkdfVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5pbXBvcnQge1xuICBDYXZlYXRUeXBlcyxcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMnO1xuaW1wb3J0IHsgVUlfTk9USUZJQ0FUSU9OUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IE1JTExJU0VDT05EIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7XG4gIFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMsXG4gIFNVQkpFQ1RfVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuaW1wb3J0IHsgaGV4VG9EZWNpbWFsIH0gZnJvbSAnLi4vLi4vdWkvaGVscGVycy91dGlscy9jb252ZXJzaW9ucy51dGlsJztcbmltcG9ydCB7IGdldFRva2VuVmFsdWVQYXJhbSB9IGZyb20gJy4uLy4uL3VpL2hlbHBlcnMvdXRpbHMvdG9rZW4tdXRpbCc7XG5pbXBvcnQgeyBnZXRUcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuLi8uLi91aS9oZWxwZXJzL3V0aWxzL3RyYW5zYWN0aW9ucy51dGlsJztcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuLi8uLi91aS9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IENvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUgZnJvbSAnLi9saWIvQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSc7XG5pbXBvcnQgQWNjb3VudFRyYWNrZXIgZnJvbSAnLi9saWIvYWNjb3VudC10cmFja2VyJztcbmltcG9ydCBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZUxvZ2dlck1pZGRsZXdhcmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWV0aG9kTWlkZGxld2FyZSxcbn0gZnJvbSAnLi9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVPcmlnaW5NaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZU9yaWdpbk1pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZVRhYklkTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVUYWJJZE1pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZU9uYm9hcmRpbmdNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZU9uYm9hcmRpbmdNaWRkbGV3YXJlJztcbmltcG9ydCB7IHNldHVwTXVsdGlwbGV4IH0gZnJvbSAnLi9saWIvc3RyZWFtLXV0aWxzJztcbmltcG9ydCBFbnNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvZW5zJztcbmltcG9ydCBOZXR3b3JrQ29udHJvbGxlciwgeyBORVRXT1JLX0VWRU5UUyB9IGZyb20gJy4vY29udHJvbGxlcnMvbmV0d29yayc7XG5pbXBvcnQgUHJlZmVyZW5jZXNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvcHJlZmVyZW5jZXMnO1xuaW1wb3J0IEFwcFN0YXRlQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2FwcC1zdGF0ZSc7XG5pbXBvcnQgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvY2FjaGVkLWJhbGFuY2VzJztcbmltcG9ydCBBbGVydENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9hbGVydCc7XG5pbXBvcnQgT25ib2FyZGluZ0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9vbmJvYXJkaW5nJztcbmltcG9ydCBUaHJlZUJveENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy90aHJlZWJveCc7XG5pbXBvcnQgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvaW5jb21pbmctdHJhbnNhY3Rpb25zJztcbmltcG9ydCBNZXNzYWdlTWFuYWdlciwgeyBub3JtYWxpemVNc2dEYXRhIH0gZnJvbSAnLi9saWIvbWVzc2FnZS1tYW5hZ2VyJztcbmltcG9ydCBEZWNyeXB0TWVzc2FnZU1hbmFnZXIgZnJvbSAnLi9saWIvZGVjcnlwdC1tZXNzYWdlLW1hbmFnZXInO1xuaW1wb3J0IEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIGZyb20gJy4vbGliL2VuY3J5cHRpb24tcHVibGljLWtleS1tYW5hZ2VyJztcbmltcG9ydCBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyIGZyb20gJy4vbGliL3BlcnNvbmFsLW1lc3NhZ2UtbWFuYWdlcic7XG5pbXBvcnQgVHlwZWRNZXNzYWdlTWFuYWdlciBmcm9tICcuL2xpYi90eXBlZC1tZXNzYWdlLW1hbmFnZXInO1xuaW1wb3J0IFRyYW5zYWN0aW9uQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgRGV0ZWN0VG9rZW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2RldGVjdC10b2tlbnMnO1xuaW1wb3J0IFN3YXBzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3N3YXBzJztcbmltcG9ydCBhY2NvdW50SW1wb3J0ZXIgZnJvbSAnLi9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzJztcbmltcG9ydCBzZWVkUGhyYXNlVmVyaWZpZXIgZnJvbSAnLi9saWIvc2VlZC1waHJhc2UtdmVyaWZpZXInO1xuaW1wb3J0IE1ldGFNZXRyaWNzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL21ldGFtZXRyaWNzJztcbmltcG9ydCB7IHNlZ21lbnQgfSBmcm9tICcuL2xpYi9zZWdtZW50JztcbmltcG9ydCBjcmVhdGVNZXRhUlBDSGFuZGxlciBmcm9tICcuL2xpYi9jcmVhdGVNZXRhUlBDSGFuZGxlcic7XG5pbXBvcnQge1xuICBDYXZlYXRNdXRhdG9yRmFjdG9yaWVzLFxuICBnZXRDYXZlYXRTcGVjaWZpY2F0aW9ucyxcbiAgZ2V0Q2hhbmdlZEFjY291bnRzLFxuICBnZXRQZXJtaXNzaW9uQmFja2dyb3VuZEFwaU1ldGhvZHMsXG4gIGdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyxcbiAgZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbixcbiAgTk9USUZJQ0FUSU9OX05BTUVTLFxuICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcixcbiAgdW5yZXN0cmljdGVkTWV0aG9kcyxcbn0gZnJvbSAnLi9jb250cm9sbGVycy9wZXJtaXNzaW9ucyc7XG5cbmV4cG9ydCBjb25zdCBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyA9IHtcbiAgLy8gRmlyZWQgYWZ0ZXIgc3RhdGUgY2hhbmdlcyB0aGF0IGltcGFjdCB0aGUgZXh0ZW5zaW9uIGJhZGdlICh1bmFwcHJvdmVkIG1zZyBjb3VudClcbiAgLy8gVGhlIHByb2Nlc3Mgb2YgdXBkYXRpbmcgdGhlIGJhZGdlIGhhcHBlbnMgaW4gYXBwL3NjcmlwdHMvYmFja2dyb3VuZC5qcy5cbiAgVVBEQVRFX0JBREdFOiAndXBkYXRlQmFkZ2UnLFxuICAvLyBUT0RPOiBBZGQgdGhpcyBhbmQgc2ltaWxhciBlbnVtcyB0byBAbWV0YW1hc2svY29udHJvbGxlcnMgYW5kIGV4cG9ydCB0aGVtXG4gIEFQUFJPVkFMX1NUQVRFX0NIQU5HRTogJ0FwcHJvdmFsQ29udHJvbGxlcjpzdGF0ZUNoYW5nZScsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhbWFza0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMjA7XG5cbiAgICB0aGlzLnNlbmRVcGRhdGUgPSBkZWJvdW5jZShcbiAgICAgIHRoaXMucHJpdmF0ZVNlbmRVcGRhdGUuYmluZCh0aGlzKSxcbiAgICAgIE1JTExJU0VDT05EICogMjAwLFxuICAgICk7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmV4dGVuc2lvbiA9IG9wdHMuZXh0ZW5zaW9uO1xuICAgIHRoaXMucGxhdGZvcm0gPSBvcHRzLnBsYXRmb3JtO1xuICAgIHRoaXMubm90aWZpY2F0aW9uTWFuYWdlciA9IG9wdHMubm90aWZpY2F0aW9uTWFuYWdlcjtcbiAgICBjb25zdCBpbml0U3RhdGUgPSBvcHRzLmluaXRTdGF0ZSB8fCB7fTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5wbGF0Zm9ybS5nZXRWZXJzaW9uKCk7XG4gICAgdGhpcy5yZWNvcmRGaXJzdFRpbWVJbmZvKGluaXRTdGF0ZSk7XG5cbiAgICAvLyB0aGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IFwiY29udHJvbGxlclN0cmVhbVwiIGNvbm5lY3Rpb25zIGFyZSBvcGVuXG4gICAgLy8gdGhlIG9ubHkgdGhpbmcgdGhhdCB1c2VzIGNvbnRyb2xsZXIgY29ubmVjdGlvbnMgYXJlIG9wZW4gbWV0YW1hc2sgVUkgaW5zdGFuY2VzXG4gICAgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMgPSAwO1xuXG4gICAgdGhpcy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcyA9IG9wdHMuZ2V0UmVxdWVzdEFjY291bnRUYWJJZHM7XG4gICAgdGhpcy5nZXRPcGVuTWV0YW1hc2tUYWJzSWRzID0gb3B0cy5nZXRPcGVuTWV0YW1hc2tUYWJzSWRzO1xuXG4gICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyID0gbmV3IENvbnRyb2xsZXJNZXNzZW5nZXIoKTtcblxuICAgIC8vIG9ic2VydmFibGUgc3RhdGUgc3RvcmVcbiAgICB0aGlzLnN0b3JlID0gbmV3IENvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgc3RhdGU6IGluaXRTdGF0ZSxcbiAgICAgIGNvbnRyb2xsZXJNZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3NlbmdlcixcbiAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBleHRlcm5hbCBjb25uZWN0aW9ucyBieSBvcmlnaW5cbiAgICAvLyBEbyBub3QgbW9kaWZ5IGRpcmVjdGx5LiBVc2UgdGhlIGFzc29jaWF0ZWQgbWV0aG9kcy5cbiAgICB0aGlzLmNvbm5lY3Rpb25zID0ge307XG5cbiAgICAvLyBsb2NrIHRvIGVuc3VyZSBvbmx5IG9uZSB2YXVsdCBjcmVhdGVkIGF0IG9uY2VcbiAgICB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXggPSBuZXcgTXV0ZXgoKTtcblxuICAgIHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoKGRldGFpbHMpID0+IHtcbiAgICAgIGlmIChkZXRhaWxzLnJlYXNvbiA9PT0gJ3VwZGF0ZScgJiYgdmVyc2lvbiA9PT0gJzguMS4wJykge1xuICAgICAgICB0aGlzLnBsYXRmb3JtLm9wZW5FeHRlbnNpb25JbkJyb3dzZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG5leHQsIHdlIHdpbGwgaW5pdGlhbGl6ZSB0aGUgY29udHJvbGxlcnNcbiAgICAvLyBjb250cm9sbGVyIGluaXRpYWxpemF0aW9uIG9yZGVyIG1hdHRlcnNcblxuICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyID0gbmV3IEFwcHJvdmFsQ29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ0FwcHJvdmFsQ29udHJvbGxlcicsXG4gICAgICB9KSxcbiAgICAgIHNob3dBcHByb3ZhbFJlcXVlc3Q6IG9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24sXG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyID0gbmV3IE5ldHdvcmtDb250cm9sbGVyKGluaXRTdGF0ZS5OZXR3b3JrQ29udHJvbGxlcik7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRJbmZ1cmFQcm9qZWN0SWQob3B0cy5pbmZ1cmFQcm9qZWN0SWQpO1xuXG4gICAgLy8gbm93IHdlIGNhbiBpbml0aWFsaXplIHRoZSBSUEMgcHJvdmlkZXIsIHdoaWNoIG90aGVyIGNvbnRyb2xsZXJzIHJlcXVpcmVcbiAgICB0aGlzLmluaXRpYWxpemVQcm92aWRlcigpO1xuICAgIHRoaXMucHJvdmlkZXIgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkucHJvdmlkZXI7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkuYmxvY2tUcmFja2VyO1xuXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBuZXcgUHJlZmVyZW5jZXNDb250cm9sbGVyKHtcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGluaXRMYW5nQ29kZTogb3B0cy5pbml0TGFuZ0NvZGUsXG4gICAgICBvcGVuUG9wdXA6IG9wdHMub3BlblBvcHVwLFxuICAgICAgbmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgbWlncmF0ZUFkZHJlc3NCb29rU3RhdGU6IHRoaXMubWlncmF0ZUFkZHJlc3NCb29rU3RhdGUuYmluZCh0aGlzKSxcbiAgICB9KTtcblxuICAgIHRoaXMudG9rZW5zQ29udHJvbGxlciA9IG5ldyBUb2tlbnNDb250cm9sbGVyKHtcbiAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgKSxcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgKSxcbiAgICAgIGNvbmZpZzogeyBwcm92aWRlcjogdGhpcy5wcm92aWRlciB9LFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5Ub2tlbnNDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIgPSBuZXcgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyID0gbmV3IENvbGxlY3RpYmxlc0NvbnRyb2xsZXIoXG4gICAgICB7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICksXG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICksXG4gICAgICAgIGdldEVSQzcyMUFzc2V0TmFtZTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxQXNzZXROYW1lLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGdldEVSQzcyMUFzc2V0U3ltYm9sOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkM3MjFBc3NldFN5bWJvbC5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRFUkM3MjFUb2tlblVSSTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxVG9rZW5VUkkuYmluZChcbiAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0RVJDNzIxT3duZXJPZjogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxT3duZXJPZi5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRFUkMxMTU1QmFsYW5jZU9mOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkMxMTU1QmFsYW5jZU9mLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGdldEVSQzExNTVUb2tlblVSSTogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDMTE1NVRva2VuVVJJLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAge30sXG4gICAgICBpbml0U3RhdGUuQ29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLnNldEFwaUtleShwcm9jZXNzLmVudi5PUEVOU0VBX0tFWSk7XG5cbiAgICBwcm9jZXNzLmVudi5DT0xMRUNUSUJMRVNfVjEgJiZcbiAgICAgICh0aGlzLmNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlciA9IG5ldyBDb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBvbkNvbGxlY3RpYmxlc1N0YXRlQ2hhbmdlOiAobGlzdGVuZXIpID0+XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuc3Vic2NyaWJlKGxpc3RlbmVyKSxcbiAgICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBnZXRPcGVuU2VhQXBpS2V5OiAoKSA9PiB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIub3BlblNlYUFwaUtleSxcbiAgICAgICAgICBnZXRCYWxhbmNlc0luU2luZ2xlQ2FsbDogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwuYmluZChcbiAgICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgICAgYWRkQ29sbGVjdGlibGU6IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5hZGRDb2xsZWN0aWJsZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgICAgZ2V0Q29sbGVjdGlibGVzU3RhdGU6ICgpID0+IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5zdGF0ZSxcbiAgICAgICAgfSxcbiAgICAgICkpO1xuXG4gICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIgPSBuZXcgTWV0YU1ldHJpY3NDb250cm9sbGVyKHtcbiAgICAgIHNlZ21lbnQsXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIG9uTmV0d29ya0RpZENoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbi5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICBORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsXG4gICAgICApLFxuICAgICAgZ2V0TmV0d29ya0lkZW50aWZpZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0TmV0d29ya0lkZW50aWZpZXIuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHZlcnNpb246IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpLFxuICAgICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0VOVklST05NRU5ULFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgY2FwdHVyZUV4Y2VwdGlvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IGdhc0ZlZU1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgIG5hbWU6ICdHYXNGZWVDb250cm9sbGVyJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGdhc0FwaUJhc2VVcmwgPSBwcm9jZXNzLmVudi5TV0FQU19VU0VfREVWX0FQSVNcbiAgICAgID8gR0FTX0RFVl9BUElfQkFTRV9VUkxcbiAgICAgIDogR0FTX0FQSV9CQVNFX1VSTDtcblxuICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlciA9IG5ldyBHYXNGZWVDb250cm9sbGVyKHtcbiAgICAgIGludGVydmFsOiAxMDAwMCxcbiAgICAgIG1lc3NlbmdlcjogZ2FzRmVlTWVzc2VuZ2VyLFxuICAgICAgY2xpZW50SWQ6IFNXQVBTX0NMSUVOVF9JRCxcbiAgICAgIGdldFByb3ZpZGVyOiAoKSA9PlxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkucHJvdmlkZXIsXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbi5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICBORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHk6IHRoaXMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICB0aGlzLFxuICAgICAgKSxcbiAgICAgIGxlZ2FjeUFQSUVuZHBvaW50OiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy88Y2hhaW5faWQ+L2dhc1ByaWNlc2AsXG4gICAgICBFSVAxNTU5QVBJRW5kcG9pbnQ6IGAke2dhc0FwaUJhc2VVcmx9L25ldHdvcmtzLzxjaGFpbl9pZD4vc3VnZ2VzdGVkR2FzRmVlc2AsXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHk6ICgpID0+IHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LklOX1RFU1QgfHwgY2hhaW5JZCA9PT0gTUFJTk5FVF9DSEFJTl9JRDtcbiAgICAgIH0sXG4gICAgICBnZXRDaGFpbklkOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5JTl9URVNUXG4gICAgICAgICAgPyBNQUlOTkVUX0NIQUlOX0lEXG4gICAgICAgICAgOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5xckhhcmR3YXJlS2V5cmluZyA9IG5ldyBRUkhhcmR3YXJlS2V5cmluZygpO1xuXG4gICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIgPSBuZXcgQXBwU3RhdGVDb250cm9sbGVyKHtcbiAgICAgIGFkZFVubG9ja0xpc3RlbmVyOiB0aGlzLm9uLmJpbmQodGhpcywgJ3VubG9jaycpLFxuICAgICAgaXNVbmxvY2tlZDogdGhpcy5pc1VubG9ja2VkLmJpbmQodGhpcyksXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICBvbkluYWN0aXZlVGltZW91dDogKCkgPT4gdGhpcy5zZXRMb2NrZWQoKSxcbiAgICAgIHNob3dVbmxvY2tSZXF1ZXN0OiBvcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBxckhhcmR3YXJlU3RvcmU6IHRoaXMucXJIYXJkd2FyZUtleXJpbmcuZ2V0TWVtU3RvcmUoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGN1cnJlbmN5UmF0ZU1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgIG5hbWU6ICdDdXJyZW5jeVJhdGVDb250cm9sbGVyJyxcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgPSBuZXcgQ3VycmVuY3lSYXRlQ29udHJvbGxlcih7XG4gICAgICBpbmNsdWRlVVNEUmF0ZTogdHJ1ZSxcbiAgICAgIG1lc3NlbmdlcjogY3VycmVuY3lSYXRlTWVzc2VuZ2VyLFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5DdXJyZW5jeUNvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbkxpc3RNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnVG9rZW5MaXN0Q29udHJvbGxlcicsXG4gICAgfSk7XG4gICAgdGhpcy50b2tlbkxpc3RDb250cm9sbGVyID0gbmV3IFRva2VuTGlzdENvbnRyb2xsZXIoe1xuICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQoKSksXG4gICAgICB1c2VTdGF0aWNUb2tlbkxpc3Q6ICF0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpXG4gICAgICAgIC51c2VUb2tlbkRldGVjdGlvbixcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAoY2IpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChuZXR3b3JrU3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlcixcbiAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKG5ldHdvcmtTdGF0ZS5wcm92aWRlci5jaGFpbklkKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWROZXR3b3JrU3RhdGUpO1xuICAgICAgICB9KSxcbiAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTogKGNiKSA9PlxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKHByZWZlcmVuY2VzU3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllZFByZWZlcmVuY2VzU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5wcmVmZXJlbmNlc1N0YXRlLFxuICAgICAgICAgICAgdXNlU3RhdGljVG9rZW5MaXN0OiAhdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAudXNlVG9rZW5EZXRlY3Rpb24sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWRQcmVmZXJlbmNlc1N0YXRlKTtcbiAgICAgICAgfSksXG4gICAgICBtZXNzZW5nZXI6IHRva2VuTGlzdE1lc3NlbmdlcixcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMucGhpc2hpbmdDb250cm9sbGVyID0gbmV3IFBoaXNoaW5nQ29udHJvbGxlcigpO1xuXG4gICAgdGhpcy5ub3RpZmljYXRpb25Db250cm9sbGVyID0gbmV3IE5vdGlmaWNhdGlvbkNvbnRyb2xsZXIoXG4gICAgICB7IGFsbE5vdGlmaWNhdGlvbnM6IFVJX05PVElGSUNBVElPTlMgfSxcbiAgICAgIGluaXRTdGF0ZS5Ob3RpZmljYXRpb25Db250cm9sbGVyLFxuICAgICk7XG5cbiAgICAvLyB0b2tlbiBleGNoYW5nZSByYXRlIHRyYWNrZXJcbiAgICB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyID0gbmV3IFRva2VuUmF0ZXNDb250cm9sbGVyKHtcbiAgICAgIG9uVG9rZW5zU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT5cbiAgICAgICAgdGhpcy50b2tlbnNDb250cm9sbGVyLnN1YnNjcmliZShsaXN0ZW5lciksXG4gICAgICBvbkN1cnJlbmN5UmF0ZVN0YXRlQ2hhbmdlOiAobGlzdGVuZXIpID0+XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgICAgICAgYCR7dGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLm5hbWV9OnN0YXRlQ2hhbmdlYCxcbiAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgKSxcbiAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlOiAoY2IpID0+XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChuZXR3b3JrU3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlcixcbiAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKG5ldHdvcmtTdGF0ZS5wcm92aWRlci5jaGFpbklkKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWROZXR3b3JrU3RhdGUpO1xuICAgICAgICB9KSxcbiAgICB9KTtcblxuICAgIHRoaXMuZW5zQ29udHJvbGxlciA9IG5ldyBFbnNDb250cm9sbGVyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBvbk5ldHdvcmtEaWRDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24uYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyID0gbmV3IEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcih7XG4gICAgICBibG9ja1RyYWNrZXI6IHRoaXMuYmxvY2tUcmFja2VyLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgIE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSxcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICAvLyBhY2NvdW50IHRyYWNrZXIgd2F0Y2hlcyBiYWxhbmNlcywgbm9uY2VzLCBhbmQgYW55IGNvZGUgYXQgdGhlaXIgYWRkcmVzc1xuICAgIHRoaXMuYWNjb3VudFRyYWNrZXIgPSBuZXcgQWNjb3VudFRyYWNrZXIoe1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBibG9ja1RyYWNrZXI6IHRoaXMuYmxvY2tUcmFja2VyLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICAvLyBzdGFydCBhbmQgc3RvcCBwb2xsaW5nIGZvciBiYWxhbmNlcyBiYXNlZCBvbiBhY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnNcbiAgICB0aGlzLm9uKCdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLCAoYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zKSA9PiB7XG4gICAgICBpZiAoYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zdGFydCgpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0Q29udHJvbGxlci5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlciA9IG5ldyBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIoe1xuICAgICAgYWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkNhY2hlZEJhbGFuY2VzQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIgPSBuZXcgT25ib2FyZGluZ0NvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuaHViLm9uKCdwZW5kaW5nU3VnZ2VzdGVkQXNzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBvcHRzLm9wZW5Qb3B1cCgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYWRkaXRpb25hbEtleXJpbmdzID0gW1xuICAgICAgVHJlem9yS2V5cmluZyxcbiAgICAgIExlZGdlckJyaWRnZUtleXJpbmcsXG4gICAgICBMYXR0aWNlS2V5cmluZyxcbiAgICAgIFFSSGFyZHdhcmVLZXlyaW5nLFxuICAgIF07XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlciA9IG5ldyBLZXlyaW5nQ29udHJvbGxlcih7XG4gICAgICBrZXlyaW5nVHlwZXM6IGFkZGl0aW9uYWxLZXlyaW5ncyxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLktleXJpbmdDb250cm9sbGVyLFxuICAgICAgZW5jcnlwdG9yOiBvcHRzLmVuY3J5cHRvciB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5zdWJzY3JpYmUoKHN0YXRlKSA9PlxuICAgICAgdGhpcy5fb25LZXlyaW5nQ29udHJvbGxlclVwZGF0ZShzdGF0ZSksXG4gICAgKTtcbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm9uKCd1bmxvY2snLCAoKSA9PiB0aGlzLl9vblVubG9jaygpKTtcbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm9uKCdsb2NrJywgKCkgPT4gdGhpcy5fb25Mb2NrKCkpO1xuXG4gICAgY29uc3QgZ2V0SWRlbnRpdGllcyA9ICgpID0+XG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLmlkZW50aXRpZXM7XG5cbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyID0gbmV3IFBlcm1pc3Npb25Db250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnUGVybWlzc2lvbkNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9Omhhc1JlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgY2F2ZWF0U3BlY2lmaWNhdGlvbnM6IGdldENhdmVhdFNwZWNpZmljYXRpb25zKHsgZ2V0SWRlbnRpdGllcyB9KSxcbiAgICAgIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9uczoge1xuICAgICAgICAuLi5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMoe1xuICAgICAgICAgIGdldElkZW50aXRpZXMsXG4gICAgICAgICAgZ2V0QWxsQWNjb3VudHM6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMuYmluZChcbiAgICAgICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzOiAoXG4gICAgICAgICAgICBpZGVudGl0aWVzID0ge30sXG4gICAgICAgICAgICBhY2NvdW50cyA9IFtdLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHNNaXNzaW5nSWRlbnRpdGllcyA9IGFjY291bnRzLmZpbHRlcihcbiAgICAgICAgICAgICAgKGFkZHJlc3MpID0+ICFpZGVudGl0aWVzW2FkZHJlc3NdLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllcyA9IGFjY291bnRzTWlzc2luZ0lkZW50aXRpZXMubWFwKFxuICAgICAgICAgICAgICAoYWRkcmVzcykgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpPy50eXBlLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgaWRlbnRpdGllc0NvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcyB8fCB7fSkubGVuZ3RoO1xuXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50VHJhY2tlckNvdW50ID0gT2JqZWN0LmtleXMoXG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50cyB8fCB7fSxcbiAgICAgICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgICAgICBjYXB0dXJlRXhjZXB0aW9uKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEF0dGVtcHQgdG8gZ2V0IHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbnMgZmFpbGVkIGJlY2F1c2UgdGhlaXIgd2VyZSAke2FjY291bnRzLmxlbmd0aH0gYWNjb3VudHMsIGJ1dCAke2lkZW50aXRpZXNDb3VudH0gaWRlbnRpdGllcywgYW5kIHRoZSAke2tleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllc30ga2V5cmluZ3MgaW5jbHVkZWQgYWNjb3VudHMgd2l0aCBtaXNzaW5nIGlkZW50aXRpZXMuIE1lYW53aGlsZSwgdGhlcmUgYXJlICR7YWNjb3VudFRyYWNrZXJDb3VudH0gYWNjb3VudHMgaW4gdGhlIGFjY291bnQgdHJhY2tlci5gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgICB1bnJlc3RyaWN0ZWRNZXRob2RzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcih7XG4gICAgICByZXN0cmljdGVkTWV0aG9kczogbmV3IFNldChPYmplY3Qua2V5cyhSZXN0cmljdGVkTWV0aG9kcykpLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ1N1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW2Ake3RoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIubmFtZX06aGFzUGVybWlzc2lvbnNgXSxcbiAgICAgIH0pLFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgc3ViamVjdENhY2hlTGltaXQ6IDEwMCxcbiAgICB9KTtcblxuXG4gICAgdGhpcy5kZXRlY3RUb2tlbnNDb250cm9sbGVyID0gbmV3IERldGVjdFRva2Vuc0NvbnRyb2xsZXIoe1xuICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgdG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgbmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIGtleXJpbmdNZW1TdG9yZTogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgIHRva2VuTGlzdDogdGhpcy50b2tlbkxpc3RDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBuZXcgQWRkcmVzc0Jvb2tDb250cm9sbGVyKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgaW5pdFN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgdGhpcy5hbGVydENvbnRyb2xsZXIgPSBuZXcgQWxlcnRDb250cm9sbGVyKHtcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkFsZXJ0Q29udHJvbGxlcixcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgIH0pO1xuXG4gICAgdGhpcy50aHJlZUJveENvbnRyb2xsZXIgPSBuZXcgVGhyZWVCb3hDb250cm9sbGVyKHtcbiAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXI6IHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICAga2V5cmluZ0NvbnRyb2xsZXI6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5UaHJlZUJveENvbnRyb2xsZXIsXG4gICAgICBnZXRLZXlyaW5nQ29udHJvbGxlclN0YXRlOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLmdldFN0YXRlLmJpbmQoXG4gICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUsXG4gICAgICApLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLnR4Q29udHJvbGxlciA9IG5ldyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOlxuICAgICAgICBpbml0U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyIHx8IGluaXRTdGF0ZS5UcmFuc2FjdGlvbk1hbmFnZXIsXG4gICAgICBnZXRQZXJtaXR0ZWRBY2NvdW50czogdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cy5iaW5kKHRoaXMpLFxuICAgICAgZ2V0UHJvdmlkZXJDb25maWc6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJDb25maWcuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5OiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5LmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTogdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5LmJpbmQoXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuICAgICAgbmV0d29ya1N0b3JlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtTdG9yZSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICB0eEhpc3RvcnlMaW1pdDogNjAsXG4gICAgICBzaWduVHJhbnNhY3Rpb246IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2lnblRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBibG9ja1RyYWNrZXI6IHRoaXMuYmxvY2tUcmFja2VyLFxuICAgICAgY3JlYXRlRXZlbnRGcmFnbWVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuY3JlYXRlRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB1cGRhdGVFdmVudEZyYWdtZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci51cGRhdGVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGZpbmFsaXplRXZlbnRGcmFnbWVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuZmluYWxpemVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldEV2ZW50RnJhZ21lbnRCeUlkOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5nZXRFdmVudEZyYWdtZW50QnlJZC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0UGFydGljaXBhdGVJbk1ldHJpY3M6ICgpID0+XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0YXRlLnBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyxcbiAgICAgIGdldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXM6IHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKFxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0RXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zOiB0aGlzLmdldEV4dGVybmFsUGVuZGluZ1RyYW5zYWN0aW9ucy5iaW5kKFxuICAgICAgICB0aGlzLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICB0aGlzLnR4Q29udHJvbGxlci5vbignbmV3VW5hcHByb3ZlZFR4JywgKCkgPT4gb3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpKTtcblxuICAgIHRoaXMudHhDb250cm9sbGVyLm9uKGB0eDpzdGF0dXMtdXBkYXRlYCwgYXN5bmMgKHR4SWQsIHN0YXR1cykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRCB8fFxuICAgICAgICBzdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgICAgICBjb25zdCBmcmVxdWVudFJwY0xpc3REZXRhaWwgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRGcmVxdWVudFJwY0xpc3REZXRhaWwoKTtcbiAgICAgICAgbGV0IHJwY1ByZWZzID0ge307XG4gICAgICAgIGlmICh0eE1ldGEuY2hhaW5JZCkge1xuICAgICAgICAgIGNvbnN0IHJwY1NldHRpbmdzID0gZnJlcXVlbnRScGNMaXN0RGV0YWlsLmZpbmQoXG4gICAgICAgICAgICAocnBjKSA9PiB0eE1ldGEuY2hhaW5JZCA9PT0gcnBjLmNoYWluSWQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBycGNQcmVmcyA9IHJwY1NldHRpbmdzPy5ycGNQcmVmcyA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXRmb3JtLnNob3dUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbih0eE1ldGEsIHJwY1ByZWZzKTtcblxuICAgICAgICBjb25zdCB7IHR4UmVjZWlwdCB9ID0gdHhNZXRhO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2ZlckZyb20gbWV0aG9kIGdlbmVyYXRlZCBmcm9tIHdpdGhpbiB0aGUgYXBwIGl0IG1heSBiZSBhIGNvbGxlY3RpYmxlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCB3YW50IHRvIGNoZWNrIGFuZCB1cGRhdGUgb3duZXJzaGlwIHN0YXR1cyBvZiB0aGUgdHJhbnNmZXJyZWQgY29sbGVjdGlibGUuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eE1ldGEudHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00gJiZcbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMgIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgdG86IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGZyb206IHVzZXJBZGRyZXNzLFxuICAgICAgICAgIH0gPSB0eE1ldGEudHhQYXJhbXM7XG4gICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0eE1ldGE7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0gZ2V0VHJhbnNhY3Rpb25EYXRhKGRhdGEpO1xuICAgICAgICAgIGNvbnN0IHRva2VuQW1vdW50T3JUb2tlbklkID0gZ2V0VG9rZW5WYWx1ZVBhcmFtKHRyYW5zYWN0aW9uRGF0YSk7XG4gICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5zdGF0ZTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGl0cyBhIGtub3duIGNvbGxlY3RpYmxlXG4gICAgICAgICAgY29uc3Qga25vd25Db2xsZWN0aWJsZSA9IGFsbENvbGxlY3RpYmxlcz8uW3VzZXJBZGRyZXNzXT8uW1xuICAgICAgICAgICAgY2hhaW5JZFxuICAgICAgICAgIF0uZmluZChcbiAgICAgICAgICAgICh7IGFkZHJlc3MsIHRva2VuSWQgfSkgPT5cbiAgICAgICAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShhZGRyZXNzLCBjb250cmFjdEFkZHJlc3MpICYmXG4gICAgICAgICAgICAgIHRva2VuSWQgPT09IHRva2VuQW1vdW50T3JUb2tlbklkLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBpZiBpdCBpcyB3ZSBjaGVjayBhbmQgdXBkYXRlIG93bmVyc2hpcCBzdGF0dXMuXG4gICAgICAgICAgaWYgKGtub3duQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5jaGVja0FuZFVwZGF0ZVNpbmdsZUNvbGxlY3RpYmxlT3duZXJzaGlwU3RhdHVzKFxuICAgICAgICAgICAgICBrbm93bkNvbGxlY3RpYmxlLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgeyB1c2VyQWRkcmVzcywgY2hhaW5JZCB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXRhbWFza1N0YXRlID0gYXdhaXQgdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIGlmICh0eFJlY2VpcHQgJiYgdHhSZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBldmVudDogJ1R4IFN0YXR1cyBVcGRhdGU6IE9uLUNoYWluIEZhaWx1cmUnLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogJ0JhY2tncm91bmQnLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnVHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHR4TWV0YS5zaW11bGF0aW9uRmFpbHM/LnJlYXNvbixcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRva2VuczogbWV0YW1hc2tTdGF0ZS50b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG51bWJlck9mQWNjb3VudHM6IE9iamVjdC5rZXlzKG1ldGFtYXNrU3RhdGUuYWNjb3VudHMpLmxlbmd0aCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdG9tb0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB0aWNrZXIgfSA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJDb25maWcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlci5zZXROYXRpdmVDdXJyZW5jeSh0aWNrZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGZhaWx1cmUgdG8gZ2V0IGNvbnZlcnNpb24gcmF0ZSBtb3JlIGdyYWNlZnVsbHlcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB0aGlzLm1lc3NhZ2VNYW5hZ2VyID0gbmV3IE1lc3NhZ2VNYW5hZ2VyKHtcbiAgICAgIG1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG4gICAgdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gbmV3IFBlcnNvbmFsTWVzc2FnZU1hbmFnZXIoe1xuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlciA9IG5ldyBEZWNyeXB0TWVzc2FnZU1hbmFnZXIoe1xuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcbiAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyID0gbmV3IEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyKHtcbiAgICAgIG1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG4gICAgdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyID0gbmV3IFR5cGVkTWVzc2FnZU1hbmFnZXIoe1xuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5zd2Fwc0NvbnRyb2xsZXIgPSBuZXcgU3dhcHNDb250cm9sbGVyKHtcbiAgICAgIGdldEJ1ZmZlcmVkR2FzTGltaXQ6IHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbC5nZXRCdWZmZXJlZEdhc0xpbWl0LmJpbmQoXG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbCxcbiAgICAgICksXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcjogdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgZ2V0UHJvdmlkZXJDb25maWc6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJDb25maWcuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRUb2tlblJhdGVzU3RhdGU6ICgpID0+IHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIuc3RhdGUsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXM6IHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKFxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyID0gbmV3IFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcihcbiAgICAgIHtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0TmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXROZXR3b3JrU3RhdGUuYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXROb25jZUxvY2s6IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2suYmluZChcbiAgICAgICAgICB0aGlzLnR4Q29udHJvbGxlci5ub25jZVRyYWNrZXIsXG4gICAgICAgICksXG4gICAgICAgIGNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uOiB0aGlzLnR4Q29udHJvbGxlci5jb25maXJtRXh0ZXJuYWxUcmFuc2FjdGlvbi5iaW5kKFxuICAgICAgICAgIHRoaXMudHhDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgaW5pdFN0YXRlLlNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgLy8gZW5zdXJlIGFjY291bnRUcmFja2VyIHVwZGF0ZXMgYmFsYW5jZXMgYWZ0ZXIgbmV0d29yayBjaGFuZ2VcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSwgKCkgPT4ge1xuICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5fdXBkYXRlQWNjb3VudHMoKTtcbiAgICB9KTtcblxuICAgIC8vIGNsZWFyIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIGFuZCBtZXNzYWdlcyB3aGVuIHRoZSBuZXR3b3JrIHdpbGwgY2hhbmdlXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbihORVRXT1JLX0VWRU5UUy5ORVRXT1JLX1dJTExfQ0hBTkdFLCAoKSA9PiB7XG4gICAgICB0aGlzLnR4Q29udHJvbGxlci50eFN0YXRlTWFuYWdlci5jbGVhclVuYXBwcm92ZWRUeHMoKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgICB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgICB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMubWVzc2FnZU1hbmFnZXIuY2xlYXJVbmFwcHJvdmVkKCk7XG4gICAgfSk7XG5cbiAgICAvLyBlbnN1cmUgaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgaXMgdXBkYXRlZCB3aGVuIG1lbVN0YXRlIHVwZGF0ZXNcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCAobWVtU3RhdGUpID0+IHRoaXMuX29uU3RhdGVVcGRhdGUobWVtU3RhdGUpKTtcblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RydWN0dXJlKHtcbiAgICAgIEFwcFN0YXRlQ29udHJvbGxlcjogdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBUcmFuc2FjdGlvbkNvbnRyb2xsZXI6IHRoaXMudHhDb250cm9sbGVyLnN0b3JlLFxuICAgICAgS2V5cmluZ0NvbnRyb2xsZXI6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgTWV0YU1ldHJpY3NDb250cm9sbGVyOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEFkZHJlc3NCb29rQ29udHJvbGxlcjogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICBDdXJyZW5jeUNvbnRyb2xsZXI6IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlcixcbiAgICAgIE5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyOiB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEFsZXJ0Q29udHJvbGxlcjogdGhpcy5hbGVydENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBPbmJvYXJkaW5nQ29udHJvbGxlcjogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcjogdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLnN0b3JlLFxuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgVGhyZWVCb3hDb250cm9sbGVyOiB0aGlzLnRocmVlQm94Q29udHJvbGxlci5zdG9yZSxcbiAgICAgIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXI6IHRoaXMubm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICAgIEdhc0ZlZUNvbnRyb2xsZXI6IHRoaXMuZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgIFRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICAgIFRva2Vuc0NvbnRyb2xsZXI6IHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgIFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcjogdGhpcy5zbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICBDb2xsZWN0aWJsZXNDb250cm9sbGVyOiB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IENvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIEFwcFN0YXRlQ29udHJvbGxlcjogdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIE5ldHdvcmtDb250cm9sbGVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBBY2NvdW50VHJhY2tlcjogdGhpcy5hY2NvdW50VHJhY2tlci5zdG9yZSxcbiAgICAgICAgVHhDb250cm9sbGVyOiB0aGlzLnR4Q29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgICAgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyOiB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgVG9rZW5SYXRlc0NvbnRyb2xsZXI6IHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIsXG4gICAgICAgIE1lc3NhZ2VNYW5hZ2VyOiB0aGlzLm1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyOiB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIubWVtU3RvcmUsXG4gICAgICAgIERlY3J5cHRNZXNzYWdlTWFuYWdlcjogdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIubWVtU3RvcmUsXG4gICAgICAgIEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyOiB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBUeXBlc01lc3NhZ2VNYW5hZ2VyOiB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXIubWVtU3RvcmUsXG4gICAgICAgIEtleXJpbmdDb250cm9sbGVyOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLFxuICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBNZXRhTWV0cmljc0NvbnRyb2xsZXI6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBBZGRyZXNzQm9va0NvbnRyb2xsZXI6IHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICAgICBDdXJyZW5jeUNvbnRyb2xsZXI6IHRoaXMuY3VycmVuY3lSYXRlQ29udHJvbGxlcixcbiAgICAgICAgQWxlcnRDb250cm9sbGVyOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgT25ib2FyZGluZ0NvbnRyb2xsZXI6IHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcjogdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICAgICAgICAuc3RvcmUsXG4gICAgICAgIFBlcm1pc3Npb25Db250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgICBUaHJlZUJveENvbnRyb2xsZXI6IHRoaXMudGhyZWVCb3hDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBTd2Fwc0NvbnRyb2xsZXI6IHRoaXMuc3dhcHNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBFbnNDb250cm9sbGVyOiB0aGlzLmVuc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIEFwcHJvdmFsQ29udHJvbGxlcjogdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIsXG4gICAgICAgIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXI6IHRoaXMubm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICAgICAgR2FzRmVlQ29udHJvbGxlcjogdGhpcy5nYXNGZWVDb250cm9sbGVyLFxuICAgICAgICBUb2tlbkxpc3RDb250cm9sbGVyOiB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgICAgIFRva2Vuc0NvbnRyb2xsZXI6IHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgICAgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgICAgQ29sbGVjdGlibGVzQ29udHJvbGxlcjogdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xsZXJNZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3NlbmdlcixcbiAgICB9KTtcbiAgICB0aGlzLm1lbVN0b3JlLnN1YnNjcmliZSh0aGlzLnNlbmRVcGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICBjb25zdCBwYXNzd29yZCA9IHByb2Nlc3MuZW52LkNPTkY/LlBBU1NXT1JEO1xuICAgIGlmIChcbiAgICAgIHBhc3N3b3JkICYmXG4gICAgICAhdGhpcy5pc1VubG9ja2VkKCkgJiZcbiAgICAgIHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKS5jb21wbGV0ZWRPbmJvYXJkaW5nXG4gICAgKSB7XG4gICAgICB0aGlzLnN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICAvLyBMYXppbHkgdXBkYXRlIHRoZSBzdG9yZSB3aXRoIHRoZSBjdXJyZW50IGV4dGVuc2lvbiBlbnZpcm9ubWVudFxuICAgIHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuZ2V0UGxhdGZvcm1JbmZvKCh7IG9zIH0pID0+IHtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnNldEJyb3dzZXJFbnZpcm9ubWVudChcbiAgICAgICAgb3MsXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHByZXNlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuZ2V0QnJvd3NlckluZm8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gJ2Nocm9tZSdcbiAgICAgICAgICA6ICdmaXJlZm94JyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckV2ZW50U3Vic2NyaXB0aW9ucygpO1xuXG4gICAgLy8gVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAgdGhpcy5wdWJsaWNDb25maWdTdG9yZSA9IHRoaXMuY3JlYXRlUHVibGljQ29uZmlnU3RvcmUoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldHMgdXAgQmFzZUNvbnRyb2xsZXIgVjIgZXZlbnQgc3Vic2NyaXB0aW9ucy4gQ3VycmVudGx5LCB0aGlzIGluY2x1ZGVzXG4gICAqIHRoZSBzdWJzY3JpcHRpb25zIG5lY2Vzc2FyeSB0byBub3RpZnkgcGVybWlzc2lvbiBzdWJqZWN0cyBvZiBhY2NvdW50XG4gICAqIGNoYW5nZXMuXG4gICAqXG4gICAqIFNvbWUgb2YgdGhlIHN1YnNjcmlwdGlvbnMgaW4gdGhpcyBtZXRob2QgYXJlIENvbnRyb2xsZXJNZXNzZW5nZXIgc2VsZWN0b3JcbiAgICogZXZlbnQgc3Vic2NyaXB0aW9ucy4gU2VlIHRoZSByZWxldmFudCBAbWV0YW1hc2svY29udHJvbGxlcnMgZG9jdW1lbnRhdGlvblxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IGFjY291bnQtcmVsYXRlZCBub3RpZmljYXRpb25zIGVtaXR0ZWQgd2hlbiB0aGUgZXh0ZW5zaW9uXG4gICAqIGJlY29tZXMgdW5sb2NrZWQgYXJlIGhhbmRsZWQgaW4gTWV0YU1hc2tDb250cm9sbGVyLl9vblVubG9jay5cbiAgICovXG4gIHNldHVwQ29udHJvbGxlckV2ZW50U3Vic2NyaXB0aW9ucygpIHtcbiAgICBjb25zdCBoYW5kbGVBY2NvdW50c0NoYW5nZSA9IGFzeW5jIChvcmlnaW4sIG5ld0FjY291bnRzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb25uZWN0aW9ucyhvcmlnaW4sIHtcbiAgICAgICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy5hY2NvdW50c0NoYW5nZWQsXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIHJldHVybiB2YWx1ZSBvZiBgZXRoX2FjY291bnRzYCxcbiAgICAgICAgICAvLyBuYW1lbHkgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgLyBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIEV0aGVyZXVtXG4gICAgICAgICAgLy8gYWNjb3VudC5cbiAgICAgICAgICBwYXJhbXM6XG4gICAgICAgICAgICBuZXdBY2NvdW50cy5sZW5ndGggPCAyXG4gICAgICAgICAgICAgID8gLy8gSWYgdGhlIGxlbmd0aCBpcyAxIG9yIDAsIHRoZSBhY2NvdW50cyBhcmUgc29ydGVkIGJ5IGRlZmluaXRpb24uXG4gICAgICAgICAgICAgICAgbmV3QWNjb3VudHNcbiAgICAgICAgICAgICAgOiAvLyBJZiB0aGUgbGVuZ3RoIGlzIDIgb3IgZ3JlYXRlciwgd2UgaGF2ZSB0byBleGVjdXRlXG4gICAgICAgICAgICAgICAgLy8gYGV0aF9hY2NvdW50c2AgdmkgdGhpcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyhvcmlnaW4pLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci51cGRhdGVBY2NvdW50c0hpc3Rvcnkob3JpZ2luLCBuZXdBY2NvdW50cyk7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgaGFuZGxlcyBhY2NvdW50IGNoYW5nZXMgd2hlbmV2ZXIgdGhlIHNlbGVjdGVkIGFkZHJlc3MgY2hhbmdlcy5cbiAgICBsZXQgbGFzdFNlbGVjdGVkQWRkcmVzcztcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoYXN5bmMgKHsgc2VsZWN0ZWRBZGRyZXNzIH0pID0+IHtcbiAgICAgIGlmIChzZWxlY3RlZEFkZHJlc3MgJiYgc2VsZWN0ZWRBZGRyZXNzICE9PSBsYXN0U2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIGxhc3RTZWxlY3RlZEFkZHJlc3MgPSBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHBlcm1pdHRlZEFjY291bnRzTWFwID0gZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbihcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnN0YXRlLFxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgW29yaWdpbiwgYWNjb3VudHNdIG9mIHBlcm1pdHRlZEFjY291bnRzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmIChhY2NvdW50cy5pbmNsdWRlcyhzZWxlY3RlZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICBoYW5kbGVBY2NvdW50c0NoYW5nZShvcmlnaW4sIGFjY291bnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoaXMgaGFuZGxlcyBhY2NvdW50IGNoYW5nZXMgZXZlcnkgdGltZSByZWxldmFudCBwZXJtaXNzaW9uIHN0YXRlXG4gICAgLy8gY2hhbmdlcywgZm9yIGFueSByZWFzb24uXG4gICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcbiAgICAgIGAke3RoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIubmFtZX06c3RhdGVDaGFuZ2VgLFxuICAgICAgYXN5bmMgKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2VkQWNjb3VudHMgPSBnZXRDaGFuZ2VkQWNjb3VudHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtvcmlnaW4sIGFjY291bnRzXSBvZiBjaGFuZ2VkQWNjb3VudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgaGFuZGxlQWNjb3VudHNDaGFuZ2Uob3JpZ2luLCBhY2NvdW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRQZXJtaXR0ZWRBY2NvdW50c0J5T3JpZ2luLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXI6IGluaXRpYWxpemUgYSBwcm92aWRlci5cbiAgICovXG4gIGluaXRpYWxpemVQcm92aWRlcigpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5wbGF0Zm9ybS5nZXRWZXJzaW9uKCk7XG4gICAgY29uc3QgcHJvdmlkZXJPcHRzID0ge1xuICAgICAgc3RhdGljOiB7XG4gICAgICAgIGV0aF9zeW5jaW5nOiBmYWxzZSxcbiAgICAgICAgd2ViM19jbGllbnRWZXJzaW9uOiBgTWV0YU1hc2svdiR7dmVyc2lvbn1gLFxuICAgICAgfSxcbiAgICAgIHZlcnNpb24sXG4gICAgICAvLyBhY2NvdW50IG1nbXRcbiAgICAgIGdldEFjY291bnRzOiBhc3luYyAoeyBvcmlnaW4gfSkgPT4ge1xuICAgICAgICBpZiAob3JpZ2luID09PSAnbWV0YW1hc2snKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkQWRkcmVzcyA/IFtzZWxlY3RlZEFkZHJlc3NdIDogW107XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTsgLy8gY2hhbmdpbmcgdGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgfSxcbiAgICAgIC8vIHR4IHNpZ25pbmdcbiAgICAgIHByb2Nlc3NUcmFuc2FjdGlvbjogdGhpcy5uZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIC8vIG1zZyBzaWduaW5nXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2U6IHRoaXMubmV3VW5zaWduZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlOiB0aGlzLm5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlVjM6IHRoaXMubmV3VW5zaWduZWRUeXBlZE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNDogdGhpcy5uZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZTogdGhpcy5uZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlOiB0aGlzLm5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXk6IHRoaXMubmV3UmVxdWVzdEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdOb25jZTogdGhpcy5nZXRQZW5kaW5nTm9uY2UuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaDogKGhhc2gpID0+XG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgc2VhcmNoQ3JpdGVyaWE6IHtcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVswXSxcbiAgICB9O1xuICAgIGNvbnN0IHByb3ZpZGVyUHJveHkgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmluaXRpYWxpemVQcm92aWRlcihcbiAgICAgIHByb3ZpZGVyT3B0cyxcbiAgICApO1xuICAgIHJldHVybiBwcm92aWRlclByb3h5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86TGVnYWN5UHJvdmlkZXI6IERlbGV0ZVxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXI6IGluaXRpYWxpemUgYSBwdWJsaWMgY29uZmlnIHN0b3JlLlxuICAgKiBUaGlzIHN0b3JlIGlzIHVzZWQgdG8gbWFrZSBzb21lIGNvbmZpZyBpbmZvIGF2YWlsYWJsZSB0byBEYXBwcyBzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgY3JlYXRlUHVibGljQ29uZmlnU3RvcmUoKSB7XG4gICAgLy8gc3Vic2V0IG9mIHN0YXRlIGZvciBtZXRhbWFzayBpbnBhZ2UgcHJvdmlkZXJcbiAgICBjb25zdCBwdWJsaWNDb25maWdTdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoKTtcbiAgICBjb25zdCB7IG5ldHdvcmtDb250cm9sbGVyIH0gPSB0aGlzO1xuXG4gICAgLy8gc2V0dXAgbWVtU3RvcmUgc3Vic2NyaXB0aW9uIGhvb2tzXG4gICAgdGhpcy5vbigndXBkYXRlJywgdXBkYXRlUHVibGljQ29uZmlnU3RvcmUpO1xuICAgIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKHRoaXMuZ2V0U3RhdGUoKSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQdWJsaWNDb25maWdTdG9yZShtZW1TdGF0ZSkge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IG5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICBpZiAobWVtU3RhdGUubmV0d29yayAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIHB1YmxpY0NvbmZpZ1N0b3JlLnB1dFN0YXRlKHNlbGVjdFB1YmxpY1N0YXRlKGNoYWluSWQsIG1lbVN0YXRlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHVibGljU3RhdGUoY2hhaW5JZCwgeyBpc1VubG9ja2VkLCBuZXR3b3JrIH0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVW5sb2NrZWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uOiBuZXR3b3JrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljQ29uZmlnU3RvcmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyByZWxldmFudCBzdGF0ZSBmb3IgdGhlIHByb3ZpZGVyIG9mIGFuIGV4dGVybmFsIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gZ2V0IHRoZSBwcm92aWRlciBzdGF0ZSBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtcbiAgICogIGlzVW5sb2NrZWQ6IGJvb2xlYW4sXG4gICAqICBuZXR3b3JrVmVyc2lvbjogc3RyaW5nLFxuICAgKiAgY2hhaW5JZDogc3RyaW5nLFxuICAgKiAgYWNjb3VudHM6IHN0cmluZ1tdLFxuICAgKiB9Pn0gQW4gb2JqZWN0IHdpdGggcmVsZXZhbnQgc3RhdGUgcHJvcGVydGllcy5cbiAgICovXG4gIGFzeW5jIGdldFByb3ZpZGVyU3RhdGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVW5sb2NrZWQ6IHRoaXMuaXNVbmxvY2tlZCgpLFxuICAgICAgLi4udGhpcy5nZXRQcm92aWRlck5ldHdvcmtTdGF0ZSgpLFxuICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbmV0d29yayBzdGF0ZSByZWxldmFudCBmb3IgZXh0ZXJuYWwgcHJvdmlkZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW21lbVN0YXRlXSAtIFRoZSBNZXRhTWFzayBtZW1TdGF0ZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0cmlldmUgdGhlIG1vc3QgcmVjZW50IHN0YXRlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCByZWxldmFudCBuZXR3b3JrIHN0YXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRQcm92aWRlck5ldHdvcmtTdGF0ZShtZW1TdGF0ZSkge1xuICAgIGNvbnN0IHsgbmV0d29yayB9ID0gbWVtU3RhdGUgfHwgdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBjaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCksXG4gICAgICBuZXR3b3JrVmVyc2lvbjogbmV0d29yayxcbiAgICB9O1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFWFBPU0VEIFRPIFRIRSBVSSBTVUJTWVNURU1cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0YW1hc2stc3RhdGUgb2YgdGhlIHZhcmlvdXMgY29udHJvbGxlcnMsIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBVSVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdGF0dXNcbiAgICovXG4gIGdldFN0YXRlKCkge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gQm9vbGVhbih2YXVsdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNJbml0aWFsaXplZCxcbiAgICAgIC4uLnRoaXMubWVtU3RvcmUuZ2V0RmxhdFN0YXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE9iamVjdCBjb250YWluaW5nIEFQSSBDYWxsYmFjayBGdW5jdGlvbnMuXG4gICAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdGhlIGludGVyZmFjZSBmb3IgdGhlIFVJLlxuICAgKiBUaGUgQVBJIG9iamVjdCBjYW4gYmUgdHJhbnNtaXR0ZWQgb3ZlciBhIHN0cmVhbSB2aWEgSlNPTi1SUEMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIEFQSSBmdW5jdGlvbnMuXG4gICAqL1xuICBnZXRBcGkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc0Jvb2tDb250cm9sbGVyLFxuICAgICAgYWxlcnRDb250cm9sbGVyLFxuICAgICAgYXBwcm92YWxDb250cm9sbGVyLFxuICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgIGNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcixcbiAgICAgIGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICBkZXRlY3RUb2tlbnNDb250cm9sbGVyLFxuICAgICAgZW5zQ29udHJvbGxlcixcbiAgICAgIGdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICBrZXlyaW5nQ29udHJvbGxlcixcbiAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgIG5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgbm90aWZpY2F0aW9uQ29udHJvbGxlcixcbiAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyLFxuICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBxckhhcmR3YXJlS2V5cmluZyxcbiAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgIHRocmVlQm94Q29udHJvbGxlcixcbiAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICB0eENvbnRyb2xsZXIsXG4gICAgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gZXRjXG4gICAgICBnZXRTdGF0ZTogdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgc2V0Q3VycmVudEN1cnJlbmN5OiBjdXJyZW5jeVJhdGVDb250cm9sbGVyLnNldEN1cnJlbnRDdXJyZW5jeS5iaW5kKFxuICAgICAgICBjdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFVzZUJsb2NraWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VCbG9ja2llLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VOb25jZUZpZWxkOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0VXNlTm9uY2VGaWVsZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlUGhpc2hEZXRlY3Q6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VQaGlzaERldGVjdC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlVG9rZW5EZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VUb2tlbkRldGVjdGlvbi5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlQ29sbGVjdGlibGVEZXRlY3Rpb246IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VDb2xsZWN0aWJsZURldGVjdGlvbi5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0T3BlblNlYUVuYWJsZWQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRPcGVuU2VhRW5hYmxlZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0SXBmc0dhdGV3YXk6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRJcGZzR2F0ZXdheS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBtZXRhTWV0cmljc0NvbnRyb2xsZXIuc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDdXJyZW50TG9jYWxlOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0Q3VycmVudExvY2FsZS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgbWFya1Bhc3N3b3JkRm9yZ290dGVuOiB0aGlzLm1hcmtQYXNzd29yZEZvcmdvdHRlbi5iaW5kKHRoaXMpLFxuICAgICAgdW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW46IHRoaXMudW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW4uYmluZCh0aGlzKSxcbiAgICAgIHNhZmVsaXN0UGhpc2hpbmdEb21haW46IHRoaXMuc2FmZWxpc3RQaGlzaGluZ0RvbWFpbi5iaW5kKHRoaXMpLFxuICAgICAgZ2V0UmVxdWVzdEFjY291bnRUYWJJZHM6IHRoaXMuZ2V0UmVxdWVzdEFjY291bnRUYWJJZHMsXG4gICAgICBnZXRPcGVuTWV0YW1hc2tUYWJzSWRzOiB0aGlzLmdldE9wZW5NZXRhbWFza1RhYnNJZHMsXG4gICAgICBtYXJrTm90aWZpY2F0aW9uUG9wdXBBc0F1dG9tYXRpY2FsbHlDbG9zZWQ6ICgpID0+XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uTWFuYWdlci5tYXJrQXNBdXRvbWF0aWNhbGx5Q2xvc2VkKCksXG5cbiAgICAgIC8vIHByaW1hcnkgSEQga2V5cmluZyBtYW5hZ2VtZW50XG4gICAgICBhZGROZXdBY2NvdW50OiB0aGlzLmFkZE5ld0FjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIHZlcmlmeVNlZWRQaHJhc2U6IHRoaXMudmVyaWZ5U2VlZFBocmFzZS5iaW5kKHRoaXMpLFxuICAgICAgcmVzZXRBY2NvdW50OiB0aGlzLnJlc2V0QWNjb3VudC5iaW5kKHRoaXMpLFxuICAgICAgcmVtb3ZlQWNjb3VudDogdGhpcy5yZW1vdmVBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICBpbXBvcnRBY2NvdW50V2l0aFN0cmF0ZWd5OiB0aGlzLmltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3kuYmluZCh0aGlzKSxcblxuICAgICAgLy8gaGFyZHdhcmUgd2FsbGV0c1xuICAgICAgY29ubmVjdEhhcmR3YXJlOiB0aGlzLmNvbm5lY3RIYXJkd2FyZS5iaW5kKHRoaXMpLFxuICAgICAgZm9yZ2V0RGV2aWNlOiB0aGlzLmZvcmdldERldmljZS5iaW5kKHRoaXMpLFxuICAgICAgY2hlY2tIYXJkd2FyZVN0YXR1czogdGhpcy5jaGVja0hhcmR3YXJlU3RhdHVzLmJpbmQodGhpcyksXG4gICAgICB1bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQ6IHRoaXMudW5sb2NrSGFyZHdhcmVXYWxsZXRBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICBzZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlOiB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICksXG4gICAgICBhdHRlbXB0TGVkZ2VyVHJhbnNwb3J0Q3JlYXRpb246IHRoaXMuYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uLmJpbmQoXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuICAgICAgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZTogdGhpcy5lc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlLmJpbmQoXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuXG4gICAgICAvLyBxciBoYXJkd2FyZSBkZXZpY2VzXG4gICAgICBzdWJtaXRRUkhhcmR3YXJlQ3J5cHRvSERLZXk6IHFySGFyZHdhcmVLZXlyaW5nLnN1Ym1pdENyeXB0b0hES2V5LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVDcnlwdG9BY2NvdW50OiBxckhhcmR3YXJlS2V5cmluZy5zdWJtaXRDcnlwdG9BY2NvdW50LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIGNhbmNlbFN5bmNRUkhhcmR3YXJlOiBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTeW5jLmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVTaWduYXR1cmU6IHFySGFyZHdhcmVLZXlyaW5nLnN1Ym1pdFNpZ25hdHVyZS5iaW5kKFxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZyxcbiAgICAgICksXG4gICAgICBjYW5jZWxRUkhhcmR3YXJlU2lnblJlcXVlc3Q6IHFySGFyZHdhcmVLZXlyaW5nLmNhbmNlbFNpZ25SZXF1ZXN0LmJpbmQoXG4gICAgICAgIHFySGFyZHdhcmVLZXlyaW5nLFxuICAgICAgKSxcblxuICAgICAgLy8gbW9iaWxlXG4gICAgICBmZXRjaEluZm9Ub1N5bmM6IHRoaXMuZmV0Y2hJbmZvVG9TeW5jLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHZhdWx0IG1hbmFnZW1lbnRcbiAgICAgIHN1Ym1pdFBhc3N3b3JkOiB0aGlzLnN1Ym1pdFBhc3N3b3JkLmJpbmQodGhpcyksXG4gICAgICB2ZXJpZnlQYXNzd29yZDogdGhpcy52ZXJpZnlQYXNzd29yZC5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBuZXR3b3JrIG1hbmFnZW1lbnRcbiAgICAgIHNldFByb3ZpZGVyVHlwZTogbmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQoXG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHJvbGxiYWNrVG9QcmV2aW91c1Byb3ZpZGVyOiBuZXR3b3JrQ29udHJvbGxlci5yb2xsYmFja1RvUHJldmlvdXNQcm92aWRlci5iaW5kKFxuICAgICAgICBuZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDdXN0b21ScGM6IHRoaXMuc2V0Q3VzdG9tUnBjLmJpbmQodGhpcyksXG4gICAgICB1cGRhdGVBbmRTZXRDdXN0b21ScGM6IHRoaXMudXBkYXRlQW5kU2V0Q3VzdG9tUnBjLmJpbmQodGhpcyksXG4gICAgICBkZWxDdXN0b21ScGM6IHRoaXMuZGVsQ3VzdG9tUnBjLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIFByZWZlcmVuY2VzQ29udHJvbGxlclxuICAgICAgc2V0U2VsZWN0ZWRBZGRyZXNzOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhZGRUb2tlbjogdG9rZW5zQ29udHJvbGxlci5hZGRUb2tlbi5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgcmVqZWN0V2F0Y2hBc3NldDogdG9rZW5zQ29udHJvbGxlci5yZWplY3RXYXRjaEFzc2V0LmJpbmQoXG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgYWNjZXB0V2F0Y2hBc3NldDogdG9rZW5zQ29udHJvbGxlci5hY2NlcHRXYXRjaEFzc2V0LmJpbmQoXG4gICAgICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdXBkYXRlVG9rZW5UeXBlOiB0b2tlbnNDb250cm9sbGVyLnVwZGF0ZVRva2VuVHlwZS5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgcmVtb3ZlVG9rZW46IHRva2Vuc0NvbnRyb2xsZXIucmVtb3ZlQW5kSWdub3JlVG9rZW4uYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIHNldEFjY291bnRMYWJlbDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFjY291bnRMYWJlbC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RmVhdHVyZUZsYWc6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRGZWF0dXJlRmxhZy5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UHJlZmVyZW5jZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgYWRkS25vd25NZXRob2REYXRhOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkS25vd25NZXRob2REYXRhLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0RGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlci5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0QWR2YW5jZWRHYXNGZWU6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZHZhbmNlZEdhc0ZlZS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RUlQMTU1OVYyRW5hYmxlZDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEVJUDE1NTlWMkVuYWJsZWQuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gQXNzZXRzQ29udHJhY3RDb250cm9sbGVyXG4gICAgICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlsczogYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLmJpbmQoXG4gICAgICAgIGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIENvbGxlY3RpYmxlc0NvbnRyb2xsZXJcbiAgICAgIGFkZENvbGxlY3RpYmxlOiBjb2xsZWN0aWJsZXNDb250cm9sbGVyLmFkZENvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBhZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcDogY29sbGVjdGlibGVzQ29udHJvbGxlci5hZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcC5iaW5kKFxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgcmVtb3ZlQW5kSWdub3JlQ29sbGVjdGlibGU6IGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIucmVtb3ZlQW5kSWdub3JlQ29sbGVjdGlibGUuYmluZChcbiAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIHJlbW92ZUNvbGxlY3RpYmxlOiBjb2xsZWN0aWJsZXNDb250cm9sbGVyLnJlbW92ZUNvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBjaGVja0FuZFVwZGF0ZUFsbENvbGxlY3RpYmxlc093bmVyc2hpcFN0YXR1czogY29sbGVjdGlibGVzQ29udHJvbGxlci5jaGVja0FuZFVwZGF0ZUFsbENvbGxlY3RpYmxlc093bmVyc2hpcFN0YXR1cy5iaW5kKFxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgY2hlY2tBbmRVcGRhdGVTaW5nbGVDb2xsZWN0aWJsZU93bmVyc2hpcFN0YXR1czogY29sbGVjdGlibGVzQ29udHJvbGxlci5jaGVja0FuZFVwZGF0ZVNpbmdsZUNvbGxlY3RpYmxlT3duZXJzaGlwU3RhdHVzLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBpc0NvbGxlY3RpYmxlT3duZXI6IGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuaXNDb2xsZWN0aWJsZU93bmVyLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBBZGRyZXNzQ29udHJvbGxlclxuICAgICAgc2V0QWRkcmVzc0Jvb2s6IGFkZHJlc3NCb29rQ29udHJvbGxlci5zZXQuYmluZChhZGRyZXNzQm9va0NvbnRyb2xsZXIpLFxuICAgICAgcmVtb3ZlRnJvbUFkZHJlc3NCb29rOiBhZGRyZXNzQm9va0NvbnRyb2xsZXIuZGVsZXRlLmJpbmQoXG4gICAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIEFwcFN0YXRlQ29udHJvbGxlclxuICAgICAgc2V0TGFzdEFjdGl2ZVRpbWU6IGFwcFN0YXRlQ29udHJvbGxlci5zZXRMYXN0QWN0aXZlVGltZS5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0RGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0Q29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bi5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bjogYXBwU3RhdGVDb250cm9sbGVyLnNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24uYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd246IGFwcFN0YXRlQ29udHJvbGxlci5zZXRSZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRTaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0U2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93bi5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkOiBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRFbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQ6IGFwcFN0YXRlQ29udHJvbGxlci5zZXRFbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQuYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHVwZGF0ZUNvbGxlY3RpYmxlRHJvcERvd25TdGF0ZTogYXBwU3RhdGVDb250cm9sbGVyLnVwZGF0ZUNvbGxlY3RpYmxlRHJvcERvd25TdGF0ZS5iaW5kKFxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgLy8gRW5zQ29udHJvbGxlclxuICAgICAgdHJ5UmV2ZXJzZVJlc29sdmVBZGRyZXNzOiBlbnNDb250cm9sbGVyLnJldmVyc2VSZXNvbHZlQWRkcmVzcy5iaW5kKFxuICAgICAgICBlbnNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gS2V5cmluZ0NvbnRyb2xsZXJcbiAgICAgIHNldExvY2tlZDogdGhpcy5zZXRMb2NrZWQuYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW46IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbi5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlOiB0aGlzLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZS5iaW5kKHRoaXMpLFxuICAgICAgZXhwb3J0QWNjb3VudDoga2V5cmluZ0NvbnRyb2xsZXIuZXhwb3J0QWNjb3VudC5iaW5kKGtleXJpbmdDb250cm9sbGVyKSxcblxuICAgICAgLy8gdHhDb250cm9sbGVyXG4gICAgICBjYW5jZWxUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmNhbmNlbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgIHR4Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhcHByb3ZlVHJhbnNhY3Rpb25zV2l0aFNhbWVOb25jZTogdHhDb250cm9sbGVyLmFwcHJvdmVUcmFuc2FjdGlvbnNXaXRoU2FtZU5vbmNlLmJpbmQoXG4gICAgICAgIHR4Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjcmVhdGVDYW5jZWxUcmFuc2FjdGlvbjogdGhpcy5jcmVhdGVDYW5jZWxUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlU3BlZWRVcFRyYW5zYWN0aW9uOiB0aGlzLmNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZXN0aW1hdGVHYXM6IHRoaXMuZXN0aW1hdGVHYXMuYmluZCh0aGlzKSxcbiAgICAgIGdldE5leHROb25jZTogdGhpcy5nZXROZXh0Tm9uY2UuYmluZCh0aGlzKSxcbiAgICAgIGFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbi5iaW5kKFxuICAgICAgICB0eENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50OiB0eENvbnRyb2xsZXIuY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIHR4Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRUcmFuc2FjdGlvbnM6IHR4Q29udHJvbGxlci5nZXRUcmFuc2FjdGlvbnMuYmluZCh0eENvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBtZXNzYWdlTWFuYWdlclxuICAgICAgc2lnbk1lc3NhZ2U6IHRoaXMuc2lnbk1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGNhbmNlbE1lc3NhZ2U6IHRoaXMuY2FuY2VsTWVzc2FnZS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBwZXJzb25hbE1lc3NhZ2VNYW5hZ2VyXG4gICAgICBzaWduUGVyc29uYWxNZXNzYWdlOiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGNhbmNlbFBlcnNvbmFsTWVzc2FnZTogdGhpcy5jYW5jZWxQZXJzb25hbE1lc3NhZ2UuYmluZCh0aGlzKSxcblxuICAgICAgLy8gdHlwZWRNZXNzYWdlTWFuYWdlclxuICAgICAgc2lnblR5cGVkTWVzc2FnZTogdGhpcy5zaWduVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxUeXBlZE1lc3NhZ2U6IHRoaXMuY2FuY2VsVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIGRlY3J5cHRNZXNzYWdlTWFuYWdlclxuICAgICAgZGVjcnlwdE1lc3NhZ2U6IHRoaXMuZGVjcnlwdE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIGRlY3J5cHRNZXNzYWdlSW5saW5lOiB0aGlzLmRlY3J5cHRNZXNzYWdlSW5saW5lLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxEZWNyeXB0TWVzc2FnZTogdGhpcy5jYW5jZWxEZWNyeXB0TWVzc2FnZS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlclxuICAgICAgZW5jcnlwdGlvblB1YmxpY0tleTogdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5LmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxFbmNyeXB0aW9uUHVibGljS2V5OiB0aGlzLmNhbmNlbEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZCh0aGlzKSxcblxuICAgICAgLy8gb25ib2FyZGluZyBjb250cm9sbGVyXG4gICAgICBzZXRTZWVkUGhyYXNlQmFja2VkVXA6IG9uYm9hcmRpbmdDb250cm9sbGVyLnNldFNlZWRQaHJhc2VCYWNrZWRVcC5iaW5kKFxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjb21wbGV0ZU9uYm9hcmRpbmc6IG9uYm9hcmRpbmdDb250cm9sbGVyLmNvbXBsZXRlT25ib2FyZGluZy5iaW5kKFxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRGaXJzdFRpbWVGbG93VHlwZTogb25ib2FyZGluZ0NvbnRyb2xsZXIuc2V0Rmlyc3RUaW1lRmxvd1R5cGUuYmluZChcbiAgICAgICAgb25ib2FyZGluZ0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBhbGVydCBjb250cm9sbGVyXG4gICAgICBzZXRBbGVydEVuYWJsZWRuZXNzOiBhbGVydENvbnRyb2xsZXIuc2V0QWxlcnRFbmFibGVkbmVzcy5iaW5kKFxuICAgICAgICBhbGVydENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bjogYWxlcnRDb250cm9sbGVyLnNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24uYmluZChcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZDogYWxlcnRDb250cm9sbGVyLnNldFdlYjNTaGltVXNhZ2VBbGVydERpc21pc3NlZC5iaW5kKFxuICAgICAgICBhbGVydENvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyAzQm94XG4gICAgICBzZXRUaHJlZUJveFN5bmNpbmdQZXJtaXNzaW9uOiB0aHJlZUJveENvbnRyb2xsZXIuc2V0VGhyZWVCb3hTeW5jaW5nUGVybWlzc2lvbi5iaW5kKFxuICAgICAgICB0aHJlZUJveENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVzdG9yZUZyb21UaHJlZUJveDogdGhyZWVCb3hDb250cm9sbGVyLnJlc3RvcmVGcm9tVGhyZWVCb3guYmluZChcbiAgICAgICAgdGhyZWVCb3hDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZTogdGhyZWVCb3hDb250cm9sbGVyLnNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZS5iaW5kKFxuICAgICAgICB0aHJlZUJveENvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0VGhyZWVCb3hMYXN0VXBkYXRlZDogdGhyZWVCb3hDb250cm9sbGVyLmdldExhc3RVcGRhdGVkLmJpbmQoXG4gICAgICAgIHRocmVlQm94Q29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB0dXJuVGhyZWVCb3hTeW5jaW5nT246IHRocmVlQm94Q29udHJvbGxlci50dXJuVGhyZWVCb3hTeW5jaW5nT24uYmluZChcbiAgICAgICAgdGhyZWVCb3hDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGluaXRpYWxpemVUaHJlZUJveDogdGhpcy5pbml0aWFsaXplVGhyZWVCb3guYmluZCh0aGlzKSxcblxuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIHJlbW92ZVBlcm1pc3Npb25zRm9yOiBwZXJtaXNzaW9uQ29udHJvbGxlci5yZXZva2VQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICBwZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhcHByb3ZlUGVybWlzc2lvbnNSZXF1ZXN0OiBwZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3QuYmluZChcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0OiBwZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QuYmluZChcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgLi4uZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzKHBlcm1pc3Npb25Db250cm9sbGVyKSxcblxuXG4gICAgICAvLyBzd2Fwc1xuICAgICAgZmV0Y2hBbmRTZXRRdW90ZXM6IHN3YXBzQ29udHJvbGxlci5mZXRjaEFuZFNldFF1b3Rlcy5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U2VsZWN0ZWRRdW90ZUFnZ0lkOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRRdW90ZUFnZ0lkLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICByZXNldFN3YXBzU3RhdGU6IHN3YXBzQ29udHJvbGxlci5yZXNldFN3YXBzU3RhdGUuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNUb2tlbnM6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1Rva2Vucy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBjbGVhclN3YXBzUXVvdGVzOiBzd2Fwc0NvbnRyb2xsZXIuY2xlYXJTd2Fwc1F1b3Rlcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRBcHByb3ZlVHhJZDogc3dhcHNDb250cm9sbGVyLnNldEFwcHJvdmVUeElkLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFRyYWRlVHhJZDogc3dhcHNDb250cm9sbGVyLnNldFRyYWRlVHhJZC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1R4R2FzUHJpY2U6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4R2FzUHJpY2UuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzVHhHYXNMaW1pdDogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhHYXNMaW1pdC5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U3dhcHNUeE1heEZlZVBlckdhczogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhNYXhGZWVQZXJHYXMuYmluZChcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFN3YXBzVHhNYXhGZWVQcmlvcml0eVBlckdhczogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhNYXhGZWVQcmlvcml0eVBlckdhcy5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2FmZVJlZmV0Y2hRdW90ZXM6IHN3YXBzQ29udHJvbGxlci5zYWZlUmVmZXRjaFF1b3Rlcy5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc3RvcFBvbGxpbmdGb3JRdW90ZXM6IHN3YXBzQ29udHJvbGxlci5zdG9wUG9sbGluZ0ZvclF1b3Rlcy5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0QmFja2dyb3VuZFN3YXBSb3V0ZVN0YXRlOiBzd2Fwc0NvbnRyb2xsZXIuc2V0QmFja2dyb3VuZFN3YXBSb3V0ZVN0YXRlLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICByZXNldFBvc3RGZXRjaFN0YXRlOiBzd2Fwc0NvbnRyb2xsZXIucmVzZXRQb3N0RmV0Y2hTdGF0ZS5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U3dhcHNFcnJvcktleTogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzRXJyb3JLZXkuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0SW5pdGlhbEdhc0VzdGltYXRlOiBzd2Fwc0NvbnRyb2xsZXIuc2V0SW5pdGlhbEdhc0VzdGltYXRlLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRDdXN0b21BcHByb3ZlVHhEYXRhOiBzd2Fwc0NvbnRyb2xsZXIuc2V0Q3VzdG9tQXBwcm92ZVR4RGF0YS5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U3dhcHNMaXZlbmVzczogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzTGl2ZW5lc3MuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNGZWF0dXJlRmxhZ3M6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0ZlYXR1cmVGbGFncy5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U3dhcHNVc2VyRmVlTGV2ZWw6IHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1VzZXJGZWVMZXZlbC5iaW5kKFxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0U3dhcHNRdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNRdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkLmJpbmQoXG4gICAgICAgIHN3YXBzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIFNtYXJ0IFRyYW5zYWN0aW9uc1xuICAgICAgc2V0U21hcnRUcmFuc2FjdGlvbnNPcHRJblN0YXR1czogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnNldE9wdEluU3RhdGUuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGZldGNoU21hcnRUcmFuc2FjdGlvbkZlZXM6IHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5nZXRGZWVzLmJpbmQoXG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBlc3RpbWF0ZVNtYXJ0VHJhbnNhY3Rpb25zR2FzOiBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuZXN0aW1hdGVHYXMuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHN1Ym1pdFNpZ25lZFRyYW5zYWN0aW9uczogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN1Ym1pdFNpZ25lZFRyYW5zYWN0aW9ucy5iaW5kKFxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgY2FuY2VsU21hcnRUcmFuc2FjdGlvbjogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmNhbmNlbFNtYXJ0VHJhbnNhY3Rpb24uYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGZldGNoU21hcnRUcmFuc2FjdGlvbnNMaXZlbmVzczogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmZldGNoTGl2ZW5lc3MuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb246IHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci51cGRhdGVTbWFydFRyYW5zYWN0aW9uLmJpbmQoXG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRTdGF0dXNSZWZyZXNoSW50ZXJ2YWw6IHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5zZXRTdGF0dXNSZWZyZXNoSW50ZXJ2YWwuYmluZChcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gTWV0YU1ldHJpY3NcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudDogbWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NQYWdlOiBtZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tQYWdlLmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBjcmVhdGVFdmVudEZyYWdtZW50OiBtZXRhTWV0cmljc0NvbnRyb2xsZXIuY3JlYXRlRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdXBkYXRlRXZlbnRGcmFnbWVudDogbWV0YU1ldHJpY3NDb250cm9sbGVyLnVwZGF0ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGZpbmFsaXplRXZlbnRGcmFnbWVudDogbWV0YU1ldHJpY3NDb250cm9sbGVyLmZpbmFsaXplRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBhcHByb3ZhbCBjb250cm9sbGVyXG4gICAgICByZXNvbHZlUGVuZGluZ0FwcHJvdmFsOiBhcHByb3ZhbENvbnRyb2xsZXIuYWNjZXB0LmJpbmQoXG4gICAgICAgIGFwcHJvdmFsQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICByZWplY3RQZW5kaW5nQXBwcm92YWw6IGFwcHJvdmFsQ29udHJvbGxlci5yZWplY3QuYmluZChhcHByb3ZhbENvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgICB1cGRhdGVWaWV3ZWROb3RpZmljYXRpb25zOiBub3RpZmljYXRpb25Db250cm9sbGVyLnVwZGF0ZVZpZXdlZC5iaW5kKFxuICAgICAgICBub3RpZmljYXRpb25Db250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gR2FzRmVlQ29udHJvbGxlclxuICAgICAgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nOiBnYXNGZWVDb250cm9sbGVyLmdldEdhc0ZlZUVzdGltYXRlc0FuZFN0YXJ0UG9sbGluZy5iaW5kKFxuICAgICAgICBnYXNGZWVDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgZGlzY29ubmVjdEdhc0ZlZUVzdGltYXRlUG9sbGVyOiBnYXNGZWVDb250cm9sbGVyLmRpc2Nvbm5lY3RQb2xsZXIuYmluZChcbiAgICAgICAgZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIGdldEdhc0ZlZVRpbWVFc3RpbWF0ZTogZ2FzRmVlQ29udHJvbGxlci5nZXRUaW1lRXN0aW1hdGUuYmluZChcbiAgICAgICAgZ2FzRmVlQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIGFkZFBvbGxpbmdUb2tlblRvQXBwU3RhdGU6IGFwcFN0YXRlQ29udHJvbGxlci5hZGRQb2xsaW5nVG9rZW4uYmluZChcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgcmVtb3ZlUG9sbGluZ1Rva2VuRnJvbUFwcFN0YXRlOiBhcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuLmJpbmQoXG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIERldGVjdFRva2VuQ29udHJvbGxlclxuICAgICAgZGV0ZWN0TmV3VG9rZW5zOiBkZXRlY3RUb2tlbnNDb250cm9sbGVyLmRldGVjdE5ld1Rva2Vucy5iaW5kKFxuICAgICAgICBkZXRlY3RUb2tlbnNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gRGV0ZWN0Q29sbGVjdGlibGVDb250cm9sbGVyXG4gICAgICBkZXRlY3RDb2xsZWN0aWJsZXM6IHByb2Nlc3MuZW52LkNPTExFQ1RJQkxFU19WMVxuICAgICAgICA/IGNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlci5kZXRlY3RDb2xsZWN0aWJsZXMuYmluZChcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcixcbiAgICAgICAgICApXG4gICAgICAgIDogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBWQVVMVCAvIEtFWVJJTkcgUkVMQVRFRCBNRVRIT0RTXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBWYXVsdCBhbmQgY3JlYXRlIGEgbmV3IGtleWNoYWluLlxuICAgKlxuICAgKiBBIHZhdWx0LCBvciBLZXlyaW5nQ29udHJvbGxlciwgaXMgYSBjb250cm9sbGVyIHRoYXQgY29udGFpbnNcbiAgICogbWFueSBkaWZmZXJlbnQgYWNjb3VudCBzdHJhdGVnaWVzLCBjdXJyZW50bHkgY2FsbGVkIEtleXJpbmdzLlxuICAgKiBDcmVhdGluZyBpdCBuZXcgbWVhbnMgd2lwaW5nIGFsbCBwcmV2aW91cyBrZXlyaW5ncy5cbiAgICpcbiAgICogQSBrZXljaGFpbiwgb3Iga2V5cmluZywgY29udHJvbHMgbWFueSBhY2NvdW50cyB3aXRoIGEgc2luZ2xlIGJhY2t1cCBhbmQgc2lnbmluZyBzdHJhdGVneS5cbiAgICogRm9yIGV4YW1wbGUsIGEgbW5lbW9uaWMgcGhyYXNlIGNhbiBnZW5lcmF0ZSBtYW55IGFjY291bnRzLCBhbmQgaXMgYSBrZXlyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmRcbiAgICogQHJldHVybnMge09iamVjdH0gdmF1bHRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW4ocGFzc3dvcmQpIHtcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IHRoaXMuY3JlYXRlVmF1bHRNdXRleC5hY3F1aXJlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2YXVsdDtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmF1bHQgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmZ1bGxVcGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKFxuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgICAgICB0aGlzLnNlbGVjdEZpcnN0SWRlbnRpdHkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVmF1bHQgYW5kIHJlc3RvcmUgYW4gZXhpc3RlbnQga2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGVuY29kZWRTZWVkUGhyYXNlIC0gVGhlIHNlZWQgcGhyYXNlLCBlbmNvZGVkIGFzIGFuIGFycmF5XG4gICAqIG9mIFVURi04IGJ5dGVzLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBlbmNvZGVkU2VlZFBocmFzZSkge1xuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgdGhpcy5jcmVhdGVWYXVsdE11dGV4LmFjcXVpcmUoKTtcbiAgICB0cnkge1xuICAgICAgbGV0IGFjY291bnRzLCBsYXN0QmFsYW5jZTtcblxuICAgICAgY29uc3Qgc2VlZFBocmFzZUFzQnVmZmVyID0gQnVmZmVyLmZyb20oZW5jb2RlZFNlZWRQaHJhc2UpO1xuXG4gICAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xuXG4gICAgICAvLyBjbGVhciBrbm93biBpZGVudGl0aWVzXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoW10pO1xuXG4gICAgICAvLyBjbGVhciBwZXJtaXNzaW9uc1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5jbGVhclN0YXRlKCk7XG5cbiAgICAgIC8vIGNsZWFyIGFjY291bnRzIGluIGFjY291bnRUcmFja2VyXG4gICAgICB0aGlzLmFjY291bnRUcmFja2VyLmNsZWFyQWNjb3VudHMoKTtcblxuICAgICAgLy8gY2xlYXIgY2FjaGVkQmFsYW5jZXNcbiAgICAgIHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLmNsZWFyQ2FjaGVkQmFsYW5jZXMoKTtcblxuICAgICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnNcbiAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xuXG4gICAgICAvLyBjcmVhdGUgbmV3IHZhdWx0XG4gICAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIHNlZWRQaHJhc2VBc0J1ZmZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV0aFF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KHRoaXMucHJvdmlkZXIpO1xuICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgbGFzdEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoXG4gICAgICAgIGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICBldGhRdWVyeSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByaW1hcnlLZXlyaW5nID0ga2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICAgICdIRCBLZXkgVHJlZScsXG4gICAgICApWzBdO1xuICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFtYXNrQ29udHJvbGxlciAtIE5vIEhEIEtleSBUcmVlIGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZWsgb3V0IHRoZSBmaXJzdCB6ZXJvIGJhbGFuY2VcbiAgICAgIHdoaWxlIChsYXN0QmFsYW5jZSAhPT0gJzB4MCcpIHtcbiAgICAgICAgYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgbGFzdEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoXG4gICAgICAgICAgYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgZXRoUXVlcnksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBleHRyYSB6ZXJvIGJhbGFuY2UgYWNjb3VudCBwb3RlbnRpYWxseSBjcmVhdGVkIGZyb20gc2Vla2luZyBhaGVhZFxuICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDEgJiYgbGFzdEJhbGFuY2UgPT09ICcweDAnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQWNjb3VudChhY2NvdW50c1thY2NvdW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBtdXN0IGJlIHNldCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGNvbW11bmljYXRlIHRvIHRoZVxuICAgICAgLy8ga2V5cmluZydzIGlmcmFtZSBhbmQgaGF2ZSB0aGUgc2V0dGluZyBpbml0aWFsaXplZCBwcm9wZXJseVxuICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgY2FsbGVkIHRvIG5vdCBibG9jayBNZXRhbWFzayBsb2dpbiBkdWUgdG9cbiAgICAgIC8vIExlZGdlciBLZXlyaW5nIEdpdEh1YiBkb3dudGltZVxuICAgICAgY29uc3QgdHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcblxuICAgICAgLy8gc2V0IG5ldyBpZGVudGl0aWVzXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoYWNjb3VudHMpO1xuICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XG4gICAgICByZXR1cm4gdmF1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhY2NvdW50IGJhbGFuY2UgZnJvbSB0aGUgQWNjb3VudFRyYWNrZXIgb3IgcmVxdWVzdCBpdCBkaXJlY3RseSBmcm9tIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhY2NvdW50IGFkZHJlc3NcbiAgICogQHBhcmFtIHtFdGhRdWVyeX0gZXRoUXVlcnkgLSBUaGUgRXRoUXVlcnkgaW5zdGFuY2UgdG8gdXNlIHdoZW4gYXNraW5nIHRoZSBuZXR3b3JrXG4gICAqL1xuICBnZXRCYWxhbmNlKGFkZHJlc3MsIGV0aFF1ZXJ5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50c1thZGRyZXNzXTtcblxuICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQuYmFsYW5jZSkge1xuICAgICAgICByZXNvbHZlKGNhY2hlZC5iYWxhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aFF1ZXJ5LmdldEJhbGFuY2UoYWRkcmVzcywgKGVycm9yLCBiYWxhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShiYWxhbmNlIHx8ICcweDAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdCB3ZSB3YW50IHRvIHNoYXJlXG4gICAqIHdpdGggdGhlIG1vYmlsZSBjbGllbnQgZm9yIHN5bmNpbmcgcHVycG9zZXNcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUGFydHMgb2YgdGhlIHN0YXRlIHRoYXQgd2Ugd2FudCB0byBzeW5jeFxuICAgKi9cbiAgYXN5bmMgZmV0Y2hJbmZvVG9TeW5jKCkge1xuICAgIC8vIFByZWZlcmVuY2VzXG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExvY2FsZSxcbiAgICAgIGZyZXF1ZW50UnBjTGlzdCxcbiAgICAgIGlkZW50aXRpZXMsXG4gICAgICBzZWxlY3RlZEFkZHJlc3MsXG4gICAgICB1c2VUb2tlbkRldGVjdGlvbixcbiAgICB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGNvbnN0IHsgdG9rZW5MaXN0IH0gPSB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RhdGU7XG5cbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IHtcbiAgICAgIGN1cnJlbnRMb2NhbGUsXG4gICAgICBmcmVxdWVudFJwY0xpc3QsXG4gICAgICBpZGVudGl0aWVzLFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzLFxuICAgIH07XG5cbiAgICAvLyBUb2tlbnNcbiAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy50b2tlbnNDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgLy8gRmlsdGVyIEVSQzIwIHRva2Vuc1xuICAgIGNvbnN0IGFsbEVSQzIwVG9rZW5zID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhhbGxUb2tlbnMpLmZvckVhY2goKGNoYWluSWQpID0+IHtcbiAgICAgIGFsbEVSQzIwVG9rZW5zW2NoYWluSWRdID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhbGxUb2tlbnNbY2hhaW5JZF0pLmZvckVhY2goKGFjY291bnRBZGRyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3MgPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyhhY2NvdW50QWRkcmVzcyk7XG4gICAgICAgIGFsbEVSQzIwVG9rZW5zW2NoYWluSWRdW2NoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3NdID0gYWxsVG9rZW5zW2NoYWluSWRdW1xuICAgICAgICAgIGNoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3NcbiAgICAgICAgXS5maWx0ZXIoKGFzc2V0KSA9PiB7XG4gICAgICAgICAgaWYgKGFzc2V0LmlzRVJDNzIxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSB0b2tlbi5hZGRyZXNzIGZyb20gYWxsVG9rZW5zIGlzIGNoZWNrc3VtYWRkcmVzc1xuICAgICAgICAgICAgLy8gYXNzZXQuYWRkcmVzcyBoYXZlIHRvIGJlIGNoYW5nZWQgdG8gbG93ZXJjYXNlIHdoZW4gd2UgYXJlIHVzaW5nIGR5bmFtaWMgbGlzdFxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHVzZVRva2VuRGV0ZWN0aW9uXG4gICAgICAgICAgICAgID8gYXNzZXQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIDogYXNzZXQuYWRkcmVzcztcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlbkxpc3Qgd2lsbCBiZSBob2xkaW5nIG9ubHkgZXJjMjAgdG9rZW5zXG4gICAgICAgICAgICBpZiAodG9rZW5MaXN0W2FkZHJlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhc3NldC5pc0VSQzcyMSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBBY2NvdW50c1xuICAgIGNvbnN0IGhkS2V5cmluZyA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICAnSEQgS2V5IFRyZWUnLFxuICAgIClbMF07XG4gICAgY29uc3Qgc2ltcGxlS2V5UGFpcktleXJpbmdzID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZShcbiAgICAgICdTaW1wbGUgS2V5IFBhaXInLFxuICAgICk7XG4gICAgY29uc3QgaGRBY2NvdW50cyA9IGF3YWl0IGhkS2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIGNvbnN0IHNpbXBsZUtleVBhaXJLZXlyaW5nQWNjb3VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNpbXBsZUtleVBhaXJLZXlyaW5ncy5tYXAoKGtleXJpbmcpID0+IGtleXJpbmcuZ2V0QWNjb3VudHMoKSksXG4gICAgKTtcbiAgICBjb25zdCBzaW1wbGVLZXlQYWlyQWNjb3VudHMgPSBzaW1wbGVLZXlQYWlyS2V5cmluZ0FjY291bnRzLnJlZHVjZShcbiAgICAgIChhY2MsIGFjY291bnRzKSA9PiBbLi4uYWNjLCAuLi5hY2NvdW50c10sXG4gICAgICBbXSxcbiAgICApO1xuICAgIGNvbnN0IGFjY291bnRzID0ge1xuICAgICAgaGQ6IGhkQWNjb3VudHNcbiAgICAgICAgLmZpbHRlcigoaXRlbSwgcG9zKSA9PiBoZEFjY291bnRzLmluZGV4T2YoaXRlbSkgPT09IHBvcylcbiAgICAgICAgLm1hcCgoYWRkcmVzcykgPT4gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgc2ltcGxlS2V5UGFpcjogc2ltcGxlS2V5UGFpckFjY291bnRzXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gc2ltcGxlS2V5UGFpckFjY291bnRzLmluZGV4T2YoaXRlbSkgPT09IHBvcylcbiAgICAgICAgLm1hcCgoYWRkcmVzcykgPT4gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgbGVkZ2VyOiBbXSxcbiAgICAgIHRyZXpvcjogW10sXG4gICAgICBsYXR0aWNlOiBbXSxcbiAgICB9O1xuXG4gICAgLy8gdHJhbnNhY3Rpb25zXG5cbiAgICBsZXQgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMudHhDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gZGVsZXRlIHR4IGZvciBvdGhlciBhY2NvdW50cyB0aGF0IHdlJ3JlIG5vdCBpbXBvcnRpbmdcbiAgICB0cmFuc2FjdGlvbnMgPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRUeEZyb20gPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyh0eC50eFBhcmFtcy5mcm9tKTtcbiAgICAgIHJldHVybiBhY2NvdW50cy5oZC5pbmNsdWRlcyhjaGVja3N1bW1lZFR4RnJvbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudHMsXG4gICAgICBwcmVmZXJlbmNlcyxcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgIHRva2VuczogeyBhbGxUb2tlbnM6IGFsbEVSQzIwVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zIH0sXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIHRoZSB1c2VyJ3MgcGFzc3dvcmQgYW5kIGF0dGVtcHRzIHRvIHVubG9jayB0aGUgdmF1bHQuXG4gICAqIEFsc28gc3luY2hyb25pemVzIHRoZSBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsIHRvIGVuc3VyZSBpdHMgc2NoZW1hXG4gICAqIGlzIHVwIHRvIGRhdGUgd2l0aCBrbm93biBhY2NvdW50cyBvbmNlIHRoZSB2YXVsdCBpcyBkZWNyeXB0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIGtleXJpbmdDb250cm9sbGVyIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIHVubG9ja2luZyBleHRlbnNpb24uJywgZXJyb3IpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0aHJlZUJveFN5bmNpbmdBbGxvd2VkID0gdGhpcy50aHJlZUJveENvbnRyb2xsZXIuZ2V0VGhyZWVCb3hTeW5jaW5nU3RhdGUoKTtcbiAgICAgIGlmICh0aHJlZUJveFN5bmNpbmdBbGxvd2VkICYmICF0aGlzLnRocmVlQm94Q29udHJvbGxlci5ib3gpIHtcbiAgICAgICAgLy8gJ2F3YWl0JyBpbnRlbnRpb25hbGx5IG9taXR0ZWQgdG8gYXZvaWQgd2FpdGluZyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy50aHJlZUJveENvbnRyb2xsZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLnRocmVlQm94Q29udHJvbGxlci50dXJuVGhyZWVCb3hTeW5jaW5nT24oKTtcbiAgICAgIH0gZWxzZSBpZiAodGhyZWVCb3hTeW5jaW5nQWxsb3dlZCAmJiB0aGlzLnRocmVlQm94Q29udHJvbGxlci5ib3gpIHtcbiAgICAgICAgdGhpcy50aHJlZUJveENvbnRyb2xsZXIudHVyblRocmVlQm94U3luY2luZ09uKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcignRXJyb3Igd2hpbGUgdW5sb2NraW5nIGV4dGVuc2lvbi4nLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBtdXN0IGJlIHNldCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIGNvbW11bmljYXRlIHRvIHRoZVxuICAgIC8vIGtleXJpbmcncyBpZnJhbWUgYW5kIGhhdmUgdGhlIHNldHRpbmcgaW5pdGlhbGl6ZWQgcHJvcGVybHlcbiAgICAvLyBPcHRpbWlzdGljYWxseSBjYWxsZWQgdG8gbm90IGJsb2NrIE1ldGFtYXNrIGxvZ2luIGR1ZSB0b1xuICAgIC8vIExlZGdlciBLZXlyaW5nIEdpdEh1YiBkb3dudGltZVxuICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cbiAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XG5cbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHVzZXIncyBwYXNzd29yZCB0byBjaGVjayBpdHMgdmFsaWRpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIHZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci52ZXJpZnlQYXNzd29yZChwYXNzd29yZCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgSWRlbnRpdHlcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgYWNjb3VudCBuaWNrbmFtZS5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWNjb3VudCdzIGV0aGVyZXVtIGFkZHJlc3MsIGluIGxvd2VyIGNhc2UuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWF5QmVGYXVjZXRpbmcgLSBXaGV0aGVyIHRoaXMgYWNjb3VudCBpcyBjdXJyZW50bHlcbiAgICogcmVjZWl2aW5nIGZ1bmRzIGZyb20gb3VyIGF1dG9tYXRpYyBSb3BzdGVuIGZhdWNldC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHN0YXRlIHRvIHRoZSBzZWxlY3RlZCBhZGRyZXNzXG4gICAqL1xuICBzZWxlY3RGaXJzdElkZW50aXR5KCkge1xuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBhZGRyZXNzID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF07XG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1uZW1vbmljIG9mIHRoZSB1c2VyJ3MgcHJpbWFyeSBrZXlyaW5nLlxuICAgKi9cbiAgZ2V0UHJpbWFyeUtleXJpbmdNbmVtb25pYygpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZSgnSEQgS2V5IFRyZWUnKVswXTtcbiAgICBpZiAoIWtleXJpbmcubW5lbW9uaWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWFyeSBrZXlyaW5nIG1uZW1vbmljIHVuYXZhaWxhYmxlLicpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cmluZy5tbmVtb25pYztcbiAgfVxuXG4gIC8vXG4gIC8vIEhhcmR3YXJlXG4gIC8vXG5cbiAgYXN5bmMgZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGggPSBudWxsKSB7XG4gICAgbGV0IGtleXJpbmdOYW1lID0gbnVsbDtcbiAgICBzd2l0Y2ggKGRldmljZU5hbWUpIHtcbiAgICAgIGNhc2UgREVWSUNFX05BTUVTLlRSRVpPUjpcbiAgICAgICAga2V5cmluZ05hbWUgPSBUcmV6b3JLZXlyaW5nLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERVZJQ0VfTkFNRVMuTEVER0VSOlxuICAgICAgICBrZXlyaW5nTmFtZSA9IExlZGdlckJyaWRnZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFVklDRV9OQU1FUy5RUjpcbiAgICAgICAga2V5cmluZ05hbWUgPSBRUkhhcmR3YXJlS2V5cmluZy50eXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgREVWSUNFX05BTUVTLkxBVFRJQ0U6XG4gICAgICAgIGtleXJpbmdOYW1lID0gTGF0dGljZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ01ldGFtYXNrQ29udHJvbGxlcjpnZXRLZXlyaW5nRm9yRGV2aWNlIC0gVW5rbm93biBkZXZpY2UnLFxuICAgICAgICApO1xuICAgIH1cbiAgICBsZXQga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBrZXlyaW5nTmFtZSxcbiAgICApWzBdO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3S2V5cmluZyhrZXlyaW5nTmFtZSk7XG4gICAgfVxuICAgIGlmIChoZFBhdGggJiYga2V5cmluZy5zZXRIZFBhdGgpIHtcbiAgICAgIGtleXJpbmcuc2V0SGRQYXRoKGhkUGF0aCk7XG4gICAgfVxuICAgIGlmIChkZXZpY2VOYW1lID09PSBERVZJQ0VfTkFNRVMuTEFUVElDRSkge1xuICAgICAga2V5cmluZy5hcHBOYW1lID0gJ01ldGFNYXNrJztcbiAgICB9XG4gICAgaWYgKGRldmljZU5hbWUgPT09IERFVklDRV9OQU1FUy5UUkVaT1IpIHtcbiAgICAgIGNvbnN0IG1vZGVsID0ga2V5cmluZy5nZXRNb2RlbCgpO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0VHJlem9yTW9kZWwobW9kZWwpO1xuICAgIH1cblxuICAgIGtleXJpbmcubmV0d29yayA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJDb25maWcoKS50eXBlO1xuXG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICBhc3luYyBhdHRlbXB0TGVkZ2VyVHJhbnNwb3J0Q3JlYXRpb24oKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShERVZJQ0VfTkFNRVMuTEVER0VSKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5hdHRlbXB0TWFrZUFwcCgpO1xuICB9XG5cbiAgYXN5bmMgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWNjb3VudCBsaXN0IGZyb20gYSB0cmV6b3IgZGV2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0gZGV2aWNlTmFtZVxuICAgKiBAcGFyYW0gcGFnZVxuICAgKiBAcGFyYW0gaGRQYXRoXG4gICAqIEByZXR1cm5zIFtdIGFjY291bnRzXG4gICAqL1xuICBhc3luYyBjb25uZWN0SGFyZHdhcmUoZGV2aWNlTmFtZSwgcGFnZSwgaGRQYXRoKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGgpO1xuICAgIGxldCBhY2NvdW50cyA9IFtdO1xuICAgIHN3aXRjaCAocGFnZSkge1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldFByZXZpb3VzUGFnZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldE5leHRQYWdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEZpcnN0UGFnZSgpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgYWNjb3VudHNcbiAgICAvLyBhbmQgbWFrZSBzdXJlIGFkZHJlc3NlcyBhcmUgbm90IHJlcGVhdGVkXG4gICAgY29uc3Qgb2xkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgY29uc3QgYWNjb3VudHNUb1RyYWNrID0gW1xuICAgICAgLi4ubmV3IFNldChcbiAgICAgICAgb2xkQWNjb3VudHMuY29uY2F0KGFjY291bnRzLm1hcCgoYSkgPT4gYS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSxcbiAgICAgICksXG4gICAgXTtcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN5bmNXaXRoQWRkcmVzc2VzKGFjY291bnRzVG9UcmFjayk7XG4gICAgcmV0dXJuIGFjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBkZXZpY2UgaXMgdW5sb2NrZWRcbiAgICpcbiAgICogQHBhcmFtIGRldmljZU5hbWVcbiAgICogQHBhcmFtIGhkUGF0aFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGNoZWNrSGFyZHdhcmVTdGF0dXMoZGV2aWNlTmFtZSwgaGRQYXRoKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGgpO1xuICAgIHJldHVybiBrZXlyaW5nLmlzVW5sb2NrZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhclxuICAgKlxuICAgKiBAcGFyYW0gZGV2aWNlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGZvcmdldERldmljZShkZXZpY2VOYW1lKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lKTtcbiAgICBrZXlyaW5nLmZvcmdldERldmljZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBoYXJkd2FyZSBhY2NvdW50IGxhYmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHN0cmluZyBsYWJlbFxuICAgKi9cblxuICBnZXRBY2NvdW50TGFiZWwobmFtZSwgaW5kZXgsIGhkUGF0aERlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGAke25hbWVbMF0udG9VcHBlckNhc2UoKX0ke25hbWUuc2xpY2UoMSl9ICR7XG4gICAgICBwYXJzZUludChpbmRleCwgMTApICsgMVxuICAgIH0gJHtoZFBhdGhEZXNjcmlwdGlvbiB8fCAnJ31gLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnRzIGFuIGFjY291bnQgZnJvbSBhIFRyZXpvciBvciBMZWRnZXIgZGV2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHBhcmFtIGRldmljZU5hbWVcbiAgICogQHBhcmFtIGhkUGF0aFxuICAgKiBAcGFyYW0gaGRQYXRoRGVzY3JpcHRpb25cbiAgICogQHJldHVybnMge30ga2V5U3RhdGVcbiAgICovXG4gIGFzeW5jIHVubG9ja0hhcmR3YXJlV2FsbGV0QWNjb3VudChcbiAgICBpbmRleCxcbiAgICBkZXZpY2VOYW1lLFxuICAgIGhkUGF0aCxcbiAgICBoZFBhdGhEZXNjcmlwdGlvbixcbiAgKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShkZXZpY2VOYW1lLCBoZFBhdGgpO1xuXG4gICAga2V5cmluZy5zZXRBY2NvdW50VG9VbmxvY2soaW5kZXgpO1xuICAgIGNvbnN0IG9sZEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIGNvbnN0IGtleVN0YXRlID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5hZGROZXdBY2NvdW50KGtleXJpbmcpO1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhuZXdBY2NvdW50cyk7XG4gICAgbmV3QWNjb3VudHMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgaWYgKCFvbGRBY2NvdW50cy5pbmNsdWRlcyhhZGRyZXNzKSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0QWNjb3VudExhYmVsKFxuICAgICAgICAgIGRldmljZU5hbWUgPT09IERFVklDRV9OQU1FUy5RUiA/IGtleXJpbmcuZ2V0TmFtZSgpIDogZGV2aWNlTmFtZSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBoZFBhdGhEZXNjcmlwdGlvbixcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU2V0IHRoZSBhY2NvdW50IGxhYmVsIHRvIFRyZXpvciAxIC8gIExlZGdlciAxIC8gUVIgSGFyZHdhcmUgMSwgZXRjXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFjY291bnRMYWJlbChhZGRyZXNzLCBsYWJlbCk7XG4gICAgICAgIC8vIFNlbGVjdCB0aGUgYWNjb3VudFxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHsgLi4ua2V5U3RhdGUsIGlkZW50aXRpZXMgfTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFjY291bnQgTWFuYWdlbWVudFxuICAvL1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGFjY291bnQgdG8gdGhlIGRlZmF1bHQgKGZpcnN0KSBIRCBzZWVkIHBocmFzZSBLZXlyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7fSBrZXlTdGF0ZVxuICAgKi9cbiAgYXN5bmMgYWRkTmV3QWNjb3VudCgpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICAnSEQgS2V5IFRyZWUnLFxuICAgIClbMF07XG4gICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBIRCBLZXkgVHJlZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9sZEFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBrZXlTdGF0ZSA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmFkZE5ld0FjY291bnQocHJpbWFyeUtleXJpbmcpO1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcblxuICAgIGF3YWl0IHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKG5ld0FjY291bnRzKTtcbiAgICBuZXdBY2NvdW50cy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICBpZiAoIW9sZEFjY291bnRzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFNlbGVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4geyAuLi5rZXlTdGF0ZSwgaWRlbnRpdGllcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSB2YWxpZGl0eSBvZiB0aGUgY3VycmVudCB2YXVsdCdzIHNlZWQgcGhyYXNlLlxuICAgKlxuICAgKiBWYWxpZGl0eTogc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGFjY291bnRzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCB2YXVsdC5cbiAgICpcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGZpcnN0IGFjY291bnQgaXMgY3JlYXRlZCBhbmQgb24gdW5sb2NraW5nIHRoZSB2YXVsdC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW10+fSBUaGUgc2VlZCBwaHJhc2UgdG8gYmUgY29uZmlybWVkIGJ5IHRoZSB1c2VyLFxuICAgKiBlbmNvZGVkIGFzIGFuIGFycmF5IG9mIFVURi04IGJ5dGVzLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5U2VlZFBocmFzZSgpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICAnSEQgS2V5IFRyZWUnLFxuICAgIClbMF07XG4gICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBIRCBLZXkgVHJlZSBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBhd2FpdCBwcmltYXJ5S2V5cmluZy5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBzZWVkUGhyYXNlQXNCdWZmZXIgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkLm1uZW1vbmljKTtcblxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBhY2NvdW50cyBmb3VuZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzZWVkUGhyYXNlVmVyaWZpZXIudmVyaWZ5QWNjb3VudHMoYWNjb3VudHMsIHNlZWRQaHJhc2VBc0J1ZmZlcik7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShzZWVkUGhyYXNlQXNCdWZmZXIudmFsdWVzKCkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSB0cmFuc2FjdGlvbiBoaXN0b3J5LCB0byBhbGxvdyB1c2VycyB0byBmb3JjZS1yZXNldCB0aGVpciBub25jZXMuXG4gICAqIE1vc3RseSB1c2VkIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cywgd2hlbiBuZXR3b3JrcyBhcmUgcmVzdGFydGVkIHdpdGhcbiAgICogdGhlIHNhbWUgbmV0d29yayBJRC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICovXG4gIGFzeW5jIHJlc2V0QWNjb3VudCgpIHtcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRTZWxlY3RlZEFkZHJlc3MoKTtcbiAgICB0aGlzLnR4Q29udHJvbGxlci53aXBlVHJhbnNhY3Rpb25zKHNlbGVjdGVkQWRkcmVzcyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5yZXNldENvbm5lY3Rpb24oKTtcblxuICAgIHJldHVybiBzZWxlY3RlZEFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGVybWl0dGVkIGFjY291bnRzIGZvciB0aGUgc3BlY2lmaWVkIG9yaWdpbi4gUmV0dXJucyBhbiBlbXB0eVxuICAgKiBhcnJheSBpZiBubyBhY2NvdW50cyBhcmUgcGVybWl0dGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB3aG9zZSBleHBvc2VkIGFjY291bnRzIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFRoZSBvcmlnaW4ncyBwZXJtaXR0ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XG4gICAqIGFycmF5LlxuICAgKi9cbiAgYXN5bmMgZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kKFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBycGNFcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXhwb3NpbmcgdGhlIGFjY291bnQgd2l0aCB0aGUgc3BlY2lmaWVkIGFkZHJlc3MgdG8gYWxsIHRoaXJkIHBhcnRpZXMuXG4gICAqIEV4cG9zZWQgYWNjb3VudHMgYXJlIHN0b3JlZCBpbiBjYXZlYXRzIG9mIHRoZSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gVGhpc1xuICAgKiBtZXRob2QgdXNlcyBgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlUGVybWlzc2lvbnNCeUNhdmVhdGAgdG9cbiAgICogcmVtb3ZlIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBmcm9tIGV2ZXJ5IGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLiBJZiBhXG4gICAqIHBlcm1pc3Npb24gb25seSBpbmNsdWRlZCB0aGlzIGFkZHJlc3MsIHRoZSBwZXJtaXNzaW9uIGlzIHJldm9rZWQgZW50aXJlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRBY2NvdW50IC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gc3RvcCBleHBvc2luZ1xuICAgKiB0byB0aGlyZCBwYXJ0aWVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsQWNjb3VudFBlcm1pc3Npb25zKHRhcmdldEFjY291bnQpIHtcbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQoXG4gICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICAoZXhpc3RpbmdBY2NvdW50cykgPT5cbiAgICAgICAgQ2F2ZWF0TXV0YXRvckZhY3Rvcmllc1tcbiAgICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNcbiAgICAgICAgXS5yZW1vdmVBY2NvdW50KHRhcmdldEFjY291bnQsIGV4aXN0aW5nQWNjb3VudHMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhY2NvdW50IGZyb20gc3RhdGUgLyBzdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBhc3NvY2lhdGVkIHBlcm1pc3Npb25zXG4gICAgdGhpcy5yZW1vdmVBbGxBY2NvdW50UGVybWlzc2lvbnMoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgYWNjb3VudCB0cmFja2VyIGNvbnRyb2xsZXJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnJlbW92ZUFjY291bnQoW2FkZHJlc3NdKTtcblxuICAgIC8vIFJlbW92ZSBhY2NvdW50IGZyb20gdGhlIGtleXJpbmdcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IHdpdGggdGhlIHNwZWNpZmllZCBpbXBvcnQgc3RyYXRlZ3kuXG4gICAqIFRoZXNlIGFyZSBkZWZpbmVkIGluIGFwcC9zY3JpcHRzL2FjY291bnQtaW1wb3J0LXN0cmF0ZWdpZXNcbiAgICogRWFjaCBzdHJhdGVneSByZXByZXNlbnRzIGEgZGlmZmVyZW50IHdheSBvZiBzZXJpYWxpemluZyBhbiBFdGhlcmV1bSBrZXkgcGFpci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmF0ZWd5IC0gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYW4gYWNjb3VudCBpbXBvcnQgc3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB7YW55fSBhcmdzIC0gVGhlIGRhdGEgcmVxdWlyZWQgYnkgdGhhdCBzdHJhdGVneSB0byBpbXBvcnQgYW4gYWNjb3VudC5cbiAgICovXG4gIGFzeW5jIGltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3koc3RyYXRlZ3ksIGFyZ3MpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gYXdhaXQgYWNjb3VudEltcG9ydGVyLmltcG9ydEFjY291bnQoc3RyYXRlZ3ksIGFyZ3MpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmFkZE5ld0tleXJpbmcoXG4gICAgICAnU2ltcGxlIEtleSBQYWlyJyxcbiAgICAgIFtwcml2YXRlS2V5XSxcbiAgICApO1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIC8vIHVwZGF0ZSBhY2NvdW50cyBpbiBwcmVmZXJlbmNlcyBjb250cm9sbGVyXG4gICAgY29uc3QgYWxsQWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKGFsbEFjY291bnRzKTtcbiAgICAvLyBzZXQgbmV3IGFjY291bnQgYXMgc2VsZWN0ZWRcbiAgICBhd2FpdCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoYWNjb3VudHNbMF0pO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElkZW50aXR5IE1hbmFnZW1lbnQgKHNpZ25hdHVyZSBvcGVyYXRpb25zKVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIERhcHAgc3VnZ2VzdHMgYSBuZXcgdHggdG8gYmUgc2lnbmVkLlxuICAgKiB0aGlzIHdyYXBwZXIgbmVlZHMgdG8gZXhpc3Qgc28gd2UgY2FuIHByb3ZpZGUgYSByZWZlcmVuY2UgdG9cbiAgICogIFwibmV3VW5hcHByb3ZlZFRyYW5zYWN0aW9uXCIgYmVmb3JlIFwidHhDb250cm9sbGVyXCIgaXMgaW5zdGFudGlhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIFRoZSB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgKi9cbiAgYXN5bmMgbmV3VW5hcHByb3ZlZFRyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50eENvbnRyb2xsZXIubmV3VW5hcHByb3ZlZFRyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICB9XG5cbiAgLy8gZXRoX3NpZ24gbWV0aG9kczpcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBEYXBwIHVzZXMgdGhlIGV0aF9zaWduIG1ldGhvZCwgdG8gcmVxdWVzdCB1c2VyIGFwcHJvdmFsLlxuICAgKiBldGhfc2lnbiBpcyBhIHB1cmUgc2lnbmF0dXJlIG9mIGFyYml0cmFyeSBkYXRhLiBJdCBpcyBvbiBhIGRlcHJlY2F0aW9uXG4gICAqIHBhdGgsIHNpbmNlIHRoaXMgZGF0YSBjYW4gYmUgYSB0cmFuc2FjdGlvbiwgb3IgY2FuIGxlYWsgcHJpdmF0ZSBrZXlcbiAgICogaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIHBhc3NlZCB0byBldGhfc2lnbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QsIGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICovXG4gIGFzeW5jIG5ld1Vuc2lnbmVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGNvbnN0IGRhdGEgPSBub3JtYWxpemVNc2dEYXRhKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICAvLyA2NCBoZXggKyBcIjB4XCIgYXQgdGhlIGJlZ2lubmluZ1xuICAgIC8vIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgRXRoZXJldW0ncyBFY1NpZ24gd29ya3Mgb25seSBvbiAzMiBieXRlIG51bWJlcnNcbiAgICAvLyBGb3IgNjcgbGVuZ3RoIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9wdWxsLzEyNjc5L2ZpbGVzI3I3NDk0Nzk2MDdcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDY2IHx8IGRhdGEubGVuZ3RoID09PSA2Nykge1xuICAgICAgcHJvbWlzZSA9IHRoaXMubWVzc2FnZU1hbmFnZXIuYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtc2dQYXJhbXMsIHJlcSk7XG4gICAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICAgIHRoaXMub3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICdldGhfc2lnbiByZXF1aXJlcyAzMiBieXRlIG1lc3NhZ2UgaGFzaCcsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ25pZmllcyB1c2VyIGludGVudCB0byBjb21wbGV0ZSBhbiBldGhfc2lnbiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIHBhc3NlZCB0byBldGhfY2FsbC5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gRnVsbCBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gc2lnbk1lc3NhZ2UnKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIHRyeSB7XG4gICAgICAvLyBzZXRzIHRoZSBzdGF0dXMgb3AgdGhlIG1lc3NhZ2UgdG8gJ2FwcHJvdmVkJ1xuICAgICAgLy8gYW5kIHJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgZm9yIHNpZ25pbmdcbiAgICAgIGNvbnN0IGNsZWFuTXNnUGFyYW1zID0gYXdhaXQgdGhpcy5tZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhd1NpZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2lnbk1lc3NhZ2UoY2xlYW5Nc2dQYXJhbXMpO1xuICAgICAgdGhpcy5tZXNzYWdlTWFuYWdlci5zZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHJhd1NpZyk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX3NpZ24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgdGhpcy5tZXNzYWdlTWFuYWdlci5lcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNhbmNlbCBhIG1lc3NhZ2Ugc3VibWl0dGVkIHZpYSBldGhfc2lnbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBtZXNzYWdlIHRvIGNhbmNlbC5cbiAgICovXG4gIGNhbmNlbE1lc3NhZ2UobXNnSWQpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2VNYW5hZ2VyIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VNYW5hZ2VyLnJlamVjdE1zZyhtc2dJZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8vIHBlcnNvbmFsX3NpZ24gbWV0aG9kczpcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBkYXBwIHVzZXMgdGhlIHBlcnNvbmFsX3NpZ24gbWV0aG9kLlxuICAgKiBUaGlzIGlzIGlkZW50aWNhbCB0byB0aGUgR2V0aCBldGhfc2lnbiBtZXRob2QsIGFuZCBtYXkgZXZlbnR1YWxseSByZXBsYWNlXG4gICAqIGV0aF9zaWduLlxuICAgKlxuICAgKiBXZSBjdXJyZW50bHkgZGVmaW5lIG91ciBldGhfc2lnbiBhbmQgcGVyc29uYWxfc2lnbiBtb3N0bHkgZm9yIGxlZ2FjeSBEYXBwcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gc2lnbiAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QsIGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICovXG4gIGFzeW5jIG5ld1Vuc2lnbmVkUGVyc29uYWxNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgcmVxLFxuICAgICk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgdGhpcy5vcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogU2lnbmlmaWVzIGEgdXNlcidzIGFwcHJvdmFsIHRvIHNpZ24gYSBwZXJzb25hbF9zaWduIG1lc3NhZ2UgaW4gcXVldWUuXG4gICAqIFRyaWdnZXJzIHNpZ25pbmcsIGFuZCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbSBuZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gc2lnbiAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBmdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zKSB7XG4gICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIHNpZ25QZXJzb25hbE1lc3NhZ2UnKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvcCB0aGUgbWVzc2FnZSB0byAnYXBwcm92ZWQnXG4gICAgLy8gYW5kIHJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgZm9yIHNpZ25pbmdcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xlYW5Nc2dQYXJhbXMgPSBhd2FpdCB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIuYXBwcm92ZU1lc3NhZ2UoXG4gICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICk7XG4gICAgICBjb25zdCByYXdTaWcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnNpZ25QZXJzb25hbE1lc3NhZ2UoXG4gICAgICAgIGNsZWFuTXNnUGFyYW1zLFxuICAgICAgKTtcbiAgICAgIC8vIHRlbGxzIHRoZSBsaXN0ZW5lciB0aGF0IHRoZSBtZXNzYWdlIGhhcyBiZWVuIHNpZ25lZFxuICAgICAgLy8gYW5kIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgZGFwcFxuICAgICAgdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgcmF3U2lnKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfcGVyc29uYWxTaWduIGZhaWxlZCcsIGVycm9yKTtcbiAgICAgIHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5lcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNhbmNlbCBhIHBlcnNvbmFsX3NpZ24gdHlwZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsUGVyc29uYWxNZXNzYWdlKG1zZ0lkKSB7XG4gICAgY29uc3QgbWVzc2FnZU1hbmFnZXIgPSB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gZXRoX2RlY3J5cHQgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgZXRoX2RlY3J5cHQgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gKG9wdGlvbmFsKSB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIFBhc3NlZCBiYWNrIHRvIHRoZSByZXF1ZXN0aW5nIERhcHAuXG4gICAqL1xuICBhc3luYyBuZXdSZXF1ZXN0RGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIuYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhcbiAgICAgIG1zZ1BhcmFtcyxcbiAgICAgIHJlcSxcbiAgICApO1xuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICAgIHRoaXMub3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgZGVjcnlwdCBtZXNzYWdlIGFuZCBkb24ndCB0b3VjaCB0cmFuc2FjdGlvbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBkZWNyeXB0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIGZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgZGVjcnlwdE1lc3NhZ2VJbmxpbmUobXNnUGFyYW1zKSB7XG4gICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIGRlY3J5cHRNZXNzYWdlSW5saW5lJyk7XG4gICAgLy8gZGVjcnlwdCB0aGUgbWVzc2FnZSBpbmxpbmVcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmdldE1zZyhtc2dJZCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBIZXhQcmVmaXgobXNnUGFyYW1zLmRhdGEpO1xuICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgICBtc2dQYXJhbXMuZGF0YSA9IEpTT04ucGFyc2UoYnVmZi50b1N0cmluZygndXRmOCcpKTtcblxuICAgICAgbXNnLnJhd0RhdGEgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXNnLmVycm9yID0gZS5tZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5fdXBkYXRlTXNnKG1zZyk7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25pZmllcyBhIHVzZXIncyBhcHByb3ZhbCB0byBkZWNyeXB0IGEgbWVzc2FnZSBpbiBxdWV1ZS5cbiAgICogVHJpZ2dlcnMgZGVjcnlwdCwgYW5kIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIG5ld1Vuc2lnbmVkRGVjcnlwdE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIGRlY3J5cHQgJiByZXR1cm4gdG8gdGhlIERhcHAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgZnVsbCBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBkZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZGVjcnlwdE1lc3NhZ2UnKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvcCB0aGUgbWVzc2FnZSB0byAnYXBwcm92ZWQnXG4gICAgLy8gYW5kIHJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgZm9yIGRlY3J5cHRpb25cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xlYW5Nc2dQYXJhbXMgPSBhd2FpdCB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEhleFByZWZpeChjbGVhbk1zZ1BhcmFtcy5kYXRhKTtcbiAgICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuZnJvbShzdHJpcHBlZCwgJ2hleCcpO1xuICAgICAgY2xlYW5Nc2dQYXJhbXMuZGF0YSA9IEpTT04ucGFyc2UoYnVmZi50b1N0cmluZygndXRmOCcpKTtcblxuICAgICAgLy8gZGVjcnlwdCB0aGUgbWVzc2FnZVxuICAgICAgY29uc3QgcmF3TWVzcyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2UoXG4gICAgICAgIGNsZWFuTXNnUGFyYW1zLFxuICAgICAgKTtcbiAgICAgIC8vIHRlbGxzIHRoZSBsaXN0ZW5lciB0aGF0IHRoZSBtZXNzYWdlIGhhcyBiZWVuIGRlY3J5cHRlZCBhbmQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBkYXBwXG4gICAgICB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5zZXRNc2dTdGF0dXNEZWNyeXB0ZWQobXNnSWQsIHJhd01lc3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX2RlY3J5cHQgZmFpbGVkLicsIGVycm9yKTtcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgZXRoX2RlY3J5cHQgdHlwZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsRGVjcnlwdE1lc3NhZ2UobXNnSWQpIHtcbiAgICBjb25zdCBtZXNzYWdlTWFuYWdlciA9IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyO1xuICAgIG1lc3NhZ2VNYW5hZ2VyLnJlamVjdE1zZyhtc2dJZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8vIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5IG1ldGhvZHNcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBkYXBwIHVzZXMgdGhlIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gc2lnbiAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIChvcHRpb25hbCkgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBQYXNzZWQgYmFjayB0byB0aGUgcmVxdWVzdGluZyBEYXBwLlxuICAgKi9cbiAgYXN5bmMgbmV3UmVxdWVzdEVuY3J5cHRpb25QdWJsaWNLZXkobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbXNnUGFyYW1zO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuXG4gICAgc3dpdGNoIChrZXlyaW5nLnR5cGUpIHtcbiAgICAgIGNhc2UgS0VZUklOR19UWVBFUy5MRURHRVI6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ0xlZGdlciBkb2VzIG5vdCBzdXBwb3J0IGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5LicpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuVFJFWk9SOiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKCdUcmV6b3IgZG9lcyBub3Qgc3VwcG9ydCBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleS4nKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxBVFRJQ0U6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ0xhdHRpY2UgZG9lcyBub3Qgc3VwcG9ydCBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleS4nKSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLlFSOiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoJ1FSIGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkuJyksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIuYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhcbiAgICAgICAgICBtc2dQYXJhbXMsXG4gICAgICAgICAgcmVxLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICAgICAgdGhpcy5vcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduaWZpZXMgYSB1c2VyJ3MgYXBwcm92YWwgdG8gcmVjZWl2aW5nIGVuY3J5cHRpb24gcHVibGljIGtleSBpbiBxdWV1ZS5cbiAgICogVHJpZ2dlcnMgcmVjZWl2aW5nLCBhbmQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gbmV3VW5zaWduZWRFbmNyeXB0aW9uUHVibGljS2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byByZWNlaXZlICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIGZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZW5jcnlwdGlvblB1YmxpY0tleScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgLy8gc2V0cyB0aGUgc3RhdHVzIG9wIHRoZSBtZXNzYWdlIHRvICdhcHByb3ZlZCdcbiAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3IgZGVjcnlwdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBhd2FpdCB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLmFwcHJvdmVNZXNzYWdlKFxuICAgICAgICBtc2dQYXJhbXMsXG4gICAgICApO1xuXG4gICAgICAvLyBFbmNyeXB0aW9uUHVibGljS2V5IG1lc3NhZ2VcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0RW5jcnlwdGlvblB1YmxpY0tleShcbiAgICAgICAgcGFyYW1zLmRhdGEsXG4gICAgICApO1xuXG4gICAgICAvLyB0ZWxscyB0aGUgbGlzdGVuZXIgdGhhdCB0aGUgbWVzc2FnZSBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgIC8vIGFuZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIGRhcHBcbiAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIuc2V0TXNnU3RhdHVzUmVjZWl2ZWQobXNnSWQsIHB1YmxpY0tleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKFxuICAgICAgICAnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgZmFpbGVkLicsXG4gICAgICAgIGVycm9yLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIuZXJyb3JNZXNzYWdlKG1zZ0lkLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjYW5jZWwgYSBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleSB0eXBlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dJZCAtIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byBjYW5jZWwuXG4gICAqL1xuICBjYW5jZWxFbmNyeXB0aW9uUHVibGljS2V5KG1zZ0lkKSB7XG4gICAgY29uc3QgbWVzc2FnZU1hbmFnZXIgPSB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyO1xuICAgIG1lc3NhZ2VNYW5hZ2VyLnJlamVjdE1zZyhtc2dJZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8vIGV0aF9zaWduVHlwZWREYXRhIG1ldGhvZHNcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBkYXBwIHVzZXMgdGhlIGV0aF9zaWduVHlwZWREYXRhIG1ldGhvZCwgcGVyIEVJUCA3MTIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIHBhc3NlZCB0byBldGhfc2lnblR5cGVkRGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QsIGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICovXG4gIG5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgcmVxLFxuICAgICAgdmVyc2lvbixcbiAgICApO1xuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICAgIHRoaXMub3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZm9yIGEgdXNlciBhcHByb3ZpbmcgYSBjYWxsIHRvIGV0aF9zaWduVHlwZWREYXRhLCBwZXIgRUlQIDcxMi5cbiAgICogVHJpZ2dlcnMgdGhlIGNhbGxiYWNrIGluIG5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBwYXNzZWQgdG8gZXRoX3NpZ25UeXBlZERhdGEuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgc2lnblR5cGVkTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX3NpZ25UeXBlZERhdGEnKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gbXNnUGFyYW1zO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIGV2ZXJ5IHZlcnNpb24gYWZ0ZXIgVjEgdXNlZCBzdHJpbmdpZmllZCBwYXJhbXMuXG4gICAgICBpZiAodmVyc2lvbiAhPT0gJ1YxJykge1xuICAgICAgICAvLyBCdXQgd2UgZG9uJ3QgaGF2ZSB0byByZXF1aXJlIHRoYXQuIFdlIGNhbiBzdG9wIHN1Z2dlc3RpbmcgaXQgbm93OlxuICAgICAgICBpZiAodHlwZW9mIGNsZWFuTXNnUGFyYW1zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2xlYW5Nc2dQYXJhbXMuZGF0YSA9IEpTT04ucGFyc2UoY2xlYW5Nc2dQYXJhbXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduVHlwZWRNZXNzYWdlKFxuICAgICAgICBjbGVhbk1zZ1BhcmFtcyxcbiAgICAgICAgeyB2ZXJzaW9uIH0sXG4gICAgICApO1xuICAgICAgdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfc2lnblR5cGVkRGF0YSBmYWlsZWQuJywgZXJyb3IpO1xuICAgICAgdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgZXRoX3NpZ25UeXBlZERhdGEgdHlwZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsVHlwZWRNZXNzYWdlKG1zZ0lkKSB7XG4gICAgY29uc3QgbWVzc2FnZU1hbmFnZXIgPSB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXlyaW5nIHR5cGUgc3VwcG9ydHMgRUlQLTE1NTlcbiAgICovXG4gIGFzeW5jIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEVORCAoVkFVTFQgLyBLRVlSSU5HIFJFTEFURUQgTUVUSE9EUylcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGF0dGVtcHQgdG8gY2FuY2VsIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cbiAgICogYnkgY3JlYXRpbmcgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvXG4gICAqICBhdHRlbXB0IHRvIGNhbmNlbFxuICAgKiBAcGFyYW0ge2ltcG9ydChcbiAgICogICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucydcbiAgICogKS5DdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyB0byB1c2UgZm9yIGdhcyBwYXJhbXNcbiAgICogIGluc3RlYWQgb2YgYWxsb3dpbmcgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlbVxuICAgKiBAcGFyYW0gbmV3VHhNZXRhUHJvcHNcbiAgICogQHJldHVybnMge09iamVjdH0gTWV0YU1hc2sgc3RhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNhbmNlbFRyYW5zYWN0aW9uKFxuICAgIG9yaWdpbmFsVHhJZCxcbiAgICBjdXN0b21HYXNTZXR0aW5ncyxcbiAgICBuZXdUeE1ldGFQcm9wcyxcbiAgKSB7XG4gICAgYXdhaXQgdGhpcy50eENvbnRyb2xsZXIuY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24oXG4gICAgICBvcmlnaW5hbFR4SWQsXG4gICAgICBjdXN0b21HYXNTZXR0aW5ncyxcbiAgICAgIG5ld1R4TWV0YVByb3BzLFxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gYXR0ZW1wdCB0byBzcGVlZCB1cCBhIHByZXZpb3VzbHkgc3VibWl0dGVkIHRyYW5zYWN0aW9uXG4gICAqIGJ5IGNyZWF0aW5nIGEgbmV3IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxUeElkIC0gdGhlIGlkIG9mIHRoZSB0eE1ldGEgdGhhdCB5b3Ugd2FudCB0b1xuICAgKiAgYXR0ZW1wdCB0byBzcGVlZCB1cFxuICAgKiBAcGFyYW0ge2ltcG9ydChcbiAgICogICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucydcbiAgICogKS5DdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyB0byB1c2UgZm9yIGdhcyBwYXJhbXNcbiAgICogIGluc3RlYWQgb2YgYWxsb3dpbmcgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgdGhlbVxuICAgKiBAcGFyYW0gbmV3VHhNZXRhUHJvcHNcbiAgICogQHJldHVybnMge09iamVjdH0gTWV0YU1hc2sgc3RhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbihcbiAgICBvcmlnaW5hbFR4SWQsXG4gICAgY3VzdG9tR2FzU2V0dGluZ3MsXG4gICAgbmV3VHhNZXRhUHJvcHMsXG4gICkge1xuICAgIGF3YWl0IHRoaXMudHhDb250cm9sbGVyLmNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbihcbiAgICAgIG9yaWdpbmFsVHhJZCxcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgbmV3VHhNZXRhUHJvcHMsXG4gICAgKTtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBlc3RpbWF0ZUdhcyhlc3RpbWF0ZUdhc1BhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50eENvbnRyb2xsZXIudHhHYXNVdGlsLnF1ZXJ5LmVzdGltYXRlR2FzKFxuICAgICAgICBlc3RpbWF0ZUdhc1BhcmFtcyxcbiAgICAgICAgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcy50b1N0cmluZygxNikpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUEFTU1dPUkQgTUFOQUdFTUVOVFxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gYmVnaW4gdGhlIHNlZWQgcGhyYXNlIHJlY292ZXJ5IHByb2Nlc3MuXG4gICAqL1xuICBtYXJrUGFzc3dvcmRGb3Jnb3R0ZW4oKSB7XG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0UGFzc3dvcmRGb3Jnb3R0ZW4odHJ1ZSk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBlbmQgdGhlIHNlZWQgcGhyYXNlIHJlY292ZXJ5IHByb2Nlc3MuXG4gICAqL1xuICB1bk1hcmtQYXNzd29yZEZvcmdvdHRlbigpIHtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRQYXNzd29yZEZvcmdvdHRlbihmYWxzZSk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNFVFVQXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQSBydW50aW1lLk1lc3NhZ2VTZW5kZXIgb2JqZWN0LCBhcyBwcm92aWRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICpcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL01vemlsbGEvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9ydW50aW1lL01lc3NhZ2VTZW5kZXJcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZVNlbmRlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gLSBUaGUgVVJMIG9mIHRoZSBwYWdlIG9yIGZyYW1lIGhvc3RpbmcgdGhlIHNjcmlwdCB0aGF0IHNlbnQgdGhlIG1lc3NhZ2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIFNuYXAgc2VuZGVyIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gU25hcFNlbmRlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc25hcElkIC0gVGhlIElEIG9mIHRoZSBzbmFwLlxuICAgKi9cblxuICAvKipcbiAgICogVXNlZCB0byBjcmVhdGUgYSBtdWx0aXBsZXhlZCBzdHJlYW0gZm9yIGNvbm5lY3RpbmcgdG8gYW4gdW50cnVzdGVkIGNvbnRleHRcbiAgICogbGlrZSBhIERhcHAgb3Igb3RoZXIgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtfSBvcHRpb25zLmNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgRHVwbGV4IHN0cmVhbSB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBvcHRpb25zLnNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ViamVjdFR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciwgaS5lLiBzdWJqZWN0LlxuICAgKi9cbiAgc2V0dXBVbnRydXN0ZWRDb21tdW5pY2F0aW9uKHsgY29ubmVjdGlvblN0cmVhbSwgc2VuZGVyLCBzdWJqZWN0VHlwZSB9KSB7XG4gICAgY29uc3QgeyB1c2VQaGlzaERldGVjdCB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGxldCBfc3ViamVjdFR5cGU7XG4gICAgaWYgKHN1YmplY3RUeXBlKSB7XG4gICAgICBfc3ViamVjdFR5cGUgPSBzdWJqZWN0VHlwZTtcbiAgICB9IGVsc2UgaWYgKHNlbmRlci5pZCAmJiBzZW5kZXIuaWQgIT09IHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuaWQpIHtcbiAgICAgIF9zdWJqZWN0VHlwZSA9IFNVQkpFQ1RfVFlQRVMuRVhURU5TSU9OO1xuICAgIH0gZWxzZSB7XG4gICAgICBfc3ViamVjdFR5cGUgPSBTVUJKRUNUX1RZUEVTLldFQlNJVEU7XG4gICAgfVxuXG4gICAgaWYgKHNlbmRlci51cmwpIHtcbiAgICAgIGNvbnN0IHsgaG9zdG5hbWUgfSA9IG5ldyBVUkwoc2VuZGVyLnVybCk7XG4gICAgICAvLyBDaGVjayBpZiBuZXcgY29ubmVjdGlvbiBpcyBibG9ja2VkIGlmIHBoaXNoaW5nIGRldGVjdGlvbiBpcyBvblxuICAgICAgaWYgKHVzZVBoaXNoRGV0ZWN0ICYmIHRoaXMucGhpc2hpbmdDb250cm9sbGVyLnRlc3QoaG9zdG5hbWUpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnTWV0YU1hc2sgLSBzZW5kaW5nIHBoaXNoaW5nIHdhcm5pbmcgZm9yJywgaG9zdG5hbWUpO1xuICAgICAgICB0aGlzLnNlbmRQaGlzaGluZ1dhcm5pbmcoY29ubmVjdGlvblN0cmVhbSwgaG9zdG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbXVsdGlwbGV4aW5nXG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XG5cbiAgICAvLyBtZXNzYWdlcyBiZXR3ZWVuIGlucGFnZSBhbmQgYmFja2dyb3VuZFxuICAgIHRoaXMuc2V0dXBQcm92aWRlckNvbm5lY3Rpb24oXG4gICAgICBtdXguY3JlYXRlU3RyZWFtKCdtZXRhbWFzay1wcm92aWRlcicpLFxuICAgICAgc2VuZGVyLFxuICAgICAgX3N1YmplY3RUeXBlLFxuICAgICk7XG5cbiAgICAvLyBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICBpZiAoc2VuZGVyLnVybCkge1xuICAgICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICAgIHRoaXMuc2V0dXBQdWJsaWNDb25maWcobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhIHRydXN0ZWQgY29udGV4dCxcbiAgICogbGlrZSBvdXIgb3duIHVzZXIgaW50ZXJmYWNlcywgd2hpY2ggaGF2ZSB0aGUgcHJvdmlkZXIgQVBJcywgYnV0IGFsc29cbiAgICogcmVjZWl2ZSB0aGUgZXhwb3J0ZWQgQVBJIGZyb20gdGhpcyBjb250cm9sbGVyLCB3aGljaCBpbmNsdWRlcyB0cnVzdGVkXG4gICAqIGZ1bmN0aW9ucywgbGlrZSB0aGUgYWJpbGl0eSB0byBhcHByb3ZlIHRyYW5zYWN0aW9ucyBvciBzaWduIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgZHVwbGV4IHN0cmVhbSB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtXG4gICAqL1xuICBzZXR1cFRydXN0ZWRDb21tdW5pY2F0aW9uKGNvbm5lY3Rpb25TdHJlYW0sIHNlbmRlcikge1xuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuICAgIC8vIGNvbm5lY3QgZmVhdHVyZXNcbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24obXV4LmNyZWF0ZVN0cmVhbSgnY29udHJvbGxlcicpKTtcbiAgICB0aGlzLnNldHVwUHJvdmlkZXJDb25uZWN0aW9uKFxuICAgICAgbXV4LmNyZWF0ZVN0cmVhbSgncHJvdmlkZXInKSxcbiAgICAgIHNlbmRlcixcbiAgICAgIFNVQkpFQ1RfVFlQRVMuSU5URVJOQUwsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB3ZSBkZXRlY3QgYSBzdXNwaWNpb3VzIGRvbWFpbi4gUmVxdWVzdHMgdGhlIGJyb3dzZXIgcmVkaXJlY3RzXG4gICAqIHRvIG91ciBhbnRpLXBoaXNoaW5nIHBhZ2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gY29ubmVjdGlvblN0cmVhbSAtIFRoZSBkdXBsZXggc3RyZWFtIHRvIHRoZSBwZXItcGFnZSBzY3JpcHQsXG4gICAqIGZvciBzZW5kaW5nIHRoZSByZWxvYWQgYXR0ZW1wdCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gVGhlIGhvc3RuYW1lIHRoYXQgdHJpZ2dlcmVkIHRoZSBzdXNwaWNpb24uXG4gICAqL1xuICBzZW5kUGhpc2hpbmdXYXJuaW5nKGNvbm5lY3Rpb25TdHJlYW0sIGhvc3RuYW1lKSB7XG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XG4gICAgY29uc3QgcGhpc2hpbmdTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKCdwaGlzaGluZycpO1xuICAgIHBoaXNoaW5nU3RyZWFtLndyaXRlKHsgaG9zdG5hbWUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHByb3ZpZGluZyBvdXIgQVBJIG92ZXIgYSBzdHJlYW0gdXNpbmcgSlNPTi1SUEMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIG91ciBBUEkgb3Zlci5cbiAgICovXG4gIHNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24ob3V0U3RyZWFtKSB7XG4gICAgY29uc3QgYXBpID0gdGhpcy5nZXRBcGkoKTtcblxuICAgIC8vIHJlcG9ydCBuZXcgYWN0aXZlIGNvbnRyb2xsZXIgY29ubmVjdGlvblxuICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zICs9IDE7XG4gICAgdGhpcy5lbWl0KCdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLCB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyk7XG5cbiAgICAvLyBzZXQgdXAgcG9zdFN0cmVhbSB0cmFuc3BvcnRcbiAgICBvdXRTdHJlYW0ub24oJ2RhdGEnLCBjcmVhdGVNZXRhUlBDSGFuZGxlcihhcGksIG91dFN0cmVhbSkpO1xuICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICh1cGRhdGUpID0+IHtcbiAgICAgIGlmIChvdXRTdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gc2VuZCBub3RpZmljYXRpb24gdG8gY2xpZW50LXNpZGVcbiAgICAgIG91dFN0cmVhbS53cml0ZSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdzZW5kVXBkYXRlJyxcbiAgICAgICAgcGFyYW1zOiBbdXBkYXRlXSxcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICBvdXRTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zIC09IDE7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgICdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLFxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyxcbiAgICAgICk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBzZXJ2aW5nIG91ciBldGhlcmV1bSBwcm92aWRlciBvdmVyIGEgZ2l2ZW4gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBvdmVyLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViamVjdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc2VuZGVyLCBpLmUuIHN1YmplY3QuXG4gICAqL1xuICBzZXR1cFByb3ZpZGVyQ29ubmVjdGlvbihvdXRTdHJlYW0sIHNlbmRlciwgc3ViamVjdFR5cGUpIHtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGlmIChzdWJqZWN0VHlwZSA9PT0gU1VCSkVDVF9UWVBFUy5JTlRFUk5BTCkge1xuICAgICAgb3JpZ2luID0gJ21ldGFtYXNrJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcmlnaW4gPSBuZXcgVVJMKHNlbmRlci51cmwpLm9yaWdpbjtcbiAgICB9XG5cbiAgICBpZiAoc2VuZGVyLmlkICYmIHNlbmRlci5pZCAhPT0gdGhpcy5leHRlbnNpb24ucnVudGltZS5pZCkge1xuICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YSh7XG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgZXh0ZW5zaW9uSWQ6IHNlbmRlci5pZCxcbiAgICAgICAgc3ViamVjdFR5cGU6IFNVQkpFQ1RfVFlQRVMuRVhURU5TSU9OLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHRhYklkO1xuICAgIGlmIChzZW5kZXIudGFiICYmIHNlbmRlci50YWIuaWQpIHtcbiAgICAgIHRhYklkID0gc2VuZGVyLnRhYi5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLnNldHVwUHJvdmlkZXJFbmdpbmUoe1xuICAgICAgb3JpZ2luLFxuICAgICAgc2VuZGVyLFxuICAgICAgc3ViamVjdFR5cGUsXG4gICAgICB0YWJJZCxcbiAgICB9KTtcblxuICAgIC8vIHNldHVwIGNvbm5lY3Rpb25cbiAgICBjb25zdCBwcm92aWRlclN0cmVhbSA9IGNyZWF0ZUVuZ2luZVN0cmVhbSh7IGVuZ2luZSB9KTtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IHRoaXMuYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pO1xuXG4gICAgcHVtcChvdXRTdHJlYW0sIHByb3ZpZGVyU3RyZWFtLCBvdXRTdHJlYW0sIChlcnIpID0+IHtcbiAgICAgIC8vIGhhbmRsZSBhbnkgbWlkZGxld2FyZSBjbGVhbnVwXG4gICAgICBlbmdpbmUuX21pZGRsZXdhcmUuZm9yRWFjaCgobWlkKSA9PiB7XG4gICAgICAgIGlmIChtaWQuZGVzdHJveSAmJiB0eXBlb2YgbWlkLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtaWQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3Rpb25JZCAmJiB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBjcmVhdGluZyBhIHByb3ZpZGVyIHRoYXQgaXMgc2FmZWx5IHJlc3RyaWN0ZWQgZm9yIHRoZSByZXF1ZXN0aW5nIHN1YmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvdmlkZXIgZW5naW5lIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc2VuZGVyXG4gICAqIEBwYXJhbSB7TWVzc2FnZVNlbmRlciB8IFNuYXBTZW5kZXJ9IG9wdGlvbnMuc2VuZGVyIC0gVGhlIHNlbmRlciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YmplY3RUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNlbmRlciBzdWJqZWN0LlxuICAgKiBAcGFyYW0ge3RhYklkfSBbb3B0aW9ucy50YWJJZF0gLSBUaGUgdGFiIElEIG9mIHRoZSBzZW5kZXIgLSBpZiB0aGUgc2VuZGVyIGlzIHdpdGhpbiBhIHRhYlxuICAgKi9cbiAgc2V0dXBQcm92aWRlckVuZ2luZSh7IG9yaWdpbiwgc3ViamVjdFR5cGUsIHNlbmRlciwgdGFiSWQgfSkge1xuICAgIC8vIHNldHVwIGpzb24gcnBjIGVuZ2luZSBzdGFja1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKc29uUnBjRW5naW5lKCk7XG4gICAgY29uc3QgeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0gPSB0aGlzO1xuXG4gICAgLy8gY3JlYXRlIGZpbHRlciBwb2x5ZmlsbCBtaWRkbGV3YXJlXG4gICAgY29uc3QgZmlsdGVyTWlkZGxld2FyZSA9IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyIH0pO1xuXG4gICAgLy8gY3JlYXRlIHN1YnNjcmlwdGlvbiBwb2x5ZmlsbCBtaWRkbGV3YXJlXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIoe1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBibG9ja1RyYWNrZXIsXG4gICAgfSk7XG4gICAgc3Vic2NyaXB0aW9uTWFuYWdlci5ldmVudHMub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PlxuICAgICAgZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIG1lc3NhZ2UpLFxuICAgICk7XG5cbiAgICAvLyBhcHBlbmQgb3JpZ2luIHRvIGVhY2ggcmVxdWVzdFxuICAgIGVuZ2luZS5wdXNoKGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUoeyBvcmlnaW4gfSkpO1xuXG4gICAgLy8gYXBwZW5kIHRhYklkIHRvIGVhY2ggcmVxdWVzdCBpZiBpdCBleGlzdHNcbiAgICBpZiAodGFiSWQpIHtcbiAgICAgIGVuZ2luZS5wdXNoKGNyZWF0ZVRhYklkTWlkZGxld2FyZSh7IHRhYklkIH0pKTtcbiAgICB9XG5cbiAgICAvLyBsb2dnaW5nXG4gICAgZW5naW5lLnB1c2goY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSh7IG9yaWdpbiB9KSk7XG4gICAgZW5naW5lLnB1c2godGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci5jcmVhdGVNaWRkbGV3YXJlKCkpO1xuXG4gICAgLy8gb25ib2FyZGluZ1xuICAgIGlmIChzdWJqZWN0VHlwZSA9PT0gU1VCSkVDVF9UWVBFUy5XRUJTSVRFKSB7XG4gICAgICBlbmdpbmUucHVzaChcbiAgICAgICAgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUoe1xuICAgICAgICAgIGxvY2F0aW9uOiBzZW5kZXIudXJsLFxuICAgICAgICAgIHJlZ2lzdGVyT25ib2FyZGluZzogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5yZWdpc3Rlck9uYm9hcmRpbmcsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBVbnJlc3RyaWN0ZWQvcGVybWlzc2lvbmxlc3MgUlBDIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnNcbiAgICBlbmdpbmUucHVzaChcbiAgICAgIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoe1xuICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgc3ViamVjdFR5cGUsXG5cbiAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICBhZGRTdWJqZWN0TWV0YWRhdGE6IHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5hZGRTdWJqZWN0TWV0YWRhdGEuYmluZChcbiAgICAgICAgICB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGdldFByb3ZpZGVyU3RhdGU6IHRoaXMuZ2V0UHJvdmlkZXJTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRVbmxvY2tQcm9taXNlOiB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5nZXRVbmxvY2tQcm9taXNlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGhhbmRsZVdhdGNoQXNzZXRSZXF1ZXN0OiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIud2F0Y2hBc3NldC5iaW5kKFxuICAgICAgICAgIHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgcmVxdWVzdFVzZXJBcHByb3ZhbDogdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdC5iaW5kKFxuICAgICAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBzZW5kTWV0cmljczogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIFBlcm1pc3Npb24tcmVsYXRlZFxuICAgICAgICBnZXRBY2NvdW50czogdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cy5iaW5kKHRoaXMsIG9yaWdpbiksXG4gICAgICAgIGdldFBlcm1pc3Npb25zRm9yT3JpZ2luOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmdldFBlcm1pc3Npb25zLmJpbmQoXG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICksXG4gICAgICAgIGhhc1Blcm1pc3Npb246IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuaGFzUGVybWlzc2lvbi5iaW5kKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICApLFxuICAgICAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgeyBvcmlnaW4gfSxcbiAgICAgICAgICB7IGV0aF9hY2NvdW50czoge30gfSxcbiAgICAgICAgKSxcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25zRm9yT3JpZ2luOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgeyBvcmlnaW4gfSxcbiAgICAgICAgKSxcblxuICAgICAgICAvLyBDdXN0b20gUlBDLXJlbGF0ZWRcbiAgICAgICAgYWRkQ3VzdG9tUnBjOiBhc3luYyAoe1xuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgYmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgY2hhaW5OYW1lLFxuICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkVG9GcmVxdWVudFJwY0xpc3QoXG4gICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgdGlja2VyLFxuICAgICAgICAgICAgY2hhaW5OYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kQ3VzdG9tUnBjQnk6IHRoaXMuZmluZEN1c3RvbVJwY0J5LmJpbmQodGhpcyksXG4gICAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgc2V0UHJvdmlkZXJUeXBlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFByb3ZpZGVyVHlwZS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHVwZGF0ZVJwY1RhcmdldDogKHsgcnBjVXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lIH0pID0+IHtcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFJwY1RhcmdldChcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdlYjMgc2hpbS1yZWxhdGVkXG4gICAgICAgIGdldFdlYjNTaGltVXNhZ2VTdGF0ZTogdGhpcy5hbGVydENvbnRyb2xsZXIuZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hbGVydENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHNldFdlYjNTaGltVXNhZ2VSZWNvcmRlZDogdGhpcy5hbGVydENvbnRyb2xsZXIuc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkLmJpbmQoXG4gICAgICAgICAgdGhpcy5hbGVydENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICApO1xuXG5cbiAgICAvLyBmaWx0ZXIgYW5kIHN1YnNjcmlwdGlvbiBwb2x5ZmlsbHNcbiAgICBlbmdpbmUucHVzaChmaWx0ZXJNaWRkbGV3YXJlKTtcbiAgICBlbmdpbmUucHVzaChzdWJzY3JpcHRpb25NYW5hZ2VyLm1pZGRsZXdhcmUpO1xuICAgIGlmIChzdWJqZWN0VHlwZSAhPT0gU1VCSkVDVF9UWVBFUy5JTlRFUk5BTCkge1xuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIGVuZ2luZS5wdXNoKFxuICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHtcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBmb3J3YXJkIHRvIG1ldGFtYXNrIHByaW1hcnkgcHJvdmlkZXJcbiAgICBlbmdpbmUucHVzaChwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikpO1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIHB1YmxpYyBjb25maWcgaW5mbyBvdmVyIGEgc3RyZWFtLlxuICAgKiBUaGlzIGluY2x1ZGVzIGluZm8gd2UgbGlrZSB0byBiZSBzeW5jaHJvbm91cyBpZiBwb3NzaWJsZSwgbGlrZVxuICAgKiB0aGUgY3VycmVudCBzZWxlY3RlZCBhY2NvdW50LCBhbmQgbmV0d29yayBJRC5cbiAgICpcbiAgICogU2luY2Ugc3luY2hyb25vdXMgbWV0aG9kcyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBpbiB3ZWIzLFxuICAgKiB0aGlzIGlzIGEgZ29vZCBjYW5kaWRhdGUgZm9yIGRlcHJlY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBwdWJsaWMgY29uZmlnIG92ZXIuXG4gICAqL1xuICBzZXR1cFB1YmxpY0NvbmZpZyhvdXRTdHJlYW0pIHtcbiAgICBjb25zdCBjb25maWdTdHJlYW0gPSBzdG9yZUFzU3RyZWFtKHRoaXMucHVibGljQ29uZmlnU3RvcmUpO1xuXG4gICAgcHVtcChjb25maWdTdHJlYW0sIG91dFN0cmVhbSwgKGVycikgPT4ge1xuICAgICAgY29uZmlnU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlZmVyZW5jZSB0byBhIGNvbm5lY3Rpb24gYnkgb3JpZ2luLiBJZ25vcmVzIHRoZSAnbWV0YW1hc2snIG9yaWdpbi5cbiAgICogQ2FsbGVyIG11c3QgZW5zdXJlIHRoYXQgdGhlIHJldHVybmVkIGlkIGlzIHN0b3JlZCBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZVxuICAgKiBjYW4gYmUgZGVsZXRlZCBsYXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBjb25uZWN0aW9uJ3Mgb3JpZ2luIHN0cmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgY29ubmVjdGlvbidzIEpTT04gUnBjIEVuZ2luZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29ubmVjdGlvbidzIGlkIChzbyB0aGF0IGl0IGNhbiBiZSBkZWxldGVkIGxhdGVyKVxuICAgKi9cbiAgYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pIHtcbiAgICBpZiAob3JpZ2luID09PSAnbWV0YW1hc2snKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dID0ge307XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl1baWRdID0ge1xuICAgICAgZW5naW5lLFxuICAgIH07XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIHJlZmVyZW5jZSB0byBhIGNvbm5lY3Rpb24sIGJ5IG9yaWdpbiBhbmQgaWQuXG4gICAqIElnbm9yZXMgdW5rbm93biBvcmlnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIGNvbm5lY3Rpb24ncyBvcmlnaW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgY29ubmVjdGlvbidzIGlkLCBhcyByZXR1cm5lZCBmcm9tIGFkZENvbm5lY3Rpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKG9yaWdpbiwgaWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcbiAgICBpZiAoIWNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIGNvbm5lY3Rpb25zW2lkXTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhjb25uZWN0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgYWxsIGNvbm5lY3Rpb25zIGZvciB0aGUgZ2l2ZW4gb3JpZ2luLCBhbmQgcmVtb3ZlcyB0aGUgcmVmZXJlbmNlc1xuICAgKiB0byB0aGVtLlxuICAgKiBJZ25vcmVzIHVua25vd24gb3JpZ2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gc3RyaW5nLlxuICAgKi9cbiAgcmVtb3ZlQWxsQ29ubmVjdGlvbnMob3JpZ2luKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XG4gICAgaWYgKCFjb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aW9uKG9yaWdpbiwgaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25uZWN0aW9ucyB0byB0aGUgZ2l2ZW4gb3JpZ2luXG4gICAqIHRvIGVtaXQgYSBub3RpZmljYXRpb24gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGF5bG9hZC5cbiAgICpcbiAgICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCBvbmx5IHBlcm1pdHRlZCBub3RpZmljYXRpb25zXG4gICAqIGFyZSBzZW50LlxuICAgKlxuICAgKiBJZ25vcmVzIHVua25vd24gb3JpZ2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBjb25uZWN0aW9uJ3Mgb3JpZ2luIHN0cmluZy5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuXG4gICAqL1xuICBub3RpZnlDb25uZWN0aW9ucyhvcmlnaW4sIHBheWxvYWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcblxuICAgIGlmIChjb25uZWN0aW9ucykge1xuICAgICAgT2JqZWN0LnZhbHVlcyhjb25uZWN0aW9ucykuZm9yRWFjaCgoY29ubikgPT4ge1xuICAgICAgICBpZiAoY29ubi5lbmdpbmUpIHtcbiAgICAgICAgICBjb25uLmVuZ2luZS5lbWl0KCdub3RpZmljYXRpb24nLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgUlBDIGVuZ2luZXMgYXNzb2NpYXRlZCB3aXRoIGFsbCBjb25uZWN0aW9ucyB0byBlbWl0IGFcbiAgICogbm90aWZpY2F0aW9uIGV2ZW50IHdpdGggdGhlIGdpdmVuIHBheWxvYWQuXG4gICAqXG4gICAqIElmIHRoZSBcInBheWxvYWRcIiBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhlIHBheWxvYWQgZm9yIGVhY2ggY29ubmVjdGlvblxuICAgKiB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhhdCBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgY29ubmVjdGlvbidzXG4gICAqIG9yaWdpbi5cbiAgICpcbiAgICogVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgdGhhdCBvbmx5IHBlcm1pdHRlZCBub3RpZmljYXRpb25zXG4gICAqIGFyZSBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZCwgb3IgcGF5bG9hZCBnZXR0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBub3RpZnlBbGxDb25uZWN0aW9ucyhwYXlsb2FkKSB7XG4gICAgY29uc3QgZ2V0UGF5bG9hZCA9XG4gICAgICB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChvcmlnaW4pID0+IHBheWxvYWQob3JpZ2luKVxuICAgICAgICA6ICgpID0+IHBheWxvYWQ7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5mb3JFYWNoKChvcmlnaW4pID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dKS5mb3JFYWNoKGFzeW5jIChjb25uKSA9PiB7XG4gICAgICAgIGlmIChjb25uLmVuZ2luZSkge1xuICAgICAgICAgIGNvbm4uZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIGF3YWl0IGdldFBheWxvYWQob3JpZ2luKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaGFuZGxlcnNcblxuICAvKipcbiAgICogSGFuZGxlIGEgS2V5cmluZ0NvbnRyb2xsZXIgdXBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIHRoZSBLQyBzdGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9vbktleXJpbmdDb250cm9sbGVyVXBkYXRlKHN0YXRlKSB7XG4gICAgY29uc3QgeyBrZXlyaW5ncyB9ID0gc3RhdGU7XG4gICAgY29uc3QgYWRkcmVzc2VzID0ga2V5cmluZ3MucmVkdWNlKFxuICAgICAgKGFjYywgeyBhY2NvdW50cyB9KSA9PiBhY2MuY29uY2F0KGFjY291bnRzKSxcbiAgICAgIFtdLFxuICAgICk7XG5cbiAgICBpZiAoIWFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgcHJlZmVyZW5jZXMgKyBpZGVudGl0aWVzIGNvbnRyb2xsZXIga25vdyBhYm91dCBhbGwgYWRkcmVzc2VzXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3luY0FkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3luY1dpdGhBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZ2xvYmFsIGFwcGxpY2F0aW9uIHVubG9jay5cbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZCwgYW5kIHdoaWNoXG4gICAqIGFjY291bnQocykgYXJlIGN1cnJlbnRseSBhY2Nlc3NpYmxlLCBpZiBhbnkuXG4gICAqL1xuICBfb25VbmxvY2soKSB7XG4gICAgdGhpcy5ub3RpZnlBbGxDb25uZWN0aW9ucyhhc3luYyAob3JpZ2luKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy51bmxvY2tTdGF0ZUNoYW5nZWQsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGlzVW5sb2NrZWQ6IHRydWUsXG4gICAgICAgICAgYWNjb3VudHM6IGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBJbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiwgdGhpcyBoYW5kbGVyIGlzIHRyaWdnZXJlZCBieSBhXG4gICAgLy8gS2V5cmluZ0NvbnRyb2xsZXIgZXZlbnQuIE90aGVyIGNvbnRyb2xsZXJzIHN1YnNjcmliZSB0byB0aGUgJ3VubG9jaydcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cbiAgICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBnbG9iYWwgYXBwbGljYXRpb24gbG9jay5cbiAgICogTm90aWZpZXMgYWxsIGNvbm5lY3Rpb25zIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBsb2NrZWQuXG4gICAqL1xuICBfb25Mb2NrKCkge1xuICAgIHRoaXMubm90aWZ5QWxsQ29ubmVjdGlvbnMoe1xuICAgICAgbWV0aG9kOiBOT1RJRklDQVRJT05fTkFNRVMudW5sb2NrU3RhdGVDaGFuZ2VkLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIEluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCB0aGlzIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIGJ5IGFcbiAgICAvLyBLZXlyaW5nQ29udHJvbGxlciBldmVudC4gT3RoZXIgY29udHJvbGxlcnMgc3Vic2NyaWJlIHRvIHRoZSAnbG9jaydcbiAgICAvLyBldmVudCBvZiB0aGUgTWV0YU1hc2tDb250cm9sbGVyIGl0c2VsZi5cbiAgICB0aGlzLmVtaXQoJ2xvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgbWVtb3J5IHN0YXRlIHVwZGF0ZXMuXG4gICAqIC0gRW5zdXJlIGlzQ2xpZW50T3BlbkFuZFVubG9ja2VkIGlzIHVwZGF0ZWRcbiAgICogLSBOb3RpZmllcyBhbGwgY29ubmVjdGlvbnMgd2l0aCB0aGUgbmV3IHByb3ZpZGVyIG5ldHdvcmsgc3RhdGVcbiAgICogICAtIFRoZSBleHRlcm5hbCBwcm92aWRlcnMgaGFuZGxlIGRpZmZpbmcgdGhlIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBuZXdTdGF0ZVxuICAgKi9cbiAgX29uU3RhdGVVcGRhdGUobmV3U3RhdGUpIHtcbiAgICB0aGlzLmlzQ2xpZW50T3BlbkFuZFVubG9ja2VkID0gbmV3U3RhdGUuaXNVbmxvY2tlZCAmJiB0aGlzLl9pc0NsaWVudE9wZW47XG4gICAgdGhpcy5ub3RpZnlBbGxDb25uZWN0aW9ucyh7XG4gICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy5jaGFpbkNoYW5nZWQsXG4gICAgICBwYXJhbXM6IHRoaXMuZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUobmV3U3RhdGUpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gbWlzY1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3IgZW1pdHRpbmcgdGhlIGZ1bGwgTWV0YU1hc2sgc3RhdGUgdG8gYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZVNlbmRVcGRhdGUoKSB7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldFN0YXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBleHRlbnNpb24gaXMgdW5sb2NrZWQuXG4gICAqL1xuICBpc1VubG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLmdldFN0YXRlKCkuaXNVbmxvY2tlZDtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTUlTQ0VMTEFORU9VU1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZ2V0RXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gdGhpcy5zbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIGFkZHJlc3NGcm9tOiBhZGRyZXNzLFxuICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9uY2UgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uIG9uY2UgYXBwcm92ZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgaGV4IHN0cmluZyBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdOb25jZShhZGRyZXNzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2VEZXRhaWxzLFxuICAgICAgcmVsZWFzZUxvY2ssXG4gICAgfSA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soYWRkcmVzcyk7XG4gICAgY29uc3QgcGVuZGluZ05vbmNlID0gbm9uY2VEZXRhaWxzLnBhcmFtcy5oaWdoZXN0U3VnZ2VzdGVkO1xuXG4gICAgcmVsZWFzZUxvY2soKTtcbiAgICByZXR1cm4gcGVuZGluZ05vbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uY2UgYWNjb3JkaW5nIHRvIHRoZSBub25jZS10cmFja2VyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBzdHJpbmcgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAqL1xuICBhc3luYyBnZXROZXh0Tm9uY2UoYWRkcmVzcykge1xuICAgIGNvbnN0IG5vbmNlTG9jayA9IGF3YWl0IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soXG4gICAgICBhZGRyZXNzLFxuICAgICk7XG4gICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgcmV0dXJuIG5vbmNlTG9jay5uZXh0Tm9uY2U7XG4gIH1cblxuICAvKipcbiAgICogTWlncmF0ZSBhZGRyZXNzIGJvb2sgc3RhdGUgZnJvbSBvbGQgdG8gbmV3IGNoYWluSWQuXG4gICAqXG4gICAqIEFkZHJlc3MgYm9vayBzdGF0ZSBpcyBrZXllZCBieSB0aGUgYG5ldHdvcmtTdG9yZWAgc3RhdGUgZnJvbSB0aGUgbmV0d29yayBjb250cm9sbGVyLiBUaGlzIHZhbHVlIGlzIHNldCB0byB0aGVcbiAgICogYG5ldHdvcmtJZGAgZm9yIG91ciBidWlsdC1pbiBJbmZ1cmEgbmV0d29ya3MsIGJ1dCBpdCdzIHNldCB0byB0aGUgYGNoYWluSWRgIGZvciBjdXN0b20gbmV0d29ya3MuXG4gICAqIFdoZW4gdGhpcyBgY2hhaW5JZGAgdmFsdWUgaXMgY2hhbmdlZCBmb3IgY3VzdG9tIFJQQyBlbmRwb2ludHMsIHdlIG5lZWQgdG8gbWlncmF0ZSBhbnkgY29udGFjdHMgc3RvcmVkIHVuZGVyIHRoZVxuICAgKiBvbGQga2V5IHRvIHRoZSBuZXcga2V5LlxuICAgKlxuICAgKiBUaGUgYGR1cGxpY2F0ZWAgcGFyYW1ldGVyIGlzIHVzZWQgdG8gc3BlY2lmeSB0aGF0IHRoZSBjb250YWN0cyB1bmRlciB0aGUgb2xkIGtleSBzaG91bGQgbm90IGJlIHJlbW92ZWQuIFRoaXMgaXNcbiAgICogdXNlZnVsIGluIHRoZSBjYXNlIHdoZXJlIHR3byBSUEMgZW5kcG9pbnRzIHNoYXJlZCB0aGUgc2FtZSBzZXQgb2YgY29udGFjdHMsIGFuZCB3ZSdyZSBub3Qgc3VyZSB3aGljaCBvbmUgZWFjaFxuICAgKiBjb250YWN0IGJlbG9uZ3MgdW5kZXIuIER1cGxpY2F0aW5nIHRoZSBjb250YWN0cyB1bmRlciBib3RoIGtleXMgaXMgdGhlIG9ubHkgd2F5IHRvIGVuc3VyZSB0aGV5IGFyZSBub3QgbG9zdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZENoYWluSWQgLSBUaGUgb2xkIGNoYWluSWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NoYWluSWQgLSBUaGUgbmV3IGNoYWluSWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbZHVwbGljYXRlXSAtIFdoZXRoZXIgdG8gZHVwbGljYXRlIHRoZSBhZGRyZXNzZXMgb24gYm90aCBjaGFpbklkcyAoZGVmYXVsdDogZmFsc2UpXG4gICAqL1xuICBhc3luYyBtaWdyYXRlQWRkcmVzc0Jvb2tTdGF0ZShvbGRDaGFpbklkLCBuZXdDaGFpbklkLCBkdXBsaWNhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgYWRkcmVzc0Jvb2sgfSA9IHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgaWYgKCFhZGRyZXNzQm9va1tvbGRDaGFpbklkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhZGRyZXNzQm9va1tvbGRDaGFpbklkXSkpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYWRkcmVzc0Jvb2tbb2xkQ2hhaW5JZF1bYWRkcmVzc107XG4gICAgICB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlci5zZXQoXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGVudHJ5Lm5hbWUsXG4gICAgICAgIG5ld0NoYWluSWQsXG4gICAgICAgIGVudHJ5Lm1lbW8sXG4gICAgICApO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIuZGVsZXRlKG9sZENoYWluSWQsIGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09ORklHXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBMb2cgYmxvY2tzXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjdXN0b20gVVJMIGZvciBhbiBldGhlcmV1bSBSUEMgcHJvdmlkZXIgYW5kIHVwZGF0aW5nIGl0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBBIFVSTCBmb3IgYSB2YWxpZCBFdGhlcmV1bSBSUEMgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlja2VyIC0gVGhlIHRpY2tlciBzeW1ib2wgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmlja25hbWVdIC0gTmlja25hbWUgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcnBjUHJlZnNdIC0gUlBDIHByZWZlcmVuY2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JwY1ByZWZzLmJsb2NrRXhwbG9yZXJVcmxdIC0gVVJMIG9mIGJsb2NrIGV4cGxvcmVyIGZvciB0aGUgY2hhaW4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBSUEMgVGFyZ2V0IFVSTCBjb25maXJtZWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVBbmRTZXRDdXN0b21ScGMoXG4gICAgcnBjVXJsLFxuICAgIGNoYWluSWQsXG4gICAgdGlja2VyID0gJ0VUSCcsXG4gICAgbmlja25hbWUsXG4gICAgcnBjUHJlZnMsXG4gICkge1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UnBjVGFyZ2V0KFxuICAgICAgcnBjVXJsLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHRpY2tlcixcbiAgICAgIG5pY2tuYW1lLFxuICAgICAgcnBjUHJlZnMsXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci51cGRhdGVScGMoe1xuICAgICAgcnBjVXJsLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHRpY2tlcixcbiAgICAgIG5pY2tuYW1lLFxuICAgICAgcnBjUHJlZnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJwY1VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3Igc2VsZWN0aW5nIGEgY3VzdG9tIFVSTCBmb3IgYW4gZXRoZXJldW0gUlBDIHByb3ZpZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnBjVXJsIC0gQSBVUkwgZm9yIGEgdmFsaWQgRXRoZXJldW0gUlBDIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgY2hhaW5JZCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpY2tlciAtIFRoZSB0aWNrZXIgc3ltYm9sIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmlja25hbWUgLSBPcHRpb25hbCBuaWNrbmFtZSBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHJwY1ByZWZzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBSUEMgVGFyZ2V0IFVSTCBjb25maXJtZWQuXG4gICAqL1xuICBhc3luYyBzZXRDdXN0b21ScGMoXG4gICAgcnBjVXJsLFxuICAgIGNoYWluSWQsXG4gICAgdGlja2VyID0gJ0VUSCcsXG4gICAgbmlja25hbWUgPSAnJyxcbiAgICBycGNQcmVmcyA9IHt9LFxuICApIHtcbiAgICBjb25zdCBmcmVxdWVudFJwY0xpc3REZXRhaWwgPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRGcmVxdWVudFJwY0xpc3REZXRhaWwoKTtcbiAgICBjb25zdCBycGNTZXR0aW5ncyA9IGZyZXF1ZW50UnBjTGlzdERldGFpbC5maW5kKFxuICAgICAgKHJwYykgPT4gcnBjVXJsID09PSBycGMucnBjVXJsLFxuICAgICk7XG5cbiAgICBpZiAocnBjU2V0dGluZ3MpIHtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc2V0UnBjVGFyZ2V0KFxuICAgICAgICBycGNTZXR0aW5ncy5ycGNVcmwsXG4gICAgICAgIHJwY1NldHRpbmdzLmNoYWluSWQsXG4gICAgICAgIHJwY1NldHRpbmdzLnRpY2tlcixcbiAgICAgICAgcnBjU2V0dGluZ3Mubmlja25hbWUsXG4gICAgICAgIHJwY1ByZWZzLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRScGNUYXJnZXQoXG4gICAgICAgIHJwY1VybCxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdGlja2VyLFxuICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgcnBjUHJlZnMsXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkVG9GcmVxdWVudFJwY0xpc3QoXG4gICAgICAgIHJwY1VybCxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdGlja2VyLFxuICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgcnBjUHJlZnMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcnBjVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBkZWxldGluZyBhIHNlbGVjdGVkIGN1c3RvbSBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBBIFJQQyBVUkwgdG8gZGVsZXRlLlxuICAgKi9cbiAgYXN5bmMgZGVsQ3VzdG9tUnBjKHJwY1VybCkge1xuICAgIGF3YWl0IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUZyb21GcmVxdWVudFJwY0xpc3QocnBjVXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBSUEMgaW5mbyBvYmplY3QgdGhhdCBtYXRjaGVzIGF0IGxlYXN0IG9uZSBmaWVsZCBvZiB0aGVcbiAgICogcHJvdmlkZWQgc2VhcmNoIGNyaXRlcmlhLiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJwY0luZm8gLSBUaGUgUlBDIGVuZHBvaW50IHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBjaGVjay5cbiAgICogQHJldHVybnMge09iamVjdH0gcnBjSW5mbyBmb3VuZCBpbiB0aGUgZnJlcXVlbnRScGNMaXN0XG4gICAqL1xuICBmaW5kQ3VzdG9tUnBjQnkocnBjSW5mbykge1xuICAgIGNvbnN0IGZyZXF1ZW50UnBjTGlzdERldGFpbCA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgIGZvciAoY29uc3QgZXhpc3RpbmdScGNJbmZvIG9mIGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocnBjSW5mbykpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nUnBjSW5mb1trZXldID09PSBycGNJbmZvW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdScGNJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZVRocmVlQm94KCkge1xuICAgIGF3YWl0IHRoaXMudGhyZWVCb3hDb250cm9sbGVyLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBMZWRnZXIgTGl2ZSBwcmVmZXJlbmNlIHRvIHVzZSBmb3IgTGVkZ2VyIGhhcmR3YXJlIHdhbGxldCBzdXBwb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc3BvcnRUeXBlIC0gVGhlIExlZGdlciB0cmFuc3BvcnQgdHlwZS5cbiAgICovXG4gIGFzeW5jIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0VHlwZSkge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoXG4gICAgICB0cmFuc3BvcnRUeXBlLFxuICAgICk7XG5cbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yRGV2aWNlKERFVklDRV9OQU1FUy5MRURHRVIpO1xuICAgIGlmIChrZXlyaW5nPy51cGRhdGVUcmFuc3BvcnRNZXRob2QpIHtcbiAgICAgIHJldHVybiBrZXlyaW5nLnVwZGF0ZVRyYW5zcG9ydE1ldGhvZChuZXdWYWx1ZSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHVwZGF0aW5nIHRoZSB0cmFuc3BvcnQsIHdlIHNob3VsZFxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoY3VycmVudFZhbHVlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIGluaXRpYWxpemluZyBzdG9yYWdlIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdFN0YXRlIC0gVGhlIGRlZmF1bHQgc3RhdGUgdG8gaW5pdGlhbGl6ZSB3aXRoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVjb3JkRmlyc3RUaW1lSW5mbyhpbml0U3RhdGUpIHtcbiAgICBpZiAoISgnZmlyc3RUaW1lSW5mbycgaW4gaW5pdFN0YXRlKSkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpO1xuICAgICAgaW5pdFN0YXRlLmZpcnN0VGltZUluZm8gPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGRhdGU6IERhdGUubm93KCksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IFJlcGxhY2UgaXNDbGllbnRPcGVuIG1ldGhvZHMgd2l0aCBgY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkYCBldmVudHMuXG4gIC8qIGVzbGludC1kaXNhYmxlIGFjY2Vzc29yLXBhaXJzICovXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3IgcmVjb3JkaW5nIHdoZXRoZXIgdGhlIE1ldGFNYXNrIHVzZXIgaW50ZXJmYWNlIGlzIG9wZW4gb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5cbiAgICovXG4gIHNldCBpc0NsaWVudE9wZW4ob3Blbikge1xuICAgIHRoaXMuX2lzQ2xpZW50T3BlbiA9IG9wZW47XG4gICAgdGhpcy5kZXRlY3RUb2tlbnNDb250cm9sbGVyLmlzT3BlbiA9IG9wZW47XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBhY2Nlc3Nvci1wYWlycyAqL1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBieSB0aGUgYmFja2dyb3VuZCB3aGVuIGFsbCBpbnN0YW5jZXMgb2YgbWV0YW1hc2sgYXJlIGNsb3NlZC5cbiAgICogQ3VycmVudGx5IHVzZWQgdG8gc3RvcCBwb2xsaW5nIGluIHRoZSBnYXNGZWVDb250cm9sbGVyLlxuICAgKi9cbiAgb25DbGllbnRDbG9zZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5zdG9wUG9sbGluZygpO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuY2xlYXJQb2xsaW5nVG9rZW5zKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBieSB0aGUgYmFja2dyb3VuZCB3aGVuIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCB0eXBlIGlzIGNsb3NlZCAoZnVsbHNjcmVlbiwgcG9wdXAsIG5vdGlmaWNhdGlvbikuXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlciBmb3Igb25seSB0aGF0IGVudmlyb25lbWVudCB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSBlbnZpcm9ubWVudFR5cGVcbiAgICovXG4gIG9uRW52aXJvbm1lbnRUeXBlQ2xvc2VkKGVudmlyb25tZW50VHlwZSkge1xuICAgIGNvbnN0IGFwcFN0YXRlUG9sbGluZ1Rva2VuVHlwZSA9XG4gICAgICBQT0xMSU5HX1RPS0VOX0VOVklST05NRU5UX1RZUEVTW2Vudmlyb25tZW50VHlwZV07XG4gICAgY29uc3QgcG9sbGluZ1Rva2Vuc1RvRGlzY29ubmVjdCA9IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKClbXG4gICAgICBhcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGVcbiAgICBdO1xuICAgIHBvbGxpbmdUb2tlbnNUb0Rpc2Nvbm5lY3QuZm9yRWFjaCgocG9sbGluZ1Rva2VuKSA9PiB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZGlzY29ubmVjdFBvbGxlcihwb2xsaW5nVG9rZW4pO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuKFxuICAgICAgICBwb2xsaW5nVG9rZW4sXG4gICAgICAgIGFwcFN0YXRlUG9sbGluZ1Rva2VuVHlwZSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGRvbWFpbiB0byB0aGUgUGhpc2hpbmdDb250cm9sbGVyIHNhZmVsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIHRoZSBkb21haW4gdG8gc2FmZWxpc3RcbiAgICovXG4gIHNhZmVsaXN0UGhpc2hpbmdEb21haW4oaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuYnlwYXNzKGhvc3RuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyBNZXRhTWFza1xuICAgKi9cbiAgc2V0TG9ja2VkKCkge1xuICAgIGNvbnN0IFt0cmV6b3JLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBLRVlSSU5HX1RZUEVTLlRSRVpPUixcbiAgICApO1xuICAgIGlmICh0cmV6b3JLZXlyaW5nKSB7XG4gICAgICB0cmV6b3JLZXlyaW5nLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2V0TG9ja2VkKCk7XG4gIH1cblxufVxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gKiBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gKiBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAqIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuIFRoZSBmdW5jdGlvbiBhbHNvIGhhcyBhIHByb3BlcnR5ICdjbGVhcicgXG4gKiB0aGF0IGlzIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBjbGVhciB0aGUgdGltZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IHNjaGVkdWxlZCBleGVjdXRpb25zLiBcbiAqXG4gKiBAc291cmNlIHVuZGVyc2NvcmUuanNcbiAqIEBzZWUgaHR0cDovL3Vuc2NyaXB0YWJsZS5jb20vMjAwOS8wMy8yMC9kZWJvdW5jaW5nLWphdmFzY3JpcHQtbWV0aG9kcy9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IGluIG1zIChgMTAwYClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgKGBmYWxzZWApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKXtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICBpZiAobnVsbCA9PSB3YWl0KSB3YWl0ID0gMTAwO1xuXG4gIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24oKXtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgZGVib3VuY2VkLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpXG52YXIgd3JpdGVNZXRob2RzID0gW1wid3JpdGVcIiwgXCJlbmRcIiwgXCJkZXN0cm95XCJdXG52YXIgcmVhZE1ldGhvZHMgPSBbXCJyZXN1bWVcIiwgXCJwYXVzZVwiXVxudmFyIHJlYWRFdmVudHMgPSBbXCJkYXRhXCIsIFwiY2xvc2VcIl1cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGxleFxuXG5mdW5jdGlvbiBmb3JFYWNoIChhcnIsIGZuKSB7XG4gICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmbilcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbihhcnJbaV0sIGkpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkdXBsZXgod3JpdGVyLCByZWFkZXIpIHtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gICAgdmFyIGVuZGVkID0gZmFsc2VcblxuICAgIGZvckVhY2god3JpdGVNZXRob2RzLCBwcm94eVdyaXRlcilcblxuICAgIGZvckVhY2gocmVhZE1ldGhvZHMsIHByb3h5UmVhZGVyKVxuXG4gICAgZm9yRWFjaChyZWFkRXZlbnRzLCBwcm94eVN0cmVhbSlcblxuICAgIHJlYWRlci5vbihcImVuZFwiLCBoYW5kbGVFbmQpXG5cbiAgICB3cml0ZXIub24oXCJkcmFpblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5lbWl0KFwiZHJhaW5cIilcbiAgICB9KVxuXG4gICAgd3JpdGVyLm9uKFwiZXJyb3JcIiwgcmVlbWl0KVxuICAgIHJlYWRlci5vbihcImVycm9yXCIsIHJlZW1pdClcblxuICAgIHN0cmVhbS53cml0YWJsZSA9IHdyaXRlci53cml0YWJsZVxuICAgIHN0cmVhbS5yZWFkYWJsZSA9IHJlYWRlci5yZWFkYWJsZVxuXG4gICAgcmV0dXJuIHN0cmVhbVxuXG4gICAgZnVuY3Rpb24gcHJveHlXcml0ZXIobWV0aG9kTmFtZSkge1xuICAgICAgICBzdHJlYW1bbWV0aG9kTmFtZV0gPSBtZXRob2RcblxuICAgICAgICBmdW5jdGlvbiBtZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyW21ldGhvZE5hbWVdLmFwcGx5KHdyaXRlciwgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJveHlSZWFkZXIobWV0aG9kTmFtZSkge1xuICAgICAgICBzdHJlYW1bbWV0aG9kTmFtZV0gPSBtZXRob2RcblxuICAgICAgICBmdW5jdGlvbiBtZXRob2QoKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdChtZXRob2ROYW1lKVxuICAgICAgICAgICAgdmFyIGZ1bmMgPSByZWFkZXJbbWV0aG9kTmFtZV1cbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkocmVhZGVyLCBhcmd1bWVudHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuZW1pdChtZXRob2ROYW1lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJveHlTdHJlYW0obWV0aG9kTmFtZSkge1xuICAgICAgICByZWFkZXIub24obWV0aG9kTmFtZSwgcmVlbWl0KVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZW1pdCgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobWV0aG9kTmFtZSlcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVuZCgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBlbmRlZCA9IHRydWVcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgYXJncy51bnNoaWZ0KFwiZW5kXCIpXG4gICAgICAgIHN0cmVhbS5lbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWVtaXQoZXJyKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgZXJyKVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgc3RhdGVcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoe30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJvbUNoaWxkID0gKGNoaWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RhdGVbY2hpbGRLZXldID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUodXBkYXRlRnJvbUNoaWxkKTtcbiAgICAgICAgdXBkYXRlRnJvbUNoaWxkKGNoaWxkLmdldFN0YXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IENvbXBvc2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgTG9jYWxTdG9yYWdlU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYWxTdG9yYWdlU3RvcmUgLSBjYW5cXCd0IGZpbmQgbG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghb3B0cy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsU3RvcmFnZVN0b3JlIC0gbm8gc3RvcmFnZUtleSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmFnZUtleSA9IG9wdHMuc3RvcmFnZUtleTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmFnZUtleSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkID8gSlNPTi5wYXJzZShzZXJpYWxpemVkKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KG5ld1N0YXRlKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9zdG9yYWdlS2V5LCBzZXJpYWxpemVkKTtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsU3RvcmFnZVN0b3JlID0gTG9jYWxTdG9yYWdlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2NhbFN0b3JhZ2VTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBpbml0IHN0YXRlXG4gICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSB2b2lkIDA7XG5jb25zdCB0aHJvdWdoMl8xID0gcmVxdWlyZShcInRocm91Z2gyXCIpO1xuZnVuY3Rpb24gc3RvcmVUcmFuc2Zvcm1TdHJlYW0oc3luY1RyYW5zZm9ybUZuKSB7XG4gICAgcmV0dXJuIHRocm91Z2gyXzEub2JqKChzdGF0ZSwgX2VuY29kaW5nLCBjYikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzeW5jVHJhbnNmb3JtRm4oc3RhdGUpO1xuICAgICAgICAgICAgY2IobnVsbCwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHN0b3JlVHJhbnNmb3JtU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci50eXBlID09PSAnZXRoZXJzY2FuJykge1xuICAgICAgICB2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncnBjJztcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPVxuICAgICAgICAgICdodHRwczovL3JwYy5tZXRhbWFzay5pby8nO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIGVtcHR5XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM7XG5jb25zdCBvbGRUZXN0UnBjID0gJ2h0dHBzOi8vcmF3dGVzdHJwYy5tZXRhbWFzay5pby8nO1xuY29uc3QgbmV3VGVzdFJwYyA9ICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgaWYgKHZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIucnBjVGFyZ2V0ID09PSBvbGRUZXN0UnBjKSB7XG4gICAgICAgIHZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIucnBjVGFyZ2V0ID0gbmV3VGVzdFJwYztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBlbXB0eVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZSh2ZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3Qgc2FmZVZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAodmVyc2lvbmVkRGF0YSk7XG4gICAgc2FmZVZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgaWYgKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgIT09ICdycGMnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2FmZVZlcnNpb25lZERhdGEpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQpIHtcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly90ZXN0cnBjLm1ldGFtYXNrLmlvLyc6XG4gICAgICAgICAgc2FmZVZlcnNpb25lZERhdGEuZGF0YS5jb25maWcucHJvdmlkZXIgPSB7XG4gICAgICAgICAgICB0eXBlOiAndGVzdG5ldCcsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly9ycGMubWV0YW1hc2suaW8vJzpcbiAgICAgICAgICBzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdtYWlubmV0JyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBObyBkZWZhdWx0XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gZW1wdHlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gbW9kaWZpZXMgb3VyIG5vdGljZXMgdG8gZGVsZXRlIHRoZWlyIGJvZHkgYWZ0ZXIgYmVpbmcgcmVhZC5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDEyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlci5ub3RpY2VzTGlzdC5mb3JFYWNoKChub3RpY2UpID0+IHtcbiAgICBpZiAobm90aWNlLnJlYWQpIHtcbiAgICAgIG5vdGljZS5ib2R5ID0gJyc7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gc2V0cyB0cmFuc2FjdGlvbnMgYXMgZmFpbGVkXG53aG9zIG5vbmNlIGlzIHRvbyBoaWdoXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMTk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5cbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChcbiAgICAgICh0eE1ldGEsIF8sIHR4TGlzdCkgPT4ge1xuICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEKSB7XG4gICAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZFR4cyA9IHR4TGlzdFxuICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRClcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHgudHhQYXJhbXMuZnJvbSA9PT0gdHhNZXRhLnR4UGFyYW1zLmZyb20pXG4gICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICh0eCkgPT4gdHgubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSA9PT0gdHhNZXRhLm1ldGFtYXNrTmV0d29ya0lkLmZyb20sXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaGlnaGVzdENvbmZpcm1lZE5vbmNlID0gZ2V0SGlnaGVzdE5vbmNlKGNvbmZpcm1lZFR4cyk7XG5cbiAgICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHR4TGlzdFxuICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRClcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHgudHhQYXJhbXMuZnJvbSA9PT0gdHhNZXRhLnR4UGFyYW1zLmZyb20pXG4gICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgICh0eCkgPT4gdHgubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSA9PT0gdHhNZXRhLm1ldGFtYXNrTmV0d29ya0lkLmZyb20sXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaGlnaGVzdENvbnRpbnVvdXNOb25jZSA9IGdldEhpZ2hlc3RDb250aW51b3VzRnJvbShcbiAgICAgICAgICBwZW5kaW5nVHhzLFxuICAgICAgICAgIGhpZ2hlc3RDb25maXJtZWROb25jZSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtYXhOb25jZSA9IE1hdGgubWF4KFxuICAgICAgICAgIGhpZ2hlc3RDb250aW51b3VzTm9uY2UsXG4gICAgICAgICAgaGlnaGVzdENvbmZpcm1lZE5vbmNlLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChwYXJzZUludCh0eE1ldGEudHhQYXJhbXMubm9uY2UsIDE2KSA+IG1heE5vbmNlICsgMSkge1xuICAgICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XG4gICAgICAgICAgdHhNZXRhLmVyciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdub25jZSB0b28gaGlnaCcsXG4gICAgICAgICAgICBub3RlOiAnbWlncmF0aW9uIDAxOSBjdXN0b20gZXJyb3InLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RDb250aW51b3VzRnJvbSh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcbiAgY29uc3Qgbm9uY2VzID0gdHhMaXN0Lm1hcCgodHhNZXRhKSA9PiB7XG4gICAgY29uc3QgeyBub25jZSB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpO1xuICB9KTtcblxuICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnQ7XG4gIHdoaWxlIChub25jZXMuaW5jbHVkZXMoaGlnaGVzdCkpIHtcbiAgICBoaWdoZXN0ICs9IDE7XG4gIH1cblxuICByZXR1cm4gaGlnaGVzdDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdE5vbmNlKHR4TGlzdCkge1xuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICBjb25zdCB7IG5vbmNlIH0gPSB0eE1ldGEudHhQYXJhbXM7XG4gICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlIHx8ICcweDAnLCAxNik7XG4gIH0pO1xuICBjb25zdCBoaWdoZXN0Tm9uY2UgPSBNYXRoLm1heC5hcHBseShudWxsLCBub25jZXMpO1xuICByZXR1cm4gaGlnaGVzdE5vbmNlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDExO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5pc0Rpc2NsYWltZXJDb25maXJtZWQ7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAxNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcblxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghdHhNZXRhLmVycikge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0eE1ldGEuZXJyID09PSAndHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkLidcbiAgICAgICkge1xuICAgICAgICB0eE1ldGEuc3RhdHVzID0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEO1xuICAgICAgICBkZWxldGUgdHhNZXRhLmVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gc2V0cyB0cmFuc2FjdGlvbnMgd2l0aCB0aGUgJ0dhdmUgdXAgc3VibWl0dGluZyB0eC4nIGVyciBtZXNzYWdlXG50byBhICdmYWlsZWQnIHN0YXRlZFxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDE1O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghdHhNZXRhLmVycikge1xuICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgfSBlbHNlIGlmICh0eE1ldGEuZXJyLm1lc3NhZ2UgPT09ICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJykge1xuICAgICAgICB0eE1ldGEuc3RhdHVzID0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBTaGFwZVNoaWZ0Q29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDEwO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZSh7fSwgc3RhdGUsIHtcbiAgICBTaGFwZVNoaWZ0Q29udHJvbGxlcjoge1xuICAgICAgc2hhcGVTaGlmdFR4TGlzdDogc3RhdGUuc2hhcGVTaGlmdFR4TGlzdCB8fCBbXSxcbiAgICB9LFxuICB9KTtcbiAgZGVsZXRlIG5ld1N0YXRlLnNoYXBlU2hpZnRUeExpc3Q7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyBwcm92aWRlciBmcm9tIGNvbmZpZyBhbmQgbW92ZXMgaXQgdG9vIE5ldHdvcmtDb250cm9sbGVyLlxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMTQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlciA9IHt9O1xuICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciA9IG5ld1N0YXRlLmNvbmZpZy5wcm92aWRlcjtcbiAgZGVsZXRlIG5ld1N0YXRlLmNvbmZpZy5wcm92aWRlcjtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyBwcmV2aW91cyBpbnN0YWxsYXRpb25zXG5nZXQgYSBgZmlyc3RUaW1lSW5mb2Aga2V5IG9uIHRoZSBtZXRhbWFzayBzdGF0ZSxcbnNvIHRoYXQgd2UgY2FuIHZlcnNpb24gbm90aWNlcyBpbiB0aGUgZnV0dXJlLlxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjA7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoJ21ldGFtYXNrJyBpbiBuZXdTdGF0ZSAmJiAhKCdmaXJzdFRpbWVJbmZvJyBpbiBuZXdTdGF0ZS5tZXRhbWFzaykpIHtcbiAgICBuZXdTdGF0ZS5tZXRhbWFzay5maXJzdFRpbWVJbmZvID0ge1xuICAgICAgdmVyc2lvbjogJzMuMTIuMCcsXG4gICAgICBkYXRlOiBEYXRlLm5vdygpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgQmxhY2tMaXN0Q29udHJvbGxlciBmcm9tIGRpc2sgc3RhdGVcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDIxO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgZGVsZXRlIG5ld1N0YXRlLkJsYWNrbGlzdENvbnRyb2xsZXI7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5SZWNlbnRCbG9ja3M7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIEN1cnJlbmN5Q29udHJvbGxlciBzdWJzdGF0ZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlKHt9LCBzdGF0ZSwge1xuICAgIEN1cnJlbmN5Q29udHJvbGxlcjoge1xuICAgICAgY3VycmVudEN1cnJlbmN5OiBzdGF0ZS5jdXJyZW50RmlhdCB8fCBzdGF0ZS5maWF0Q3VycmVuY3kgfHwgJ1VTRCcsXG4gICAgICBjb252ZXJzaW9uUmF0ZTogc3RhdGUuY29udmVyc2lvblJhdGUsXG4gICAgICBjb252ZXJzaW9uRGF0ZTogc3RhdGUuY29udmVyc2lvbkRhdGUsXG4gICAgfSxcbiAgfSk7XG4gIGRlbGV0ZSBuZXdTdGF0ZS5jdXJyZW50RmlhdDtcbiAgZGVsZXRlIG5ld1N0YXRlLmZpYXRDdXJyZW5jeTtcbiAgZGVsZXRlIG5ld1N0YXRlLmNvbnZlcnNpb25SYXRlO1xuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvbkRhdGU7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxuLypcblxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcblxuKi9cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcbiAgICBpZiAobmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbiAgICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKFxuICAgICAgICAodHhNZXRhKSA9PiB0eE1ldGEuc3RhdHVzICE9PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYWRkcyBzdWJtaXR0ZWRUaW1lIHRvIHRoZSB0eE1ldGEgaWYgaXQgaXMgbm90IHRoZWlyXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG5cbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgIT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCB8fFxuICAgICAgICB0eE1ldGEuc3VibWl0dGVkVGltZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0eE1ldGE7XG4gICAgICB9XG4gICAgICB0eE1ldGEuc3VibWl0dGVkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb3ZlcyB0aGUgaWRlbnRpdGllcyBzdG9yZWQgaW4gdGhlIEtleXJpbmdDb250cm9sbGVyXG4gaW50byB0aGUgUHJlZmVyZW5jZXNDb250cm9sbGVyXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlciB8fCAhc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlci53YWxsZXROaWNrbmFtZXMpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllcyA9IE9iamVjdC5rZXlzKFxuICAgIHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcyxcbiAgKS5yZWR1Y2UoKGlkZW50aXRpZXMsIGFkZHJlc3MpID0+IHtcbiAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0ge1xuICAgICAgbmFtZTogc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzW2FkZHJlc3NdLFxuICAgICAgYWRkcmVzcyxcbiAgICB9O1xuICAgIHJldHVybiBpZGVudGl0aWVzO1xuICB9LCB7fSk7XG4gIGRlbGV0ZSBzdGF0ZS5LZXlyaW5nQ29udHJvbGxlci53YWxsZXROaWNrbmFtZXM7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VmdWxsIGRvd24gdG8gNDAgdG90YWxcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAyMztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG5cbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPD0gNDApIHtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXZlcnNlVHhMaXN0ID0gdHJhbnNhY3Rpb25zLnJldmVyc2UoKTtcbiAgICBsZXQgc3RyaXBwaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAocmV2ZXJzZVR4TGlzdC5sZW5ndGggPiA0MCAmJiBzdHJpcHBpbmcpIHtcbiAgICAgIGNvbnN0IHR4SW5kZXggPSByZXZlcnNlVHhMaXN0LmZpbmRJbmRleCgodHhNZXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEIHx8XG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuUkVKRUNURUQgfHxcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQgfHxcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5EUk9QUEVEXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0eEluZGV4IDwgMCkge1xuICAgICAgICBzdHJpcHBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldmVyc2VUeExpc3Quc3BsaWNlKHR4SW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSByZXZlcnNlVHhMaXN0LnJldmVyc2UoKTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG4vKlxuXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xuXG4qL1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSAyNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xuICAgIGlmIChuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXG4gICAgICAgICh0eE1ldGEpID0+IHtcbiAgICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuVU5BUFBST1ZFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zID0gbm9ybWFsaXplVHhQYXJhbXModHhNZXRhLnR4UGFyYW1zKTtcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR4UGFyYW1zKHR4UGFyYW1zKSB7XG4gIC8vIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZSBub3JtYWxpemluZyBvZiB0aGF0IGtleSBpbiB0eFBhcmFtc1xuICBjb25zdCB3aGl0ZUxpc3QgPSB7XG4gICAgZnJvbTogKGZyb20pID0+IGFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxuICAgIHRvOiAoKSA9PiBhZGRIZXhQcmVmaXgodHhQYXJhbXMudG8pLnRvTG93ZXJDYXNlKCksXG4gICAgbm9uY2U6IChub25jZSkgPT4gYWRkSGV4UHJlZml4KG5vbmNlKSxcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBhZGRIZXhQcmVmaXgodmFsdWUpLFxuICAgIGRhdGE6IChkYXRhKSA9PiBhZGRIZXhQcmVmaXgoZGF0YSksXG4gICAgZ2FzOiAoZ2FzKSA9PiBhZGRIZXhQcmVmaXgoZ2FzKSxcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBhZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxuICB9O1xuXG4gIC8vIGFwcGx5IG9ubHkga2V5cyBpbiB0aGUgd2hpdGVMaXN0XG4gIGNvbnN0IG5vcm1hbGl6ZWRUeFBhcmFtcyA9IHt9O1xuICBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XG4gICAgICBub3JtYWxpemVkVHhQYXJhbXNba2V5XSA9IHdoaXRlTGlzdFtrZXldKHR4UGFyYW1zW2tleV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRUeFBhcmFtcztcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdobyB3ZXJlIHJldHJpZWQgYW5kIG1hcmtlZCBhcyBmYWlsZWQgdG8gc3VibWl0dGVkXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMTc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4TWV0YSkgPT4ge1xuICAgICAgaWYgKCF0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQpIHtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH1cbiAgICAgIGlmICh0eE1ldGEucmV0cnlDb3VudCA+IDAgJiYgdHhNZXRhLnJldHJ5Q291bnQgPCAyKSB7XG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQ7XG4gICAgICAgIGRlbGV0ZSB0eE1ldGEuZXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBlbnN1cmVzIHRoYXQgdGhlIGZyb20gYWRkcmVzcyBpbiB0eFBhcmFtcyBpcyB0byBsb3dlciBjYXNlIGZvclxuYWxsIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG5jb25zdCB2ZXJzaW9uID0gMjQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBpZiAoIW5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChcbiAgICAodHhNZXRhLCBfKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQgJiZcbiAgICAgICAgdHhNZXRhLnR4UGFyYW1zICYmXG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5mcm9tXG4gICAgICApIHtcbiAgICAgICAgdHhNZXRhLnR4UGFyYW1zLmZyb20gPSB0eE1ldGEudHhQYXJhbXMuZnJvbS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9LFxuICApO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG4vKlxuXG5SZW1vdmVzIHRoZSBkZXByZWNhdGVkICdzZWVkV29yZHMnIHN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzNTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKFxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciAmJlxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5zZWVkV29yZHMgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcztcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzQ7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gZW5hYmxlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZyBhbmQgc2V0IHRoZSB1c2VyIGFzIGJlaW5nIG1pZ3JhdGVkXG4gKiBpZiBpdCB3YXMge0Bjb2RlIGZhbHNlfS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xuXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xuXG4gICAgaWYgKFxuICAgICAgIWZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAmJlxuICAgICAgdHlwZW9mIFByZWZlcmVuY2VzQ29udHJvbGxlci5taWdyYXRlZFByaXZhY3lNb2RlID09PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgLy8gTWFyayB0aGUgc3RhdGUgaGFzIGJlaW5nIG1pZ3JhdGVkIGFuZCBlbmFibGUgUHJpdmFjeSBNb2RlXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIubWlncmF0ZWRQcml2YWN5TW9kZSA9IHRydWU7XG4gICAgICBmZWF0dXJlRmxhZ3MucHJpdmFjeU1vZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbnJlbW92ZXMgaW52YWxpZCBjaGFpZHMgZnJvbSBwcmVmZXJlbmNlcyBhbmQgbmV0d29ya0NvbnRyb2xsZXIgZm9yIGN1c3RvbSBycGNzXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzMDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIGlmIChmcmVxdWVudFJwY0xpc3REZXRhaWwpIHtcbiAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChycGMsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgICBpZiAoQm9vbGVhbihycGMuY2hhaW5JZCkgJiYgTnVtYmVyLmlzTmFOKHBhcnNlSW50KHJwYy5jaGFpbklkKSkpIHtcbiAgICAgICAgICBkZWxldGUgZnJlcXVlbnRScGNMaXN0RGV0YWlsW2luZGV4XS5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwgPSBmcmVxdWVudFJwY0xpc3REZXRhaWw7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikge1xuICAgIGlmIChcbiAgICAgIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmsgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgTnVtYmVyLmlzTmFOKHBhcnNlSW50KG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmspKVxuICAgICkge1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgJiZcbiAgICAgIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgTnVtYmVyLmlzTmFOKHBhcnNlSW50KG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQpKVxuICAgICkge1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDM2O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHJlbW92ZSB0aGUge0Bjb2RlIHByaXZhY3lNb2RlfSBmZWF0dXJlIGZsYWcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG4vKlxuXG5DbGVhbnMgdXAgbm90aWNlcyBhbmQgYXNzb2NhdGVkIG5vdGljZSBjb250cm9sbGVyIGNvZGVcblxuKi9cblxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDMzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgLy8gdHJhbnNmb3JtIHN0YXRlIGhlcmVcbiAgaWYgKHN0YXRlLk5vdGljZUNvbnRyb2xsZXIpIHtcbiAgICBkZWxldGUgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlcjtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzI7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XG5cbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHsgYmV0YVVJIH0gPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cbiAgICAvLyBhcyB0aGV5J2xsIHNlZSBubyBkaWZmZXJlbmNlIGluIHRoaXMgdmVyc2lvblxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5jb21wbGV0ZWRVaU1pZ3JhdGlvbiA9IGJldGFVSTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0NDtcblxuLyoqXG4gKiBSZW1vdmUgdW51c2VkICdta3JNaWdyYXRpb25SZW1pbmRlclRpbWVzdGFtcCcgc3RhdGUgZnJvbSB0aGUgYEFwcFN0YXRlQ29udHJvbGxlcmBcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBzdGF0ZT8uQXBwU3RhdGVDb250cm9sbGVyPy5ta3JNaWdyYXRpb25SZW1pbmRlclRpbWVzdGFtcCAhPT1cbiAgICAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBkZWxldGUgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLm1rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB0b0NoZWNrc3VtSGV4QWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5cbmNvbnN0IHZlcnNpb24gPSAzOTtcblxuY29uc3QgREFJX1YxX0NPTlRSQUNUX0FERFJFU1MgPSAnMHg4OWQyNEE2YjRDY0IxQjZmQUEyNjI1ZkU1NjJiREQ5YTIzMjYwMzU5JztcbmNvbnN0IERBSV9WMV9UT0tFTl9TWU1CT0wgPSAnREFJJztcbmNvbnN0IFNBSV9UT0tFTl9TWU1CT0wgPSAnU0FJJztcblxuZnVuY3Rpb24gaXNPbGREYWkodG9rZW4gPSB7fSkge1xuICByZXR1cm4gKFxuICAgIHRva2VuICYmXG4gICAgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJlxuICAgIHRva2VuLnN5bWJvbCA9PT0gREFJX1YxX1RPS0VOX1NZTUJPTCAmJlxuICAgIHRvQ2hlY2tzdW1IZXhBZGRyZXNzKHRva2VuLmFkZHJlc3MpID09PSBEQUlfVjFfQ09OVFJBQ1RfQUREUkVTU1xuICApO1xufVxuXG4vKipcbiAqIFRoaXMgbWlncmF0aW9uIHJlbmFtZXMgdGhlIERhaSB0b2tlbiB0byBTYWkuXG4gKlxuICogQXMgb2YgMjAxOS0xMS0xOCBEYWkgaXMgbm93IGNhbGxlZCBTYWkgKHJlZnMgaHR0cHM6Ly9naXQuaW8vSmVvb1ApIHRvIGZhY2lsaXRhdGVcbiAqIE1ha2VyJ3MgdXBncmFkZSB0byBNdWx0aS1Db2xsYXRlcmFsIERhaSBhbmQgdGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgdG9rZW5cbiAqIGF0IHRoZSBvbGQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xuXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zIHx8IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChpc09sZERhaSh0b2tlbikpIHtcbiAgICAgICAgICB0b2tlbi5zeW1ib2wgPSBTQUlfVE9LRU5fU1lNQk9MO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudFRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zIHx8IHt9O1xuICAgIGlmIChhY2NvdW50VG9rZW5zICYmIHR5cGVvZiBhY2NvdW50VG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdO1xuICAgICAgICBpZiAobmV0d29ya1Rva2VucyAmJiB0eXBlb2YgbmV0d29ya1Rva2VucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc09uTmV0d29yayA9IG5ldHdvcmtUb2tlbnNbbmV0d29ya107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnNPbk5ldHdvcmspKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zT25OZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4uc3ltYm9sID0gU0FJX1RPS0VOX1NZTUJPTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDY7XG5cbi8qKlxuICogRGVsZXRlIHtAY29kZSBBQlRlc3RDb250cm9sbGVyfSBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAodHlwZW9mIHN0YXRlPy5BQlRlc3RDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBzdGF0ZS5BQlRlc3RDb250cm9sbGVyO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMjg7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcbiAgICBpZiAoXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zICYmXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllc1xuICAgICkge1xuICAgICAgY29uc3QgeyBpZGVudGl0aWVzLCB0b2tlbnMgfSA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0ge307XG4gICAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKChpZGVudGl0eSkgPT4ge1xuICAgICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1tpZGVudGl0eV0gPSB7XG4gICAgICAgICAgbWFpbm5ldDogdG9rZW5zLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gW107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQxO1xuXG4vKipcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlci5hdXRvTG9nb3V0VGltZUxpbWl0IC0+IGF1dG9Mb2NrVGltZUxpbWl0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgJiYgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0ID1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcy5hdXRvTG9nb3V0VGltZUxpbWl0O1xuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMuYXV0b0xvZ291dFRpbWVMaW1pdDtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDA7XG5cbi8qKlxuICogU2l0ZSBjb25uZWN0aW9ucyBhcmUgbm93IG1hbmFnZWQgYnkgdGhlIFBlcm1pc3Npb25zQ29udHJvbGxlciwgYW5kIHRoZVxuICogUHJvdmlkZXJBcHByb3ZhbENvbnRyb2xsZXIgaXMgcmVtb3ZlZC4gVGhpcyBtaWdyYXRpb24gZGVsZXRlcyBhbGxcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIHN0YXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBkZWxldGUgc3RhdGUuUHJvdmlkZXJBcHByb3ZhbENvbnRyb2xsZXI7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0MjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGBjb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duYCB0byBgZmFsc2VgIGlmIGl0IGhhc24ndCB5ZXQgYmVlbiBzZXQsXG4gKiBzbyB0aGF0IGV4aXN0aW5nIHVzZXJzIGFyZSBpbnRyb2R1Y2VkIHRvIHRoZSBuZXcgY29ubmVjdGVkIHN0YXR1cyBpbmRpY2F0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcikge1xuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlci5jb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyID0ge1xuICAgICAgY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bjogZmFsc2UsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb2RpZmllcyB0aGUgbmV0d29yayBjb25maWcgZnJvbSBhbWJpZ3VvdXMgJ3Rlc3RuZXQnIHRvIGV4cGxpY2l0ICdyb3BzdGVuJ1xuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMTM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCB7IGNvbmZpZyB9ID0gbmV3U3RhdGU7XG4gIGlmIChjb25maWcgJiYgY29uZmlnLnByb3ZpZGVyKSB7XG4gICAgaWYgKGNvbmZpZy5wcm92aWRlci50eXBlID09PSAndGVzdG5ldCcpIHtcbiAgICAgIG5ld1N0YXRlLmNvbmZpZy5wcm92aWRlci50eXBlID0gJ3JvcHN0ZW4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDc7XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBgbWV0YW1hc2tOZXR3b3JrSWRgIHByb3BlcnR5IG9mIGFsbCB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpKSB7XG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID09PSAnbnVtYmVyJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZCA9IHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ1O1xuXG4vKipcbiAqIFJlcGxhY2VzIHtAY29kZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXl9IHdpdGggJ2R3ZWIubGluaycgaWYgc2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmNvbnN0IG91dGRhdGVkR2F0ZXdheXMgPSBbJ2lwZnMuaW8nLCAnaXBmcy5kd2ViLmxpbmsnXTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKG91dGRhdGVkR2F0ZXdheXMuaW5jbHVkZXMoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uaXBmc0dhdGV3YXkpKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlwZnNHYXRld2F5ID0gJ2R3ZWIubGluayc7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDQ5O1xuXG4vKipcbiAqIE1pZ3JhdGUgbWV0YU1ldHJpY3Mgc3RhdGUgdG8gdGhlIG5ldyBNZXRhTWV0cmljcyBjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFNZXRyaWNzSWQsXG4gICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MsXG4gICAgICBtZXRhTWV0cmljc1NlbmRDb3VudCxcbiAgICB9ID0gc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA/PyB7fTtcblxuICAgIGlmIChtZXRhTWV0cmljc0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkID0gbWV0YU1ldHJpY3NJZDtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIubWV0YU1ldHJpY3NJZDtcbiAgICB9XG5cbiAgICBpZiAocGFydGljaXBhdGVJbk1ldGFNZXRyaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgPSBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcztcbiAgICB9XG5cbiAgICBpZiAobWV0YU1ldHJpY3NTZW5kQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50ID0gbWV0YU1ldHJpY3NTZW5kQ291bnQ7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgTkVUV09SS19UWVBFX1RPX0lEX01BUCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA1MTtcblxuLyoqXG4gKiBTZXQgdGhlIGNoYWluSWQgaW4gdGhlIE5ldHdvcmsgQ29udHJvbGxlciBwcm92aWRlciBkYXRhIGZvciBhbGwgaW5mdXJhIG5ldHdvcmtzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgdHlwZSB9ID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcbiAgY29uc3QgZW51bUNoYWluSWQgPSBORVRXT1JLX1RZUEVfVE9fSURfTUFQW3R5cGVdPy5jaGFpbklkO1xuXG4gIGlmIChlbnVtQ2hhaW5JZCAmJiBjaGFpbklkICE9PSBlbnVtQ2hhaW5JZCkge1xuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgPSBlbnVtQ2hhaW5JZDtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgR09FUkxJLFxuICBHT0VSTElfQ0hBSU5fSUQsXG4gIEtPVkFOLFxuICBLT1ZBTl9DSEFJTl9JRCxcbiAgTUFJTk5FVCxcbiAgTUFJTk5FVF9DSEFJTl9JRCxcbiAgTkVUV09SS19UWVBFX1JQQyxcbiAgUklOS0VCWSxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgUk9QU1RFTixcbiAgUk9QU1RFTl9DSEFJTl9JRCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgdmVyc2lvbiA9IDUyO1xuXG4vKipcbiAqIE1pZ3JhdGUgdG9rZW5zIGluIFByZWZlcmVuY2VzIHRvIGJlIGtleWVkIGJ5IGNoYWluSWQgaW5zdGVhZCBvZlxuICogcHJvdmlkZXJUeXBlLiBUbyBwcmV2ZW50IGJyZWFraW5nIHVzZXIncyBNZXRhTWFzayBhbmQgc2VsZWN0ZWRcbiAqIHRva2VucywgdGhpcyBtaWdyYXRpb24gY29waWVzIHRoZSBSUEMgZW50cnkgaW50byAqZXZlcnkqIGN1c3RvbSBSUENcbiAqIGNoYWluSWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY291bnRUb2tlbnMsXG4gICAgICBhY2NvdW50SGlkZGVuVG9rZW5zLFxuICAgICAgZnJlcXVlbnRScGNMaXN0RGV0YWlsLFxuICAgIH0gPSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG5cbiAgICBjb25zdCBuZXdBY2NvdW50VG9rZW5zID0ge307XG4gICAgY29uc3QgbmV3QWNjb3VudEhpZGRlblRva2VucyA9IHt9O1xuXG4gICAgaWYgKGFjY291bnRUb2tlbnMgJiYgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XG4gICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc10gPSB7fTtcbiAgICAgICAgaWYgKGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFX1JQQ10pIHtcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW2RldGFpbC5jaGFpbklkXSA9XG4gICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFX1JQQ107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcm92aWRlclR5cGUgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2Vuc1thZGRyZXNzXSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNQUlOTkVUOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdW01BSU5ORVRfQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW01BSU5ORVRdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUk9QU1RFTjpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtST1BTVEVOX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtST1BTVEVOXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJTktFQlk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bUklOS0VCWV9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bUklOS0VCWV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHT0VSTEk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bR09FUkxJX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtHT0VSTEldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS09WQU46XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bS09WQU5fQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW0tPVkFOXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gbmV3QWNjb3VudFRva2VucztcbiAgICB9XG5cbiAgICBpZiAoYWNjb3VudEhpZGRlblRva2VucyAmJiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2VucykpIHtcbiAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXSA9IHt9O1xuICAgICAgICBpZiAoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVfUlBDXSkge1xuICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bZGV0YWlsLmNoYWluSWRdID1cbiAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVfUlBDXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyVHlwZSBvZiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdKSkge1xuICAgICAgICAgIHN3aXRjaCAocHJvdmlkZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1BSU5ORVQ6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTUFJTk5FVF9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTUFJTk5FVF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBST1BTVEVOOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW1JPUFNURU5fQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW1JPUFNURU5dO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklOS0VCWTpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtSSU5LRUJZX0NIQUlOX0lEXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtSSU5LRUJZXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdPRVJMSTpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtHT0VSTElfQ0hBSU5fSURdID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW0dPRVJMSV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLT1ZBTjpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtLT1ZBTl9DSEFJTl9JRF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bS09WQU5dO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRIaWRkZW5Ub2tlbnMgPSBuZXdBY2NvdW50SGlkZGVuVG9rZW5zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNDM7XG5cbi8qKlxuICogUmVtb3ZlIHVudXNlZCAnY3VycmVudEFjY291bnRUYWInIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5jdXJyZW50QWNjb3VudFRhYikge1xuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY3VycmVudEFjY291bnRUYWI7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IE5FVFdPUktfVFlQRV9UT19JRF9NQVAgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTU7XG5cbi8qKlxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuY29uc3QgVU5LTk9XTl9DSEFJTl9JRF9LRVkgPSAnVU5LTk9XTic7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChcbiAgICBzdGF0ZT8uSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyPy5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmtcbiAgKSB7XG4gICAgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkID0gbWFwS2V5cyhcbiAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmssXG4gICAgICAvLyB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBpbiBjYXNlIHVzZXIncyBzdGF0ZSBoYXMgZmV0Y2hlZCBibG9ja3MgZm9yXG4gICAgICAvLyBSUEMgbmV0d29yayB0eXBlcyAod2hpY2ggZG9uJ3QgbWFwIHRvIGEgc2luZ2xlIGNoYWluSWQpLiBUaGlzIHNob3VsZFxuICAgICAgLy8gbm90IGJlIHBvc3NpYmxlLCBidXQgaXQncyBzYWZlclxuICAgICAgKF8sIGtleSkgPT4gTkVUV09SS19UWVBFX1RPX0lEX01BUFtrZXldPy5jaGFpbklkID8/IFVOS05PV05fQ0hBSU5fSURfS0VZLFxuICAgICk7XG4gICAgLy8gTm93IHRoYXQgbWFpbm5ldCBhbmQgdGVzdCBuZXQgbGFzdCBmZXRjaGVkIGJsb2NrcyBhcmUga2V5ZWQgYnkgdGhlaXJcbiAgICAvLyByZXNwZWN0aXZlIGNoYWluSWRzLCB3ZSBjYW4gc2FmZWx5IGRlbGV0ZSBhbnl0aGluZyB3ZSBoYWQgZm9yIGN1c3RvbVxuICAgIC8vIG5ldHdvcmtzLiBBbnkgY3VzdG9tIG5ldHdvcmsgdGhhdCBzaGFyZXMgYSBjaGFpbklkIHdpdGggb25lIG9mIHRoZVxuICAgIC8vIGFmb3JlbWVudGlvbmVkIG5ldHdvcmtzIHdpbGwgdXNlIHRoZSB2YWx1ZSBzdG9yZWQgYnkgY2hhaW5JZC5cbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWRbVU5LTk9XTl9DSEFJTl9JRF9LRVldO1xuICAgIGRlbGV0ZSBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDUwO1xuXG5jb25zdCBMRUdBQ1lfTE9DQUxfU1RPUkFHRV9LRVlTID0gW1xuICAnTUVUQVNXQVBfR0FTX1BSSUNFX0VTVElNQVRFU19MQVNUX1JFVFJJRVZFRCcsXG4gICdNRVRBU1dBUF9HQVNfUFJJQ0VfRVNUSU1BVEVTJyxcbiAgJ2NhY2hlZEZldGNoJyxcbiAgJ0JBU0lDX1BSSUNFX0VTVElNQVRFU19MQVNUX1JFVFJJRVZFRCcsXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVMnLFxuICAnQkFTSUNfR0FTX0FORF9USU1FX0FQSV9FU1RJTUFURVMnLFxuICAnQkFTSUNfR0FTX0FORF9USU1FX0FQSV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxuICAnR0FTX0FQSV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxuICAnR0FTX0FQSV9FU1RJTUFURVMnLFxuXTtcblxuLyoqXG4gKiBNaWdyYXRlIG1ldGFNZXRyaWNzIHN0YXRlIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgY29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcblxuICAgIExFR0FDWV9MT0NBTF9TVE9SQUdFX0tFWVMuZm9yRWFjaCgoa2V5KSA9PlxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZT8ucmVtb3ZlSXRlbShrZXkpLFxuICAgICk7XG5cbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTQ7XG5cbmZ1bmN0aW9uIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscykge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkZWNpbWFscyA9PT0gJ251bWJlcicgfHxcbiAgICAodHlwZW9mIGRlY2ltYWxzID09PSAnc3RyaW5nJyAmJiBkZWNpbWFscy5tYXRjaCgvXigweCk/XFxkKyQvdSkpXG4gICk7XG59XG5cbi8qKlxuICogTWlncmF0ZXMgcHJlZmVyZW5jZSB0b2tlbnMgd2l0aCBkZWNpbWFscyB0eXBlZCBhcyBzdHJpbmcgdG8gbnVtYmVyLlxuICogSXQgYWxzbyByZW1vdmVzIGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgb3IgaW5jb252ZXJ0aWJsZSBkZWNpbWFsIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIGlmICghbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgY29uc3QgdG9rZW5zID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyB8fCBbXTtcbiAgLy8gRmlsdGVyIG91dCBhbnkgdG9rZW5zIHdpdGggY29ycnVwdGVkIGRlY2ltYWwgdmFsdWVzXG4gIGNvbnN0IHZhbGlkVG9rZW5zID0gdG9rZW5zLmZpbHRlcigoeyBkZWNpbWFscyB9KSA9PlxuICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXG4gICk7XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgdmFsaWRUb2tlbnMpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGRlY2ltYWwgdmFsdWUgdHlwZSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAgaWYgKHR5cGVvZiB0b2tlbi5kZWNpbWFscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgICAgdG9rZW4uZGVjaW1hbHMgPSBwYXJzZUludCh0b2tlbi5kZWNpbWFscyk7XG4gICAgfVxuICB9XG4gIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgPSB2YWxpZFRva2VucztcblxuICBjb25zdCB7IGFjY291bnRUb2tlbnMgfSA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcbiAgaWYgKGFjY291bnRUb2tlbnMgJiYgdHlwZW9mIGFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XG4gICAgICBjb25zdCBuZXR3b3JrVG9rZW5zID0gYWNjb3VudFRva2Vuc1thZGRyZXNzXTtcbiAgICAgIGlmIChuZXR3b3JrVG9rZW5zICYmIHR5cGVvZiBuZXR3b3JrVG9rZW5zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbnNPbk5ldHdvcmsgPSBuZXR3b3JrVG9rZW5zW25ldHdvcmtdIHx8IFtdO1xuICAgICAgICAgIC8vIEZpbHRlciBvdXQgYW55IHRva2VucyB3aXRoIGNvcnJ1cHRlZCBkZWNpbWFsIHZhbHVlc1xuICAgICAgICAgIGNvbnN0IHZhbGlkVG9rZW5zT25OZXR3b3JrID0gdG9rZW5zT25OZXR3b3JrLmZpbHRlcigoeyBkZWNpbWFscyB9KSA9PlxuICAgICAgICAgICAgaXNWYWxpZERlY2ltYWxzKGRlY2ltYWxzKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgZGVjaW1hbCB2YWx1ZSB0eXBlIHN0cmluZywgY29udmVydCB0byBhIG51bWJlci5cbiAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHZhbGlkVG9rZW5zT25OZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuLmRlY2ltYWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcbiAgICAgICAgICAgICAgdG9rZW4uZGVjaW1hbHMgPSBwYXJzZUludCh0b2tlbi5kZWNpbWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ldHdvcmtUb2tlbnNbbmV0d29ya10gPSB2YWxpZFRva2Vuc09uTmV0d29yaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucyA9IGFjY291bnRUb2tlbnM7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDU2O1xuXG4vKipcbiAqIFJlbW92ZSB0b2tlbnMgdGhhdCBkb24ndCBoYXZlIGFuIGFkZHJlc3MgZHVlIHRvXG4gKiBsYWNrIG9mIHByZXZpb3VzIGFkZFRva2VuIHZhbGlkYXRpb24uICBBbHNvIHJlbW92ZXNcbiAqIGFuIHVud2FudGVkLCB1bmRlZmluZWQgaW1hZ2UgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnMpKSB7XG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2Vucy5maWx0ZXIoXG4gICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zICYmXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICBPYmplY3Qua2V5cyhQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBPYmplY3Qua2V5cyhcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XSxcbiAgICAgICAgKTtcbiAgICAgICAgY2hhaW5zLmZvckVhY2goKGNoYWluKSA9PiB7XG4gICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bXG4gICAgICAgICAgICBjaGFpblxuICAgICAgICAgIF0gPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XVtjaGFpbl0uZmlsdGVyKFxuICAgICAgICAgICAgKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcyAmJlxuICAgICAgJ3VuZGVmaW5lZCcgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzXG4gICAgKSB7XG4gICAgICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzLnVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjE7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhdHRyaWJ1dGVzIHJlbGF0ZWQgdG8gcmVjb3Zlcnkgc2VlZCBwaHJhc2UgcmVtaW5kZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLnJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24gPSBmYWxzZTtcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIucmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93biA9IGN1cnJlbnRUaW1lO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlciA9IHtcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IGZhbHNlLFxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjogY3VycmVudFRpbWUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuY29uc3QgdmVyc2lvbiA9IDY0O1xuXG5jb25zdCBTRU5UX0VUSEVSID0gJ3NlbnRFdGhlcic7IC8vIHRoZSBsZWdhY3kgdHJhbnNhY3Rpb24gdHlwZSBiZWluZyByZXBsYWNlZCBpbiB0aGlzIG1pZ3JhdGlvbiB3aXRoIFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EXG5cbi8qKlxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KHRyYW5zYWN0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IHR4IG9mIE9iamVjdC52YWx1ZXModHJhbnNhY3Rpb25zKSkge1xuICAgICAgaWYgKHR4LnR5cGUgPT09IFNFTlRfRVRIRVIpIHtcbiAgICAgICAgdHgudHlwZSA9IFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EO1xuICAgICAgfVxuICAgICAgaWYgKHR4Lmhpc3RvcnkpIHtcbiAgICAgICAgdHguaGlzdG9yeS5tYXAoKHR4RXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodHhFdmVudC50eXBlICYmIHR4RXZlbnQudHlwZSA9PT0gU0VOVF9FVEhFUikge1xuICAgICAgICAgICAgdHhFdmVudC50eXBlID0gVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eEV2ZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY1O1xuXG4vKipcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZE9uYm9hcmRpbmcsXG4gICAgICBmaXJzdFRpbWVGbG93VHlwZSxcbiAgICB9ID0gc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyID0gc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIgPz8ge307XG5cbiAgICBpZiAoY29tcGxldGVkT25ib2FyZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlci5jb21wbGV0ZWRPbmJvYXJkaW5nID0gY29tcGxldGVkT25ib2FyZGluZztcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZztcbiAgICB9XG4gICAgaWYgKGZpcnN0VGltZUZsb3dUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlID0gZmlyc3RUaW1lRmxvd1R5cGU7XG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA2MDtcbmNvbnN0IFNVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWSA9IDI7XG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFID0gJzIwMjAtMDgtMzEnO1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHN1cHBvcnQgc3VydmV5IG5vdGlmaWNhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBzdGF0ZT8uTm90aWZpY2F0aW9uQ29udHJvbGxlcj8ubm90aWZpY2F0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3Qobm90aWZpY2F0aW9ucykpIHtcbiAgICBpZiAoXG4gICAgICBub3RpZmljYXRpb25zW1NVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWV0/LmRhdGUgPT09XG4gICAgICBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFXG4gICAgKSB7XG4gICAgICBkZWxldGUgc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zW1xuICAgICAgICBTVVBQT1JUX05PVElGSUNBVElPTl9LRVlcbiAgICAgIF07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA1ODtcblxuLyoqXG4gKiBEZWxldGVzIHRoZSBzd2Fwc1dlbGNvbWVNZXNzYWdlSGFzQmVlblNob3duIHByb3BlcnR5IGZyb20gc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgZGVsZXRlIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcj8uc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93bjtcblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjI7XG5cbi8qKlxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyBtZXRhTWV0cmljc1NlbmRDb3VudCB9ID0gc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyO1xuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgU1VCSkVDVF9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuY29uc3QgdmVyc2lvbiA9IDY5O1xuXG4vKipcbiAqIEFkZHMgdGhlIGBzdWJqZWN0VHlwZWAgcHJvcGVydHkgdG8gYWxsIHN1YmplY3QgbWV0YWRhdGEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZT8uU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcj8uc3ViamVjdE1ldGFkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHtcbiAgICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IHsgc3ViamVjdE1ldGFkYXRhIH0sXG4gICAgfSA9IHN0YXRlO1xuXG4gICAgLy8gbXV0YXRlIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuc3ViamVjdE1ldGFkYXRhIGluIHBsYWNlXG4gICAgT2JqZWN0LnZhbHVlcyhzdWJqZWN0TWV0YWRhdGEpLmZvckVhY2goKG1ldGFkYXRhKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG1ldGFkYXRhICYmXG4gICAgICAgIHR5cGVvZiBtZXRhZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpXG4gICAgICApIHtcbiAgICAgICAgbWV0YWRhdGEuc3ViamVjdFR5cGUgPSBtZXRhZGF0YS5leHRlbnNpb25JZFxuICAgICAgICAgID8gU1VCSkVDVF9UWVBFUy5FWFRFTlNJT05cbiAgICAgICAgICA6IFNVQkpFQ1RfVFlQRVMuV0VCU0lURTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQge1xuICBjbG9uZURlZXAsXG4gIGNvbmNhdCxcbiAgZ3JvdXBCeSxcbiAga2V5QnksXG4gIHBpY2tCeSxcbiAgaXNQbGFpbk9iamVjdCxcbn0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSA1OTtcblxuLyoqXG4gKiBSZW1vdmVzIG9ycGhhbmVkIGNhbmNlbCBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zIHRoYXQgbm8gbG9uZ2VyIGhhdmUgdGhlXG4gKiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBpbiBzdGF0ZSwgd2hpY2ggcmVzdWx0cyBpbiBidWdzLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KHRyYW5zYWN0aW9ucykpIHtcbiAgICBjb25zdCBub25jZU5ldHdvcmtHcm91cGVkT2JqZWN0ID0gZ3JvdXBCeShcbiAgICAgIE9iamVjdC52YWx1ZXModHJhbnNhY3Rpb25zKSxcbiAgICAgICh0eCkgPT4ge1xuICAgICAgICByZXR1cm4gYCR7dHgudHhQYXJhbXM/Lm5vbmNlfS0ke3R4LmNoYWluSWQgPz8gdHgubWV0YW1hc2tOZXR3b3JrSWR9YDtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IHdpdGhvdXRPcnBoYW5zID0gcGlja0J5KG5vbmNlTmV0d29ya0dyb3VwZWRPYmplY3QsIChncm91cCkgPT4ge1xuICAgICAgcmV0dXJuIGdyb3VwLnNvbWUoXG4gICAgICAgICh0eCkgPT5cbiAgICAgICAgICB0eC50eXBlICE9PSBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUwgJiZcbiAgICAgICAgICB0eC50eXBlICE9PSBUUkFOU0FDVElPTl9UWVBFUy5SRVRSWSxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxuICAgICAgY29uY2F0KC4uLk9iamVjdC52YWx1ZXMod2l0aG91dE9ycGhhbnMpKSxcbiAgICAgICh0eCkgPT4gdHguaWQsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSAzMTtcblxuLypcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHByb3Blcmx5IHNldCB0aGUgY29tcGxldGVkT25ib2FyZGluZyBmbGFnIGJhc2VkIG9uIHRoZSBzdGF0ZVxuICogb2YgdGhlIEtleXJpbmdDb250cm9sbGVyLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgeyBLZXlyaW5nQ29udHJvbGxlciwgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcblxuICBpZiAoS2V5cmluZ0NvbnRyb2xsZXIgJiYgUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gS2V5cmluZ0NvbnRyb2xsZXI7XG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmNvbXBsZXRlZE9uYm9hcmRpbmcgPSBCb29sZWFuKHZhdWx0KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXJzJztcblxuY29uc3QgdmVyc2lvbiA9IDM3O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHVwZGF0ZSB0aGUgYWRkcmVzcyBib29rIHN0YXRlXG4gKiB0byB0aGUgbmV3IHNjaGVtYSB3aXRoIGNoYWluSWQgYXMgYSBrZXkuXG4gKiBhbmQgdG8gYWRkIHRoZSBpc0VucyBmbGFnIHRvIGFsbCBlbnRyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBhYiA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vaztcblxuICAgIGNvbnN0IGNoYWluSWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5ld0FkZHJlc3NCb29rID0ge307XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGFpbklkcyB0byBhIHNldFxuICAgIE9iamVjdC52YWx1ZXMoYWIpLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGNoYWluSWRzLmFkZCh2LmNoYWluSWQpO1xuICAgIH0pO1xuXG4gICAgLy8gZmlsbCB0aGUgY2hhaW5JZCBvYmplY3Qgd2l0aCB0aGUgZW50cmllcyB3aXRoIHRoZSBtYXRjaGluZyBjaGFpbklkXG4gICAgZm9yIChjb25zdCBpZCBvZiBjaGFpbklkcy52YWx1ZXMoKSkge1xuICAgICAgLy8gbWFrZSBhbiBlbXB0eSBvYmplY3QgZW50cnkgZm9yIGVhY2ggY2hhaW5JZFxuICAgICAgbmV3QWRkcmVzc0Jvb2tbaWRdID0ge307XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gYWIpIHtcbiAgICAgICAgaWYgKGFiW2FkZHJlc3NdLmNoYWluSWQgPT09IGlkKSB7XG4gICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodXRpbC5ub3JtYWxpemVFbnNOYW1lKGFiW2FkZHJlc3NdLm5hbWUpKSB7XG4gICAgICAgICAgICBhYlthZGRyZXNzXS5pc0VucyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld0FkZHJlc3NCb29rW2lkXVthZGRyZXNzXSA9IGFiW2FkZHJlc3NdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLmFkZHJlc3NCb29rID0gbmV3QWRkcmVzc0Jvb2s7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBOb3RpY2VDb250cm9sbGVyIHN1YnN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgTm90aWNlQ29udHJvbGxlcjoge1xuICAgICAgbm90aWNlc0xpc3Q6IHN0YXRlLm5vdGljZXNMaXN0IHx8IFtdLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS5ub3RpY2VzTGlzdDtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvKlxuXG5UaGlzIG1pZ3JhdGlvbiBtb3ZlcyBLZXlyaW5nQ29udHJvbGxlci5zZWxlY3RlZEFkZHJlc3MgdG8gUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlbGVjdGVkQWRkcmVzc1xuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IG1pZ3JhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBtaWdyYXRlU3RhdGUoc3RhdGUpIHtcbiAgY29uc3Qga2V5cmluZ1N1YnN0YXRlID0gc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXI7XG5cbiAgLy8gYWRkIG5ldyBzdGF0ZVxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcbiAgICAgIHNlbGVjdGVkQWRkcmVzczoga2V5cmluZ1N1YnN0YXRlLnNlbGVjdGVkQWNjb3VudCxcbiAgICB9LFxuICB9O1xuXG4gIC8vIHJtIG9sZCBzdGF0ZVxuICBkZWxldGUgbmV3U3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIuc2VsZWN0ZWRBY2NvdW50O1xuXG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsIi8qXG5cblRoaXMgbWlncmF0aW9uIG1vdmVzIHN0YXRlIGZyb20gdGhlIGZsYXQgc3RhdGUgdHJpZSBpbnRvIEtleXJpbmdDb250cm9sbGVyIHN1YnN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA1O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gc2VsZWN0U3Vic3RhdGVGb3JLZXlyaW5nQ29udHJvbGxlcihzdGF0ZSk7XG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICM1JHtlcnIuc3RhY2t9YCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBzZWxlY3RTdWJzdGF0ZUZvcktleXJpbmdDb250cm9sbGVyKHN0YXRlKSB7XG4gIGNvbnN0IHsgY29uZmlnIH0gPSBzdGF0ZTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgS2V5cmluZ0NvbnRyb2xsZXI6IHtcbiAgICAgIHZhdWx0OiBzdGF0ZS52YXVsdCxcbiAgICAgIHNlbGVjdGVkQWNjb3VudDogY29uZmlnLnNlbGVjdGVkQWNjb3VudCxcbiAgICAgIHdhbGxldE5pY2tuYW1lczogc3RhdGUud2FsbGV0Tmlja25hbWVzLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS52YXVsdDtcbiAgZGVsZXRlIG5ld1N0YXRlLndhbGxldE5pY2tuYW1lcztcbiAgZGVsZXRlIG5ld1N0YXRlLmNvbmZpZy5zZWxlY3RlZEFjY291bnQ7XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgVHJhbnNhY3Rpb25NYW5hZ2VyIHN1YnN0YXRlXG5cbiovXG5cbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgVHJhbnNhY3Rpb25NYW5hZ2VyOiB7XG4gICAgICB0cmFuc2FjdGlvbnM6IHN0YXRlLnRyYW5zYWN0aW9ucyB8fCBbXSxcbiAgICAgIGdhc011bHRpcGxpZXI6IHN0YXRlLmdhc011bHRpcGxpZXIgfHwgMSxcbiAgICB9LFxuICB9O1xuICBkZWxldGUgbmV3U3RhdGUudHJhbnNhY3Rpb25zO1xuICBkZWxldGUgbmV3U3RhdGUuZ2FzTXVsdGlwbGllcjtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IGZhaWxUeHNUaGF0IGZyb20gJy4vZmFpbC10eCc7XG5cbmNvbnN0IHZlcnNpb24gPSAyOTtcblxuLy8gdGltZVxuY29uc3Qgc2Vjb25kcyA9IDEwMDA7XG5jb25zdCBtaW51dGVzID0gNjAgKiBzZWNvbmRzO1xuY29uc3QgaG91cnMgPSA2MCAqIG1pbnV0ZXM7XG5jb25zdCB1bmFjY2VwdGFibGVEZWxheSA9IDEyICogaG91cnM7XG5cbi8qXG5cbm5vcm1hbGl6ZXMgdHhQYXJhbXMgb24gdW5jb25maXJtZWQgdHhzXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcblxuICBtaWdyYXRlOiBmYWlsVHhzVGhhdChcbiAgICB2ZXJzaW9uLFxuICAgICdTdHVjayBpbiBhcHByb3ZlZCBzdGF0ZSBmb3IgdG9vIGxvbmcuJyxcbiAgICAodHhNZXRhKSA9PiB7XG4gICAgICBjb25zdCBpc0FwcHJvdmVkID0gdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQ7XG4gICAgICBjb25zdCBjcmVhdGVkVGltZSA9IHR4TWV0YS5zdWJtaXR0ZWRUaW1lO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiBpc0FwcHJvdmVkICYmIG5vdyAtIGNyZWF0ZWRUaW1lID4gdW5hY2NlcHRhYmxlRGVsYXk7XG4gICAgfSxcbiAgKSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gMzg7XG5cbi8qKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gYXNzaWduIGFsbCB1c2VycyB0byBhIHRlc3QgZ3JvdXAgZm9yIHRoZSBmdWxsU2NyZWVuVnNQb3B1cCBhL2IgdGVzdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCB7IEFCVGVzdENvbnRyb2xsZXI6IEFCVGVzdENvbnRyb2xsZXJTdGF0ZSA9IHt9IH0gPSBzdGF0ZTtcbiAgY29uc3QgeyBhYlRlc3RzID0ge30gfSA9IEFCVGVzdENvbnRyb2xsZXJTdGF0ZTtcblxuICBpZiAoYWJUZXN0cy5mdWxsU2NyZWVuVnNQb3B1cCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgQUJUZXN0Q29udHJvbGxlcjoge1xuICAgICAgLi4uQUJUZXN0Q29udHJvbGxlclN0YXRlLFxuICAgICAgYWJUZXN0czoge1xuICAgICAgICAuLi5hYlRlc3RzLFxuICAgICAgICBmdWxsU2NyZWVuVnNQb3B1cDogJ2NvbnRyb2wnLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCBrZXlCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcblxuY29uc3QgdmVyc2lvbiA9IDU3O1xuXG4vKipcbiAqIHJlcGxhY2UgJ2luY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yaycgd2l0aCAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGlmIChcbiAgICBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnMgJiZcbiAgICBBcnJheS5pc0FycmF5KHN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpICYmXG4gICAgIXN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMuc29tZShcbiAgICAgIChpdGVtKSA9PlxuICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ZW0udHhQYXJhbXMgPT09ICd1bmRlZmluZWQnLFxuICAgIClcbiAgKSB7XG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxuICAgICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyxcbiAgICAgIC8vIEluIGNhc2UgZm9yIHNvbWUgcmVhc29uIGFueSBvZiBhIHVzZXIncyB0cmFuc2FjdGlvbnMgZG8gbm90IGhhdmUgYW4gaWRcbiAgICAgIC8vIGdlbmVyYXRlIGEgbmV3IG9uZSBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHguaWQgPT09ICd1bmRlZmluZWQnIHx8IHR4LmlkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBtdXRhdGVzIHRoZSBpdGVtIGluIHRoZSBhcnJheSwgc28gd2lsbCByZXN1bHQgaW4gYSBjaGFuZ2UgdG9cbiAgICAgICAgICAvLyB0aGUgc3RhdGUuXG4gICAgICAgICAgdHguaWQgPSBjcmVhdGVJZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eC5pZDtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgTEVER0VSX1RSQU5TUE9SVF9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5cbmNvbnN0IHZlcnNpb24gPSA2NjtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB1c2VMZWRnZXJMaXZlIGJvb2xlYW4gcHJvcGVydHkgdG8gdGhlIGxlZGdlclRyYW5zcG9ydFR5cGUgZW51bVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IGRlZmF1bHRUcmFuc3BvcnRUeXBlID0gd2luZG93Lm5hdmlnYXRvci5oaWRcbiAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuV0VCSElEXG4gICAgOiBMRURHRVJfVFJBTlNQT1JUX1RZUEVTLlUyRjtcbiAgY29uc3QgdXNlTGVkZ2VyTGl2ZSA9IEJvb2xlYW4oc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyPy51c2VMZWRnZXJMaXZlKTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICAuLi5zdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgbGVkZ2VyVHJhbnNwb3J0VHlwZTogdXNlTGVkZ2VyTGl2ZVxuICAgICAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuTElWRVxuICAgICAgICA6IGRlZmF1bHRUcmFuc3BvcnRUeXBlLFxuICAgIH0sXG4gIH07XG4gIGRlbGV0ZSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlTGVkZ2VyTGl2ZTtcbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmNvbnN0IHZlcnNpb24gPSA1MztcblxuLyoqXG4gKiBEZXByZWNhdGUgdHJhbnNhY3Rpb25DYXRlZ29yeSBhbmQgY29uc29saWRhdGUgb24gJ3R5cGUnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcbiAgY29uc3QgaW5jb21pbmdUcmFuc2FjdGlvbnMgPVxuICAgIHN0YXRlPy5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI/LmluY29taW5nVHJhbnNhY3Rpb25zO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpKSB7XG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgIT09IFRSQU5TQUNUSU9OX1RZUEVTLlJFVFJZICYmXG4gICAgICAgICAgdHJhbnNhY3Rpb24udHlwZSAhPT0gVFJBTlNBQ1RJT05fVFlQRVMuQ0FOQ0VMXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChpbmNvbWluZ1RyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IGluY29taW5nVHJhbnNhY3Rpb25zRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGluY29taW5nVHJhbnNhY3Rpb25zKTtcbiAgICBpbmNvbWluZ1RyYW5zYWN0aW9uc0VudHJpZXMuZm9yRWFjaCgoW2tleSwgdHJhbnNhY3Rpb25dKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uQ2F0ZWdvcnk7XG4gICAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5pbmNvbWluZ1RyYW5zYWN0aW9uc1trZXldID0ge1xuICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgIHR5cGU6IFRSQU5TQUNUSU9OX1RZUEVTLklOQ09NSU5HLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA0ODtcblxuLyoqXG4gKiAxLiAgRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXG4gKiAyYS4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IGlmIHNldCB0byB0eXBlICdycGMnIG9yXG4gKiAgICAgJ2xvY2FsaG9zdCcuXG4gKiAyYi4gUmUta2V5IHByb3ZpZGVyLnJwY1RhcmdldCB0byBwcm92aWRlci5ycGNVcmxcbiAqIDMuICBBZGQgbG9jYWxob3N0IG5ldHdvcmsgdG8gZnJlcXVlbnRScGNMaXN0RGV0YWlsLlxuICogNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcbiAqIDUuICBDb252ZXJ0IHRyYW5zYWN0aW9ucyBtZXRhbWFza05ldHdvcmtJZCB0byBkZWNpbWFsIGlmIHRoZXkgYXJlIGhleFxuICogNi4gIENvbnZlcnQgYWRkcmVzcyBib29rIGtleXMgZnJvbSBkZWNpbWFsIHRvIGhleFxuICogNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxuICogOC4gIE1lcmdlICdsb2NhbGhvc3QnIHRva2VucyBpbnRvICdycGMnIHRva2Vuc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5jb25zdCBoZXhSZWdFeCA9IC9eMHhbMC05YS1mXSskL2l1O1xuY29uc3QgY2hhaW5JZFJlZ0V4ID0gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcbiAgLy8gMS4gRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXG4gIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8uc2V0dGluZ3M7XG5cbiAgLy8gMi4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IG9yIHJlbmFtZSBycGNUYXJnZXQga2V5XG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xuICBjb25zdCBpc0N1c3RvbVJwY1dpdGhJbnZhbGlkQ2hhaW5JZCA9XG4gICAgcHJvdmlkZXIudHlwZSA9PT0gJ3JwYycgJiZcbiAgICAodHlwZW9mIHByb3ZpZGVyLmNoYWluSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhY2hhaW5JZFJlZ0V4LnRlc3QocHJvdmlkZXIuY2hhaW5JZCkpO1xuICBpZiAoaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgfHwgcHJvdmlkZXIudHlwZSA9PT0gJ2xvY2FsaG9zdCcpIHtcbiAgICBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciA9IHtcbiAgICAgIHR5cGU6ICdyaW5rZWJ5JyxcbiAgICAgIHJwY1VybDogJycsXG4gICAgICBjaGFpbklkOiAnMHg0JyxcbiAgICAgIG5pY2tuYW1lOiAnJyxcbiAgICAgIHJwY1ByZWZzOiB7fSxcbiAgICAgIHRpY2tlcjogJ0VUSCcsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIpIHtcbiAgICBpZiAoJ3JwY1RhcmdldCcgaW4gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IHJwY1VybCA9IHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1RhcmdldDtcbiAgICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1VybCA9IHJwY1VybDtcbiAgICB9XG4gICAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlcj8ucnBjVGFyZ2V0O1xuICB9XG5cbiAgLy8gMy4gIEFkZCBsb2NhbGhvc3QgbmV0d29yayB0byBmcmVxdWVudFJwY0xpc3REZXRhaWwuXG4gIGlmICghc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyID0ge307XG4gIH1cbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB7XG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbCA9IFtdO1xuICB9XG4gIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwudW5zaGlmdCh7XG4gICAgcnBjVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JyxcbiAgICBjaGFpbklkOiAnMHg1MzknLFxuICAgIHRpY2tlcjogJ0VUSCcsXG4gICAgbmlja25hbWU6ICdMb2NhbGhvc3QgODU0NScsXG4gICAgcnBjUHJlZnM6IHt9LFxuICB9KTtcblxuICAvLyA0LiAgRGVsZXRlIENhY2hlZEJhbGFuY2VzQ29udHJvbGxlci5jYWNoZWRCYWxhbmNlc1xuICBkZWxldGUgc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcztcblxuICAvLyA1LiAgQ29udmVydCB0cmFuc2FjdGlvbnMgbWV0YW1hc2tOZXR3b3JrSWQgdG8gZGVjaW1hbCBpZiB0aGV5IGFyZSBoZXhcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IG1ldGFtYXNrTmV0d29ya0lkID0gdHJhbnNhY3Rpb24/Lm1ldGFtYXNrTmV0d29ya0lkO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbWV0YW1hc2tOZXR3b3JrSWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGhleFJlZ0V4LnRlc3QobWV0YW1hc2tOZXR3b3JrSWQpXG4gICAgICApIHtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPSBwYXJzZUludChcbiAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcbiAgICAgICAgICAxNixcbiAgICAgICAgKS50b1N0cmluZygxMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyA2LiAgQ29udmVydCBhZGRyZXNzIGJvb2sga2V5cyBmcm9tIGRlY2ltYWwgdG8gaGV4XG4gIGNvbnN0IGFkZHJlc3NCb29rID0gc3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyPy5hZGRyZXNzQm9vayB8fCB7fTtcbiAgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2spLmZvckVhY2goKG5ldHdvcmtLZXkpID0+IHtcbiAgICBpZiAoL15cXGQrJC9pdS50ZXN0KG5ldHdvcmtLZXkpKSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gYDB4JHtwYXJzZUludChuZXR3b3JrS2V5LCAxMCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICB1cGRhdGVDaGFpbklkcyhhZGRyZXNzQm9va1tuZXR3b3JrS2V5XSwgY2hhaW5JZCk7XG5cbiAgICAgIGlmIChhZGRyZXNzQm9va1tjaGFpbklkXSkge1xuICAgICAgICBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRyZXNzQm9va1tjaGFpbklkXSA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW25ldHdvcmtLZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxuICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgPy5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms/LmxvY2FsaG9zdDtcblxuICAvLyA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XG4gIGlmIChhY2NvdW50VG9rZW5zKSB7XG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgY29uc3QgbG9jYWxob3N0VG9rZW5zID0gYWNjb3VudFRva2Vuc1thY2NvdW50XT8ubG9jYWxob3N0IHx8IFtdO1xuXG4gICAgICBpZiAobG9jYWxob3N0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcnBjVG9rZW5zID0gYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgfHwgW107XG5cbiAgICAgICAgaWYgKHJwY1Rva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBtZXJnZVRva2VuQXJyYXlzKFxuICAgICAgICAgICAgbG9jYWxob3N0VG9rZW5zLFxuICAgICAgICAgICAgcnBjVG9rZW5zLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBsb2NhbGhvc3RUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3Q7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogTWVyZ2VzIHRoZSB0d28gZ2l2ZW4ga2V5cyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MgYm9vayBpbiBwbGFjZS5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzc0Jvb2tcbiAqIEBwYXJhbSBuZXR3b3JrS2V5XG4gKiBAcGFyYW0gY2hhaW5JZEtleVxuICovXG5mdW5jdGlvbiBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZEtleSkge1xuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xuICAvLyBGb3IgdGhlIG5ldyBlbnRyaWVzLCBzdGFydCBieSBjb3B5aW5nIHRoZSBleGlzdGluZyBlbnRyaWVzIGZvciB0aGUgY2hhaW5JZFxuICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5hZGRyZXNzQm9va1tjaGFpbklkS2V5XSB9O1xuXG4gIC8vIEZvciBlYWNoIGFkZHJlc3Mgb2YgdGhlIG9sZC9uZXR3b3JrSWQga2V5IGVudHJpZXNcbiAgT2JqZWN0LmtleXMobmV0d29ya0tleUVudHJpZXMpLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG1lcmdlZEVudHJ5ID0ge307XG5cbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcbiAgICAgIC8vIGVudHJ5IHdpdGggdGhlIG5ldHdvcmtJZCBlbnRyeVxuICAgICAgbmV3IFNldChbXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXSB8fCB7fSksXG4gICAgICBdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcbiAgICAgICAgbWVyZ2VkRW50cnlba2V5XSA9XG4gICAgICAgICAgbmV3RW50cmllc1thZGRyZXNzXVtrZXldIHx8IG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdPy5ba2V5XSB8fCAnJztcbiAgICAgIH0pO1xuXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbWVyZ2VkRW50cnk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdICYmXG4gICAgICB0eXBlb2YgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gPT09ICdvYmplY3QnXG4gICAgKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGNoYWluSWQgZW50cnksIGp1c3QgdXNlIHRoZSBuZXR3b3JrSWQgZW50cnlcbiAgICAgIC8vIGRpcmVjdGx5XG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XG4gICAgfVxuICB9KTtcblxuICBhZGRyZXNzQm9va1tjaGFpbklkS2V5XSA9IG5ld0VudHJpZXM7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgY2hhaW5JZCBrZXkgdmFsdWVzIHRvIHRoZSBnaXZlbiBjaGFpbklkIGluIHBsYWNlIGZvciBhbGwgdmFsdWVzXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrRW50cmllc1xuICogQHBhcmFtIGNoYWluSWRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hhaW5JZHMobmV0d29ya0VudHJpZXMsIGNoYWluSWQpIHtcbiAgT2JqZWN0LnZhbHVlcyhuZXR3b3JrRW50cmllcykuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkgJiYgdHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgZW50cnkuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgdGhlIHR3byBnaXZlbiwgbm9uLWVtcHR5IGFycmF5cyBvZiB0b2tlbiBvYmplY3RzIGFuZCByZXR1cm5zIGEgbmV3XG4gKiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxob3N0VG9rZW5zXG4gKiBAcGFyYW0gcnBjVG9rZW5zXG4gKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn1cbiAqL1xuZnVuY3Rpb24gbWVyZ2VUb2tlbkFycmF5cyhsb2NhbGhvc3RUb2tlbnMsIHJwY1Rva2Vucykge1xuICBjb25zdCBsb2NhbGhvc3RUb2tlbnNNYXAgPSB0b2tlbkFycmF5VG9NYXAobG9jYWxob3N0VG9rZW5zKTtcbiAgY29uc3QgcnBjVG9rZW5zTWFwID0gdG9rZW5BcnJheVRvTWFwKHJwY1Rva2Vucyk7XG5cbiAgY29uc3QgbWVyZ2VkVG9rZW5zID0gW107XG4gIG5ldyBTZXQoW1xuICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsaG9zdFRva2Vuc01hcCksXG4gICAgLi4uT2JqZWN0LmtleXMocnBjVG9rZW5zTWFwKSxcbiAgXSkuZm9yRWFjaCgodG9rZW5BZGRyZXNzKSA9PiB7XG4gICAgbWVyZ2VkVG9rZW5zLnB1c2goe1xuICAgICAgLi4ubG9jYWxob3N0VG9rZW5zTWFwW3Rva2VuQWRkcmVzc10sXG4gICAgICAuLi5ycGNUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1lcmdlZFRva2VucztcblxuICBmdW5jdGlvbiB0b2tlbkFycmF5VG9NYXAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChtYXAsIHRva2VuKSA9PiB7XG4gICAgICBpZiAodG9rZW4/LmFkZHJlc3MgJiYgdHlwZW9mIHRva2VuPy5hZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICBtYXBbdG9rZW4uYWRkcmVzc10gPSB0b2tlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB2ZXJzaW9uID0gNjM7XG5cbi8qKlxuICogTW92ZXMgdG9rZW4gc3RhdGUgZnJvbSBwcmVmZXJlbmNlcyBjb250cm9sbGVyIHRvIFRva2Vuc0NvbnRyb2xsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBhY2NvdW50VG9rZW5zID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucztcbiAgY29uc3QgYWNjb3VudEhpZGRlblRva2VucyA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRIaWRkZW5Ub2tlbnM7XG5cbiAgY29uc3QgbmV3QWxsVG9rZW5zID0ge307XG4gIGlmIChhY2NvdW50VG9rZW5zKSB7XG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudEFkZHJlc3MpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnNbYWNjb3VudEFkZHJlc3NdKS5mb3JFYWNoKChjaGFpbklkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2Vuc0FycmF5ID0gYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc11bY2hhaW5JZF07XG4gICAgICAgIGlmIChuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9IHsgW2FjY291bnRBZGRyZXNzXTogdG9rZW5zQXJyYXkgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPSB7XG4gICAgICAgICAgICAuLi5uZXdBbGxUb2tlbnNbY2hhaW5JZF0sXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG5ld0FsbElnbm9yZWRUb2tlbnMgPSB7fTtcbiAgaWYgKGFjY291bnRIaWRkZW5Ub2tlbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcbiAgICAgICAgY29uc3QgaWdub3JlZFRva2Vuc0FycmF5ID0gYWNjb3VudEhpZGRlblRva2Vuc1thY2NvdW50QWRkcmVzc11bY2hhaW5JZF07XG4gICAgICAgIGlmIChuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xuICAgICAgICAgICAgW2FjY291bnRBZGRyZXNzXTogaWdub3JlZFRva2Vuc0FycmF5LFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSA9IHtcbiAgICAgICAgICAgIC4uLm5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0sXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3RhdGUuVG9rZW5zQ29udHJvbGxlcikge1xuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIuYWxsVG9rZW5zID0gbmV3QWxsVG9rZW5zO1xuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIuYWxsSWdub3JlZFRva2VucyA9IG5ld0FsbElnbm9yZWRUb2tlbnM7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlciA9IHtcbiAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxuICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICB9O1xuICB9XG5cbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRIaWRkZW5Ub2tlbnM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYXNzZXRJbWFnZXM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5oaWRkZW5Ub2tlbnM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnM7XG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5zdWdnZXN0ZWRUb2tlbnM7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcblxuY29uc3QgdmVyc2lvbiA9IDY4O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIFBlcm1pc3Npb25zQ29udHJvbGxlciBhbmQgUGVybWlzc2lvbnNNZXRhZGF0YSBzdWJzdGF0ZXNcbiAqIHRvIG1hdGNoIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIFBlcm1pc3Npb25zQ29udHJvbGxlciA9IHt9LFxuICAgIFBlcm1pc3Npb25zTWV0YWRhdGEgPSB7fSxcbiAgICAuLi5yZW1haW5pbmdTdGF0ZVxuICB9ID0gc3RhdGU7XG5cbiAgY29uc3Qge1xuICAgIGRvbWFpbk1ldGFkYXRhID0ge30sXG4gICAgcGVybWlzc2lvbnNIaXN0b3J5ID0ge30sXG4gICAgcGVybWlzc2lvbnNMb2cgPSBbXSxcbiAgfSA9IFBlcm1pc3Npb25zTWV0YWRhdGE7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZW1haW5pbmdTdGF0ZSxcbiAgICBQZXJtaXNzaW9uQ29udHJvbGxlcjogZ2V0UGVybWlzc2lvbkNvbnRyb2xsZXJTdGF0ZShQZXJtaXNzaW9uc0NvbnRyb2xsZXIpLFxuICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7XG4gICAgICBwZXJtaXNzaW9uQWN0aXZpdHlMb2c6IHBlcm1pc3Npb25zTG9nLFxuICAgICAgcGVybWlzc2lvbkhpc3Rvcnk6IHBlcm1pc3Npb25zSGlzdG9yeSxcbiAgICB9LFxuICAgIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI6IGdldFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXJTdGF0ZShcbiAgICAgIGRvbWFpbk1ldGFkYXRhLFxuICAgICksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSB7XG4gIGNvbnN0IHsgZG9tYWlucyA9IHt9IH0gPSBQZXJtaXNzaW9uc0NvbnRyb2xsZXI7XG5cbiAgLyoqXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluIGVudHJ5LiBFdmVyeSBleGlzdGluZyBkb21haW4gd2lsbCBoYXZlIGEgc2luZ2xlXG4gICAqIGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLCB3aGljaCBzaW1wbGlmaWVzIHRoZSB0cmFuc2Zvcm0uXG4gICAqXG4gICAqICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbyc6IHtcbiAgICogICBwZXJtaXNzaW9uczogW1xuICAgKiAgICAge1xuICAgKiAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ycGMtY2FwJ10sXG4gICAqICAgICAgICdjYXZlYXRzJzogW1xuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgIG5hbWU6ICdwcmltYXJ5QWNjb3VudE9ubHknLFxuICAgKiAgICAgICAgICAgdHlwZTogJ2xpbWl0UmVzcG9uc2VMZW5ndGgnLFxuICAgKiAgICAgICAgICAgdmFsdWU6IDEsXG4gICAqICAgICAgICAgfSxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICBuYW1lOiAnZXhwb3NlZEFjY291bnRzJyxcbiAgICogICAgICAgICAgIHR5cGU6ICdmaWx0ZXJSZXNwb25zZScsXG4gICAqICAgICAgICAgICB2YWx1ZTogWycweDBjOTdhNWM4MWU1MGEwMmZmOGJlNzNjYzNmMGEwNTY5ZTYxZjRlZDgnXSxcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnZGF0ZSc6IDE2MTYwMDYzNjk0OTgsXG4gICAqICAgICAgICdpZCc6ICczZDBiZGMyNy1lOGU0LTRmYjAtYTI0Yi0zNDBkNjFmNmEzZmEnLFxuICAgKiAgICAgICAnaW52b2tlcic6ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbycsXG4gICAqICAgICAgICdwYXJlbnRDYXBhYmlsaXR5JzogJ2V0aF9hY2NvdW50cycsXG4gICAqICAgICB9LFxuICAgKiAgIF0sXG4gICAqIH0sXG4gICAqL1xuXG4gIGNvbnN0IEVUSF9BQ0NPVU5UUyA9ICdldGhfYWNjb3VudHMnO1xuICBjb25zdCBORVdfQ0FWRUFUX1RZUEUgPSAncmVzdHJpY3RSZXR1cm5lZEFjY291bnRzJztcbiAgY29uc3QgT0xEX0NBVkVBVF9OQU1FID0gJ2V4cG9zZWRBY2NvdW50cyc7XG5cbiAgY29uc3Qgc3ViamVjdHMgPSBPYmplY3QuZW50cmllcyhkb21haW5zKS5yZWR1Y2UoXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBkb21haW5FbnRyeV0pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGVybWlzc2lvbnM6IFtldGhBY2NvdW50c1Blcm1pc3Npb25dLFxuICAgICAgfSA9IGRvbWFpbkVudHJ5O1xuXG4gICAgICAvLyBUaGVyZSBhcmUgdHdvIGNhdmVhdHMgZm9yIGVhY2ggZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIGJ1dCB3ZSBvbmx5XG4gICAgICAvLyBuZWVkIHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhlbSBpbiB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxuICAgICAgY29uc3Qgb2xkQ2F2ZWF0ID0gZXRoQWNjb3VudHNQZXJtaXNzaW9uLmNhdmVhdHMuZmluZChcbiAgICAgICAgKGNhdmVhdCkgPT4gY2F2ZWF0Lm5hbWUgPT09IE9MRF9DQVZFQVRfTkFNRSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld1Blcm1pc3Npb24gPSB7XG4gICAgICAgIC4uLmV0aEFjY291bnRzUGVybWlzc2lvbixcbiAgICAgICAgY2F2ZWF0czogW3sgdHlwZTogTkVXX0NBVkVBVF9UWVBFLCB2YWx1ZTogb2xkQ2F2ZWF0LnZhbHVlIH1dLFxuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmV2ZXIgdXNlZCB0aGlzLCBhbmQganVzdCBvbWl0IGl0IGluIHRoZSBuZXcgc3lzdGVtLlxuICAgICAgZGVsZXRlIG5ld1Blcm1pc3Npb25bJ0Bjb250ZXh0J107XG5cbiAgICAgIHRyYW5zZm9ybWVkW29yaWdpbl0gPSB7XG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICBbRVRIX0FDQ09VTlRTXTogbmV3UGVybWlzc2lvbixcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgfSxcbiAgICB7fSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHN1YmplY3RzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyU3RhdGUoZG9tYWluTWV0YWRhdGEpIHtcbiAgLyoqXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluTWV0YWRhdGEgZW50cnkuXG4gICAqXG4gICAqIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIjoge1xuICAgKiAgIFwiaG9zdFwiOiBcInd3dy55b3V0dWJlLmNvbVwiLFxuICAgKiAgIFwiaWNvblwiOiBudWxsLFxuICAgKiAgIFwibGFzdFVwZGF0ZWRcIjogMTYzNzY5NzkxNDkwOCxcbiAgICogICBcIm5hbWVcIjogXCJZb3VUdWJlXCJcbiAgICogfVxuICAgKi9cblxuICBjb25zdCBzdWJqZWN0TWV0YWRhdGEgPSBPYmplY3QuZW50cmllcyhkb21haW5NZXRhZGF0YSkucmVkdWNlKFxuICAgICh0cmFuc2Zvcm1lZCwgW29yaWdpbiwgbWV0YWRhdGFdKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUgPSBudWxsLFxuICAgICAgICBpY29uID0gbnVsbCxcbiAgICAgICAgZXh0ZW5zaW9uSWQgPSBudWxsLFxuICAgICAgICAuLi5vdGhlclxuICAgICAgfSA9IG1ldGFkYXRhO1xuXG4gICAgICAvLyBXZSdyZSBnZXR0aW5nIHJpZCBvZiB0aGVzZS5cbiAgICAgIGRlbGV0ZSBvdGhlci5sYXN0VXBkYXRlZDtcbiAgICAgIGRlbGV0ZSBvdGhlci5ob3N0O1xuXG4gICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkW29yaWdpbl0gPSB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpY29uVXJsOiBpY29uLFxuICAgICAgICAgIGV4dGVuc2lvbklkLFxuICAgICAgICAgIC4uLm90aGVyLFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICB9LFxuICAgIHt9LFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgc3ViamVjdE1ldGFkYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IFRFU1RfQ0hBSU5TIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxuICBuZXcgQmlnTnVtYmVyKGhleE51bWJlciB8fCAnMHgwJywgMTYpLmd0KDApO1xuXG5jb25zdCB2ZXJzaW9uID0gNjc7XG5cbi8qKlxuICogU2V0cyB0aGUgc2hvd1Rlc3ROZXR3b3JrcyBwcm9wZXJ0eSB0byB0cnVlIGlmIGl0IHdhcyBmYWxzZSBvciB1bmRlZmluZWQsIGFuZCB0aGVyZSBpcyBldmlkZW5jZVxuICogdGhhdCB0aGUgdXNlciBoYXMgdXNlZCBhIHRlc3QgbmV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbixcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcbiAgY29uc3QgcHJlZmVyZW5jZXMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIucHJlZmVyZW5jZXMgfHwge307XG5cbiAgaWYgKHByZWZlcmVuY2VzLnNob3dUZXN0TmV0d29ya3MpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnMgfHwge307XG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xuICBjb25zdCBjYWNoZWRCYWxhbmNlcyA9IHN0YXRlLkNhY2hlZEJhbGFuY2VzQ29udHJvbGxlcj8uY2FjaGVkQmFsYW5jZXMgfHwge307XG5cbiAgY29uc3QgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCA9IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKHByb3ZpZGVyPy5jaGFpbklkKTtcbiAgY29uc3QgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uID0gT2JqZWN0LnZhbHVlcyhcbiAgICB0cmFuc2FjdGlvbnMsXG4gICkuc29tZSgoeyBjaGFpbklkIH0pID0+IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKGNoYWluSWQpKTtcbiAgY29uc3QgdXNlckhhc0FDYWNoZWRCYWxhbmNlT25BVGVzdG5ldCA9IFRFU1RfQ0hBSU5TLnNvbWUoKGNoYWluSWQpID0+IHtcbiAgICBjb25zdCBjYWNoZWRCYWxhbmNlc0ZvckNoYWluID0gT2JqZWN0LnZhbHVlcyhjYWNoZWRCYWxhbmNlc1tjaGFpbklkXSB8fCB7fSk7XG4gICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPSBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoXG4gICAgICBoZXhOdW1iZXJJc0dyZWF0ZXJUaGFuWmVybyxcbiAgICApO1xuICAgIHJldHVybiB1c2VySGFzQUJhbGFuY2VHcmVhdGVyVGhhblplcm9PblRoaXNDaGFpbjtcbiAgfSk7XG4gIGNvbnN0IHVzZXJIYXNVc2VkQVRlc3RuZXQgPVxuICAgIHVzZXJJc0N1cnJlbnRseU9uQVRlc3ROZXQgfHxcbiAgICB1c2VySGFzTWFkZUFUZXN0TmV0VHJhbnNhY3Rpb24gfHxcbiAgICB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0O1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xuICAgICAgLi4uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgLi4ucHJlZmVyZW5jZXMsXG4gICAgICAgIHNob3dUZXN0TmV0d29ya3M6IHVzZXJIYXNVc2VkQVRlc3RuZXQsXG4gICAgICB9LFxuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuIiwiLypcblxuVGhpcyBtaWdyYXRpb24gdXBkYXRlcyBcInRyYW5zYWN0aW9uIHN0YXRlIGhpc3RvcnlcIiB0byBkaWZmcyBzdHlsZVxuXG4qL1xuXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgc25hcHNob3RGcm9tVHhNZXRhLFxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXG59IGZyb20gJy4uL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9saWIvdHgtc3RhdGUtaGlzdG9yeS1oZWxwZXJzJztcblxuY29uc3QgdmVyc2lvbiA9IDE4O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG5cbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIC8vIG5vIGhpc3Rvcnk6IGluaXRpYWxpemVcbiAgICAgIGlmICghdHhNZXRhLmhpc3RvcnkgfHwgdHhNZXRhLmhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XG4gICAgICAgIHR4TWV0YS5oaXN0b3J5ID0gW3NuYXBzaG90XTtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH1cbiAgICAgIC8vIGhhcyBoaXN0b3J5OiBtaWdyYXRlXG4gICAgICBjb25zdCBuZXdIaXN0b3J5ID0gbWlncmF0ZUZyb21TbmFwc2hvdHNUb0RpZmZzKHR4TWV0YS5oaXN0b3J5KVxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcbiAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8IGVudHJ5Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0pO1xuICAgICAgdHhNZXRhLmhpc3RvcnkgPSBuZXdIaXN0b3J5O1xuICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3U3RhdGU7XG59XG4iLCJ2YXIgdG9EYXRhVmlldyA9IHJlcXVpcmUoJ3RvLWRhdGEtdmlldycpXG5cbnZhciBSRkM0NjQ4ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J1xudmFyIFJGQzQ2NDhfSEVYID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ1xudmFyIENST0NLRk9SRCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWidcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlMzJFbmNvZGUgKGRhdGEsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGFscGhhYmV0LCBkZWZhdWx0UGFkZGluZ1xuXG4gIHN3aXRjaCAodmFyaWFudCkge1xuICAgIGNhc2UgJ1JGQzM1NDgnOlxuICAgIGNhc2UgJ1JGQzQ2NDgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4XG4gICAgICBkZWZhdWx0UGFkZGluZyA9IHRydWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnUkZDNDY0OC1IRVgnOlxuICAgICAgYWxwaGFiZXQgPSBSRkM0NjQ4X0hFWFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0Nyb2NrZm9yZCc6XG4gICAgICBhbHBoYWJldCA9IENST0NLRk9SRFxuICAgICAgZGVmYXVsdFBhZGRpbmcgPSBmYWxzZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UzMiB2YXJpYW50OiAnICsgdmFyaWFudClcbiAgfVxuXG4gIHZhciBwYWRkaW5nID0gKG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogZGVmYXVsdFBhZGRpbmcpXG4gIHZhciB2aWV3ID0gdG9EYXRhVmlldyhkYXRhKVxuXG4gIHZhciBiaXRzID0gMFxuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBvdXRwdXQgPSAnJ1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA4KSB8IHZpZXcuZ2V0VWludDgoaSlcbiAgICBiaXRzICs9IDhcblxuICAgIHdoaWxlIChiaXRzID49IDUpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFsodmFsdWUgPj4+IChiaXRzIC0gNSkpICYgMzFdXG4gICAgICBiaXRzIC09IDVcbiAgICB9XG4gIH1cblxuICBpZiAoYml0cyA+IDApIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbKHZhbHVlIDw8ICg1IC0gYml0cykpICYgMzFdXG4gIH1cblxuICBpZiAocGFkZGluZykge1xuICAgIHdoaWxlICgob3V0cHV0Lmxlbmd0aCAlIDgpICE9PSAwKSB7XG4gICAgICBvdXRwdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwiaW1wb3J0IG5hbWVoYXNoIGZyb20gJ2V0aC1lbnMtbmFtZWhhc2gnO1xuaW1wb3J0IEV0aCBmcm9tICdldGhqcy1xdWVyeSc7XG5pbXBvcnQgRXRoQ29udHJhY3QgZnJvbSAnZXRoanMtY29udHJhY3QnO1xuaW1wb3J0IGNvbnRlbnRIYXNoIGZyb20gJ0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaCc7XG5pbXBvcnQgcmVnaXN0cnlBYmkgZnJvbSAnLi9jb250cmFjdHMvcmVnaXN0cnknO1xuaW1wb3J0IHJlc29sdmVyQWJpIGZyb20gJy4vY29udHJhY3RzL3Jlc29sdmVyJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVuc1RvSXBmc0NvbnRlbnRJZCh7IHByb3ZpZGVyLCBuYW1lIH0pIHtcbiAgY29uc3QgZXRoID0gbmV3IEV0aChwcm92aWRlcik7XG4gIGNvbnN0IGhhc2ggPSBuYW1laGFzaC5oYXNoKG5hbWUpO1xuICBjb25zdCBjb250cmFjdCA9IG5ldyBFdGhDb250cmFjdChldGgpO1xuICAvLyBsb29rdXAgcmVnaXN0cnlcbiAgY29uc3QgY2hhaW5JZCA9IE51bWJlci5wYXJzZUludChhd2FpdCBldGgubmV0X3ZlcnNpb24oKSwgMTApO1xuICBjb25zdCByZWdpc3RyeUFkZHJlc3MgPSBnZXRSZWdpc3RyeUZvckNoYWluSWQoY2hhaW5JZCk7XG4gIGlmICghcmVnaXN0cnlBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEVuc0lwZnNSZXNvbHZlciAtIG5vIGtub3duIGVucy1pcGZzIHJlZ2lzdHJ5IGZvciBjaGFpbklkIFwiJHtjaGFpbklkfVwiYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IFJlZ2lzdHJ5ID0gY29udHJhY3QocmVnaXN0cnlBYmkpLmF0KHJlZ2lzdHJ5QWRkcmVzcyk7XG4gIC8vIGxvb2t1cCByZXNvbHZlclxuICBjb25zdCByZXNvbHZlckxvb2t1cFJlc3VsdCA9IGF3YWl0IFJlZ2lzdHJ5LnJlc29sdmVyKGhhc2gpO1xuICBjb25zdCByZXNvbHZlckFkZHJlc3MgPSByZXNvbHZlckxvb2t1cFJlc3VsdFswXTtcbiAgaWYgKGhleFZhbHVlSXNFbXB0eShyZXNvbHZlckFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbnNJcGZzUmVzb2x2ZXIgLSBubyByZXNvbHZlciBmb3VuZCBmb3IgbmFtZSBcIiR7bmFtZX1cImApO1xuICB9XG4gIGNvbnN0IFJlc29sdmVyID0gY29udHJhY3QocmVzb2x2ZXJBYmkpLmF0KHJlc29sdmVyQWRkcmVzcyk7XG5cbiAgY29uc3QgaXNFSVAxNTc3Q29tcGxpYW50ID0gYXdhaXQgUmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoJzB4YmMxYzU4ZDEnKTtcbiAgY29uc3QgaXNMZWdhY3lSZXNvbHZlciA9IGF3YWl0IFJlc29sdmVyLnN1cHBvcnRzSW50ZXJmYWNlKCcweGQ4Mzg5ZGM1Jyk7XG4gIGlmIChpc0VJUDE1NzdDb21wbGlhbnRbMF0pIHtcbiAgICBjb25zdCBjb250ZW50TG9va3VwUmVzdWx0ID0gYXdhaXQgUmVzb2x2ZXIuY29udGVudGhhc2goaGFzaCk7XG4gICAgY29uc3QgcmF3Q29udGVudEhhc2ggPSBjb250ZW50TG9va3VwUmVzdWx0WzBdO1xuICAgIGxldCBkZWNvZGVkQ29udGVudEhhc2ggPSBjb250ZW50SGFzaC5kZWNvZGUocmF3Q29udGVudEhhc2gpO1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZW50SGFzaC5nZXRDb2RlYyhyYXdDb250ZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2lwZnMtbnMnIHx8IHR5cGUgPT09ICdpcG5zLW5zJykge1xuICAgICAgZGVjb2RlZENvbnRlbnRIYXNoID0gY29udGVudEhhc2guaGVscGVycy5jaWRWMFRvVjFCYXNlMzIoXG4gICAgICAgIGRlY29kZWRDb250ZW50SGFzaCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZSwgaGFzaDogZGVjb2RlZENvbnRlbnRIYXNoIH07XG4gIH1cbiAgaWYgKGlzTGVnYWN5UmVzb2x2ZXJbMF0pIHtcbiAgICAvLyBsb29rdXAgY29udGVudCBpZFxuICAgIGNvbnN0IGNvbnRlbnRMb29rdXBSZXN1bHQgPSBhd2FpdCBSZXNvbHZlci5jb250ZW50KGhhc2gpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50TG9va3VwUmVzdWx0WzBdO1xuICAgIGlmIChoZXhWYWx1ZUlzRW1wdHkoY29udGVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVuc0lwZnNSZXNvbHZlciAtIG5vIGNvbnRlbnQgSUQgZm91bmQgZm9yIG5hbWUgXCIke25hbWV9XCJgLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3N3YXJtLW5zJywgaGFzaDogY29udGVudC5zbGljZSgyKSB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgRW5zSXBmc1Jlc29sdmVyIC0gdGhlIHJlc29sdmVyIGZvciBuYW1lIFwiJHtuYW1lfVwiIGlzIG5vdCBzdGFuZGFyZCwgaXQgc2hvdWxkIGVpdGhlciBzdXBwb3J0cyBjb250ZW50aGFzaCgpIG9yIGNvbnRlbnQoKWAsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGhleFZhbHVlSXNFbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICcweCcsXG4gICAgJzB4MCcsXG4gICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gIF0uaW5jbHVkZXModmFsdWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZ2lzdHJ5IGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBjaGFpbiBJRFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkIC0gdGhlIGNoYWluIElEXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IHRoZSByZWdpc3RyeSBhZGRyZXNzIGlmIGtub3duLCBudWxsIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBnZXRSZWdpc3RyeUZvckNoYWluSWQoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICBjYXNlIDU6XG4gICAgICAvLyBNYWlubmV0LCBSb3BzdGVuLCBSaW5rZWJ5LCBhbmQgR29lcmxpLCByZXNwZWN0aXZlbHksIHVzZSB0aGUgc2FtZSBhZGRyZXNzXG4gICAgICByZXR1cm4gJzB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIFJldHVybnMgYSBtaWRkbGV3YXJlIHRoYXQgYXBwZW5kcyB0aGUgREFwcCBvcmlnaW4gdG8gcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7eyBvcmlnaW46IHN0cmluZyB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVPcmlnaW5NaWRkbGV3YXJlKG9wdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9yaWdpbk1pZGRsZXdhcmUoXG4gICAgLyoqIEB0eXBlIHthbnl9ICovIHJlcSxcbiAgICAvKiogQHR5cGUge2FueX0gKi8gXyxcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyBuZXh0LFxuICApIHtcbiAgICByZXEub3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgbmV4dCgpO1xuICB9O1xufVxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgbWlkZGxld2FyZSB0aGF0IGFwcGVuZHMgdGhlIERBcHAgVGFiSWQgdG8gdGhlIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge3sgdGFiSWQ6IG51bWJlciB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUYWJJZE1pZGRsZXdhcmUob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdGFiSWRNaWRkbGV3YXJlKFxuICAgIC8qKiBAdHlwZSB7YW55fSAqLyByZXEsXG4gICAgLyoqIEB0eXBlIHthbnl9ICovIF8sXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gbmV4dCxcbiAgKSB7XG4gICAgcmVxLnRhYklkID0gb3B0cy50YWJJZDtcbiAgICBuZXh0KCk7XG4gIH07XG59XG4iLCIvLyBUaGlzIGZpbGUgcmVwbGFjZXMgYGluZGV4LmpzYCBpbiBidW5kbGVycyBsaWtlIHdlYnBhY2sgb3IgUm9sbHVwLFxuLy8gYWNjb3JkaW5nIHRvIGBicm93c2VyYCBjb25maWcgaW4gYHBhY2thZ2UuanNvbmAuXG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBBbGwgYnVuZGxlcnMgd2lsbCByZW1vdmUgdGhpcyBibG9jayBpbiBwcm9kdWN0aW9uIGJ1bmRsZVxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUmVhY3QgTmF0aXZlIGRvZXMgbm90IGhhdmUgYSBidWlsdC1pbiBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAnRm9yIHNlY3VyZSBJRCBpbnN0YWxsIGBleHBvLXJhbmRvbWAgbG9jYWxseSBhbmQgdXNlIGBuYW5vaWQvYXN5bmNgLidcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCAoIXNlbGYuY3J5cHRvICYmICFzZWxmLm1zQ3J5cHRvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3VyIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxuXG52YXIgY3J5cHRvID0gc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0b1xuXG4vLyBUaGlzIGFscGhhYmV0IHVzZXMgYS16IEEtWiAwLTkgXy0gc3ltYm9scy5cbi8vIFN5bWJvbHMgYXJlIGdlbmVyYXRlZCBmb3Igc21hbGxlciBzaXplLlxuLy8gLV96eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYTk4NzY1NDMyMTBaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQVxudmFyIHVybCA9ICctXydcbi8vIExvb3AgZnJvbSAzNiB0byAwIChmcm9tIHogdG8gYSBhbmQgOSB0byAwIGluIEJhc2UzNikuXG52YXIgaSA9IDM2XG53aGlsZSAoaS0tKSB7XG4gIC8vIDM2IGlzIHJhZGl4LiBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nKDM2KSByZXR1cm5zIG51bWJlclxuICAvLyBpbiBCYXNlMzYgcmVwcmVzZW50YXRpb24uIEJhc2UzNiBpcyBsaWtlIGhleCwgYnV0IGl0IHVzZXMgMOKAkzkgYW5kIGEtei5cbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpXG59XG4vLyBMb29wIGZyb20gMzYgdG8gMTAgKGZyb20gWiB0byBBIGluIEJhc2UzNikuXG5pID0gMzZcbndoaWxlIChpLS0gLSAxMCkge1xuICB1cmwgKz0gaS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHZhciBpZCA9ICcnXG4gIHZhciBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSB8fCAyMSkpXG4gIGkgPSBzaXplIHx8IDIxXG5cbiAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKWBcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIFdlIGNhbuKAmXQgdXNlIGJ5dGVzIGJpZ2dlciB0aGFuIHRoZSBhbHBoYWJldC4gNjMgaXMgMDAxMTExMTEgYml0bWFzay5cbiAgICAvLyBUaGlzIG1hc2sgcmVkdWNlcyByYW5kb20gYnl0ZSAwLTI1NSB0byAwLTYzIHZhbHVlcy5cbiAgICAvLyBUaGVyZSBpcyBubyBuZWVkIGluIGB8fCAnJ2AgYW5kIGAqIDEuNmAgaGFja3MgaW4gaGVyZSxcbiAgICAvLyBiZWNhdXNlIGJpdG1hc2sgdHJpbSBieXRlcyBleGFjdCB0byBhbHBoYWJldCBzaXplLlxuICAgIGlkICs9IHVybFtieXRlc1tpXSAmIDYzXVxuICB9XG4gIHJldHVybiBpZFxufVxuIiwiaW1wb3J0IHsgZXRoRXJyb3JzLCBzZXJpYWxpemVFcnJvciB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcblxuY29uc3QgY3JlYXRlTWV0YVJQQ0hhbmRsZXIgPSAoYXBpLCBvdXRTdHJlYW0pID0+IHtcbiAgcmV0dXJuIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWFwaVtkYXRhLm1ldGhvZF0pIHtcbiAgICAgIG91dFN0cmVhbS53cml0ZSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBlcnJvcjogZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCh7XG4gICAgICAgICAgbWVzc2FnZTogYCR7ZGF0YS5tZXRob2R9IG5vdCBmb3VuZGAsXG4gICAgICAgIH0pLFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBhcGlbZGF0YS5tZXRob2RdKC4uLmRhdGEucGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgIH1cblxuICAgIGlmIChvdXRTdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIG91dFN0cmVhbS53cml0ZSh7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBlcnJvcjogc2VyaWFsaXplRXJyb3IoZXJyb3IsIHsgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlIH0pLFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRTdHJlYW0ud3JpdGUoe1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1ldGFSUENIYW5kbGVyO1xuIiwiY29uc3QgRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuRHVwbGV4XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRW5naW5lU3RyZWFtXG5cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbSh7IGVuZ2luZSB9KSB7XG4gIGlmICghZW5naW5lKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5naW5lIHBhcmFtZXRlciEnKVxuICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4U3RyZWFtKHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSlcbiAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gIGlmIChlbmdpbmUub24pIHtcbiAgICBlbmdpbmUub24oJ25vdGlmaWNhdGlvbicsIChtZXNzYWdlKSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVxuXG4gIGZ1bmN0aW9uIHJlYWQgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZ1bmN0aW9uIHdyaXRlIChyZXEsIGVuY29kaW5nLCBjYikge1xuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIHRoaXMucHVzaChyZXMpXG4gICAgfSlcbiAgICBjYigpXG4gIH1cbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgZ2V0UGVyc2lzdGVudFN0YXRlIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXJzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5Db250cm9sbGVyTWVzc2VuZ2VyfSBDb250cm9sbGVyTWVzc2VuZ2VyXG4gKi9cblxuLyoqXG4gKiBBbiBPYnNlcnZhYmxlU3RvcmUgdGhhdCBjYW4gY29tcG9zZXMgYSBmbGF0XG4gKiBzdHJ1Y3R1cmUgb2YgY2hpbGQgc3RvcmVzIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgd2hpY2ggc3RvcmVzIGFyZSBiZWluZyBjb21wb3NlZC4gVGhlIGtleSBpcyB0aGUgbmFtZSBvZiB0aGVcbiAgICogc3RvcmUsIGFuZCB0aGUgdmFsdWUgaXMgZWl0aGVyIGFuIE9ic2VyYWJsZVN0b3JlLCBvciBhIGNvbnRyb2xsZXIgdGhhdFxuICAgKiBleHRlbmRzIG9uZSBvZiB0aGUgdHdvIGJhc2UgY29udHJvbGxlcnMgaW4gdGhlIGBAbWV0YW1hc2svY29udHJvbGxlcnNgXG4gICAqIHBhY2thZ2UuXG4gICAqXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBPYmplY3Q+fVxuICAgKi9cbiAgY29uZmlnID0ge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdG9yZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29uZmlnXSAtIE1hcCBvZiBpbnRlcm5hbCBzdGF0ZSBrZXlzIHRvIGNoaWxkIHN0b3Jlc1xuICAgKiBAcGFyYW0ge0NvbnRyb2xsZXJNZXNzZW5nZXJ9IG9wdGlvbnMuY29udHJvbGxlck1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyXG4gICAqICAgbWVzc2VuZ2VyLCB1c2VkIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgZnJvbSBCYXNlQ29udHJvbGxlclYyLWJhc2VkXG4gICAqICAgY29udHJvbGxlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdGF0ZV0gLSBUaGUgaW5pdGlhbCBzdG9yZSBzdGF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RdIC0gV2hldGhlciBvciBub3QgdG8gYXBwbHkgdGhlIHBlcnNpc3RlbmNlIGZvciB2MiBjb250cm9sbGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWcsIGNvbnRyb2xsZXJNZXNzZW5nZXIsIHN0YXRlLCBwZXJzaXN0IH0pIHtcbiAgICBzdXBlcihzdGF0ZSk7XG4gICAgdGhpcy5wZXJzaXN0ID0gcGVyc2lzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBjb250cm9sbGVyTWVzc2VuZ2VyO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMudXBkYXRlU3RydWN0dXJlKGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VzIGEgbmV3IGludGVybmFsIHN0b3JlIHN1YnNjcmlwdGlvbiBzdHJ1Y3R1cmVcbiAgICpcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBPYmplY3Q+fSBjb25maWcgLSBEZXNjcmliZXMgd2hpY2ggc3RvcmVzIGFyZSBiZWluZ1xuICAgKiAgIGNvbXBvc2VkLiBUaGUga2V5IGlzIHRoZSBuYW1lIG9mIHRoZSBzdG9yZSwgYW5kIHRoZSB2YWx1ZSBpcyBlaXRoZXIgYW5cbiAgICogICBPYnNlcmFibGVTdG9yZSwgb3IgYSBjb250cm9sbGVyIHRoYXQgZXh0ZW5kcyBvbmUgb2YgdGhlIHR3byBiYXNlXG4gICAqICAgY29udHJvbGxlcnMgaW4gdGhlIGBAbWV0YW1hc2svY29udHJvbGxlcnNgIHBhY2thZ2UuXG4gICAqL1xuICB1cGRhdGVTdHJ1Y3R1cmUoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICBpZiAoIWNvbmZpZ1trZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5kZWZpbmVkICcke2tleX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKHN0b3JlLnN1YnNjcmliZSkge1xuICAgICAgICBjb25maWdba2V5XS5zdWJzY3JpYmUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IFtrZXldOiBzdGF0ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxuICAgICAgICAgIGAke3N0b3JlLm5hbWV9OnN0YXRlQ2hhbmdlYCxcbiAgICAgICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcnNpc3QpIHtcbiAgICAgICAgICAgICAgdXBkYXRlZFN0YXRlID0gZ2V0UGVyc2lzdGVudFN0YXRlKHN0YXRlLCBjb25maWdba2V5XS5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHsgW2tleV06IHVwZGF0ZWRTdGF0ZSB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgYWxsIGNoaWxkIHN0b3JlIHN0YXRlIGludG8gYSBzaW5nbGUgb2JqZWN0IHJhdGhlciB0aGFuXG4gICAqIHJldHVybmluZyBhbiBvYmplY3Qga2V5ZWQgYnkgY2hpbGQgc3RvcmUgY2xhc3MgbmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBtZXJnZWQgY2hpbGQgc3RvcmUgc3RhdGVcbiAgICovXG4gIGdldEZsYXRTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCBmbGF0U3RhdGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZykpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLmdldFN0YXRlXG4gICAgICAgID8gY29udHJvbGxlci5nZXRTdGF0ZSgpXG4gICAgICAgIDogY29udHJvbGxlci5zdGF0ZTtcbiAgICAgIGZsYXRTdGF0ZSA9IHsgLi4uZmxhdFN0YXRlLCAuLi5zdGF0ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gZmxhdFN0YXRlO1xuICB9XG59XG4iLCJpbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWlkZGxld2FyZSB0aGF0IGxvZ3MgUlBDIGFjdGl2aXR5XG4gKlxuICogQHBhcmFtIHt7IG9yaWdpbjogc3RyaW5nIH19IG9wdHMgLSBUaGUgbWlkZGxld2FyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nZ2VyTWlkZGxld2FyZShcbiAgICAvKiogQHR5cGUge2FueX0gKi8gcmVxLFxuICAgIC8qKiBAdHlwZSB7YW55fSAqLyByZXMsXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gbmV4dCxcbiAgKSB7XG4gICAgbmV4dCgoLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gY2IpID0+IHtcbiAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgbG9nLmVycm9yKCdFcnJvciBpbiBSUEMgcmVzcG9uc2U6XFxuJywgcmVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEuaXNNZXRhbWFza0ludGVybmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZy5pbmZvKGBSUEMgKCR7b3B0cy5vcmlnaW59KTpgLCByZXEsICctPicsIHJlcyk7XG4gICAgICBjYigpO1xuICAgIH0pO1xuICB9O1xufVxuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgZXh0ZW5zaW9uIGZyb20gJ2V4dGVuc2lvbml6ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYSBtaWRkbGV3YXJlIHRoYXQgaW50ZXJjZXB0cyBgd2FsbGV0X3JlZ2lzdGVyT25ib2FyZGluZ2AgbWVzc2FnZXNcbiAqXG4gKiBAcGFyYW0ge3sgbG9jYXRpb246IHN0cmluZywgcmVnaXN0ZXJPbmJvYXJkaW5nOiBGdW5jdGlvbiB9fSBvcHRzIC0gVGhlIG1pZGRsZXdhcmUgb3B0aW9uc1xuICogQHJldHVybnMgeyhyZXE6IGFueSwgcmVzOiBhbnksIG5leHQ6IEZ1bmN0aW9uLCBlbmQ6IEZ1bmN0aW9uKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSh7XG4gIGxvY2F0aW9uLFxuICByZWdpc3Rlck9uYm9hcmRpbmcsXG59KSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBvcmlnaW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBlbmQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcS5tZXRob2QgIT09ICd3YWxsZXRfcmVnaXN0ZXJPbmJvYXJkaW5nJykge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXEudGFiSWQgJiYgcmVxLnRhYklkICE9PSBleHRlbnNpb24udGFicy5UQUJfSURfTk9ORSkge1xuICAgICAgICBhd2FpdCByZWdpc3Rlck9uYm9hcmRpbmcobG9jYXRpb24sIHJlcS50YWJJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgYCd3YWxsZXRfcmVnaXN0ZXJPbmJvYXJkaW5nJyBtZXNzYWdlIGZyb20gJHtsb2NhdGlvbn0gaWdub3JlZCBkdWUgdG8gbWlzc2luZyB0YWJJZGAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXMucmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlbmQoZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW5pdFN0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNlZWRQaHJhc2VCYWNrZWRVcCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBoYXMgY29tcGxldGVkIHRoZSBzZWVkIHBocmFzZSBiYWNrdXAgY2hhbGxlbmdlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbXBsZXRlZE9uYm9hcmRpbmcgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGNvbXBsZXRlZCB0aGUgb25ib2FyZGluZyBmbG93XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPbmJvYXJkaW5nT3B0aW9uc1xuICogQHByb3BlcnR5IHtJbml0U3RhdGV9IGluaXRTdGF0ZSBUaGUgaW5pdGlhbCBjb250cm9sbGVyIHN0YXRlXG4gKi9cblxuLyoqXG4gKiBDb250cm9sbGVyIHJlc3BvbnNpYmxlIGZvciBtYWludGFpbmluZ1xuICogc3RhdGUgcmVsYXRlZCB0byBvbmJvYXJkaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9uYm9hcmRpbmdDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge09uYm9hcmRpbmdPcHRpb25zfSBbb3B0c10gLSBDb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgaW5pdGlhbFRyYW5zaWVudFN0YXRlID0ge1xuICAgICAgb25ib2FyZGluZ1RhYnM6IHt9LFxuICAgIH07XG4gICAgY29uc3QgaW5pdFN0YXRlID0ge1xuICAgICAgc2VlZFBocmFzZUJhY2tlZFVwOiBudWxsLFxuICAgICAgZmlyc3RUaW1lRmxvd1R5cGU6IG51bGwsXG4gICAgICBjb21wbGV0ZWRPbmJvYXJkaW5nOiBmYWxzZSxcbiAgICAgIC4uLm9wdHMuaW5pdFN0YXRlLFxuICAgICAgLi4uaW5pdGlhbFRyYW5zaWVudFN0YXRlLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgfVxuXG4gIHNldFNlZWRQaHJhc2VCYWNrZWRVcChuZXdTZWVkUGhyYXNlQmFja1VwU3RhdGUpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHNlZWRQaHJhc2VCYWNrZWRVcDogbmV3U2VlZFBocmFzZUJhY2tVcFN0YXRlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gLyoqXG4gIC8vICAqIFNldHMgdGhlIGNvbXBsZXRlZE9uYm9hcmRpbmcgc3RhdGUgdG8gdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSB1c2VyIGhhcyBjb21wbGV0ZWQgdGhlXG4gIC8vICAqIG9uYm9hcmRpbmcgcHJvY2Vzcy5cbiAgLy8gICovXG4gIGNvbXBsZXRlT25ib2FyZGluZygpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGNvbXBsZXRlZE9uYm9hcmRpbmc6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgZmlyc3RUaW1lRmxvd1R5cGVgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGZpcnN0IHRpbWUgZmxvdyAtIGNyZWF0ZSBvciBpbXBvcnQgLSB0aGUgdXNlciB3aXNoZXMgdG8gZm9sbG93XG4gICAqL1xuICBzZXRGaXJzdFRpbWVGbG93VHlwZSh0eXBlKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZpcnN0VGltZUZsb3dUeXBlOiB0eXBlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyaW5nIGEgc2l0ZSBhcyBoYXZpbmcgaW5pdGlhdGVkIG9uYm9hcmRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIG9mIHRoZSBzaXRlIHJlZ2lzdGVyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJJZCAtIFRoZSBpZCBvZiB0aGUgdGFiIHJlZ2lzdGVyaW5nXG4gICAqL1xuICByZWdpc3Rlck9uYm9hcmRpbmcgPSBhc3luYyAobG9jYXRpb24sIHRhYklkKSA9PiB7XG4gICAgaWYgKHRoaXMuY29tcGxldGVkT25ib2FyZGluZykge1xuICAgICAgbG9nLmRlYnVnKCdJZ25vcmluZyByZWdpc3Rlck9uYm9hcmRpbmc7IHVzZXIgYWxyZWFkeSBvbmJvYXJkZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25ib2FyZGluZ1RhYnMgPSB7IC4uLnRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5vbmJvYXJkaW5nVGFicyB9O1xuICAgIGlmICghb25ib2FyZGluZ1RhYnNbbG9jYXRpb25dIHx8IG9uYm9hcmRpbmdUYWJzW2xvY2F0aW9uXSAhPT0gdGFiSWQpIHtcbiAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgYFJlZ2lzdGVyaW5nIG9uYm9hcmRpbmcgdGFiIGF0IGxvY2F0aW9uICcke2xvY2F0aW9ufScgd2l0aCB0YWJJZCAnJHt0YWJJZH0nYCxcbiAgICAgICk7XG4gICAgICBvbmJvYXJkaW5nVGFic1tsb2NhdGlvbl0gPSB0YWJJZDtcbiAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBvbmJvYXJkaW5nVGFicyB9KTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQgeyBNSU5VVEUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBTdGF0ZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZFVubG9ja0xpc3RlbmVyLFxuICAgICAgaXNVbmxvY2tlZCxcbiAgICAgIGluaXRTdGF0ZSxcbiAgICAgIG9uSW5hY3RpdmVUaW1lb3V0LFxuICAgICAgc2hvd1VubG9ja1JlcXVlc3QsXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlLFxuICAgICAgcXJIYXJkd2FyZVN0b3JlLFxuICAgIH0gPSBvcHRzO1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9uSW5hY3RpdmVUaW1lb3V0ID0gb25JbmFjdGl2ZVRpbWVvdXQgfHwgKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdGltZW91dE1pbnV0ZXM6IDAsXG4gICAgICBjb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duOiB0cnVlLFxuICAgICAgZGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lOiBudWxsLFxuICAgICAgYnJvd3NlckVudmlyb25tZW50OiB7fSxcbiAgICAgIHBvcHVwR2FzUG9sbFRva2VuczogW10sXG4gICAgICBub3RpZmljYXRpb25HYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIGZ1bGxTY3JlZW5HYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IGZhbHNlLFxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICBjb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQ6IGZhbHNlLFxuICAgICAgZW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkOiBmYWxzZSxcbiAgICAgIHNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd246IHRydWUsXG4gICAgICB0cmV6b3JNb2RlbDogbnVsbCxcbiAgICAgIC4uLmluaXRTdGF0ZSxcbiAgICAgIHFySGFyZHdhcmU6IHt9LFxuICAgICAgY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZToge30sXG4gICAgfSk7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG5cbiAgICB0aGlzLmlzVW5sb2NrZWQgPSBpc1VubG9ja2VkO1xuICAgIHRoaXMud2FpdGluZ0ZvclVubG9jayA9IFtdO1xuICAgIGFkZFVubG9ja0xpc3RlbmVyKHRoaXMuaGFuZGxlVW5sb2NrLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc2hvd1VubG9ja1JlcXVlc3QgPSBzaG93VW5sb2NrUmVxdWVzdDtcblxuICAgIHByZWZlcmVuY2VzU3RvcmUuc3Vic2NyaWJlKCh7IHByZWZlcmVuY2VzIH0pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUudGltZW91dE1pbnV0ZXMgIT09IHByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0KSB7XG4gICAgICAgIHRoaXMuX3NldEluYWN0aXZlVGltZW91dChwcmVmZXJlbmNlcy5hdXRvTG9ja1RpbWVMaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBxckhhcmR3YXJlU3RvcmUuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHFySGFyZHdhcmU6IHN0YXRlIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBwcmVmZXJlbmNlcyB9ID0gcHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuX3NldEluYWN0aXZlVGltZW91dChwcmVmZXJlbmNlcy5hdXRvTG9ja1RpbWVMaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICogVGhpcyBQcm9taXNlIHdpbGwgbmV2ZXIgcmVqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0IC0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIG5vdGlmaWNhdGlvblxuICAgKiBwb3B1cCBzaG91bGQgYmUgb3BlbmVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzXG4gICAqIHVubG9ja2VkLCBvciBpbW1lZGlhdGVseSBpZiB0aGUgZXh0ZW5zaW9uIGlzIGFscmVhZHkgdW5sb2NrZWQuXG4gICAqL1xuICBnZXRVbmxvY2tQcm9taXNlKHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YWl0Rm9yVW5sb2NrKHJlc29sdmUsIHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgUHJvbWlzZSdzIHJlc29sdmUgZnVuY3Rpb24gdG8gdGhlIHdhaXRpbmdGb3JVbmxvY2sgcXVldWUuXG4gICAqIEFsc28gb3BlbnMgdGhlIGV4dGVuc2lvbiBwb3B1cCBpZiBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZS5yZXNvbHZlfSByZXNvbHZlIC0gQSBQcm9taXNlJ3MgcmVzb2x2ZSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICogYmUgY2FsbGVkIHdoZW4gdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRTaG93VW5sb2NrUmVxdWVzdCAtIFdoZXRoZXIgdGhlIGV4dGVuc2lvbiBub3RpZmljYXRpb25cbiAgICogcG9wdXAgc2hvdWxkIGJlIG9wZW5lZC5cbiAgICovXG4gIHdhaXRGb3JVbmxvY2socmVzb2x2ZSwgc2hvdWxkU2hvd1VubG9ja1JlcXVlc3QpIHtcbiAgICB0aGlzLndhaXRpbmdGb3JVbmxvY2sucHVzaCh7IHJlc29sdmUgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gICAgaWYgKHNob3VsZFNob3dVbmxvY2tSZXF1ZXN0KSB7XG4gICAgICB0aGlzLl9zaG93VW5sb2NrUmVxdWVzdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFpbnMgdGhlIHdhaXRpbmdGb3JVbmxvY2sgcXVldWUsIHJlc29sdmluZyBhbGwgdGhlIHJlbGF0ZWQgUHJvbWlzZXMuXG4gICAqL1xuICBoYW5kbGVVbmxvY2soKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvclVubG9jay5sZW5ndGggPiAwKSB7XG4gICAgICB3aGlsZSAodGhpcy53YWl0aW5nRm9yVW5sb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yVW5sb2NrLnNoaWZ0KCkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgaG9tZSB0YWJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWVdIC0gdGhlIHRhYiBuYW1lXG4gICAqL1xuICBzZXREZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWUoZGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBkZWZhdWx0SG9tZUFjdGl2ZVRhYk5hbWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoYXQgdGhlIHVzZXIgaGFzIHNlZW4gdGhlIGNvbm5lY3RlZCBzdGF0dXMgaW5mbyBwb3BvdmVyXG4gICAqL1xuICBzZXRDb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93bjogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgdGhhdCB0aGUgdXNlciBoYXMgYmVlbiBzaG93biB0aGUgcmVjb3ZlcnkgcGhyYXNlIHJlbWluZGVyLlxuICAgKi9cbiAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bigpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd246IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgdGltZSB0aGUgdXNlciBoYXMgc2VlbiB0aGUgcmVjb3ZlcnkgcGhyYXNlIHJlbWluZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0U2hvd24gLSB0aW1lc3RhbXAgd2hlbiB1c2VyIHdhcyBsYXN0IHNob3duIHRoZSByZW1pbmRlci5cbiAgICovXG4gIHNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd24obGFzdFNob3duKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICByZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duOiBsYXN0U2hvd24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGFzdCBhY3RpdmUgdGltZSB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgc2V0TGFzdEFjdGl2ZVRpbWUoKSB7XG4gICAgdGhpcy5fcmVzZXRUaW1lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGluYWN0aXZlIHRpbWVvdXQgZm9yIHRoZSBhcHBcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNaW51dGVzIC0gVGhlIGluYWN0aXZlIHRpbWVvdXQgaW4gbWludXRlcy5cbiAgICovXG4gIF9zZXRJbmFjdGl2ZVRpbWVvdXQodGltZW91dE1pbnV0ZXMpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRpbWVvdXRNaW51dGVzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVzZXRUaW1lcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgaW5hY3RpdmUgdGltZXJcbiAgICpcbiAgICogSWYgdGhlIHtAY29kZSB0aW1lb3V0TWludXRlc30gc3RhdGUgaXMgZmFsc3kgKGkuZS4sIHplcm8pIHRoZW4gYSBuZXdcbiAgICogdGltZXIgd2lsbCBub3QgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFRpbWVyKCkge1xuICAgIGNvbnN0IHsgdGltZW91dE1pbnV0ZXMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuXG4gICAgaWYgKCF0aW1lb3V0TWludXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gdGhpcy5vbkluYWN0aXZlVGltZW91dCgpLFxuICAgICAgdGltZW91dE1pbnV0ZXMgKiBNSU5VVEUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGJyb3dzZXIgYW5kIE9TIGVudmlyb25tZW50XG4gICAqXG4gICAqIEBwYXJhbSBvc1xuICAgKiBAcGFyYW0gYnJvd3NlclxuICAgKi9cbiAgc2V0QnJvd3NlckVudmlyb25tZW50KG9zLCBicm93c2VyKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGJyb3dzZXJFbnZpcm9ubWVudDogeyBvcywgYnJvd3NlciB9IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwb2xsaW5nVG9rZW4gZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnRUeXBlXG4gICAqXG4gICAqIEBwYXJhbSBwb2xsaW5nVG9rZW5cbiAgICogQHBhcmFtIHBvbGxpbmdUb2tlblR5cGVcbiAgICovXG4gIGFkZFBvbGxpbmdUb2tlbihwb2xsaW5nVG9rZW4sIHBvbGxpbmdUb2tlblR5cGUpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKClbcG9sbGluZ1Rva2VuVHlwZV07XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBbcG9sbGluZ1Rva2VuVHlwZV06IFsuLi5wcmV2U3RhdGUsIHBvbGxpbmdUb2tlbl0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlcyBhIHBvbGxpbmdUb2tlbiBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudFR5cGVcbiAgICpcbiAgICogQHBhcmFtIHBvbGxpbmdUb2tlblxuICAgKiBAcGFyYW0gcG9sbGluZ1Rva2VuVHlwZVxuICAgKi9cbiAgcmVtb3ZlUG9sbGluZ1Rva2VuKHBvbGxpbmdUb2tlbiwgcG9sbGluZ1Rva2VuVHlwZSkge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVtwb2xsaW5nVG9rZW5UeXBlXTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIFtwb2xsaW5nVG9rZW5UeXBlXTogcHJldlN0YXRlLmZpbHRlcigodG9rZW4pID0+IHRva2VuICE9PSBwb2xsaW5nVG9rZW4pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGNsZWFycyBhbGwgcG9sbGluZ1Rva2Vuc1xuICAgKi9cbiAgY2xlYXJQb2xsaW5nVG9rZW5zKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgcG9wdXBHYXNQb2xsVG9rZW5zOiBbXSxcbiAgICAgIG5vdGlmaWNhdGlvbkdhc1BvbGxUb2tlbnM6IFtdLFxuICAgICAgZnVsbFNjcmVlbkdhc1BvbGxUb2tlbnM6IFtdLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgdGVzdG5ldCBkaXNtaXNzYWwgbGluayBzaG91bGQgYmUgc2hvd24gaW4gdGhlIG5ldHdvcmsgZHJvcGRvd25cbiAgICpcbiAgICogQHBhcmFtIHNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd25cbiAgICovXG4gIHNldFNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd24oc2hvd1Rlc3RuZXRNZXNzYWdlSW5Ecm9wZG93bikge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9wZXJ0eSBpbmRpY2F0aW5nIHRoZSBtb2RlbCBvZiB0aGUgdXNlcidzIFRyZXpvciBoYXJkd2FyZSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHRyZXpvck1vZGVsIC0gVGhlIFRyZXpvciBtb2RlbC5cbiAgICovXG4gIHNldFRyZXpvck1vZGVsKHRyZXpvck1vZGVsKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHRyZXpvck1vZGVsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgYGNvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZGAgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIGNvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZFxuICAgKi9cbiAgc2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkKFxuICAgIGNvbGxlY3RpYmxlc0RldGVjdGlvbk5vdGljZURpc21pc3NlZCxcbiAgKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBjb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIHRoZSBgZW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0gZW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkXG4gICAqL1xuICBzZXRFbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQoZW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBlbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIHRoZSBgY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZWAgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIGNvbGxlY3RpYmxlc0Ryb3Bkb3duU3RhdGVcbiAgICovXG4gIHVwZGF0ZUNvbGxlY3RpYmxlRHJvcERvd25TdGF0ZShjb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBjb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7XG4gIFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMsXG4gIFdFQjNfU0hJTV9VU0FHRV9BTEVSVF9TVEFURVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYWxlcnRzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbGVydENvbnRyb2xsZXJJbml0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhbGVydEVuYWJsZWRuZXNzIC0gQSBtYXAgb2YgYWxlcnRzIElEcyB0byBib29sZWFucywgd2hlcmVcbiAqIGB0cnVlYCBpbmRpY2F0ZXMgdGhhdCB0aGUgYWxlcnQgaXMgZW5hYmxlZCBhbmQgc2hvd24sIGFuZCBgZmFsc2VgIHRoZSBvcHBvc2l0ZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2lucyAtIEEgbWFwIG9mIG9yaWdpblxuICogc3RyaW5ncyB0byBib29sZWFucyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwic3dpdGNoIHRvIGNvbm5lY3RlZFwiIGFsZXJ0IGhhc1xuICogYmVlbiBzaG93biAoYHRydWVgKSBvciBvdGhlcndpc2UgKGBmYWxzZWApLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQWxlcnRDb250cm9sbGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBbGVydENvbnRyb2xsZXJJbml0U3RhdGV9IGluaXRTdGF0ZSAtIFRoZSBpbml0aWFsIGNvbnRyb2xsZXIgc3RhdGVcbiAqL1xuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIGFsZXJ0RW5hYmxlZG5lc3M6IFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMucmVkdWNlKFxuICAgIChhbGVydEVuYWJsZWRuZXNzLCBhbGVydFR5cGUpID0+IHtcbiAgICAgIGFsZXJ0RW5hYmxlZG5lc3NbYWxlcnRUeXBlXSA9IHRydWU7XG4gICAgICByZXR1cm4gYWxlcnRFbmFibGVkbmVzcztcbiAgICB9LFxuICAgIHt9LFxuICApLFxuICB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2luczoge30sXG4gIHdlYjNTaGltVXNhZ2VPcmlnaW5zOiB7fSxcbn07XG5cbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3IgbWFpbnRhaW5pbmcgYWxlcnQtcmVsYXRlZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnRDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWxlcnRDb250cm9sbGVyT3B0aW9uc30gW29wdHNdIC0gQ29udHJvbGxlciBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW5pdFN0YXRlID0ge30sIHByZWZlcmVuY2VzU3RvcmUgfSA9IG9wdHM7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAuLi5kZWZhdWx0U3RhdGUsXG4gICAgICBhbGVydEVuYWJsZWRuZXNzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRTdGF0ZS5hbGVydEVuYWJsZWRuZXNzLFxuICAgICAgICAuLi5pbml0U3RhdGUuYWxlcnRFbmFibGVkbmVzcyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHN0YXRlKTtcblxuICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gcHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzcztcblxuICAgIHByZWZlcmVuY2VzU3RvcmUuc3Vic2NyaWJlKCh7IHNlbGVjdGVkQWRkcmVzcyB9KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRTdGF0ZS51bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2lucyAmJlxuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyAhPT0gc2VsZWN0ZWRBZGRyZXNzXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2luczoge30gfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRBbGVydEVuYWJsZWRuZXNzKGFsZXJ0SWQsIGVuYWJsZWRuZXNzKSB7XG4gICAgbGV0IHsgYWxlcnRFbmFibGVkbmVzcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGFsZXJ0RW5hYmxlZG5lc3MgPSB7IC4uLmFsZXJ0RW5hYmxlZG5lc3MgfTtcbiAgICBhbGVydEVuYWJsZWRuZXNzW2FsZXJ0SWRdID0gZW5hYmxlZG5lc3M7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFsZXJ0RW5hYmxlZG5lc3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgXCJzd2l0Y2ggdG8gY29ubmVjdGVkXCIgYWxlcnQgYXMgc2hvd24gZm9yIHRoZSBnaXZlbiBvcmlnaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gdGhlIGFsZXJ0IGhhcyBiZWVuIHNob3duIGZvclxuICAgKi9cbiAgc2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bihvcmlnaW4pIHtcbiAgICBsZXQgeyB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2lucyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd25PcmlnaW5zID0ge1xuICAgICAgLi4udW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnMsXG4gICAgfTtcbiAgICB1bmNvbm5lY3RlZEFjY291bnRBbGVydFNob3duT3JpZ2luc1tvcmlnaW5dID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bk9yaWdpbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgd2ViMyBzaGltIHVzYWdlIHN0YXRlIGZvciB0aGUgZ2l2ZW4gb3JpZ2luLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB0byBnZXQgdGhlIHdlYjMgc2hpbSB1c2FnZSBzdGF0ZSBmb3IuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCAxIHwgMn0gVGhlIHdlYjMgc2hpbSB1c2FnZSBzdGF0ZSBmb3IgdGhlIGdpdmVuXG4gICAqIG9yaWdpbiwgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlKG9yaWdpbikge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkud2ViM1NoaW1Vc2FnZU9yaWdpbnNbb3JpZ2luXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3ZWIzIHNoaW0gdXNhZ2Ugc3RhdGUgZm9yIHRoZSBnaXZlbiBvcmlnaW4gdG8gUkVDT1JERUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoZSB0aGF0IHVzZWQgdGhlIHdlYjMgc2hpbS5cbiAgICovXG4gIHNldFdlYjNTaGltVXNhZ2VSZWNvcmRlZChvcmlnaW4pIHtcbiAgICB0aGlzLl9zZXRXZWIzU2hpbVVzYWdlU3RhdGUob3JpZ2luLCBXRUIzX1NISU1fVVNBR0VfQUxFUlRfU1RBVEVTLlJFQ09SREVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3ZWIzIHNoaW0gdXNhZ2Ugc3RhdGUgZm9yIHRoZSBnaXZlbiBvcmlnaW4gdG8gRElTTUlTU0VELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB0aGF0IHRoZSB3ZWIzIHNoaW0gbm90aWZpY2F0aW9uIHdhc1xuICAgKiBkaXNtaXNzZWQgZm9yLlxuICAgKi9cbiAgc2V0V2ViM1NoaW1Vc2FnZUFsZXJ0RGlzbWlzc2VkKG9yaWdpbikge1xuICAgIHRoaXMuX3NldFdlYjNTaGltVXNhZ2VTdGF0ZShvcmlnaW4sIFdFQjNfU0hJTV9VU0FHRV9BTEVSVF9TVEFURVMuRElTTUlTU0VEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiB0byBzZXQgdGhlIHN0YXRlIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHN0YXRlIHZhbHVlIHRvIHNldC5cbiAgICovXG4gIF9zZXRXZWIzU2hpbVVzYWdlU3RhdGUob3JpZ2luLCB2YWx1ZSkge1xuICAgIGxldCB7IHdlYjNTaGltVXNhZ2VPcmlnaW5zIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgd2ViM1NoaW1Vc2FnZU9yaWdpbnMgPSB7XG4gICAgICAuLi53ZWIzU2hpbVVzYWdlT3JpZ2lucyxcbiAgICB9O1xuICAgIHdlYjNTaGltVXNhZ2VPcmlnaW5zW29yaWdpbl0gPSB2YWx1ZTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgd2ViM1NoaW1Vc2FnZU9yaWdpbnMgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgYnVmZmVyVG9IZXgsIHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgaGV4UmUgPSAvXlswLTlBLUZhLWZdKyQvZ3U7XG5cbi8qKlxuICogUmVwcmVzZW50cywgYW5kIGNvbnRhaW5zIGRhdGEgYWJvdXQsIGFuICdldGhfZGVjcnlwdCcgdHlwZSBkZWNyeXB0aW9uIHJlcXVlc3QuIFRoZXNlIGFyZSBjcmVhdGVkIHdoZW4gYVxuICogZGVjcnlwdGlvbiBmb3IgYW4gZXRoX2RlY3J5cHQgY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVjcnlwdE1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBBbiBpZCB0byB0cmFjayBhbmQgaWRlbnRpZnkgdGhlIG1lc3NhZ2Ugb2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIGRlY3J5cHRNZXNzYWdlIG1ldGhvZCBvbmNlIHRoZSBkZWNyeXB0aW9uIHJlcXVlc3QgaXNcbiAqIGFwcHJvdmVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtc2dQYXJhbXMuZGF0YSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgcmF3IGJ1ZmZlciBkYXRhIG9mIHRoZSBkZWNyeXB0aW9uIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoZSB0aGlzIG1lc3NhZ2Ugd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlY3J5cHRpb24gcmVxdWVzdCBpcyAndW5hcHByb3ZlZCcsICdhcHByb3ZlZCcsICdkZWNyeXB0ZWQnIG9yICdyZWplY3RlZCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBqc29uLXByYyBkZWNyeXB0aW9uIG1ldGhvZCBmb3Igd2hpY2ggYSBkZWNyeXB0aW9uIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gQSAnTWVzc2FnZScgd2lsbFxuICogYWx3YXlzIGhhdmUgYSAnZXRoX2RlY3J5cHQnIHR5cGUuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBEZWNyeXB0TWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBDb250cm9sbGVyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5tZXRyaWNFdmVudCAtIEEgZnVuY3Rpb24gZm9yIGVtaXR0aW5nIGEgbWV0cmljIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZERlY3J5cHRNc2dzOiB7fSxcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubWV0cmljc0V2ZW50ID0gb3B0cy5tZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIERlY3J5cHRNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIERlY3J5cHRNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBnZXQgdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRVbmFwcHJvdmVkTXNncygpKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSAndW5hcHByb3ZlZCcgRGVjcnlwdE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgRGVjcnlwdE1lc3NhZ2UgaWRzIHRvIERlY3J5cHRNZXNzYWdlcywgZm9yIGFsbCAndW5hcHByb3ZlZCcgRGVjcnlwdE1lc3NhZ2VzIGluXG4gICAqIHRoaXMubWVzc2FnZXNcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRGVjcnlwdE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbXNnUGFyYW1zLiB0aGlzLmFkZE1zZyBpcyBjYWxsZWQgdG8gYWRkXG4gICAqIHRoZSBuZXcgRGVjcnlwdE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgRGVjcnlwdE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX2RlY3J5cHQgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgZGVjcnlwdGVkIG1lc3NhZ2UgY29udGVudHNcbiAgICovXG4gIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFtc2dQYXJhbXMuZnJvbSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBEZWNyeXB0aW9uOiBmcm9tIGZpZWxkIGlzIHJlcXVpcmVkLicpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnZGVjcnlwdGVkJzpcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS5yYXdEYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICdNZXRhTWFzayBEZWNyeXB0aW9uOiBVc2VyIGRlbmllZCBtZXNzYWdlIGRlY3J5cHRpb24uJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGlzIG1lc3NhZ2UgY2Fubm90IGJlIGRlY3J5cHRlZCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIERlY3J5cHRpb246IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IERlY3J5cHRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IERlY3J5cHRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIERlY3J5cHRNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9kZWNyeXB0TXNnIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgRGVjcnlwdE1lc3NhZ2UuXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGxvZy5kZWJ1ZyhcbiAgICAgIGBEZWNyeXB0TWVzc2FnZU1hbmFnZXIgYWRkVW5hcHByb3ZlZE1lc3NhZ2U6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICl9YCxcbiAgICApO1xuICAgIC8vIGFkZCBvcmlnaW4gZnJvbSByZXF1ZXN0XG4gICAgaWYgKHJlcSkge1xuICAgICAgbXNnUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgfVxuICAgIG1zZ1BhcmFtcy5kYXRhID0gdGhpcy5ub3JtYWxpemVNc2dEYXRhKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICAvLyBjcmVhdGUgdHhEYXRhIG9iaiB3aXRoIHBhcmFtZXRlcnMgYW5kIG1ldGEgZGF0YVxuICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBtc2dJZCA9IGNyZWF0ZUlkKCk7XG4gICAgY29uc3QgbXNnRGF0YSA9IHtcbiAgICAgIGlkOiBtc2dJZCxcbiAgICAgIG1zZ1BhcmFtcyxcbiAgICAgIHRpbWUsXG4gICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgIHR5cGU6IE1FU1NBR0VfVFlQRS5FVEhfREVDUllQVCxcbiAgICB9O1xuICAgIHRoaXMuYWRkTXNnKG1zZ0RhdGEpO1xuXG4gICAgLy8gc2lnbmFsIHVwZGF0ZVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgcmV0dXJuIG1zZ0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwYXNzZWQgRGVjcnlwdE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBEZWNyeXB0TWVzc2FnZXMgZnJvbSB0aGF0XG4gICAqIGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgLSBUaGUgRGVjcnlwdE1lc3NhZ2UgdG8gYWRkIHRvIHRoaXMubWVzc2FnZXNcbiAgICovXG4gIGFkZE1zZyhtc2cpIHtcbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgRGVjcnlwdE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHtEZWNyeXB0TWVzc2FnZXx1bmRlZmluZWR9IFRoZSBEZWNyeXB0TWVzc2FnZSB3aXRoIHRoZSBpZCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBtc2dJZCwgb3IgdW5kZWZpbmVkXG4gICAqIGlmIG5vIERlY3J5cHRNZXNzYWdlIGhhcyB0aGF0IGlkLlxuICAgKi9cbiAgZ2V0TXNnKG1zZ0lkKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobXNnKSA9PiBtc2cuaWQgPT09IG1zZ0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlcyBhIERlY3J5cHRNZXNzYWdlLiBTZXRzIHRoZSBtZXNzYWdlIHN0YXR1cyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQsIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxuICAgKiB3aXRoIHRoZSBtZXNzYWdlIHBhcmFtcyBtb2RpZmllZCBmb3IgcHJvcGVyIGRlY3J5cHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbXNnUGFyYW1zIHRvIGJlIHVzZWQgd2hlbiBldGhfZGVjcnlwdE1zZyBpcyBjYWxsZWQsIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFzay5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIC0gQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIG9iamVjdCB3aXRoIG1ldGFtYXNrSWQgcmVtb3ZlZC5cbiAgICovXG4gIGFwcHJvdmVNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnUGFyYW1zLm1ldGFtYXNrSWQpO1xuICAgIHJldHVybiB0aGlzLnByZXBNc2dGb3JEZWNyeXB0aW9uKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIERlY3J5cHRNZXNzYWdlIHN0YXR1cyB0byAnYXBwcm92ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIERlY3J5cHRNZXNzYWdlIHRvIGFwcHJvdmUuXG4gICAqL1xuICBzZXRNc2dTdGF0dXNBcHByb3ZlZChtc2dJZCkge1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ2FwcHJvdmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIERlY3J5cHRNZXNzYWdlIHN0YXR1cyB0byAnZGVjcnlwdGVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IERlY3J5cHRNZXNzYWdlIGluXG4gICAqIHRoaXMubWVzc2FnZXMgYnkgYWRkaW5nIHRoZSByYXcgZGVjcnlwdGlvbiBkYXRhIG9mIHRoZSBkZWNyeXB0aW9uIHJlcXVlc3QgdG8gdGhlIERlY3J5cHRNZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHtidWZmZXJ9IHJhd0RhdGEgLSBUaGUgcmF3IGRhdGEgb2YgdGhlIG1lc3NhZ2UgcmVxdWVzdFxuICAgKi9cbiAgc2V0TXNnU3RhdHVzRGVjcnlwdGVkKG1zZ0lkLCByYXdEYXRhKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5yYXdEYXRhID0gcmF3RGF0YTtcbiAgICB0aGlzLl91cGRhdGVNc2cobXNnKTtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdkZWNyeXB0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IGZyb20gcGFzc2VkIG1zZ1BhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdGhlIHVwZGF0ZWQgbXNnUGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbXNnUGFyYW1zIHRvIG1vZGlmeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIHdpdGggdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgcmVtb3ZlZFxuICAgKi9cbiAgcHJlcE1zZ0ZvckRlY3J5cHRpb24obXNnUGFyYW1zKSB7XG4gICAgZGVsZXRlIG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRGVjcnlwdE1lc3NhZ2Ugc3RhdHVzIHRvICdyZWplY3RlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgRGVjcnlwdE1lc3NhZ2UgdG8gcmVqZWN0LlxuICAgKiBAcGFyYW0gcmVhc29uXG4gICAqL1xuICByZWplY3RNc2cobXNnSWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIHRoaXMubWV0cmljc0V2ZW50KHtcbiAgICAgICAgZXZlbnQ6IHJlYXNvbixcbiAgICAgICAgY2F0ZWdvcnk6ICdNZXNzYWdlcycsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBhY3Rpb246ICdEZWNyeXB0IE1lc3NhZ2UgUmVxdWVzdCcsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAncmVqZWN0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIHN0YXR1cyB0byAnZXJyb3JlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGVycm9yXG4gICAqIEBwYXJhbSBlcnJvclxuICAgKi9cbiAgZXJyb3JNZXNzYWdlKG1zZ0lkLCBlcnJvcikge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLl91cGRhdGVNc2cobXNnKTtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdlcnJvcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCB1bmFwcHJvdmVkIG1lc3NhZ2VzIGZyb20gbWVtb3J5LlxuICAgKi9cbiAgY2xlYXJVbmFwcHJvdmVkKCkge1xuICAgIHRoaXMubWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzICE9PSAndW5hcHByb3ZlZCcpO1xuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdHVzIG9mIGEgRGVjcnlwdE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIERlY3J5cHRNZXNzYWdlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyAtIFRoZSBuZXcgc3RhdHVzIG9mIHRoZSBEZWNyeXB0TWVzc2FnZS5cbiAgICogQHRocm93cyBBICdEZWNyeXB0TWVzc2FnZU1hbmFnZXIgLSBEZWNyeXB0TWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuJyBpZiB0aGVyZSBpcyBubyBEZWNyeXB0TWVzc2FnZVxuICAgKiBpbiB0aGlzLm1lc3NhZ2VzIHdpdGggYW4gaWQgZXF1YWwgdG8gdGhlIHBhc3NlZCBtc2dJZFxuICAgKiBAZmlyZXMgQW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OiR7c3RhdHVzfWAuIFRoZSBEZWNyeXB0TWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ2RlY3J5cHRlZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmdcbiAgICogd2l0aCB0aGUgRGVjcnlwdE1lc3NhZ2VcbiAgICovXG4gIF9zZXRNc2dTdGF0dXMobXNnSWQsIHN0YXR1cykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChcbiAgICAgIHN0YXR1cyA9PT0gJ3JlamVjdGVkJyB8fFxuICAgICAgc3RhdHVzID09PSAnZGVjcnlwdGVkJyB8fFxuICAgICAgc3RhdHVzID09PSAnZXJyb3JlZCdcbiAgICApIHtcbiAgICAgIHRoaXMuZW1pdChgJHttc2dJZH06ZmluaXNoZWRgLCBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRGVjcnlwdE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB0byB0aGUgcGFzc2VkIERlY3J5cHRNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZVxuICAgKiB1bmFwcHJvdmVkRGVjcnlwdE1zZ3MgaW5kZXggdG8gc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEZWNyeXB0TWVzc2FnZX0gbXNnIC0gQSBEZWNyeXB0TWVzc2FnZSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBEZWNyeXB0TWVzc2FnZSAod2l0aCB0aGUgc2FtZVxuICAgKiBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIERlY3J5cHRNZXNzYWdlcywgYW5kIHRoZWlyIGNvdW50LCB0byB0aGlzLm1lbVN0b3JlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyAndXBkYXRlQmFkZ2UnXG4gICAqL1xuICBfc2F2ZU1zZ0xpc3QoKSB7XG4gICAgY29uc3QgdW5hcHByb3ZlZERlY3J5cHRNc2dzID0gdGhpcy5nZXRVbmFwcHJvdmVkTXNncygpO1xuICAgIGNvbnN0IHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkRGVjcnlwdE1zZ3MpLmxlbmd0aDtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNncyxcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQsXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXcgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBUaGUgYnVmZmVyIGRhdGEgdG8gY29udmVydCB0byBhIGhleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgYnVmZmVyIGRhdGFcbiAgICovXG4gIG5vcm1hbGl6ZU1zZ0RhdGEoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGRhdGEpO1xuICAgICAgaWYgKHN0cmlwcGVkLm1hdGNoKGhleFJlKSkge1xuICAgICAgICByZXR1cm4gYWRkSGV4UHJlZml4KHN0cmlwcGVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoYE1lc3NhZ2Ugd2FzIG5vdCBoZXggZW5jb2RlZCwgaW50ZXJwcmV0aW5nIGFzIHV0ZjguYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclRvSGV4KEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JykpO1xuICB9XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMsIGFuZCBjb250YWlucyBkYXRhIGFib3V0LCBhbiAnZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXknIHR5cGUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlblxuICogYW4gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRW5jcnlwdGlvblB1YmxpY0tleVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZW5jcnlwdGlvblB1YmxpY0tleSBtZXRob2Qgb25jZSB0aGUgcmVxdWVzdCBpc1xuICogYXBwcm92ZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1zZ1BhcmFtcy5kYXRhIEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSByYXcgYnVmZmVyIGRhdGEgb2YgdGhlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoZSB0aGlzIG1lc3NhZ2Ugd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgJ3VuYXBwcm92ZWQnLCAnYXBwcm92ZWQnLCAncmVjZWl2ZWQnIG9yICdyZWplY3RlZCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBqc29uLXByYyBtZXRob2QgZm9yIHdoaWNoIGEgcmVxdWVzdCBoYXMgYmVlbiBtYWRlLiBBICdNZXNzYWdlJyB3aWxsXG4gKiBhbHdheXMgaGF2ZSBhICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScgdHlwZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gRW5jcnlwdGlvblB1YmxpY0tleS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBDb250cm9sbGVyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5tZXRyaWNFdmVudCAtIEEgZnVuY3Rpb24gZm9yIGVtaXR0aW5nIGEgbWV0cmljIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzOiB7fSxcbiAgICAgIHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNnQ291bnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMubWV0cmljc0V2ZW50ID0gb3B0cy5tZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiAndW5hcHByb3ZlZCcgRW5jcnlwdGlvblB1YmxpY0tleXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgZ2V0IHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNnQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluIHRoaXMubWVzc2FnZXNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQW4gaW5kZXggb2YgRW5jcnlwdGlvblB1YmxpY0tleSBpZHMgdG8gRW5jcnlwdGlvblB1YmxpY0tleXMsIGZvciBhbGwgJ3VuYXBwcm92ZWQnIEVuY3J5cHRpb25QdWJsaWNLZXlzIGluXG4gICAqIHRoaXMubWVzc2FnZXNcbiAgICovXG4gIGdldFVuYXBwcm92ZWRNc2dzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbXNnKSA9PiB7XG4gICAgICAgIHJlc3VsdFttc2cuaWRdID0gbXNnO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRW5jcnlwdGlvblB1YmxpY0tleSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBFbmNyeXB0aW9uUHVibGljS2V5IHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIEVuY3J5cHRpb25QdWJsaWNLZXlzIGZyb20gdGhhdCBsaXN0IHRvXG4gICAqIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhZGRyZXNzIC0gVGhlIHBhcmFtIGZvciB0aGUgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSByYXcgcHVibGljIGtleSBjb250ZW50c1xuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhhZGRyZXNzLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ01ldGFNYXNrIE1lc3NhZ2U6IGFkZHJlc3MgZmllbGQgaXMgcmVxdWlyZWQuJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtc2dJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UoYWRkcmVzcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAncmVjZWl2ZWQnOlxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhLnJhd0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgJ01ldGFNYXNrIEVuY3J5cHRpb25QdWJsaWNLZXk6IFVzZXIgZGVuaWVkIG1lc3NhZ2UgRW5jcnlwdGlvblB1YmxpY0tleS4nLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIEVuY3J5cHRpb25QdWJsaWNLZXk6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFbmNyeXB0aW9uUHVibGljS2V5IHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1zZ1BhcmFtcy4gdGhpcy5hZGRNc2cgaXMgY2FsbGVkIHRvIGFkZFxuICAgKiB0aGUgbmV3IEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgRW5jcnlwdGlvblB1YmxpY0tleXMgZnJvbSB0aGF0IGxpc3QgdG9cbiAgICogdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFkZHJlc3MgLSBUaGUgcGFyYW0gZm9yIHRoZSBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleSBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2UgaXMgYXBwcm92ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShhZGRyZXNzLCByZXEpIHtcbiAgICBsb2cuZGVidWcoYEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIGFkZFVuYXBwcm92ZWRNZXNzYWdlOiBhZGRyZXNzYCk7XG4gICAgLy8gY3JlYXRlIHR4RGF0YSBvYmogd2l0aCBwYXJhbWV0ZXJzIGFuZCBtZXRhIGRhdGFcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgbXNnSWQgPSBjcmVhdGVJZCgpO1xuICAgIGNvbnN0IG1zZ0RhdGEgPSB7XG4gICAgICBpZDogbXNnSWQsXG4gICAgICBtc2dQYXJhbXM6IGFkZHJlc3MsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVksXG4gICAgfTtcblxuICAgIGlmIChyZXEpIHtcbiAgICAgIG1zZ0RhdGEub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1zZyhtc2dEYXRhKTtcblxuICAgIC8vIHNpZ25hbCB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgIHJldHVybiBtc2dJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzc2VkIEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBFbmNyeXB0aW9uUHVibGljS2V5cyBmcm9tIHRoYXRcbiAgICogbGlzdCB0byB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZyAtIFRoZSBFbmNyeXB0aW9uUHVibGljS2V5IHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBhZGRNc2cobXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgRW5jcnlwdGlvblB1YmxpY0tleSB0byBnZXRcbiAgICogQHJldHVybnMge0VuY3J5cHRpb25QdWJsaWNLZXl8dW5kZWZpbmVkfSBUaGUgRW5jcnlwdGlvblB1YmxpY0tleSB3aXRoIHRoZSBpZCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBtc2dJZCwgb3IgdW5kZWZpbmVkXG4gICAqIGlmIG5vIEVuY3J5cHRpb25QdWJsaWNLZXkgaGFzIHRoYXQgaWQuXG4gICAqL1xuICBnZXRNc2cobXNnSWQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maW5kKChtc2cpID0+IG1zZy5pZCA9PT0gbXNnSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcHJvdmVzIGEgRW5jcnlwdGlvblB1YmxpY0tleS4gU2V0cyB0aGUgbWVzc2FnZSBzdGF0dXMgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkLCBhbmQgcmV0dXJucyBhIHByb21pc2VcbiAgICogd2l0aCBhbnkgdGhlIG1lc3NhZ2UgcGFyYW1zIG1vZGlmaWVkIGZvciBwcm9wZXIgcHJvdmlkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1zZ1BhcmFtcyB0byBiZSB1c2VkIHdoZW4gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgaXMgY2FsbGVkLCBwbHVzIGRhdGEgYWRkZWQgYnkgTWV0YU1hc2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMubWV0YW1hc2tJZCAtIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZXMgdGhlIG1zZ1BhcmFtcyBvYmplY3Qgd2l0aCBtZXRhbWFza0lkIHJlbW92ZWQuXG4gICAqL1xuICBhcHByb3ZlTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ1BhcmFtcy5tZXRhbWFza0lkKTtcbiAgICByZXR1cm4gdGhpcy5wcmVwTXNnRm9yRW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBFbmNyeXB0aW9uUHVibGljS2V5IHN0YXR1cyB0byAnYXBwcm92ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gYXBwcm92ZS5cbiAgICovXG4gIHNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ0lkKSB7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnYXBwcm92ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRW5jcnlwdGlvblB1YmxpY0tleSBzdGF0dXMgdG8gJ3JlY2VpdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IEVuY3J5cHRpb25QdWJsaWNLZXkgaW5cbiAgICogdGhpcy5tZXNzYWdlcyBieSBhZGRpbmcgdGhlIHJhdyBkYXRhIG9mIHJlcXVlc3QgdG8gdGhlIEVuY3J5cHRpb25QdWJsaWNLZXlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5LlxuICAgKiBAcGFyYW0ge2J1ZmZlcn0gcmF3RGF0YSAtIFRoZSByYXcgZGF0YSBvZiB0aGUgbWVzc2FnZSByZXF1ZXN0XG4gICAqL1xuICBzZXRNc2dTdGF0dXNSZWNlaXZlZChtc2dJZCwgcmF3RGF0YSkge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3RGF0YSA9IHJhd0RhdGE7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAncmVjZWl2ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IGZyb20gcGFzc2VkIG1zZ1BhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdGhlIHVwZGF0ZWQgbXNnUGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbXNnUGFyYW1zIHRvIG1vZGlmeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIHdpdGggdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgcmVtb3ZlZFxuICAgKi9cbiAgcHJlcE1zZ0ZvckVuY3J5cHRpb25QdWJsaWNLZXkobXNnUGFyYW1zKSB7XG4gICAgZGVsZXRlIG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgRW5jcnlwdGlvblB1YmxpY0tleSBzdGF0dXMgdG8gJ3JlamVjdGVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5IHRvIHJlamVjdC5cbiAgICogQHBhcmFtIHJlYXNvblxuICAgKi9cbiAgcmVqZWN0TXNnKG1zZ0lkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAocmVhc29uKSB7XG4gICAgICB0aGlzLm1ldHJpY3NFdmVudCh7XG4gICAgICAgIGV2ZW50OiByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5OiAnTWVzc2FnZXMnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYWN0aW9uOiAnRW5jcnlwdGlvbiBwdWJsaWMga2V5IFJlcXVlc3QnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3JlamVjdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFR5cGVkTWVzc2FnZSB0byBlcnJvclxuICAgKiBAcGFyYW0gZXJyb3JcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIEVuY3J5cHRpb25QdWJsaWNLZXkgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIEVuY3J5cHRpb25QdWJsaWNLZXkgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIC0gVGhlIG5ldyBzdGF0dXMgb2YgdGhlIEVuY3J5cHRpb25QdWJsaWNLZXkuXG4gICAqIEB0aHJvd3MgQSAnRW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIgLSBFbmNyeXB0aW9uUHVibGljS2V5IG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi4nIGlmIHRoZXJlIGlzIG5vIEVuY3J5cHRpb25QdWJsaWNLZXlcbiAgICogaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgRW5jcnlwdGlvblB1YmxpY0tleSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3JlY2VpdmVkJywgYW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OmZpbmlzaGVkYCBpcyBmaXJlZCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBFbmNyeXB0aW9uUHVibGljS2V5XG4gICAqL1xuICBfc2V0TXNnU3RhdHVzKG1zZ0lkLCBzdGF0dXMpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChzdGF0dXMgPT09ICdyZWplY3RlZCcgfHwgc3RhdHVzID09PSAncmVjZWl2ZWQnKSB7XG4gICAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OmZpbmlzaGVkYCwgbXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIEVuY3J5cHRpb25QdWJsaWNLZXkgaW4gdGhpcy5tZXNzYWdlcyB0byB0aGUgcGFzc2VkIEVuY3J5cHRpb25QdWJsaWNLZXkgaWYgdGhlIGlkcyBhcmUgZXF1YWwuIFRoZW4gc2F2ZXMgdGhlXG4gICAqIHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNncyBpbmRleCB0byBzdG9yYWdlIHZpYSB0aGlzLl9zYXZlTXNnTGlzdFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0VuY3J5cHRpb25QdWJsaWNLZXl9IG1zZyAtIEEgRW5jcnlwdGlvblB1YmxpY0tleSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBFbmNyeXB0aW9uUHVibGljS2V5ICh3aXRoIHRoZSBzYW1lXG4gICAqIGlkKSBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBfdXBkYXRlTXNnKG1zZykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZXNzYWdlcy5maW5kSW5kZXgoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuaWQgPT09IG1zZy5pZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5tZXNzYWdlc1tpbmRleF0gPSBtc2c7XG4gICAgfVxuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIHVuYXBwcm92ZWQgRW5jcnlwdGlvblB1YmxpY0tleXMsIGFuZCB0aGVpciBjb3VudCwgdG8gdGhpcy5tZW1TdG9yZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgJ3VwZGF0ZUJhZGdlJ1xuICAgKi9cbiAgX3NhdmVNc2dMaXN0KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNncyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKTtcbiAgICBjb25zdCB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50ID0gT2JqZWN0LmtleXMoXG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MsXG4gICAgKS5sZW5ndGg7XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MsXG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50LFxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYWNoZWRCYWxhbmNlc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhY2NvdW50VHJhY2tlciBBbiB7QGNvZGUgQWNjb3VudFRyYWNrZXJ9IHJlZmVyZW5jZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0Q3VycmVudENoYWluSWQgQSBmdW5jdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgY2hhaW4gaWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbml0U3RhdGUgVGhlIGluaXRpYWwgY29udHJvbGxlciBzdGF0ZVxuICovXG5cbi8qKlxuICogQmFja2dyb3VuZCBjb250cm9sbGVyIHJlc3BvbnNpYmxlIGZvciBtYWludGFpbmluZ1xuICogYSBjYWNoZSBvZiBhY2NvdW50IGJhbGFuY2VzIGluIGxvY2FsIHN0b3JhZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge0NhY2hlZEJhbGFuY2VzT3B0aW9uc30gW29wdHNdIC0gQ29udHJvbGxlciBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgYWNjb3VudFRyYWNrZXIsIGdldEN1cnJlbnRDaGFpbklkIH0gPSBvcHRzO1xuXG4gICAgdGhpcy5hY2NvdW50VHJhY2tlciA9IGFjY291bnRUcmFja2VyO1xuICAgIHRoaXMuZ2V0Q3VycmVudENoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZDtcblxuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHsgY2FjaGVkQmFsYW5jZXM6IHt9LCAuLi5vcHRzLmluaXRTdGF0ZSB9O1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKGluaXRTdGF0ZSk7XG5cbiAgICB0aGlzLl9yZWdpc3RlclVwZGF0ZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYWNoZWRCYWxhbmNlcyBwcm9wZXJ0eSBmb3IgdGhlIGN1cnJlbnQgY2hhaW4uIENhY2hlZCBiYWxhbmNlcyB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhvc2UgaW4gdGhlIHBhc3NlZCBhY2NvdW50c1xuICAgKiBpZiBiYWxhbmNlcyBpbiB0aGUgcGFzc2VkIGFjY291bnRzIGFyZSB0cnV0aHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgdGhlIHJlY2VudGx5IHVwZGF0ZWQgYWNjb3VudHMgb2JqZWN0IGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgKiBAcGFyYW0gb2JqLmFjY291bnRzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQ2FjaGVkQmFsYW5jZXMoeyBhY2NvdW50cyB9KSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBjb25zdCBiYWxhbmNlc1RvQ2FjaGUgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZUJhbGFuY2VzVG9DYWNoZShcbiAgICAgIGFjY291bnRzLFxuICAgICAgY2hhaW5JZCxcbiAgICApO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgY2FjaGVkQmFsYW5jZXM6IGJhbGFuY2VzVG9DYWNoZSxcbiAgICB9KTtcbiAgfVxuXG4gIF9nZW5lcmF0ZUJhbGFuY2VzVG9DYWNoZShuZXdBY2NvdW50cywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHsgY2FjaGVkQmFsYW5jZXMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50Q2hhaW5CYWxhbmNlc1RvQ2FjaGUgPSB7IC4uLmNhY2hlZEJhbGFuY2VzW2NoYWluSWRdIH07XG5cbiAgICBPYmplY3Qua2V5cyhuZXdBY2NvdW50cykuZm9yRWFjaCgoYWNjb3VudElEKSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gbmV3QWNjb3VudHNbYWNjb3VudElEXTtcblxuICAgICAgaWYgKGFjY291bnQuYmFsYW5jZSkge1xuICAgICAgICBjdXJyZW50Q2hhaW5CYWxhbmNlc1RvQ2FjaGVbYWNjb3VudElEXSA9IGFjY291bnQuYmFsYW5jZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBiYWxhbmNlc1RvQ2FjaGUgPSB7XG4gICAgICAuLi5jYWNoZWRCYWxhbmNlcyxcbiAgICAgIFtjaGFpbklkXTogY3VycmVudENoYWluQmFsYW5jZXNUb0NhY2hlLFxuICAgIH07XG5cbiAgICByZXR1cm4gYmFsYW5jZXNUb0NhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2FjaGVkQmFsYW5jZXNcbiAgICovXG5cbiAgY2xlYXJDYWNoZWRCYWxhbmNlcygpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgY2FjaGVkQmFsYW5jZXM6IHt9IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgbGlzdGVuZXJzIGFuZCBzdWJzY3JpcHRpb25zIHdoaWNoIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiBjYWNoZWQgYmFsYW5jZXMuIFRoZXNlIHVwZGF0ZXMgd2lsbFxuICAgKiBoYXBwZW4gd2hlbiB0aGUgY3VycmVudCBhY2NvdW50IGNoYW5nZXMuIFdoaWNoIGhhcHBlbnMgb24gYmxvY2sgdXBkYXRlcywgYXMgd2VsbCBhcyBvbiBuZXR3b3JrIGFuZCBhY2NvdW50XG4gICAqIHNlbGVjdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXJVcGRhdGVzKCkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMudXBkYXRlQ2FjaGVkQmFsYW5jZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLnN1YnNjcmliZSh1cGRhdGUpO1xuICB9XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGJ1ZmZlclRvSGV4LCBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGhleFJlID0gL15bMC05QS1GYS1mXSskL2d1O1xuXG4vKipcbiAqIFJlcHJlc2VudHMsIGFuZCBjb250YWlucyBkYXRhIGFib3V0LCBhbiAncGVyc29uYWxfc2lnbicgdHlwZSBzaWduYXR1cmUgcmVxdWVzdC4gVGhlc2UgYXJlIGNyZWF0ZWQgd2hlbiBhXG4gKiBzaWduYXR1cmUgZm9yIGFuIHBlcnNvbmFsX3NpZ24gY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93ZWIzanMucmVhZHRoZWRvY3MuaW8vZW4vMS4wL3dlYjMtZXRoLXBlcnNvbmFsLmh0bWwjc2lnbn1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlcnNvbmFsTWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgcGVyc29uYWxfc2lnbiBtZXRob2Qgb25jZSB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgaXNcbiAqIGFwcHJvdmVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtc2dQYXJhbXMuZGF0YSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgcmF3IGJ1ZmZlciBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhlIHRoaXMgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1cyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgaXMgJ3VuYXBwcm92ZWQnLCAnYXBwcm92ZWQnLCAnc2lnbmVkJyBvciAncmVqZWN0ZWQnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUganNvbi1wcmMgc2lnbmluZyBtZXRob2QgZm9yIHdoaWNoIGEgc2lnbmF0dXJlIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gQSAnTWVzc2FnZScgd2lsbFxuICogYWx3YXlzIGhhdmUgYSAncGVyc29uYWxfc2lnbicgdHlwZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBQZXJzb25hbE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm1ldHJpY3NFdmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBtZXRyaWNzRXZlbnQgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZFBlcnNvbmFsTXNnczoge30sXG4gICAgICB1bmFwcHJvdmVkUGVyc29uYWxNc2dDb3VudDogMCxcbiAgICB9KTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5tZXRyaWNzRXZlbnQgPSBtZXRyaWNzRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIFBlcnNvbmFsTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBQZXJzb25hbE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXNcbiAgICovXG4gIGdldCB1bmFwcHJvdmVkUGVyc29uYWxNc2dDb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRVbmFwcHJvdmVkTXNncygpKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSAndW5hcHByb3ZlZCcgUGVyc29uYWxNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIGluZGV4IG9mIFBlcnNvbmFsTWVzc2FnZSBpZHMgdG8gUGVyc29uYWxNZXNzYWdlcywgZm9yIGFsbCAndW5hcHByb3ZlZCcgUGVyc29uYWxNZXNzYWdlcyBpblxuICAgKiB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBnZXRVbmFwcHJvdmVkTXNncygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAucmVkdWNlKChyZXN1bHQsIG1zZykgPT4ge1xuICAgICAgICByZXN1bHRbbXNnLmlkXSA9IG1zZztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBlcnNvbmFsTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBQZXJzb25hbE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgUGVyc29uYWxNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gV2hlbiB0aGUgbWVzc2FnZSBoYXMgYmVlbiBzaWduZWQgb3IgcmVqZWN0ZWRcbiAgICovXG4gIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobXNnUGFyYW1zLCByZXEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFtc2dQYXJhbXMuZnJvbSkge1xuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKCdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogZnJvbSBmaWVsZCBpcyByZXF1aXJlZC4nKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgJ01ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlICdlcnJvcmVkJzpcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiAke2RhdGEuZXJyb3J9YCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBlcnNvbmFsTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGRcbiAgICogdGhlIG5ldyBQZXJzb25hbE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgUGVyc29uYWxNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0b1xuICAgKiB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgUGVyc29uYWxNZXNzYWdlLlxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBsb2cuZGVidWcoXG4gICAgICBgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBhZGRVbmFwcHJvdmVkTWVzc2FnZTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKX1gLFxuICAgICk7XG4gICAgLy8gYWRkIG9yaWdpbiBmcm9tIHJlcXVlc3RcbiAgICBpZiAocmVxKSB7XG4gICAgICBtc2dQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICB9XG4gICAgbXNnUGFyYW1zLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZU1zZ0RhdGEobXNnUGFyYW1zLmRhdGEpO1xuICAgIC8vIGNyZWF0ZSB0eERhdGEgb2JqIHdpdGggcGFyYW1ldGVycyBhbmQgbWV0YSBkYXRhXG4gICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1zZ0lkID0gY3JlYXRlSWQoKTtcbiAgICBjb25zdCBtc2dEYXRhID0ge1xuICAgICAgaWQ6IG1zZ0lkLFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgdGltZSxcbiAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLlBFUlNPTkFMX1NJR04sXG4gICAgfTtcbiAgICB0aGlzLmFkZE1zZyhtc2dEYXRhKTtcblxuICAgIC8vIHNpZ25hbCB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgIHJldHVybiBtc2dJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcGFzc2VkIFBlcnNvbmFsTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgY2FsbHMgdGhpcy5fc2F2ZU1zZ0xpc3QoKSB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIFBlcnNvbmFsTWVzc2FnZXMgZnJvbSB0aGF0XG4gICAqIGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgLSBUaGUgUGVyc29uYWxNZXNzYWdlIHRvIGFkZCB0byB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBhZGRNc2cobXNnKSB7XG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIFBlcnNvbmFsTWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHtQZXJzb25hbE1lc3NhZ2V8dW5kZWZpbmVkfSBUaGUgUGVyc29uYWxNZXNzYWdlIHdpdGggdGhlIGlkIHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIG1zZ0lkLCBvciB1bmRlZmluZWRcbiAgICogaWYgbm8gUGVyc29uYWxNZXNzYWdlIGhhcyB0aGF0IGlkLlxuICAgKi9cbiAgZ2V0TXNnKG1zZ0lkKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobXNnKSA9PiBtc2cuaWQgPT09IG1zZ0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlcyBhIFBlcnNvbmFsTWVzc2FnZS4gU2V0cyB0aGUgbWVzc2FnZSBzdGF0dXMgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1zZ1N0YXR1c0FwcHJvdmVkLCBhbmQgcmV0dXJucyBhIHByb21pc2VcbiAgICogd2l0aCBhbnkgdGhlIG1lc3NhZ2UgcGFyYW1zIG1vZGlmaWVkIGZvciBwcm9wZXIgc2lnbmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gYmUgdXNlZCB3aGVuIGV0aF9zaWduIGlzIGNhbGxlZCwgcGx1cyBkYXRhIGFkZGVkIGJ5IE1ldGFNYXNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zLm1ldGFtYXNrSWQgLSBBZGRlZCB0byBtc2dQYXJhbXMgZm9yIHRyYWNraW5nIGFuZCBpZGVudGlmaWNhdGlvbiB3aXRoaW4gTWV0YU1hc2suXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgb2JqZWN0IHdpdGggbWV0YW1hc2tJZCByZW1vdmVkLlxuICAgKi9cbiAgYXBwcm92ZU1lc3NhZ2UobXNnUGFyYW1zKSB7XG4gICAgdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZChtc2dQYXJhbXMubWV0YW1hc2tJZCk7XG4gICAgcmV0dXJuIHRoaXMucHJlcE1zZ0ZvclNpZ25pbmcobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgUGVyc29uYWxNZXNzYWdlIHN0YXR1cyB0byAnYXBwcm92ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFBlcnNvbmFsTWVzc2FnZSB0byBhcHByb3ZlLlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnSWQpIHtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdhcHByb3ZlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBQZXJzb25hbE1lc3NhZ2Ugc3RhdHVzIHRvICdzaWduZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzIGFuZCB1cGRhdGVzIHRoYXQgUGVyc29uYWxNZXNzYWdlIGluXG4gICAqIHRoaXMubWVzc2FnZXMgYnkgYWRkaW5nIHRoZSByYXcgc2lnbmF0dXJlIGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IHRvIHRoZSBQZXJzb25hbE1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UgdG8gc2lnbi5cbiAgICogQHBhcmFtIHtidWZmZXJ9IHJhd1NpZyAtIFRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAgICovXG4gIHNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgcmF3U2lnKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5yYXdTaWcgPSByYXdTaWc7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnc2lnbmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtc2dQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1zZ1BhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1zZ1BhcmFtcyB0byBtb2RpZnlcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZXMgdGhlIG1zZ1BhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IHJlbW92ZWRcbiAgICovXG4gIHByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcykge1xuICAgIGRlbGV0ZSBtc2dQYXJhbXMubWV0YW1hc2tJZDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFBlcnNvbmFsTWVzc2FnZSBzdGF0dXMgdG8gJ3JlamVjdGVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UgdG8gcmVqZWN0LlxuICAgKiBAcGFyYW0gcmVhc29uXG4gICAqL1xuICByZWplY3RNc2cobXNnSWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICAgIHRoaXMubWV0cmljc0V2ZW50KHtcbiAgICAgICAgZXZlbnQ6IHJlYXNvbixcbiAgICAgICAgY2F0ZWdvcnk6ICdUcmFuc2FjdGlvbnMnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYWN0aW9uOiAnU2lnbiBSZXF1ZXN0JyxcbiAgICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdyZWplY3RlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAnZXJyb3JlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBlcnJvclxuICAgKiBAcGFyYW0gZXJyb3JcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIFBlcnNvbmFsTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIHZpYSBhIGNhbGwgdG8gdGhpcy5fdXBkYXRlTXNnXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgUGVyc29uYWxNZXNzYWdlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyAtIFRoZSBuZXcgc3RhdHVzIG9mIHRoZSBQZXJzb25hbE1lc3NhZ2UuXG4gICAqIEB0aHJvd3MgQSAnUGVyc29uYWxNZXNzYWdlTWFuYWdlciAtIFBlcnNvbmFsTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuJyBpZiB0aGVyZSBpcyBubyBQZXJzb25hbE1lc3NhZ2VcbiAgICogaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgUGVyc29uYWxNZXNzYWdlIGlzIGFsc28gZmlyZWQuXG4gICAqIEBmaXJlcyBJZiBzdGF0dXMgaXMgJ3JlamVjdGVkJyBvciAnc2lnbmVkJywgYW4gZXZlbnQgd2l0aCBhIG5hbWUgZXF1YWwgdG8gYCR7bXNnSWR9OmZpbmlzaGVkYCBpcyBmaXJlZCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBQZXJzb25hbE1lc3NhZ2VcbiAgICovXG4gIF9zZXRNc2dTdGF0dXMobXNnSWQsIHN0YXR1cykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGVyc29uYWxNZXNzYWdlTWFuYWdlciAtIE1lc3NhZ2Ugbm90IGZvdW5kIGZvciBpZDogXCIke21zZ0lkfVwiLmAsXG4gICAgICApO1xuICAgIH1cbiAgICBtc2cuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuZW1pdChgJHttc2dJZH06JHtzdGF0dXN9YCwgbXNnKTtcbiAgICBpZiAoc3RhdHVzID09PSAncmVqZWN0ZWQnIHx8IHN0YXR1cyA9PT0gJ3NpZ25lZCcpIHtcbiAgICAgIHRoaXMuZW1pdChgJHttc2dJZH06ZmluaXNoZWRgLCBtc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgUGVyc29uYWxNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdG8gdGhlIHBhc3NlZCBQZXJzb25hbE1lc3NhZ2UgaWYgdGhlIGlkcyBhcmUgZXF1YWwuIFRoZW4gc2F2ZXMgdGhlXG4gICAqIHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MgaW5kZXggdG8gc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQZXJzb25hbE1lc3NhZ2V9IG1zZyAtIEEgUGVyc29uYWxNZXNzYWdlIHRoYXQgd2lsbCByZXBsYWNlIGFuIGV4aXN0aW5nIFBlcnNvbmFsTWVzc2FnZSAod2l0aCB0aGUgc2FtZVxuICAgKiBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIFBlcnNvbmFsTWVzc2FnZXMsIGFuZCB0aGVpciBjb3VudCwgdG8gdGhpcy5tZW1TdG9yZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgJ3VwZGF0ZUJhZGdlJ1xuICAgKi9cbiAgX3NhdmVNc2dMaXN0KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MgPSB0aGlzLmdldFVuYXBwcm92ZWRNc2dzKCk7XG4gICAgY29uc3QgdW5hcHByb3ZlZFBlcnNvbmFsTXNnQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkUGVyc29uYWxNc2dzKVxuICAgICAgLmxlbmd0aDtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MsXG4gICAgICB1bmFwcHJvdmVkUGVyc29uYWxNc2dDb3VudCxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHJhdyBidWZmZXIgZGF0YSB0byBhIGhleCwgb3IganVzdCByZXR1cm5zIHRoZSBkYXRhIGlmIGl0IGlzIGFscmVhZHkgZm9ybWF0dGVkIGFzIGEgaGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZGF0YSAtIFRoZSBidWZmZXIgZGF0YSB0byBjb252ZXJ0IHRvIGEgaGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSBidWZmZXIgZGF0YVxuICAgKi9cbiAgbm9ybWFsaXplTXNnRGF0YShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBIZXhQcmVmaXgoZGF0YSk7XG4gICAgICBpZiAoc3RyaXBwZWQubWF0Y2goaGV4UmUpKSB7XG4gICAgICAgIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyaXBwZWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgTWVzc2FnZSB3YXMgbm90IGhleCBlbmNvZGVkLCBpbnRlcnByZXRpbmcgYXMgdXRmOC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyVG9IZXgoQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSk7XG4gIH1cbn1cbiIsImltcG9ydCBLZXlyaW5nQ29udHJvbGxlciBmcm9tICdldGgta2V5cmluZy1jb250cm9sbGVyJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5jb25zdCBzZWVkUGhyYXNlVmVyaWZpZXIgPSB7XG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiB0aGUgc2VlZCB3b3JkcyBjYW4gcmVzdG9yZSB0aGUgYWNjb3VudHMuXG4gICAqXG4gICAqIEtleSBub3RlczpcbiAgICogLSBUaGUgc2VlZCB3b3JkcyBjYW4gcmVjcmVhdGUgdGhlIHByaW1hcnkga2V5cmluZyBhbmQgdGhlIGFjY291bnRzIGJlbG9uZ2luZyB0byBpdC5cbiAgICogLSBUaGUgY3JlYXRlZCBhY2NvdW50cyBpbiB0aGUgcHJpbWFyeSBrZXlyaW5nIGFyZSBhbHdheXMgdGhlIHNhbWUuXG4gICAqIC0gVGhlIGtleXJpbmcgYWx3YXlzIGNyZWF0ZXMgdGhlIGFjY291bnRzIGluIHRoZSBzYW1lIHNlcXVlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjcmVhdGVkQWNjb3VudHMgLSBUaGUgYWNjb3VudHMgdG8gcmVzdG9yZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2VlZFBocmFzZSAtIFRoZSBzZWVkIHdvcmRzIHRvIHZlcmlmeSwgZW5jb2RlZCBhcyBhIEJ1ZmZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHZlcmlmeUFjY291bnRzKGNyZWF0ZWRBY2NvdW50cywgc2VlZFBocmFzZSkge1xuICAgIGlmICghY3JlYXRlZEFjY291bnRzIHx8IGNyZWF0ZWRBY2NvdW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNyZWF0ZWQgYWNjb3VudHMgZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlyaW5nQ29udHJvbGxlciA9IG5ldyBLZXlyaW5nQ29udHJvbGxlcih7fSk7XG4gICAgY29uc3QgS2V5cmluZyA9IGtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdDbGFzc0ZvclR5cGUoJ0hEIEtleSBUcmVlJyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIG1uZW1vbmljOiBzZWVkUGhyYXNlLFxuICAgICAgbnVtYmVyT2ZBY2NvdW50czogY3JlYXRlZEFjY291bnRzLmxlbmd0aCxcbiAgICB9O1xuXG4gICAgY29uc3Qga2V5cmluZyA9IG5ldyBLZXlyaW5nKG9wdHMpO1xuICAgIGNvbnN0IHJlc3RvcmVkQWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgbG9nLmRlYnVnKGBDcmVhdGVkIGFjY291bnRzOiAke0pTT04uc3RyaW5naWZ5KGNyZWF0ZWRBY2NvdW50cyl9YCk7XG4gICAgbG9nLmRlYnVnKGBSZXN0b3JlZCBhY2NvdW50czogJHtKU09OLnN0cmluZ2lmeShyZXN0b3JlZEFjY291bnRzKX1gKTtcblxuICAgIGlmIChyZXN0b3JlZEFjY291bnRzLmxlbmd0aCAhPT0gY3JlYXRlZEFjY291bnRzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBzaG91bGQgbm90IGhhcHBlbi4uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgYWNjb3VudHMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3RvcmVkQWNjb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVzdG9yZWRBY2NvdW50c1tpXS50b0xvd2VyQ2FzZSgpICE9PSBjcmVhdGVkQWNjb3VudHNbaV0udG9Mb3dlckNhc2UoKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgTm90IGlkZW50aWNhbCBhY2NvdW50cyEgT3JpZ2luYWw6ICR7Y3JlYXRlZEFjY291bnRzW2ldfSwgUmVzdG9yZWQ6ICR7cmVzdG9yZWRBY2NvdW50c1tpXX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlZWRQaHJhc2VWZXJpZmllcjtcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgYnVmZmVyVG9IZXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgZXRoRXJyb3JzIH0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCBjcmVhdGVJZCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9yYW5kb20taWQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMsIGFuZCBjb250YWlucyBkYXRhIGFib3V0LCBhbiAnZXRoX3NpZ24nIHR5cGUgc2lnbmF0dXJlIHJlcXVlc3QuIFRoZXNlIGFyZSBjcmVhdGVkIHdoZW4gYSBzaWduYXR1cmUgZm9yXG4gKiBhbiBldGhfc2lnbiBjYWxsIGlzIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWdufVxuICogQHR5cGVkZWYge09iamVjdH0gTWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIEFuIGlkIHRvIHRyYWNrIGFuZCBpZGVudGlmeSB0aGUgbWVzc2FnZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgZXRoX3NpZ24gbWV0aG9kIG9uY2UgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzIGFwcHJvdmVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtc2dQYXJhbXMuZGF0YSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgcmF3IGJ1ZmZlciBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhlIHRoaXMgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1cyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgaXMgJ3VuYXBwcm92ZWQnLCAnYXBwcm92ZWQnLCAnc2lnbmVkJyBvciAncmVqZWN0ZWQnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUganNvbi1wcmMgc2lnbmluZyBtZXRob2QgZm9yIHdoaWNoIGEgc2lnbmF0dXJlIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gQSAnTWVzc2FnZScgd2l0aFxuICogYWx3YXlzIGhhdmUgYSAnZXRoX3NpZ24nIHR5cGUuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIE1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIENvbnRyb2xsZXIgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLm1ldHJpY3NFdmVudCAtIEEgZnVuY3Rpb24gZm9yIGVtaXR0aW5nIGEgbWV0cmljIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBtZXRyaWNzRXZlbnQgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoe1xuICAgICAgdW5hcHByb3ZlZE1zZ3M6IHt9LFxuICAgICAgdW5hcHByb3ZlZE1zZ0NvdW50OiAwLFxuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLm1ldHJpY3NFdmVudCA9IG1ldHJpY3NFdmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIG51bWJlciBvZiAndW5hcHByb3ZlZCcgTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBnZXQgdW5hcHByb3ZlZE1zZ0NvdW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldFVuYXBwcm92ZWRNc2dzKCkpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIGluZGV4IG9mIE1lc3NhZ2UgaWRzIHRvIE1lc3NhZ2VzLCBmb3IgYWxsICd1bmFwcHJvdmVkJyBNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqL1xuICBnZXRVbmFwcHJvdmVkTXNncygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAucmVkdWNlKChyZXN1bHQsIG1zZykgPT4ge1xuICAgICAgICByZXN1bHRbbXNnLmlkXSA9IG1zZztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbXNnUGFyYW1zLiB0aGlzLmFkZE1zZyBpcyBjYWxsZWQgdG8gYWRkIHRoZVxuICAgKiBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0byB0aGlzLm1lbVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtyZXFdIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpblxuICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gYWZ0ZXIgc2lnbmF0dXJlIGhhcyBiZWVuXG4gICAqL1xuICBhc3luYyBhZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKG1zZ1BhcmFtcywgcmVxKSB7XG4gICAgY29uc3QgbXNnSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gYXdhaXQgZmluaXNoZWRcbiAgICAgIHRoaXMub25jZShgJHttc2dJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEucmF3U2lnKTtcbiAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChcbiAgICAgICAgICAgICAgICAnTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgJ2Vycm9yZWQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKGBNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogJHtkYXRhLmVycm9yfWApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtc2dQYXJhbXMuIHRoaXMuYWRkTXNnIGlzIGNhbGxlZCB0byBhZGQgdGhlXG4gICAqIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIE1lc3NhZ2VzIGZyb20gdGhhdCBsaXN0IHRvIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgd2hlcmUgdGhlIG9yaWdpbiBtYXkgYmUgc3BlY2lmaWVkXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlLlxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICAvLyBhZGQgb3JpZ2luIGZyb20gcmVxdWVzdFxuICAgIGlmIChyZXEpIHtcbiAgICAgIG1zZ1BhcmFtcy5vcmlnaW4gPSByZXEub3JpZ2luO1xuICAgIH1cbiAgICBtc2dQYXJhbXMuZGF0YSA9IG5vcm1hbGl6ZU1zZ0RhdGEobXNnUGFyYW1zLmRhdGEpO1xuICAgIC8vIGNyZWF0ZSB0eERhdGEgb2JqIHdpdGggcGFyYW1ldGVycyBhbmQgbWV0YSBkYXRhXG4gICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IG1zZ0lkID0gY3JlYXRlSWQoKTtcbiAgICBjb25zdCBtc2dEYXRhID0ge1xuICAgICAgaWQ6IG1zZ0lkLFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgdGltZSxcbiAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLkVUSF9TSUdOLFxuICAgIH07XG4gICAgdGhpcy5hZGRNc2cobXNnRGF0YSk7XG5cbiAgICAvLyBzaWduYWwgdXBkYXRlXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgICByZXR1cm4gbXNnSWQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHBhc3NlZCBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCBjYWxscyB0aGlzLl9zYXZlTXNnTGlzdCgpIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgTWVzc2FnZXMgZnJvbSB0aGF0XG4gICAqIGxpc3QgdG8gdGhpcy5tZW1TdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgLSBUaGUgTWVzc2FnZSB0byBhZGQgdG8gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgYWRkTXNnKG1zZykge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlfHVuZGVmaW5lZH0gVGhlIE1lc3NhZ2Ugd2l0aCB0aGUgaWQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgbXNnSWQsIG9yIHVuZGVmaW5lZCBpZiBubyBNZXNzYWdlIGhhcyB0aGF0IGlkLlxuICAgKi9cbiAgZ2V0TXNnKG1zZ0lkKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobXNnKSA9PiBtc2cuaWQgPT09IG1zZ0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHByb3ZlcyBhIE1lc3NhZ2UuIFNldHMgdGhlIG1lc3NhZ2Ugc3RhdHVzIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZCwgYW5kIHJldHVybnMgYSBwcm9taXNlIHdpdGhcbiAgICogYW55IHRoZSBtZXNzYWdlIHBhcmFtcyBtb2RpZmllZCBmb3IgcHJvcGVyIHNpZ25pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbXNnUGFyYW1zIHRvIGJlIHVzZWQgd2hlbiBldGhfc2lnbiBpcyBjYWxsZWQsIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFzay5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIC0gQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIG9iamVjdCB3aXRoIG1ldGFtYXNrSWQgcmVtb3ZlZC5cbiAgICovXG4gIGFwcHJvdmVNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnUGFyYW1zLm1ldGFtYXNrSWQpO1xuICAgIHJldHVybiB0aGlzLnByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIE1lc3NhZ2Ugc3RhdHVzIHRvICdhcHByb3ZlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBhcHByb3ZlLlxuICAgKi9cbiAgc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnSWQpIHtcbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdhcHByb3ZlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAnc2lnbmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyBieVxuICAgKiBhZGRpbmcgdGhlIHJhdyBzaWduYXR1cmUgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgdG8gdGhlIE1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7YnVmZmVyfSByYXdTaWcgLSBUaGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAqL1xuICBzZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHJhd1NpZykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3U2lnID0gcmF3U2lnO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3NpZ25lZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbXNnUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0aGUgdXBkYXRlZCBtc2dQYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqL1xuICBwcmVwTXNnRm9yU2lnbmluZyhtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2dQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAncmVqZWN0ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gcmVqZWN0LlxuICAgKiBAcGFyYW0gcmVhc29uXG4gICAqL1xuICByZWplY3RNc2cobXNnSWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICAgIHRoaXMubWV0cmljc0V2ZW50KHtcbiAgICAgICAgZXZlbnQ6IHJlYXNvbixcbiAgICAgICAgY2F0ZWdvcnk6ICdUcmFuc2FjdGlvbnMnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYWN0aW9uOiAnU2lnbiBSZXF1ZXN0JyxcbiAgICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdyZWplY3RlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIHN0YXR1cyB0byAnZXJyb3JlZCcgdmlhIGEgY2FsbCB0byB0aGlzLl9zZXRNc2dTdGF0dXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgTWVzc2FnZSB0byBlcnJvclxuICAgKiBAcGFyYW0gZXJyb3JcbiAgICovXG4gIGVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgbXNnLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnZXJyb3JlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdW5hcHByb3ZlZCBtZXNzYWdlcyBmcm9tIG1lbW9yeS5cbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZCgpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcy5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyAhPT0gJ3VuYXBwcm92ZWQnKTtcbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIC0gVGhlIG5ldyBzdGF0dXMgb2YgdGhlIE1lc3NhZ2UuXG4gICAqIEB0aHJvd3MgQSAnTWVzc2FnZU1hbmFnZXIgLSBNZXNzYWdlIG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi4nIGlmIHRoZXJlIGlzIG5vIE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB3aXRoIGFuXG4gICAqIGlkIGVxdWFsIHRvIHRoZSBwYXNzZWQgbXNnSWRcbiAgICogQGZpcmVzIEFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfToke3N0YXR1c31gLiBUaGUgTWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3NpZ25lZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmcgd2l0aCB0aGUgbWVzc2FnZVxuICAgKi9cbiAgX3NldE1zZ1N0YXR1cyhtc2dJZCwgc3RhdHVzKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIGlmICghbXNnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2VNYW5hZ2VyIC0gTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiBcIiR7bXNnSWR9XCIuYCk7XG4gICAgfVxuICAgIG1zZy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5fdXBkYXRlTXNnKG1zZyk7XG4gICAgdGhpcy5lbWl0KGAke21zZ0lkfToke3N0YXR1c31gLCBtc2cpO1xuICAgIGlmIChzdGF0dXMgPT09ICdyZWplY3RlZCcgfHwgc3RhdHVzID09PSAnc2lnbmVkJykge1xuICAgICAgdGhpcy5lbWl0KGAke21zZ0lkfTpmaW5pc2hlZGAsIG1zZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdG8gdGhlIHBhc3NlZCBNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZSB1bmFwcHJvdmVkTXNnIGxpc3QgdG9cbiAgICogc3RvcmFnZSB2aWEgdGhpcy5fc2F2ZU1zZ0xpc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2cgLSBBIE1lc3NhZ2UgdGhhdCB3aWxsIHJlcGxhY2UgYW4gZXhpc3RpbmcgTWVzc2FnZSAod2l0aCB0aGUgc2FtZSBpZCkgaW4gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgX3VwZGF0ZU1zZyhtc2cpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtc2cuaWQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbXNnO1xuICAgIH1cbiAgICB0aGlzLl9zYXZlTXNnTGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIG1lc3NhZ2VzLCBhbmQgdGhlaXIgY291bnQsIHRvIHRoaXMubWVtU3RvcmVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzICd1cGRhdGVCYWRnZSdcbiAgICovXG4gIF9zYXZlTXNnTGlzdCgpIHtcbiAgICBjb25zdCB1bmFwcHJvdmVkTXNncyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKTtcbiAgICBjb25zdCB1bmFwcHJvdmVkTXNnQ291bnQgPSBPYmplY3Qua2V5cyh1bmFwcHJvdmVkTXNncykubGVuZ3RoO1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoeyB1bmFwcHJvdmVkTXNncywgdW5hcHByb3ZlZE1zZ0NvdW50IH0pO1xuICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICB9XG59XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXcgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gZGF0YSAtIFRoZSBidWZmZXIgZGF0YSB0byBjb252ZXJ0IHRvIGEgaGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGhleCBzdHJpbmcgY29udmVyc2lvbiBvZiB0aGUgYnVmZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU1zZ0RhdGEoZGF0YSkge1xuICBpZiAoZGF0YS5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgIC8vIGRhdGEgaXMgYWxyZWFkeSBoZXhcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvLyBkYXRhIGlzIHVuaWNvZGUsIGNvbnZlcnQgdG8gaGV4XG4gIHJldHVybiBidWZmZXJUb0hleChCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpKTtcbn1cbiIsImltcG9ydCB7IG1lcmdlLCBvbWl0LCBvbWl0QnkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBidWZmZXJUb0hleCwga2VjY2FrIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gJ3B1Ym51Yic7XG5pbXBvcnQgeyBFTlZJUk9OTUVOVF9UWVBFX0JBQ0tHUk9VTkQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQge1xuICBNRVRBTUVUUklDU19BTk9OWU1PVVNfSUQsXG4gIE1FVEFNRVRSSUNTX0JBQ0tHUk9VTkRfUEFHRV9PQkpFQ1QsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcblxuY29uc3QgZGVmYXVsdENhcHR1cmVFeGNlcHRpb24gPSAoZXJyKSA9PiB7XG4gIC8vIHRocm93IGVycm9yIG9uIGNsZWFuIHN0YWNrIHNvIGl0cyBjYXB0dXJlZCBieSBwbGF0Zm9ybSBpbnRlZ3JhdGlvbnMgKGVnIHNlbnRyeSlcbiAgLy8gYnV0IGRvZXMgbm90IGludGVycnVwdCB0aGUgY2FsbCBzdGFja1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTtcblxuY29uc3QgZXhjZXB0aW9uc1RvRmlsdGVyID0ge1xuICBbYFlvdSBtdXN0IHBhc3MgZWl0aGVyIGFuIFwiYW5vbnltb3VzSWRcIiBvciBhIFwidXNlcklkXCIuYF06IHRydWUsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnKS5NZXRhTWV0cmljc0NvbnRleHR9IE1ldGFNZXRyaWNzQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLk1ldGFNZXRyaWNzRXZlbnRQYXlsb2FkfSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLk1ldGFNZXRyaWNzRXZlbnRPcHRpb25zfSBNZXRhTWV0cmljc0V2ZW50T3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLlNlZ21lbnRFdmVudFBheWxvYWR9IFNlZ21lbnRFdmVudFBheWxvYWRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnKS5TZWdtZW50SW50ZXJmYWNlfSBTZWdtZW50SW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJykuTWV0YU1ldHJpY3NQYWdlUGF5bG9hZH0gTWV0YU1ldHJpY3NQYWdlUGF5bG9hZFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcycpLk1ldGFNZXRyaWNzUGFnZU9wdGlvbnN9IE1ldGFNZXRyaWNzUGFnZU9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnKS5NZXRhTWV0cmljc0V2ZW50RnJhZ21lbnR9IE1ldGFNZXRyaWNzRXZlbnRGcmFnbWVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YU1ldHJpY3NDb250cm9sbGVyU3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWV0YU1ldHJpY3NJZF0gLSBUaGUgdXNlcidzIG1ldGFNZXRyaWNzSWQgdGhhdCB3aWxsIGJlXG4gKiAgYXR0YWNoZWQgdG8gYWxsIG5vbi1hbm9ueW1pemVkIGV2ZW50IHBheWxvYWRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3NdIC0gVGhlIHVzZXIncyBwcmVmZXJlbmNlIGZvclxuICogIHBhcnRpY2lwYXRpbmcgaW4gdGhlIE1ldGFNZXRyaWNzIGFuYWx5dGljcyBwcm9ncmFtLiBUaGlzIHNldHRpbmcgY29udHJvbHNcbiAqICB3aGV0aGVyIG9yIG5vdCBldmVudHMgYXJlIHRyYWNrZWRcbiAqIEBwcm9wZXJ0eSB7e1tzdHJpbmddOiBNZXRhTWV0cmljc0V2ZW50RnJhZ21lbnR9fSBbZnJhZ21lbnRzXSAtIE9iamVjdCBrZXllZFxuICogIGJ5IFVVSUQgd2l0aCBzdG9yZWQgZnJhZ21lbnRzIGFzIHZhbHVlcy5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXRhTWV0cmljc0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2VnbWVudCAtIGFuIGluc3RhbmNlIG9mIGFuYWx5dGljcy1ub2RlIGZvciB0cmFja2luZ1xuICAgKiAgZXZlbnRzIHRoYXQgY29uZm9ybSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIHRyYWNraW5nIHBsYW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByZWZlcmVuY2VzU3RvcmUgLSBUaGUgcHJlZmVyZW5jZXMgY29udHJvbGxlciBzdG9yZSwgdXNlZFxuICAgKiAgdG8gYWNjZXNzIGFuZCBzdWJzY3JpYmUgdG8gcHJlZmVyZW5jZXMgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uTmV0d29ya0RpZENoYW5nZSAtIFVzZWQgdG8gYXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlXG4gICAqICBuZXR3b3JrRGlkQ2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIG5ldHdvcmtDb250cm9sbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZ2V0Q3VycmVudENoYWluSWQgLSBHZXRzIHRoZSBjdXJyZW50IGNoYWluIGlkIGZyb20gdGhlXG4gICAqICBuZXR3b3JrIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5nZXROZXR3b3JrSWRlbnRpZmllciAtIEdldHMgdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgKiAgaWRlbnRpZmllciBmcm9tIHRoZSBuZXR3b3JrIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZW52aXJvbm1lbnQgLSBUaGUgZW52aXJvbm1lbnQgdGhlIGV4dGVuc2lvbiBpcyBydW5uaW5nIGluXG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NDb250cm9sbGVyU3RhdGV9IG9wdGlvbnMuaW5pdFN0YXRlIC0gU3RhdGUgdG8gaW5pdGlhbGl6ZWQgd2l0aFxuICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0dXJlRXhjZXB0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VnbWVudCxcbiAgICBwcmVmZXJlbmNlc1N0b3JlLFxuICAgIG9uTmV0d29ya0RpZENoYW5nZSxcbiAgICBnZXRDdXJyZW50Q2hhaW5JZCxcbiAgICBnZXROZXR3b3JrSWRlbnRpZmllcixcbiAgICB2ZXJzaW9uLFxuICAgIGVudmlyb25tZW50LFxuICAgIGluaXRTdGF0ZSxcbiAgICBjYXB0dXJlRXhjZXB0aW9uID0gZGVmYXVsdENhcHR1cmVFeGNlcHRpb24sXG4gIH0pIHtcbiAgICB0aGlzLl9jYXB0dXJlRXhjZXB0aW9uID0gKGVycikgPT4ge1xuICAgICAgLy8gVGhpcyBpcyBhIHRlbXBvcmFyeSBtZWFzdXJlLiBDdXJyZW50bHkgdGhlcmUgYXJlIGVycm9ycyBmbG9vZGluZyBzZW50cnkgZHVlIHRvIGEgcHJvYmxlbSBpbiBob3cgd2UgYXJlIHRyYWNraW5nIGFub255bW91c0lkXG4gICAgICAvLyBXZSBpbnRlbmQgb24gcmVtb3ZpbmcgdGhpcyBhcyBzb29uIGFzIHdlIHVuZGVyc3RhbmQgaG93IHRvIGNvcnJlY3RseSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAgICBpZiAoIWV4Y2VwdGlvbnNUb0ZpbHRlcltlcnIubWVzc2FnZV0pIHtcbiAgICAgICAgY2FwdHVyZUV4Y2VwdGlvbihlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlZlN0YXRlID0gcHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgdGhpcy5uZXR3b3JrID0gZ2V0TmV0d29ya0lkZW50aWZpZXIoKTtcbiAgICB0aGlzLmxvY2FsZSA9IHByZWZTdGF0ZS5jdXJyZW50TG9jYWxlLnJlcGxhY2UoJ18nLCAnLScpO1xuICAgIHRoaXMudmVyc2lvbiA9XG4gICAgICBlbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nID8gdmVyc2lvbiA6IGAke3ZlcnNpb259LSR7ZW52aXJvbm1lbnR9YDtcblxuICAgIGNvbnN0IGFiYW5kb25lZEZyYWdtZW50cyA9IG9taXRCeShpbml0U3RhdGU/LmZyYWdtZW50cywgJ3BlcnNpc3QnKTtcblxuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljczogbnVsbCxcbiAgICAgIG1ldGFNZXRyaWNzSWQ6IG51bGwsXG4gICAgICAuLi5pbml0U3RhdGUsXG4gICAgICBmcmFnbWVudHM6IHtcbiAgICAgICAgLi4uaW5pdFN0YXRlPy5mcmFnbWVudHMsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcHJlZmVyZW5jZXNTdG9yZS5zdWJzY3JpYmUoKHsgY3VycmVudExvY2FsZSB9KSA9PiB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGN1cnJlbnRMb2NhbGUucmVwbGFjZSgnXycsICctJyk7XG4gICAgfSk7XG5cbiAgICBvbk5ldHdvcmtEaWRDaGFuZ2UoKCkgPT4ge1xuICAgICAgdGhpcy5jaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICAgIHRoaXMubmV0d29yayA9IGdldE5ldHdvcmtJZGVudGlmaWVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcblxuICAgIC8vIFRyYWNrIGFiYW5kb25lZCBmcmFnbWVudHMgdGhhdCB3ZXJlbid0IHByb3Blcmx5IGNsZWFuZWQgdXAuXG4gICAgLy8gQWJhbmRvbmVkIGZyYWdtZW50cyBhcmUgdGhvc2UgdGhhdCB3ZXJlIHN0b3JlZCBpbiBwZXJzaXN0ZW50IG1lbW9yeVxuICAgIC8vIGFuZCBhcmUgYXZhaWxhYmxlIGF0IGNvbnRyb2xsZXIgaW5zdGFuY2UgY3JlYXRpb24sIGJ1dCBkbyBub3QgaGF2ZSB0aGVcbiAgICAvLyAncGVyc2lzdCcgZmxhZyBzZXQuIFRoaXMgbWVhbnMgYW55dGltZSB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkLCBhbnlcbiAgICAvLyBmcmFnbWVudHMgdGhhdCBhcmUgbm90IG1hcmtlZCBhcyBwZXJzaXN0ZW50IHdpbGwgYmUgcHVyZ2VkIGFuZCB0aGVcbiAgICAvLyBmYWlsdXJlIGV2ZW50IHdpbGwgYmUgZW1pdHRlZC5cbiAgICBPYmplY3QudmFsdWVzKGFiYW5kb25lZEZyYWdtZW50cykuZm9yRWFjaCgoZnJhZ21lbnQpID0+IHtcbiAgICAgIHRoaXMuZmluYWxpemVFdmVudEZyYWdtZW50KGZyYWdtZW50LmlkLCB7IGFiYW5kb25lZDogdHJ1ZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIENsb3NlIG91dCBldmVudCBmcmFnbWVudHMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnV0IG5vdCBwcm9ncmVzc2VkLiBBblxuICAgIC8vIGludGVydmFsIGlzIHVzZWQgdG8gcm91dGluZWx5IGNoZWNrIGlmIGEgZnJhZ21lbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWRcbiAgICAvLyB3aXRoaW4gdGhlIGZyYWdtZW50J3MgdGltZW91dCB3aW5kb3cuIFdoZW4gY3JlYXRpbmcgYSBuZXcgZXZlbnQgZnJhZ21lbnRcbiAgICAvLyBhIHRpbWVvdXQgY2FuIGJlIHNwZWNpZmllZCB0aGF0IHdpbGwgY2F1c2UgYW4gYWJhbmRvbmVkIGV2ZW50IHRvIGJlXG4gICAgLy8gdHJhY2tlZCBpZiB0aGUgZXZlbnQgaXNuJ3QgcHJvZ3Jlc3NlZCB3aXRoaW4gdGhhdCBhbW91bnQgb2YgdGltZS5cbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5mcmFnbWVudHMpLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmcmFnbWVudC50aW1lb3V0ICYmXG4gICAgICAgICAgRGF0ZS5ub3coKSAtIGZyYWdtZW50Lmxhc3RVcGRhdGVkIC8gMTAwMCA+IGZyYWdtZW50LnRpbWVvdXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5maW5hbGl6ZUV2ZW50RnJhZ21lbnQoZnJhZ21lbnQuaWQsIHsgYWJhbmRvbmVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBTRUNPTkQgKiAzMCk7XG4gIH1cblxuICBnZW5lcmF0ZU1ldGFNZXRyaWNzSWQoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvSGV4KFxuICAgICAga2VjY2FrKFxuICAgICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgICBTdHJpbmcoRGF0ZS5ub3coKSkgK1xuICAgICAgICAgICAgU3RyaW5nKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSksXG4gICAgICAgICksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV2ZW50IGZyYWdtZW50IGluIHN0YXRlIGFuZCByZXR1cm5zIHRoZSBldmVudCBmcmFnbWVudCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NFdmVudEZyYWdtZW50fSBvcHRpb25zIC0gRnJhZ21lbnQgc2V0dGluZ3MgYW5kIHByb3BlcnRpZXNcbiAgICogIHRvIGluaXRpYXRlIHRoZSBmcmFnbWVudCB3aXRoLlxuICAgKiBAcmV0dXJucyB7TWV0YU1ldHJpY3NFdmVudEZyYWdtZW50fVxuICAgKi9cbiAgY3JlYXRlRXZlbnRGcmFnbWVudChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnN1Y2Nlc3NFdmVudCB8fCAhb3B0aW9ucy5jYXRlZ29yeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTXVzdCBzcGVjaWZ5IHN1Y2Nlc3MgZXZlbnQgYW5kIGNhdGVnb3J5LiBTdWNjZXNzIGV2ZW50IHdhczogJHtcbiAgICAgICAgICBvcHRpb25zLmV2ZW50XG4gICAgICAgIH0uIENhdGVnb3J5IHdhczogJHtvcHRpb25zLmNhdGVnb3J5fS4gUGF5bG9hZCBrZXlzIHdlcmU6ICR7T2JqZWN0LmtleXMoXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKX0uICR7XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMucHJvcGVydGllcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gYFBheWxvYWQgcHJvcGVydHkga2V5cyB3ZXJlOiAke09iamVjdC5rZXlzKG9wdGlvbnMucHJvcGVydGllcyl9YFxuICAgICAgICAgICAgOiAnJ1xuICAgICAgICB9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgZnJhZ21lbnRzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCBpZCA9IG9wdGlvbnMudW5pcXVlSWRlbnRpZmllciA/PyBnZW5lcmF0ZVVVSUQoKTtcbiAgICBjb25zdCBmcmFnbWVudCA9IHtcbiAgICAgIGlkLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBmcmFnbWVudHM6IHtcbiAgICAgICAgLi4uZnJhZ21lbnRzLFxuICAgICAgICBbaWRdOiBmcmFnbWVudCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsRXZlbnQpIHtcbiAgICAgIHRoaXMudHJhY2tFdmVudCh7XG4gICAgICAgIGV2ZW50OiBmcmFnbWVudC5pbml0aWFsRXZlbnQsXG4gICAgICAgIGNhdGVnb3J5OiBmcmFnbWVudC5jYXRlZ29yeSxcbiAgICAgICAgcHJvcGVydGllczogZnJhZ21lbnQucHJvcGVydGllcyxcbiAgICAgICAgc2Vuc2l0aXZlUHJvcGVydGllczogZnJhZ21lbnQuc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICAgICAgcGFnZTogZnJhZ21lbnQucGFnZSxcbiAgICAgICAgcmVmZXJyZXI6IGZyYWdtZW50LnJlZmVycmVyLFxuICAgICAgICByZXZlbnVlOiBmcmFnbWVudC5yZXZlbnVlLFxuICAgICAgICB2YWx1ZTogZnJhZ21lbnQudmFsdWUsXG4gICAgICAgIGN1cnJlbmN5OiBmcmFnbWVudC5jdXJyZW5jeSxcbiAgICAgICAgZW52aXJvbm1lbnRUeXBlOiBmcmFnbWVudC5lbnZpcm9ubWVudFR5cGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhZ21lbnQgc3RvcmVkIGluIG1lbW9yeSB3aXRoIHByb3ZpZGVkIGlkIG9yIHVuZGVmaW5lZCBpZiBpdFxuICAgKiBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWQgb2YgZnJhZ21lbnQgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMge1tNZXRhTWV0cmljc0V2ZW50RnJhZ21lbnRdfVxuICAgKi9cbiAgZ2V0RXZlbnRGcmFnbWVudEJ5SWQoaWQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBmcmFnbWVudHNbaWRdO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXZlbnQgZnJhZ21lbnQgaW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGZyYWdtZW50IGlkIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRGcmFnbWVudH0gcGF5bG9hZCAtIEZyYWdtZW50IHNldHRpbmdzIGFuZFxuICAgKiAgcHJvcGVydGllcyB0byBpbml0aWF0ZSB0aGUgZnJhZ21lbnQgd2l0aC5cbiAgICovXG4gIHVwZGF0ZUV2ZW50RnJhZ21lbnQoaWQsIHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgZnJhZ21lbnQgPSBmcmFnbWVudHNbaWRdO1xuXG4gICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCBmcmFnbWVudCB3aXRoIGlkICR7aWR9IGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgZnJhZ21lbnRzOiB7XG4gICAgICAgIC4uLmZyYWdtZW50cyxcbiAgICAgICAgW2lkXTogbWVyZ2UoZnJhZ21lbnRzW2lkXSwge1xuICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZXMgYSBmcmFnbWVudCwgdHJhY2tpbmcgZWl0aGVyIGEgc3VjY2VzcyBldmVudCBvciBmYWlsdXJlIEV2ZW50XG4gICAqIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGZyYWdtZW50IGZyb20gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFVVSUQgb2YgdGhlIGV2ZW50IGZyYWdtZW50IHRvIGJlIGNsb3NlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFiYW5kb25lZF0gLSBpZiB0cnVlIHRyYWNrIHRoZSBmYWlsdXJlXG4gICAqICBldmVudCBpbnN0ZWFkIG9mIHRoZSBzdWNjZXNzIGV2ZW50XG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NDb250ZXh0LnBhZ2V9IFtvcHRpb25zLnBhZ2VdIC0gcGFnZSB0aGUgZmluYWwgZXZlbnRcbiAgICogIG9jY3VycmVkIG9uLiBUaGlzIHdpbGwgb3ZlcnJpZGUgd2hhdGV2ZXIgaXMgc2V0IG9uIHRoZSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzQ29udGV4dC5yZWZlcnJlcn0gW29wdGlvbnMucmVmZXJyZXJdIC0gRGFwcCB0aGF0XG4gICAqICBvcmlnaW5hdGVkIHRoZSBmcmFnbWVudC4gVGhpcyBpcyBmb3IgZmFsbGJhY2sgb25seSwgdGhlIGZyYWdtZW50IHJlZmVycmVyXG4gICAqICBwcm9wZXJ0eSB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICovXG4gIGZpbmFsaXplRXZlbnRGcmFnbWVudChpZCwgeyBhYmFuZG9uZWQgPSBmYWxzZSwgcGFnZSwgcmVmZXJyZXIgfSA9IHt9KSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZnJhZ21lbnRzW2lkXTtcbiAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bm5lbCB3aXRoIGlkICR7aWR9IGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGFiYW5kb25lZCA/IGZyYWdtZW50LmZhaWx1cmVFdmVudCA6IGZyYWdtZW50LnN1Y2Nlc3NFdmVudDtcblxuICAgIHRoaXMudHJhY2tFdmVudCh7XG4gICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgY2F0ZWdvcnk6IGZyYWdtZW50LmNhdGVnb3J5LFxuICAgICAgcHJvcGVydGllczogZnJhZ21lbnQucHJvcGVydGllcyxcbiAgICAgIHNlbnNpdGl2ZVByb3BlcnRpZXM6IGZyYWdtZW50LnNlbnNpdGl2ZVByb3BlcnRpZXMsXG4gICAgICBwYWdlOiBwYWdlID8/IGZyYWdtZW50LnBhZ2UsXG4gICAgICByZWZlcnJlcjogZnJhZ21lbnQucmVmZXJyZXIgPz8gcmVmZXJyZXIsXG4gICAgICByZXZlbnVlOiBmcmFnbWVudC5yZXZlbnVlLFxuICAgICAgdmFsdWU6IGZyYWdtZW50LnZhbHVlLFxuICAgICAgY3VycmVuY3k6IGZyYWdtZW50LmN1cnJlbmN5LFxuICAgICAgZW52aXJvbm1lbnRUeXBlOiBmcmFnbWVudC5lbnZpcm9ubWVudFR5cGUsXG4gICAgfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudHMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBkZWxldGUgZnJhZ21lbnRzW2lkXTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZnJhZ21lbnRzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3NgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgd2FudHNcbiAgICogIHRvIHBhcnRpY2lwYXRlIGluIE1ldGFNZXRyaWNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gdGhlIHN0cmluZyBvZiB0aGUgbmV3IG1ldGFtZXRyaWNzIGlkLCBvciBudWxsXG4gICAqICBpZiBub3Qgc2V0XG4gICAqL1xuICBzZXRQYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MocGFydGljaXBhdGVJbk1ldGFNZXRyaWNzKSB7XG4gICAgbGV0IHsgbWV0YU1ldHJpY3NJZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAocGFydGljaXBhdGVJbk1ldGFNZXRyaWNzICYmICFtZXRhTWV0cmljc0lkKSB7XG4gICAgICBtZXRhTWV0cmljc0lkID0gdGhpcy5nZW5lcmF0ZU1ldGFNZXRyaWNzSWQoKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGFNZXRyaWNzSWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLCBtZXRhTWV0cmljc0lkIH0pO1xuICAgIHJldHVybiBtZXRhTWV0cmljc0lkO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgdGhlIGNvbnRleHQgb2JqZWN0IHRvIGF0dGFjaCB0byBwYWdlIGFuZCB0cmFjayBldmVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UGljazxNZXRhTWV0cmljc0NvbnRleHQsICdyZWZlcnJlcic+fSBbcmVmZXJyZXJdIC0gZGFwcCBvcmlnaW4gdGhhdCBpbml0aWFsaXplZFxuICAgKiAgdGhlIG5vdGlmaWNhdGlvbiB3aW5kb3cuXG4gICAqIEBwYXJhbSB7UGljazxNZXRhTWV0cmljc0NvbnRleHQsICdwYWdlJz59IFtwYWdlXSAtIHBhZ2Ugb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGN1cnJlbnRcbiAgICogIHZpZXcgb2YgdGhlIGV4dGVuc2lvbi4gRGVmYXVsdHMgdG8gdGhlIGJhY2tncm91bmQtcHJvY2VzcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtNZXRhTWV0cmljc0NvbnRleHR9XG4gICAqL1xuICBfYnVpbGRDb250ZXh0KHJlZmVycmVyLCBwYWdlID0gTUVUQU1FVFJJQ1NfQkFDS0dST1VORF9QQUdFX09CSkVDVCkge1xuICAgIHJldHVybiB7XG4gICAgICBhcHA6IHtcbiAgICAgICAgbmFtZTogJ01ldGFNYXNrIEV4dGVuc2lvbicsXG4gICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIH0sXG4gICAgICB1c2VyQWdlbnQ6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgcGFnZSxcbiAgICAgIHJlZmVycmVyLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQncyB0aGUgZXZlbnQgcGF5bG9hZCwgcHJvY2Vzc2luZyBhbGwgZmllbGRzIGludG8gYSBmb3JtYXQgdGhhdCBjYW4gYmVcbiAgICogZmVkIHRvIFNlZ21lbnQncyB0cmFjayBtZXRob2RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtcbiAgICogIE9taXQ8TWV0YU1ldHJpY3NFdmVudFBheWxvYWQsICdzZW5zaXRpdmVQcm9wZXJ0aWVzJz5cbiAgICogfSByYXdQYXlsb2FkIC0gcmF3IHBheWxvYWQgcHJvdmlkZWQgdG8gdHJhY2tFdmVudFxuICAgKiBAcmV0dXJucyB7U2VnbWVudEV2ZW50UGF5bG9hZH0gZm9ybWF0dGVkIGV2ZW50IHBheWxvYWQgZm9yIHNlZ21lbnRcbiAgICovXG4gIF9idWlsZEV2ZW50UGF5bG9hZChyYXdQYXlsb2FkKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgcmV2ZW51ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgY3VycmVuY3ksXG4gICAgICBjYXRlZ29yeSxcbiAgICAgIHBhZ2UsXG4gICAgICByZWZlcnJlcixcbiAgICAgIGVudmlyb25tZW50VHlwZSA9IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCxcbiAgICB9ID0gcmF3UGF5bG9hZDtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIFRoZXNlIHZhbHVlcyBhcmUgb21pdHRlZCBmcm9tIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGhhdmUgc3BlY2lhbCBtZWFuaW5nXG4gICAgICAgIC8vIGluIHNlZ21lbnQuIGh0dHBzOi8vc2VnbWVudC5jb20vZG9jcy9jb25uZWN0aW9ucy9zcGVjL3RyYWNrLyNwcm9wZXJ0aWVzLlxuICAgICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgdXNpbmcgdGhlc2UgaW5hcHByb3ByaWF0ZWx5LCB5b3UgbXVzdCBhZGQgdGhlbSBhcyB0b3BcbiAgICAgICAgLy8gbGV2ZWwgcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgcGF5bG9hZC4gV2UgYWxzbyBleGNsdWRlIGxvY2FsZSB0byBwcmV2ZW50IGNvbnN1bWVyc1xuICAgICAgICAvLyBmcm9tIG92ZXJ3cml0aW5nIHRoaXMgY29udGV4dCBsZXZlbCBwcm9wZXJ0eS4gV2UgdHJhY2sgaXQgYXMgYSBwcm9wZXJ0eVxuICAgICAgICAvLyBiZWNhdXNlIG5vdCBhbGwgZGVzdGluYXRpb25zIG1hcCBsb2NhbGUgZnJvbSBjb250ZXh0LlxuICAgICAgICAuLi5vbWl0KHByb3BlcnRpZXMsIFsncmV2ZW51ZScsICdsb2NhbGUnLCAnY3VycmVuY3knLCAndmFsdWUnXSksXG4gICAgICAgIHJldmVudWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjdXJyZW5jeSxcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIG5ldHdvcms6IHByb3BlcnRpZXM/Lm5ldHdvcmsgPz8gdGhpcy5uZXR3b3JrLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICBjaGFpbl9pZDogcHJvcGVydGllcz8uY2hhaW5faWQgPz8gdGhpcy5jaGFpbklkLFxuICAgICAgICBlbnZpcm9ubWVudF90eXBlOiBlbnZpcm9ubWVudFR5cGUsXG4gICAgICB9LFxuICAgICAgY29udGV4dDogdGhpcy5fYnVpbGRDb250ZXh0KHJlZmVycmVyLCBwYWdlKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdmFsaWRhdGlvbiBvbiB0aGUgcGF5bG9hZCBhbmQgdXBkYXRlIHRoZSBpZCB0eXBlIHRvIHVzZSBiZWZvcmVcbiAgICogc2VuZGluZyB0byBTZWdtZW50LiBBbHNvIGV4YW1pbmVzIHRoZSBvcHRpb25zIHRvIHJvdXRlIGFuZCBoYW5kbGUgdGhlXG4gICAqIGV2ZW50IGFwcHJvcHJpYXRlbHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U2VnbWVudEV2ZW50UGF5bG9hZH0gcGF5bG9hZCAtIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRvIGV2ZW50XG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NFdmVudE9wdGlvbnN9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIHJvdXRpbmcgYW5kXG4gICAqICBoYW5kbGluZyB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBfdHJhY2socGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzT3B0SW4sXG4gICAgICBtZXRhTWV0cmljc0lkOiBtZXRhTWV0cmljc0lkT3ZlcnJpZGUsXG4gICAgICBtYXRvbW9FdmVudCxcbiAgICAgIGZsdXNoSW1tZWRpYXRlbHksXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IGlkVHlwZSA9ICd1c2VySWQnO1xuICAgIGxldCBpZFZhbHVlID0gdGhpcy5zdGF0ZS5tZXRhTWV0cmljc0lkO1xuICAgIGxldCBleGNsdWRlTWV0YU1ldHJpY3NJZCA9IG9wdGlvbnM/LmV4Y2x1ZGVNZXRhTWV0cmljc0lkID8/IGZhbHNlO1xuICAgIC8vIFRoaXMgaXMgY2FycmllZCBvdmVyIGZyb20gdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgYW5kIHdpbGwgbGlrZWx5IG5lZWRcbiAgICAvLyB0byBiZSB1cGRhdGVkIHRvIHdvcmsgd2l0aCB0aGUgbmV3IHRyYWNraW5nIHBsYW4uIEkgdGhpbmsgd2Ugc2hvdWxkIHVzZVxuICAgIC8vIGEgY29uZmlnIHNldHRpbmcgZm9yIHRoaXMgaW5zdGVhZCBvZiB0cnlpbmcgdG8gbWF0Y2ggdGhlIGV2ZW50IG5hbWVcbiAgICBjb25zdCBpc1NlbmRGbG93ID0gQm9vbGVhbihwYXlsb2FkLmV2ZW50Lm1hdGNoKC9ec2VuZHxeY29uZmlybS9pdSkpO1xuICAgIGlmIChpc1NlbmRGbG93KSB7XG4gICAgICBleGNsdWRlTWV0YU1ldHJpY3NJZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSB0cmFja2luZyBzZW5zaXRpdmUgZGF0YSB3ZSB3aWxsIGFsd2F5cyB1c2UgdGhlIGFub255bW91c0lkXG4gICAgLy8gcHJvcGVydHkgYXMgd2VsbCBhcyBvdXIgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lELiBUaGlzIHByZXZlbnRzIHVzIGZyb21cbiAgICAvLyBhc3NvY2lhdGluZyBwb3RlbnRpYWxseSBpZGVudGlmaWFibGUgaW5mb3JtYXRpb24gd2l0aCBhIHNwZWNpZmljIGlkLlxuICAgIC8vIER1cmluZyB0aGUgb3B0IGluIGZsb3cgd2Ugd2lsbCB0cmFjayBhbGwgZXZlbnRzLCBidXQgZG8gc28gd2l0aCB0aGVcbiAgICAvLyBhbm9ueW1vdXMgaWQuIFRoZSBvbmUgZXhjZXB0aW9uIHRvIHRoYXQgcnVsZSBpcyBhZnRlciB0aGUgdXNlciBvcHRzIGluXG4gICAgLy8gdG8gTWV0YU1ldHJpY3MuIFdoZW4gdGhhdCBoYXBwZW5zIHdlIHJlY2VpdmUgYmFjayB0aGUgdXNlcidzIG5ld1xuICAgIC8vIE1ldGFNZXRyaWNzIGlkIGJlZm9yZSBpdCBpcyBmdWxseSBwZXJzaXN0ZWQgdG8gc3RhdGUuIFRvIGF2b2lkIGEgcmFjZVxuICAgIC8vIGNvbmRpdGlvbiB3ZSBleHBsaWNpdGx5IHBhc3MgdGhlIG5ldyBpZCB0byB0aGUgdHJhY2sgbWV0aG9kLiBJbiB0aGF0XG4gICAgLy8gY2FzZSB3ZSB3aWxsIHRyYWNrIHRoZSBvcHQgaW4gZXZlbnQgdG8gdGhlIHVzZXIncyBpZC4gSW4gYWxsIG90aGVyIGNhc2VzXG4gICAgLy8gd2UgdXNlIHRoZSBtZXRhTWV0cmljc0lkIGZyb20gc3RhdGUuXG4gICAgaWYgKGV4Y2x1ZGVNZXRhTWV0cmljc0lkIHx8IChpc09wdEluICYmICFtZXRhTWV0cmljc0lkT3ZlcnJpZGUpKSB7XG4gICAgICBpZFR5cGUgPSAnYW5vbnltb3VzSWQnO1xuICAgICAgaWRWYWx1ZSA9IE1FVEFNRVRSSUNTX0FOT05ZTU9VU19JRDtcbiAgICB9IGVsc2UgaWYgKGlzT3B0SW4gJiYgbWV0YU1ldHJpY3NJZE92ZXJyaWRlKSB7XG4gICAgICBpZFZhbHVlID0gbWV0YU1ldHJpY3NJZE92ZXJyaWRlO1xuICAgIH1cbiAgICBwYXlsb2FkW2lkVHlwZV0gPSBpZFZhbHVlO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBldmVudCBvbiB0aGUgb2xkIG1hdG9tbyBzY2hlbWEsIGFkZCBhIGtleSB0byB0aGUgcGF5bG9hZFxuICAgIC8vIHRvIGRlc2lnbmF0ZSBpdCBhcyBzdWNoXG4gICAgaWYgKG1hdG9tb0V2ZW50ID09PSB0cnVlKSB7XG4gICAgICBwYXlsb2FkLnByb3BlcnRpZXMubGVnYWN5X2V2ZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBQcm9taXNlcyB3aWxsIG9ubHkgcmVzb2x2ZSB3aGVuIHRoZSBldmVudCBpcyBzZW50IHRvIHNlZ21lbnQuIEZvciBhbnlcbiAgICAvLyBldmVudCB0aGF0IHJlbGllcyBvbiB0aGlzIHByb21pc2UgYmVpbmcgZnVsZmlsbGVkIGJlZm9yZSBwZXJmb3JtaW5nIFVJXG4gICAgLy8gdXBkYXRlcywgb3Igb3RoZXJ3aXNlIGRlbGF5aW5nIHVzZXIgaW50ZXJhY3Rpb24sIHN1cHBseSB0aGVcbiAgICAvLyAnZmx1c2hJbW1lZGlhdGVseScgZmxhZyB0byB0aGUgdHJhY2tFdmVudCBtZXRob2QuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIHRoYXQgc2VnbWVudCBnaXZlcyB1cyBoYXMgc29tZSBtYW5pcHVsYXRpb24gZG9uZSB0byBpdFxuICAgICAgICAgIC8vIHRoYXQgc2VlbWluZ2x5IGJyZWFrcyB3aXRoIGxvY2tkb3duIGVuYWJsZWQuIENyZWF0aW5nIGEgbmV3IGVycm9yXG4gICAgICAgICAgLy8gaGVyZSBwcmV2ZW50cyB0aGUgc3lzdGVtIGZyb20gZnJlZXppbmcgd2hlbiB0aGUgbmV0d29yayByZXF1ZXN0IHRvXG4gICAgICAgICAgLy8gc2VnbWVudCBmYWlscyBmb3IgYW55IHJlYXNvbi5cbiAgICAgICAgICBjb25zdCBzYWZlRXJyb3IgPSBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIHNhZmVFcnJvci5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHNhZmVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc2VnbWVudC50cmFjayhwYXlsb2FkLCBjYWxsYmFjayk7XG4gICAgICBpZiAoZmx1c2hJbW1lZGlhdGVseSkge1xuICAgICAgICB0aGlzLnNlZ21lbnQuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cmFjayBhIHBhZ2UgdmlldyB3aXRoIFNlZ21lbnRcbiAgICpcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc1BhZ2VQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgcGFnZSB2aWV3ZWRcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc1BhZ2VPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBoYW5kbGluZyB0aGUgcGFnZVxuICAgKiAgdmlld1xuICAgKi9cbiAgdHJhY2tQYWdlKHsgbmFtZSwgcGFyYW1zLCBlbnZpcm9ubWVudFR5cGUsIHBhZ2UsIHJlZmVycmVyIH0sIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zdGF0ZS5wYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgPT09IG51bGwgJiZcbiAgICAgICAgIW9wdGlvbnM/LmlzT3B0SW5QYXRoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBtZXRhTWV0cmljc0lkIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgaWRUcmFpdCA9IG1ldGFNZXRyaWNzSWQgPyAndXNlcklkJyA6ICdhbm9ueW1vdXNJZCc7XG4gICAgICBjb25zdCBpZFZhbHVlID0gbWV0YU1ldHJpY3NJZCA/PyBNRVRBTUVUUklDU19BTk9OWU1PVVNfSUQ7XG4gICAgICB0aGlzLnNlZ21lbnQucGFnZSh7XG4gICAgICAgIFtpZFRyYWl0XTogaWRWYWx1ZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICAgICAgICBjaGFpbl9pZDogdGhpcy5jaGFpbklkLFxuICAgICAgICAgIGVudmlyb25tZW50X3R5cGU6IGVudmlyb25tZW50VHlwZSxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDogdGhpcy5fYnVpbGRDb250ZXh0KHJlZmVycmVyLCBwYWdlKSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY2FwdHVyZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzdWJtaXRzIGEgbWV0YW1ldHJpY3MgZXZlbnQsIG5vdCB3YWl0aW5nIGZvciBpdCB0byBjb21wbGV0ZSBvciBhbGxvd2luZyBpdHMgZXJyb3IgdG8gYnViYmxlIHVwXG4gICAqXG4gICAqIEBwYXJhbSB7TWV0YU1ldHJpY3NFdmVudFBheWxvYWR9IHBheWxvYWQgLSBkZXRhaWxzIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRPcHRpb25zfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBoYW5kbGluZy9yb3V0aW5nIHRoZSBldmVudFxuICAgKi9cbiAgdHJhY2tFdmVudChwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgLy8gdmFsaWRhdGlvbiBpcyBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkXG4gICAgdGhpcy52YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgdGhpcy5zdWJtaXRFdmVudChwYXlsb2FkLCBvcHRpb25zKS5jYXRjaCgoZXJyKSA9PlxuICAgICAgdGhpcy5fY2FwdHVyZUV4Y2VwdGlvbihlcnIpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogc3VibWl0cyAob3IgcXVldWVzIGZvciBzdWJtaXNzaW9uKSBhIG1ldGFtZXRyaWNzIGV2ZW50LCBwZXJmb3JtaW5nIG5lY2Vzc2FyeSBwYXlsb2FkIG1hbmlwdWxhdGlvbiBhbmRcbiAgICogcm91dGluZyB0aGUgZXZlbnQgdG8gdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgc291cmNlLiBXaWxsIHNwbGl0IGV2ZW50c1xuICAgKiB3aXRoIHNlbnNpdGl2ZVByb3BlcnRpZXMgaW50byB0d28gZXZlbnRzLCB0cmFja2luZyB0aGUgc2Vuc2l0aXZlUHJvcGVydGllc1xuICAgKiB3aXRoIHRoZSBhbm9ueW1vdXNJZCBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtNZXRhTWV0cmljc0V2ZW50T3B0aW9uc30gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgaGFuZGxpbmcvcm91dGluZyB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzdWJtaXRFdmVudChwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgdGhpcy52YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG5cbiAgICBpZiAoIXRoaXMuc3RhdGUucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzICYmICFvcHRpb25zPy5pc09wdEluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgbWlnaHQgdHJhY2sgbXVsdGlwbGUgZXZlbnRzIGlmIHNlbnNpdGl2ZVByb3BlcnRpZXMgaXMgaW5jbHVkZWQsIHRoaXMgYXJyYXkgd2lsbCBob2xkXG4gICAgLy8gdGhlIHByb21pc2VzIHJldHVybmVkIGZyb20gdGhpcy5fdHJhY2suXG4gICAgY29uc3QgZXZlbnRzID0gW107XG5cbiAgICBpZiAocGF5bG9hZC5zZW5zaXRpdmVQcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBzZW5zaXRpdmVQcm9wZXJ0aWVzIHdpbGwgb25seSBiZSB0cmFja2VkIHVzaW5nIHRoZSBhbm9ueW1vdXNJZCBwcm9wZXJ0eSBhbmQgZ2VuZXJpYyBpZFxuICAgICAgLy8gSWYgdGhlIGV2ZW50IG9wdGlvbnMgYWxyZWFkeSBzcGVjaWZ5IHRvIGV4Y2x1ZGUgdGhlIG1ldGFNZXRyaWNzSWQgd2UgdGhyb3cgYW4gZXJyb3IgYXNcbiAgICAgIC8vIGEgc2lnbmFsIHRvIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGUgZXZlbnQgd2FzIGltcGxlbWVudGVkIGluY29ycmVjdGx5XG4gICAgICBpZiAob3B0aW9ucz8uZXhjbHVkZU1ldGFNZXRyaWNzSWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdzZW5zaXRpdmVQcm9wZXJ0aWVzIHdhcyBzcGVjaWZpZWQgaW4gYW4gZXZlbnQgcGF5bG9hZCB0aGF0IGFsc28gc2V0IHRoZSBleGNsdWRlTWV0YU1ldHJpY3NJZCBmbGFnJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tYmluZWRQcm9wZXJ0aWVzID0gbWVyZ2UoXG4gICAgICAgIHBheWxvYWQuc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICAgICAgcGF5bG9hZC5wcm9wZXJ0aWVzLFxuICAgICAgKTtcblxuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIHRoaXMuX3RyYWNrKFxuICAgICAgICAgIHRoaXMuX2J1aWxkRXZlbnRQYXlsb2FkKHtcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBjb21iaW5lZFByb3BlcnRpZXMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyAuLi5vcHRpb25zLCBleGNsdWRlTWV0YU1ldHJpY3NJZDogdHJ1ZSB9LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBldmVudHMucHVzaCh0aGlzLl90cmFjayh0aGlzLl9idWlsZEV2ZW50UGF5bG9hZChwYXlsb2FkKSwgb3B0aW9ucykpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZXZlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2YWxpZGF0ZXMgYSBtZXRhbWV0cmljcyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge01ldGFNZXRyaWNzRXZlbnRQYXlsb2FkfSBwYXlsb2FkIC0gZGV0YWlscyBvZiB0aGUgZXZlbnRcbiAgICovXG4gIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgLy8gZXZlbnQgYW5kIGNhdGVnb3J5IGFyZSByZXF1aXJlZCBmaWVsZHMgZm9yIGFsbCBwYXlsb2Fkc1xuICAgIGlmICghcGF5bG9hZC5ldmVudCB8fCAhcGF5bG9hZC5jYXRlZ29yeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTXVzdCBzcGVjaWZ5IGV2ZW50IGFuZCBjYXRlZ29yeS4gRXZlbnQgd2FzOiAke1xuICAgICAgICAgIHBheWxvYWQuZXZlbnRcbiAgICAgICAgfS4gQ2F0ZWdvcnkgd2FzOiAke3BheWxvYWQuY2F0ZWdvcnl9LiBQYXlsb2FkIGtleXMgd2VyZTogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICApfS4gJHtcbiAgICAgICAgICB0eXBlb2YgcGF5bG9hZC5wcm9wZXJ0aWVzID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBgUGF5bG9hZCBwcm9wZXJ0eSBrZXlzIHdlcmU6ICR7T2JqZWN0LmtleXMocGF5bG9hZC5wcm9wZXJ0aWVzKX1gXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qIEFjY291bnQgVHJhY2tlclxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFja2luZyBhbnkgbnVtYmVyIG9mIGFjY291bnRzXG4gKiBhbmQgY2FjaGluZyB0aGVpciBjdXJyZW50IGJhbGFuY2VzICYgdHJhbnNhY3Rpb24gY291bnRzLlxuICpcbiAqIEl0IGFsc28gdHJhY2tzIHRyYW5zYWN0aW9uIGhhc2hlcywgYW5kIGNoZWNrcyB0aGVpciBpbmNsdXNpb24gc3RhdHVzXG4gKiBvbiBlYWNoIG5ldyBibG9jay5cbiAqL1xuXG5pbXBvcnQgRXRoUXVlcnkgZnJvbSAnZXRoLXF1ZXJ5JztcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBwaWZ5IGZyb20gJ3BpZnknO1xuaW1wb3J0IFdlYjMgZnJvbSAnd2ViMyc7XG5pbXBvcnQgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUJJIGZyb20gJ3NpbmdsZS1jYWxsLWJhbGFuY2UtY2hlY2tlci1hYmknO1xuaW1wb3J0IHtcbiAgTUFJTk5FVF9DSEFJTl9JRCxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgUk9QU1RFTl9DSEFJTl9JRCxcbiAgS09WQU5fQ0hBSU5fSUQsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmltcG9ydCB7XG4gIFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1MsXG4gIFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfUklOS0VCWSxcbiAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19ST1BTVEVOLFxuICBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX0tPVkFOLFxufSBmcm9tICcuLi9jb25zdGFudHMvY29udHJhY3RzJztcbmltcG9ydCB7IGJuVG9IZXggfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFja2luZyBhbnkgbnVtYmVyIG9mIGFjY291bnRzIGFuZCBjYWNoaW5nIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXMgJiB0cmFuc2FjdGlvblxuICogY291bnRzLlxuICpcbiAqIEl0IGFsc28gdHJhY2tzIHRyYW5zYWN0aW9uIGhhc2hlcywgYW5kIGNoZWNrcyB0aGVpciBpbmNsdXNpb24gc3RhdHVzIG9uIGVhY2ggbmV3IGJsb2NrLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFjY291bnRUcmFja2VyXG4gKiBAcHJvcGVydHkge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlZCBvYmplY3QgY29udGFpbmluZyBhbGwgYWNjb3VudHMgdG8gdHJhY2ssIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgYmxvY2sncyBnYXMgbGltaXQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gc3RvcmUuYWNjb3VudHMgVGhlIGFjY291bnRzIGN1cnJlbnRseSBzdG9yZWQgaW4gdGhpcyBBY2NvdW50VHJhY2tlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0b3JlLmN1cnJlbnRCbG9ja0dhc0xpbWl0IEEgaGV4IHN0cmluZyBpbmRpY2F0aW5nIHRoZSBnYXMgbGltaXQgb2YgdGhlIGN1cnJlbnQgYmxvY2tcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBfcHJvdmlkZXIgQSBwcm92aWRlciBuZWVkZWQgdG8gY3JlYXRlIHRoZSBFdGhRdWVyeSBpbnN0YW5jZSB1c2VkIHdpdGhpbiB0aGlzIEFjY291bnRUcmFja2VyLlxuICogQHByb3BlcnR5IHtFdGhRdWVyeX0gX3F1ZXJ5IEFuIEV0aFF1ZXJ5IGluc3RhbmNlIHVzZWQgdG8gYWNjZXNzIGFjY291bnQgaW5mb3JtYXRpb24gZnJvbSB0aGUgYmxvY2tjaGFpblxuICogQHByb3BlcnR5IHtCbG9ja1RyYWNrZXJ9IF9ibG9ja1RyYWNrZXIgQSBCbG9ja1RyYWNrZXIgaW5zdGFuY2UuIE5lZWRlZCB0byBlbnN1cmUgdGhhdCBhY2NvdW50cyBhbmQgdGhlaXIgaW5mbyB1cGRhdGVzXG4gKiB3aGVuIGEgbmV3IGJsb2NrIGlzIGNyZWF0ZWQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gX2N1cnJlbnRCbG9ja051bWJlciBSZWZlcmVuY2UgdG8gYSBwcm9wZXJ0eSBvbiB0aGUgX2Jsb2NrVHJhY2tlcjogdGhlIG51bWJlciAoaS5lLiBhbiBpZCkgb2YgdGhlIHRoZSBjdXJyZW50IGJsb2NrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY291bnRUcmFja2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3ZpZGVyIC0gQW4gRUlQLTExOTMgcHJvdmlkZXIgaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBjdXJyZW50IGdsb2JhbCBuZXR3b3JrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJsb2NrVHJhY2tlciAtIEEgYmxvY2sgdHJhY2tlciwgd2hpY2ggZW1pdHMgZXZlbnRzIGZvciBlYWNoIG5ldyBibG9ja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmdldEN1cnJlbnRDaGFpbklkIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGBjaGFpbklkYCBmb3IgdGhlIGN1cnJlbnQgZ2xvYmFsIG5ldHdvcmtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGFjY291bnRzOiB7fSxcbiAgICAgIGN1cnJlbnRCbG9ja0dhc0xpbWl0OiAnJyxcbiAgICB9O1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKGluaXRTdGF0ZSk7XG5cbiAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgdGhpcy5fcXVlcnkgPSBwaWZ5KG5ldyBFdGhRdWVyeSh0aGlzLl9wcm92aWRlcikpO1xuICAgIHRoaXMuX2Jsb2NrVHJhY2tlciA9IG9wdHMuYmxvY2tUcmFja2VyO1xuICAgIC8vIGJsb2NrVHJhY2tlci5jdXJyZW50QmxvY2sgbWF5IGJlIG51bGxcbiAgICB0aGlzLl9jdXJyZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9ibG9ja1RyYWNrZXIuZ2V0Q3VycmVudEJsb2NrKCk7XG4gICAgdGhpcy5fYmxvY2tUcmFja2VyLm9uY2UoJ2xhdGVzdCcsIChibG9ja051bWJlcikgPT4ge1xuICAgICAgdGhpcy5fY3VycmVudEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgfSk7XG4gICAgLy8gYmluZCBmdW5jdGlvbiBmb3IgZWFzaWVyIGxpc3RlbmVyIHN5bnRheFxuICAgIHRoaXMuX3VwZGF0ZUZvckJsb2NrID0gdGhpcy5fdXBkYXRlRm9yQmxvY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEN1cnJlbnRDaGFpbklkID0gb3B0cy5nZXRDdXJyZW50Q2hhaW5JZDtcblxuICAgIHRoaXMud2ViMyA9IG5ldyBXZWIzKHRoaXMuX3Byb3ZpZGVyKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIC8vIHJlbW92ZSBmaXJzdCB0byBhdm9pZCBkb3VibGUgYWRkXG4gICAgdGhpcy5fYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl91cGRhdGVGb3JCbG9jayk7XG4gICAgLy8gYWRkIGxpc3RlbmVyXG4gICAgdGhpcy5fYmxvY2tUcmFja2VyLmFkZExpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl91cGRhdGVGb3JCbG9jayk7XG4gICAgLy8gZmV0Y2ggYWNjb3VudCBiYWxhbmNlc1xuICAgIHRoaXMuX3VwZGF0ZUFjY291bnRzKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5yZW1vdmVMaXN0ZW5lcignbGF0ZXN0JywgdGhpcy5fdXBkYXRlRm9yQmxvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgbG9jYWxseSBzdG9yZWQgYWNjb3VudHMgYXJlIGluIHN5bmMgd2l0aCBhIHNldCBvZiBhY2NvdW50cyBzdG9yZWQgZXh0ZXJuYWxseSB0byB0aGlzXG4gICAqIEFjY291bnRUcmFja2VyLlxuICAgKlxuICAgKiBPbmNlIHRoaXMgQWNjb3VudFRyYWNrZXIncyBhY2NvdW50cyBhcmUgdXAgdG8gZGF0ZSB3aXRoIHRob3NlIHJlZmVyZW5jZWQgYnkgdGhlIHBhc3NlZCBhZGRyZXNzZXMsIGVhY2hcbiAgICogb2YgdGhlc2UgYWNjb3VudHMgYXJlIGdpdmVuIGFuIHVwZGF0ZWQgYmFsYW5jZSB2aWEgRXRoUXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFkZHJlc3NlcyAtIFRoZSBhcnJheSBvZiBoZXggYWRkcmVzc2VzIGZvciBhY2NvdW50cyB3aXRoIHdoaWNoIHRoaXMgQWNjb3VudFRyYWNrZXIncyBhY2NvdW50cyBzaG91bGQgYmVcbiAgICogaW4gc3luY1xuICAgKi9cbiAgc3luY1dpdGhBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGxvY2FscyA9IE9iamVjdC5rZXlzKGFjY291bnRzKTtcblxuICAgIGNvbnN0IGFjY291bnRzVG9BZGQgPSBbXTtcbiAgICBhZGRyZXNzZXMuZm9yRWFjaCgodXBzdHJlYW0pID0+IHtcbiAgICAgIGlmICghbG9jYWxzLmluY2x1ZGVzKHVwc3RyZWFtKSkge1xuICAgICAgICBhY2NvdW50c1RvQWRkLnB1c2godXBzdHJlYW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjb3VudHNUb1JlbW92ZSA9IFtdO1xuICAgIGxvY2Fscy5mb3JFYWNoKChsb2NhbCkgPT4ge1xuICAgICAgaWYgKCFhZGRyZXNzZXMuaW5jbHVkZXMobG9jYWwpKSB7XG4gICAgICAgIGFjY291bnRzVG9SZW1vdmUucHVzaChsb2NhbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZEFjY291bnRzKGFjY291bnRzVG9BZGQpO1xuICAgIHRoaXMucmVtb3ZlQWNjb3VudChhY2NvdW50c1RvUmVtb3ZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5ldyBhZGRyZXNzZXMgdG8gdHJhY2sgdGhlIGJhbGFuY2VzIG9mXG4gICAqIGdpdmVuIGEgYmFsYW5jZSBhcyBsb25nIHRoaXMuX2N1cnJlbnRCbG9ja051bWJlciBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhZGRyZXNzZXMgLSBBbiBhcnJheSBvZiBoZXggYWRkcmVzc2VzIG9mIG5ldyBhY2NvdW50cyB0byB0cmFja1xuICAgKi9cbiAgYWRkQWNjb3VudHMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIGFkZCBpbml0aWFsIHN0YXRlIGZvciBhZGRyZXNzZXNcbiAgICBhZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7fTtcbiAgICB9KTtcbiAgICAvLyBzYXZlIGFjY291bnRzIHN0YXRlXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzIH0pO1xuICAgIC8vIGZldGNoIGJhbGFuY2VzIGZvciB0aGUgYWNjb3VudHMgaWYgdGhlcmUgaXMgYmxvY2sgbnVtYmVyIHJlYWR5XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQWNjb3VudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFjY291bnRzIGZyb20gYmVpbmcgdHJhY2tlZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhZGRyZXNzZXMgLSBBbiBhcnJheSBvZiBoZXggYWRkcmVzc2VzIHRvIHN0b3AgdHJhY2tpbmcuXG4gICAqL1xuICByZW1vdmVBY2NvdW50KGFkZHJlc3Nlcykge1xuICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAvLyByZW1vdmUgZWFjaCBzdGF0ZSBvYmplY3RcbiAgICBhZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgZGVsZXRlIGFjY291bnRzW2FkZHJlc3NdO1xuICAgIH0pO1xuICAgIC8vIHNhdmUgYWNjb3VudHMgc3RhdGVcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgYWNjb3VudHMgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgYWRkcmVzc2VzIGFuZCBhc3NvY2lhdGVkIGJhbGFuY2VzXG4gICAqL1xuXG4gIGNsZWFyQWNjb3VudHMoKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzOiB7fSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGJsb2NrLCB1cGRhdGVzIHRoaXMgQWNjb3VudFRyYWNrZXIncyBjdXJyZW50QmxvY2tHYXNMaW1pdCwgYW5kIHRoZW4gdXBkYXRlcyBlYWNoIGxvY2FsIGFjY291bnQncyBiYWxhbmNlXG4gICAqIHZpYSBFdGhRdWVyeVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tOdW1iZXIgLSB0aGUgYmxvY2sgbnVtYmVyIHRvIHVwZGF0ZSB0by5cbiAgICogQGZpcmVzICdibG9jaycgVGhlIHVwZGF0ZWQgc3RhdGUsIGlmIGFsbCBhY2NvdW50IHVwZGF0ZXMgYXJlIHN1Y2Nlc3NmdWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVGb3JCbG9jayhibG9ja051bWJlcikge1xuICAgIHRoaXMuX2N1cnJlbnRCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXG4gICAgLy8gYmxvY2sgZ2FzTGltaXQgcG9sbGluZyBzaG91bGRuJ3QgYmUgaW4gYWNjb3VudC10cmFja2VyIHNob3VsZG4ndCBiZSBoZXJlLi4uXG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5fcXVlcnkuZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlciwgZmFsc2UpO1xuICAgIGlmICghY3VycmVudEJsb2NrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRCbG9ja0dhc0xpbWl0ID0gY3VycmVudEJsb2NrLmdhc0xpbWl0O1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBjdXJyZW50QmxvY2tHYXNMaW1pdCB9KTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVBY2NvdW50cygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGJhbGFuY2VDaGVja2VyIGlzIGRlcGxveWVkIG9uIG1haW4gZXRoICh0ZXN0KW5ldHMgYW5kIHJlcXVpcmVzIGEgc2luZ2xlIGNhbGxcbiAgICogZm9yIGFsbCBvdGhlciBuZXR3b3JrcywgY2FsbHMgdGhpcy5fdXBkYXRlQWNjb3VudCBmb3IgZWFjaCBhY2NvdW50IGluIHRoaXMuc3RvcmVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IGFmdGVyIGFsbCBhY2NvdW50IGJhbGFuY2VzIHVwZGF0ZWRcbiAgICovXG4gIGFzeW5jIF91cGRhdGVBY2NvdW50cygpIHtcbiAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gT2JqZWN0LmtleXMoYWNjb3VudHMpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG5cbiAgICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICAgIGNhc2UgTUFJTk5FVF9DSEFJTl9JRDpcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQWNjb3VudHNWaWFCYWxhbmNlQ2hlY2tlcihcbiAgICAgICAgICBhZGRyZXNzZXMsXG4gICAgICAgICAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUklOS0VCWV9DSEFJTl9JRDpcbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQWNjb3VudHNWaWFCYWxhbmNlQ2hlY2tlcihcbiAgICAgICAgICBhZGRyZXNzZXMsXG4gICAgICAgICAgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19SSU5LRUJZLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBST1BTVEVOX0NIQUlOX0lEOlxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVBY2NvdW50c1ZpYUJhbGFuY2VDaGVja2VyKFxuICAgICAgICAgIGFkZHJlc3NlcyxcbiAgICAgICAgICBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX1JPUFNURU4sXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtPVkFOX0NIQUlOX0lEOlxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVBY2NvdW50c1ZpYUJhbGFuY2VDaGVja2VyKFxuICAgICAgICAgIGFkZHJlc3NlcyxcbiAgICAgICAgICBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX0tPVkFOLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYWRkcmVzc2VzLm1hcCh0aGlzLl91cGRhdGVBY2NvdW50LmJpbmQodGhpcykpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY3VycmVudCBiYWxhbmNlIG9mIGFuIGFjY291bnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzcyBvZiBhIHRoZSBhY2NvdW50IHRvIGJlIHVwZGF0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2V9IGFmdGVyIHRoZSBhY2NvdW50IGJhbGFuY2UgaXMgdXBkYXRlZFxuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZUFjY291bnQoYWRkcmVzcykge1xuICAgIC8vIHF1ZXJ5IGJhbGFuY2VcbiAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgdGhpcy5fcXVlcnkuZ2V0QmFsYW5jZShhZGRyZXNzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7IGFkZHJlc3MsIGJhbGFuY2UgfTtcbiAgICAvLyB1cGRhdGUgYWNjb3VudHMgc3RhdGVcbiAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gb25seSBwb3B1bGF0ZSBpZiB0aGUgZW50cnkgaXMgc3RpbGwgcHJlc2VudFxuICAgIGlmICghYWNjb3VudHNbYWRkcmVzc10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWNjb3VudHNbYWRkcmVzc10gPSByZXN1bHQ7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGFjY291bnRzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBhZGRyZXNzIGJhbGFuY2VzIGZyb20gYmFsYW5jZUNoZWNrZXIgZGVwbG95ZWQgY29udHJhY3QgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHsqfSBhZGRyZXNzZXNcbiAgICogQHBhcmFtIHsqfSBkZXBsb3llZENvbnRyYWN0QWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgX3VwZGF0ZUFjY291bnRzVmlhQmFsYW5jZUNoZWNrZXIoYWRkcmVzc2VzLCBkZXBsb3llZENvbnRyYWN0QWRkcmVzcykge1xuICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLndlYjMuc2V0UHJvdmlkZXIodGhpcy5fcHJvdmlkZXIpO1xuICAgIGNvbnN0IGV0aENvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aFxuICAgICAgLmNvbnRyYWN0KFNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FCSSlcbiAgICAgIC5hdChkZXBsb3llZENvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgZXRoQmFsYW5jZSA9IFsnMHgwJ107XG5cbiAgICBldGhDb250cmFjdC5iYWxhbmNlcyhhZGRyZXNzZXMsIGV0aEJhbGFuY2UsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbG9nLndhcm4oXG4gICAgICAgICAgYE1ldGFNYXNrIC0gQWNjb3VudCBUcmFja2VyIHNpbmdsZSBjYWxsIGJhbGFuY2UgZmV0Y2ggZmFpbGVkYCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgICAgUHJvbWlzZS5hbGwoYWRkcmVzc2VzLm1hcCh0aGlzLl91cGRhdGVBY2NvdW50LmJpbmQodGhpcykpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSByZXN1bHRbaW5kZXhdID8gYm5Ub0hleChyZXN1bHRbaW5kZXhdKSA6ICcweDAnO1xuICAgICAgICBhY2NvdW50c1thZGRyZXNzXSA9IHsgYWRkcmVzcywgYmFsYW5jZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgYWNjb3VudHMgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5pbXBvcnQgeyBiblRvSGV4IH0gZnJvbSAnLi4vbGliL3V0aWwnO1xuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvZmV0Y2gtd2l0aC10aW1lb3V0JztcblxuaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQLFxuICBDSEFJTl9JRF9UT19UWVBFX01BUCxcbiAgR09FUkxJX0NIQUlOX0lELFxuICBLT1ZBTl9DSEFJTl9JRCxcbiAgTUFJTk5FVF9DSEFJTl9JRCxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgUk9QU1RFTl9DSEFJTl9JRCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5cbmNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KFNFQ09ORCAqIDMwKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcbiAqL1xuXG4vKipcbiAqIEEgdHJhbnNhY3Rpb24gb2JqZWN0IGluIHRoZSBmb3JtYXQgcmV0dXJuZWQgYnkgdGhlIEV0aGVyc2NhbiBBUEkuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgdHlwZSBkZWZpbml0b247IG9ubHkgdGhlIHByb3BlcnRpZXMgd2UgdXNlIGFyZSBkZWZpbmVkXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJzY2FuVHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBibG9ja051bWJlciAtIFRoZSBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGZvdW5kIGluLCBpbiBkZWNpbWFsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnJvbSAtIFRoZSBoZXgtcHJlZml4ZWQgYWRkcmVzcyBvZiB0aGUgc2VuZGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzIC0gVGhlIGdhcyBsaW1pdCwgaW4gZGVjaW1hbCBHV0VJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dhc1ByaWNlXSAtIFRoZSBnYXMgcHJpY2UsIGluIGRlY2ltYWwgV0VJXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heEZlZVBlckdhc10gLSBUaGUgbWF4aW11bSBmZWUgcGVyIGdhcywgaW5jbHVzaXZlIG9mIHRpcCwgaW4gZGVjaW1hbCBXRUlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWF4UHJpb3JpdHlGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gdGlwIHBlciBnYXMgaW4gZGVjaW1hbCBXRUlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoIC0gVGhlIGhleC1wcmVmaXhlZCB0cmFuc2FjdGlvbiBoYXNoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaXNFcnJvciAtIFdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgb3IgZmFpbGVkICgwIGZvciBjb25maXJtZWQsIDEgZm9yIGZhaWxlZClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBub25jZSAtIFRoZSB0cmFuc2FjdGlvbiBub25jZSwgaW4gZGVjaW1hbFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVTdGFtcCAtIFRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbiwgaW4gc2Vjb25kc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHRvIC0gVGhlIGhleC1wcmVmaXhlZCBhZGRyZXNzIG9mIHRoZSByZWNpcGllbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBhbW91bnQgb2YgRVRIIHNlbnQgaW4gdGhpcyB0cmFuc2FjdGlvbiwgaW4gZGVjaW1hbCBXRUlcbiAqL1xuXG4vKipcbiAqIFRoaXMgY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZyBpbmNvbWluZyB0cmFuc2FjdGlvbnMuIEV0aGVyc2NhbiBpcyBwb2xsZWQgb25jZSBldmVyeSBibG9jayB0byBjaGVja1xuICogZm9yIG5ldyBpbmNvbWluZyB0cmFuc2FjdGlvbnMgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGVkIGFjY291bnQgb24gdGhlIGN1cnJlbnQgbmV0d29ya1xuICpcbiAqIE5vdGUgdGhhdCBvbmx5IHRoZSBidWlsdC1pbiBJbmZ1cmEgbmV0d29ya3MgYXJlIHN1cHBvcnRlZCAoaS5lLiBhbnl0aGluZyBpbiBgSU5GVVJBX1BST1ZJREVSX1RZUEVTYCkuIFdlIHdpbGwgbm90XG4gKiBhdHRlbXB0IHRvIHJldHJpZXZlIGluY29taW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgY3VzdG9tIFJQQyBlbmRwb2ludHMuXG4gKi9cbmNvbnN0IGV0aGVyc2NhblN1cHBvcnRlZE5ldHdvcmtzID0gW1xuICBHT0VSTElfQ0hBSU5fSUQsXG4gIEtPVkFOX0NIQUlOX0lELFxuICBNQUlOTkVUX0NIQUlOX0lELFxuICBSSU5LRUJZX0NIQUlOX0lELFxuICBST1BTVEVOX0NIQUlOX0lELFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tUcmFja2VyLFxuICAgICAgb25OZXR3b3JrRGlkQ2hhbmdlLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgfSA9IG9wdHM7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPSBibG9ja1RyYWNrZXI7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gcHJlZmVyZW5jZXNDb250cm9sbGVyO1xuXG4gICAgdGhpcy5fb25MYXRlc3RCbG9jayA9IGFzeW5jIChuZXdCbG9ja051bWJlckhleCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICBjb25zdCBuZXdCbG9ja051bWJlckRlYyA9IHBhcnNlSW50KG5ld0Jsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGUoc2VsZWN0ZWRBZGRyZXNzLCBuZXdCbG9ja051bWJlckRlYyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGluY29taW5nVHJhbnNhY3Rpb25zOiB7fSxcbiAgICAgIGluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkOiB7XG4gICAgICAgIFtHT0VSTElfQ0hBSU5fSURdOiBudWxsLFxuICAgICAgICBbS09WQU5fQ0hBSU5fSURdOiBudWxsLFxuICAgICAgICBbTUFJTk5FVF9DSEFJTl9JRF06IG51bGwsXG4gICAgICAgIFtSSU5LRUJZX0NIQUlOX0lEXTogbnVsbCxcbiAgICAgICAgW1JPUFNURU5fQ0hBSU5fSURdOiBudWxsLFxuICAgICAgfSxcbiAgICAgIC4uLm9wdHMuaW5pdFN0YXRlLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShcbiAgICAgIHByZXZpb3VzVmFsdWVDb21wYXJhdG9yKChwcmV2U3RhdGUsIGN1cnJTdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgICAgICBzaG93SW5jb21pbmdUcmFuc2FjdGlvbnM6IHByZXZTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgfSA9IHt9LFxuICAgICAgICB9ID0gcHJldlN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgICAgICBzaG93SW5jb21pbmdUcmFuc2FjdGlvbnM6IGN1cnJTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgfSA9IHt9LFxuICAgICAgICB9ID0gY3VyclN0YXRlO1xuXG4gICAgICAgIGlmIChjdXJyU2hvd0luY29taW5nVHJhbnNhY3Rpb25zID09PSBwcmV2U2hvd0luY29taW5nVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMgJiYgIWN1cnJTaG93SW5jb21pbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9LCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpKSxcbiAgICApO1xuXG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKFxuICAgICAgcHJldmlvdXNWYWx1ZUNvbXBhcmF0b3IoYXN5bmMgKHByZXZTdGF0ZSwgY3VyclN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzOiBwcmV2U2VsZWN0ZWRBZGRyZXNzIH0gPSBwcmV2U3RhdGU7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzOiBjdXJyU2VsZWN0ZWRBZGRyZXNzIH0gPSBjdXJyU3RhdGU7XG5cbiAgICAgICAgaWYgKGN1cnJTZWxlY3RlZEFkZHJlc3MgPT09IHByZXZTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlKGN1cnJTZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgfSwgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKSksXG4gICAgKTtcblxuICAgIG9uTmV0d29ya0RpZENoYW5nZShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGUoYWRkcmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBjb25zdCB7IGZlYXR1cmVGbGFncyA9IHt9IH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgc2hvd0luY29taW5nVHJhbnNhY3Rpb25zIH0gPSBmZWF0dXJlRmxhZ3M7XG5cbiAgICBpZiAoIXNob3dJbmNvbWluZ1RyYW5zYWN0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl9vbkxhdGVzdEJsb2NrKTtcbiAgICB0aGlzLmJsb2NrVHJhY2tlci5hZGRMaXN0ZW5lcignbGF0ZXN0JywgdGhpcy5fb25MYXRlc3RCbG9jayk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuYmxvY2tUcmFja2VyLnJlbW92ZUxpc3RlbmVyKCdsYXRlc3QnLCB0aGlzLl9vbkxhdGVzdEJsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBjb3JyZWN0IGJsb2NrIG51bWJlciB0byBiZWdpbiBsb29raW5nIGZvciBuZXcgdHJhbnNhY3Rpb25zXG4gICAqIGZyb20sIGZldGNoZXMgdGhlIHRyYW5zYWN0aW9ucyBhbmQgdGhlbiBzYXZlcyB0aGVtIGFuZCB0aGUgbmV4dCBibG9ja1xuICAgKiBudW1iZXIgdG8gYmVnaW4gZmV0Y2hpbmcgZnJvbSBpbiBzdGF0ZS4gQmxvY2sgbnVtYmVycyBhbmQgdHJhbnNhY3Rpb25zIGFyZVxuICAgKiBzdG9yZWQgcGVyIGNoYWluSWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gYWRkcmVzcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW25ld0Jsb2NrTnVtYmVyRGVjXSAtIGJsb2NrIG51bWJlciB0byBiZWdpbiBmZXRjaGluZyBmcm9tXG4gICAqL1xuICBhc3luYyBfdXBkYXRlKGFkZHJlc3MsIG5ld0Jsb2NrTnVtYmVyRGVjKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBpZiAoIWV0aGVyc2NhblN1cHBvcnRlZE5ldHdvcmtzLmluY2x1ZGVzKGNoYWluSWQpIHx8ICFhZGRyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBjdXJyZW50QmxvY2sgPSBwYXJzZUludCh0aGlzLmJsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKSwgMTYpO1xuXG4gICAgICBjb25zdCBtb3N0UmVjZW50bHlGZXRjaGVkQmxvY2sgPVxuICAgICAgICBjdXJyZW50U3RhdGUuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWRbY2hhaW5JZF07XG4gICAgICBjb25zdCBibG9ja1RvRmV0Y2hGcm9tID1cbiAgICAgICAgbW9zdFJlY2VudGx5RmV0Y2hlZEJsb2NrID8/IG5ld0Jsb2NrTnVtYmVyRGVjID8/IGN1cnJlbnRCbG9jaztcblxuICAgICAgY29uc3QgbmV3SW5jb21pbmdUeHMgPSBhd2FpdCB0aGlzLl9nZXROZXdJbmNvbWluZ1RyYW5zYWN0aW9ucyhcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmxvY2tUb0ZldGNoRnJvbSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICk7XG5cbiAgICAgIGxldCBuZXdNb3N0UmVjZW50bHlGZXRjaGVkQmxvY2sgPSBibG9ja1RvRmV0Y2hGcm9tO1xuXG4gICAgICBuZXdJbmNvbWluZ1R4cy5mb3JFYWNoKCh0eCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHguYmxvY2tOdW1iZXIgJiZcbiAgICAgICAgICBwYXJzZUludChuZXdNb3N0UmVjZW50bHlGZXRjaGVkQmxvY2ssIDEwKSA8XG4gICAgICAgICAgICBwYXJzZUludCh0eC5ibG9ja051bWJlciwgMTApXG4gICAgICAgICkge1xuICAgICAgICAgIG5ld01vc3RSZWNlbnRseUZldGNoZWRCbG9jayA9IHBhcnNlSW50KHR4LmJsb2NrTnVtYmVyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQ6IHtcbiAgICAgICAgICAuLi5jdXJyZW50U3RhdGUuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQsXG4gICAgICAgICAgW2NoYWluSWRdOiBuZXdNb3N0UmVjZW50bHlGZXRjaGVkQmxvY2sgKyAxLFxuICAgICAgICB9LFxuICAgICAgICBpbmNvbWluZ1RyYW5zYWN0aW9uczogbmV3SW5jb21pbmdUeHMucmVkdWNlKFxuICAgICAgICAgICh0cmFuc2FjdGlvbnMsIHR4KSA9PiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnNbdHguaGFzaF0gPSB0eDtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbnM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U3RhdGUuaW5jb21pbmdUcmFuc2FjdGlvbnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGZldGNoZXMgdHJhbnNhY3Rpb25zIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcyBhbmQgY2hhaW4sIHZpYSBldGhlcnNjYW4sIHRoZW5cbiAgICogcHJvY2Vzc2VzIHRoZSBkYXRhIGludG8gdGhlIG5lY2Vzc2FyeSBzaGFwZSBmb3IgdXNhZ2UgaW4gdGhpcyBjb250cm9sbGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FkZHJlc3NdIC0gQWRkcmVzcyB0byBmZXRjaCB0cmFuc2FjdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUJsb2NrXSAtIEJsb2NrIHRvIGxvb2sgZm9yIHRyYW5zYWN0aW9ucyBhdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYWluSWRdIC0gVGhlIGNoYWluSWQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfVxuICAgKi9cbiAgYXN5bmMgX2dldE5ld0luY29taW5nVHJhbnNhY3Rpb25zKGFkZHJlc3MsIGZyb21CbG9jaywgY2hhaW5JZCkge1xuICAgIGNvbnN0IGV0aGVyc2NhblN1YmRvbWFpbiA9XG4gICAgICBjaGFpbklkID09PSBNQUlOTkVUX0NIQUlOX0lEXG4gICAgICAgID8gJ2FwaSdcbiAgICAgICAgOiBgYXBpLSR7Q0hBSU5fSURfVE9fVFlQRV9NQVBbY2hhaW5JZF19YDtcblxuICAgIGNvbnN0IGFwaVVybCA9IGBodHRwczovLyR7ZXRoZXJzY2FuU3ViZG9tYWlufS5ldGhlcnNjYW4uaW9gO1xuICAgIGxldCB1cmwgPSBgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MWA7XG5cbiAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICB1cmwgKz0gYCZzdGFydEJsb2NrPSR7cGFyc2VJbnQoZnJvbUJsb2NrLCAxMCl9YDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KHVybCk7XG4gICAgY29uc3QgeyBzdGF0dXMsIHJlc3VsdCB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGxldCBuZXdJbmNvbWluZ1R4cyA9IFtdO1xuICAgIGlmIChzdGF0dXMgPT09ICcxJyAmJiBBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlbW90ZVR4TGlzdCA9IHt9O1xuICAgICAgY29uc3QgcmVtb3RlVHhzID0gW107XG4gICAgICByZXN1bHQuZm9yRWFjaCgodHgpID0+IHtcbiAgICAgICAgaWYgKCFyZW1vdGVUeExpc3RbdHguaGFzaF0pIHtcbiAgICAgICAgICByZW1vdGVUeHMucHVzaCh0aGlzLl9ub3JtYWxpemVUeEZyb21FdGhlcnNjYW4odHgsIGNoYWluSWQpKTtcbiAgICAgICAgICByZW1vdGVUeExpc3RbdHguaGFzaF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbmV3SW5jb21pbmdUeHMgPSByZW1vdGVUeHMuZmlsdGVyKFxuICAgICAgICAodHgpID0+IHR4LnR4UGFyYW1zPy50bz8udG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgKTtcbiAgICAgIG5ld0luY29taW5nVHhzLnNvcnQoKGEsIGIpID0+IChhLnRpbWUgPCBiLnRpbWUgPyAtMSA6IDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0luY29taW5nVHhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbXV0ZXMgYSBFdGhlcnNjYW5UcmFuc2FjdGlvbiBpbnRvIGEgVHJhbnNhY3Rpb25NZXRhXG4gICAqXG4gICAqIEBwYXJhbSB7RXRoZXJzY2FuVHJhbnNhY3Rpb259IGV0aGVyc2NhblRyYW5zYWN0aW9uIC0gdGhlIHRyYW5zYWN0aW9uIHRvIG5vcm1hbGl6ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YX1cbiAgICovXG4gIF9ub3JtYWxpemVUeEZyb21FdGhlcnNjYW4oZXRoZXJzY2FuVHJhbnNhY3Rpb24sIGNoYWluSWQpIHtcbiAgICBjb25zdCB0aW1lID0gcGFyc2VJbnQoZXRoZXJzY2FuVHJhbnNhY3Rpb24udGltZVN0YW1wLCAxMCkgKiAxMDAwO1xuICAgIGNvbnN0IHN0YXR1cyA9XG4gICAgICBldGhlcnNjYW5UcmFuc2FjdGlvbi5pc0Vycm9yID09PSAnMCdcbiAgICAgICAgPyBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRURcbiAgICAgICAgOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICBmcm9tOiBldGhlcnNjYW5UcmFuc2FjdGlvbi5mcm9tLFxuICAgICAgZ2FzOiBiblRvSGV4KG5ldyBCTihldGhlcnNjYW5UcmFuc2FjdGlvbi5nYXMpKSxcbiAgICAgIG5vbmNlOiBiblRvSGV4KG5ldyBCTihldGhlcnNjYW5UcmFuc2FjdGlvbi5ub25jZSkpLFxuICAgICAgdG86IGV0aGVyc2NhblRyYW5zYWN0aW9uLnRvLFxuICAgICAgdmFsdWU6IGJuVG9IZXgobmV3IEJOKGV0aGVyc2NhblRyYW5zYWN0aW9uLnZhbHVlKSksXG4gICAgfTtcblxuICAgIGlmIChldGhlcnNjYW5UcmFuc2FjdGlvbi5nYXNQcmljZSkge1xuICAgICAgdHhQYXJhbXMuZ2FzUHJpY2UgPSBiblRvSGV4KG5ldyBCTihldGhlcnNjYW5UcmFuc2FjdGlvbi5nYXNQcmljZSkpO1xuICAgIH0gZWxzZSBpZiAoZXRoZXJzY2FuVHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKSB7XG4gICAgICB0eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSBiblRvSGV4KFxuICAgICAgICBuZXcgQk4oZXRoZXJzY2FuVHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKSxcbiAgICAgICk7XG4gICAgICB0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGJuVG9IZXgoXG4gICAgICAgIG5ldyBCTihldGhlcnNjYW5UcmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBibG9ja051bWJlcjogZXRoZXJzY2FuVHJhbnNhY3Rpb24uYmxvY2tOdW1iZXIsXG4gICAgICBpZDogY3JlYXRlSWQoKSxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtZXRhbWFza05ldHdvcmtJZDogQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbY2hhaW5JZF0sXG4gICAgICBzdGF0dXMsXG4gICAgICB0aW1lLFxuICAgICAgdHhQYXJhbXMsXG4gICAgICBoYXNoOiBldGhlcnNjYW5UcmFuc2FjdGlvbi5oYXNoLFxuICAgICAgdHlwZTogVFJBTlNBQ1RJT05fVFlQRVMuSU5DT01JTkcsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGFyaXR5IDEgdGhhdCBjYWNoZXMgdGhlIGFyZ3VtZW50IHRoYXQgdGhlIGZ1bmN0aW9uXG4gKiBpcyBjYWxsZWQgd2l0aCBhbmQgaW52b2tlcyB0aGUgY29tcGFyYXRvciB3aXRoIGJvdGggdGhlIGNhY2hlZCwgcHJldmlvdXMsXG4gKiB2YWx1ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUuIElmIHNwZWNpZmllZCwgdGhlIGluaXRpYWxWYWx1ZSB3aWxsIGJlIHBhc3NlZFxuICogaW4gYXMgdGhlIHByZXZpb3VzIHZhbHVlIG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSByZXR1cm5lZCBtZXRob2QuXG4gKlxuICogQHRlbXBsYXRlIEEgLSBUaGUgdHlwZSBvZiB0aGUgY29tcGFyZWQgdmFsdWUuXG4gKiBAcGFyYW0geyhwcmV2VmFsdWU6IEEsIG5leHRWYWx1ZTogQSkgPT4gdm9pZH0gY29tcGFyYXRvciAtIEEgbWV0aG9kIHRvIGNvbXBhcmVcbiAqIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0F9IFtpbml0aWFsVmFsdWVdIC0gVGhlIGluaXRpYWwgdmFsdWUgdG8gc3VwcGx5IHRvIHByZXZWYWx1ZVxuICogb24gZmlyc3QgY2FsbCBvZiB0aGUgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBwcmV2aW91c1ZhbHVlQ29tcGFyYXRvcihjb21wYXJhdG9yLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGNhY2hlO1xuICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihpbml0aWFsVmFsdWUgPz8gdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYXJhdG9yKGNhY2hlLCB2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNhY2hlID0gdmFsdWU7XG4gICAgfVxuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pZFJlbWFwTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlQXN5bmNNaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldFVuaXF1ZUlkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Kc29uUnBjRW5naW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXJnZU1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOXpjbU12YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3TzBGQlFVRXNjMFJCUVc5RE8wRkJRM0JETERCRVFVRjNRenRCUVVONFF5dzJSRUZCTWtNN1FVRkRNME1zWjBSQlFUaENPMEZCUXpsQ0xHdEVRVUZuUXp0QlFVTm9ReXh2UkVGQmEwTWlmUT09IiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgc3RyaWN0IGFzIGFzc2VydCB9IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCB7IHR5cGVkU2lnbmF0dXJlSGFzaCwgVFlQRURfTUVTU0FHRV9TQ0hFTUEgfSBmcm9tICdldGgtc2lnLXV0aWwnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQganNvbnNjaGVtYSBmcm9tICdqc29uc2NoZW1hJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcbmltcG9ydCB7IGlzVmFsaWRIZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzLCBhbmQgY29udGFpbnMgZGF0YSBhYm91dCwgYW4gJ2V0aF9zaWduVHlwZWREYXRhJyB0eXBlIHNpZ25hdHVyZSByZXF1ZXN0LiBUaGVzZSBhcmUgY3JlYXRlZCB3aGVuIGFcbiAqIHNpZ25hdHVyZSBmb3IgYW4gZXRoX3NpZ25UeXBlZERhdGEgY2FsbCBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVHlwZWRNZXNzYWdlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgQW4gaWQgdG8gdHJhY2sgYW5kIGlkZW50aWZ5IHRoZSBtZXNzYWdlIG9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcyBUaGUgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBldGhfc2lnblR5cGVkRGF0YSBtZXRob2Qgb25jZSB0aGUgc2lnbmF0dXJlIHJlcXVlc3QgaXNcbiAqIGFwcHJvdmVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIEFkZGVkIHRvIG1zZ1BhcmFtcyBmb3IgdHJhY2tpbmcgYW5kIGlkZW50aWZpY2F0aW9uIHdpdGhpbiBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtc2dQYXJhbXMuZnJvbSBUaGUgYWRkcmVzcyB0aGF0IGlzIG1ha2luZyB0aGUgc2lnbmF0dXJlIHJlcXVlc3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbXNnUGFyYW1zLmRhdGEgQSBoZXggc3RyaW5nIGNvbnZlcnNpb24gb2YgdGhlIHJhdyBidWZmZXIgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoZSB0aGlzIG1lc3NhZ2Ugd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0dXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSByZXF1ZXN0IGlzICd1bmFwcHJvdmVkJywgJ2FwcHJvdmVkJywgJ3NpZ25lZCcsICdyZWplY3RlZCcsIG9yICdlcnJvcmVkJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGpzb24tcHJjIHNpZ25pbmcgbWV0aG9kIGZvciB3aGljaCBhIHNpZ25hdHVyZSByZXF1ZXN0IGhhcyBiZWVuIG1hZGUuIEEgJ01lc3NhZ2UnIHdpbGxcbiAqIGFsd2F5cyBoYXZlIGEgJ2V0aF9zaWduVHlwZWREYXRhJyB0eXBlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIFR5cGVkTWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q3VycmVudENoYWluSWRcbiAgICogQHBhcmFtIG9wdGlvbnMubWV0cmljc0V2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGdldEN1cnJlbnRDaGFpbklkLCBtZXRyaWNzRXZlbnQgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZ2V0Q3VycmVudENoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZDtcbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlczoge30sXG4gICAgICB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlc0NvdW50OiAwLFxuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLm1ldHJpY3NFdmVudCA9IG1ldHJpY3NFdmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIG51bWJlciBvZiAndW5hcHByb3ZlZCcgVHlwZWRNZXNzYWdlcyBpbiB0aGlzLm1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIFR5cGVkTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgZ2V0IHVuYXBwcm92ZWRUeXBlZE1lc3NhZ2VzQ291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKSkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgJ3VuYXBwcm92ZWQnIFR5cGVkTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBpbmRleCBvZiBUeXBlZE1lc3NhZ2UgaWRzIHRvIFR5cGVkTWVzc2FnZXMsIGZvciBhbGwgJ3VuYXBwcm92ZWQnIFR5cGVkTWVzc2FnZXMgaW5cbiAgICogdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgZ2V0VW5hcHByb3ZlZE1zZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXNcbiAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyA9PT0gJ3VuYXBwcm92ZWQnKVxuICAgICAgLnJlZHVjZSgocmVzdWx0LCBtc2cpID0+IHtcbiAgICAgICAgcmVzdWx0W21zZy5pZF0gPSBtc2c7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUeXBlZE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbXNnUGFyYW1zLiB0aGlzLmFkZE1zZyBpcyBjYWxsZWQgdG8gYWRkXG4gICAqIHRoZSBuZXcgVHlwZWRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIFR5cGVkTWVzc2FnZXMgZnJvbSB0aGF0IGxpc3QgdG9cbiAgICogdGhpcy5tZW1TdG9yZS4gQmVmb3JlIGFueSBvZiB0aGlzIGlzIGRvbmUsIG1zZ1BhcmFtcyBhcmUgdmFsaWRhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqIEByZXR1cm5zIHtwcm9taXNlfSBXaGVuIHRoZSBtZXNzYWdlIGhhcyBiZWVuIHNpZ25lZCBvciByZWplY3RlZFxuICAgKi9cbiAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBtc2dJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgICAgdGhpcy5vbmNlKGAke21zZ0lkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSAnZXJyb3JlZCc6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiAke2RhdGEuZXJyb3J9YCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtc2dQYXJhbXMsXG4gICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUeXBlZE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbXNnUGFyYW1zLiB0aGlzLmFkZE1zZyBpcyBjYWxsZWQgdG8gYWRkXG4gICAqIHRoZSBuZXcgVHlwZWRNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIFR5cGVkTWVzc2FnZXMgZnJvbSB0aGF0IGxpc3QgdG9cbiAgICogdGhpcy5tZW1TdG9yZS4gQmVmb3JlIGFueSBvZiB0aGlzIGlzIGRvbmUsIG1zZ1BhcmFtcyBhcmUgdmFsaWRhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBUeXBlZE1lc3NhZ2UuXG4gICAqL1xuICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbikge1xuICAgIG1zZ1BhcmFtcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBpZiAocmVxKSB7XG4gICAgICBtc2dQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZVBhcmFtcyhtc2dQYXJhbXMpO1xuXG4gICAgbG9nLmRlYnVnKFxuICAgICAgYFR5cGVkTWVzc2FnZU1hbmFnZXIgYWRkVW5hcHByb3ZlZE1lc3NhZ2U6ICR7SlNPTi5zdHJpbmdpZnkobXNnUGFyYW1zKX1gLFxuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgdHhEYXRhIG9iaiB3aXRoIHBhcmFtZXRlcnMgYW5kIG1ldGEgZGF0YVxuICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBtc2dJZCA9IGNyZWF0ZUlkKCk7XG4gICAgY29uc3QgbXNnRGF0YSA9IHtcbiAgICAgIGlkOiBtc2dJZCxcbiAgICAgIG1zZ1BhcmFtcyxcbiAgICAgIHRpbWUsXG4gICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgIHR5cGU6IE1FU1NBR0VfVFlQRS5FVEhfU0lHTl9UWVBFRF9EQVRBLFxuICAgIH07XG4gICAgdGhpcy5hZGRNc2cobXNnRGF0YSk7XG5cbiAgICAvLyBzaWduYWwgdXBkYXRlXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgICByZXR1cm4gbXNnSWQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZS4gVmFsaWRhdGVzIHRoYXQgdGhlIHBhc3NlZCBwYXJhbXMgaGF2ZSB0aGUgcmVxdWlyZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbXMgdG8gdmFsaWRhdGVcbiAgICovXG4gIHZhbGlkYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGFzc2VydC5vayhcbiAgICAgIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JyxcbiAgICAgICdQYXJhbXMgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICApO1xuICAgIGFzc2VydC5vaygnZGF0YScgaW4gcGFyYW1zLCAnUGFyYW1zIG11c3QgaW5jbHVkZSBhIFwiZGF0YVwiIGZpZWxkLicpO1xuICAgIGFzc2VydC5vaygnZnJvbScgaW4gcGFyYW1zLCAnUGFyYW1zIG11c3QgaW5jbHVkZSBhIFwiZnJvbVwiIGZpZWxkLicpO1xuICAgIGFzc2VydC5vayhcbiAgICAgIHR5cGVvZiBwYXJhbXMuZnJvbSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgaXNWYWxpZEhleEFkZHJlc3MocGFyYW1zLmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSksXG4gICAgICAnXCJmcm9tXCIgZmllbGQgbXVzdCBiZSBhIHZhbGlkLCBsb3dlcmNhc2UsIGhleGFkZWNpbWFsIEV0aGVyZXVtIGFkZHJlc3Mgc3RyaW5nLicsXG4gICAgKTtcblxuICAgIHN3aXRjaCAocGFyYW1zLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ1YxJzpcbiAgICAgICAgYXNzZXJ0Lm9rKFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyYW1zLmRhdGEpLFxuICAgICAgICAgICdcInBhcmFtcy5kYXRhXCIgbXVzdCBiZSBhbiBhcnJheS4nLFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuZG9lc05vdFRocm93KCgpID0+IHtcbiAgICAgICAgICB0eXBlZFNpZ25hdHVyZUhhc2gocGFyYW1zLmRhdGEpO1xuICAgICAgICB9LCAnU2lnbmluZyBkYXRhIG11c3QgYmUgdmFsaWQgRUlQLTcxMiB0eXBlZCBkYXRhLicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1YzJzpcbiAgICAgIGNhc2UgJ1Y0Jzoge1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgdHlwZW9mIHBhcmFtcy5kYXRhLFxuICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICdcInBhcmFtcy5kYXRhXCIgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICApO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdygoKSA9PiB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocGFyYW1zLmRhdGEpO1xuICAgICAgICB9LCAnXCJkYXRhXCIgbXVzdCBiZSBhIHZhbGlkIEpTT04gc3RyaW5nLicpO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0ganNvbnNjaGVtYS52YWxpZGF0ZShkYXRhLCBUWVBFRF9NRVNTQUdFX1NDSEVNQSk7XG4gICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICBkYXRhLnByaW1hcnlUeXBlIGluIGRhdGEudHlwZXMsXG4gICAgICAgICAgYFByaW1hcnkgdHlwZSBvZiBcIiR7ZGF0YS5wcmltYXJ5VHlwZX1cIiBoYXMgbm8gdHlwZSBkZWZpbml0aW9uLmAsXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICB2YWxpZGF0aW9uLmVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAnU2lnbmluZyBkYXRhIG11c3QgY29uZm9ybSB0byBFSVAtNzEyIHNjaGVtYS4gU2VlIGh0dHBzOi8vZ2l0LmlvL2ZOdGN4LicsXG4gICAgICAgICk7XG4gICAgICAgIGxldCB7IGNoYWluSWQgfSA9IGRhdGEuZG9tYWluO1xuICAgICAgICBpZiAoY2hhaW5JZCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNoYWluSWQgPSBwYXJzZUludCh0aGlzLl9nZXRDdXJyZW50Q2hhaW5JZCgpLCAxNik7XG4gICAgICAgICAgYXNzZXJ0Lm9rKFxuICAgICAgICAgICAgIU51bWJlci5pc05hTihhY3RpdmVDaGFpbklkKSxcbiAgICAgICAgICAgIGBDYW5ub3Qgc2lnbiBtZXNzYWdlcyBmb3IgY2hhaW5JZCBcIiR7Y2hhaW5JZH1cIiwgYmVjYXVzZSBNZXRhTWFzayBpcyBzd2l0Y2hpbmcgbmV0d29ya3MuYCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hhaW5JZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkLCBjaGFpbklkLnN0YXJ0c1dpdGgoJzB4JykgPyAxNiA6IDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGFjdGl2ZUNoYWluSWQsXG4gICAgICAgICAgICBgUHJvdmlkZWQgY2hhaW5JZCBcIiR7Y2hhaW5JZH1cIiBtdXN0IG1hdGNoIHRoZSBhY3RpdmUgY2hhaW5JZCBcIiR7YWN0aXZlQ2hhaW5JZH1cImAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydC5mYWlsKGBVbmtub3duIHR5cGVkIGRhdGEgdmVyc2lvbiBcIiR7cGFyYW1zLnZlcnNpb259XCJgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHBhc3NlZCBUeXBlZE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIGNhbGxzIHRoaXMuX3NhdmVNc2dMaXN0KCkgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzIGZyb20gdGhhdFxuICAgKiBsaXN0IHRvIHRoaXMubWVtU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbXNnIC0gVGhlIFR5cGVkTWVzc2FnZSB0byBhZGQgdG8gdGhpcy5tZXNzYWdlc1xuICAgKi9cbiAgYWRkTXNnKG1zZykge1xuICAgIHRoaXMubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIHRoaXMuX3NhdmVNc2dMaXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBUeXBlZE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGdldFxuICAgKiBAcmV0dXJucyB7VHlwZWRNZXNzYWdlfHVuZGVmaW5lZH0gVGhlIFR5cGVkTWVzc2FnZSB3aXRoIHRoZSBpZCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBtc2dJZCwgb3IgdW5kZWZpbmVkXG4gICAqIGlmIG5vIFR5cGVkTWVzc2FnZSBoYXMgdGhhdCBpZC5cbiAgICovXG4gIGdldE1zZyhtc2dJZCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbmQoKG1zZykgPT4gbXNnLmlkID09PSBtc2dJZCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwcm92ZXMgYSBUeXBlZE1lc3NhZ2UuIFNldHMgdGhlIG1lc3NhZ2Ugc3RhdHVzIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNc2dTdGF0dXNBcHByb3ZlZCwgYW5kIHJldHVybnMgYSBwcm9taXNlXG4gICAqIHdpdGggYW55IHRoZSBtZXNzYWdlIHBhcmFtcyBtb2RpZmllZCBmb3IgcHJvcGVyIHNpZ25pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgbXNnUGFyYW1zIHRvIGJlIHVzZWQgd2hlbiBldGhfc2lnbiBpcyBjYWxsZWQsIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFzay5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcy5tZXRhbWFza0lkIC0gQWRkZWQgdG8gbXNnUGFyYW1zIGZvciB0cmFja2luZyBhbmQgaWRlbnRpZmljYXRpb24gd2l0aGluIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBQcm9taXNlcyB0aGUgbXNnUGFyYW1zIG9iamVjdCB3aXRoIG1ldGFtYXNrSWQgcmVtb3ZlZC5cbiAgICovXG4gIGFwcHJvdmVNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIHRoaXMuc2V0TXNnU3RhdHVzQXBwcm92ZWQobXNnUGFyYW1zLm1ldGFtYXNrSWQpO1xuICAgIHJldHVybiB0aGlzLnByZXBNc2dGb3JTaWduaW5nKG1zZ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gYXBwcm92ZS5cbiAgICovXG4gIHNldE1zZ1N0YXR1c0FwcHJvdmVkKG1zZ0lkKSB7XG4gICAgdGhpcy5fc2V0TXNnU3RhdHVzKG1zZ0lkLCAnYXBwcm92ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIHN0YXR1cyB0byAnc2lnbmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cyBhbmQgdXBkYXRlcyB0aGF0IFR5cGVkTWVzc2FnZSBpblxuICAgKiB0aGlzLm1lc3NhZ2VzIGJ5IGFkZGluZyB0aGUgcmF3IHNpZ25hdHVyZSBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdCB0byB0aGUgVHlwZWRNZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7YnVmZmVyfSByYXdTaWcgLSBUaGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0XG4gICAqL1xuICBzZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHJhd1NpZykge1xuICAgIGNvbnN0IG1zZyA9IHRoaXMuZ2V0TXNnKG1zZ0lkKTtcbiAgICBtc2cucmF3U2lnID0gcmF3U2lnO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ3NpZ25lZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbXNnUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0aGUgdXBkYXRlZCBtc2dQYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtc2dQYXJhbXMgdG8gbW9kaWZ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIHRoZSBtc2dQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkXG4gICAqL1xuICBwcmVwTXNnRm9yU2lnbmluZyhtc2dQYXJhbXMpIHtcbiAgICBkZWxldGUgbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgZGVsZXRlIG1zZ1BhcmFtcy52ZXJzaW9uO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIHN0YXR1cyB0byAncmVqZWN0ZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5fc2V0TXNnU3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFR5cGVkTWVzc2FnZSB0byByZWplY3QuXG4gICAqIEBwYXJhbSByZWFzb25cbiAgICovXG4gIHJlamVjdE1zZyhtc2dJZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgICAgdGhpcy5tZXRyaWNzRXZlbnQoe1xuICAgICAgICBldmVudDogcmVhc29uLFxuICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBhY3Rpb246ICdTaWduIFJlcXVlc3QnLFxuICAgICAgICAgIHZlcnNpb246IG1zZy5tc2dQYXJhbXMudmVyc2lvbixcbiAgICAgICAgICB0eXBlOiBtc2cudHlwZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zZXRNc2dTdGF0dXMobXNnSWQsICdyZWplY3RlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBUeXBlZE1lc3NhZ2Ugc3RhdHVzIHRvICdlcnJvcmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuX3NldE1zZ1N0YXR1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1zZ0lkIC0gVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gZXJyb3JcbiAgICogQHBhcmFtIGVycm9yXG4gICAqL1xuICBlcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKSB7XG4gICAgY29uc3QgbXNnID0gdGhpcy5nZXRNc2cobXNnSWQpO1xuICAgIG1zZy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuX3VwZGF0ZU1zZyhtc2cpO1xuICAgIHRoaXMuX3NldE1zZ1N0YXR1cyhtc2dJZCwgJ2Vycm9yZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIHVuYXBwcm92ZWQgbWVzc2FnZXMgZnJvbSBtZW1vcnkuXG4gICAqL1xuICBjbGVhclVuYXBwcm92ZWQoKSB7XG4gICAgdGhpcy5tZXNzYWdlcyA9IHRoaXMubWVzc2FnZXMuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgIT09ICd1bmFwcHJvdmVkJyk7XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgYSBUeXBlZE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyB2aWEgYSBjYWxsIHRvIHRoaXMuX3VwZGF0ZU1zZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIFR5cGVkTWVzc2FnZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgLSBUaGUgbmV3IHN0YXR1cyBvZiB0aGUgVHlwZWRNZXNzYWdlLlxuICAgKiBAdGhyb3dzIEEgJ1R5cGVkTWVzc2FnZU1hbmFnZXIgLSBUeXBlZE1lc3NhZ2Ugbm90IGZvdW5kIGZvciBpZDogXCIke21zZ0lkfVwiLicgaWYgdGhlcmUgaXMgbm8gVHlwZWRNZXNzYWdlXG4gICAqIGluIHRoaXMubWVzc2FnZXMgd2l0aCBhbiBpZCBlcXVhbCB0byB0aGUgcGFzc2VkIG1zZ0lkXG4gICAqIEBmaXJlcyBBbiBldmVudCB3aXRoIGEgbmFtZSBlcXVhbCB0byBgJHttc2dJZH06JHtzdGF0dXN9YC4gVGhlIFR5cGVkTWVzc2FnZSBpcyBhbHNvIGZpcmVkLlxuICAgKiBAZmlyZXMgSWYgc3RhdHVzIGlzICdyZWplY3RlZCcgb3IgJ3NpZ25lZCcsIGFuIGV2ZW50IHdpdGggYSBuYW1lIGVxdWFsIHRvIGAke21zZ0lkfTpmaW5pc2hlZGAgaXMgZmlyZWQgYWxvbmdcbiAgICogd2l0aCB0aGUgVHlwZWRNZXNzYWdlXG4gICAqL1xuICBfc2V0TXNnU3RhdHVzKG1zZ0lkLCBzdGF0dXMpIHtcbiAgICBjb25zdCBtc2cgPSB0aGlzLmdldE1zZyhtc2dJZCk7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFR5cGVkTWVzc2FnZU1hbmFnZXIgLSBNZXNzYWdlIG5vdCBmb3VuZCBmb3IgaWQ6IFwiJHttc2dJZH1cIi5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgbXNnLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLl91cGRhdGVNc2cobXNnKTtcbiAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OiR7c3RhdHVzfWAsIG1zZyk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ3JlamVjdGVkJyB8fCBzdGF0dXMgPT09ICdzaWduZWQnIHx8IHN0YXR1cyA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICB0aGlzLmVtaXQoYCR7bXNnSWR9OmZpbmlzaGVkYCwgbXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBpbiB0aGlzLm1lc3NhZ2VzIHRvIHRoZSBwYXNzZWQgVHlwZWRNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLiBUaGVuIHNhdmVzIHRoZVxuICAgKiB1bmFwcHJvdmVkVHlwZWRNc2dzIGluZGV4IHRvIHN0b3JhZ2UgdmlhIHRoaXMuX3NhdmVNc2dMaXN0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VHlwZWRNZXNzYWdlfSBtc2cgLSBBIFR5cGVkTWVzc2FnZSB0aGF0IHdpbGwgcmVwbGFjZSBhbiBleGlzdGluZyBUeXBlZE1lc3NhZ2UgKHdpdGggdGhlIHNhbWVcbiAgICogaWQpIGluIHRoaXMubWVzc2FnZXNcbiAgICovXG4gIF91cGRhdGVNc2cobXNnKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm1lc3NhZ2VzLmZpbmRJbmRleCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbXNnLmlkKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzW2luZGV4XSA9IG1zZztcbiAgICB9XG4gICAgdGhpcy5fc2F2ZU1zZ0xpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLCBhbmQgdGhlaXIgY291bnQsIHRvIHRoaXMubWVtU3RvcmVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzICd1cGRhdGVCYWRnZSdcbiAgICovXG4gIF9zYXZlTXNnTGlzdCgpIHtcbiAgICBjb25zdCB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlcyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1zZ3MoKTtcbiAgICBjb25zdCB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlc0NvdW50ID0gT2JqZWN0LmtleXModW5hcHByb3ZlZFR5cGVkTWVzc2FnZXMpXG4gICAgICAubGVuZ3RoO1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgdW5hcHByb3ZlZFR5cGVkTWVzc2FnZXMsXG4gICAgICB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlc0NvdW50LFxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICB9XG59XG4iLCJpbXBvcnQgcHVueWNvZGUgZnJvbSAncHVueWNvZGUvcHVueWNvZGUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcbmltcG9ydCBFbnMgZnJvbSAnLi9lbnMnO1xuXG5jb25zdCBaRVJPX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbmNvbnN0IFpFUk9fWF9FUlJPUl9BRERSRVNTID0gJzB4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5zQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHsgZW5zLCBwcm92aWRlciwgb25OZXR3b3JrRGlkQ2hhbmdlLCBnZXRDdXJyZW50Q2hhaW5JZCB9ID0ge30pIHtcbiAgICBjb25zdCBpbml0U3RhdGUgPSB7XG4gICAgICBlbnNSZXNvbHV0aW9uc0J5QWRkcmVzczoge30sXG4gICAgfTtcblxuICAgIHRoaXMuX2VucyA9IGVucztcbiAgICBpZiAoIXRoaXMuX2Vucykge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICBjb25zdCBuZXR3b3JrID0gQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbY2hhaW5JZF07XG4gICAgICBpZiAoRW5zLmdldE5ldHdvcmtFbnNTdXBwb3J0KG5ldHdvcmspKSB7XG4gICAgICAgIHRoaXMuX2VucyA9IG5ldyBFbnMoe1xuICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKGluaXRTdGF0ZSk7XG4gICAgb25OZXR3b3JrRGlkQ2hhbmdlKCgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUucHV0U3RhdGUoaW5pdFN0YXRlKTtcbiAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgICAgY29uc3QgbmV0d29yayA9IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW2NoYWluSWRdO1xuICAgICAgaWYgKEVucy5nZXROZXR3b3JrRW5zU3VwcG9ydChuZXR3b3JrKSkge1xuICAgICAgICB0aGlzLl9lbnMgPSBuZXcgRW5zKHtcbiAgICAgICAgICBuZXR3b3JrLFxuICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9lbnM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnNlUmVzb2x2ZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUmVzb2x2ZUFkZHJlc3ModG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpO1xuICB9XG5cbiAgYXN5bmMgX3JldmVyc2VSZXNvbHZlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9lbnMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLmVuc1Jlc29sdXRpb25zQnlBZGRyZXNzW2FkZHJlc3NdKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZW5zUmVzb2x1dGlvbnNCeUFkZHJlc3NbYWRkcmVzc107XG4gICAgfVxuXG4gICAgbGV0IGRvbWFpbjtcbiAgICB0cnkge1xuICAgICAgZG9tYWluID0gYXdhaXQgdGhpcy5fZW5zLnJldmVyc2UoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCByZWdpc3RlcmVkQWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgcmVnaXN0ZXJlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLl9lbnMubG9va3VwKGRvbWFpbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzID09PSBaRVJPX0FERFJFU1MgfHxcbiAgICAgIHJlZ2lzdGVyZWRBZGRyZXNzID09PSBaRVJPX1hfRVJST1JfQUREUkVTU1xuICAgICkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodG9DaGVja3N1bUhleEFkZHJlc3MocmVnaXN0ZXJlZEFkZHJlc3MpICE9PSBhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJlc29sdXRpb25zQnlBZGRyZXNzKGFkZHJlc3MsIHB1bnljb2RlLnRvQVNDSUkoZG9tYWluKSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuXG4gIF91cGRhdGVSZXNvbHV0aW9uc0J5QWRkcmVzcyhhZGRyZXNzLCBkb21haW4pIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnB1dFN0YXRlKHtcbiAgICAgIGVuc1Jlc29sdXRpb25zQnlBZGRyZXNzOiB7XG4gICAgICAgIC4uLm9sZFN0YXRlLmVuc1Jlc29sdXRpb25zQnlBZGRyZXNzLFxuICAgICAgICBbYWRkcmVzc106IGRvbWFpbixcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vY2F2ZWF0LW11dGF0b3JzJztcbmV4cG9ydCAqIGZyb20gJy4vYmFja2dyb3VuZC1hcGknO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL3Blcm1pc3Npb24tbG9nJztcbmV4cG9ydCAqIGZyb20gJy4vc3BlY2lmaWNhdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3RvcnMnO1xuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdzYWZlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgeyBidWZmZXJUb0hleCwga2VjY2FrLCB0b0J1ZmZlciwgaXNIZXhTdHJpbmcgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aGpzLXF1ZXJ5JztcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCBDb21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgTm9uY2VUcmFja2VyIGZyb20gJ25vbmNlLXRyYWNrZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgY2xlYW5FcnJvclN0YWNrIGZyb20gJy4uLy4uL2xpYi9jbGVhbkVycm9yU3RhY2snO1xuaW1wb3J0IHtcbiAgaGV4VG9CbixcbiAgYm5Ub0hleCxcbiAgQm5NdWx0aXBseUJ5RnJhY3Rpb24sXG4gIGFkZEhleFByZWZpeCxcbiAgZ2V0Q2hhaW5UeXBlLFxufSBmcm9tICcuLi8uLi9saWIvdXRpbCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9OT19DT05UUkFDVF9FUlJPUl9LRVkgfSBmcm9tICcuLi8uLi8uLi8uLi91aS9oZWxwZXJzL2NvbnN0YW50cy9lcnJvci1rZXlzJztcbmltcG9ydCB7IGdldFN3YXBzVG9rZW5zUmVjZWl2ZWRGcm9tVHhNZXRhIH0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvcGFnZXMvc3dhcHMvc3dhcHMudXRpbCc7XG5pbXBvcnQge1xuICBoZXhXRUlUb0RlY0dXRUksXG4gIGRlY2ltYWxUb0hleCxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvaGVscGVycy91dGlscy9jb252ZXJzaW9ucy51dGlsJztcbmltcG9ydCB7XG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxuICBUUkFOU0FDVElPTl9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMsXG4gIFRSQU5TQUNUSU9OX0VWRU5UUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFX05BTUVTIH0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvaGVscGVycy9jb25zdGFudHMvdHJhbnNhY3Rpb25zJztcbmltcG9ydCB7IE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTIH0gZnJvbSAnLi4vLi4vbWV0YW1hc2stY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBHQVNfTElNSVRTLFxuICBHQVNfRVNUSU1BVEVfVFlQRVMsXG4gIEdBU19SRUNPTU1FTkRBVElPTlMsXG4gIENVU1RPTV9HQVNfRVNUSU1BVEUsXG4gIFBSSU9SSVRZX0xFVkVMUyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgZGVjR1dFSVRvSGV4V0VJIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQge1xuICBIQVJERk9SS1MsXG4gIE1BSU5ORVQsXG4gIE5FVFdPUktfVFlQRV9SUEMsXG4gIENIQUlOX0lEX1RPX0dBU19MSU1JVF9CVUZGRVJfTUFQLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgaXNFSVAxNTU5VHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdWkvaGVscGVycy91dGlscy91dGlsJztcbmltcG9ydCBUcmFuc2FjdGlvblN0YXRlTWFuYWdlciBmcm9tICcuL3R4LXN0YXRlLW1hbmFnZXInO1xuaW1wb3J0IFR4R2FzVXRpbCBmcm9tICcuL3R4LWdhcy11dGlscyc7XG5pbXBvcnQgUGVuZGluZ1RyYW5zYWN0aW9uVHJhY2tlciBmcm9tICcuL3BlbmRpbmctdHgtdHJhY2tlcic7XG5pbXBvcnQgKiBhcyB0eFV0aWxzIGZyb20gJy4vbGliL3V0aWwnO1xuXG5jb25zdCBoc3RJbnRlcmZhY2UgPSBuZXcgZXRoZXJzLnV0aWxzLkludGVyZmFjZShhYmkpO1xuXG5jb25zdCBNQVhfTUVNU1RPUkVfVFhfTElTVF9TSVpFID0gMTAwOyAvLyBOdW1iZXIgb2YgdHJhbnNhY3Rpb25zIChieSB1bmlxdWUgbm9uY2VzKSB0byBrZWVwIGluIG1lbW9yeVxuXG5jb25zdCBTV0FQX1RSQU5TQUNUSU9OX1RZUEVTID0gW1xuICBUUkFOU0FDVElPTl9UWVBFUy5TV0FQLFxuICBUUkFOU0FDVElPTl9UWVBFUy5TV0FQX0FQUFJPVkFMLFxuXTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nKS5UcmFuc2FjdGlvbk1ldGFNZXRyaWNzRXZlbnRTdHJpbmd9IFRyYW5zYWN0aW9uTWV0YU1ldHJpY3NFdmVudFN0cmluZ1xuICovXG5cbmNvbnN0IE1FVFJJQ1NfU1RBVFVTX0ZBSUxFRCA9ICdmYWlsZWQgb24tY2hhaW4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUdhc1NldHRpbmdzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dhc10gLSBUaGUgZ2FzIGxpbWl0IHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dhc1ByaWNlXSAtIFRoZSBnYXNQcmljZSB0byB1c2UgZm9yIGEgbGVnYWN5IHRyYW5zYWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heEZlZVBlckdhc10gLSBUaGUgbWF4aW11bSBhbW91bnQgdG8gcGF5IHBlciBnYXMgb24gYVxuICogIEVJUC0xNTU5IHRyYW5zYWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heFByaW9yaXR5RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBwYWlkIGZlZVxuICogIHRvIGJlIGRpc3RyaWJ1dGVkIHRvIG1pbmVyIGluIGFuIEVJUC0xNTU5IHRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBDb250cm9sbGVyIGlzIGFuIGFnZ3JlZ2F0ZSBvZiBzdWItY29udHJvbGxlcnMgYW5kIHRyYWNrZXJzXG4gKiBjb21wb3NpbmcgdGhlbSBpbiBhIHdheSB0byBiZSBleHBvc2VkIHRvIHRoZSBtZXRhbWFzayBjb250cm9sbGVyXG4gKlxuICogLSBgdHhTdGF0ZU1hbmFnZXJcbiAqIHJlc3BvbnNpYmxlIGZvciB0aGUgc3RhdGUgb2YgYSB0cmFuc2FjdGlvbiBhbmRcbiAqIHN0b3JpbmcgdGhlIHRyYW5zYWN0aW9uXG4gKiAtIHBlbmRpbmdUeFRyYWNrZXJcbiAqIHdhdGNoaW5nIGJsb2NrcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGJlIGluY2x1ZGVcbiAqIGFuZCBlbWl0dGluZyBjb25maXJtZWQgZXZlbnRzXG4gKiAtIHR4R2FzVXRpbFxuICogZ2FzIGNhbGN1bGF0aW9ucyBhbmQgc2FmZXR5IGJ1ZmZlcmluZ1xuICogLSBub25jZVRyYWNrZXJcbiAqIGNhbGN1bGF0aW5nIG5vbmNlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5pbml0U3RhdGUgLSBpbml0aWFsIHRyYW5zYWN0aW9uIGxpc3QgZGVmYXVsdCBpcyBhbiBlbXB0eSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMubmV0d29ya1N0b3JlIC0gYW4gb2JzZXJ2YWJsZSBzdG9yZSBmb3IgbmV0d29yayBudW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJsb2NrVHJhY2tlciAtIEFuIGluc3RhbmNlIG9mIGV0aC1ibG9ja3RyYWNrZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3ZpZGVyIC0gQSBuZXR3b3JrIHByb3ZpZGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5zaWduVHJhbnNhY3Rpb24gLSBmdW5jdGlvbiB0aGUgc2lnbnMgYW4gQGV0aGVyZXVtanMvdHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmdldFBlcm1pdHRlZEFjY291bnRzIC0gZ2V0IGFjY291bnRzIHRoYXQgYW4gb3JpZ2luIGhhcyBwZXJtaXNzaW9ucyBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuc2lnblRyYW5zYWN0aW9uIC0gZXRoVHggc2lnbmVyIHRoYXQgcmV0dXJucyBhIHJhd1R4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHhIaXN0b3J5TGltaXRdIC0gbnVtYmVyICpvcHRpb25hbCogZm9yIGxpbWl0aW5nIGhvdyBtYW55IHRyYW5zYWN0aW9ucyBhcmUgaW4gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByZWZlcmVuY2VzU3RvcmVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5ldHdvcmtTdG9yZSA9IG9wdHMubmV0d29ya1N0b3JlIHx8IG5ldyBPYnNlcnZhYmxlU3RvcmUoe30pO1xuICAgIHRoaXMuX2dldEN1cnJlbnRDaGFpbklkID0gb3B0cy5nZXRDdXJyZW50Q2hhaW5JZDtcbiAgICB0aGlzLmdldFByb3ZpZGVyQ29uZmlnID0gb3B0cy5nZXRQcm92aWRlckNvbmZpZztcbiAgICB0aGlzLl9nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgIG9wdHMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTtcbiAgICB0aGlzLl9nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgIG9wdHMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTtcbiAgICB0aGlzLnByZWZlcmVuY2VzU3RvcmUgPSBvcHRzLnByZWZlcmVuY2VzU3RvcmUgfHwgbmV3IE9ic2VydmFibGVTdG9yZSh7fSk7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyA9IG9wdHMuZ2V0UGVybWl0dGVkQWNjb3VudHM7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPSBvcHRzLmJsb2NrVHJhY2tlcjtcbiAgICB0aGlzLnNpZ25FdGhUeCA9IG9wdHMuc2lnblRyYW5zYWN0aW9uO1xuICAgIHRoaXMuaW5Qcm9jZXNzT2ZTaWduaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCA9IG9wdHMudHJhY2tNZXRhTWV0cmljc0V2ZW50O1xuICAgIHRoaXMuX2dldFBhcnRpY2lwYXRlSW5NZXRyaWNzID0gb3B0cy5nZXRQYXJ0aWNpcGF0ZUluTWV0cmljcztcbiAgICB0aGlzLl9nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzID0gb3B0cy5nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzO1xuICAgIHRoaXMuY3JlYXRlRXZlbnRGcmFnbWVudCA9IG9wdHMuY3JlYXRlRXZlbnRGcmFnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUV2ZW50RnJhZ21lbnQgPSBvcHRzLnVwZGF0ZUV2ZW50RnJhZ21lbnQ7XG4gICAgdGhpcy5maW5hbGl6ZUV2ZW50RnJhZ21lbnQgPSBvcHRzLmZpbmFsaXplRXZlbnRGcmFnbWVudDtcbiAgICB0aGlzLmdldEV2ZW50RnJhZ21lbnRCeUlkID0gb3B0cy5nZXRFdmVudEZyYWdtZW50QnlJZDtcblxuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHt9KTtcbiAgICB0aGlzLnF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KHRoaXMucHJvdmlkZXIpO1xuXG4gICAgdGhpcy50eEdhc1V0aWwgPSBuZXcgVHhHYXNVdGlsKHRoaXMucHJvdmlkZXIpO1xuICAgIHRoaXMuX21hcE1ldGhvZHMoKTtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyID0gbmV3IFRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyKHtcbiAgICAgIGluaXRTdGF0ZTogb3B0cy5pbml0U3RhdGUsXG4gICAgICB0eEhpc3RvcnlMaW1pdDogb3B0cy50eEhpc3RvcnlMaW1pdCxcbiAgICAgIGdldE5ldHdvcms6IHRoaXMuZ2V0TmV0d29yay5iaW5kKHRoaXMpLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IG9wdHMuZ2V0Q3VycmVudENoYWluSWQsXG4gICAgfSk7XG4gICAgdGhpcy5fb25Cb290Q2xlYW5VcCgpO1xuXG4gICAgdGhpcy5zdG9yZSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuc3RvcmU7XG4gICAgdGhpcy5ub25jZVRyYWNrZXIgPSBuZXcgTm9uY2VUcmFja2VyKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcbiAgICAgIGdldFBlbmRpbmdUcmFuc2FjdGlvbnM6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbnMgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zID0gb3B0cy5nZXRFeHRlcm5hbFBlbmRpbmdUcmFuc2FjdGlvbnMoXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFsuLi5wZW5kaW5nVHJhbnNhY3Rpb25zLCAuLi5leHRlcm5hbFBlbmRpbmdUcmFuc2FjdGlvbnNdO1xuICAgICAgfSxcbiAgICAgIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uczogdGhpcy50eFN0YXRlTWFuYWdlci5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMuYmluZChcbiAgICAgICAgdGhpcy50eFN0YXRlTWFuYWdlcixcbiAgICAgICksXG4gICAgfSk7XG5cbiAgICB0aGlzLnBlbmRpbmdUeFRyYWNrZXIgPSBuZXcgUGVuZGluZ1RyYW5zYWN0aW9uVHJhY2tlcih7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG5vbmNlVHJhY2tlcjogdGhpcy5ub25jZVRyYWNrZXIsXG4gICAgICBwdWJsaXNoVHJhbnNhY3Rpb246IChyYXdUeCkgPT4gdGhpcy5xdWVyeS5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHgpLFxuICAgICAgZ2V0UGVuZGluZ1RyYW5zYWN0aW9uczogKCkgPT4ge1xuICAgICAgICBjb25zdCBwZW5kaW5nID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRBcHByb3ZlZFRyYW5zYWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gWy4uLnBlbmRpbmcsIC4uLmFwcHJvdmVkXTtcbiAgICAgIH0sXG4gICAgICBhcHByb3ZlVHJhbnNhY3Rpb246IHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBnZXRDb21wbGV0ZWRUcmFuc2FjdGlvbnM6IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zLmJpbmQoXG4gICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zdG9yZS5zdWJzY3JpYmUoKCkgPT5cbiAgICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpLFxuICAgICk7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICAvLyBtZW1zdG9yZSBpcyBjb21wdXRlZCBmcm9tIGEgZmV3IGRpZmZlcmVudCBzdG9yZXNcbiAgICB0aGlzLl91cGRhdGVNZW1zdG9yZSgpO1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc3RvcmUuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZU1lbXN0b3JlKCkpO1xuICAgIHRoaXMubmV0d29ya1N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9vbkJvb3RDbGVhblVwKCk7XG4gICAgICB0aGlzLl91cGRhdGVNZW1zdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gcmVxdWVzdCBzdGF0ZSB1cGRhdGUgdG8gZmluYWxpemUgaW5pdGlhbGl6YXRpb25cbiAgICB0aGlzLl91cGRhdGVQZW5kaW5nVHhzQWZ0ZXJGaXJzdEJsb2NrKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBjaGFpbklkIGluIHRoZSBuZXR3b3JrIHN0b3JlIGFzIGEgbnVtYmVyLCByZXR1cm5pbmcgMCBpZlxuICAgKiB0aGUgY2hhaW5JZCBwYXJzZXMgdG8gTmFOLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtZXJpY2FsIGNoYWluSWQuXG4gICAqL1xuICBnZXRDaGFpbklkKCkge1xuICAgIGNvbnN0IG5ldHdvcmtTdGF0ZSA9IHRoaXMubmV0d29ya1N0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuX2dldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgY29uc3QgaW50ZWdlckNoYWluSWQgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgaWYgKG5ldHdvcmtTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IE51bWJlci5pc05hTihpbnRlZ2VyQ2hhaW5JZCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZWdlckNoYWluSWQ7XG4gIH1cblxuICBhc3luYyBnZXRFSVAxNTU5Q29tcGF0aWJpbGl0eShmcm9tQWRkcmVzcykge1xuICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrSXNDb21wYXRpYmxlID0gYXdhaXQgdGhpcy5fZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgIGNvbnN0IGZyb21BY2NvdW50SXNDb21wYXRpYmxlID0gYXdhaXQgdGhpcy5fZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eShcbiAgICAgIGZyb21BZGRyZXNzLFxuICAgICk7XG4gICAgcmV0dXJuIGN1cnJlbnROZXR3b3JrSXNDb21wYXRpYmxlICYmIGZyb21BY2NvdW50SXNDb21wYXRpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIGBAZXRoZXJldW1qcy90eGAgdXNlcyBgQGV0aGVyZXVtanMvY29tbW9uYCBhcyBhIGNvbmZpZ3VyYXRpb24gdG9vbCBmb3JcbiAgICogc3BlY2lmeWluZyB3aGljaCBjaGFpbiwgbmV0d29yaywgaGFyZGZvcmsgYW5kIEVJUHMgdG8gc3VwcG9ydCBmb3JcbiAgICogYSB0cmFuc2FjdGlvbi4gQnkgcmVmZXJlbmNpbmcgdGhpcyBjb25maWd1cmF0aW9uLCBhbmQgYW5hbHl6aW5nIHRoZSBmaWVsZHNcbiAgICogc3BlY2lmaWVkIGluIHR4UGFyYW1zLCBgQGV0aGVyZXVtanMvdHhgIGlzIGFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIEVJUC0yNzE4XG4gICAqIHRyYW5zYWN0aW9uIHR5cGUgdG8gdXNlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbUFkZHJlc3NcbiAgICogQHJldHVybnMge0NvbW1vbn0gY29tbW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBhc3luYyBnZXRDb21tb25Db25maWd1cmF0aW9uKGZyb21BZGRyZXNzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBuaWNrbmFtZTogbmFtZSB9ID0gdGhpcy5nZXRQcm92aWRlckNvbmZpZygpO1xuICAgIGNvbnN0IHN1cHBvcnRzRUlQMTU1OSA9IGF3YWl0IHRoaXMuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoZnJvbUFkZHJlc3MpO1xuXG4gICAgLy8gVGhpcyBsb2dpYyBiZWxvdyB3aWxsIGhhdmUgdG8gYmUgdXBkYXRlZCBlYWNoIHRpbWUgYSBoYXJkZm9yayBoYXBwZW5zXG4gICAgLy8gdGhhdCBjYXJyaWVzIHdpdGggaXQgYSBuZXcgVHJhbnNhY3Rpb24gdHlwZS4gSXQgaXMgaW5jb25zZXF1ZW50aWFsIGZvclxuICAgIC8vIGhhcmRmb3JrcyB0aGF0IGRvIG5vdCBpbmNsdWRlIG5ldyB0eXBlcy5cbiAgICBjb25zdCBoYXJkZm9yayA9IHN1cHBvcnRzRUlQMTU1OSA/IEhBUkRGT1JLUy5MT05ET04gOiBIQVJERk9SS1MuQkVSTElOO1xuXG4gICAgLy8gdHlwZSB3aWxsIGJlIG9uZSBvZiBvdXIgZGVmYXVsdCBuZXR3b3JrIG5hbWVzIG9yICdycGMnLiB0aGUgZGVmYXVsdFxuICAgIC8vIG5ldHdvcmsgbmFtZXMgYXJlIHN1ZmZpY2llbnQgY29uZmlndXJhdGlvbiwgc2ltcGx5IHBhc3MgdGhlIG5hbWUgYXMgdGhlXG4gICAgLy8gY2hhaW4gYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgIGlmICh0eXBlICE9PSBORVRXT1JLX1RZUEVfUlBDKSB7XG4gICAgICByZXR1cm4gbmV3IENvbW1vbih7XG4gICAgICAgIGNoYWluOiB0eXBlLFxuICAgICAgICBoYXJkZm9yayxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZvciAncnBjJyB3ZSBuZWVkIHRvIHVzZSB0aGUgc2FtZSBiYXNpYyBjb25maWd1cmF0aW9uIGFzIG1haW5uZXQsXG4gICAgLy8gc2luY2Ugd2Ugb25seSBzdXBwb3J0IEVWTSBjb21wYXRpYmxlIGNoYWlucywgYW5kIHRoZW4gb3ZlcnJpZGUgdGhlXG4gICAgLy8gbmFtZSwgY2hhaW5JZCBhbmQgbmV0d29ya0lkIHByb3BlcnRpZXMuIFRoaXMgaXMgZG9uZSB1c2luZyB0aGVcbiAgICAvLyBgZm9yQ3VzdG9tQ2hhaW5gIHN0YXRpYyBtZXRob2Qgb24gdGhlIENvbW1vbiBjbGFzcy5cbiAgICBjb25zdCBjaGFpbklkID0gcGFyc2VJbnQodGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKSwgMTYpO1xuICAgIGNvbnN0IG5ldHdvcmtJZCA9IHRoaXMubmV0d29ya1N0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCBjdXN0b21DaGFpblBhcmFtcyA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBjaGFpbklkLFxuICAgICAgLy8gSXQgaXMgaW1wcm9iYWJsZSBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBzaWduZWQgd2hpbGUgdGhlIG5ldHdvcmtcbiAgICAgIC8vIGlzIGxvYWRpbmcgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gMS4gUGVuZGluZywgdW5jb25maXJtZWQgdHJhbnNhY3Rpb25zIGFyZSB3aXBlZCBvbiBuZXR3b3JrIGNoYW5nZVxuICAgICAgLy8gMi4gVGhlIFVJIGlzIHVudXNhYmxlIChsb2FkaW5nIGluZGljYXRvcikgd2hlbiBuZXR3b3JrIGlzIGxvYWRpbmcuXG4gICAgICAvLyBzZXR0aW5nIHRoZSBuZXR3b3JrSWQgdG8gMCBpcyBmb3IgdHlwZSBzYWZldHkgYW5kIHRvIGV4cGxpY2l0eSBsZWFkXG4gICAgICAvLyB0aGUgdHJhbnNhY3Rpb24gdG8gZmFpbGluZyBpZiBhIHVzZXIgaXMgYWJsZSB0byBnZXQgdG8gdGhpcyBicmFuY2hcbiAgICAgIC8vIG9uIGEgY3VzdG9tIG5ldHdvcmsgdGhhdCByZXF1aXJlcyB2YWxpZCBuZXR3b3JrIGlkLiBJIGhhdmUgbm90IHJhblxuICAgICAgLy8gaW50byB0aGlzIGxpbWl0YXRpb24gb24gYW55IG5ldHdvcmsgSSBoYXZlIGF0dGVtcHRlZCwgZXZlbiB3aGVuXG4gICAgICAvLyBoYXJkY29kaW5nIG5ldHdvcmtJZCB0byAnbG9hZGluZycuXG4gICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZCA9PT0gJ2xvYWRpbmcnID8gMCA6IHBhcnNlSW50KG5ldHdvcmtJZCwgMTApLFxuICAgIH07XG5cbiAgICByZXR1cm4gQ29tbW9uLmZvckN1c3RvbUNoYWluKE1BSU5ORVQsIGN1c3RvbUNoYWluUGFyYW1zLCBoYXJkZm9yayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHR4IHRvIHRoZSB0eGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHR4TWV0YVxuICAgKiBAZmlyZXMgJHt0eE1ldGEuaWR9OnVuYXBwcm92ZWRcbiAgICovXG4gIGFkZFRyYW5zYWN0aW9uKHR4TWV0YSkge1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuYWRkVHJhbnNhY3Rpb24odHhNZXRhKTtcbiAgICB0aGlzLmVtaXQoYCR7dHhNZXRhLmlkfTp1bmFwcHJvdmVkYCwgdHhNZXRhKTtcbiAgICB0aGlzLl90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgVFJBTlNBQ1RJT05fRVZFTlRTLkFEREVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaXBlcyB0aGUgdHJhbnNhY3Rpb25zIGZvciBhIGdpdmVuIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBoZXggc3RyaW5nIG9mIHRoZSBmcm9tIGFkZHJlc3MgZm9yIHR4cyBiZWluZyByZW1vdmVkXG4gICAqL1xuICB3aXBlVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLndpcGVUcmFuc2FjdGlvbnMoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHVuYXBwcm92ZWQgdHJhbnNhY3Rpb24gdG8gdGhlIHBpcGVsaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBiZWluZyBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4UGFyYW1zIC0gdHhQYXJhbXMgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHdpdGggdGhlIGtleSBvcmlnaW4gdG8gcHV0IHRoZSBvcmlnaW4gb24gdGhlIHR4TWV0YVxuICAgKi9cbiAgYXN5bmMgbmV3VW5hcHByb3ZlZFRyYW5zYWN0aW9uKHR4UGFyYW1zLCBvcHRzID0ge30pIHtcbiAgICBsb2cuZGVidWcoXG4gICAgICBgTWV0YU1hc2tDb250cm9sbGVyIG5ld1VuYXBwcm92ZWRUcmFuc2FjdGlvbiAke0pTT04uc3RyaW5naWZ5KHR4UGFyYW1zKX1gLFxuICAgICk7XG5cbiAgICBjb25zdCBpbml0aWFsVHhNZXRhID0gYXdhaXQgdGhpcy5hZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24oXG4gICAgICB0eFBhcmFtcyxcbiAgICAgIG9wdHMub3JpZ2luLFxuICAgICk7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHR4IGNvbXBsZXRpb24gKHN1Y2Nlc3MsIGZhaWwpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIub25jZShcbiAgICAgICAgYCR7aW5pdGlhbFR4TWV0YS5pZH06ZmluaXNoZWRgLFxuICAgICAgICAoZmluaXNoZWRUeE1ldGEpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkVHhNZXRhLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQ6XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbmlzaGVkVHhNZXRhLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgJ01ldGFNYXNrIFR4IFNpZ25hdHVyZTogVXNlciBkZW5pZWQgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLicsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucnBjLmludGVybmFsKGZpbmlzaGVkVHhNZXRhLmVyci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgICBjbGVhbkVycm9yU3RhY2soXG4gICAgICAgICAgICAgICAgICBldGhFcnJvcnMucnBjLmludGVybmFsKFxuICAgICAgICAgICAgICAgICAgICBgTWV0YU1hc2sgVHggU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRUeE1ldGEudHhQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgZ2VuZXJhdGVzIGEgdHhNZXRhIHdpdGggZGVmYXVsdHMgYW5kIHB1dHMgaXQgaW4gdHhTdGF0ZU1hbmFnZXJcbiAgICogc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB0eFBhcmFtc1xuICAgKiBAcGFyYW0gb3JpZ2luXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvblR5cGVcbiAgICogQHJldHVybnMge3R4TWV0YX1cbiAgICovXG4gIGFzeW5jIGFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbih0eFBhcmFtcywgb3JpZ2luLCB0cmFuc2FjdGlvblR5cGUpIHtcbiAgICBpZiAoXG4gICAgICB0cmFuc2FjdGlvblR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIVNXQVBfVFJBTlNBQ1RJT05fVFlQRVMuaW5jbHVkZXModHJhbnNhY3Rpb25UeXBlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJhbnNhY3Rpb25Db250cm9sbGVyIC0gaW52YWxpZCB0cmFuc2FjdGlvblR5cGUgdmFsdWU6ICR7dHJhbnNhY3Rpb25UeXBlfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlXG4gICAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0gdHhVdGlscy5ub3JtYWxpemVUeFBhcmFtcyh0eFBhcmFtcyk7XG4gICAgY29uc3QgZWlwMTU1OUNvbXBhdGliaWxpdHkgPSBhd2FpdCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG5cbiAgICB0eFV0aWxzLnZhbGlkYXRlVHhQYXJhbXMobm9ybWFsaXplZFR4UGFyYW1zLCBlaXAxNTU5Q29tcGF0aWJpbGl0eSk7XG5cbiAgICAvKipcbiAgICAgKiBgZ2VuZXJhdGVUeE1ldGFgIGFkZHMgdGhlIGRlZmF1bHQgdHhNZXRhIHByb3BlcnRpZXMgdG8gdGhlIHBhc3NlZCBvYmplY3QuXG4gICAgICogVGhlc2UgaW5jbHVkZSB0aGUgdHgncyBgaWRgLiBBcyB3ZSB1c2UgdGhlIGlkIGZvciBkZXRlcm1pbmluZyBvcmRlciBvZlxuICAgICAqIHR4ZXMgaW4gdGhlIHR4LXN0YXRlLW1hbmFnZXIsIGl0IGlzIG5lY2Vzc2FyeSB0byBjYWxsIHRoZSBhc3luY2hyb25vdXNcbiAgICAgKiBtZXRob2QgYHRoaXMuX2RldGVybWluZVRyYW5zYWN0aW9uVHlwZWAgYWZ0ZXIgYGdlbmVyYXRlVHhNZXRhYC5cbiAgICAgKi9cbiAgICBsZXQgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZW5lcmF0ZVR4TWV0YSh7XG4gICAgICB0eFBhcmFtczogbm9ybWFsaXplZFR4UGFyYW1zLFxuICAgICAgb3JpZ2luLFxuICAgIH0pO1xuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ21ldGFtYXNrJykge1xuICAgICAgLy8gQXNzZXJ0IHRoZSBmcm9tIGFkZHJlc3MgaXMgdGhlIHNlbGVjdGVkIGFkZHJlc3NcbiAgICAgIGlmIChub3JtYWxpemVkVHhQYXJhbXMuZnJvbSAhPT0gdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MoKSkge1xuICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICBtZXNzYWdlOiBgSW50ZXJuYWxseSBpbml0aWF0ZWQgdHJhbnNhY3Rpb24gaXMgdXNpbmcgaW52YWxpZCBhY2NvdW50LmAsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgZnJvbUFkZHJlc3M6IG5vcm1hbGl6ZWRUeFBhcmFtcy5mcm9tLFxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiB0aGlzLmdldFNlbGVjdGVkQWRkcmVzcygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBc3NlcnQgdGhhdCB0aGUgb3JpZ2luIGhhcyBwZXJtaXNzaW9ucyB0byBpbml0aWF0ZSB0cmFuc2FjdGlvbnMgZnJvbVxuICAgICAgLy8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAgICBjb25zdCBwZXJtaXR0ZWRBZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbik7XG4gICAgICBpZiAoIXBlcm1pdHRlZEFkZHJlc3Nlcy5pbmNsdWRlcyhub3JtYWxpemVkVHhQYXJhbXMuZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7IGRhdGE6IHsgb3JpZ2luIH0gfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyB0eXBlLCBnZXRDb2RlUmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMuX2RldGVybWluZVRyYW5zYWN0aW9uVHlwZShcbiAgICAgIHR4UGFyYW1zLFxuICAgICk7XG4gICAgdHhNZXRhLnR5cGUgPSB0cmFuc2FjdGlvblR5cGUgfHwgdHlwZTtcblxuICAgIC8vIGVuc3VyZSB2YWx1ZVxuICAgIHR4TWV0YS50eFBhcmFtcy52YWx1ZSA9IHR4TWV0YS50eFBhcmFtcy52YWx1ZVxuICAgICAgPyBhZGRIZXhQcmVmaXgodHhNZXRhLnR4UGFyYW1zLnZhbHVlKVxuICAgICAgOiAnMHgwJztcblxuICAgIHRoaXMuYWRkVHJhbnNhY3Rpb24odHhNZXRhKTtcbiAgICB0aGlzLmVtaXQoJ25ld1VuYXBwcm92ZWRUeCcsIHR4TWV0YSk7XG5cbiAgICB0cnkge1xuICAgICAgdHhNZXRhID0gYXdhaXQgdGhpcy5hZGRUeEdhc0RlZmF1bHRzKHR4TWV0YSwgZ2V0Q29kZVJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLndhcm4oZXJyb3IpO1xuICAgICAgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eE1ldGEuaWQpO1xuICAgICAgdHhNZXRhLmxvYWRpbmdEZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICAnRmFpbGVkIHRvIGNhbGN1bGF0ZSBnYXMgZGVmYXVsdHMuJyxcbiAgICAgICk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB0eE1ldGEubG9hZGluZ0RlZmF1bHRzID0gZmFsc2U7XG4gICAgLy8gc2F2ZSB0eE1ldGFcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgdHhNZXRhLFxuICAgICAgJ0FkZGVkIG5ldyB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uLicsXG4gICAgKTtcblxuICAgIHJldHVybiB0eE1ldGE7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdHggZ2FzIGRlZmF1bHRzOiBnYXMgJiYgZ2FzUHJpY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEBwYXJhbSBnZXRDb2RlUmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gcmVzb2x2ZXMgd2l0aCB0eE1ldGFcbiAgICovXG4gIGFzeW5jIGFkZFR4R2FzRGVmYXVsdHModHhNZXRhLCBnZXRDb2RlUmVzcG9uc2UpIHtcbiAgICBjb25zdCBlaXAxNTU5Q29tcGF0aWJpbGl0eSA9XG4gICAgICB0eE1ldGEudHhQYXJhbXMudHlwZSAhPT0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZICYmXG4gICAgICAoYXdhaXQgdGhpcy5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpKTtcbiAgICBjb25zdCB7XG4gICAgICBnYXNQcmljZTogZGVmYXVsdEdhc1ByaWNlLFxuICAgICAgbWF4RmVlUGVyR2FzOiBkZWZhdWx0TWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGRlZmF1bHRNYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGVmYXVsdEdhc0ZlZXModHhNZXRhLCBlaXAxNTU5Q29tcGF0aWJpbGl0eSk7XG4gICAgY29uc3Qge1xuICAgICAgZ2FzTGltaXQ6IGRlZmF1bHRHYXNMaW1pdCxcbiAgICAgIHNpbXVsYXRpb25GYWlscyxcbiAgICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGVmYXVsdEdhc0xpbWl0KHR4TWV0YSwgZ2V0Q29kZVJlc3BvbnNlKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhNZXRhLmlkKTtcbiAgICBpZiAoc2ltdWxhdGlvbkZhaWxzKSB7XG4gICAgICB0eE1ldGEuc2ltdWxhdGlvbkZhaWxzID0gc2ltdWxhdGlvbkZhaWxzO1xuICAgIH1cblxuICAgIGlmIChlaXAxNTU5Q29tcGF0aWJpbGl0eSkge1xuICAgICAgY29uc3QgeyBlaXAxNTU5VjJFbmFibGVkIH0gPSB0aGlzLnByZWZlcmVuY2VzU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGFkdmFuY2VkR2FzRmVlRGVmYXVsdFZhbHVlcyA9IHRoaXMuZ2V0QWR2YW5jZWRHYXNGZWUoKTtcbiAgICAgIGlmIChcbiAgICAgICAgZWlwMTU1OVYyRW5hYmxlZCAmJlxuICAgICAgICBCb29sZWFuKGFkdmFuY2VkR2FzRmVlRGVmYXVsdFZhbHVlcykgJiZcbiAgICAgICAgIVNXQVBfVFJBTlNBQ1RJT05fVFlQRVMuaW5jbHVkZXModHhNZXRhLnR5cGUpXG4gICAgICApIHtcbiAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IENVU1RPTV9HQVNfRVNUSU1BVEU7XG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSBkZWNHV0VJVG9IZXhXRUkoXG4gICAgICAgICAgYWR2YW5jZWRHYXNGZWVEZWZhdWx0VmFsdWVzLm1heEJhc2VGZWUsXG4gICAgICAgICk7XG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGRlY0dXRUlUb0hleFdFSShcbiAgICAgICAgICBhZHZhbmNlZEdhc0ZlZURlZmF1bHRWYWx1ZXMucHJpb3JpdHlGZWUsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UgJiZcbiAgICAgICAgIXR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgIXR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgKSB7XG4gICAgICAgIC8vIElmIHRoZSBkYXBwIGhhcyBzdWdnZXN0ZWQgYSBnYXMgcHJpY2UsIGJ1dCBubyBtYXhGZWVQZXJHYXMgb3IgbWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgLy8gIHRoZW4gd2Ugc2V0IG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgdG8gdGhlIHN1Z2dlc3RlZCBnYXNQcmljZS5cbiAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcyA9IHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZTtcbiAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlO1xuICAgICAgICBpZiAoZWlwMTU1OVYyRW5hYmxlZCAmJiB0eE1ldGEub3JpZ2luICE9PSAnbWV0YW1hc2snKSB7XG4gICAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IFBSSU9SSVRZX0xFVkVMUy5EQVBQX1NVR0dFU1RFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eE1ldGEudXNlckZlZUxldmVsID0gQ1VTVE9NX0dBU19FU1RJTUFURTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChkZWZhdWx0TWF4RmVlUGVyR2FzICYmXG4gICAgICAgICAgICBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgICAgICF0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzICYmXG4gICAgICAgICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzKSB8fFxuICAgICAgICAgIHR4TWV0YS5vcmlnaW4gPT09ICdtZXRhbWFzaydcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHhNZXRhLnVzZXJGZWVMZXZlbCA9IEdBU19SRUNPTU1FTkRBVElPTlMuTUVESVVNO1xuICAgICAgICB9IGVsc2UgaWYgKGVpcDE1NTlWMkVuYWJsZWQpIHtcbiAgICAgICAgICB0eE1ldGEudXNlckZlZUxldmVsID0gUFJJT1JJVFlfTEVWRUxTLkRBUFBfU1VHR0VTVEVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR4TWV0YS51c2VyRmVlTGV2ZWwgPSBDVVNUT01fR0FTX0VTVElNQVRFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRNYXhGZWVQZXJHYXMgJiYgIXR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGFwcCBoYXMgbm90IHNldCB0aGUgZ2FzUHJpY2Ugb3IgdGhlIG1heEZlZVBlckdhcywgdGhlbiB3ZSBzZXQgbWF4RmVlUGVyR2FzXG4gICAgICAgICAgLy8gd2l0aCB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBnYXNGZWVDb250cm9sbGVyLCBpZiB0aGF0IGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzID0gZGVmYXVsdE1heEZlZVBlckdhcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgICAhdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIElmIHRoZSBkYXBwIGhhcyBub3Qgc2V0IHRoZSBnYXNQcmljZSBvciB0aGUgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIHRoZW4gd2Ugc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgLy8gd2l0aCB0aGUgb25lIHJldHVybmVkIGJ5IHRoZSBnYXNGZWVDb250cm9sbGVyLCBpZiB0aGF0IGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdEdhc1ByaWNlICYmICF0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRhcHAgaGFzIG5vdCBzZXQgdGhlIGdhc1ByaWNlIG9yIHRoZSBtYXhGZWVQZXJHYXMsIGFuZCBubyBtYXhGZWVQZXJHYXMgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gZnJvbSB0aGUgZ2FzRmVlQ29udHJvbGxlciwgdGhlbiB3ZSBzZXQgbWF4RmVlUGVyR2FzIHRvIHRoZSBkZWZhdWx0R2FzUHJpY2UsIGFzc3VtaW5nIGl0IGlzXG4gICAgICAgICAgLy8gYXZhaWxhYmxlLlxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSBkZWZhdWx0R2FzUHJpY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcyAmJlxuICAgICAgICAgICF0eE1ldGEudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRhcHAgaGFzIG5vdCBzZXQgdGhlIGdhc1ByaWNlIG9yIHRoZSBtYXhQcmlvcml0eUZlZVBlckdhcywgYW5kIG5vIG1heFByaW9yaXR5RmVlUGVyR2FzIGlzXG4gICAgICAgICAgLy8gYXZhaWxhYmxlIGZyb20gdGhlIGdhc0ZlZUNvbnRyb2xsZXIsIHRoZW4gd2Ugc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzIHRvXG4gICAgICAgICAgLy8gdHhNZXRhLnR4UGFyYW1zLm1heEZlZVBlckdhcywgd2hpY2ggd2lsbCBlaXRoZXIgYmUgdGhlIGdhc1ByaWNlIGZyb20gdGhlIGNvbnRyb2xsZXIsIHRoZSBtYXhGZWVQZXJHYXNcbiAgICAgICAgICAvLyBzZXQgYnkgdGhlIGRhcHAsIG9yIHRoZSBtYXhGZWVQZXJHYXMgZnJvbSB0aGUgY29udHJvbGxlci5cbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHJlbW92ZSB0aGUgZ2FzUHJpY2UgcGFyYW0gZW50aXJlbHkgd2hlbiBvbiBhbiBlaXAxNTU5IGNvbXBhdGlibGUgbmV0d29ya1xuXG4gICAgICBkZWxldGUgdHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBlbnN1cmUgdGhhdCBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGFyZSBub3QgaW4gdGhlIHRyYW5zYWN0aW9uIHBhcmFtc1xuICAgICAgLy8gd2hlbiBub3Qgb24gYSBFSVAxNTU5IGNvbXBhdGlibGUgbmV0d29ya1xuXG4gICAgICBkZWxldGUgdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgZGVsZXRlIHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXM7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgYW5kIG5vbmUgb2YgZ2FzUHJpY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzIG9yIG1heEZlZVBlckdhcyBhcmVcbiAgICAvLyBzZXQgb24gdHhQYXJhbXMsIGl0IG1lYW5zIHRoYXQgZWl0aGVyIHdlIGFyZSBvbiBhIG5vbi1FSVAxNTU5IG5ldHdvcmsgYW5kIHRoZSBkYXBwIGRpZG4ndCBzdWdnZXN0XG4gICAgLy8gYSBnYXMgcHJpY2UsIG9yIHdlIGFyZSBvbiBhbiBFSVAxNTU5IG5ldHdvcmssIGFuZCBub25lIG9mIGdhc1ByaWNlLCBtYXhQcmlvcml0eUZlZVBlckdhcyBvciBtYXhGZWVQZXJHYXNcbiAgICAvLyB3ZXJlIGF2YWlsYWJsZSBmcm9tIGVpdGhlciB0aGUgZGFwcCBvciB0aGUgbmV0d29yay5cbiAgICBpZiAoXG4gICAgICBkZWZhdWx0R2FzUHJpY2UgJiZcbiAgICAgICF0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UgJiZcbiAgICAgICF0eE1ldGEudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICF0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzXG4gICAgKSB7XG4gICAgICB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UgPSBkZWZhdWx0R2FzUHJpY2U7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRHYXNMaW1pdCAmJiAhdHhNZXRhLnR4UGFyYW1zLmdhcykge1xuICAgICAgdHhNZXRhLnR4UGFyYW1zLmdhcyA9IGRlZmF1bHRHYXNMaW1pdDtcbiAgICAgIHR4TWV0YS5vcmlnaW5hbEdhc0VzdGltYXRlID0gZGVmYXVsdEdhc0xpbWl0O1xuICAgIH1cbiAgICB0eE1ldGEuZGVmYXVsdEdhc0VzdGltYXRlcyA9IHtcbiAgICAgIGVzdGltYXRlVHlwZTogdHhNZXRhLnVzZXJGZWVMZXZlbCxcbiAgICAgIGdhczogdHhNZXRhLnR4UGFyYW1zLmdhcyxcbiAgICAgIGdhc1ByaWNlOiB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgICBtYXhGZWVQZXJHYXM6IHR4TWV0YS50eFBhcmFtcy5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdHhNZXRhLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgIH07XG4gICAgcmV0dXJuIHR4TWV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGRlZmF1bHQgZ2FzIGZlZXMsIG9yIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgZ2FzIGZlZXMgYXJlIGFscmVhZHkgc2V0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSBUaGUgdHhNZXRhIG9iamVjdFxuICAgKiBAcGFyYW0gZWlwMTU1OUNvbXBhdGliaWxpdHlcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfHVuZGVmaW5lZD59IFRoZSBkZWZhdWx0IGdhcyBwcmljZVxuICAgKi9cbiAgYXN5bmMgX2dldERlZmF1bHRHYXNGZWVzKHR4TWV0YSwgZWlwMTU1OUNvbXBhdGliaWxpdHkpIHtcbiAgICBpZiAoXG4gICAgICAoIWVpcDE1NTlDb21wYXRpYmlsaXR5ICYmIHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSkgfHxcbiAgICAgIChlaXAxNTU5Q29tcGF0aWJpbGl0eSAmJlxuICAgICAgICB0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzICYmXG4gICAgICAgIHR4TWV0YS50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBnYXNGZWVFc3RpbWF0ZXMsXG4gICAgICAgIGdhc0VzdGltYXRlVHlwZSxcbiAgICAgIH0gPSBhd2FpdCB0aGlzLl9nZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzKCk7XG4gICAgICBpZiAoXG4gICAgICAgIGVpcDE1NTlDb21wYXRpYmlsaXR5ICYmXG4gICAgICAgIGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVRcbiAgICAgICkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVkaXVtOiB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMgfSA9IHt9LFxuICAgICAgICB9ID0gZ2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgICAgIGlmIChzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyAmJiBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBkZWNHV0VJVG9IZXhXRUkoc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBkZWNHV0VJVG9IZXhXRUkoXG4gICAgICAgICAgICAgIHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWSkge1xuICAgICAgICAvLyBUaGUgTEVHQUNZIHR5cGUgaW5jbHVkZXMgbG93LCBtZWRpdW0gYW5kIGhpZ2ggZXN0aW1hdGVzIG9mXG4gICAgICAgIC8vIGdhcyBwcmljZSB2YWx1ZXMuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2FzUHJpY2U6IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMubWVkaXVtKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFKSB7XG4gICAgICAgIC8vIFRoZSBFVEhfR0FTUFJJQ0UgdHlwZSBqdXN0IGluY2x1ZGVzIGEgc2luZ2xlIGdhcyBwcmljZSBwcm9wZXJ0eSxcbiAgICAgICAgLy8gd2hpY2ggd2UgY2FuIGFzc3VtZSB3YXMgcmV0cmlldmVkIGZyb20gZXRoX2dhc1ByaWNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2FzUHJpY2U6IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMuZ2FzUHJpY2UpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5Lmdhc1ByaWNlKCk7XG5cbiAgICByZXR1cm4geyBnYXNQcmljZTogZ2FzUHJpY2UgJiYgYWRkSGV4UHJlZml4KGdhc1ByaWNlLnRvU3RyaW5nKDE2KSkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGRlZmF1bHQgZ2FzIGxpbWl0LCBvciBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCB3aHkgZ2FzIGVzdGltYXRlIGZhaWxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIFRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBnZXRDb2RlUmVzcG9uc2UgLSBUaGUgdHJhbnNhY3Rpb24gY2F0ZWdvcnkgY29kZSByZXNwb25zZSwgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IE9iamVjdCBjb250YWluaW5nIHRoZSBkZWZhdWx0IGdhcyBsaW1pdCwgb3IgdGhlIHNpbXVsYXRpb24gZmFpbHVyZSBvYmplY3RcbiAgICovXG4gIGFzeW5jIF9nZXREZWZhdWx0R2FzTGltaXQodHhNZXRhLCBnZXRDb2RlUmVzcG9uc2UpIHtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBjb25zdCBjdXN0b21OZXR3b3JrR2FzQnVmZmVyID0gQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF07XG4gICAgY29uc3QgY2hhaW5UeXBlID0gZ2V0Q2hhaW5UeXBlKGNoYWluSWQpO1xuXG4gICAgaWYgKHR4TWV0YS50eFBhcmFtcy5nYXMpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHhNZXRhLnR4UGFyYW1zLnRvICYmXG4gICAgICB0eE1ldGEudHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQgJiZcbiAgICAgIGNoYWluVHlwZSAhPT0gJ2N1c3RvbSdcbiAgICApIHtcbiAgICAgIC8vIGlmIHRoZXJlJ3MgZGF0YSBpbiB0aGUgcGFyYW1zLCBidXQgdGhlcmUncyBubyBjb250cmFjdCBjb2RlLCBpdCdzIG5vdCBhIHZhbGlkIHRyYW5zYWN0aW9uXG4gICAgICBpZiAodHhNZXRhLnR4UGFyYW1zLmRhdGEpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUeEdhc1V0aWwgLSBUcnlpbmcgdG8gY2FsbCBhIGZ1bmN0aW9uIG9uIGEgbm9uLWNvbnRyYWN0IGFkZHJlc3MnLFxuICAgICAgICApO1xuICAgICAgICAvLyBzZXQgZXJyb3Iga2V5IHNvIHVpIGNhbiBkaXNwbGF5IGxvY2FsaXplZCBlcnJvciBtZXNzYWdlXG4gICAgICAgIGVyci5lcnJvcktleSA9IFRSQU5TQUNUSU9OX05PX0NPTlRSQUNUX0VSUk9SX0tFWTtcblxuICAgICAgICAvLyBzZXQgdGhlIHJlc3BvbnNlIG9uIHRoZSBlcnJvciBzbyB0aGF0IHdlIGNhbiBzZWUgaW4gbG9ncyB3aGF0IHRoZSBhY3R1YWwgcmVzcG9uc2Ugd2FzXG4gICAgICAgIGVyci5nZXRDb2RlUmVzcG9uc2UgPSBnZXRDb2RlUmVzcG9uc2U7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhIHN0YW5kYXJkIGV0aGVyIHNpbXBsZSBzZW5kLCBnYXMgcmVxdWlyZW1lbnQgaXMgZXhhY3RseSAyMWtcbiAgICAgIHJldHVybiB7IGdhc0xpbWl0OiBHQVNfTElNSVRTLlNJTVBMRSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBlc3RpbWF0ZWRHYXNIZXgsXG4gICAgICBzaW11bGF0aW9uRmFpbHMsXG4gICAgfSA9IGF3YWl0IHRoaXMudHhHYXNVdGlsLmFuYWx5emVHYXNVc2FnZSh0eE1ldGEpO1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgZ2FzIGJ1ZmZlciB0byBvdXIgZXN0aW1hdGlvbiBmb3Igc2FmZXR5XG4gICAgY29uc3QgZ2FzTGltaXQgPSB0aGlzLnR4R2FzVXRpbC5hZGRHYXNCdWZmZXIoXG4gICAgICBhZGRIZXhQcmVmaXgoZXN0aW1hdGVkR2FzSGV4KSxcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBjdXN0b21OZXR3b3JrR2FzQnVmZmVyLFxuICAgICk7XG4gICAgcmV0dXJuIHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgVHJhbnNhY3Rpb25NZXRhIG9iamVjdCwgZ2VuZXJhdGUgbmV3IGdhcyBwYXJhbXMgc3VjaCB0aGF0IGlmIHRoZVxuICAgKiB0cmFuc2FjdGlvbiB3YXMgYW4gRUlQMTU1OSB0cmFuc2FjdGlvbiwgaXQgb25seSBoYXMgRUlQMTU1OSBnYXMgZmllbGRzLFxuICAgKiBvdGhlcndpc2UgaXQgb25seSBoYXMgZ2FzUHJpY2UuIFdpbGwgdXNlIHdoYXRldmVyIGN1c3RvbSB2YWx1ZXMgYXJlXG4gICAqIHNwZWNpZmllZCBpbiBjdXN0b21HYXNTZXR0aW5ncywgb3IgZmFsbHMgYmFjayB0byBpbmNyZW1lbnRpbmcgYnkgYSBwZXJjZW50XG4gICAqIHdoaWNoIGlzIGRlZmluZWQgYnkgc3BlY2lmeWluZyBhIG51bWVyYXRvci4gMTEgaXMgYSAxMCUgYnVtcCwgMTIgd291bGQgYmVcbiAgICogYSAyMCUgYnVtcCwgYW5kIHNvIG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YX0gb3JpZ2luYWxUeE1ldGEgLSBPcmlnaW5hbCB0cmFuc2FjdGlvbiB0byB1c2UgYXNcbiAgICogIGJhc2VcbiAgICogQHBhcmFtIHtDdXN0b21HYXNTZXR0aW5nc30gW2N1c3RvbUdhc1NldHRpbmdzXSAtIG92ZXJyaWRlcyBmb3IgdGhlIGdhc1xuICAgKiAgZmllbGRzIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50TnVtZXJhdG9yXSAtIE51bWVyYXRvciBmcm9tIHdoaWNoIHRvIGdlbmVyYXRlIGFcbiAgICogIHBlcmNlbnRhZ2UgYnVtcCBvZiBnYXMgcHJpY2UuIEUuZyAxMSB3b3VsZCBiZSBhIDEwJSBidW1wIG92ZXIgYmFzZS5cbiAgICogQHJldHVybnMge3sgbmV3R2FzUGFyYW1zOiBDdXN0b21HYXNTZXR0aW5ncywgcHJldmlvdXNHYXNQYXJhbXM6IEN1c3RvbUdhc1NldHRpbmdzIH19XG4gICAqL1xuICBnZW5lcmF0ZU5ld0dhc1BhcmFtcyhcbiAgICBvcmlnaW5hbFR4TWV0YSxcbiAgICBjdXN0b21HYXNTZXR0aW5ncyA9IHt9LFxuICAgIGluY3JlbWVudE51bWVyYXRvciA9IDExLFxuICApIHtcbiAgICBjb25zdCB7IHR4UGFyYW1zIH0gPSBvcmlnaW5hbFR4TWV0YTtcbiAgICBjb25zdCBwcmV2aW91c0dhc1BhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG5ld0dhc1BhcmFtcyA9IHt9O1xuICAgIGlmIChjdXN0b21HYXNTZXR0aW5ncy5nYXNMaW1pdCkge1xuICAgICAgbmV3R2FzUGFyYW1zLmdhcyA9IGN1c3RvbUdhc1NldHRpbmdzPy5nYXMgPz8gR0FTX0xJTUlUUy5TSU1QTEU7XG4gICAgfVxuXG4gICAgaWYgKGN1c3RvbUdhc1NldHRpbmdzLmVzdGltYXRlU3VnZ2VzdGVkKSB7XG4gICAgICBuZXdHYXNQYXJhbXMuZXN0aW1hdGVTdWdnZXN0ZWQgPSBjdXN0b21HYXNTZXR0aW5ncy5lc3RpbWF0ZVN1Z2dlc3RlZDtcbiAgICB9XG5cbiAgICBpZiAoY3VzdG9tR2FzU2V0dGluZ3MuZXN0aW1hdGVVc2VkKSB7XG4gICAgICBuZXdHYXNQYXJhbXMuZXN0aW1hdGVVc2VkID0gY3VzdG9tR2FzU2V0dGluZ3MuZXN0aW1hdGVVc2VkO1xuICAgIH1cblxuICAgIGlmIChpc0VJUDE1NTlUcmFuc2FjdGlvbihvcmlnaW5hbFR4TWV0YSkpIHtcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLm1heEZlZVBlckdhcyA9IHR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICBuZXdHYXNQYXJhbXMubWF4RmVlUGVyR2FzID1cbiAgICAgICAgY3VzdG9tR2FzU2V0dGluZ3M/Lm1heEZlZVBlckdhcyB8fFxuICAgICAgICBiblRvSGV4KFxuICAgICAgICAgIEJuTXVsdGlwbHlCeUZyYWN0aW9uKFxuICAgICAgICAgICAgaGV4VG9Cbih0eFBhcmFtcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgaW5jcmVtZW50TnVtZXJhdG9yLFxuICAgICAgICAgICAgMTAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIG5ld0dhc1BhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9XG4gICAgICAgIGN1c3RvbUdhc1NldHRpbmdzPy5tYXhQcmlvcml0eUZlZVBlckdhcyB8fFxuICAgICAgICBiblRvSGV4KFxuICAgICAgICAgIEJuTXVsdGlwbHlCeUZyYWN0aW9uKFxuICAgICAgICAgICAgaGV4VG9Cbih0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBpbmNyZW1lbnROdW1lcmF0b3IsXG4gICAgICAgICAgICAxMCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0dhc1BhcmFtcy5nYXNQcmljZSA9IHR4UGFyYW1zLmdhc1ByaWNlO1xuICAgICAgbmV3R2FzUGFyYW1zLmdhc1ByaWNlID1cbiAgICAgICAgY3VzdG9tR2FzU2V0dGluZ3M/Lmdhc1ByaWNlIHx8XG4gICAgICAgIGJuVG9IZXgoXG4gICAgICAgICAgQm5NdWx0aXBseUJ5RnJhY3Rpb24oXG4gICAgICAgICAgICBoZXhUb0JuKHR4UGFyYW1zLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGluY3JlbWVudE51bWVyYXRvcixcbiAgICAgICAgICAgIDEwLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJldmlvdXNHYXNQYXJhbXMsIG5ld0dhc1BhcmFtcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYXBwcm92ZWQgdHJhbnNhY3Rpb24gdG8gYXR0ZW1wdCB0byBjYW5jZWwgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCB0cmFuc2FjdGlvbi4gVGhlXG4gICAqIG5ldyB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgc2FtZSBub25jZSBhcyB0aGUgcHJldmlvdXMsIGlzIGEgYmFzaWMgRVRIIHRyYW5zZmVyIG9mIDB4IHZhbHVlIHRvXG4gICAqIHRoZSBzZW5kZXIncyBhZGRyZXNzLCBhbmQgaGFzIGEgaGlnaGVyIGdhc1ByaWNlIHRoYW4gdGhhdCBvZiB0aGUgcHJldmlvdXMgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5hbFR4SWQgLSB0aGUgaWQgb2YgdGhlIHR4TWV0YSB0aGF0IHlvdSB3YW50IHRvIGF0dGVtcHQgdG8gY2FuY2VsXG4gICAqIEBwYXJhbSB7Q3VzdG9tR2FzU2V0dGluZ3N9IFtjdXN0b21HYXNTZXR0aW5nc10gLSBvdmVycmlkZXMgdG8gdXNlIGZvciBnYXNcbiAgICogIHBhcmFtcyBpbnN0ZWFkIG9mIGFsbG93aW5nIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIHRoZW1cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZXN0aW1hdGVkQmFzZUZlZVxuICAgKiBAcmV0dXJucyB7dHhNZXRhfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24oXG4gICAgb3JpZ2luYWxUeElkLFxuICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgIHsgZXN0aW1hdGVkQmFzZUZlZSB9ID0ge30sXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsVHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbihvcmlnaW5hbFR4SWQpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXMgfSA9IG9yaWdpbmFsVHhNZXRhO1xuICAgIGNvbnN0IHsgZnJvbSwgbm9uY2UgfSA9IHR4UGFyYW1zO1xuXG4gICAgY29uc3QgeyBwcmV2aW91c0dhc1BhcmFtcywgbmV3R2FzUGFyYW1zIH0gPSB0aGlzLmdlbmVyYXRlTmV3R2FzUGFyYW1zKFxuICAgICAgb3JpZ2luYWxUeE1ldGEsXG4gICAgICB7XG4gICAgICAgIC4uLmN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgICAvLyBXZSB3YW50IHRvIG92ZXJyaWRlIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbnMgZ2FzTGltaXQgYmVjYXVzZSBpdFxuICAgICAgICAvLyB3aWxsIG5vdyBiZSBhIHNpbXBsZSBzZW5kIGluc3RlYWQgb2Ygd2hhdGV2ZXIgaXQgd2FzIGJlZm9yZSBzdWNoXG4gICAgICAgIC8vIGFzIGEgdG9rZW4gdHJhbnNmZXIgb3IgY29udHJhY3QgY2FsbC5cbiAgICAgICAgZ2FzTGltaXQ6IGN1c3RvbUdhc1NldHRpbmdzLmdhc0xpbWl0IHx8IEdBU19MSU1JVFMuU0lNUExFLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgbmV3VHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZW5lcmF0ZVR4TWV0YSh7XG4gICAgICB0eFBhcmFtczoge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0bzogZnJvbSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgLi4ubmV3R2FzUGFyYW1zLFxuICAgICAgfSxcbiAgICAgIHByZXZpb3VzR2FzUGFyYW1zLFxuICAgICAgbG9hZGluZ0RlZmF1bHRzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQsXG4gICAgICB0eXBlOiBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUwsXG4gICAgfSk7XG5cbiAgICBpZiAoZXN0aW1hdGVkQmFzZUZlZSkge1xuICAgICAgbmV3VHhNZXRhLmVzdGltYXRlZEJhc2VGZWUgPSBlc3RpbWF0ZWRCYXNlRmVlO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVHJhbnNhY3Rpb24obmV3VHhNZXRhKTtcbiAgICBhd2FpdCB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbihuZXdUeE1ldGEuaWQpO1xuICAgIHJldHVybiBuZXdUeE1ldGE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhcHByb3ZlZCB0cmFuc2FjdGlvbiB0byBhdHRlbXB0IHRvIHNwZWVkIHVwIGEgcHJldmlvdXNseSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb24uIFRoZVxuICAgKiBuZXcgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIHNhbWUgbm9uY2UgYXMgdGhlIHByZXZpb3VzLiBCeSBkZWZhdWx0LCB0aGUgbmV3IHRyYW5zYWN0aW9uIHdpbGwgdXNlXG4gICAqIHRoZSBzYW1lIGdhcyBsaW1pdCBhbmQgYSAxMCUgaGlnaGVyIGdhcyBwcmljZSwgdGhvdWdoIGl0IGlzIHBvc3NpYmxlIHRvIHNldCBhIGN1c3RvbSB2YWx1ZSBmb3JcbiAgICogZWFjaCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxUeElkIC0gdGhlIGlkIG9mIHRoZSB0eE1ldGEgdGhhdCB5b3Ugd2FudCB0byBzcGVlZCB1cFxuICAgKiBAcGFyYW0ge0N1c3RvbUdhc1NldHRpbmdzfSBbY3VzdG9tR2FzU2V0dGluZ3NdIC0gb3ZlcnJpZGVzIHRvIHVzZSBmb3IgZ2FzXG4gICAqICBwYXJhbXMgaW5zdGVhZCBvZiBhbGxvd2luZyB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGVtXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmVzdGltYXRlZEJhc2VGZWVcbiAgICogQHJldHVybnMge3R4TWV0YX1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbihcbiAgICBvcmlnaW5hbFR4SWQsXG4gICAgY3VzdG9tR2FzU2V0dGluZ3MsXG4gICAgeyBlc3RpbWF0ZWRCYXNlRmVlIH0gPSB7fSxcbiAgKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUeE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKG9yaWdpbmFsVHhJZCk7XG4gICAgY29uc3QgeyB0eFBhcmFtcyB9ID0gb3JpZ2luYWxUeE1ldGE7XG5cbiAgICBjb25zdCB7IHByZXZpb3VzR2FzUGFyYW1zLCBuZXdHYXNQYXJhbXMgfSA9IHRoaXMuZ2VuZXJhdGVOZXdHYXNQYXJhbXMoXG4gICAgICBvcmlnaW5hbFR4TWV0YSxcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgICk7XG5cbiAgICBjb25zdCBuZXdUeE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdlbmVyYXRlVHhNZXRhKHtcbiAgICAgIHR4UGFyYW1zOiB7XG4gICAgICAgIC4uLnR4UGFyYW1zLFxuICAgICAgICAuLi5uZXdHYXNQYXJhbXMsXG4gICAgICB9LFxuICAgICAgcHJldmlvdXNHYXNQYXJhbXMsXG4gICAgICBsb2FkaW5nRGVmYXVsdHM6IGZhbHNlLFxuICAgICAgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRCxcbiAgICAgIHR5cGU6IFRSQU5TQUNUSU9OX1RZUEVTLlJFVFJZLFxuICAgIH0pO1xuXG4gICAgaWYgKGVzdGltYXRlZEJhc2VGZWUpIHtcbiAgICAgIG5ld1R4TWV0YS5lc3RpbWF0ZWRCYXNlRmVlID0gZXN0aW1hdGVkQmFzZUZlZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRyYW5zYWN0aW9uKG5ld1R4TWV0YSk7XG4gICAgYXdhaXQgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24obmV3VHhNZXRhLmlkKTtcbiAgICByZXR1cm4gbmV3VHhNZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZXMgdGhlIHR4TWV0YSBpbiB0aGUgdHhTdGF0ZU1hbmFnZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB1cGRhdGVkIHR4TWV0YVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICdjb25mVHg6IHVzZXIgdXBkYXRlZCB0cmFuc2FjdGlvbicsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVzIGFuZCBhcHByb3ZlcyB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uKHR4TWV0YSkge1xuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICB0eE1ldGEsXG4gICAgICAnY29uZlR4OiB1c2VyIGFwcHJvdmVkIHRyYW5zYWN0aW9uJyxcbiAgICApO1xuICAgIGF3YWl0IHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uKHR4TWV0YS5pZCk7XG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgdHggc3RhdHVzIHRvIGFwcHJvdmVkXG4gICAqIGF1dG8gZmlsbHMgdGhlIG5vbmNlXG4gICAqIHNpZ25zIHRoZSB0cmFuc2FjdGlvblxuICAgKiBwdWJsaXNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqIGlmIGFueSBvZiB0aGVzZSBzdGVwcyBmYWlscyB0aGUgdHggc3RhdHVzIHdpbGwgYmUgc2V0IHRvIGZhaWxlZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAqL1xuICBhc3luYyBhcHByb3ZlVHJhbnNhY3Rpb24odHhJZCkge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyBzYWZldHkgb3V0IG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgLy8gU2luY2UgdGhpcyB0cmFuc2FjdGlvbiBpcyBhc3luYyxcbiAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgc2lnbmVkLFxuICAgIC8vIFNvIHRoYXQgd2UgZG8gbm90IGluY3JlbWVudCBub25jZSArIHJlc3VibWl0IHNvbWV0aGluZ1xuICAgIC8vIHRoYXQgaXMgYWxyZWFkeSBiZWluZyBpbmNyZW1lbnRlZCAmIHNpZ25lZC5cbiAgICBpZiAodGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuaGFzKHR4SWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5Qcm9jZXNzT2ZTaWduaW5nLmFkZCh0eElkKTtcbiAgICBsZXQgbm9uY2VMb2NrO1xuICAgIHRyeSB7XG4gICAgICAvLyBhcHByb3ZlXG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnNldFR4U3RhdHVzQXBwcm92ZWQodHhJZCk7XG4gICAgICAvLyBnZXQgbmV4dCBub25jZVxuICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcblxuICAgICAgY29uc3QgZnJvbUFkZHJlc3MgPSB0eE1ldGEudHhQYXJhbXMuZnJvbTtcbiAgICAgIC8vIHdhaXQgZm9yIGEgbm9uY2VcbiAgICAgIGxldCB7IGN1c3RvbU5vbmNlVmFsdWUgfSA9IHR4TWV0YTtcbiAgICAgIGN1c3RvbU5vbmNlVmFsdWUgPSBOdW1iZXIoY3VzdG9tTm9uY2VWYWx1ZSk7XG4gICAgICBub25jZUxvY2sgPSBhd2FpdCB0aGlzLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soZnJvbUFkZHJlc3MpO1xuICAgICAgLy8gYWRkIG5vbmNlIHRvIHR4UGFyYW1zXG4gICAgICAvLyBpZiB0eE1ldGEgaGFzIHByZXZpb3VzR2FzUGFyYW1zIHRoZW4gaXQgaXMgYSByZXRyeSBhdCBzYW1lIG5vbmNlIHdpdGhcbiAgICAgIC8vIGhpZ2hlciBnYXMgc2V0dGluZ3MgYW5kIHRoZXJlZm9yIHRoZSBub25jZSBzaG91bGQgbm90IGJlIHJlY2FsY3VsYXRlZFxuICAgICAgY29uc3Qgbm9uY2UgPSB0eE1ldGEucHJldmlvdXNHYXNQYXJhbXNcbiAgICAgICAgPyB0eE1ldGEudHhQYXJhbXMubm9uY2VcbiAgICAgICAgOiBub25jZUxvY2submV4dE5vbmNlO1xuICAgICAgY29uc3QgY3VzdG9tT3JOb25jZSA9XG4gICAgICAgIGN1c3RvbU5vbmNlVmFsdWUgPT09IDAgPyBjdXN0b21Ob25jZVZhbHVlIDogY3VzdG9tTm9uY2VWYWx1ZSB8fCBub25jZTtcblxuICAgICAgdHhNZXRhLnR4UGFyYW1zLm5vbmNlID0gYWRkSGV4UHJlZml4KGN1c3RvbU9yTm9uY2UudG9TdHJpbmcoMTYpKTtcbiAgICAgIC8vIGFkZCBub25jZSBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gdG8gdHhNZXRhXG4gICAgICB0eE1ldGEubm9uY2VEZXRhaWxzID0gbm9uY2VMb2NrLm5vbmNlRGV0YWlscztcbiAgICAgIGlmIChjdXN0b21Ob25jZVZhbHVlKSB7XG4gICAgICAgIHR4TWV0YS5ub25jZURldGFpbHMuY3VzdG9tTm9uY2VWYWx1ZSA9IGN1c3RvbU5vbmNlVmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICB0eE1ldGEsXG4gICAgICAgICd0cmFuc2FjdGlvbnMjYXBwcm92ZVRyYW5zYWN0aW9uJyxcbiAgICAgICk7XG4gICAgICAvLyBzaWduIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCByYXdUeCA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4SWQpO1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVHJhbnNhY3Rpb24odHhJZCwgcmF3VHgpO1xuICAgICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudCh0eE1ldGEsIFRSQU5TQUNUSU9OX0VWRU5UUy5BUFBST1ZFRCk7XG4gICAgICAvLyBtdXN0IHNldCB0cmFuc2FjdGlvbiB0byBzdWJtaXR0ZWQvZmFpbGVkIGJlZm9yZSByZWxlYXNpbmcgbG9ja1xuICAgICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyB0aGlzIGlzIHRyeS1jYXRjaCB3cmFwcGVkIHNvIHRoYXQgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBub25jZUxvY2sgaXMgcmVsZWFzZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2ZhaWxUcmFuc2FjdGlvbih0eElkLCBlcnIpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyMik7XG4gICAgICB9XG4gICAgICAvLyBtdXN0IHNldCB0cmFuc2FjdGlvbiB0byBzdWJtaXR0ZWQvZmFpbGVkIGJlZm9yZSByZWxlYXNpbmcgbG9ja1xuICAgICAgaWYgKG5vbmNlTG9jaykge1xuICAgICAgICBub25jZUxvY2sucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnRpbnVlIHdpdGggZXJyb3IgY2hhaW5cbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuZGVsZXRlKHR4SWQpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFwcHJvdmVUcmFuc2FjdGlvbnNXaXRoU2FtZU5vbmNlKGxpc3RPZlR4UGFyYW1zID0gW10pIHtcbiAgICBpZiAobGlzdE9mVHhQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbFR4ID0gbGlzdE9mVHhQYXJhbXNbMF07XG4gICAgY29uc3QgY29tbW9uID0gYXdhaXQgdGhpcy5nZXRDb21tb25Db25maWd1cmF0aW9uKGluaXRpYWxUeC5mcm9tKTtcbiAgICBjb25zdCBpbml0aWFsVHhBc0V0aFR4ID0gVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoaW5pdGlhbFR4LCB7XG4gICAgICBjb21tb24sXG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFR4QXNTZXJpYWxpemVkSGV4ID0gYnVmZmVyVG9IZXgoaW5pdGlhbFR4QXNFdGhUeC5zZXJpYWxpemUoKSk7XG5cbiAgICBpZiAodGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuaGFzKGluaXRpYWxUeEFzU2VyaWFsaXplZEhleCkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuYWRkKGluaXRpYWxUeEFzU2VyaWFsaXplZEhleCk7XG4gICAgbGV0IHJhd1R4ZXMsIG5vbmNlTG9jaztcbiAgICB0cnkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFkZCBhIGNoZWNrIHRvIHZlcmlmeSB0aGF0IGFsbCB0cmFuc2FjdGlvbnMgaGF2ZSB0aGUgc2FtZSBmcm9tIGFkZHJlc3NcbiAgICAgIGNvbnN0IGZyb21BZGRyZXNzID0gaW5pdGlhbFR4LmZyb207XG4gICAgICBub25jZUxvY2sgPSBhd2FpdCB0aGlzLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2soZnJvbUFkZHJlc3MpO1xuICAgICAgY29uc3Qgbm9uY2UgPSBub25jZUxvY2submV4dE5vbmNlO1xuXG4gICAgICByYXdUeGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGxpc3RPZlR4UGFyYW1zLm1hcCgodHhQYXJhbXMpID0+IHtcbiAgICAgICAgICB0eFBhcmFtcy5ub25jZSA9IGFkZEhleFByZWZpeChub25jZS50b1N0cmluZygxNikpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25FeHRlcm5hbFRyYW5zYWN0aW9uKHR4UGFyYW1zKTtcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICAvLyBtdXN0IHNldCB0cmFuc2FjdGlvbiB0byBzdWJtaXR0ZWQvZmFpbGVkIGJlZm9yZSByZWxlYXNpbmcgbG9ja1xuICAgICAgLy8gY29udGludWUgd2l0aCBlcnJvciBjaGFpblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAobm9uY2VMb2NrKSB7XG4gICAgICAgIG5vbmNlTG9jay5yZWxlYXNlTG9jaygpO1xuICAgICAgfVxuICAgICAgdGhpcy5pblByb2Nlc3NPZlNpZ25pbmcuZGVsZXRlKGluaXRpYWxUeEFzU2VyaWFsaXplZEhleCk7XG4gICAgfVxuICAgIHJldHVybiByYXdUeGVzO1xuICB9XG5cbiAgYXN5bmMgc2lnbkV4dGVybmFsVHJhbnNhY3Rpb24oX3R4UGFyYW1zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0gdHhVdGlscy5ub3JtYWxpemVUeFBhcmFtcyhfdHhQYXJhbXMpO1xuICAgIC8vIGFkZCBuZXR3b3JrL2NoYWluIGlkXG4gICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHR5cGUgPSBpc0VJUDE1NTlUcmFuc2FjdGlvbih7IHR4UGFyYW1zOiBub3JtYWxpemVkVHhQYXJhbXMgfSlcbiAgICAgID8gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVFxuICAgICAgOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1k7XG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICAuLi5ub3JtYWxpemVkVHhQYXJhbXMsXG4gICAgICB0eXBlLFxuICAgICAgZ2FzTGltaXQ6IG5vcm1hbGl6ZWRUeFBhcmFtcy5nYXMsXG4gICAgICBjaGFpbklkOiBhZGRIZXhQcmVmaXgoZGVjaW1hbFRvSGV4KGNoYWluSWQpKSxcbiAgICB9O1xuICAgIC8vIHNpZ24gdHhcbiAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHR4UGFyYW1zLmZyb207XG4gICAgY29uc3QgY29tbW9uID0gYXdhaXQgdGhpcy5nZXRDb21tb25Db25maWd1cmF0aW9uKGZyb21BZGRyZXNzKTtcbiAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhQYXJhbXMsIHsgY29tbW9uIH0pO1xuICAgIGNvbnN0IHNpZ25lZEV0aFR4ID0gYXdhaXQgdGhpcy5zaWduRXRoVHgodW5zaWduZWRFdGhUeCwgZnJvbUFkZHJlc3MpO1xuXG4gICAgY29uc3QgcmF3VHggPSBidWZmZXJUb0hleChzaWduZWRFdGhUeC5zZXJpYWxpemUoKSk7XG4gICAgcmV0dXJuIHJhd1R4O1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZHMgdGhlIGNoYWluIGlkIGFuZCBzaWducyB0aGUgdHJhbnNhY3Rpb24gYW5kIHNldCB0aGUgc3RhdHVzIHRvIHNpZ25lZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHJhd1R4XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHhJZCkge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgLy8gYWRkIG5ldHdvcmsvY2hhaW4gaWRcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdHlwZSA9IGlzRUlQMTU1OVRyYW5zYWN0aW9uKHR4TWV0YSlcbiAgICAgID8gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVFxuICAgICAgOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1k7XG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICAuLi50eE1ldGEudHhQYXJhbXMsXG4gICAgICB0eXBlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxuICAgIH07XG4gICAgLy8gc2lnbiB0eFxuICAgIGNvbnN0IGZyb21BZGRyZXNzID0gdHhQYXJhbXMuZnJvbTtcbiAgICBjb25zdCBjb21tb24gPSBhd2FpdCB0aGlzLmdldENvbW1vbkNvbmZpZ3VyYXRpb24odHhQYXJhbXMuZnJvbSk7XG4gICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4UGFyYW1zLCB7IGNvbW1vbiB9KTtcbiAgICBjb25zdCBzaWduZWRFdGhUeCA9IGF3YWl0IHRoaXMuc2lnbkV0aFR4KHVuc2lnbmVkRXRoVHgsIGZyb21BZGRyZXNzKTtcblxuICAgIC8vIGFkZCByLHMsdiB2YWx1ZXMgZm9yIHByb3ZpZGVyIHJlcXVlc3QgcHVycG9zZXMgc2VlIGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZVxuICAgIC8vIGFuZCBKU09OIHJwYyBzdGFuZGFyZCBmb3IgZnVydGhlciBleHBsYW5hdGlvblxuICAgIHR4TWV0YS5yID0gYnVmZmVyVG9IZXgoc2lnbmVkRXRoVHgucik7XG4gICAgdHhNZXRhLnMgPSBidWZmZXJUb0hleChzaWduZWRFdGhUeC5zKTtcbiAgICB0eE1ldGEudiA9IGJ1ZmZlclRvSGV4KHNpZ25lZEV0aFR4LnYpO1xuXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICd0cmFuc2FjdGlvbnMjc2lnblRyYW5zYWN0aW9uOiBhZGQgciwgcywgdiB2YWx1ZXMnLFxuICAgICk7XG5cbiAgICAvLyBzZXQgc3RhdGUgdG8gc2lnbmVkXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c1NpZ25lZCh0eE1ldGEuaWQpO1xuICAgIGNvbnN0IHJhd1R4ID0gYnVmZmVyVG9IZXgoc2lnbmVkRXRoVHguc2VyaWFsaXplKCkpO1xuICAgIHJldHVybiByYXdUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBwdWJsaXNoZXMgdGhlIHJhdyB0eCBhbmQgc2V0cyB0aGUgdHhNZXRhIHRvIHN1Ym1pdHRlZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdUeCAtIHRoZSBoZXggc3RyaW5nIG9mIHRoZSBzZXJpYWxpemVkIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hUcmFuc2FjdGlvbih0eElkLCByYXdUeCkge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgdHhNZXRhLnJhd1R4ID0gcmF3VHg7XG4gICAgaWYgKHR4TWV0YS50eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5TV0FQKSB7XG4gICAgICBjb25zdCBwcmVUeEJhbGFuY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldEJhbGFuY2UodHhNZXRhLnR4UGFyYW1zLmZyb20pO1xuICAgICAgdHhNZXRhLnByZVR4QmFsYW5jZSA9IHByZVR4QmFsYW5jZS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICB0eE1ldGEsXG4gICAgICAndHJhbnNhY3Rpb25zI3B1Ymxpc2hUcmFuc2FjdGlvbicsXG4gICAgKTtcbiAgICBsZXQgdHhIYXNoO1xuICAgIHRyeSB7XG4gICAgICB0eEhhc2ggPSBhd2FpdCB0aGlzLnF1ZXJ5LnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUeCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2tub3duIHRyYW5zYWN0aW9uJykpIHtcbiAgICAgICAgdHhIYXNoID0ga2VjY2FrKHRvQnVmZmVyKGFkZEhleFByZWZpeChyYXdUeCksICdoZXgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB0eEhhc2ggPSBhZGRIZXhQcmVmaXgodHhIYXNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldFR4SGFzaCh0eElkLCB0eEhhc2gpO1xuXG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c1N1Ym1pdHRlZCh0eElkKTtcblxuICAgIHRoaXMuX3RyYWNrVHJhbnNhY3Rpb25NZXRyaWNzRXZlbnQodHhNZXRhLCBUUkFOU0FDVElPTl9FVkVOVFMuU1VCTUlUVEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0dXMgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbmZpcm1lZCBhbmQgc2V0cyB0aGUgc3RhdHVzIG9mIG5vbmNlIGR1cGxpY2F0ZXMgYXNcbiAgICogZHJvcHBlZCBpZiB0aGUgdHhQYXJhbXMgaGF2ZSBkYXRhIGl0IHdpbGwgZmV0Y2ggdGhlIHR4UmVjZWlwdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIFRoZSB0eCdzIElEXG4gICAqIEBwYXJhbSB0eFJlY2VpcHRcbiAgICogQHBhcmFtIGJhc2VGZWVQZXJHYXNcbiAgICogQHBhcmFtIGJsb2NrVGltZXN0YW1wXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uKHR4SWQsIHR4UmVjZWlwdCwgYmFzZUZlZVBlckdhcywgYmxvY2tUaW1lc3RhbXApIHtcbiAgICAvLyBnZXQgdGhlIHR4UmVjZWlwdCBiZWZvcmUgbWFya2luZyB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWVkXG4gICAgLy8gdG8gZW5zdXJlIHRoZSByZWNlaXB0IGlzIGdvdHRlbiBiZWZvcmUgdGhlIHVpIHJldml2ZXMgdGhlIHR4XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcblxuICAgIGlmICghdHhNZXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGdhc1VzZWQgPSB0eFV0aWxzLm5vcm1hbGl6ZVR4UmVjZWlwdEdhc1VzZWQodHhSZWNlaXB0Lmdhc1VzZWQpO1xuXG4gICAgICB0eE1ldGEudHhSZWNlaXB0ID0ge1xuICAgICAgICAuLi50eFJlY2VpcHQsXG4gICAgICAgIGdhc1VzZWQsXG4gICAgICB9O1xuXG4gICAgICBpZiAoYmFzZUZlZVBlckdhcykge1xuICAgICAgICB0eE1ldGEuYmFzZUZlZVBlckdhcyA9IGJhc2VGZWVQZXJHYXM7XG4gICAgICB9XG4gICAgICBpZiAoYmxvY2tUaW1lc3RhbXApIHtcbiAgICAgICAgdHhNZXRhLmJsb2NrVGltZXN0YW1wID0gYmxvY2tUaW1lc3RhbXA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIuc2V0VHhTdGF0dXNDb25maXJtZWQodHhJZCk7XG4gICAgICB0aGlzLl9tYXJrTm9uY2VEdXBsaWNhdGVzRHJvcHBlZCh0eElkKTtcblxuICAgICAgY29uc3QgeyBzdWJtaXR0ZWRUaW1lIH0gPSB0eE1ldGE7XG4gICAgICBjb25zdCBtZXRyaWNzUGFyYW1zID0geyBnYXNfdXNlZDogZ2FzVXNlZCB9O1xuXG4gICAgICBpZiAoc3VibWl0dGVkVGltZSkge1xuICAgICAgICBtZXRyaWNzUGFyYW1zLmNvbXBsZXRpb25fdGltZSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uQ29tcGxldGlvblRpbWUoXG4gICAgICAgICAgc3VibWl0dGVkVGltZSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR4UmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XG4gICAgICAgIG1ldHJpY3NQYXJhbXMuc3RhdHVzID0gTUVUUklDU19TVEFUVVNfRkFJTEVEO1xuICAgICAgICAvLyBtZXRyaWNzUGFyYW1zLmVycm9yID0gVE9ETzogZmlndXJlIG91dCBhIHdheSB0byBnZXQgdGhlIG9uLWNoYWluIGZhaWx1cmUgcmVhc29uXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyYWNrVHJhbnNhY3Rpb25NZXRyaWNzRXZlbnQoXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRCxcbiAgICAgICAgbWV0cmljc1BhcmFtcyxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgJ3RyYW5zYWN0aW9ucyNjb25maXJtVHJhbnNhY3Rpb24gLSBhZGQgdHhSZWNlaXB0JyxcbiAgICAgICk7XG5cbiAgICAgIGlmICh0eE1ldGEudHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuU1dBUCkge1xuICAgICAgICBjb25zdCBwb3N0VHhCYWxhbmNlID0gYXdhaXQgdGhpcy5xdWVyeS5nZXRCYWxhbmNlKHR4TWV0YS50eFBhcmFtcy5mcm9tKTtcbiAgICAgICAgY29uc3QgbGF0ZXN0VHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcblxuICAgICAgICBjb25zdCBhcHByb3ZhbFR4TWV0YSA9IGxhdGVzdFR4TWV0YS5hcHByb3ZhbFR4SWRcbiAgICAgICAgICA/IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24obGF0ZXN0VHhNZXRhLmFwcHJvdmFsVHhJZClcbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgbGF0ZXN0VHhNZXRhLnBvc3RUeEJhbGFuY2UgPSBwb3N0VHhCYWxhbmNlLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICAgIGxhdGVzdFR4TWV0YSxcbiAgICAgICAgICAndHJhbnNhY3Rpb25zI2NvbmZpcm1UcmFuc2FjdGlvbiAtIGFkZCBwb3N0VHhCYWxhbmNlJyxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl90cmFja1N3YXBzTWV0cmljcyhsYXRlc3RUeE1ldGEsIGFwcHJvdmFsVHhNZXRhKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uKHR4TWV0YSwgdHhSZWNlaXB0LCBiYXNlRmVlUGVyR2FzKSB7XG4gICAgLy8gYWRkIGV4dGVybmFsIHRyYW5zYWN0aW9uXG4gICAgYXdhaXQgdGhpcy50eFN0YXRlTWFuYWdlci5hZGRFeHRlcm5hbFRyYW5zYWN0aW9uKHR4TWV0YSk7XG5cbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHR4SWQgPSB0eE1ldGEuaWQ7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZ2FzVXNlZCA9IHR4VXRpbHMubm9ybWFsaXplVHhSZWNlaXB0R2FzVXNlZCh0eFJlY2VpcHQuZ2FzVXNlZCk7XG5cbiAgICAgIHR4TWV0YS50eFJlY2VpcHQgPSB7XG4gICAgICAgIC4uLnR4UmVjZWlwdCxcbiAgICAgICAgZ2FzVXNlZCxcbiAgICAgIH07XG5cbiAgICAgIGlmIChiYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgIHR4TWV0YS5iYXNlRmVlUGVyR2FzID0gYmFzZUZlZVBlckdhcztcbiAgICAgIH1cblxuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c0NvbmZpcm1lZCh0eElkKTtcbiAgICAgIHRoaXMuX21hcmtOb25jZUR1cGxpY2F0ZXNEcm9wcGVkKHR4SWQpO1xuXG4gICAgICBjb25zdCB7IHN1Ym1pdHRlZFRpbWUgfSA9IHR4TWV0YTtcbiAgICAgIGNvbnN0IG1ldHJpY3NQYXJhbXMgPSB7IGdhc191c2VkOiBnYXNVc2VkIH07XG5cbiAgICAgIGlmIChzdWJtaXR0ZWRUaW1lKSB7XG4gICAgICAgIG1ldHJpY3NQYXJhbXMuY29tcGxldGlvbl90aW1lID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25Db21wbGV0aW9uVGltZShcbiAgICAgICAgICBzdWJtaXR0ZWRUaW1lLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHhSZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgbWV0cmljc1BhcmFtcy5zdGF0dXMgPSBNRVRSSUNTX1NUQVRVU19GQUlMRUQ7XG4gICAgICAgIC8vIG1ldHJpY3NQYXJhbXMuZXJyb3IgPSBUT0RPOiBmaWd1cmUgb3V0IGEgd2F5IHRvIGdldCB0aGUgb24tY2hhaW4gZmFpbHVyZSByZWFzb25cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudChcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICBUUkFOU0FDVElPTl9FVkVOVFMuRklOQUxJWkVELFxuICAgICAgICBtZXRyaWNzUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICAndHJhbnNhY3Rpb25zI2NvbmZpcm1UcmFuc2FjdGlvbiAtIGFkZCB0eFJlY2VpcHQnLFxuICAgICAgKTtcblxuICAgICAgaWYgKHR4TWV0YS50eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5TV0FQKSB7XG4gICAgICAgIGNvbnN0IHBvc3RUeEJhbGFuY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldEJhbGFuY2UodHhNZXRhLnR4UGFyYW1zLmZyb20pO1xuICAgICAgICBjb25zdCBsYXRlc3RUeE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuXG4gICAgICAgIGNvbnN0IGFwcHJvdmFsVHhNZXRhID0gbGF0ZXN0VHhNZXRhLmFwcHJvdmFsVHhJZFxuICAgICAgICAgID8gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbihsYXRlc3RUeE1ldGEuYXBwcm92YWxUeElkKVxuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBsYXRlc3RUeE1ldGEucG9zdFR4QmFsYW5jZSA9IHBvc3RUeEJhbGFuY2UudG9TdHJpbmcoMTYpO1xuXG4gICAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgbGF0ZXN0VHhNZXRhLFxuICAgICAgICAgICd0cmFuc2FjdGlvbnMjY29uZmlybVRyYW5zYWN0aW9uIC0gYWRkIHBvc3RUeEJhbGFuY2UnLFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3RyYWNrU3dhcHNNZXRyaWNzKGxhdGVzdFR4TWV0YSwgYXBwcm92YWxUeE1ldGEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgdGhlIHVpIHRoYXRzIHNldHMgdGhlIHRyYW5zYWN0aW9uIHRvIHJlamVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHR4J3MgSWRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBjYW5jZWxUcmFuc2FjdGlvbih0eElkKSB7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCk7XG4gICAgdGhpcy5fdHJhY2tUcmFuc2FjdGlvbk1ldHJpY3NFdmVudCh0eE1ldGEsIFRSQU5TQUNUSU9OX0VWRU5UUy5SRUpFQ1RFRCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHhIYXMgb24gdGhlIHR4TWV0YVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0eCdzIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggLSB0aGUgaGFzaCBmb3IgdGhlIHR4TWV0YVxuICAgKi9cbiAgc2V0VHhIYXNoKHR4SWQsIHR4SGFzaCkge1xuICAgIC8vIEFkZCB0aGUgdHggaGFzaCB0byB0aGUgcGVyc2lzdGVkIG1ldGEtdHggb2JqZWN0XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0eE1ldGEuaGFzaCA9IHR4SGFzaDtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSwgJ3RyYW5zYWN0aW9ucyNzZXRUeEhhc2gnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRoZSBVSSB0byBlYXNpbHkgY3JlYXRlIGV2ZW50IGZyYWdtZW50cyB3aGVuIHRoZVxuICAgKiBmcmFnbWVudCBkb2VzIG5vdCBleGlzdCBpbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zYWN0aW9uSWQgLSBUaGUgdHJhbnNhY3Rpb24gaWQgdG8gY3JlYXRlIHRoZSBldmVudFxuICAgKiAgZnJhZ21lbnQgZm9yXG4gICAqIEBwYXJhbSB7dmFsdWVPZjxUUkFOU0FDVElPTl9FVkVOVFM+fSBldmVudCAtIGV2ZW50IHR5cGUgdG8gY3JlYXRlXG4gICAqL1xuICBhc3luYyBjcmVhdGVUcmFuc2FjdGlvbkV2ZW50RnJhZ21lbnQodHJhbnNhY3Rpb25JZCwgZXZlbnQpIHtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzLFxuICAgIH0gPSBhd2FpdCB0aGlzLl9idWlsZEV2ZW50RnJhZ21lbnRQcm9wZXJ0aWVzKHR4TWV0YSk7XG4gICAgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50KFxuICAgICAgdHhNZXRhLFxuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICApO1xuICB9XG5cbiAgLy9cbiAgLy8gICAgICAgICAgIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuICAvKiogbWFwcyBtZXRob2RzIGZvciBjb252ZW5pZW5jZSovXG4gIF9tYXBNZXRob2RzKCkge1xuICAgIC8qKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgc3RhdGUgaW4gdHJhbnNhY3Rpb24gY29udHJvbGxlciAqL1xuICAgIHRoaXMuZ2V0U3RhdGUgPSAoKSA9PiB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvKiogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHRoZSBuZXR3b3JrIG51bWJlciBzdG9yZWQgaW4gbmV0d29ya1N0b3JlICovXG4gICAgdGhpcy5nZXROZXR3b3JrID0gKCkgPT4gdGhpcy5uZXR3b3JrU3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8qKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdXNlciBzZWxlY3RlZCBhZGRyZXNzICovXG4gICAgdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MgPSAoKSA9PlxuICAgICAgdGhpcy5wcmVmZXJlbmNlc1N0b3JlLmdldFN0YXRlKCkuc2VsZWN0ZWRBZGRyZXNzO1xuXG4gICAgLyoqIEByZXR1cm5zIHtBcnJheX0gdHJhbnNhY3Rpb25zIHdob3Mgc3RhdHVzIGlzIHVuYXBwcm92ZWQgKi9cbiAgICB0aGlzLmdldFVuYXBwcm92ZWRUeENvdW50ID0gKCkgPT5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VW5hcHByb3ZlZFR4TGlzdCgpKS5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSB0aGUgc3RhdHVzIHN1Ym1pdHRlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IC0gaGV4IHByZWZpeGVkIGFjY291bnRcbiAgICAgKi9cbiAgICB0aGlzLmdldFBlbmRpbmdUeENvdW50ID0gKGFjY291bnQpID0+XG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoYWNjb3VudCkubGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogc2VlIHR4U3RhdGVNYW5hZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqL1xuICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25zID0gKG9wdHMpID0+IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb25zKG9wdHMpO1xuXG4gICAgLyoqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBzYXZlZCBkZWZhdWx0IHZhbHVlcyBmb3IgYWR2YW5jZWRHYXNGZWUgKi9cbiAgICB0aGlzLmdldEFkdmFuY2VkR2FzRmVlID0gKCkgPT5cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpLmFkdmFuY2VkR2FzRmVlO1xuICB9XG5cbiAgLy8gY2FsbGVkIG9uY2Ugb24gc3RhcnR1cFxuICBhc3luYyBfdXBkYXRlUGVuZGluZ1R4c0FmdGVyRmlyc3RCbG9jaygpIHtcbiAgICAvLyB3YWl0IGZvciBmaXJzdCBibG9jayBzbyB3ZSBrbm93IHdlJ3JlIHJlYWR5XG4gICAgYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAvLyBnZXQgc3RhdHVzIHVwZGF0ZSBmb3IgYWxsIHBlbmRpbmcgdHJhbnNhY3Rpb25zIChmb3IgdGhlIGN1cnJlbnQgbmV0d29yaylcbiAgICBhd2FpdCB0aGlzLnBlbmRpbmdUeFRyYWNrZXIudXBkYXRlUGVuZGluZ1R4cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRyYW5zYWN0aW9uIGNvbnRyb2xsZXIgd2FzIHJlYm9vdGVkIHdpdGggdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHVuY29tcGxldGVkXG4gICAqIGluIHN0ZXBzIG9mIHRoZSB0cmFuc2FjdGlvbiBzaWduaW5nIG9yIHVzZXIgY29uZmlybWF0aW9uIHByb2Nlc3MgaXQgd2lsbCBlaXRoZXJcbiAgICogdHJhbnNpdGlvbiB0eE1ldGFzIHRvIGEgZmFpbGVkIHN0YXRlIG9yIHRyeSB0byByZWRvIHRob3NlIHRhc2tzLlxuICAgKi9cblxuICBfb25Cb290Q2xlYW5VcCgpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyXG4gICAgICAuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgICAgc2VhcmNoQ3JpdGVyaWE6IHtcbiAgICAgICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQsXG4gICAgICAgICAgbG9hZGluZ0RlZmF1bHRzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKCh0eCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFR4R2FzRGVmYXVsdHModHgpXG4gICAgICAgICAgLnRoZW4oKHR4TWV0YSkgPT4ge1xuICAgICAgICAgICAgdHhNZXRhLmxvYWRpbmdEZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgdHhNZXRhLFxuICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zOiBnYXMgZXN0aW1hdGlvbiBmb3IgdHggb24gYm9vdCcsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eC5pZCk7XG4gICAgICAgICAgICB0eE1ldGEubG9hZGluZ0RlZmF1bHRzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICB0eE1ldGEsXG4gICAgICAgICAgICAgICdmYWlsZWQgdG8gZXN0aW1hdGUgZ2FzIGR1cmluZyBib290IGNsZWFudXAuJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9mYWlsVHJhbnNhY3Rpb24odHhNZXRhLmlkLCBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMudHhTdGF0ZU1hbmFnZXJcbiAgICAgIC5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgICBzZWFyY2hDcml0ZXJpYToge1xuICAgICAgICAgIHN0YXR1czogVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmZvckVhY2goKHR4TWV0YSkgPT4ge1xuICAgICAgICBjb25zdCB0eFNpZ25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVHJhbnNhY3Rpb24gZm91bmQgYXMgXCJhcHByb3ZlZFwiIGR1cmluZyBib290IC0gcG9zc2libHkgc3R1Y2sgZHVyaW5nIHNpZ25pbmcnLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9mYWlsVHJhbnNhY3Rpb24odHhNZXRhLmlkLCB0eFNpZ25FcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpcyBjYWxsZWQgaW4gY29uc3RydWN0b3IgYXBwbGllcyB0aGUgbGlzdGVuZXJzIGZvciBwZW5kaW5nVHhUcmFja2VyIHR4U3RhdGVNYW5hZ2VyXG4gICAqIGFuZCBibG9ja1RyYWNrZXJcbiAgICovXG4gIF9zZXR1cExpc3RlbmVycygpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLm9uKFxuICAgICAgJ3R4OnN0YXR1cy11cGRhdGUnLFxuICAgICAgdGhpcy5lbWl0LmJpbmQodGhpcywgJ3R4OnN0YXR1cy11cGRhdGUnKSxcbiAgICApO1xuICAgIHRoaXMuX3NldHVwQmxvY2tUcmFja2VyTGlzdGVuZXIoKTtcbiAgICB0aGlzLnBlbmRpbmdUeFRyYWNrZXIub24oJ3R4Ondhcm5pbmcnLCAodHhNZXRhKSA9PiB7XG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICB0eE1ldGEsXG4gICAgICAgICd0cmFuc2FjdGlvbnMvcGVuZGluZy10eC10cmFja2VyI2V2ZW50OiB0eDp3YXJuaW5nJyxcbiAgICAgICk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVHhUcmFja2VyLm9uKCd0eDpmYWlsZWQnLCAodHhJZCwgZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuX2ZhaWxUcmFuc2FjdGlvbih0eElkLCBlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVHhUcmFja2VyLm9uKFxuICAgICAgJ3R4OmNvbmZpcm1lZCcsXG4gICAgICAodHhJZCwgdHJhbnNhY3Rpb25SZWNlaXB0LCBiYXNlRmVlUGVyR2FzLCBibG9ja1RpbWVzdGFtcCkgPT5cbiAgICAgICAgdGhpcy5jb25maXJtVHJhbnNhY3Rpb24oXG4gICAgICAgICAgdHhJZCxcbiAgICAgICAgICB0cmFuc2FjdGlvblJlY2VpcHQsXG4gICAgICAgICAgYmFzZUZlZVBlckdhcyxcbiAgICAgICAgICBibG9ja1RpbWVzdGFtcCxcbiAgICAgICAgKSxcbiAgICApO1xuICAgIHRoaXMucGVuZGluZ1R4VHJhY2tlci5vbigndHg6ZHJvcHBlZCcsICh0eElkKSA9PiB7XG4gICAgICB0aGlzLl9kcm9wVHJhbnNhY3Rpb24odHhJZCk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVHhUcmFja2VyLm9uKCd0eDpibG9jay11cGRhdGUnLCAodHhNZXRhLCBsYXRlc3RCbG9ja051bWJlcikgPT4ge1xuICAgICAgaWYgKCF0eE1ldGEuZmlyc3RSZXRyeUJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHR4TWV0YS5maXJzdFJldHJ5QmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgdGhpcy50eFN0YXRlTWFuYWdlci51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgICB0eE1ldGEsXG4gICAgICAgICAgJ3RyYW5zYWN0aW9ucy9wZW5kaW5nLXR4LXRyYWNrZXIjZXZlbnQ6IHR4OmJsb2NrLXVwZGF0ZScsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nVHhUcmFja2VyLm9uKCd0eDpyZXRyeScsICh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghKCdyZXRyeUNvdW50JyBpbiB0eE1ldGEpKSB7XG4gICAgICAgIHR4TWV0YS5yZXRyeUNvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHR4TWV0YS5yZXRyeUNvdW50ICs9IDE7XG4gICAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICB0eE1ldGEsXG4gICAgICAgICd0cmFuc2FjdGlvbnMvcGVuZGluZy10eC10cmFja2VyI2V2ZW50OiB0eDpyZXRyeScsXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsgJ3RyYW5zZmVyJyB8ICdhcHByb3ZlJyB8ICd0cmFuc2ZlcmZyb20nIHwgJ2NvbnRyYWN0SW50ZXJhY3Rpb24nfCAnc2ltcGxlU2VuZCcgfSBJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc1xuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gSW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHRcbiAgICogQHByb3BlcnR5IHtJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc30gdHlwZSAtIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZXRDb2RlUmVzcG9uc2UgLSBUaGUgY29udHJhY3QgY29kZSwgaW4gaGV4IGZvcm1hdCBpZlxuICAgKiAgaXQgZXhpc3RzLiAnMHgwJyBvciAnMHgnIGFyZSBhbHNvIGluZGljYXRvcnMgb2Ygbm9uLWV4aXN0ZW50IGNvbnRyYWN0XG4gICAqICBjb2RlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbiBieSBhbmFseXppbmcgdGhlIHR4UGFyYW1zLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBvbmUgb2YgdGhlIHR5cGVzIGRlZmluZWQgaW4gc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbnNcbiAgICogSXQgd2lsbCBuZXZlciByZXR1cm4gVFJBTlNBQ1RJT05fVFlQRV9DQU5DRUwgb3IgVFJBTlNBQ1RJT05fVFlQRV9SRVRSWSBhcyB0aGVzZVxuICAgKiByZXByZXNlbnQgc3BlY2lmaWMgZXZlbnRzIHRoYXQgd2UgY29udHJvbCBmcm9tIHRoZSBleHRlbnNpb24gYW5kIGFyZSBhZGRlZCBtYW51YWxseVxuICAgKiBhdCB0cmFuc2FjdGlvbiBjcmVhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4UGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cbiAgICovXG4gIGFzeW5jIF9kZXRlcm1pbmVUcmFuc2FjdGlvblR5cGUodHhQYXJhbXMpIHtcbiAgICBjb25zdCB7IGRhdGEsIHRvIH0gPSB0eFBhcmFtcztcbiAgICBsZXQgbmFtZTtcbiAgICB0cnkge1xuICAgICAgbmFtZSA9IGRhdGEgJiYgaHN0SW50ZXJmYWNlLnBhcnNlVHJhbnNhY3Rpb24oeyBkYXRhIH0pLm5hbWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5kZWJ1ZygnRmFpbGVkIHRvIHBhcnNlIHRyYW5zYWN0aW9uIGRhdGEuJywgZXJyb3IsIGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuTWV0aG9kTmFtZSA9IFtcbiAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFLFxuICAgICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSLFxuICAgICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00sXG4gICAgXS5maW5kKChtZXRob2ROYW1lKSA9PiBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKG1ldGhvZE5hbWUsIG5hbWUpKTtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGRhdGEgJiYgdG9rZW5NZXRob2ROYW1lKSB7XG4gICAgICByZXN1bHQgPSB0b2tlbk1ldGhvZE5hbWU7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICF0bykge1xuICAgICAgcmVzdWx0ID0gVFJBTlNBQ1RJT05fVFlQRVMuREVQTE9ZX0NPTlRSQUNUO1xuICAgIH1cblxuICAgIGxldCBjb250cmFjdENvZGU7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cmFjdENvZGU6IHJlc3VsdENvZGUsXG4gICAgICAgIGlzQ29udHJhY3RBZGRyZXNzLFxuICAgICAgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdCh0aGlzLnF1ZXJ5LCB0byk7XG5cbiAgICAgIGNvbnRyYWN0Q29kZSA9IHJlc3VsdENvZGU7XG4gICAgICByZXN1bHQgPSBpc0NvbnRyYWN0QWRkcmVzc1xuICAgICAgICA/IFRSQU5TQUNUSU9OX1RZUEVTLkNPTlRSQUNUX0lOVEVSQUNUSU9OXG4gICAgICAgIDogVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0LCBnZXRDb2RlUmVzcG9uc2U6IGNvbnRyYWN0Q29kZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3RoZXIgdHhNZXRhIHN0YXR1c2VzIHRvIGRyb3BwZWQgaWYgdGhlIHR4TWV0YSB0aGF0IGhhcyBiZWVuIGNvbmZpcm1lZCBoYXMgb3RoZXIgdHJhbnNhY3Rpb25zXG4gICAqIGluIHRoZSBsaXN0IGhhdmUgdGhlIHNhbWUgbm9uY2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdHhJZCBvZiB0aGUgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYmVlbiBjb25maXJtZWQgaW4gYSBibG9ja1xuICAgKi9cbiAgX21hcmtOb25jZUR1cGxpY2F0ZXNEcm9wcGVkKHR4SWQpIHtcbiAgICAvLyBnZXQgdGhlIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMgbm9uY2UgYW5kIGZyb20gYWRkcmVzc1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgY29uc3QgeyBub25jZSwgZnJvbSB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgIGNvbnN0IHNhbWVOb25jZVR4cyA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIHNlYXJjaENyaXRlcmlhOiB7IG5vbmNlLCBmcm9tIH0sXG4gICAgfSk7XG4gICAgaWYgKCFzYW1lTm9uY2VUeHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1hcmsgYWxsIHNhbWUgbm9uY2UgdHJhbnNhY3Rpb25zIGFzIGRyb3BwZWQgYW5kIGdpdmUgaSBhIHJlcGxhY2VkQnkgaGFzaFxuICAgIHNhbWVOb25jZVR4cy5mb3JFYWNoKChvdGhlclR4TWV0YSkgPT4ge1xuICAgICAgaWYgKG90aGVyVHhNZXRhLmlkID09PSB0eElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG90aGVyVHhNZXRhLnJlcGxhY2VkQnkgPSB0eE1ldGEuaGFzaDtcbiAgICAgIHRoaXMudHhTdGF0ZU1hbmFnZXIudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgJ3RyYW5zYWN0aW9ucy9wZW5kaW5nLXR4LXRyYWNrZXIjZXZlbnQ6IHR4OmNvbmZpcm1lZCByZWZlcmVuY2UgdG8gY29uZmlybWVkIHR4SGFzaCB3aXRoIHNhbWUgbm9uY2UnLFxuICAgICAgKTtcbiAgICAgIHRoaXMuX2Ryb3BUcmFuc2FjdGlvbihvdGhlclR4TWV0YS5pZCk7XG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBCbG9ja1RyYWNrZXJMaXN0ZW5lcigpIHtcbiAgICBsZXQgbGlzdGVuZXJzQXJlQWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgbGF0ZXN0QmxvY2tIYW5kbGVyID0gdGhpcy5fb25MYXRlc3RCbG9jay5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHsgYmxvY2tUcmFja2VyLCB0eFN0YXRlTWFuYWdlciB9ID0gdGhpcztcblxuICAgIHR4U3RhdGVNYW5hZ2VyLm9uKCd0eDpzdGF0dXMtdXBkYXRlJywgdXBkYXRlU3Vic2NyaXB0aW9uKTtcbiAgICB1cGRhdGVTdWJzY3JpcHRpb24oKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0eFN0YXRlTWFuYWdlci5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICBpZiAoIWxpc3RlbmVyc0FyZUFjdGl2ZSAmJiBwZW5kaW5nVHhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2tUcmFja2VyLm9uKCdsYXRlc3QnLCBsYXRlc3RCbG9ja0hhbmRsZXIpO1xuICAgICAgICBsaXN0ZW5lcnNBcmVBY3RpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnNBcmVBY3RpdmUgJiYgIXBlbmRpbmdUeHMubGVuZ3RoKSB7XG4gICAgICAgIGJsb2NrVHJhY2tlci5yZW1vdmVMaXN0ZW5lcignbGF0ZXN0JywgbGF0ZXN0QmxvY2tIYW5kbGVyKTtcbiAgICAgICAgbGlzdGVuZXJzQXJlQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX29uTGF0ZXN0QmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nVHhUcmFja2VyLnVwZGF0ZVBlbmRpbmdUeHMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nVHhUcmFja2VyLnJlc3VibWl0UGVuZGluZ1R4cyhibG9ja051bWJlcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWVtU3RvcmUgaW4gdHJhbnNhY3Rpb24gY29udHJvbGxlclxuICAgKi9cbiAgX3VwZGF0ZU1lbXN0b3JlKCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeHMgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFVuYXBwcm92ZWRUeExpc3QoKTtcbiAgICBjb25zdCBjdXJyZW50TmV0d29ya1R4TGlzdCA9IHRoaXMudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIGxpbWl0OiBNQVhfTUVNU1RPUkVfVFhfTElTVF9TSVpFLFxuICAgIH0pO1xuICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoeyB1bmFwcHJvdmVkVHhzLCBjdXJyZW50TmV0d29ya1R4TGlzdCB9KTtcbiAgfVxuXG4gIF90cmFja1N3YXBzTWV0cmljcyh0eE1ldGEsIGFwcHJvdmFsVHhNZXRhKSB7XG4gICAgaWYgKHRoaXMuX2dldFBhcnRpY2lwYXRlSW5NZXRyaWNzKCkgJiYgdHhNZXRhLnN3YXBNZXRhRGF0YSkge1xuICAgICAgaWYgKHR4TWV0YS50eFJlY2VpcHQuc3RhdHVzID09PSAnMHgwJykge1xuICAgICAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiAnU3dhcCBGYWlsZWQnLFxuICAgICAgICAgIHNlbnNpdGl2ZVByb3BlcnRpZXM6IHsgLi4udHhNZXRhLnN3YXBNZXRhRGF0YSB9LFxuICAgICAgICAgIGNhdGVnb3J5OiAnc3dhcHMnLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRva2Vuc1JlY2VpdmVkID0gZ2V0U3dhcHNUb2tlbnNSZWNlaXZlZEZyb21UeE1ldGEoXG4gICAgICAgICAgdHhNZXRhLmRlc3RpbmF0aW9uVG9rZW5TeW1ib2wsXG4gICAgICAgICAgdHhNZXRhLFxuICAgICAgICAgIHR4TWV0YS5kZXN0aW5hdGlvblRva2VuQWRkcmVzcyxcbiAgICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbSxcbiAgICAgICAgICB0eE1ldGEuZGVzdGluYXRpb25Ub2tlbkRlY2ltYWxzLFxuICAgICAgICAgIGFwcHJvdmFsVHhNZXRhLFxuICAgICAgICAgIHR4TWV0YS5jaGFpbklkLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHF1b3RlVnNFeGVjdXRpb25SYXRpbyA9IHRva2Vuc1JlY2VpdmVkXG4gICAgICAgICAgPyBgJHtuZXcgQmlnTnVtYmVyKHRva2Vuc1JlY2VpdmVkLCAxMClcbiAgICAgICAgICAgICAgLmRpdih0eE1ldGEuc3dhcE1ldGFEYXRhLnRva2VuX3RvX2Ftb3VudCwgMTApXG4gICAgICAgICAgICAgIC50aW1lcygxMDApXG4gICAgICAgICAgICAgIC5yb3VuZCgyKX0lYFxuICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBjb25zdCBlc3RpbWF0ZWRWc1VzZWRHYXNSYXRpbyA9XG4gICAgICAgICAgdHhNZXRhLnR4UmVjZWlwdC5nYXNVc2VkICYmIHR4TWV0YS5zd2FwTWV0YURhdGEuZXN0aW1hdGVkX2dhc1xuICAgICAgICAgICAgPyBgJHtuZXcgQmlnTnVtYmVyKHR4TWV0YS50eFJlY2VpcHQuZ2FzVXNlZCwgMTYpXG4gICAgICAgICAgICAgICAgLmRpdih0eE1ldGEuc3dhcE1ldGFEYXRhLmVzdGltYXRlZF9nYXMsIDEwKVxuICAgICAgICAgICAgICAgIC50aW1lcygxMDApXG4gICAgICAgICAgICAgICAgLnJvdW5kKDIpfSVgXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICBldmVudDogJ1N3YXAgQ29tcGxldGVkJyxcbiAgICAgICAgICBjYXRlZ29yeTogJ3N3YXBzJyxcbiAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAuLi50eE1ldGEuc3dhcE1ldGFEYXRhLFxuICAgICAgICAgICAgdG9rZW5fdG9fYW1vdW50X3JlY2VpdmVkOiB0b2tlbnNSZWNlaXZlZCxcbiAgICAgICAgICAgIHF1b3RlX3ZzX2V4ZWN1dGlvblJhdGlvOiBxdW90ZVZzRXhlY3V0aW9uUmF0aW8sXG4gICAgICAgICAgICBlc3RpbWF0ZWRfdnNfdXNlZF9nYXNSYXRpbzogZXN0aW1hdGVkVnNVc2VkR2FzUmF0aW8sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2J1aWxkRXZlbnRGcmFnbWVudFByb3BlcnRpZXModHhNZXRhLCBleHRyYVBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB0aW1lLFxuICAgICAgc3RhdHVzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG9yaWdpbjogcmVmZXJyZXIsXG4gICAgICB0eFBhcmFtczoge1xuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgZ2FzOiBnYXNMaW1pdCxcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgZXN0aW1hdGVTdWdnZXN0ZWQsXG4gICAgICAgIGVzdGltYXRlVXNlZCxcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0R2FzRXN0aW1hdGVzLFxuICAgICAgbWV0YW1hc2tOZXR3b3JrSWQ6IG5ldHdvcmssXG4gICAgfSA9IHR4TWV0YTtcbiAgICBjb25zdCBzb3VyY2UgPSByZWZlcnJlciA9PT0gJ21ldGFtYXNrJyA/ICd1c2VyJyA6ICdkYXBwJztcblxuICAgIGNvbnN0IGdhc1BhcmFtcyA9IHt9O1xuXG4gICAgaWYgKGlzRUlQMTU1OVRyYW5zYWN0aW9uKHR4TWV0YSkpIHtcbiAgICAgIGdhc1BhcmFtcy5tYXhfZmVlX3Blcl9nYXMgPSBtYXhGZWVQZXJHYXM7XG4gICAgICBnYXNQYXJhbXMubWF4X3ByaW9yaXR5X2ZlZV9wZXJfZ2FzID0gbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdhc1BhcmFtcy5nYXNfcHJpY2UgPSBnYXNQcmljZTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdEdhc0VzdGltYXRlcykge1xuICAgICAgY29uc3QgeyBlc3RpbWF0ZVR5cGUgfSA9IGRlZmF1bHRHYXNFc3RpbWF0ZXM7XG4gICAgICBpZiAoZXN0aW1hdGVUeXBlKSB7XG4gICAgICAgIGdhc1BhcmFtcy5kZWZhdWx0X2VzdGltYXRlID0gZXN0aW1hdGVUeXBlO1xuICAgICAgICBsZXQgZGVmYXVsdE1heEZlZVBlckdhcyA9IHR4TWV0YS5kZWZhdWx0R2FzRXN0aW1hdGVzLm1heEZlZVBlckdhcztcbiAgICAgICAgbGV0IGRlZmF1bHRNYXhQcmlvcml0eUZlZVBlckdhcyA9XG4gICAgICAgICAgdHhNZXRhLmRlZmF1bHRHYXNFc3RpbWF0ZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIEdBU19SRUNPTU1FTkRBVElPTlMuTE9XLFxuICAgICAgICAgICAgR0FTX1JFQ09NTUVOREFUSU9OUy5NRURJVU0sXG4gICAgICAgICAgICBHQVNfUkVDT01NRU5EQVRJT05TLk1FRElVTS5ISUdILFxuICAgICAgICAgIF0uaW5jbHVkZXMoZXN0aW1hdGVUeXBlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCB7IGdhc0ZlZUVzdGltYXRlcyB9ID0gYXdhaXQgdGhpcy5fZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlcygpO1xuICAgICAgICAgIGlmIChnYXNGZWVFc3RpbWF0ZXM/Lltlc3RpbWF0ZVR5cGVdPy5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgIGRlZmF1bHRNYXhGZWVQZXJHYXMgPVxuICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXNbZXN0aW1hdGVUeXBlXT8uc3VnZ2VzdGVkTWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgZ2FzUGFyYW1zLmRlZmF1bHRfbWF4X2ZlZV9wZXJfZ2FzID0gZGVmYXVsdE1heEZlZVBlckdhcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdhc0ZlZUVzdGltYXRlcz8uW2VzdGltYXRlVHlwZV0/LnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgICAgICBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXMgPVxuICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXNbZXN0aW1hdGVUeXBlXT8uc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICBnYXNQYXJhbXMuZGVmYXVsdF9tYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXMgPSBkZWZhdWx0TWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eE1ldGEuZGVmYXVsdEdhc0VzdGltYXRlcy5nYXMpIHtcbiAgICAgICAgZ2FzUGFyYW1zLmRlZmF1bHRfZ2FzID0gdHhNZXRhLmRlZmF1bHRHYXNFc3RpbWF0ZXMuZ2FzO1xuICAgICAgfVxuICAgICAgaWYgKHR4TWV0YS5kZWZhdWx0R2FzRXN0aW1hdGVzLmdhc1ByaWNlKSB7XG4gICAgICAgIGdhc1BhcmFtcy5kZWZhdWx0X2dhc19wcmljZSA9IHR4TWV0YS5kZWZhdWx0R2FzRXN0aW1hdGVzLmdhc1ByaWNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlc3RpbWF0ZVN1Z2dlc3RlZCkge1xuICAgICAgZ2FzUGFyYW1zLmVzdGltYXRlX3N1Z2dlc3RlZCA9IGVzdGltYXRlU3VnZ2VzdGVkO1xuICAgIH1cblxuICAgIGlmIChlc3RpbWF0ZVVzZWQpIHtcbiAgICAgIGdhc1BhcmFtcy5lc3RpbWF0ZV91c2VkID0gZXN0aW1hdGVVc2VkO1xuICAgIH1cblxuICAgIGNvbnN0IGdhc1BhcmFtc0luR3dlaSA9IHRoaXMuX2dldEdhc1ZhbHVlc0luR1dFSShnYXNQYXJhbXMpO1xuXG4gICAgbGV0IGVpcDE1NTlWZXJzaW9uID0gJzAnO1xuICAgIGlmICh0eE1ldGEudHhQYXJhbXMubWF4RmVlUGVyR2FzKSB7XG4gICAgICBjb25zdCB7IGVpcDE1NTlWMkVuYWJsZWQgfSA9IHRoaXMucHJlZmVyZW5jZXNTdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgZWlwMTU1OVZlcnNpb24gPSBlaXAxNTU5VjJFbmFibGVkID8gJzInIDogJzEnO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBjaGFpbl9pZDogY2hhaW5JZCxcbiAgICAgIHJlZmVycmVyLFxuICAgICAgc291cmNlLFxuICAgICAgbmV0d29yayxcbiAgICAgIHR5cGUsXG4gICAgICBlaXBfMTU1OV92ZXJzaW9uOiBlaXAxNTU5VmVyc2lvbixcbiAgICAgIGdhc19lZGl0X3R5cGU6ICdub25lJyxcbiAgICAgIGdhc19lZGl0X2F0dGVtcHRlZDogJ25vbmUnLFxuICAgIH07XG5cbiAgICBjb25zdCBzZW5zaXRpdmVQcm9wZXJ0aWVzID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdHJhbnNhY3Rpb25fZW52ZWxvcGVfdHlwZTogaXNFSVAxNTU5VHJhbnNhY3Rpb24odHhNZXRhKVxuICAgICAgICA/IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVfTkFNRVMuRkVFX01BUktFVFxuICAgICAgICA6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVfTkFNRVMuTEVHQUNZLFxuICAgICAgZmlyc3Rfc2VlbjogdGltZSxcbiAgICAgIGdhc19saW1pdDogZ2FzTGltaXQsXG4gICAgICAuLi5nYXNQYXJhbXNJbkd3ZWksXG4gICAgICAuLi5leHRyYVBhcmFtcyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgcHJvcGVydGllcywgc2Vuc2l0aXZlUHJvcGVydGllcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdGhhdCBjaGVja3MgZm9yIHRoZSBwcmVzZW5jZSBvZiBhbiBleGlzdGluZyBmcmFnbWVudCBieSBpZFxuICAgKiBhcHByb3ByaWF0ZSBmb3IgdGhlIHR5cGUgb2YgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgZnJhZ21lbnQgY3JlYXRpb24uIElmIHRoZVxuICAgKiBhcHByb3ByaWF0ZSBmcmFnbWVudCBleGlzdHMsIHRoZW4gbm90aGluZyBpcyBkb25lLiBJZiBpdCBkb2VzIG5vdCBleGlzdCBhXG4gICAqIG5ldyBldmVudCBmcmFnbWVudCBpcyBjcmVhdGVkIHdpdGggdGhlIGFwcHJvcHJpYXRlIHBheWxvYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25NZXRhfSB0eE1ldGEgLSBUcmFuc2FjdGlvbiBtZXRhIG9iamVjdFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YU1ldHJpY3NFdmVudFN0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgdHlwZSB0aGF0XG4gICAqICB0cmlnZ2VyZWQgZnJhZ21lbnQgY3JlYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGZyYWdtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2Vuc2l0aXZlUHJvcGVydGllc10gLSBzZW5zaXRpdmUgcHJvcGVydGllcyB0byBpbmNsdWRlIGluXG4gICAqICB0aGUgZnJhZ21lbnRcbiAgICovXG4gIF9jcmVhdGVUcmFuc2FjdGlvbkV2ZW50RnJhZ21lbnQoXG4gICAgdHhNZXRhLFxuICAgIGV2ZW50LFxuICAgIHByb3BlcnRpZXMsXG4gICAgc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgKSB7XG4gICAgY29uc3QgaXNTdWJtaXR0ZWQgPSBbXG4gICAgICBUUkFOU0FDVElPTl9FVkVOVFMuRklOQUxJWkVELFxuICAgICAgVFJBTlNBQ1RJT05fRVZFTlRTLlNVQk1JVFRFRCxcbiAgICBdLmluY2x1ZGVzKGV2ZW50KTtcbiAgICBjb25zdCB1bmlxdWVJZGVudGlmaWVyID0gYHRyYW5zYWN0aW9uLSR7XG4gICAgICBpc1N1Ym1pdHRlZCA/ICdzdWJtaXR0ZWQnIDogJ2FkZGVkJ1xuICAgIH0tJHt0eE1ldGEuaWR9YDtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudEZyYWdtZW50QnlJZCh1bmlxdWVJZGVudGlmaWVyKTtcbiAgICBpZiAodHlwZW9mIGZyYWdtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIC8vIFdoZW4gYSB0cmFuc2FjdGlvbiBpcyBhZGRlZCB0byB0aGUgY29udHJvbGxlciwgd2Uga25vdyB0aGF0IHRoZSB1c2VyXG4gICAgICAvLyB3aWxsIGJlIHByZXNlbnRlZCB3aXRoIGEgY29uZmlybWF0aW9uIHNjcmVlbi4gVGhlIHVzZXIgd2lsbCB0aGVuXG4gICAgICAvLyBlaXRoZXIgY29uZmlybSBvciByZWplY3QgdGhhdCB0cmFuc2FjdGlvbi4gRWFjaCBoYXMgYW4gYXNzb2NpYXRlZFxuICAgICAgLy8gZXZlbnQgd2Ugd2FudCB0byB0cmFjay4gV2hpbGUgd2UgZG9uJ3QgbmVjZXNzYXJpbHkgbmVlZCBhbiBldmVudFxuICAgICAgLy8gZnJhZ21lbnQgdG8gbW9kZWwgdGhpcywgaGF2aW5nIG9uZSBhbGxvd3MgdXMgdG8gcmVjb3JkIGFkZGl0aW9uYWxcbiAgICAgIC8vIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgZnJvbSB0aGUgVUkuIEZvciBleGFtcGxlLCB3aGVuIHRoZSB1c2VyXG4gICAgICAvLyBlZGl0cyB0aGUgdHJhbnNhY3Rpb25zIGdhcyBwYXJhbXMgd2UgY2FuIHJlY29yZCB0aGF0IHByb3BlcnR5IGFuZFxuICAgICAgLy8gdGhlbiBnZXQgYW5hbHl0aWNzIG9uIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHdoaWNoIGdhcyBlZGl0c1xuICAgICAgLy8gb2NjdXIuXG4gICAgICBjYXNlIFRSQU5TQUNUSU9OX0VWRU5UUy5BRERFRDpcbiAgICAgICAgdGhpcy5jcmVhdGVFdmVudEZyYWdtZW50KHtcbiAgICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgaW5pdGlhbEV2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuQURERUQsXG4gICAgICAgICAgc3VjY2Vzc0V2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuQVBQUk9WRUQsXG4gICAgICAgICAgZmFpbHVyZUV2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuUkVKRUNURUQsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzLFxuICAgICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgICAgdW5pcXVlSWRlbnRpZmllcixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSWYgZm9yIHNvbWUgcmVhc29uIGFuIGFwcHJvdmFsIG9yIHJlamVjdGlvbiBvY2N1cnMgd2l0aG91dCB0aGUgYWRkZWRcbiAgICAgIC8vIGZyYWdtZW50IGV4aXN0aW5nIGluIG1lbW9yeSwgd2UgY3JlYXRlIHRoZSBhZGRlZCBmcmFnbWVudCBidXQgd2l0aG91dFxuICAgICAgLy8gdGhlIGluaXRpYWxFdmVudCBmaXJpbmcuIFRoaXMgaXMgdG8gcHJldmVudCBwb3NzaWJsZSBkdXBsaWNhdGlvbiBvZlxuICAgICAgLy8gZXZlbnRzLiBBIGdvb2QgZXhhbXBsZSB3aHkgdGhpcyBtaWdodCBvY2N1ciBpcyBpZiB0aGUgdXNlciBoYWRcbiAgICAgIC8vIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIGluIG1lbW9yeSB3aGVuIHVwZGF0aW5nIHRvIHRoZSB2ZXJzaW9uIHRoYXRcbiAgICAgIC8vIGluY2x1ZGVzIHRoaXMgY2hhbmdlLiBBIG1pZ3JhdGlvbiB3b3VsZCBoYXZlIGFsc28gaGVscGVkIGhlcmUgYnV0IHRoaXNcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIGhhcmRlbnMgYWdhaW5zdCBvdGhlciBwb3NzaWJsZSBidWdzIHdoZXJlIGEgZnJhZ21lbnRcbiAgICAgIC8vIGRvZXMgbm90IGV4aXN0LlxuICAgICAgY2FzZSBUUkFOU0FDVElPTl9FVkVOVFMuQVBQUk9WRUQ6XG4gICAgICBjYXNlIFRSQU5TQUNUSU9OX0VWRU5UUy5SRUpFQ1RFRDpcbiAgICAgICAgdGhpcy5jcmVhdGVFdmVudEZyYWdtZW50KHtcbiAgICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgc3VjY2Vzc0V2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuQVBQUk9WRUQsXG4gICAgICAgICAgZmFpbHVyZUV2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuUkVKRUNURUQsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzLFxuICAgICAgICAgIHBlcnNpc3Q6IHRydWUsXG4gICAgICAgICAgdW5pcXVlSWRlbnRpZmllcixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gV2hlbiBhIHRyYW5zYWN0aW9uIGlzIHN1Ym1pdHRlZCBpdCB3aWxsIGFsd2F5cyByZXN1bHQgaW4gdXBkYXRpbmdcbiAgICAgIC8vIHRvIGEgZmluYWxpemVkIHN0YXRlIChkcm9wcGVkLCBmYWlsZWQsIGNvbmZpcm1lZCkgLS0gZXZlbnR1YWxseS5cbiAgICAgIC8vIEhvd2V2ZXIgaGF2aW5nIGEgZnJhZ21lbnQgc3RhcnRlZCBhdCB0aGlzIHN0YWdlIGFsbG93cyBhdWdtZW50aW5nXG4gICAgICAvLyBhbmFseXRpY3MgZGF0YSB3aXRoIHVzZXIgaW50ZXJhY3Rpb25zIHN1Y2ggYXMgc3BlZWRpbmcgdXAgYW5kXG4gICAgICAvLyBjYW5jZWxpbmcgdGhlIHRyYW5zYWN0aW9ucy4gRnJvbSB0aGlzIGNvbnRyb2xsZXJzIHBlcnNwZWN0aXZlIGEgbmV3XG4gICAgICAvLyB0cmFuc2FjdGlvbiB3aXRoIGEgbmV3IGlkIGlzIGdlbmVyYXRlZCBmb3Igc3BlZWQgdXAgYW5kIGNhbmNlbFxuICAgICAgLy8gdHJhbnNhY3Rpb25zLCBidXQgZnJvbSB0aGUgVUkgd2UgY291bGQgYXVnbWVudCB0aGUgcHJldmlvdXMgSUQgd2l0aFxuICAgICAgLy8gc3VwcGxlbWVudGFsIGRhdGEgdG8gc2hvdyB1c2VyIGludGVudC4gU3VjaCBhcyB3aGVuIHRoZXkgb3BlbiB0aGVcbiAgICAgIC8vIGNhbmNlbCBVSSBidXQgZG9uJ3Qgc3VibWl0LiBXZSBjYW4gcmVjb3JkIHRoYXQgdGhpcyBoYXBwZW5lZCBhbmQgYWRkXG4gICAgICAvLyBwcm9wZXJ0aWVzIHRvIHRoZSB0cmFuc2FjdGlvbiBldmVudC5cbiAgICAgIGNhc2UgVFJBTlNBQ1RJT05fRVZFTlRTLlNVQk1JVFRFRDpcbiAgICAgICAgdGhpcy5jcmVhdGVFdmVudEZyYWdtZW50KHtcbiAgICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgaW5pdGlhbEV2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuU1VCTUlUVEVELFxuICAgICAgICAgIHN1Y2Nlc3NFdmVudDogVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRCxcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIHNlbnNpdGl2ZVByb3BlcnRpZXMsXG4gICAgICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICAgICAgICB1bmlxdWVJZGVudGlmaWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBJZiBmb3Igc29tZSByZWFzb24gYSB0cmFuc2FjdGlvbiBpcyBmaW5hbGl6ZWQgd2l0aG91dCB0aGUgc3VibWl0dGVkXG4gICAgICAvLyBmcmFnbWVudCBleGlzdGluZyBpbiBtZW1vcnksIHdlIGNyZWF0ZSB0aGUgc3VibWl0dGVkIGZyYWdtZW50IGJ1dFxuICAgICAgLy8gd2l0aG91dCB0aGUgaW5pdGlhbEV2ZW50IGZpcmluZy4gVGhpcyBpcyB0byBwcmV2ZW50IHBvc3NpYmxlXG4gICAgICAvLyBkdXBsaWNhdGlvbiBvZiBldmVudHMuIEEgZ29vZCBleGFtcGxlIHdoeSB0aGlzIG1pZ2h0IG9jY3VyIGlzIGlmIHRoXG4gICAgICAvLyB1c2VyIGhhZCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBpbiBtZW1vcnkgd2hlbiB1cGRhdGluZyB0byB0aGUgdmVyc2lvblxuICAgICAgLy8gdGhhdCBpbmNsdWRlcyB0aGlzIGNoYW5nZS4gQSBtaWdyYXRpb24gd291bGQgaGF2ZSBhbHNvIGhlbHBlZCBoZXJlIGJ1dFxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBoYXJkZW5zIGFnYWluc3Qgb3RoZXIgcG9zc2libGUgYnVncyB3aGVyZSBhXG4gICAgICAvLyBmcmFnbWVudCBkb2VzIG5vdCBleGlzdC5cbiAgICAgIGNhc2UgVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRDpcbiAgICAgICAgdGhpcy5jcmVhdGVFdmVudEZyYWdtZW50KHtcbiAgICAgICAgICBjYXRlZ29yeTogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgc3VjY2Vzc0V2ZW50OiBUUkFOU0FDVElPTl9FVkVOVFMuRklOQUxJWkVELFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICAgICAgICBwZXJzaXN0OiB0cnVlLFxuICAgICAgICAgIHVuaXF1ZUlkZW50aWZpZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyByZWxldmFudCBwcm9wZXJ0aWVzIGZyb20gYSB0cmFuc2FjdGlvbiBtZXRhXG4gICAqIG9iamVjdCBhbmQgdXNlcyB0aGVtIHRvIGNyZWF0ZSBhbmQgc2VuZCBtZXRyaWNzIGZvciB2YXJpb3VzIHRyYW5zYWN0aW9uXG4gICAqIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50U3RyaW5nfSBldmVudCAtIHRoZSBuYW1lIG9mIHRoZSB0cmFuc2FjdGlvbiBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFQYXJhbXMgLSBvcHRpb25hbCBwcm9wcyBhbmQgdmFsdWVzIHRvIGluY2x1ZGUgaW4gc2Vuc2l0aXZlUHJvcGVydGllc1xuICAgKi9cbiAgYXN5bmMgX3RyYWNrVHJhbnNhY3Rpb25NZXRyaWNzRXZlbnQodHhNZXRhLCBldmVudCwgZXh0cmFQYXJhbXMgPSB7fSkge1xuICAgIGlmICghdHhNZXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzLFxuICAgIH0gPSBhd2FpdCB0aGlzLl9idWlsZEV2ZW50RnJhZ21lbnRQcm9wZXJ0aWVzKHR4TWV0YSwgZXh0cmFQYXJhbXMpO1xuXG4gICAgLy8gQ3JlYXRlIGV2ZW50IGZyYWdtZW50cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBzcGF3biBmcmFnbWVudHMsIGFuZCBlbnN1cmVcbiAgICAvLyBleGlzdGVuY2Ugb2YgZnJhZ21lbnRzIGZvciBldmVudCB0eXBlcyB0aGF0IGFjdCB1cG9uIHRoZW0uXG4gICAgdGhpcy5fY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50KFxuICAgICAgdHhNZXRhLFxuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICApO1xuXG4gICAgbGV0IGlkO1xuXG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgYXBwcm92ZXMgYSB0cmFuc2FjdGlvbiwgZmluYWxpemUgdGhlIHRyYW5zYWN0aW9uIGFkZGVkXG4gICAgICAvLyBldmVudCBmcmFnbWVudC5cbiAgICAgIGNhc2UgVFJBTlNBQ1RJT05fRVZFTlRTLkFQUFJPVkVEOlxuICAgICAgICBpZCA9IGB0cmFuc2FjdGlvbi1hZGRlZC0ke3R4TWV0YS5pZH1gO1xuICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50RnJhZ21lbnQoaWQsIHsgcHJvcGVydGllcywgc2Vuc2l0aXZlUHJvcGVydGllcyB9KTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZUV2ZW50RnJhZ21lbnQoaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIElmIHRoZSB1c2VyIHJlamVjdHMgYSB0cmFuc2FjdGlvbiwgZmluYWxpemUgdGhlIHRyYW5zYWN0aW9uIGFkZGVkXG4gICAgICAvLyBldmVudCBmcmFnbWVudC4gd2l0aCB0aGUgYWJhbmRvbmVkIGZsYWcgc2V0LlxuICAgICAgY2FzZSBUUkFOU0FDVElPTl9FVkVOVFMuUkVKRUNURUQ6XG4gICAgICAgIGlkID0gYHRyYW5zYWN0aW9uLWFkZGVkLSR7dHhNZXRhLmlkfWA7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRGcmFnbWVudChpZCwgeyBwcm9wZXJ0aWVzLCBzZW5zaXRpdmVQcm9wZXJ0aWVzIH0pO1xuICAgICAgICB0aGlzLmZpbmFsaXplRXZlbnRGcmFnbWVudChpZCwge1xuICAgICAgICAgIGFiYW5kb25lZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gV2hlbiBhIHRyYW5zYWN0aW9uIGlzIGZpbmFsaXplZCwgYWxzbyBmaW5hbGl6ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIC8vIHN1Ym1pdHRlZCBldmVudCBmcmFnbWVudC5cbiAgICAgIGNhc2UgVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRDpcbiAgICAgICAgaWQgPSBgdHJhbnNhY3Rpb24tc3VibWl0dGVkLSR7dHhNZXRhLmlkfWA7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRGcmFnbWVudChpZCwgeyBwcm9wZXJ0aWVzLCBzZW5zaXRpdmVQcm9wZXJ0aWVzIH0pO1xuICAgICAgICB0aGlzLmZpbmFsaXplRXZlbnRGcmFnbWVudChgdHJhbnNhY3Rpb24tc3VibWl0dGVkLSR7dHhNZXRhLmlkfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRUcmFuc2FjdGlvbkNvbXBsZXRpb25UaW1lKHN1Ym1pdHRlZFRpbWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHN1Ym1pdHRlZFRpbWUpIC8gMTAwMCkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIF9nZXRHYXNWYWx1ZXNJbkdXRUkoZ2FzUGFyYW1zKSB7XG4gICAgY29uc3QgZ2FzVmFsdWVzSW5Hd2VpID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBpbiBnYXNQYXJhbXMpIHtcbiAgICAgIGlmIChpc0hleFN0cmluZyhnYXNQYXJhbXNbcGFyYW1dKSkge1xuICAgICAgICBnYXNWYWx1ZXNJbkd3ZWlbcGFyYW1dID0gaGV4V0VJVG9EZWNHV0VJKGdhc1BhcmFtc1twYXJhbV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2FzVmFsdWVzSW5Hd2VpW3BhcmFtXSA9IGdhc1BhcmFtc1twYXJhbV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnYXNWYWx1ZXNJbkd3ZWk7XG4gIH1cblxuICBfZmFpbFRyYW5zYWN0aW9uKHR4SWQsIGVycm9yKSB7XG4gICAgdGhpcy50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c0ZhaWxlZCh0eElkLCBlcnJvcik7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy50eFN0YXRlTWFuYWdlci5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0aGlzLl90cmFja1RyYW5zYWN0aW9uTWV0cmljc0V2ZW50KHR4TWV0YSwgVFJBTlNBQ1RJT05fRVZFTlRTLkZJTkFMSVpFRCwge1xuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgfSk7XG4gIH1cblxuICBfZHJvcFRyYW5zYWN0aW9uKHR4SWQpIHtcbiAgICB0aGlzLnR4U3RhdGVNYW5hZ2VyLnNldFR4U3RhdHVzRHJvcHBlZCh0eElkKTtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLnR4U3RhdGVNYW5hZ2VyLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHRoaXMuX3RyYWNrVHJhbnNhY3Rpb25NZXRyaWNzRXZlbnQodHhNZXRhLCBUUkFOU0FDVElPTl9FVkVOVFMuRklOQUxJWkVEKTtcbiAgfVxufVxuIiwiaW1wb3J0IEFuYWx5dGljcyBmcm9tICdhbmFseXRpY3Mtbm9kZSc7XG5pbXBvcnQgeyBTRUNPTkQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuXG5jb25zdCBpc0Rldk9yVGVzdEVudmlyb25tZW50ID0gQm9vbGVhbihcbiAgcHJvY2Vzcy5lbnYuTUVUQU1BU0tfREVCVUcgfHwgcHJvY2Vzcy5lbnYuSU5fVEVTVCxcbik7XG5jb25zdCBTRUdNRU5UX1dSSVRFX0tFWSA9IHByb2Nlc3MuZW52LlNFR01FTlRfV1JJVEVfS0VZID8/IG51bGw7XG5jb25zdCBTRUdNRU5UX0hPU1QgPSBwcm9jZXNzLmVudi5TRUdNRU5UX0hPU1QgPz8gbnVsbDtcblxuLy8gZmx1c2hBdCBjb250cm9scyBob3cgbWFueSBldmVudHMgYXJlIHNlbnQgdG8gc2VnbWVudCBhdCBvbmNlLiBTZWdtZW50IHdpbGxcbi8vIGhvbGQgb250byBhIHF1ZXVlIG9mIGV2ZW50cyB1bnRpbCBpdCBoaXRzIHRoaXMgbnVtYmVyLCB0aGVuIGl0IHNlbmRzIHRoZW0gYXNcbi8vIGEgYmF0Y2guIFRoaXMgc2V0dGluZyBkZWZhdWx0cyB0byAyMCwgYnV0IGluIGRldmVsb3BtZW50IHdlIGxpa2VseSB3YW50IHRvXG4vLyBzZWUgZXZlbnRzIGluIHJlYWwgdGltZSBmb3IgZGVidWdnaW5nLCBzbyB0aGlzIGlzIHNldCB0byAxIHRvIGRpc2FibGUgdGhlXG4vLyBxdWV1ZWluZyBtZWNoYW5pc20uXG5jb25zdCBTRUdNRU5UX0ZMVVNIX0FUID1cbiAgcHJvY2Vzcy5lbnYuTUVUQU1BU0tfRU5WSVJPTk1FTlQgPT09ICdwcm9kdWN0aW9uJyA/IHVuZGVmaW5lZCA6IDE7XG5cbi8vIGZsdXNoSW50ZXJ2YWwgY29udHJvbHMgaG93IGZyZXF1ZW50bHkgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgdG8gc2VnbWVudC5cbi8vIFRoaXMgaGFwcGVucyByZWdhcmRsZXNzIG9mIHRoZSBzaXplIG9mIHRoZSBxdWV1ZS4gVGhlIGRlZmF1bHQgc2V0dGluZyBpc1xuLy8gMTAsMDAwbXMgKDEwIHNlY29uZHMpLiBUaGlzIGRlZmF1bHQgaXMgcmF0aGVyIGhpZ2gsIHRob3VnaCB0aGFua2Z1bGx5XG4vLyB1c2luZyB0aGUgYmFja2dyb3VuZCBwcm9jZXNzIGFzIG91ciBldmVudCBoYW5kbGVyIG1lYW5zIHdlIGRvbid0IGhhdmUgdG9cbi8vIGRlYWwgd2l0aCBzaG9ydCBsaXZlZCBzZXNzaW9ucyB0aGF0IGhhcHBlbiBmYXN0ZXIgdGhhbiB0aGUgaW50ZXJ2YWxcbi8vIGUuZyBjb25maXJtYXRpb25zLiBUaGlzIGlzIHNldCB0byA1LDAwMG1zICg1IHNlY29uZHMpIGFyYml0cmFyaWx5IHdpdGggdGhlXG4vLyBpbnRlbnQgb2YgaGF2aW5nIGEgdmFsdWUgbGVzcyB0aGFuIDEwIHNlY29uZHMuXG5jb25zdCBTRUdNRU5UX0ZMVVNIX0lOVEVSVkFMID0gU0VDT05EICogNTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbW9jayBzZWdtZW50IG1vZHVsZSBmb3IgdXNhZ2UgaW4gdGVzdCBlbnZpcm9ubWVudHMuIFRoaXMgaXMgdXNlZFxuICogd2hlbiBidWlsZGluZyB0aGUgYXBwbGljYXRpb24gaW4gdGVzdCBtb2RlIHRvIGNhdGNoIGV2ZW50IGNhbGxzIGFuZCBwcmV2ZW50XG4gKiB0aGVtIGZyb20gYmVpbmcgc2VudCB0byBzZWdtZW50LiBJdCBpcyBhbHNvIHVzZWQgaW4gdW5pdCB0ZXN0cyB0byBtb2NrIGFuZFxuICogc3B5IG9uIHRoZSBtZXRob2RzIHRvIGVuc3VyZSBwcm9wZXIgYmVoYXZpb3JcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZmx1c2hBdCAtIG51bWJlciBvZiBldmVudHMgdG8gcXVldWUgYmVmb3JlIHNlbmRpbmcgdG8gc2VnbWVudFxuICogQHJldHVybnMge1NlZ21lbnRJbnRlcmZhY2V9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZWdtZW50TW9jayA9IChmbHVzaEF0ID0gU0VHTUVOVF9GTFVTSF9BVCkgPT4ge1xuICBjb25zdCBzZWdtZW50TW9jayA9IHtcbiAgICAvLyBJbnRlcm5hbCBxdWV1ZSB0byBrZWVwIHRyYWNrIG9mIGV2ZW50cyBhbmQgcHJvcGVybHkgbWltaWMgc2VnbWVudCdzXG4gICAgLy8gcXVldWVpbmcgYmVoYXZpb3IuXG4gICAgcXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBpbW1lZGlhdGVseSBzZW5kIGFsbCBxdWV1ZWQgZXZlbnRzIGFuZCByZXNldCB0aGUgcXVldWUgdG8gemVyby5cbiAgICAgKiBGb3Igb3VyIHB1cnBvc2VzIHRoaXMgc2ltcGx5IHRyaWdnZXJzIHRoZSBjYWxsYmFjayBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoXG4gICAgICogdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgc2VnbWVudE1vY2sucXVldWUuZm9yRWFjaCgoW18sIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICBzZWdtZW50TW9jay5xdWV1ZSA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFjayBhbiBldmVudCBhbmQgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gSWYgdGhlIHF1ZXVlIHNpemUgcmVhY2hlcyB0aGVcbiAgICAgKiBmbHVzaEF0IHRocmVzaG9sZCwgZmx1c2ggdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0cmFjayhwYXlsb2FkLCBjYWxsYmFjayA9ICgpID0+IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudE1vY2sucXVldWUucHVzaChbcGF5bG9hZCwgY2FsbGJhY2tdKTtcblxuICAgICAgaWYgKHNlZ21lbnRNb2NrLnF1ZXVlLmxlbmd0aCA+PSBmbHVzaEF0KSB7XG4gICAgICAgIHNlZ21lbnRNb2NrLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJ1ZSBOT09QLCB0aGVzZSBtZXRob2RzIGFyZSBlaXRoZXIgbm90IHVzZWQgb3IgZG8gbm90IGF3YWl0IGNhbGxiYWNrXG4gICAgICogYW5kIHRoZXJlZm9yZSByZXF1aXJlIG5vIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgcGFnZSgpIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9LFxuICAgIGlkZW50aWZ5KCkge1xuICAgICAgLy8gbm9vcFxuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHNlZ21lbnRNb2NrO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlZ21lbnQgPVxuICAhU0VHTUVOVF9XUklURV9LRVkgfHwgKGlzRGV2T3JUZXN0RW52aXJvbm1lbnQgJiYgIVNFR01FTlRfSE9TVClcbiAgICA/IGNyZWF0ZVNlZ21lbnRNb2NrKFNFR01FTlRfRkxVU0hfQVQsIFNFR01FTlRfRkxVU0hfSU5URVJWQUwpXG4gICAgOiBuZXcgQW5hbHl0aWNzKFNFR01FTlRfV1JJVEVfS0VZLCB7XG4gICAgICAgIGhvc3Q6IFNFR01FTlRfSE9TVCxcbiAgICAgICAgZmx1c2hBdDogU0VHTUVOVF9GTFVTSF9BVCxcbiAgICAgICAgZmx1c2hJbnRlcnZhbDogU0VHTUVOVF9GTFVTSF9JTlRFUlZBTCxcbiAgICAgIH0pO1xuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgV2FsbGV0IGZyb20gJ2V0aGVyZXVtanMtd2FsbGV0JztcbmltcG9ydCBpbXBvcnRlcnMgZnJvbSAnZXRoZXJldW1qcy13YWxsZXQvdGhpcmRwYXJ0eSc7XG5pbXBvcnQge1xuICB0b0J1ZmZlcixcbiAgaXNWYWxpZFByaXZhdGUsXG4gIGJ1ZmZlclRvSGV4LFxuICBzdHJpcEhleFByZWZpeCxcbn0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcblxuY29uc3QgYWNjb3VudEltcG9ydGVyID0ge1xuICBpbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltcG9ydGVyID0gdGhpcy5zdHJhdGVnaWVzW3N0cmF0ZWd5XTtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXlIZXggPSBpbXBvcnRlciguLi5hcmdzKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJpdmF0ZUtleUhleCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfSxcblxuICBzdHJhdGVnaWVzOiB7XG4gICAgJ1ByaXZhdGUgS2V5JzogKHByaXZhdGVLZXkpID0+IHtcbiAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgYW4gZW1wdHkga2V5LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGFkZEhleFByZWZpeChwcml2YXRlS2V5KTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRvQnVmZmVyKHByZWZpeGVkKTtcblxuICAgICAgaWYgKCFpc1ZhbGlkUHJpdmF0ZShidWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBpbnZhbGlkIHByaXZhdGUga2V5LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KHByZWZpeGVkKTtcbiAgICAgIHJldHVybiBzdHJpcHBlZDtcbiAgICB9LFxuICAgICdKU09OIEZpbGUnOiAoaW5wdXQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICBsZXQgd2FsbGV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2FsbGV0ID0gaW1wb3J0ZXJzLmZyb21FdGhlcldhbGxldChpbnB1dCwgcGFzc3dvcmQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoJ0F0dGVtcHQgdG8gaW1wb3J0IGFzIEV0aGVyV2FsbGV0IGZvcm1hdCBmYWlsZWQsIHRyeWluZyBWMycpO1xuICAgICAgICB3YWxsZXQgPSBXYWxsZXQuZnJvbVYzKGlucHV0LCBwYXNzd29yZCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3YWxsZXRUb1ByaXZhdGVLZXkod2FsbGV0KTtcbiAgICB9LFxuICB9LFxufTtcblxuZnVuY3Rpb24gd2FsbGV0VG9Qcml2YXRlS2V5KHdhbGxldCkge1xuICBjb25zdCBwcml2YXRlS2V5QnVmZmVyID0gd2FsbGV0LmdldFByaXZhdGVLZXkoKTtcbiAgcmV0dXJuIGJ1ZmZlclRvSGV4KHByaXZhdGVLZXlCdWZmZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhY2NvdW50SW1wb3J0ZXI7XG4iLCJleHBvcnQgeyBkZWZhdWx0LCBORVRXT1JLX0VWRU5UUyB9IGZyb20gJy4vbmV0d29yayc7XG4iLCJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IG1hcFZhbHVlcywgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCB7IGNhbGNUb2tlbkFtb3VudCB9IGZyb20gJy4uLy4uLy4uL3VpL2hlbHBlcnMvdXRpbHMvdG9rZW4tdXRpbCc7XG5pbXBvcnQgeyBjYWxjR2FzVG90YWwgfSBmcm9tICcuLi8uLi8uLi91aS9wYWdlcy9zZW5kL3NlbmQudXRpbHMnO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIGRlY0dXRUlUb0hleFdFSSxcbiAgYWRkQ3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQge1xuICBERUZBVUxUX0VSQzIwX0FQUFJPVkVfR0FTLFxuICBRVU9URVNfRVhQSVJFRF9FUlJPUixcbiAgUVVPVEVTX05PVF9BVkFJTEFCTEVfRVJST1IsXG4gIFNXQVBTX0ZFVENIX09SREVSX0NPTkZMSUNULFxuICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3N3YXBzJztcbmltcG9ydCB7IEdBU19FU1RJTUFURV9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvZ2FzJztcblxuaW1wb3J0IHsgaXNTd2Fwc0RlZmF1bHRUb2tlbkFkZHJlc3MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9zd2Fwcy51dGlscyc7XG5cbmltcG9ydCB7XG4gIGZldGNoVHJhZGVzSW5mbyBhcyBkZWZhdWx0RmV0Y2hUcmFkZXNJbmZvLFxuICBnZXRCYXNlQXBpLFxufSBmcm9tICcuLi8uLi8uLi91aS9wYWdlcy9zd2Fwcy9zd2Fwcy51dGlsJztcbmltcG9ydCBmZXRjaFdpdGhDYWNoZSBmcm9tICcuLi8uLi8uLi91aS9oZWxwZXJzL3V0aWxzL2ZldGNoLXdpdGgtY2FjaGUnO1xuaW1wb3J0IHsgTUlOVVRFLCBTRUNPTkQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uLy4uL3VpL2hlbHBlcnMvdXRpbHMvdXRpbCc7XG5pbXBvcnQgeyBORVRXT1JLX0VWRU5UUyB9IGZyb20gJy4vbmV0d29yayc7XG5cbi8vIFRoZSBNQVhfR0FTX0xJTUlUIGlzIGEgbnVtYmVyIHRoYXQgaXMgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gZ2FzIGNvc3RzIHdlIGhhdmUgb2JzZXJ2ZWQgb24gYW55IGFnZ3JlZ2F0b3JcbmNvbnN0IE1BWF9HQVNfTElNSVQgPSAyNTAwMDAwO1xuXG4vLyBUbyBlbnN1cmUgdGhhdCBvdXIgc2VydmVzIGFyZSBub3Qgc3BhbW1lZCBpZiBNZXRhTWFzayBpcyBsZWZ0IGlkbGUsIHdlIGxpbWl0IHRoZSBudW1iZXIgb2YgZmV0Y2hlcyBmb3IgcXVvdGVzIHRoYXQgYXJlIG1hZGUgb24gdGltZWQgaW50ZXJ2YWxzLlxuLy8gMyBzZWVtcyB0byBiZSBhbiBhcHByb3ByaWF0ZSBiYWxhbmNlIG9mIGdpdmluZyB1c2VycyB0aGUgdGltZSB0aGV5IG5lZWQgd2hlbiBNZXRhTWFzayBpcyBub3QgbGVmdCBpZGxlLCBhbmQgdHVybmluZyBwb2xsaW5nIG9mZiB3aGVuIGl0IGlzLlxuY29uc3QgUE9MTF9DT1VOVF9MSU1JVCA9IDM7XG5cbi8vIElmIGZvciBhbnkgcmVhc29uIHRoZSBNZXRhU3dhcCBBUEkgZmFpbHMgdG8gcHJvdmlkZSBhIHJlZnJlc2ggdGltZSxcbi8vIHByb3ZpZGUgYSByZWFzb25hYmxlIGZhbGxiYWNrIHRvIGF2b2lkIGZ1cnRoZXIgZXJyb3JzXG5jb25zdCBGQUxMQkFDS19RVU9URV9SRUZSRVNIX1RJTUUgPSBNSU5VVEU7XG5jb25zdCBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTl9SRUZSRVNIX1RJTUUgPSBTRUNPTkQgKiAxMDtcbmNvbnN0IEZBTExCQUNLX1NNQVJUX1RSQU5TQUNUSU9OU19ERUFETElORSA9IDE4MDtcblxuZnVuY3Rpb24gY2FsY3VsYXRlR2FzRXN0aW1hdGVXaXRoUmVmdW5kKFxuICBtYXhHYXMgPSBNQVhfR0FTX0xJTUlULFxuICBlc3RpbWF0ZWRSZWZ1bmQgPSAwLFxuICBlc3RpbWF0ZWRHYXMgPSAwLFxuKSB7XG4gIGNvbnN0IG1heEdhc01pbnVzUmVmdW5kID0gbmV3IEJpZ051bWJlcihtYXhHYXMsIDEwKS5taW51cyhcbiAgICBlc3RpbWF0ZWRSZWZ1bmQsXG4gICAgMTAsXG4gICk7XG4gIGNvbnN0IGlzTWF4R2FzTWludXNSZWZ1bmROZWdhdGl2ZSA9IG1heEdhc01pbnVzUmVmdW5kLmx0KDApO1xuXG4gIGNvbnN0IGdhc0VzdGltYXRlV2l0aFJlZnVuZCA9XG4gICAgIWlzTWF4R2FzTWludXNSZWZ1bmROZWdhdGl2ZSAmJiBtYXhHYXNNaW51c1JlZnVuZC5sdChlc3RpbWF0ZWRHYXMsIDE2KVxuICAgICAgPyBgMHgke21heEdhc01pbnVzUmVmdW5kLnRvU3RyaW5nKDE2KX1gXG4gICAgICA6IGVzdGltYXRlZEdhcztcblxuICByZXR1cm4gZ2FzRXN0aW1hdGVXaXRoUmVmdW5kO1xufVxuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN3YXBzU3RhdGU6IHtcbiAgICBxdW90ZXM6IHt9LFxuICAgIHF1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQ6IGZhbHNlLFxuICAgIGZldGNoUGFyYW1zOiBudWxsLFxuICAgIHRva2VuczogbnVsbCxcbiAgICB0cmFkZVR4SWQ6IG51bGwsXG4gICAgYXBwcm92ZVR4SWQ6IG51bGwsXG4gICAgcXVvdGVzTGFzdEZldGNoZWQ6IG51bGwsXG4gICAgY3VzdG9tTWF4R2FzOiAnJyxcbiAgICBjdXN0b21HYXNQcmljZTogbnVsbCxcbiAgICBjdXN0b21NYXhGZWVQZXJHYXM6IG51bGwsXG4gICAgY3VzdG9tTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG51bGwsXG4gICAgc3dhcHNVc2VyRmVlTGV2ZWw6ICcnLFxuICAgIHNlbGVjdGVkQWdnSWQ6IG51bGwsXG4gICAgY3VzdG9tQXBwcm92ZVR4RGF0YTogJycsXG4gICAgZXJyb3JLZXk6ICcnLFxuICAgIHRvcEFnZ0lkOiBudWxsLFxuICAgIHJvdXRlU3RhdGU6ICcnLFxuICAgIHN3YXBzRmVhdHVyZUlzTGl2ZTogdHJ1ZSxcbiAgICBzYXZlRmV0Y2hlZFF1b3RlczogZmFsc2UsXG4gICAgc3dhcHNRdW90ZVJlZnJlc2hUaW1lOiBGQUxMQkFDS19RVU9URV9SRUZSRVNIX1RJTUUsXG4gICAgc3dhcHNRdW90ZVByZWZldGNoaW5nUmVmcmVzaFRpbWU6IEZBTExCQUNLX1FVT1RFX1JFRlJFU0hfVElNRSxcbiAgICBzd2Fwc1N0eEJhdGNoU3RhdHVzUmVmcmVzaFRpbWU6IEZBTExCQUNLX1NNQVJUX1RSQU5TQUNUSU9OX1JFRlJFU0hfVElNRSxcbiAgICBzd2Fwc1N0eEdldFRyYW5zYWN0aW9uc1JlZnJlc2hUaW1lOiBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTl9SRUZSRVNIX1RJTUUsXG4gICAgc3dhcHNGZWF0dXJlRmxhZ3M6IHt9LFxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dhcHNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGdldEJ1ZmZlcmVkR2FzTGltaXQsXG4gICAgbmV0d29ya0NvbnRyb2xsZXIsXG4gICAgcHJvdmlkZXIsXG4gICAgZ2V0UHJvdmlkZXJDb25maWcsXG4gICAgZ2V0VG9rZW5SYXRlc1N0YXRlLFxuICAgIGZldGNoVHJhZGVzSW5mbyA9IGRlZmF1bHRGZXRjaFRyYWRlc0luZm8sXG4gICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlcyxcbiAgfSkge1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uaW5pdGlhbFN0YXRlLnN3YXBzU3RhdGUgfSxcbiAgICB9KTtcblxuICAgIHRoaXMuX2ZldGNoVHJhZGVzSW5mbyA9IGZldGNoVHJhZGVzSW5mbztcbiAgICB0aGlzLl9nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICAgIHRoaXMuX2dldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXMgPSBnZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzO1xuXG4gICAgdGhpcy5nZXRCdWZmZXJlZEdhc0xpbWl0ID0gZ2V0QnVmZmVyZWRHYXNMaW1pdDtcbiAgICB0aGlzLmdldFRva2VuUmF0ZXNTdGF0ZSA9IGdldFRva2VuUmF0ZXNTdGF0ZTtcblxuICAgIHRoaXMucG9sbENvdW50ID0gMDtcbiAgICB0aGlzLmdldFByb3ZpZGVyQ29uZmlnID0gZ2V0UHJvdmlkZXJDb25maWc7XG5cbiAgICB0aGlzLmluZGV4T2ZOZXdlc3RDYWxsSW5GbGlnaHQgPSAwO1xuXG4gICAgdGhpcy5ldGhlcnNQcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihwcm92aWRlcik7XG4gICAgdGhpcy5fY3VycmVudE5ldHdvcmsgPSBuZXR3b3JrQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLm5ldHdvcms7XG4gICAgbmV0d29ya0NvbnRyb2xsZXIub24oTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCAobmV0d29yaykgPT4ge1xuICAgICAgaWYgKG5ldHdvcmsgIT09ICdsb2FkaW5nJyAmJiBuZXR3b3JrICE9PSB0aGlzLl9jdXJyZW50TmV0d29yaykge1xuICAgICAgICB0aGlzLl9jdXJyZW50TmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTd2Fwc1JlZnJlc2hSYXRlcyhjaGFpbklkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcbiAgICAgIGdldEJhc2VBcGkoJ25ldHdvcmsnLCBjaGFpbklkKSxcbiAgICAgIHsgbWV0aG9kOiAnR0VUJyB9LFxuICAgICAgeyBjYWNoZVJlZnJlc2hUaW1lOiA2MDAwMDAgfSxcbiAgICApO1xuICAgIGNvbnN0IHsgcmVmcmVzaFJhdGVzIH0gPSByZXNwb25zZSB8fCB7fTtcbiAgICBpZiAoXG4gICAgICAhcmVmcmVzaFJhdGVzIHx8XG4gICAgICB0eXBlb2YgcmVmcmVzaFJhdGVzLnF1b3RlcyAhPT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiByZWZyZXNoUmF0ZXMucXVvdGVzUHJlZmV0Y2hpbmcgIT09ICdudW1iZXInIHx8XG4gICAgICB0eXBlb2YgcmVmcmVzaFJhdGVzLnN0eEdldFRyYW5zYWN0aW9ucyAhPT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiByZWZyZXNoUmF0ZXMuc3R4QmF0Y2hTdGF0dXMgIT09ICdudW1iZXInXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNZXRhTWFzayAtIGludmFsaWQgcmVzcG9uc2UgZm9yIHJlZnJlc2hSYXRlczogJHtyZXNwb25zZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gV2UgcHJlc2VudGx5IHVzZSBtaWxsaXNlY29uZHMgaW4gdGhlIFVJLlxuICAgIHJldHVybiB7XG4gICAgICBxdW90ZXM6IHJlZnJlc2hSYXRlcy5xdW90ZXMgKiAxMDAwLFxuICAgICAgcXVvdGVzUHJlZmV0Y2hpbmc6IHJlZnJlc2hSYXRlcy5xdW90ZXNQcmVmZXRjaGluZyAqIDEwMDAsXG4gICAgICBzdHhHZXRUcmFuc2FjdGlvbnM6IHJlZnJlc2hSYXRlcy5zdHhHZXRUcmFuc2FjdGlvbnMgKiAxMDAwLFxuICAgICAgc3R4QmF0Y2hTdGF0dXM6IHJlZnJlc2hSYXRlcy5zdHhCYXRjaFN0YXR1cyAqIDEwMDAsXG4gICAgICBzdHhTdGF0dXNEZWFkbGluZTogcmVmcmVzaFJhdGVzLnN0eFN0YXR1c0RlYWRsaW5lLFxuICAgIH07XG4gIH1cblxuICAvLyBTZXRzIHRoZSByZWZyZXNoIHJhdGUgZm9yIHF1b3RlIHVwZGF0ZXMgZnJvbSB0aGUgTWV0YVN3YXAgQVBJXG4gIGFzeW5jIF9zZXRTd2Fwc1JlZnJlc2hSYXRlcygpIHtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5fZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBsZXQgc3dhcHNSZWZyZXNoUmF0ZXM7XG4gICAgdHJ5IHtcbiAgICAgIHN3YXBzUmVmcmVzaFJhdGVzID0gYXdhaXQgdGhpcy5mZXRjaFN3YXBzUmVmcmVzaFJhdGVzKGNoYWluSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlcXVlc3QgZm9yIHN3YXBzIHF1b3RlIHJlZnJlc2ggdGltZSBmYWlsZWQ6ICcsIGUpO1xuICAgIH1cbiAgICBjb25zdCB7IHN3YXBzU3RhdGU6IGxhdGVzdFN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHtcbiAgICAgICAgLi4ubGF0ZXN0U3dhcHNTdGF0ZSxcbiAgICAgICAgc3dhcHNRdW90ZVJlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzUmVmcmVzaFJhdGVzPy5xdW90ZXMgfHwgRkFMTEJBQ0tfUVVPVEVfUkVGUkVTSF9USU1FLFxuICAgICAgICBzd2Fwc1F1b3RlUHJlZmV0Y2hpbmdSZWZyZXNoVGltZTpcbiAgICAgICAgICBzd2Fwc1JlZnJlc2hSYXRlcz8ucXVvdGVzUHJlZmV0Y2hpbmcgfHwgRkFMTEJBQ0tfUVVPVEVfUkVGUkVTSF9USU1FLFxuICAgICAgICBzd2Fwc1N0eEdldFRyYW5zYWN0aW9uc1JlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzUmVmcmVzaFJhdGVzPy5zdHhHZXRUcmFuc2FjdGlvbnMgfHxcbiAgICAgICAgICBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTl9SRUZSRVNIX1RJTUUsXG4gICAgICAgIHN3YXBzU3R4QmF0Y2hTdGF0dXNSZWZyZXNoVGltZTpcbiAgICAgICAgICBzd2Fwc1JlZnJlc2hSYXRlcz8uc3R4QmF0Y2hTdGF0dXMgfHxcbiAgICAgICAgICBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTl9SRUZSRVNIX1RJTUUsXG4gICAgICAgIHN3YXBzU3R4U3RhdHVzRGVhZGxpbmU6XG4gICAgICAgICAgc3dhcHNSZWZyZXNoUmF0ZXM/LnN0eFN0YXR1c0RlYWRsaW5lIHx8XG4gICAgICAgICAgRkFMTEJBQ0tfU01BUlRfVFJBTlNBQ1RJT05TX0RFQURMSU5FLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE9uY2UgcXVvdGVzIGFyZSBmZXRjaGVkLCB3ZSBwb2xsIGZvciBuZXcgb25lcyB0byBrZWVwIHRoZSBxdW90ZXMgdXAgdG8gZGF0ZS4gTWFya2V0IGFuZCBhZ2dyZWdhdG9yIGNvbnRyYWN0IGNvbmRpdGlvbnMgY2FuIGNoYW5nZSBmYXN0IGVub3VnaFxuICAvLyB0aGF0IHF1b3RlcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgYWZ0ZXIgMSBvciAyIG1pbnV0ZXMuIFdoZW4gZmV0Y2hBbmRTZXRRdW90ZXMgaXMgZmlyc3QgY2FsbGVkLCBpdCByZWNlaXZlcyBmZXRjaCBwYXJhbWV0ZXJzIHRoYXQgYXJlIHN0b3JlZCBpblxuICAvLyBzdGF0ZS4gVGhlc2Ugc3RvcmVkIHBhcmFtZXRlcnMgYXJlIHVzZWQgb24gc3Vic2VxdWVudCBjYWxscyBtYWRlIGR1cmluZyBwb2xsaW5nLlxuICAvLyBOb3RlOiB3ZSBzdG9wIHBvbGxpbmcgYWZ0ZXIgMyByZXF1ZXN0cywgdW50aWwgbmV3IHF1b3RlcyBhcmUgZXhwbGljaXRseSBhc2tlZCBmb3IuIFRoZSBsb2dpYyB0aGF0IGVuZm9yY2VzIHRoYXQgbWF4aW11bSBpcyBpbiB0aGUgYm9keSBvZiBmZXRjaEFuZFNldFF1b3Rlc1xuICBwb2xsRm9yTmV3UXVvdGVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN3YXBzU3RhdGU6IHtcbiAgICAgICAgc3dhcHNRdW90ZVJlZnJlc2hUaW1lLFxuICAgICAgICBzd2Fwc1F1b3RlUHJlZmV0Y2hpbmdSZWZyZXNoVGltZSxcbiAgICAgICAgcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZCxcbiAgICAgIH0sXG4gICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAvLyBzd2Fwc1F1b3RlUmVmcmVzaFRpbWUgaXMgdXNlZCBvbiB0aGUgVmlldyBRdW90ZSBwYWdlLCBzd2Fwc1F1b3RlUHJlZmV0Y2hpbmdSZWZyZXNoVGltZSBpcyB1c2VkIG9uIHRoZSBCdWlsZCBRdW90ZSBwYWdlLlxuICAgIGNvbnN0IHF1b3Rlc1JlZnJlc2hSYXRlSW5NcyA9IHF1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWRcbiAgICAgID8gc3dhcHNRdW90ZVJlZnJlc2hUaW1lXG4gICAgICA6IHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lO1xuICAgIHRoaXMucG9sbGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5mZXRjaEFuZFNldFF1b3RlcyhcbiAgICAgICAgc3dhcHNTdGF0ZS5mZXRjaFBhcmFtcyxcbiAgICAgICAgc3dhcHNTdGF0ZS5mZXRjaFBhcmFtcz8ubWV0YURhdGEsXG4gICAgICAgIHRydWUsXG4gICAgICApO1xuICAgIH0sIHF1b3Rlc1JlZnJlc2hSYXRlSW5Ncyk7XG4gIH1cblxuICBzdG9wUG9sbGluZ0ZvclF1b3RlcygpIHtcbiAgICBpZiAodGhpcy5wb2xsaW5nVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9sbGluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZldGNoQW5kU2V0UXVvdGVzKFxuICAgIGZldGNoUGFyYW1zLFxuICAgIGZldGNoUGFyYW1zTWV0YURhdGEgPSB7fSxcbiAgICBpc1BvbGxlZFJlcXVlc3QsXG4gICkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gZmV0Y2hQYXJhbXNNZXRhRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBzd2Fwc1N0YXRlOiB7IHF1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQsIHNhdmVGZXRjaGVkUXVvdGVzIH0sXG4gICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmICghZmV0Y2hQYXJhbXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBFdmVyeSB0aW1lIHdlIGdldCBhIG5ldyByZXF1ZXN0IHRoYXQgaXMgbm90IGZyb20gdGhlIHBvbGxpbmcsIHdlIHJlc2V0IHRoZSBwb2xsIGNvdW50IHNvIHdlIGNhbiBwb2xsIGZvciB1cCB0byB0aHJlZSBtb3JlIHNldHMgb2YgcXVvdGVzIHdpdGggdGhlc2UgbmV3IHBhcmFtcy5cbiAgICBpZiAoIWlzUG9sbGVkUmVxdWVzdCkge1xuICAgICAgdGhpcy5wb2xsQ291bnQgPSAwO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgcGVuZGluZyBwb2xsIHJlcXVlc3RzLCBjbGVhciB0aGVtIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgY2FsbCB3aGlsZSB0aGlzIG5ldyBmZXRjaCBpcyBpbiBwcm9jZXNzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucG9sbGluZ1RpbWVvdXQpO1xuXG4gICAgaWYgKCFpc1BvbGxlZFJlcXVlc3QpIHtcbiAgICAgIHRoaXMuc2V0U3dhcHNFcnJvcktleSgnJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhPZkN1cnJlbnRDYWxsID0gdGhpcy5pbmRleE9mTmV3ZXN0Q2FsbEluRmxpZ2h0ICsgMTtcbiAgICB0aGlzLmluZGV4T2ZOZXdlc3RDYWxsSW5GbGlnaHQgPSBpbmRleE9mQ3VycmVudENhbGw7XG5cbiAgICBpZiAoIXNhdmVGZXRjaGVkUXVvdGVzKSB7XG4gICAgICB0aGlzLnNldFNhdmVGZXRjaGVkUXVvdGVzKHRydWUpO1xuICAgIH1cblxuICAgIGxldCBbbmV3UXVvdGVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX2ZldGNoVHJhZGVzSW5mbyhmZXRjaFBhcmFtcywge1xuICAgICAgICAuLi5mZXRjaFBhcmFtc01ldGFEYXRhLFxuICAgICAgfSksXG4gICAgICB0aGlzLl9zZXRTd2Fwc1JlZnJlc2hSYXRlcygpLFxuICAgIF0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgc3dhcHNTdGF0ZTogeyBzYXZlRmV0Y2hlZFF1b3Rlczogc2F2ZUZldGNoZWRRdW90ZXNBZnRlclJlc3BvbnNlIH0sXG4gICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIHNhdmVGZXRjaGVkUXVvdGVzQWZ0ZXJSZXNwb25zZSBpcyBmYWxzZSwgaXQgbWVhbnMgYSB1c2VyIGxlZnQgU3dhcHMgKHdlIGNsZWFuZWQgdGhlIHN0YXRlKVxuICAgIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIHNldCBhbnkgQVBJIHJlc3BvbnNlIHdpdGggcXVvdGVzIGludG8gc3RhdGUuXG4gICAgaWYgKCFzYXZlRmV0Y2hlZFF1b3Rlc0FmdGVyUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt9LCAvLyBxdW90ZXNcbiAgICAgICAgbnVsbCwgLy8gc2VsZWN0ZWRBZ2dJZFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBuZXdRdW90ZXMgPSBtYXBWYWx1ZXMobmV3UXVvdGVzLCAocXVvdGUpID0+ICh7XG4gICAgICAuLi5xdW90ZSxcbiAgICAgIHNvdXJjZVRva2VuSW5mbzogZmV0Y2hQYXJhbXNNZXRhRGF0YS5zb3VyY2VUb2tlbkluZm8sXG4gICAgICBkZXN0aW5hdGlvblRva2VuSW5mbzogZmV0Y2hQYXJhbXNNZXRhRGF0YS5kZXN0aW5hdGlvblRva2VuSW5mbyxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBxdW90ZXNMYXN0RmV0Y2hlZCA9IERhdGUubm93KCk7XG5cbiAgICBsZXQgYXBwcm92YWxSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgICFpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyhmZXRjaFBhcmFtcy5zb3VyY2VUb2tlbiwgY2hhaW5JZCkgJiZcbiAgICAgIE9iamVjdC52YWx1ZXMobmV3UXVvdGVzKS5sZW5ndGhcbiAgICApIHtcbiAgICAgIGNvbnN0IGFsbG93YW5jZSA9IGF3YWl0IHRoaXMuX2dldEVSQzIwQWxsb3dhbmNlKFxuICAgICAgICBmZXRjaFBhcmFtcy5zb3VyY2VUb2tlbixcbiAgICAgICAgZmV0Y2hQYXJhbXMuZnJvbUFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICApO1xuICAgICAgY29uc3QgW2ZpcnN0UXVvdGVdID0gT2JqZWN0LnZhbHVlcyhuZXdRdW90ZXMpO1xuXG4gICAgICAvLyBGb3IgYSB1c2VyIHRvIGJlIGFibGUgdG8gc3dhcCBhIHRva2VuLCB0aGV5IG5lZWQgdG8gaGF2ZSBhcHByb3ZlZCB0aGUgTWV0YVN3YXAgY29udHJhY3QgdG8gd2l0aGRyYXcgdGhhdCB0b2tlbi5cbiAgICAgIC8vIF9nZXRFUkMyMEFsbG93YW5jZSgpIHJldHVybnMgdGhlIGFtb3VudCBvZiB0aGUgdG9rZW4gdGhleSBoYXZlIGFwcHJvdmVkIGZvciB3aXRoZHJhd2FsLiBJZiB0aGF0IGFtb3VudCBpcyBncmVhdGVyXG4gICAgICAvLyB0aGFuIDAsIGl0IG1lYW5zIHRoYXQgYXBwcm92YWwgaGFzIGFscmVhZHkgb2NjdXJyZWQgYW5kIGlzIG5vdCBuZWVkZWQuIE90aGVyd2lzZSwgZm9yIHRva2VucyB0byBiZSBzd2FwcGVkLCBhIG5ld1xuICAgICAgLy8gY2FsbCBvZiB0aGUgRVJDLTIwIGFwcHJvdmUgbWV0aG9kIGlzIHJlcXVpcmVkLlxuICAgICAgYXBwcm92YWxSZXF1aXJlZCA9XG4gICAgICAgIGZpcnN0UXVvdGUuYXBwcm92YWxOZWVkZWQgJiZcbiAgICAgICAgYWxsb3dhbmNlLmVxKDApICYmXG4gICAgICAgIGZpcnN0UXVvdGUuYWdncmVnYXRvciAhPT0gJ3dyYXBwZWROYXRpdmUnO1xuICAgICAgaWYgKCFhcHByb3ZhbFJlcXVpcmVkKSB7XG4gICAgICAgIG5ld1F1b3RlcyA9IG1hcFZhbHVlcyhuZXdRdW90ZXMsIChxdW90ZSkgPT4gKHtcbiAgICAgICAgICAuLi5xdW90ZSxcbiAgICAgICAgICBhcHByb3ZhbE5lZWRlZDogbnVsbCxcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNQb2xsZWRSZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzTGltaXQ6IGFwcHJvdmFsR2FzIH0gPSBhd2FpdCB0aGlzLnRpbWVkb3V0R2FzUmV0dXJuKFxuICAgICAgICAgIGZpcnN0UXVvdGUuYXBwcm92YWxOZWVkZWQsXG4gICAgICAgICk7XG5cbiAgICAgICAgbmV3UXVvdGVzID0gbWFwVmFsdWVzKG5ld1F1b3RlcywgKHF1b3RlKSA9PiAoe1xuICAgICAgICAgIC4uLnF1b3RlLFxuICAgICAgICAgIGFwcHJvdmFsTmVlZGVkOiB7XG4gICAgICAgICAgICAuLi5xdW90ZS5hcHByb3ZhbE5lZWRlZCxcbiAgICAgICAgICAgIGdhczogYXBwcm92YWxHYXMgfHwgREVGQVVMVF9FUkMyMF9BUFBST1ZFX0dBUyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHRvcEFnZ0lkID0gbnVsbDtcblxuICAgIC8vIFdlIGNhbiByZWR1Y2UgdGltZSBvbiB0aGUgbG9hZGluZyBzY3JlZW4gYnkgb25seSBkb2luZyB0aGlzIGFmdGVyIHRoZVxuICAgIC8vIGxvYWRpbmcgc2NyZWVuIGFuZCBiZXN0IHF1b3RlIGhhdmUgcmVuZGVyZWQuXG4gICAgaWYgKCFhcHByb3ZhbFJlcXVpcmVkICYmICFmZXRjaFBhcmFtcz8uYmFsYW5jZUVycm9yKSB7XG4gICAgICBuZXdRdW90ZXMgPSBhd2FpdCB0aGlzLmdldEFsbFF1b3Rlc1dpdGhHYXNFc3RpbWF0ZXMobmV3UXVvdGVzKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhuZXdRdW90ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zZXRTd2Fwc0Vycm9yS2V5KFFVT1RFU19OT1RfQVZBSUxBQkxFX0VSUk9SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW1xuICAgICAgICBfdG9wQWdnSWQsXG4gICAgICAgIHF1b3Rlc1dpdGhTYXZpbmdzQW5kRmVlRGF0YSxcbiAgICAgIF0gPSBhd2FpdCB0aGlzLl9maW5kVG9wUXVvdGVBbmRDYWxjdWxhdGVTYXZpbmdzKG5ld1F1b3Rlcyk7XG4gICAgICB0b3BBZ2dJZCA9IF90b3BBZ2dJZDtcbiAgICAgIG5ld1F1b3RlcyA9IHF1b3Rlc1dpdGhTYXZpbmdzQW5kRmVlRGF0YTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5ld2VyIGNhbGwgaGFzIGJlZW4gbWFkZSwgZG9uJ3QgdXBkYXRlIHN0YXRlIHdpdGggb2xkIGluZm9ybWF0aW9uXG4gICAgLy8gUHJldmVudHMgdGltaW5nIGNvbmZsaWN0cyBiZXR3ZWVuIGZldGNoZXNcbiAgICBpZiAodGhpcy5pbmRleE9mTmV3ZXN0Q2FsbEluRmxpZ2h0ICE9PSBpbmRleE9mQ3VycmVudENhbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihTV0FQU19GRVRDSF9PUkRFUl9DT05GTElDVCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgbGV0IHsgc2VsZWN0ZWRBZ2dJZCB9ID0gc3dhcHNTdGF0ZTtcbiAgICBpZiAoIW5ld1F1b3Rlc1tzZWxlY3RlZEFnZ0lkXSkge1xuICAgICAgc2VsZWN0ZWRBZ2dJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7XG4gICAgICAgIC4uLnN3YXBzU3RhdGUsXG4gICAgICAgIHF1b3RlczogbmV3UXVvdGVzLFxuICAgICAgICBmZXRjaFBhcmFtczogeyAuLi5mZXRjaFBhcmFtcywgbWV0YURhdGE6IGZldGNoUGFyYW1zTWV0YURhdGEgfSxcbiAgICAgICAgcXVvdGVzTGFzdEZldGNoZWQsXG4gICAgICAgIHNlbGVjdGVkQWdnSWQsXG4gICAgICAgIHRvcEFnZ0lkLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmIChxdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkKSB7XG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZG8gdXAgdG8gYSBtYXhpbXVtIG9mIHRocmVlIHJlcXVlc3RzIGZyb20gcG9sbGluZyBpZiBwb2xsaW5nIGxpbWl0IGlzIGVuYWJsZWQuXG4gICAgICAvLyBPdGhlcndpc2Ugd2Ugd29uJ3QgaW5jcmVhc2UgcG9sbENvdW50LCBzbyBwb2xsaW5nIHdpbGwgcnVuIHdpdGhvdXQgYSBsaW1pdC5cbiAgICAgIHRoaXMucG9sbENvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKCFxdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkIHx8IHRoaXMucG9sbENvdW50IDwgUE9MTF9DT1VOVF9MSU1JVCArIDEpIHtcbiAgICAgIHRoaXMucG9sbEZvck5ld1F1b3RlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0UG9zdEZldGNoU3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3dhcHNFcnJvcktleShRVU9URVNfRVhQSVJFRF9FUlJPUik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gW25ld1F1b3RlcywgdG9wQWdnSWRdO1xuICB9XG5cbiAgc2FmZVJlZmV0Y2hRdW90ZXMoKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKCF0aGlzLnBvbGxpbmdUaW1lb3V0ICYmIHN3YXBzU3RhdGUuZmV0Y2hQYXJhbXMpIHtcbiAgICAgIHRoaXMuZmV0Y2hBbmRTZXRRdW90ZXMoc3dhcHNTdGF0ZS5mZXRjaFBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgc2V0U2VsZWN0ZWRRdW90ZUFnZ0lkKHNlbGVjdGVkQWdnSWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBzZWxlY3RlZEFnZ0lkIH0gfSk7XG4gIH1cblxuICBzZXRTd2Fwc1Rva2Vucyh0b2tlbnMpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCB0b2tlbnMgfSB9KTtcbiAgfVxuXG4gIGNsZWFyU3dhcHNRdW90ZXMoKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgcXVvdGVzOiB7fSB9IH0pO1xuICB9XG5cbiAgc2V0U3dhcHNFcnJvcktleShlcnJvcktleSkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIGVycm9yS2V5IH0gfSk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxRdW90ZXNXaXRoR2FzRXN0aW1hdGVzKHF1b3Rlcykge1xuICAgIGNvbnN0IHF1b3RlR2FzRGF0YSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LnZhbHVlcyhxdW90ZXMpLm1hcChhc3luYyAocXVvdGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBnYXNMaW1pdCwgc2ltdWxhdGlvbkZhaWxzIH0gPSBhd2FpdCB0aGlzLnRpbWVkb3V0R2FzUmV0dXJuKFxuICAgICAgICAgIHF1b3RlLnRyYWRlLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gW2dhc0xpbWl0LCBzaW11bGF0aW9uRmFpbHMsIHF1b3RlLmFnZ3JlZ2F0b3JdO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIGNvbnN0IG5ld1F1b3RlcyA9IHt9O1xuICAgIHF1b3RlR2FzRGF0YS5mb3JFYWNoKChbZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscywgYWdnSWRdKSA9PiB7XG4gICAgICBpZiAoZ2FzTGltaXQgJiYgIXNpbXVsYXRpb25GYWlscykge1xuICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZVdpdGhSZWZ1bmQgPSBjYWxjdWxhdGVHYXNFc3RpbWF0ZVdpdGhSZWZ1bmQoXG4gICAgICAgICAgcXVvdGVzW2FnZ0lkXS5tYXhHYXMsXG4gICAgICAgICAgcXVvdGVzW2FnZ0lkXS5lc3RpbWF0ZWRSZWZ1bmQsXG4gICAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgICk7XG5cbiAgICAgICAgbmV3UXVvdGVzW2FnZ0lkXSA9IHtcbiAgICAgICAgICAuLi5xdW90ZXNbYWdnSWRdLFxuICAgICAgICAgIGdhc0VzdGltYXRlOiBnYXNMaW1pdCxcbiAgICAgICAgICBnYXNFc3RpbWF0ZVdpdGhSZWZ1bmQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHF1b3Rlc1thZ2dJZF0uYXBwcm92YWxOZWVkZWQpIHtcbiAgICAgICAgLy8gSWYgZ2FzIGVzdGltYXRpb24gZmFpbHMsIGJ1dCBhbiBFUkMtMjAgYXBwcm92ZSBpcyBuZWVkZWQsIHRoZW4gd2UgZG8gbm90IGFkZCBhbnkgZXN0aW1hdGUgcHJvcGVydHkgdG8gdGhlIHF1b3RlIG9iamVjdFxuICAgICAgICAvLyBTdWNoIHF1b3RlcyB3aWxsIHJlbHkgb24gdGhlIG1heEdhcyBhbmQgYXZlcmFnZUdhcyBwcm9wZXJ0aWVzIGZyb20gdGhlIGFwaVxuICAgICAgICBuZXdRdW90ZXNbYWdnSWRdID0gcXVvdGVzW2FnZ0lkXTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGdhcyBlc3RpbWF0aW9uIGZhaWxzIGFuZCBubyBhcHByb3ZhbCBpcyBuZWVkZWQsIHRoZW4gd2UgZmlsdGVyIHRoYXQgcXVvdGUgb3V0LCBzbyB0aGF0IGl0IGlzIG5vdCBzaG93biB0byB0aGUgdXNlclxuICAgIH0pO1xuICAgIHJldHVybiBuZXdRdW90ZXM7XG4gIH1cblxuICB0aW1lZG91dEdhc1JldHVybih0cmFkZVR4UGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsZXQgZ2FzVGltZWRPdXQgPSBmYWxzZTtcblxuICAgICAgY29uc3QgZ2FzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBnYXNUaW1lZE91dCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoeyBnYXNMaW1pdDogbnVsbCwgc2ltdWxhdGlvbkZhaWxzOiB0cnVlIH0pO1xuICAgICAgfSwgU0VDT05EICogNSk7XG5cbiAgICAgIC8vIFJlbW92ZSBnYXMgZnJvbSBwYXJhbXMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYGVzdGltYXRlR2FzYCBjYWxsXG4gICAgICAvLyBJbmNsdWRpbmcgaXQgY2FuIGNhdXNlIHRoZSBlc3RpbWF0ZSB0byBmYWlsIGlmIHRoZSBhY3R1YWwgZ2FzIG5lZWRlZFxuICAgICAgLy8gZXhjZWVkcyB0aGUgcGFzc2VkIGdhc1xuICAgICAgY29uc3QgdHJhZGVUeFBhcmFtc0Zvckdhc0VzdGltYXRlID0ge1xuICAgICAgICBkYXRhOiB0cmFkZVR4UGFyYW1zLmRhdGEsXG4gICAgICAgIGZyb206IHRyYWRlVHhQYXJhbXMuZnJvbSxcbiAgICAgICAgdG86IHRyYWRlVHhQYXJhbXMudG8sXG4gICAgICAgIHZhbHVlOiB0cmFkZVR4UGFyYW1zLnZhbHVlLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5nZXRCdWZmZXJlZEdhc0xpbWl0KHsgdHhQYXJhbXM6IHRyYWRlVHhQYXJhbXNGb3JHYXNFc3RpbWF0ZSB9LCAxKVxuICAgICAgICAudGhlbigoeyBnYXNMaW1pdCwgc2ltdWxhdGlvbkZhaWxzIH0pID0+IHtcbiAgICAgICAgICBpZiAoIWdhc1RpbWVkT3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2FzVGltZW91dCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGxvZy5lcnJvcihlKTtcbiAgICAgICAgICBpZiAoIWdhc1RpbWVkT3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2FzVGltZW91dCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZ2FzTGltaXQ6IG51bGwsIHNpbXVsYXRpb25GYWlsczogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2V0SW5pdGlhbEdhc0VzdGltYXRlKGluaXRpYWxBZ2dJZCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgcXVvdGVUb1VwZGF0ZSA9IHsgLi4uc3dhcHNTdGF0ZS5xdW90ZXNbaW5pdGlhbEFnZ0lkXSB9O1xuXG4gICAgY29uc3Qge1xuICAgICAgZ2FzTGltaXQ6IG5ld0dhc0VzdGltYXRlLFxuICAgICAgc2ltdWxhdGlvbkZhaWxzLFxuICAgIH0gPSBhd2FpdCB0aGlzLnRpbWVkb3V0R2FzUmV0dXJuKHF1b3RlVG9VcGRhdGUudHJhZGUpO1xuXG4gICAgaWYgKG5ld0dhc0VzdGltYXRlICYmICFzaW11bGF0aW9uRmFpbHMpIHtcbiAgICAgIGNvbnN0IGdhc0VzdGltYXRlV2l0aFJlZnVuZCA9IGNhbGN1bGF0ZUdhc0VzdGltYXRlV2l0aFJlZnVuZChcbiAgICAgICAgcXVvdGVUb1VwZGF0ZS5tYXhHYXMsXG4gICAgICAgIHF1b3RlVG9VcGRhdGUuZXN0aW1hdGVkUmVmdW5kLFxuICAgICAgICBuZXdHYXNFc3RpbWF0ZSxcbiAgICAgICk7XG5cbiAgICAgIHF1b3RlVG9VcGRhdGUuZ2FzRXN0aW1hdGUgPSBuZXdHYXNFc3RpbWF0ZTtcbiAgICAgIHF1b3RlVG9VcGRhdGUuZ2FzRXN0aW1hdGVXaXRoUmVmdW5kID0gZ2FzRXN0aW1hdGVXaXRoUmVmdW5kO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5zd2Fwc1N0YXRlLFxuICAgICAgICBxdW90ZXM6IHsgLi4uc3dhcHNTdGF0ZS5xdW90ZXMsIFtpbml0aWFsQWdnSWRdOiBxdW90ZVRvVXBkYXRlIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0QXBwcm92ZVR4SWQoYXBwcm92ZVR4SWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBhcHByb3ZlVHhJZCB9IH0pO1xuICB9XG5cbiAgc2V0VHJhZGVUeElkKHRyYWRlVHhJZCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHRyYWRlVHhJZCB9IH0pO1xuICB9XG5cbiAgc2V0UXVvdGVzTGFzdEZldGNoZWQocXVvdGVzTGFzdEZldGNoZWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgcXVvdGVzTGFzdEZldGNoZWQgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzVHhHYXNQcmljZShnYXNQcmljZSkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBjdXN0b21HYXNQcmljZTogZ2FzUHJpY2UgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzVHhNYXhGZWVQZXJHYXMobWF4RmVlUGVyR2FzKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIGN1c3RvbU1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRTd2Fwc1VzZXJGZWVMZXZlbChzd2Fwc1VzZXJGZWVMZXZlbCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBzd2Fwc1VzZXJGZWVMZXZlbCB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0U3dhcHNRdW90ZXNQb2xsaW5nTGltaXRFbmFibGVkKHF1b3Rlc1BvbGxpbmdMaW1pdEVuYWJsZWQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgcXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZCB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0U3dhcHNUeE1heEZlZVByaW9yaXR5UGVyR2FzKG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7XG4gICAgICAgIC4uLnN3YXBzU3RhdGUsXG4gICAgICAgIGN1c3RvbU1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBzZXRTd2Fwc1R4R2FzTGltaXQoZ2FzTGltaXQpIHtcbiAgICBjb25zdCB7IHN3YXBzU3RhdGUgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgY3VzdG9tTWF4R2FzOiBnYXNMaW1pdCB9LFxuICAgIH0pO1xuICB9XG5cbiAgc2V0Q3VzdG9tQXBwcm92ZVR4RGF0YShkYXRhKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIGN1c3RvbUFwcHJvdmVUeERhdGE6IGRhdGEgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldEJhY2tncm91bmRTd2FwUm91dGVTdGF0ZShyb3V0ZVN0YXRlKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHN3YXBzU3RhdGU6IHsgLi4uc3dhcHNTdGF0ZSwgcm91dGVTdGF0ZSB9IH0pO1xuICB9XG5cbiAgc2V0U2F2ZUZldGNoZWRRdW90ZXMoc3RhdHVzKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHNhdmVGZXRjaGVkUXVvdGVzOiBzdGF0dXMgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzTGl2ZW5lc3Moc3dhcHNMaXZlbmVzcykge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgc3dhcHNGZWF0dXJlSXNMaXZlIH0gPSBzd2Fwc0xpdmVuZXNzO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZTogeyAuLi5zd2Fwc1N0YXRlLCBzd2Fwc0ZlYXR1cmVJc0xpdmUgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHNldFN3YXBzRmVhdHVyZUZsYWdzKHN3YXBzRmVhdHVyZUZsYWdzKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7IC4uLnN3YXBzU3RhdGUsIHN3YXBzRmVhdHVyZUZsYWdzIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXNldFBvc3RGZXRjaFN0YXRlKCkge1xuICAgIGNvbnN0IHsgc3dhcHNTdGF0ZSB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgc3dhcHNTdGF0ZToge1xuICAgICAgICAuLi5pbml0aWFsU3RhdGUuc3dhcHNTdGF0ZSxcbiAgICAgICAgdG9rZW5zOiBzd2Fwc1N0YXRlLnRva2VucyxcbiAgICAgICAgZmV0Y2hQYXJhbXM6IHN3YXBzU3RhdGUuZmV0Y2hQYXJhbXMsXG4gICAgICAgIHN3YXBzRmVhdHVyZUlzTGl2ZTogc3dhcHNTdGF0ZS5zd2Fwc0ZlYXR1cmVJc0xpdmUsXG4gICAgICAgIHN3YXBzUXVvdGVSZWZyZXNoVGltZTogc3dhcHNTdGF0ZS5zd2Fwc1F1b3RlUmVmcmVzaFRpbWUsXG4gICAgICAgIHN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lOlxuICAgICAgICAgIHN3YXBzU3RhdGUuc3dhcHNRdW90ZVByZWZldGNoaW5nUmVmcmVzaFRpbWUsXG4gICAgICAgIHN3YXBzRmVhdHVyZUZsYWdzOiBzd2Fwc1N0YXRlLnN3YXBzRmVhdHVyZUZsYWdzLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsaW5nVGltZW91dCk7XG4gIH1cblxuICByZXNldFN3YXBzU3RhdGUoKSB7XG4gICAgY29uc3QgeyBzd2Fwc1N0YXRlIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBzd2Fwc1N0YXRlOiB7XG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZS5zd2Fwc1N0YXRlLFxuICAgICAgICBzd2Fwc1F1b3RlUmVmcmVzaFRpbWU6IHN3YXBzU3RhdGUuc3dhcHNRdW90ZVJlZnJlc2hUaW1lLFxuICAgICAgICBzd2Fwc1F1b3RlUHJlZmV0Y2hpbmdSZWZyZXNoVGltZTpcbiAgICAgICAgICBzd2Fwc1N0YXRlLnN3YXBzUXVvdGVQcmVmZXRjaGluZ1JlZnJlc2hUaW1lLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsaW5nVGltZW91dCk7XG4gIH1cblxuICBhc3luYyBfZmluZFRvcFF1b3RlQW5kQ2FsY3VsYXRlU2F2aW5ncyhxdW90ZXMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczogdG9rZW5Db252ZXJzaW9uUmF0ZXMsXG4gICAgfSA9IHRoaXMuZ2V0VG9rZW5SYXRlc1N0YXRlKCk7XG4gICAgY29uc3Qge1xuICAgICAgc3dhcHNTdGF0ZTogeyBjdXN0b21HYXNQcmljZSwgY3VzdG9tTWF4UHJpb3JpdHlGZWVQZXJHYXMgfSxcbiAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLl9nZXRDdXJyZW50Q2hhaW5JZCgpO1xuXG4gICAgY29uc3QgbnVtUXVvdGVzID0gT2JqZWN0LmtleXMocXVvdGVzKS5sZW5ndGg7XG4gICAgaWYgKCFudW1RdW90ZXMpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdRdW90ZXMgPSBjbG9uZURlZXAocXVvdGVzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGdhc0ZlZUVzdGltYXRlcyxcbiAgICAgIGdhc0VzdGltYXRlVHlwZSxcbiAgICB9ID0gYXdhaXQgdGhpcy5fZ2V0RUlQMTU1OUdhc0ZlZUVzdGltYXRlcygpO1xuXG4gICAgbGV0IHVzZWRHYXNQcmljZSA9ICcweDAnO1xuXG4gICAgaWYgKGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGlnaDogeyBzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyB9LFxuICAgICAgICBlc3RpbWF0ZWRCYXNlRmVlLFxuICAgICAgfSA9IGdhc0ZlZUVzdGltYXRlcztcblxuICAgICAgdXNlZEdhc1ByaWNlID0gYWRkQ3VycmVuY2llcyhcbiAgICAgICAgY3VzdG9tTWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgLy8gSXMgYWxyZWFkeSBpbiBoZXggV0VJLlxuICAgICAgICAgIGRlY0dXRUlUb0hleFdFSShzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgIGRlY0dXRUlUb0hleFdFSShlc3RpbWF0ZWRCYXNlRmVlKSxcbiAgICAgICAge1xuICAgICAgICAgIGFCYXNlOiAxNixcbiAgICAgICAgICBiQmFzZTogMTYsXG4gICAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNixcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5MRUdBQ1kpIHtcbiAgICAgIHVzZWRHYXNQcmljZSA9IGN1c3RvbUdhc1ByaWNlIHx8IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMuaGlnaCk7XG4gICAgfSBlbHNlIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0UpIHtcbiAgICAgIHVzZWRHYXNQcmljZSA9XG4gICAgICAgIGN1c3RvbUdhc1ByaWNlIHx8IGRlY0dXRUlUb0hleFdFSShnYXNGZWVFc3RpbWF0ZXMuZ2FzUHJpY2UpO1xuICAgIH1cblxuICAgIGxldCB0b3BBZ2dJZCA9IG51bGw7XG4gICAgbGV0IG92ZXJhbGxWYWx1ZU9mQmVzdFF1b3RlRm9yU29ydGluZyA9IG51bGw7XG5cbiAgICBPYmplY3QudmFsdWVzKG5ld1F1b3RlcykuZm9yRWFjaCgocXVvdGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWdncmVnYXRvcixcbiAgICAgICAgYXBwcm92YWxOZWVkZWQsXG4gICAgICAgIGF2ZXJhZ2VHYXMsXG4gICAgICAgIGRlc3RpbmF0aW9uQW1vdW50ID0gMCxcbiAgICAgICAgZGVzdGluYXRpb25Ub2tlbixcbiAgICAgICAgZGVzdGluYXRpb25Ub2tlbkluZm8sXG4gICAgICAgIGdhc0VzdGltYXRlLFxuICAgICAgICBzb3VyY2VBbW91bnQsXG4gICAgICAgIHNvdXJjZVRva2VuLFxuICAgICAgICB0cmFkZSxcbiAgICAgICAgZmVlOiBtZXRhTWFza0ZlZSxcbiAgICAgIH0gPSBxdW90ZTtcblxuICAgICAgY29uc3QgdHJhZGVHYXNMaW1pdEZvckNhbGN1bGF0aW9uID0gZ2FzRXN0aW1hdGVcbiAgICAgICAgPyBuZXcgQmlnTnVtYmVyKGdhc0VzdGltYXRlLCAxNilcbiAgICAgICAgOiBuZXcgQmlnTnVtYmVyKGF2ZXJhZ2VHYXMgfHwgTUFYX0dBU19MSU1JVCwgMTApO1xuXG4gICAgICBjb25zdCB0b3RhbEdhc0xpbWl0Rm9yQ2FsY3VsYXRpb24gPSB0cmFkZUdhc0xpbWl0Rm9yQ2FsY3VsYXRpb25cbiAgICAgICAgLnBsdXMoYXBwcm92YWxOZWVkZWQ/LmdhcyB8fCAnMHgwJywgMTYpXG4gICAgICAgIC50b1N0cmluZygxNik7XG5cbiAgICAgIGNvbnN0IGdhc1RvdGFsSW5XZWlIZXggPSBjYWxjR2FzVG90YWwoXG4gICAgICAgIHRvdGFsR2FzTGltaXRGb3JDYWxjdWxhdGlvbixcbiAgICAgICAgdXNlZEdhc1ByaWNlLFxuICAgICAgKTtcblxuICAgICAgLy8gdHJhZGUudmFsdWUgaXMgYSBzdW0gb2YgZGlmZmVyZW50IHZhbHVlcyBkZXBlbmRpbmcgb24gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgLy8gSXQgYWx3YXlzIGluY2x1ZGVzIGFueSBleHRlcm5hbCBmZWVzIGNoYXJnZWQgYnkgdGhlIHF1b3RlIHNvdXJjZS4gSW5cbiAgICAgIC8vIGFkZGl0aW9uLCBpZiB0aGUgc291cmNlIGFzc2V0IGlzIHRoZSBzZWxlY3RlZCBjaGFpbidzIGRlZmF1bHQgdG9rZW4sIHRyYWRlLnZhbHVlXG4gICAgICAvLyBpbmNsdWRlcyB0aGUgYW1vdW50IG9mIHRoYXQgdG9rZW4uXG4gICAgICBjb25zdCB0b3RhbFdlaUNvc3QgPSBuZXcgQmlnTnVtYmVyKGdhc1RvdGFsSW5XZWlIZXgsIDE2KS5wbHVzKFxuICAgICAgICB0cmFkZS52YWx1ZSxcbiAgICAgICAgMTYsXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0b3RhbEV0aENvc3QgPSBjb252ZXJzaW9uVXRpbCh0b3RhbFdlaUNvc3QsIHtcbiAgICAgICAgZnJvbUN1cnJlbmN5OiAnRVRIJyxcbiAgICAgICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXG4gICAgICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgICAgICAgZnJvbU51bWVyaWNCYXNlOiAnQk4nLFxuICAgICAgICBudW1iZXJPZkRlY2ltYWxzOiA2LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSB0b3RhbCBmZWUgaXMgYWdncmVnYXRvci9leGNoYW5nZSBmZWVzIHBsdXMgZ2FzIGZlZXMuXG4gICAgICAvLyBJZiB0aGUgc3dhcCBpcyBmcm9tIHRoZSBzZWxlY3RlZCBjaGFpbidzIGRlZmF1bHQgdG9rZW4sIHN1YnRyYWN0XG4gICAgICAvLyB0aGUgc291cmNlQW1vdW50IGZyb20gdGhlIHRvdGFsIGNvc3QuIE90aGVyd2lzZSwgdGhlIHRvdGFsIGZlZVxuICAgICAgLy8gaXMgc2ltcGx5IHRyYWRlLnZhbHVlIHBsdXMgZ2FzIGZlZXMuXG4gICAgICBjb25zdCBldGhGZWUgPSBpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyhzb3VyY2VUb2tlbiwgY2hhaW5JZClcbiAgICAgICAgPyBjb252ZXJzaW9uVXRpbChcbiAgICAgICAgICAgIHRvdGFsV2VpQ29zdC5taW51cyhzb3VyY2VBbW91bnQsIDEwKSwgLy8gc291cmNlQW1vdW50IGlzIGluIHdlaVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmcm9tQ3VycmVuY3k6ICdFVEgnLFxuICAgICAgICAgICAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICAgICAgICAgICAgdG9EZW5vbWluYXRpb246ICdFVEgnLFxuICAgICAgICAgICAgICBmcm9tTnVtZXJpY0Jhc2U6ICdCTicsXG4gICAgICAgICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIClcbiAgICAgICAgOiB0b3RhbEV0aENvc3Q7XG5cbiAgICAgIGNvbnN0IGRlY2ltYWxBZGp1c3RlZERlc3RpbmF0aW9uQW1vdW50ID0gY2FsY1Rva2VuQW1vdW50KFxuICAgICAgICBkZXN0aW5hdGlvbkFtb3VudCxcbiAgICAgICAgZGVzdGluYXRpb25Ub2tlbkluZm8uZGVjaW1hbHMsXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0b2tlblBlcmNlbnRhZ2VPZlByZUZlZURlc3RBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDEwMCwgMTApXG4gICAgICAgIC5taW51cyhtZXRhTWFza0ZlZSwgMTApXG4gICAgICAgIC5kaXYoMTAwKTtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQW1vdW50QmVmb3JlTWV0YU1hc2tGZWUgPSBkZWNpbWFsQWRqdXN0ZWREZXN0aW5hdGlvbkFtb3VudC5kaXYoXG4gICAgICAgIHRva2VuUGVyY2VudGFnZU9mUHJlRmVlRGVzdEFtb3VudCxcbiAgICAgICk7XG4gICAgICBjb25zdCBtZXRhTWFza0ZlZUluVG9rZW5zID0gZGVzdGluYXRpb25BbW91bnRCZWZvcmVNZXRhTWFza0ZlZS5taW51cyhcbiAgICAgICAgZGVjaW1hbEFkanVzdGVkRGVzdGluYXRpb25BbW91bnQsXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0b2tlbkNvbnZlcnNpb25SYXRlID1cbiAgICAgICAgdG9rZW5Db252ZXJzaW9uUmF0ZXNbXG4gICAgICAgICAgT2JqZWN0LmtleXModG9rZW5Db252ZXJzaW9uUmF0ZXMpLmZpbmQoKHRva2VuQWRkcmVzcykgPT5cbiAgICAgICAgICAgIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUodG9rZW5BZGRyZXNzLCBkZXN0aW5hdGlvblRva2VuKSxcbiAgICAgICAgICApXG4gICAgICAgIF07XG4gICAgICBjb25zdCBjb252ZXJzaW9uUmF0ZUZvclNvcnRpbmcgPSB0b2tlbkNvbnZlcnNpb25SYXRlIHx8IDE7XG5cbiAgICAgIGNvbnN0IGV0aFZhbHVlT2ZUb2tlbnMgPSBkZWNpbWFsQWRqdXN0ZWREZXN0aW5hdGlvbkFtb3VudC50aW1lcyhcbiAgICAgICAgY29udmVyc2lvblJhdGVGb3JTb3J0aW5nLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgMTAsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBjb252ZXJzaW9uUmF0ZUZvckNhbGN1bGF0aW9ucyA9IGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKFxuICAgICAgICBkZXN0aW5hdGlvblRva2VuLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgKVxuICAgICAgICA/IDFcbiAgICAgICAgOiB0b2tlbkNvbnZlcnNpb25SYXRlO1xuXG4gICAgICBjb25zdCBvdmVyYWxsVmFsdWVPZlF1b3RlRm9yU29ydGluZyA9XG4gICAgICAgIGNvbnZlcnNpb25SYXRlRm9yQ2FsY3VsYXRpb25zID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGV0aFZhbHVlT2ZUb2tlbnNcbiAgICAgICAgICA6IGV0aFZhbHVlT2ZUb2tlbnMubWludXMoZXRoRmVlLCAxMCk7XG5cbiAgICAgIHF1b3RlLmV0aEZlZSA9IGV0aEZlZS50b1N0cmluZygxMCk7XG5cbiAgICAgIGlmIChjb252ZXJzaW9uUmF0ZUZvckNhbGN1bGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1b3RlLmV0aFZhbHVlT2ZUb2tlbnMgPSBldGhWYWx1ZU9mVG9rZW5zLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgcXVvdGUub3ZlcmFsbFZhbHVlT2ZRdW90ZSA9IG92ZXJhbGxWYWx1ZU9mUXVvdGVGb3JTb3J0aW5nLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgcXVvdGUubWV0YU1hc2tGZWVJbkV0aCA9IG1ldGFNYXNrRmVlSW5Ub2tlbnNcbiAgICAgICAgICAudGltZXMoY29udmVyc2lvblJhdGVGb3JDYWxjdWxhdGlvbnMudG9TdHJpbmcoMTApKVxuICAgICAgICAgIC50b1N0cmluZygxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb3ZlcmFsbFZhbHVlT2ZCZXN0UXVvdGVGb3JTb3J0aW5nID09PSBudWxsIHx8XG4gICAgICAgIG92ZXJhbGxWYWx1ZU9mUXVvdGVGb3JTb3J0aW5nLmd0KG92ZXJhbGxWYWx1ZU9mQmVzdFF1b3RlRm9yU29ydGluZylcbiAgICAgICkge1xuICAgICAgICB0b3BBZ2dJZCA9IGFnZ3JlZ2F0b3I7XG4gICAgICAgIG92ZXJhbGxWYWx1ZU9mQmVzdFF1b3RlRm9yU29ydGluZyA9IG92ZXJhbGxWYWx1ZU9mUXVvdGVGb3JTb3J0aW5nO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaXNCZXN0ID1cbiAgICAgIGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKFxuICAgICAgICBuZXdRdW90ZXNbdG9wQWdnSWRdLmRlc3RpbmF0aW9uVG9rZW4sXG4gICAgICAgIGNoYWluSWQsXG4gICAgICApIHx8XG4gICAgICBCb29sZWFuKFxuICAgICAgICB0b2tlbkNvbnZlcnNpb25SYXRlc1tcbiAgICAgICAgICBPYmplY3Qua2V5cyh0b2tlbkNvbnZlcnNpb25SYXRlcykuZmluZCgodG9rZW5BZGRyZXNzKSA9PlxuICAgICAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICBuZXdRdW90ZXNbdG9wQWdnSWRdPy5kZXN0aW5hdGlvblRva2VuLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApXG4gICAgICAgIF0sXG4gICAgICApO1xuXG4gICAgbGV0IHNhdmluZ3MgPSBudWxsO1xuXG4gICAgaWYgKGlzQmVzdCkge1xuICAgICAgY29uc3QgYmVzdFF1b3RlID0gbmV3UXVvdGVzW3RvcEFnZ0lkXTtcblxuICAgICAgc2F2aW5ncyA9IHt9O1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGV0aEZlZTogbWVkaWFuRXRoRmVlLFxuICAgICAgICBtZXRhTWFza0ZlZUluRXRoOiBtZWRpYW5NZXRhTWFza0ZlZSxcbiAgICAgICAgZXRoVmFsdWVPZlRva2VuczogbWVkaWFuRXRoVmFsdWVPZlRva2VucyxcbiAgICAgIH0gPSBnZXRNZWRpYW5FdGhWYWx1ZVF1b3RlKE9iamVjdC52YWx1ZXMobmV3UXVvdGVzKSk7XG5cbiAgICAgIC8vIFBlcmZvcm1hbmNlIHNhdmluZ3MgYXJlIGNhbGN1bGF0ZWQgYXM6XG4gICAgICAvLyAgIChldGhWYWx1ZU9mVG9rZW5zIGZvciB0aGUgYmVzdCB0cmFkZSkgLSAoZXRoVmFsdWVPZlRva2VucyBmb3IgdGhlIG1lZGlhIHRyYWRlKVxuICAgICAgc2F2aW5ncy5wZXJmb3JtYW5jZSA9IG5ldyBCaWdOdW1iZXIoYmVzdFF1b3RlLmV0aFZhbHVlT2ZUb2tlbnMsIDEwKS5taW51cyhcbiAgICAgICAgbWVkaWFuRXRoVmFsdWVPZlRva2VucyxcbiAgICAgICAgMTAsXG4gICAgICApO1xuXG4gICAgICAvLyBGZWUgc2F2aW5ncyBhcmUgY2FsY3VsYXRlZCBhczpcbiAgICAgIC8vICAgKGZlZSBmb3IgdGhlIG1lZGlhbiB0cmFkZSkgLSAoZmVlIGZvciB0aGUgYmVzdCB0cmFkZSlcbiAgICAgIHNhdmluZ3MuZmVlID0gbmV3IEJpZ051bWJlcihtZWRpYW5FdGhGZWUpLm1pbnVzKGJlc3RRdW90ZS5ldGhGZWUsIDEwKTtcblxuICAgICAgc2F2aW5ncy5tZXRhTWFza0ZlZSA9IGJlc3RRdW90ZS5tZXRhTWFza0ZlZUluRXRoO1xuXG4gICAgICAvLyBUb3RhbCBzYXZpbmdzIGFyZSBjYWxjdWxhdGVkIGFzOlxuICAgICAgLy8gICBwZXJmb3JtYW5jZSBzYXZpbmdzICsgZmVlIHNhdmluZ3MgLSBtZXRhbWFzayBmZWVcbiAgICAgIHNhdmluZ3MudG90YWwgPSBzYXZpbmdzLnBlcmZvcm1hbmNlXG4gICAgICAgIC5wbHVzKHNhdmluZ3MuZmVlKVxuICAgICAgICAubWludXMoc2F2aW5ncy5tZXRhTWFza0ZlZSlcbiAgICAgICAgLnRvU3RyaW5nKDEwKTtcbiAgICAgIHNhdmluZ3MucGVyZm9ybWFuY2UgPSBzYXZpbmdzLnBlcmZvcm1hbmNlLnRvU3RyaW5nKDEwKTtcbiAgICAgIHNhdmluZ3MuZmVlID0gc2F2aW5ncy5mZWUudG9TdHJpbmcoMTApO1xuICAgICAgc2F2aW5ncy5tZWRpYW5NZXRhTWFza0ZlZSA9IG1lZGlhbk1ldGFNYXNrRmVlO1xuXG4gICAgICBuZXdRdW90ZXNbdG9wQWdnSWRdLmlzQmVzdFF1b3RlID0gdHJ1ZTtcbiAgICAgIG5ld1F1b3Rlc1t0b3BBZ2dJZF0uc2F2aW5ncyA9IHNhdmluZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0b3BBZ2dJZCwgbmV3UXVvdGVzXTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRFUkMyMEFsbG93YW5jZShjb250cmFjdEFkZHJlc3MsIHdhbGxldEFkZHJlc3MsIGNoYWluSWQpIHtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhYmksXG4gICAgICB0aGlzLmV0aGVyc1Byb3ZpZGVyLFxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IGNvbnRyYWN0LmFsbG93YW5jZShcbiAgICAgIHdhbGxldEFkZHJlc3MsXG4gICAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW2NoYWluSWRdLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtZWRpYW4gb3ZlcmFsbFZhbHVlT2ZRdW90ZSBvZiBhIHNhbXBsZSBvZiBxdW90ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gX3F1b3RlcyAtIEEgc2FtcGxlIG9mIHF1b3RlIG9iamVjdHMgd2l0aCBvdmVyYWxsVmFsdWVPZlF1b3RlLCBldGhGZWUsIG1ldGFNYXNrRmVlSW5FdGgsIGFuZCBldGhWYWx1ZU9mVG9rZW5zIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBldGhWYWx1ZU9mVG9rZW5zLCBldGhGZWUsIGFuZCBtZXRhTWFza0ZlZUluRXRoIG9mIHRoZSBxdW90ZSB3aXRoIHRoZSBtZWRpYW4gb3ZlcmFsbFZhbHVlT2ZRdW90ZVxuICovXG5mdW5jdGlvbiBnZXRNZWRpYW5FdGhWYWx1ZVF1b3RlKF9xdW90ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KF9xdW90ZXMpIHx8IF9xdW90ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tZW1wdHkgYXJyYXkgcGFyYW0uJyk7XG4gIH1cblxuICBjb25zdCBxdW90ZXMgPSBbLi4uX3F1b3Rlc107XG5cbiAgcXVvdGVzLnNvcnQoKHF1b3RlQSwgcXVvdGVCKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmFsbFZhbHVlT2ZRdW90ZUEgPSBuZXcgQmlnTnVtYmVyKHF1b3RlQS5vdmVyYWxsVmFsdWVPZlF1b3RlLCAxMCk7XG4gICAgY29uc3Qgb3ZlcmFsbFZhbHVlT2ZRdW90ZUIgPSBuZXcgQmlnTnVtYmVyKHF1b3RlQi5vdmVyYWxsVmFsdWVPZlF1b3RlLCAxMCk7XG4gICAgaWYgKG92ZXJhbGxWYWx1ZU9mUXVvdGVBLmVxdWFscyhvdmVyYWxsVmFsdWVPZlF1b3RlQikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmFsbFZhbHVlT2ZRdW90ZUEubGVzc1RoYW4ob3ZlcmFsbFZhbHVlT2ZRdW90ZUIpID8gLTEgOiAxO1xuICB9KTtcblxuICBpZiAocXVvdGVzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gbWlkZGxlIHZhbHVlc1xuICAgIGNvbnN0IG1lZGlhbk92ZXJhbGxWYWx1ZSA9XG4gICAgICBxdW90ZXNbKHF1b3Rlcy5sZW5ndGggLSAxKSAvIDJdLm92ZXJhbGxWYWx1ZU9mUXVvdGU7XG4gICAgY29uc3QgcXVvdGVzTWF0Y2hpbmdNZWRpYW5RdW90ZVZhbHVlID0gcXVvdGVzLmZpbHRlcihcbiAgICAgIChxdW90ZSkgPT4gbWVkaWFuT3ZlcmFsbFZhbHVlID09PSBxdW90ZS5vdmVyYWxsVmFsdWVPZlF1b3RlLFxuICAgICk7XG4gICAgcmV0dXJuIG1lYW5zT2ZRdW90ZXNGZWVzQW5kVmFsdWUocXVvdGVzTWF0Y2hpbmdNZWRpYW5RdW90ZVZhbHVlKTtcbiAgfVxuXG4gIC8vIHJldHVybiBtZWFuIG9mIG1pZGRsZSB0d28gdmFsdWVzXG4gIGNvbnN0IHVwcGVySW5kZXggPSBxdW90ZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgbG93ZXJJbmRleCA9IHVwcGVySW5kZXggLSAxO1xuXG4gIGNvbnN0IG92ZXJhbGxWYWx1ZUF0VXBwZXJJbmRleCA9IHF1b3Rlc1t1cHBlckluZGV4XS5vdmVyYWxsVmFsdWVPZlF1b3RlO1xuICBjb25zdCBvdmVyYWxsVmFsdWVBdExvd2VySW5kZXggPSBxdW90ZXNbbG93ZXJJbmRleF0ub3ZlcmFsbFZhbHVlT2ZRdW90ZTtcblxuICBjb25zdCBxdW90ZXNNYXRjaGluZ1VwcGVySW5kZXhWYWx1ZSA9IHF1b3Rlcy5maWx0ZXIoXG4gICAgKHF1b3RlKSA9PiBvdmVyYWxsVmFsdWVBdFVwcGVySW5kZXggPT09IHF1b3RlLm92ZXJhbGxWYWx1ZU9mUXVvdGUsXG4gICk7XG4gIGNvbnN0IHF1b3Rlc01hdGNoaW5nTG93ZXJJbmRleFZhbHVlID0gcXVvdGVzLmZpbHRlcihcbiAgICAocXVvdGUpID0+IG92ZXJhbGxWYWx1ZUF0TG93ZXJJbmRleCA9PT0gcXVvdGUub3ZlcmFsbFZhbHVlT2ZRdW90ZSxcbiAgKTtcblxuICBjb25zdCBmZWVzQW5kVmFsdWVBdFVwcGVySW5kZXggPSBtZWFuc09mUXVvdGVzRmVlc0FuZFZhbHVlKFxuICAgIHF1b3Rlc01hdGNoaW5nVXBwZXJJbmRleFZhbHVlLFxuICApO1xuICBjb25zdCBmZWVzQW5kVmFsdWVBdExvd2VySW5kZXggPSBtZWFuc09mUXVvdGVzRmVlc0FuZFZhbHVlKFxuICAgIHF1b3Rlc01hdGNoaW5nTG93ZXJJbmRleFZhbHVlLFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgZXRoRmVlOiBuZXcgQmlnTnVtYmVyKGZlZXNBbmRWYWx1ZUF0VXBwZXJJbmRleC5ldGhGZWUsIDEwKVxuICAgICAgLnBsdXMoZmVlc0FuZFZhbHVlQXRMb3dlckluZGV4LmV0aEZlZSwgMTApXG4gICAgICAuZGl2aWRlZEJ5KDIpXG4gICAgICAudG9TdHJpbmcoMTApLFxuICAgIG1ldGFNYXNrRmVlSW5FdGg6IG5ldyBCaWdOdW1iZXIoXG4gICAgICBmZWVzQW5kVmFsdWVBdFVwcGVySW5kZXgubWV0YU1hc2tGZWVJbkV0aCxcbiAgICAgIDEwLFxuICAgIClcbiAgICAgIC5wbHVzKGZlZXNBbmRWYWx1ZUF0TG93ZXJJbmRleC5tZXRhTWFza0ZlZUluRXRoLCAxMClcbiAgICAgIC5kaXZpZGVkQnkoMilcbiAgICAgIC50b1N0cmluZygxMCksXG4gICAgZXRoVmFsdWVPZlRva2VuczogbmV3IEJpZ051bWJlcihcbiAgICAgIGZlZXNBbmRWYWx1ZUF0VXBwZXJJbmRleC5ldGhWYWx1ZU9mVG9rZW5zLFxuICAgICAgMTAsXG4gICAgKVxuICAgICAgLnBsdXMoZmVlc0FuZFZhbHVlQXRMb3dlckluZGV4LmV0aFZhbHVlT2ZUb2tlbnMsIDEwKVxuICAgICAgLmRpdmlkZWRCeSgyKVxuICAgICAgLnRvU3RyaW5nKDEwKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhcml0aG1ldGljIG1lYW4gZm9yIGVhY2ggb2YgdGhyZWUgcHJvcGVydGllcyAtIGV0aEZlZSwgbWV0YU1hc2tGZWVJbkV0aCBhbmQgZXRoVmFsdWVPZlRva2VucyAtIGFjcm9zc1xuICogYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRob3NlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVvdGVzIC0gQSBzYW1wbGUgb2YgcXVvdGUgb2JqZWN0cyB3aXRoIG92ZXJhbGxWYWx1ZU9mUXVvdGUsIGV0aEZlZSwgbWV0YU1hc2tGZWVJbkV0aCBhbmRcbiAqIGV0aFZhbHVlT2ZUb2tlbnMgcHJvcGVydGllc1xuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGFyaXRobWV0aWMgbWVhbiBlYWNoIG9mIHRoZSBldGhGZWUsIG1ldGFNYXNrRmVlSW5FdGggYW5kIGV0aFZhbHVlT2ZUb2tlbnMgb2ZcbiAqIHRoZSBwYXNzZWQgcXVvdGUgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBtZWFuc09mUXVvdGVzRmVlc0FuZFZhbHVlKHF1b3Rlcykge1xuICBjb25zdCBmZWVBbmRWYWx1ZVN1bXNBc0JpZ051bWJlcnMgPSBxdW90ZXMucmVkdWNlKFxuICAgIChmZWVBbmRWYWx1ZVN1bXMsIHF1b3RlKSA9PiAoe1xuICAgICAgZXRoRmVlOiBmZWVBbmRWYWx1ZVN1bXMuZXRoRmVlLnBsdXMocXVvdGUuZXRoRmVlLCAxMCksXG4gICAgICBtZXRhTWFza0ZlZUluRXRoOiBmZWVBbmRWYWx1ZVN1bXMubWV0YU1hc2tGZWVJbkV0aC5wbHVzKFxuICAgICAgICBxdW90ZS5tZXRhTWFza0ZlZUluRXRoLFxuICAgICAgICAxMCxcbiAgICAgICksXG4gICAgICBldGhWYWx1ZU9mVG9rZW5zOiBmZWVBbmRWYWx1ZVN1bXMuZXRoVmFsdWVPZlRva2Vucy5wbHVzKFxuICAgICAgICBxdW90ZS5ldGhWYWx1ZU9mVG9rZW5zLFxuICAgICAgICAxMCxcbiAgICAgICksXG4gICAgfSksXG4gICAge1xuICAgICAgZXRoRmVlOiBuZXcgQmlnTnVtYmVyKDAsIDEwKSxcbiAgICAgIG1ldGFNYXNrRmVlSW5FdGg6IG5ldyBCaWdOdW1iZXIoMCwgMTApLFxuICAgICAgZXRoVmFsdWVPZlRva2VuczogbmV3IEJpZ051bWJlcigwLCAxMCksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGV0aEZlZTogZmVlQW5kVmFsdWVTdW1zQXNCaWdOdW1iZXJzLmV0aEZlZVxuICAgICAgLmRpdihxdW90ZXMubGVuZ3RoLCAxMClcbiAgICAgIC50b1N0cmluZygxMCksXG4gICAgbWV0YU1hc2tGZWVJbkV0aDogZmVlQW5kVmFsdWVTdW1zQXNCaWdOdW1iZXJzLm1ldGFNYXNrRmVlSW5FdGhcbiAgICAgIC5kaXYocXVvdGVzLmxlbmd0aCwgMTApXG4gICAgICAudG9TdHJpbmcoMTApLFxuICAgIGV0aFZhbHVlT2ZUb2tlbnM6IGZlZUFuZFZhbHVlU3Vtc0FzQmlnTnVtYmVycy5ldGhWYWx1ZU9mVG9rZW5zXG4gICAgICAuZGl2KHF1b3Rlcy5sZW5ndGgsIDEwKVxuICAgICAgLnRvU3RyaW5nKDEwKSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICBnZXRNZWRpYW5FdGhWYWx1ZVF1b3RlLFxuICBtZWFuc09mUXVvdGVzRmVlc0FuZFZhbHVlLFxufTtcbiIsImNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgSERLZXkgPSByZXF1aXJlKCdoZGtleScpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IHNpZ1V0aWwgPSByZXF1aXJlKCdldGgtc2lnLXV0aWwnKVxuY29uc3QgeyBUcmFuc2FjdGlvbkZhY3RvcnkgfSA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4JylcblxuY29uc3QgcGF0aEJhc2UgPSAnbSdcbmNvbnN0IGhkUGF0aFN0cmluZyA9IGAke3BhdGhCYXNlfS80NCcvNjAnLzAnYFxuY29uc3QgdHlwZSA9ICdMZWRnZXIgSGFyZHdhcmUnXG5cbmNvbnN0IEJSSURHRV9VUkwgPSAnaHR0cHM6Ly9tZXRhbWFzay5naXRodWIuaW8vZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZydcblxuY29uc3QgTUFYX0lOREVYID0gMTAwMFxuY29uc3QgTkVUV09SS19BUElfVVJMUyA9IHtcbiAgcm9wc3RlbjogJ2h0dHA6Ly9hcGktcm9wc3Rlbi5ldGhlcnNjYW4uaW8nLFxuICBrb3ZhbjogJ2h0dHA6Ly9hcGkta292YW4uZXRoZXJzY2FuLmlvJyxcbiAgcmlua2VieTogJ2h0dHBzOi8vYXBpLXJpbmtlYnkuZXRoZXJzY2FuLmlvJyxcbiAgbWFpbm5ldDogJ2h0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pbycsXG59XG5cbmNsYXNzIExlZGdlckJyaWRnZUtleXJpbmcgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSB7fVxuICAgIHRoaXMuYnJpZGdlVXJsID0gbnVsbFxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgdGhpcy5wZXJQYWdlID0gNVxuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMFxuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KClcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmlmcmFtZSA9IG51bGxcbiAgICB0aGlzLm5ldHdvcmsgPSAnbWFpbm5ldCdcbiAgICB0aGlzLmltcGxlbWVudEZ1bGxCSVA0NCA9IGZhbHNlXG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKVxuXG4gICAgdGhpcy5pZnJhbWVMb2FkZWQgPSBmYWxzZVxuICAgIHRoaXMuX3NldHVwSWZyYW1lKClcbiAgfVxuXG4gIHNlcmlhbGl6ZSAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBhY2NvdW50RGV0YWlsczogdGhpcy5hY2NvdW50RGV0YWlscyxcbiAgICAgIGJyaWRnZVVybDogdGhpcy5icmlkZ2VVcmwsXG4gICAgICBpbXBsZW1lbnRGdWxsQklQNDQ6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICBkZXNlcmlhbGl6ZSAob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aCB8fCBoZFBhdGhTdHJpbmdcbiAgICB0aGlzLmJyaWRnZVVybCA9IG9wdHMuYnJpZGdlVXJsIHx8IEJSSURHRV9VUkxcbiAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cyB8fCBbXVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSBvcHRzLmFjY291bnREZXRhaWxzIHx8IHt9XG4gICAgaWYgKCFvcHRzLmFjY291bnREZXRhaWxzKSB7XG4gICAgICB0aGlzLl9taWdyYXRlQWNjb3VudERldGFpbHMob3B0cylcbiAgICB9XG5cbiAgICB0aGlzLmltcGxlbWVudEZ1bGxCSVA0NCA9IG9wdHMuaW1wbGVtZW50RnVsbEJJUDQ0IHx8IGZhbHNlXG5cbiAgICAvLyBSZW1vdmUgYWNjb3VudHMgdGhhdCBkb24ndCBoYXZlIGNvcnJlc3BvbmRpbmcgYWNjb3VudCBkZXRhaWxzXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHNcbiAgICAgIC5maWx0ZXIoKGFjY291bnQpID0+IE9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCkpKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBfbWlncmF0ZUFjY291bnREZXRhaWxzIChvcHRzKSB7XG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpICYmIG9wdHMuYWNjb3VudEluZGV4ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBPYmplY3Qua2V5cyhvcHRzLmFjY291bnRJbmRleGVzKSkge1xuICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2FjY291bnRdID0ge1xuICAgICAgICAgIGJpcDQ0OiB0cnVlLFxuICAgICAgICAgIGhkUGF0aDogdGhpcy5fZ2V0UGF0aEZvckluZGV4KG9wdHMuYWNjb3VudEluZGV4ZXNbYWNjb3VudF0pLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIG1pZ3JhdGUgbm9uLUxlZGdlckxpdmUgYWNjb3VudHMgdG9vXG4gICAgaWYgKCF0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSkge1xuICAgICAgdGhpcy5hY2NvdW50c1xuICAgICAgICAuZmlsdGVyKChhY2NvdW50KSA9PiAhT2JqZWN0LmtleXModGhpcy5hY2NvdW50RGV0YWlscykuaW5jbHVkZXMoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhY2NvdW50KSkpXG4gICAgICAgIC5mb3JFYWNoKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudERldGFpbHNbZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhY2NvdW50KV0gPSB7XG4gICAgICAgICAgICAgIGJpcDQ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgaGRQYXRoOiB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWNjb3VudCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGZhaWxlZCB0byBtaWdyYXRlIGFjY291bnQgJHthY2NvdW50fWApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzVW5sb2NrZWQgKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuaGRrICYmIHRoaXMuaGRrLnB1YmxpY0tleSlcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIHNldEhkUGF0aCAoaGRQYXRoKSB7XG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoXG4gIH1cblxuICB1bmxvY2sgKGhkUGF0aCkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSAmJiAhaGRQYXRoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJylcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGhkUGF0aCA/IHRoaXMuX3RvTGVkZ2VyUGF0aChoZFBhdGgpIDogdGhpcy5oZFBhdGhcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdW5sb2NrJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMuaGRrLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgICB0aGlzLmhkay5jaGFpbkNvZGUgPSBCdWZmZXIuZnJvbShwYXlsb2FkLmNoYWluQ29kZSwgJ2hleCcpXG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmFkZHJlc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oYXN5bmMgKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy51bmxvY2tlZEFjY291bnRcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhwYXRoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0ge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0aGlzIHByb3BlcnR5LCBhcyB0aGUgY3VycmVudCBuYW1lIGlzIG1pc2xlYWRpbmdcbiAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCB0byByZXByZXNlbnQgd2hldGhlciBhbiBhY2NvdW50IHVzZXMgdGhlIExlZGdlciBMaXZlIHBhdGguXG4gICAgICAgICAgICAgIGJpcDQ0OiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSxcbiAgICAgICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hY2NvdW50cylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlICgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSlcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQgKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKVxuICAgIH1cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoKGEpID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgIGRlbGV0ZSB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldXG4gIH1cblxuICBhdHRlbXB0TWFrZUFwcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLW1ha2UtYXBwJyxcbiAgICAgIH0sICh7IHN1Y2Nlc3MsIGVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVUcmFuc3BvcnRNZXRob2QgKHRyYW5zcG9ydFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0LCBsZXQncyBzdG9yZSB0aGUgZGVzaXJlZCB0cmFuc3BvcnRUeXBlIHZhbHVlIGFuZFxuICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlXG4gICAgICBpZiAoIXRoaXMuaWZyYW1lTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UgPSB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgdHJhbnNwb3J0VHlwZSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdXBkYXRlLXRyYW5zcG9ydCcsXG4gICAgICAgIHBhcmFtczogeyB0cmFuc3BvcnRUeXBlIH0sXG4gICAgICB9LCAoeyBzdWNjZXNzIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyIHRyYW5zcG9ydCBjb3VsZCBub3QgYmUgdXBkYXRlZCcpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIGxldCByYXdUeEhleFxuICAgIC8vIHRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gICAgLy8gZ2V0Q2hhaW5JZCBtZXRob2QgdGhhdCBuZXdlciB2ZXJzaW9ucyBkbyBub3QuIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gICAgLy8gd2hpbGUgbmV3ZXIgdmVyc2lvbnMgZGVmYXVsdCB0byBiZWluZyBpbW11dGFibGUuIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gICAgLy8gb2YgZGF0YSBmb3IgdiwgciBhbmQgcyBkaWZmZXIgKEJ1ZmZlciAob2xkKSB2cyBCTiAobmV3KSlcbiAgICBpZiAodHlwZW9mIHR4LmdldENoYWluSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICB0eC52ID0gZXRoVXRpbC5idWZmZXJUb0hleCh0eC5nZXRDaGFpbklkKCkpXG4gICAgICB0eC5yID0gJzB4MDAnXG4gICAgICB0eC5zID0gJzB4MDAnXG5cbiAgICAgIHJhd1R4SGV4ID0gdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKVxuICAgICAgICB0eC5yID0gQnVmZmVyLmZyb20ocGF5bG9hZC5yLCAnaGV4JylcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpXG4gICAgICAgIHJldHVybiB0eFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVsb3cgYGVuY29kZWAgY2FsbCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgYXMgYGdldE1lc3NhZ2VUb1NpZ25gXG4gICAgLy8gY2FsbHMgYHJscC5lbmNvZGVgIGludGVybmFsbHkgZm9yIG5vbi1sZWdhY3kgdHJhbnNhY3Rpb25zLiBBcyBwZXIgdGhlIFwiVHJhbnNhY3Rpb24gRXhlY3V0aW9uXCJcbiAgICAvLyBzZWN0aW9uIG9mIHRoZSBldGhlcmV1bSB5ZWxsb3cgcGFwZXIsIHRyYW5zYWN0aW9ucyBuZWVkIHRvIGJlIFwid2VsbC1mb3JtZWQgUkxQLCB3aXRoIG5vIGFkZGl0aW9uYWxcbiAgICAvLyB0cmFpbGluZyBieXRlc1wiLlxuXG4gICAgLy8gTm90ZSBhbHNvIHRoYXQgYGdldE1lc3NhZ2VUb1NpZ25gIHdpbGwgcmV0dXJuIHZhbGlkIFJMUCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzLCB3aGVyZWFzIHRoZVxuICAgIC8vIGBzZXJpYWxpemVgIG1ldGhvZCB3aWxsIG5vdCBmb3IgYW55IHRyYW5zYWN0aW9uIHR5cGUgZXhjZXB0IGxlZ2FjeS4gVGhpcyBpcyBiZWNhdXNlIGBzZXJpYWxpemVgIGluY2x1ZGVzXG4gICAgLy8gZW1wdHkgciwgcyBhbmQgdiB2YWx1ZXMgaW4gdGhlIGVuY29kZWQgcmxwLiBUaGlzIGlzIHdoeSB3ZSB1c2UgYGdldE1lc3NhZ2VUb1NpZ25gIGhlcmUgaW5zdGVhZCBvZiBgc2VyaWFsaXplYC5cbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSlcblxuICAgIHJhd1R4SGV4ID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2VUb1NpZ24pXG4gICAgICA/IG1lc3NhZ2VUb1NpZ24udG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IGV0aFV0aWwucmxwLmVuY29kZShtZXNzYWdlVG9TaWduKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIHR4IHdpbGwgYmUgaW1tdXRhYmxlLCBmaXJzdCBnZXQgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAvLyBub21lbmNsYXR1cmUgb2YgZXRoZXJldW1qcy90eC5cbiAgICAgIGNvbnN0IHR4RGF0YSA9IHR4LnRvSlNPTigpXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgYSB0eXBlIHRvIHN1cHBvcnQgdHJhbnNhY3Rpb25zIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gMFxuICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgdHhEYXRhLnYgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnYpXG4gICAgICB0eERhdGEuciA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucilcbiAgICAgIHR4RGF0YS5zID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5zKVxuICAgICAgLy8gQWRvcHQgdGhlICdjb21tb24nIG9wdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBhbmQgc2V0IHRoZVxuICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IHRvIGJlIGZyb3plbiBpZiB0aGUgb3JpZ2luYWwgaXMgZnJvemVuLlxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwgeyBjb21tb246IHR4LmNvbW1vbiwgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9zaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHJhd1R4SGV4LCBoYW5kbGVTaWduaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAudGhlbigoaGRQYXRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHR4OiByYXdUeEhleCxcbiAgICAgICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdPck11dGF0ZWRUeCA9IGhhbmRsZVNpZ25pbmcocGF5bG9hZClcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBuZXdPck11dGF0ZWRUeC52ZXJpZnlTaWduYXR1cmUoKVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld09yTXV0YXRlZFR4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyB0cmFuc2FjdGlvbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25NZXNzYWdlICh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXBlcnNvbmFsLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGxldCB2ID0gcGF5bG9hZC52IC0gMjdcbiAgICAgICAgICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhOiBtZXNzYWdlLCBzaWc6IHNpZ25hdHVyZSB9KVxuICAgICAgICAgICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgdW5sb2NrQWNjb3VudEJ5QWRkcmVzcyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcylcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGNoZWNrc3VtbWVkQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50IGZvciBhZGRyZXNzICcke2NoZWNrc3VtbWVkQWRkcmVzc30nIG5vdCBmb3VuZGApXG4gICAgfVxuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnREZXRhaWxzW2NoZWNrc3VtbWVkQWRkcmVzc11cbiAgICBjb25zdCB1bmxvY2tlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhoZFBhdGgpXG5cbiAgICAvLyB1bmxvY2sgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBoZFBhdGggYXMgcmVwb3J0ZWQgYnkgdGhlIGxlZGdlciBkZXZpY2VcbiAgICAvLyBpZiB0aGF0IGFkZHJlc3MgaXMgbm90IHRoZSByZXF1ZXN0ZWQgYWRkcmVzcywgdGhlbiB0aGlzIGFjY291bnQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBkZXZpY2Ugb3Igc2VlZFxuICAgIGlmICh1bmxvY2tlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZGdlcjogQWNjb3VudCAke2FkZHJlc3N9IGRvZXMgbm90IGJlbG9uZyB0byB0aGUgY29ubmVjdGVkIGRldmljZWApXG4gICAgfVxuICAgIHJldHVybiBoZFBhdGhcbiAgfVxuXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEgKHdpdGhBY2NvdW50LCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpc1Y0ID0gb3B0aW9ucy52ZXJzaW9uID09PSAnVjQnXG4gICAgaWYgKCFpc1Y0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlZGdlcjogT25seSB2ZXJzaW9uIDQgb2YgdHlwZWQgZGF0YSBzaWduaW5nIGlzIHN1cHBvcnRlZCcpXG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZG9tYWluLFxuICAgICAgdHlwZXMsXG4gICAgICBwcmltYXJ5VHlwZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgfSA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuc2FuaXRpemVEYXRhKGRhdGEpXG4gICAgY29uc3QgZG9tYWluU2VwYXJhdG9ySGV4ID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBkb21haW4sIHR5cGVzLCBpc1Y0KS50b1N0cmluZygnaGV4JylcbiAgICBjb25zdCBoYXNoU3RydWN0TWVzc2FnZUhleCA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuaGFzaFN0cnVjdChwcmltYXJ5VHlwZSwgbWVzc2FnZSwgdHlwZXMsIGlzVjQpLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy51bmxvY2tBY2NvdW50QnlBZGRyZXNzKHdpdGhBY2NvdW50KVxuICAgIGNvbnN0IHsgc3VjY2VzcywgcGF5bG9hZCB9ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHlwZWQtZGF0YScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICBkb21haW5TZXBhcmF0b3JIZXgsXG4gICAgICAgICAgaGFzaFN0cnVjdE1lc3NhZ2VIZXgsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgKHJlc3VsdCkgPT4gcmVzb2x2ZShyZXN1bHQpKVxuICAgIH0pXG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgbGV0IHYgPSBwYXlsb2FkLnYgLSAyN1xuICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICBpZiAodi5sZW5ndGggPCAyKSB7XG4gICAgICAgIHYgPSBgMCR7dn1gXG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBgMHgke3BheWxvYWQucn0ke3BheWxvYWQuc30ke3Z9YFxuICAgICAgY29uc3QgYWRkcmVzc1NpZ25lZFdpdGggPSBzaWdVdGlsLnJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZzogc2lnbmF0dXJlLFxuICAgICAgfSlcbiAgICAgIGlmIChldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3NTaWduZWRXaXRoKSAhPT0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyh3aXRoQWNjb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXI6IFRoZSBzaWduYXR1cmUgZG9lc250IG1hdGNoIHRoZSByaWdodCBhZGRyZXNzJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaWduYXR1cmVcbiAgICB9XG4gICAgdGhyb3cgcGF5bG9hZC5lcnJvciB8fCBuZXcgRXJyb3IoJ0xlZGdlcjogVW5rbm93biBlcnJvciB3aGlsZSBzaWduaW5nIG1lc3NhZ2UnKVxuICB9XG5cbiAgZXhwb3J0QWNjb3VudCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJylcbiAgfVxuXG4gIGZvcmdldERldmljZSAoKSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdXG4gICAgdGhpcy5wYWdlID0gMFxuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMFxuICAgIHRoaXMucGF0aHMgPSB7fVxuICAgIHRoaXMuYWNjb3VudERldGFpbHMgPSB7fVxuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KClcbiAgfVxuXG4gIC8qIFBSSVZBVEUgTUVUSE9EUyAqL1xuXG4gIF9zZXR1cElmcmFtZSAoKSB7XG4gICAgdGhpcy5pZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgIHRoaXMuaWZyYW1lLnNyYyA9IHRoaXMuYnJpZGdlVXJsXG4gICAgdGhpcy5pZnJhbWUuYWxsb3cgPSBgaGlkICdzcmMnYFxuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBsZWRnZXIgbGl2ZSBwcmVmZXJlbmNlIHdhcyBzZXQgYmVmb3JlIHRoZSBpZnJhbWUgaXMgbG9hZGVkLFxuICAgICAgLy8gc2V0IGl0IGFmdGVyIHRoZSBpZnJhbWUgaGFzIGxvYWRlZFxuICAgICAgdGhpcy5pZnJhbWVMb2FkZWQgPSB0cnVlXG4gICAgICBpZiAodGhpcy5kZWxheWVkUHJvbWlzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudXBkYXRlVHJhbnNwb3J0TWV0aG9kKFxuICAgICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS50cmFuc3BvcnRUeXBlLFxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLmRlbGF5ZWRQcm9taXNlLnJlc29sdmUocmVzdWx0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS5yZWplY3QoZSlcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5kZWxheWVkUHJvbWlzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5pZnJhbWUpXG4gIH1cblxuICBfZ2V0T3JpZ2luICgpIHtcbiAgICBjb25zdCB0bXAgPSB0aGlzLmJyaWRnZVVybC5zcGxpdCgnLycpXG4gICAgdG1wLnNwbGljZSgtMSwgMSlcbiAgICByZXR1cm4gdG1wLmpvaW4oJy8nKVxuICB9XG5cbiAgX3NlbmRNZXNzYWdlIChtc2csIGNiKSB7XG4gICAgbXNnLnRhcmdldCA9ICdMRURHRVItSUZSQU1FJ1xuICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9ICh7IG9yaWdpbiwgZGF0YSB9KSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9nZXRPcmlnaW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5hY3Rpb24gJiYgZGF0YS5hY3Rpb24gPT09IGAke21zZy5hY3Rpb259LXJlcGx5YCAmJiBjYikge1xuICAgICAgICBjYihkYXRhKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnRMaXN0ZW5lcilcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudExpc3RlbmVyKVxuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlIChpbmNyZW1lbnQpIHtcblxuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnRcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMVxuICAgIH1cbiAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlXG5cbiAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgbGV0IGFjY291bnRzXG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX2dldEFjY291bnRzQklQNDQoZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY291bnRzID0gdGhpcy5fZ2V0QWNjb3VudHNMZWdhY3koZnJvbSwgdG8pXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgYXN5bmMgX2dldEFjY291bnRzQklQNDQgKGZyb20sIHRvKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPyBhd2FpdCB0aGlzLl9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyhhZGRyZXNzKSA6IHRydWVcbiAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgICAvLyBQRVIgQklQNDRcbiAgICAgIC8vIFwiU29mdHdhcmUgc2hvdWxkIHByZXZlbnQgYSBjcmVhdGlvbiBvZiBhbiBhY2NvdW50IGlmXG4gICAgICAvLyBhIHByZXZpb3VzIGFjY291bnQgZG9lcyBub3QgaGF2ZSBhIHRyYW5zYWN0aW9uIGhpc3RvcnlcbiAgICAgIC8vIChtZWFuaW5nIG5vbmUgb2YgaXRzIGFkZHJlc3NlcyBoYXZlIGJlZW4gdXNlZCBiZWZvcmUpLlwiXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX2dldEFjY291bnRzTGVnYWN5IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRzXG4gIH1cblxuICBfcGFkTGVmdEV2ZW4gKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGAwJHtoZXh9YFxuICB9XG5cbiAgX25vcm1hbGl6ZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZExlZnRFdmVuKGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleCAocGF0aEJhc2UsIGkpIHtcbiAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BhdGhCYXNlfS8ke2l9YClcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YClcbiAgfVxuXG4gIF9wYXRoRnJvbUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdGhGb3JJbmRleChpbmRleClcbiAgfVxuXG4gIF90b0FzY2lpIChoZXgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aFxuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBpID0gMlxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBfZ2V0UGF0aEZvckluZGV4IChpbmRleCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGlzIEJJUCA0NCAoTGVkZ2VyIExpdmUpXG4gICAgcmV0dXJuIHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpID8gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYCA6IGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWBcbiAgfVxuXG4gIF9pc0xlZGdlckxpdmVIZFBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLmhkUGF0aCA9PT0gYG0vNDQnLzYwJy8wJy8wLzBgXG4gIH1cblxuICBfdG9MZWRnZXJQYXRoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5yZXBsYWNlKCdtLycsICcnKVxuICB9XG5cbiAgYXN5bmMgX2hhc1ByZXZpb3VzVHJhbnNhY3Rpb25zIChhZGRyZXNzKSB7XG4gICAgY29uc3QgYXBpVXJsID0gdGhpcy5fZ2V0QXBpVXJsKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MSZvZmZzZXQ9MWApXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAocGFyc2VkUmVzcG9uc2Uuc3RhdHVzICE9PSAnMCcgJiYgcGFyc2VkUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldEFwaVVybCAoKSB7XG4gICAgcmV0dXJuIE5FVFdPUktfQVBJX1VSTFNbdGhpcy5uZXR3b3JrXSB8fCBORVRXT1JLX0FQSV9VUkxTLm1haW5uZXRcbiAgfVxuXG59XG5cbkxlZGdlckJyaWRnZUtleXJpbmcudHlwZSA9IHR5cGVcbm1vZHVsZS5leHBvcnRzID0gTGVkZ2VyQnJpZGdlS2V5cmluZ1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmLXJld3JpdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stdHJhY2tlci1pbnNwZWN0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmZsaWdodC1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJBc01pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbUVuZ2luZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmV0cnlPbkVtcHR5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVuYXNzaWduZWQtaW1wb3J0XG5yZXF1aXJlKFwiaXNvbW9ycGhpYy1mZXRjaFwiKTtcbmNvbnN0IFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlclwiKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXJfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBCTiA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpO1xuY29uc3QgU0RLID0gcmVxdWlyZSgnZ3JpZHBsdXMtc2RrJyk7XG5jb25zdCBFdGhUeCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCdAZXRoZXJldW1qcy9jb21tb24nKS5kZWZhdWx0O1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuY29uc3Qga2V5cmluZ1R5cGUgPSAnTGF0dGljZSBIYXJkd2FyZSc7XG5jb25zdCBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuY29uc3QgUEVSX1BBR0UgPSA1O1xuY29uc3QgQ0xPU0VfQ09ERSA9IC0xMDAwO1xuY29uc3QgU1RBTkRBUkRfSERfUEFUSCA9IGBtLzQ0Jy82MCcvMCcvMC94YDtcbmNvbnN0IFNES19USU1FT1VUID0gMTIwMDAwO1xuY29uc3QgQ09OTkVDVF9USU1FT1VUID0gMjAwMDA7XG5cbmNsYXNzIExhdHRpY2VLZXlyaW5nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHM9e30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0ga2V5cmluZ1R5cGU7XG4gICAgdGhpcy5fcmVzZXREZWZhdWx0cygpO1xuICAgIHRoaXMuZGVzZXJpYWxpemUob3B0cyk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gS2V5cmluZyBBUEkgKHBlciBgaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2V0aC1zaW1wbGUta2V5cmluZ2ApXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBkZXNlcmlhbGl6ZSAob3B0cyA9IHt9KSB7XG4gICAgaWYgKG9wdHMuaGRQYXRoKVxuICAgICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aDtcbiAgICBpZiAob3B0cy5jcmVkcylcbiAgICAgIHRoaXMuY3JlZHMgPSBvcHRzLmNyZWRzO1xuICAgIGlmIChvcHRzLmFjY291bnRzKVxuICAgICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHM7XG4gICAgaWYgKG9wdHMuYWNjb3VudEluZGljZXMpXG4gICAgICB0aGlzLmFjY291bnRJbmRpY2VzID0gb3B0cy5hY2NvdW50SW5kaWNlcztcbiAgICBpZiAob3B0cy5hY2NvdW50T3B0cylcbiAgICAgIHRoaXMuYWNjb3VudE9wdHMgPSBvcHRzLmFjY291bnRPcHRzO1xuICAgIGlmIChvcHRzLndhbGxldFVJRClcbiAgICAgIHRoaXMud2FsbGV0VUlEID0gb3B0cy53YWxsZXRVSUQ7XG4gICAgaWYgKG9wdHMubmFtZSkgIC8vIExlZ2FjeTsgdXNlIGlzIGRlcHJlY2F0ZWQgYW5kIGFwcE5hbWUgaXMgbW9yZSBkZXNjcmlwdGl2ZVxuICAgICAgdGhpcy5hcHBOYW1lID0gb3B0cy5uYW1lO1xuICAgIGlmIChvcHRzLmFwcE5hbWUpXG4gICAgICB0aGlzLmFwcE5hbWUgPSBvcHRzLmFwcE5hbWU7XG4gICAgaWYgKG9wdHMubmV0d29yaylcbiAgICAgIHRoaXMubmV0d29yayA9IG9wdHMubmV0d29yaztcbiAgICBpZiAob3B0cy5wYWdlKVxuICAgICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlO1xuICAgIGlmIChvcHRzLnNka1N0YXRlKVxuICAgICAgdGhpcy5zZGtTdGF0ZSA9IG9wdHMuc2RrU3RhdGU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBzZXRIZFBhdGgoaGRQYXRoKSB7XG4gICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gIH1cblxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBjcmVkczogdGhpcy5jcmVkcyxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgYWNjb3VudEluZGljZXM6IHRoaXMuYWNjb3VudEluZGljZXMsXG4gICAgICBhY2NvdW50T3B0czogdGhpcy5hY2NvdW50T3B0cyxcbiAgICAgIHdhbGxldFVJRDogdGhpcy53YWxsZXRVSUQsXG4gICAgICBhcHBOYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsICAvLyBMZWdhY3k7IHVzZSBpcyBkZXByZWNhdGVkXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmssXG4gICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgc2RrU3RhdGU6IHRoaXMuc2RrU2Vzc2lvbiA/IFxuICAgICAgICAgICAgICAgIHRoaXMuc2RrU2Vzc2lvbi5nZXRTdGF0ZURhdGEoKSA6XG4gICAgICAgICAgICAgICAgbnVsbFxuICAgIH0pXG4gIH1cblxuICAvLyBEZXRlcmltaW5lIGlmIHdlIGhhdmUgYSBjb25uZWN0aW9uIHRvIHRoZSBMYXR0aWNlIGFuZCBhbiBleGlzdGluZyB3YWxsZXQgVUlEXG4gIC8vIGFnYWluc3Qgd2hpY2ggdG8gbWFrZSByZXF1ZXN0cy5cbiAgaXNVbmxvY2tlZCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZ2V0Q3VycmVudFdhbGxldFVJRCgpICYmICEhdGhpcy5zZGtTZXNzaW9uO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBhIHNlc3Npb24gd2l0aCB0aGUgTGF0dGljZTEgZGV2aWNlIHVzaW5nIHRoZSBHcmlkUGx1cyBTREtcbiAgLy8gTk9URTogYGJ5cGFzc09uU3RhdGVEYXRhPXRydWVgIGFsbG93cyB1cyB0byByZWh5ZHJhdGUgYSBuZXcgU0RLIHNlc3Npb24gd2l0aG91dFxuICAvLyByZWNvbm5lY3RpbmcgdG8gdGhlIHRhcmdldCBMYXR0aWNlLiBUaGlzIGlzIG9ubHkgY3VycmVudGx5IHVzZWQgZm9yIHNpZ25pbmcgXG4gIC8vIGJlY2F1c2UgaXQgZWxpbWluYXRlcyB0aGUgbmVlZCBmb3IgMiBjb25uZWN0aW9uIHJlcXVlc3RzIGFuZCBzaGF2ZXMgb2ZmIH40LTZzZWMuXG4gIC8vIFdlIGF2b2lkIHBhc3NpbmcgYGJ5cGFzc09uU3RhdGVEYXRhPXRydWVgIGZvciBvdGhlciBjYWxscyBvbiBgdW5sb2NrYCB0byBhdm9pZFxuICAvLyBwb3NzaWJsZSBlZGdlIGNhc2VzIHJlbGF0ZWQgdG8gdGhpcyBuZXcgZnVuY3Rpb25hbGl0eSAoaXQncyBwcm9iYWJseSBmaW5lIC0ganVzdFxuICAvLyBiZWluZyBjYXV0aW91cykuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHJlbW92ZSBgYnlwYXNzT25TdGF0ZURhdGFgIGVudGlyZWx5LlxuICB1bmxvY2soYnlwYXNzT25TdGF0ZURhdGE9ZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRm9yY2UgY29tcGF0YWJpbGl0eS4gYHRoaXMuYWNjb3VudE9wdHNgIHdlcmUgYWRkZWQgYWZ0ZXIgb3RoZXJcbiAgICAgIC8vIHN0YXRlIHBhcmFtcyBhbmQgbXVzdCBiZSBzeW5jZWQgaW4gb3JkZXIgZm9yIHRoaXMga2V5cmluZyB0byBmdW5jdGlvbi5cbiAgICAgIGlmICgoIXRoaXMuYWNjb3VudE9wdHMpIHx8IFxuICAgICAgICAgICh0aGlzLmFjY291bnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5hY2NvdW50T3B0cy5sZW5ndGggIT0gdGhpcy5hY2NvdW50cy5sZW5ndGgpKSBcbiAgICAgIHtcbiAgICAgICAgdGhpcy5mb3JnZXREZXZpY2UoKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgJ1lvdSBjYW4gbm93IGFkZCBtdWx0aXBsZSBMYXR0aWNlIGFuZCBTYWZlQ2FyZCBhY2NvdW50cyBhdCB0aGUgc2FtZSB0aW1lISAnICtcbiAgICAgICAgICAnWW91ciBhY2NvdW50cyBoYXZlIGJlZW4gY2xlYXJlZC4gUGxlYXNlIHByZXNzIENvbnRpbnVlIHRvIGFkZCB0aGVtIGJhY2sgaW4uJ1xuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNVbmxvY2tlZCgpICYmICF0aGlzLmZvcmNlUmVjb25uZWN0KSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCdVbmxvY2tlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9nZXRDcmVkcygpXG4gICAgICAudGhlbigoY3JlZHMpID0+IHtcbiAgICAgICAgaWYgKGNyZWRzKSB7XG4gICAgICAgICAgdGhpcy5jcmVkcy5kZXZpY2VJRCA9IGNyZWRzLmRldmljZUlEO1xuICAgICAgICAgIHRoaXMuY3JlZHMucGFzc3dvcmQgPSBjcmVkcy5wYXNzd29yZDtcbiAgICAgICAgICB0aGlzLmNyZWRzLmVuZHBvaW50ID0gY3JlZHMuZW5kcG9pbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFNlc3Npb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoaW5jbHVkZWRTdGF0ZURhdGEpID0+IHtcbiAgICAgICAgLy8gSWYgc3RhdGUgZGF0YSB3YXMgcHJvdmlkZWQgYW5kIGlmIHdlIGFyZSBhdXRob3JpemVkIHRvIFxuICAgICAgICAvLyBieXBhc3MgcmVjb25uZWN0aW5nLCB3ZSBjYW4gZXhpdCBoZXJlLlxuICAgICAgICBpZiAoaW5jbHVkZWRTdGF0ZURhdGEgJiYgYnlwYXNzT25TdGF0ZURhdGEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgnVW5sb2NrZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdCgpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoJ1VubG9ja2VkJyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBBZGQgYWRkcmVzc2VzIHRvIHRoZSBsb2NhbCBzdG9yZSBhbmQgcmV0dXJuIHRoZSBmdWxsIHJlc3VsdFxuICBhZGRBY2NvdW50cyhuPTEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKG4gPT09IENMT1NFX0NPREUpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB1c2UgYSBjb2RlIHRvIGZvcmdldCB0aGUgZGV2aWNlLiBcbiAgICAgICAgLy8gKFRoaXMgZnVuY3Rpb24gaXMgb3ZlcmxvYWRlZCBkdWUgdG8gY29uc3RyYWludHMgdXBzdHJlYW0pXG4gICAgICAgIHRoaXMuZm9yZ2V0RGV2aWNlKCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIH0gZWxzZSBpZiAobiA8PSAwKSB7XG4gICAgICAgIC8vIEF2b2lkIG5vbi1wb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICByZXR1cm4gcmVqZWN0KCdOdW1iZXIgb2YgYWNjb3VudHMgdG8gYWRkIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgYmVoYXZpb3I6IGVzdGFibGlzaCB0aGUgY29ubmVjdGlvbiBhbmQgZmV0Y2ggYWRkcmVzc2VzLlxuICAgICAgICB0aGlzLnVubG9jaygpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hBZGRyZXNzZXMobiwgdGhpcy51bmxvY2tlZEFjY291bnQpXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChhZGRycykgPT4ge1xuICAgICAgICAgIGNvbnN0IHdhbGxldFVJRCA9IHRoaXMuX2dldEN1cnJlbnRXYWxsZXRVSUQoKTtcbiAgICAgICAgICAvLyBBZGQgdGhlc2UgaW5kaWNlc1xuICAgICAgICAgIGFkZHJzLmZvckVhY2goKGFkZHIsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBhbHJlYWR5U2F2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5hY2NvdW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoKHRoaXMuYWNjb3VudHNbal0gPT09IGFkZHIpICYmIFxuICAgICAgICAgICAgICAgICAgKHRoaXMuYWNjb3VudE9wdHNbal0ud2FsbGV0VUlEID09PSB3YWxsZXRVSUQpICYmXG4gICAgICAgICAgICAgICAgICAodGhpcy5hY2NvdW50T3B0c1tqXS5oZFBhdGggPT09IHRoaXMuaGRQYXRoKSlcbiAgICAgICAgICAgICAgICBhbHJlYWR5U2F2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2F2ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHIpO1xuICAgICAgICAgICAgICB0aGlzLmFjY291bnRJbmRpY2VzLnB1c2godGhpcy51bmxvY2tlZEFjY291bnQraSk7XG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudE9wdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2FsbGV0VUlELFxuICAgICAgICAgICAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBsb2NhbCBzdG9yZSBvZiBhZGRyZXNzZXMuIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXh0ZW5zaW9uIHVubG9ja3MuXG4gIGdldEFjY291bnRzKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hY2NvdW50cyA/IHRoaXMuYWNjb3VudHMuc2xpY2UoKSA6IFtdLnNsaWNlKCkpO1xuICB9XG5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9maW5kU2lnbmVySWR4KGFkZHJlc3MpXG4gICAgICAudGhlbigoYWNjb3VudElkeCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEJ1aWxkIHRoZSBMYXR0aWNlIHJlcXVlc3QgZGF0YSBhbmQgbWFrZSByZXF1ZXN0XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGB0eGAgdG8gYmUgYW4gYGV0aGVyZXVtanMtdHhgIG9iamVjdCwgbWVhbmluZyBhbGwgZmllbGRzIGFyZSBidWZmZXJpemVkXG4gICAgICAgICAgLy8gVG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcGxheXMgbmljZWx5IHdpdGggZ3JpZHBsdXMtc2RrLCB3ZSBjb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gaGV4IHN0cmluZ3NcbiAgICAgICAgICBjb25zdCBhZGRyZXNzSWR4ID0gdGhpcy5hY2NvdW50SW5kaWNlc1thY2NvdW50SWR4XTtcbiAgICAgICAgICBjb25zdCBhZGRyZXNzUGFyZW50UGF0aCA9IHRoaXMuYWNjb3VudE9wdHNbYWNjb3VudElkeF0uaGRQYXRoO1xuICAgICAgICAgIGNvbnN0IHR4RGF0YSA9IHtcbiAgICAgICAgICAgIGNoYWluSWQ6IGAweCR7dGhpcy5fZ2V0RXRoZXJldW1Kc0NoYWluSWQodHgpLnRvU3RyaW5nKCdoZXgnKX1gIHx8IDEsXG4gICAgICAgICAgICBub25jZTogYDB4JHt0eC5ub25jZS50b1N0cmluZygnaGV4Jyl9YCB8fCAwLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGAweCR7dHguZ2FzTGltaXQudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICAgICAgICB0bzogISF0eC50byA/IHR4LnRvLnRvU3RyaW5nKCdoZXgnKSA6IG51bGwsIC8vIG51bGwgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRzXG4gICAgICAgICAgICB2YWx1ZTogYDB4JHt0eC52YWx1ZS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEubGVuZ3RoID09PSAwID8gbnVsbCA6IGAweCR7dHguZGF0YS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICAgICAgICAgIHNpZ25lclBhdGg6IHRoaXMuX2dldEhEUGF0aEluZGljZXMoYWRkcmVzc1BhcmVudFBhdGgsIGFkZHJlc3NJZHgpLFxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHR4Ll90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIGVpcDE1NTlcbiAgICAgICAgICAgICAgaWYgKCh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gbnVsbCB8fCB0eC5tYXhGZWVQZXJHYXMgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09IHVuZGVmaW5lZCB8fCB0eC5tYXhGZWVQZXJHYXMgPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbWF4UHJpb3JpdHlGZWVQZXJHYXNgIGFuZCBgbWF4RmVlUGVyR2FzYCBtdXN0IGJlIGluY2x1ZGVkIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9ucy4nKTtcbiAgICAgICAgICAgICAgdHhEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID0gYDB4JHt0eC5tYXhQcmlvcml0eUZlZVBlckdhcy50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgICAgdHhEYXRhLm1heEZlZVBlckdhcyA9IGAweCR7dHgubWF4RmVlUGVyR2FzLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgICAgICAgICB0eERhdGEuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3QgfHwgW107XG4gICAgICAgICAgICAgIHR4RGF0YS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIGVpcDI5MzBcbiAgICAgICAgICAgICAgdHhEYXRhLmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0IHx8IFtdO1xuICAgICAgICAgICAgICB0eERhdGEuZ2FzUHJpY2UgPSBgMHgke3R4Lmdhc1ByaWNlLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgICAgICAgICB0eERhdGEudHlwZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gbGVnYWN5XG4gICAgICAgICAgICAgIHR4RGF0YS5nYXNQcmljZSA9IGAweCR7dHguZ2FzUHJpY2UudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgICAgICAgICAgIHR4RGF0YS50eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIExhdHRpY2UgZmlybXdhcmUgdjAuMTEuMCBpbXBsZW1lbnRlZCBFSVAxNTU5IGFuZCBFSVAyOTMwIHNvIGZvciBwcmV2aW91cyB2ZXJpc29uc1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gb3ZlcndyaXRlIHJlbGV2YW50IHBhcmFtcyBhbmQgcmV2ZXJ0IHRvIGxlZ2FjeSB0eXBlLlxuICAgICAgICAgIC8vIE5vdGU6IGB0aGlzLnNka1Nlc3Npb24uZndWZXJzaW9uIGlzIG9mIGZvcm1hdCBbZml4LCBtaW5vciwgbWFqb3IsIHJlc2VydmVkXVxuICAgICAgICAgIGNvbnN0IGZvcmNlTGVnYWN5VHggPSB0aGlzLnNka1Nlc3Npb24uZndWZXJzaW9uWzJdIDwgMSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZGtTZXNzaW9uLmZ3VmVyc2lvblsxXSA8IDExO1xuICAgICAgICAgIGlmIChmb3JjZUxlZ2FjeVR4ICYmIHR4RGF0YS50eXBlID09PSAyKSB7XG4gICAgICAgICAgICB0eERhdGEuZ2FzUHJpY2UgPSB0eERhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgdHhEYXRhLnJldmVydFRvTGVnYWN5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eERhdGEudHlwZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eERhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgZGVsZXRlIHR4RGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGRlbGV0ZSB0eERhdGEuYWNjZXNzTGlzdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvcmNlTGVnYWN5VHggJiYgdHhEYXRhLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHR4RGF0YS5yZXZlcnRUb0xlZ2FjeSA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgdHhEYXRhLnR5cGU7XG4gICAgICAgICAgICBkZWxldGUgdHhEYXRhLmFjY2Vzc0xpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEdldCB0aGUgc2lnbmF0dXJlXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UeERhdGEodHhEYXRhKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBidWlsZCB0cmFuc2FjdGlvbi5gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oKHNpZ25lZFR4KSA9PiB7XG4gICAgICAgIC8vIEFkZCB0aGUgc2lnIHBhcmFtcy4gYHNpZ25lZFR4ID0geyBzaWc6IHsgdiwgciwgcyB9LCB0eCwgdHhIYXNofWBcbiAgICAgICAgaWYgKCFzaWduZWRUeC5zaWcgfHwgIXNpZ25lZFR4LnNpZy52IHx8ICFzaWduZWRUeC5zaWcuciB8fCAhc2lnbmVkVHguc2lnLnMpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSByZXR1cm5lZC4nKSk7XG4gICAgICAgIGNvbnN0IHR4VG9SZXR1cm4gPSB0eC50b0pTT04oKTtcbiAgICAgICAgY29uc3QgdiA9IHNpZ25lZFR4LnNpZy52Lmxlbmd0aCA9PT0gMCA/ICcwJyA6IHNpZ25lZFR4LnNpZy52LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICB0eFRvUmV0dXJuLnIgPSBVdGlsLmFkZEhleFByZWZpeChzaWduZWRUeC5zaWcuci50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB0eFRvUmV0dXJuLnMgPSBVdGlsLmFkZEhleFByZWZpeChzaWduZWRUeC5zaWcucy50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB0eFRvUmV0dXJuLnYgPSBVdGlsLmFkZEhleFByZWZpeCh2KTtcblxuICAgICAgICBpZiAoc2lnbmVkVHgucmV2ZXJ0VG9MZWdhY3kgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBJZiBmaXJtd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGFuIEVJUDE1NTkvMjkzMCB0cmFuc2FjdGlvbiB3ZSByZXZlcnQgdG8gbGVnYWN5XG4gICAgICAgICAgdHhUb1JldHVybi50eXBlID0gMDtcbiAgICAgICAgICB0eFRvUmV0dXJuLmdhc1ByaWNlID0gc2lnbmVkVHguZ2FzUHJpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlbGF5IHRoZSB0eCB0eXBlXG4gICAgICAgICAgdHhUb1JldHVybi50eXBlID0gc2lnbmVkVHgudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0eCBmb3IgZXhwb3J0XG4gICAgICAgIGxldCB2YWxpZGF0aW5nVHg7XG4gICAgICAgIGNvbnN0IF9jaGFpbklkID0gYDB4JHt0aGlzLl9nZXRFdGhlcmV1bUpzQ2hhaW5JZCh0eCkudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXcgQk4oX2NoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIGNvbnN0IGN1c3RvbU5ldHdvcmsgPSBDb21tb24uZm9yQ3VzdG9tQ2hhaW4oJ21haW5uZXQnLCB7XG4gICAgICAgICAgbmFtZTogJ25vdE1haW5uZXQnLFxuICAgICAgICAgIG5ldHdvcmtJZDogY2hhaW5JZCxcbiAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICB9LCAnbG9uZG9uJylcblxuICAgICAgICB2YWxpZGF0aW5nVHggPSBFdGhUeC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eFRvUmV0dXJuLCB7XG4gICAgICAgICAgY29tbW9uOiBjdXN0b21OZXR3b3JrLCBmcmVlemU6IE9iamVjdC5pc0Zyb3plbih0eClcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsaWRhdGluZ1R4KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UoYWRkcmVzcywgbXNnKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2UoYWRkcmVzcywgeyBwYXlsb2FkOiBtc2csIHByb3RvY29sOiAnc2lnblBlcnNvbmFsJyB9KTtcbiAgfVxuXG4gIHNpZ25UeXBlZERhdGEoYWRkcmVzcywgbXNnLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMudmVyc2lvbiAmJiAob3B0cy52ZXJzaW9uICE9PSAnVjQnICYmIG9wdHMudmVyc2lvbiAhPT0gJ1YzJykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgc2lnblR5cGVkRGF0YSBWMyBhbmQgVjQgbWVzc2FnZXMgKEVJUDcxMikgYXJlIHN1cHBvcnRlZC4gR290IHZlcnNpb24gJHtvcHRzLnZlcnNpb259YCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnbk1lc3NhZ2UoYWRkcmVzcywgeyBwYXlsb2FkOiBtc2csIHByb3RvY29sOiAnZWlwNzEyJyB9KVxuICB9XG5cbiAgc2lnbk1lc3NhZ2UoYWRkcmVzcywgbXNnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2ZpbmRTaWduZXJJZHgoYWRkcmVzcylcbiAgICAgIC50aGVuKChhY2NvdW50SWR4KSA9PiB7XG4gICAgICAgIGxldCB7IHBheWxvYWQsIHByb3RvY29sIH0gPSBtc2c7XG4gICAgICAgIC8vIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBhbiBvYmplY3Qgd2UgYXNzdW1lIGl0IGlzIGEgbGVnYWN5IHNpZ25QZXJzb25hbCByZXF1ZXN0XG4gICAgICAgIGlmICghcGF5bG9hZCB8fCAhcHJvdG9jb2wpIHtcbiAgICAgICAgICBwYXlsb2FkID0gbXNnO1xuICAgICAgICAgIHByb3RvY29sID0gJ3NpZ25QZXJzb25hbCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc0lkeCA9IHRoaXMuYWNjb3VudEluZGljZXNbYWNjb3VudElkeF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3NQYXJlbnRQYXRoID0gdGhpcy5hY2NvdW50T3B0c1thY2NvdW50SWR4XS5oZFBhdGg7XG4gICAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgICBjdXJyZW5jeTogJ0VUSF9NU0cnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHNpZ25lclBhdGg6IHRoaXMuX2dldEhEUGF0aEluZGljZXMoYWRkcmVzc1BhcmVudFBhdGgsIGFkZHJlc3NJZHgpLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNka1Nlc3Npb24uc2lnbihyZXEsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGVycikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX3N5bmNDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoJ05vIGFjdGl2ZSB3YWxsZXQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzLnNpZykge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZSByZXR1cm5lZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgYHZgIHRvIGEgbnVtYmVyLiBJdCBzaG91bGQgY29udmVydCB0byAwIG9yIDFcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHYgPSByZXMuc2lnLnYudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICB2ID0gYDAke3Z9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGAweCR7cmVzLnNpZy5yfSR7cmVzLnNpZy5zfSR7dn1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmb3JtYXQgcmV0dXJuZWQuJykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGVycikpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0QWNjb3VudChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yKCdleHBvcnRBY2NvdW50IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBkZXZpY2UnKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIHRoaXMuYWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgaWYgKGFjY291bnQudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmFjY291bnRJbmRpY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5hY2NvdW50T3B0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlKCkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIHVzZXIgaGFzIGNvbm5lY3RlZCB0byB0aGUgTGF0dGljZS5cbiAgICAvLyBVcGRhdGUgYSBzdGF0ZSB2YXJpYWJsZSB0byBmb3JjZSBvcGVuaW5nIG9mIHRoZSBMYXR0aWNlIG1hbmFnZXIgd2luZG93LlxuICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIE1ldGFNYXNrIHdpbGwgYXV0b21hdGljYWxseSBzdGFydCByZXF1ZXN0aW5nIGFkZHJlc3NlcyxcbiAgICAvLyBldmVuIGlmIHRoZSBkZXZpY2UgaXMgbm90IHJlYWNoYWJsZS5cbiAgICAvLyBUaGlzIHdheSB0aGUgdXNlciBjYW4gY2xvc2UgdGhlIHdpbmRvdyBhbmQgY29ubmVjdCBhY2NvdW50cyBmcm9tIG90aGVyXG4gICAgLy8gd2FsbGV0cyBpbnN0ZWFkIG9mIGJlaW5nIGZvcmNlZCBpbnRvIHNlbGVjdGluZyBMYXR0aWNlIGFjY291bnRzXG4gICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IHRydWU7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFnZSgwKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgc2V0QWNjb3VudFRvVW5sb2NrIChpbmRleCkge1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gcGFyc2VJbnQoaW5kZXgsIDEwKVxuICB9XG5cbiAgZm9yZ2V0RGV2aWNlICgpIHtcbiAgICB0aGlzLl9yZXNldERlZmF1bHRzKCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSW50ZXJuYWwgbWV0aG9kcyBhbmQgaW50ZXJmYWNlIHRvIFNES1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRmluZCB0aGUgYWNjb3VudCBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIGFkZHJlc3MuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHRoZSBCSVAzOSBwYXRoIGluZGV4LCBub3QgdGhlIGluZGV4IGluIHRoZSBhZGRyZXNzIGNhY2hlLlxuICBfZmluZFNpZ25lcklkeChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFVubG9jayBhbmQgZ2V0IHRoZSB3YWxsZXQgVUlELiBXZSB3aWxsIGJ5cGFzcyB0aGUgcmVjb25uZWN0aW9uXG4gICAgICAvLyBzdGVwIGlmIHdlIGFyZSBhYmxlIHRvIHJlaHlkcmF0ZSBhbiBTREsgc2Vzc2lvbiB3aXRoIHN0YXRlIGRhdGEuXG4gICAgICB0aGlzLnVubG9jayh0cnVlKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5zdXJlQ3VycmVudFdhbGxldFVJRCgpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoYWRkcnMpID0+IHtcbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbmVyIGluIG91ciBjdXJyZW50IHNldCBvZiBhY2NvdW50c1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGl0LCByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgbGV0IGFjY291bnRJZHggPSBudWxsO1xuICAgICAgICBhZGRycy5mb3JFYWNoKChhZGRyLCBpKSA9PiB7XG4gICAgICAgICAgaWYgKGFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkci50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgYWNjb3VudElkeCA9IGk7XG4gICAgICAgIH0pXG4gICAgICAgIGlmIChhY2NvdW50SWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdCgnU2lnbmVyIG5vdCBwcmVzZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWNjb3VudElkeCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgX2dldEhEUGF0aEluZGljZXMoaGRQYXRoLCBpbnNlcnRJZHg9MCkge1xuICAgIGNvbnN0IHBhdGggPSBoZFBhdGguc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgbGV0IHVzZWRYID0gZmFsc2U7XG4gICAgcGF0aC5mb3JFYWNoKChfaWR4KSA9PiB7XG4gICAgICBjb25zdCBpc0hhcmRlbmVkID0gKF9pZHhbX2lkeC5sZW5ndGggLSAxXSA9PT0gXCInXCIpO1xuICAgICAgbGV0IGlkeCA9IGlzSGFyZGVuZWQgPyBIQVJERU5FRF9PRkZTRVQgOiAwO1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYHhgIGluIHRoZSBwYXRoIHN0cmluZywgd2Ugd2lsbCB1c2UgaXQgdG8gaW5zZXJ0IG91clxuICAgICAgLy8gaW5kZXguIFRoaXMgaXMgdXNlZnVsIGZvciBlLmcuIExlZGdlciBMaXZlIHBhdGguIE1vc3QgcGF0aHMgaGF2ZSB0aGVcbiAgICAgIC8vIGNoYW5naW5nIGluZGV4IGFzIHRoZSBsYXN0IG9uZSwgc28gaGF2aW5nIGFuIGB4YCBpbiB0aGUgcGF0aCBpc24ndFxuICAgICAgLy8gdXN1YWxseSBuZWNlc3NhcnkuXG4gICAgICBpZiAoX2lkeC5pbmRleE9mKCd4JykgPiAtMSkge1xuICAgICAgICBpZHggKz0gaW5zZXJ0SWR4O1xuICAgICAgICB1c2VkWCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzSGFyZGVuZWQpIHtcbiAgICAgICAgaWR4ICs9IE51bWJlcihfaWR4LnNsaWNlKDAsIF9pZHgubGVuZ3RoIC0gMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4ICs9IE51bWJlcihfaWR4KTtcbiAgICAgIH1cbiAgICAgIGluZGljZXMucHVzaChpZHgpO1xuICAgIH0pXG4gICAgLy8gSWYgdGhpcyBwYXRoIHN0cmluZyBkb2VzIG5vdCBpbmNsdWRlIGFuIGB4YCwgd2UganVzdCBhcHBlbmQgdGhlIGluZGV4XG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgZXh0cmFjdGVkIHNldFxuICAgIGlmICh1c2VkWCA9PT0gZmFsc2UpIHtcbiAgICAgIGluZGljZXMucHVzaChpbnNlcnRJZHgpO1xuICAgIH1cbiAgICAvLyBTYW5pdHkgY2hlY2sgLS0gTGF0dGljZSBmaXJtd2FyZSB3aWxsIHRocm93IGFuIGVycm9yIGZvciBsYXJnZSBwYXRoc1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA+IDUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgSEQgcGF0aHMgd2l0aCB1cCB0byA1IGluZGljZXMgYXJlIGFsbG93ZWQuJylcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfVxuXG4gIF9yZXNldERlZmF1bHRzKCkge1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLmFjY291bnRJbmRpY2VzID0gW107XG4gICAgdGhpcy5hY2NvdW50T3B0cyA9IFtdO1xuICAgIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuY3JlZHMgPSB7XG4gICAgICBkZXZpY2VJRDogbnVsbCxcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgZW5kcG9pbnQ6IG51bGwsXG4gICAgfTtcbiAgICB0aGlzLndhbGxldFVJRCA9IG51bGw7XG4gICAgdGhpcy5zZGtTZXNzaW9uID0gbnVsbDtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5ldHdvcmsgPSBudWxsO1xuICAgIHRoaXMuaGRQYXRoID0gU1RBTkRBUkRfSERfUEFUSDtcbiAgfVxuXG4gIF9vcGVuQ29ubmVjdG9yVGFiKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBicm93c2VyVGFiID0gd2luZG93Lm9wZW4odXJsKTtcbiAgICAgIC8vIFByZWZlcnJlZCBvcHRpb24gZm9yIENocm9taXVtIGJyb3dzZXJzLiBUaGlzIGV4dGVuc2lvbiBydW5zIGluIGEgd2luZG93XG4gICAgICAvLyBmb3IgQ2hyb21pdW0gc28gd2UgY2FuIGRvIHdpbmRvdy1iYXNlZCBjb21tdW5pY2F0aW9uIHZlcnkgZWFzaWx5LlxuICAgICAgaWYgKGJyb3dzZXJUYWIpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBjaHJvbWl1bTogYnJvd3NlclRhYiB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlciAmJiBicm93c2VyLnRhYnMgJiYgYnJvd3Nlci50YWJzLmNyZWF0ZSkge1xuICAgICAgICAvLyBGaXJlRm94IGV4dGVuc2lvbnMgZG8gbm90IHJ1biBpbiB3aW5kb3dzLCBzbyBpdCB3aWxsIHJldHVybiBgbnVsbGAgZnJvbVxuICAgICAgICAvLyBgd2luZG93Lm9wZW5gLiBJbnN0ZWFkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgYGJyb3dzZXJgIEFQSSB0byBvcGVuIGEgdGFiLiBcbiAgICAgICAgLy8gV2Ugd2lsbCBzdXJ2ZWlsbGUgdGhpcyB0YWIgdG8gc2VlIGlmIGl0cyBVUkwgcGFyYW1ldGVycyBjaGFuZ2UsIHdoaWNoIFxuICAgICAgICAvLyB3aWxsIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIGxvZ2dlZCBpbi5cbiAgICAgICAgYnJvd3Nlci50YWJzLmNyZWF0ZSh7dXJsfSlcbiAgICAgICAgLnRoZW4oKHRhYikgPT4ge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgZmlyZWZveDogdGFiIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBMYXR0aWNlIGNvbm5lY3Rvci4nKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdVbmtub3duIGJyb3dzZXIgY29udGV4dC4gQ2Fubm90IG9wZW4gTGF0dGljZSBjb25uZWN0b3IuJykpXG4gICAgICB9XG5cbiAgICB9KVxuICB9XG5cbiAgX2ZpbmRUYWJCeUlkKGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGJyb3dzZXIudGFicy5xdWVyeSh7fSlcbiAgICAgIC50aGVuKCh0YWJzKSA9PiB7XG4gICAgICAgIHRhYnMuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICAgICAgaWYgKHRhYi5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRhYik7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgXG4gIF9nZXRDcmVkcygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHNldHVwIGlmIHdlIGRvbid0IGhhdmUgYSBkZXZpY2VJRFxuICAgICAgaWYgKHRoaXMuX2hhc0NyZWRzKCkgJiYgIXRoaXMuZm9yY2VSZWNvbm5lY3QpXG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAvLyBDYW5jZWwgdGhlIGZvcmNlIHJlY29ubmVjdCwgaWYgYXBwbGljYWJsZVxuICAgICAgdGhpcy5mb3JjZVJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgLy8gSWYgd2UgYXJlIG5vdCBhd2FyZSBvZiB3aGF0IExhdHRpY2Ugd2Ugc2hvdWxkIGJlIHRhbGtpbmcgdG8sXG4gICAgICAvLyB3ZSBuZWVkIHRvIG9wZW4gYSB3aW5kb3cgdGhhdCBsZXRzIHRoZSB1c2VyIGdvIHRocm91Z2ggdGhlXG4gICAgICAvLyBwYWlyaW5nIG9yIGNvbm5lY3Rpb24gcHJvY2Vzcy5cbiAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmFwcE5hbWUgPyB0aGlzLmFwcE5hbWUgOiAnVW5rbm93bidcbiAgICAgIGNvbnN0IGJhc2UgPSAnaHR0cHM6Ly9sYXR0aWNlLmdyaWRwbHVzLmlvJztcbiAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2V9P2tleXJpbmc9JHtuYW1lfSZmb3JjZUxvZ2luPXRydWVgO1xuICAgICAgbGV0IGxpc3RlbkludGVydmFsO1xuXG4gICAgICAvLyBQb3N0TWVzc2FnZSBoYW5kbGVyXG4gICAgICBmdW5jdGlvbiByZWNlaXZlTWVzc2FnZShldmVudCkge1xuICAgICAgICAvLyBFbnN1cmUgb3JpZ2luXG4gICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IGJhc2UpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFN0b3AgdGhlIGxpc3RlbmVyXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChsaXN0ZW5JbnRlcnZhbCk7XG4gICAgICAgICAgLy8gUGFyc2UgYW5kIHJldHVybiBjcmVkc1xuICAgICAgICAgIGNvbnN0IGNyZWRzID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICBpZiAoIWNyZWRzLmRldmljZUlEIHx8ICFjcmVkcy5wYXNzd29yZClcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzIHJldHVybmVkIGZyb20gTGF0dGljZS4nKSk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY3JlZHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3BlbiB0aGUgdGFiXG4gICAgICB0aGlzLl9vcGVuQ29ubmVjdG9yVGFiKHVybClcbiAgICAgIC50aGVuKChjb25uKSA9PiB7XG4gICAgICAgIGlmIChjb25uLmNocm9taXVtKSB7XG4gICAgICAgICAgLy8gT24gYSBDaHJvbWl1bSBicm93c2VyIHdlIGNhbiBqdXN0IGxpc3RlbiBmb3IgYSB3aW5kb3cgbWVzc2FnZVxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZWNlaXZlTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICAgIC8vIFdhdGNoIGZvciB0aGUgb3BlbiB3aW5kb3cgY2xvc2luZyBiZWZvcmUgY3JlZHMgYXJlIHNlbnQgYmFja1xuICAgICAgICAgIGxpc3RlbkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbm4uY2hyb21pdW0uY2xvc2VkKSB7XG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobGlzdGVuSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTGF0dGljZSBjb25uZWN0b3IgY2xvc2VkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbm4uZmlyZWZveCkge1xuICAgICAgICAgIC8vIEZvciBGaXJlZm94IHdlIGNhbm5vdCB1c2UgYHdpbmRvd2AgaW4gdGhlIGV4dGVuc2lvbiBhbmQgY2FuJ3RcbiAgICAgICAgICAvLyBkaXJlY3RseSBjb21tdW5pY2F0ZSB3aXRoIHRoZSB0YWJzIHZlcnkgZWFzaWx5IHNvIHdlIHVzZSBhXG4gICAgICAgICAgLy8gd29ya2Fyb3VuZDogbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSBVUkwsIHdoaWNoIHdpbGwgY29udGFpblxuICAgICAgICAgIC8vIHRoZSBsb2dpbiBpbmZvLlxuICAgICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBvbmx5IHdvcmsgaWYgaGF2ZSBgaHR0cHM6Ly9sYXR0aWNlLmdyaWRwbHVzLmlvLypgXG4gICAgICAgICAgLy8gaG9zdCBwZXJtaXNzaW9ucyBpbiB5b3VyIG1hbmlmZXN0IGZpbGUgKGFuZCBhbHNvIGBhY3RpdmVUYWJgIHBlcm1pc3Npb24pXG4gICAgICAgICAgY29uc3QgbG9naW5VcmxQYXJhbSA9ICcmbG9naW5DYWNoZT0nO1xuICAgICAgICAgIGxpc3RlbkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZmluZFRhYkJ5SWQoY29ubi5maXJlZm94LmlkKVxuICAgICAgICAgICAgLnRoZW4oKHRhYikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRhYiB8fCAhdGFiLnVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdMYXR0aWNlIGNvbm5lY3RvciBjbG9zZWQuJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSB0YWIgd2Ugb3BlbmVkIGNvbnRhaW5zIGEgbmV3IFVSTCBwYXJhbVxuICAgICAgICAgICAgICBjb25zdCBwYXJhbUxvYyA9IHRhYi51cmwuaW5kZXhPZihsb2dpblVybFBhcmFtKTtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtTG9jIDwgMCkgXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhTG9jID0gcGFyYW1Mb2MgKyBsb2dpblVybFBhcmFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgLy8gU3RvcCB0aGlzIGludGVydmFsXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobGlzdGVuSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBsb2dpbiBkYXRhLiBJdCBpcyBhIHN0cmluZ2lmaWVkIEpTT04gb2JqZWN0IFxuICAgICAgICAgICAgICAgIC8vIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IF9jcmVkcyA9IEJ1ZmZlci5mcm9tKHRhYi51cmwuc2xpY2UoZGF0YUxvYyksICdiYXNlNjQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHRoZSB0YWIgYW5kIHJldHVybiB0aGUgY3JlZGVudGlhbHNcbiAgICAgICAgICAgICAgICBicm93c2VyLnRhYnMucmVtb3ZlKHRhYi5pZClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjcmVkcyA9IEpTT04ucGFyc2UoX2NyZWRzKTtcbiAgICAgICAgICAgICAgICAgIGlmICghY3JlZHMuZGV2aWNlSUQgfHwgIWNyZWRzLnBhc3N3b3JkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBjcmVkZW50aWFscyByZXR1cm5lZCBmcm9tIExhdHRpY2UuJykpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY3JlZHMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0ZhaWxlZCB0byBnZXQgbG9naW4gZGF0YSBmcm9tIExhdHRpY2UuIFBsZWFzZSB0cnkgYWdhaW4uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBbcmVdY29ubmVjdCB0byB0aGUgTGF0dGljZS4gVGhpcyBzaG91bGQgYmUgZG9uZSBmcmVxdWVudGx5IHRvIGVuc3VyZVxuICAvLyB0aGUgZXhwZWN0ZWQgd2FsbGV0IFVJRCBpcyBzdGlsbCB0aGUgb25lIGFjdGl2ZSBpbiB0aGUgTGF0dGljZS5cbiAgLy8gVGhpcyB3aWxsIGhhbmRsZSBTYWZlQ2FyZCBpbnNlcnRpb24vcmVtb3ZhbCBldmVudHMuXG4gIF9jb25uZWN0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGNvbm5lY3Qgd2l0aCBhIExhdHRpY2UgdXNpbmcgYSBzaG9ydGVyIHRpbWVvdXQuIElmXG4gICAgICAvLyB0aGUgZGV2aWNlIGlzIHVucGx1Z2dlZCBpdCB3aWxsIHRpbWUgb3V0IGFuZCB3ZSBkb24ndCBuZWVkIHRvIHdhaXRcbiAgICAgIC8vIDIgbWludXRlcyBmb3IgdGhhdCB0byBoYXBwZW4uXG4gICAgICB0aGlzLnNka1Nlc3Npb24udGltZW91dCA9IENPTk5FQ1RfVElNRU9VVDtcbiAgICAgIHRoaXMuc2RrU2Vzc2lvbi5jb25uZWN0KHRoaXMuY3JlZHMuZGV2aWNlSUQsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5zZGtTZXNzaW9uLnRpbWVvdXQgPSBTREtfVElNRU9VVDtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3N5bmNDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdObyBhY3RpdmUgd2FsbGV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KVxuICB9XG5cbiAgX2luaXRTZXNzaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB1cmwgPSAnaHR0cHM6Ly9zaWduaW5nLmdyaWRwbC51cyc7XG4gICAgICAgIGlmICh0aGlzLmNyZWRzLmVuZHBvaW50KVxuICAgICAgICAgIHVybCA9IHRoaXMuY3JlZHMuZW5kcG9pbnRcbiAgICAgICAgbGV0IHNldHVwRGF0YTtcbiAgICAgICAgaWYgKHRoaXMuc2RrU3RhdGUpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHN0YXRlIGRhdGEgd2UgY2FuIGZ1bGx5IHJlaHlkcmF0ZSB0aGUgc2Vzc2lvbi5cbiAgICAgICAgICBzZXR1cERhdGEgPSB7XG4gICAgICAgICAgICBzdGF0ZURhdGE6IHRoaXMuc2RrU3RhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBzdGF0ZSBkYXRhLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNlc3Npb24uXG4gICAgICAgICAgLy8gSXRzIHN0YXRlIHdpbGwgYmUgc2F2ZWQgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC5cbiAgICAgICAgICBzZXR1cERhdGEgPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLmFwcE5hbWUsXG4gICAgICAgICAgICBiYXNlVXJsOiB1cmwsXG4gICAgICAgICAgICB0aW1lb3V0OiBTREtfVElNRU9VVCxcbiAgICAgICAgICAgIHByaXZLZXk6IHRoaXMuX2dlblNlc3Npb25LZXkoKSxcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMubmV0d29yayxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZGtTZXNzaW9uID0gbmV3IFNESy5DbGllbnQoc2V0dXBEYXRhKTtcbiAgICAgICAgLy8gUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgd2UgcHJvdmlkZWQgc3RhdGUgZGF0YS5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSwgd2UgY2FuIHNraXAgYGNvbm5lY3RgLlxuICAgICAgICByZXR1cm4gcmVzb2x2ZSghIXNldHVwRGF0YS5zdGF0ZURhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgX2ZldGNoQWRkcmVzc2VzKG49MSwgaT0wLCByZWN1cnNlZEFkZHJzPVtdKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1VubG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCgnTm8gY29ubmVjdGlvbiB0byBMYXR0aWNlLiBDYW5ub3QgZmV0Y2ggYWRkcmVzc2VzLicpXG4gICAgICB9XG4gICAgICB0aGlzLl9fZmV0Y2hBZGRyZXNzZXMobiwgaSwgKGVyciwgYWRkcnMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRycyk7XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfX2ZldGNoQWRkcmVzc2VzKG49MSwgaT0wLCBjYiwgcmVjdXJzZWRBZGRycz1bXSkge1xuICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBkbyBhIHJlY3Vyc2l2ZSBjYWxsIGhlcmUuIFdlIHByZWZlciBub3QgdG9cbiAgICAgIC8vIGJlY2F1c2UgdGhleSB3aWxsIGJlIG11Y2ggc2xvd2VyLCBidXQgTGVkZ2VyIHBhdGhzIHJlcXVpcmUgaXQgc2luY2VcbiAgICAgIC8vIHRoZXkgYXJlIG5vbi1zdGFuZGFyZC5cbiAgICAgIGlmIChuID09PSAwKVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVjdXJzZWRBZGRycyk7XG4gICAgICBjb25zdCBzaG91bGRSZWN1cnNlID0gdGhpcy5faGRQYXRoSGFzSW50ZXJuYWxWYXJJZHgoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdCB0byBnZXQgdGhlIHJlcXVlc3RlZCBhZGRyZXNzXG4gICAgICBjb25zdCBhZGRyRGF0YSA9IHsgXG4gICAgICAgIGN1cnJlbmN5OiAnRVRIJywgXG4gICAgICAgIHN0YXJ0UGF0aDogdGhpcy5fZ2V0SERQYXRoSW5kaWNlcyh0aGlzLmhkUGF0aCwgaSksIFxuICAgICAgICBuOiBzaG91bGRSZWN1cnNlID8gMSA6IG4sXG4gICAgICAgIHNraXBDYWNoZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgICB0aGlzLnNka1Nlc3Npb24uZ2V0QWRkcmVzc2VzKGFkZHJEYXRhLCAoZXJyLCBhZGRycykgPT4ge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICBpZiAoIXRoaXMuX3N5bmNDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdObyBhY3RpdmUgd2FsbGV0LicpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgLS0gaWYgdGhpcyByZXR1cm5lZCAwIGFkZHJlc3NlcywgaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICBpZiAoYWRkcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ05vIGFkZHJlc3NlcyByZXR1cm5lZCcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGFkZHJlc3NlcyB3ZSBmZXRjaGVkICp3aXRob3V0KiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICBpZiAoc2hvdWxkUmVjdXJzZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fZmV0Y2hBZGRyZXNzZXMobi0xLCBpKzEsIGNiLCByZWN1cnNlZEFkZHJzLmNvbmNhdChhZGRycykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBhZGRycyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBfc2lnblR4RGF0YSh0eERhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5zZGtTZXNzaW9uLnNpZ24oeyBjdXJyZW5jeTogJ0VUSCcsIGRhdGE6IHR4RGF0YSB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3N5bmNDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdObyBhY3RpdmUgd2FsbGV0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzLnR4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIHRyYW5zYWN0aW9uIHBheWxvYWQgcmV0dXJuZWQuJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlcmUgd2UgY2F0Y2ggYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSByZXF1ZXN0ZXIgaXMgYXNraW5nIGZvciBhbiBFSVAxNTU5XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGJ1dCBmaXJtd2FyZSBpcyBub3QgdXBkYXRlZCB0byBzdXBwb3J0IGl0LiBXZSBmYWxsYmFjayB0byBsZWdhY3kuXG4gICAgICAgIHJlcy50eXBlID0gdHhEYXRhLnR5cGU7XG4gICAgICAgIGlmICh0eERhdGEucmV2ZXJ0VG9MZWdhY3kpIHtcbiAgICAgICAgICByZXMucmV2ZXJ0VG9MZWdhY3kgPSB0cnVlO1xuICAgICAgICAgIHJlcy5nYXNQcmljZSA9IHR4RGF0YS5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHNpZ25lZCB0eFxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfZ2V0UGFnZShpbmNyZW1lbnQ9MCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuICAgICAgaWYgKHRoaXMucGFnZSA8IDApXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICBjb25zdCBzdGFydCA9IFBFUl9QQUdFICogdGhpcy5wYWdlO1xuICAgICAgLy8gT3RoZXJ3aXNlIHVubG9jayB0aGUgZGV2aWNlIGFuZCBmZXRjaCBtb3JlIGFkZHJlc3Nlc1xuICAgICAgdGhpcy51bmxvY2soKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hBZGRyZXNzZXMoUEVSX1BBR0UsIHN0YXJ0KVxuICAgICAgfSlcbiAgICAgIC50aGVuKChhZGRycykgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IFtdXG4gICAgICAgIGFkZHJzLmZvckVhY2goKGFkZHJlc3MsIGkpID0+IHtcbiAgICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICAgICAgaW5kZXg6IHN0YXJ0ICsgaSxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhY2NvdW50cylcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfaGFzQ3JlZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlZHMuZGV2aWNlSUQgIT09IG51bGwgJiYgdGhpcy5jcmVkcy5wYXNzd29yZCAhPT0gbnVsbCAmJiB0aGlzLmFwcE5hbWU7XG4gIH1cblxuICBfZ2VuU2Vzc2lvbktleSgpIHtcbiAgICBpZiAodGhpcy5uYW1lICYmICF0aGlzLmFwcE5hbWUpIC8vIE1pZ3JhdGUgZnJvbSBsZWdhY3kgcGFyYW0gaWYgbmVlZGVkXG4gICAgICB0aGlzLmFwcE5hbWUgPSB0aGlzLm5hbWU7XG4gICAgaWYgKCF0aGlzLl9oYXNDcmVkcygpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjcmVkZW50aWFscyAtLSBjYW5ub3QgY3JlYXRlIHNlc3Npb24ga2V5IScpO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20odGhpcy5jcmVkcy5wYXNzd29yZCksIFxuICAgICAgQnVmZmVyLmZyb20odGhpcy5jcmVkcy5kZXZpY2VJRCksIFxuICAgICAgQnVmZmVyLmZyb20odGhpcy5hcHBOYW1lKVxuICAgIF0pXG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcbiAgfVxuXG4gIC8vIERldGVybWluZSBpZiBhbiBIRCBwYXRoIGhhcyBhIHZhcmlhYmxlIGluZGV4IGludGVybmFsIHRvIGl0LlxuICAvLyBlLmcuIG0vNDQnLzYwJy94Jy8wLzAgLT4gdHJ1ZSwgd2hpbGUgbS80NCcvNjAnLzAnLzAveCAtPiBmYWxzZVxuICAvLyBUaGlzIGlzIGp1c3QgYSBoYWNreSBoZWxwZXIgdG8gYXZvaWQgaGF2aW5nIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIG5vbi1sZWRnZXJcbiAgLy8gZGVyaXZhdGlvbiBwYXRocy4gTGVkZ2VyIGlzIFNPIEFOTk9ZSU5HIFRPIFNVUFBPUlQuXG4gIF9oZFBhdGhIYXNJbnRlcm5hbFZhcklkeCgpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5oZFBhdGguc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0xOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldLmluZGV4T2YoJ3gnKSA+IC0xKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBjaGFpbklkIGZvciB3aGF0ZXZlciBvYmplY3QgdGhpcyBpcy5cbiAgLy8gUmV0dXJucyBhIGhleCBzdHJpbmcgd2l0aG91dCB0aGUgMHggcHJlZml4XG4gIF9nZXRFdGhlcmV1bUpzQ2hhaW5JZCh0eCkge1xuICAgIGlmICh0eXBlb2YgdHguZ2V0Q2hhaW5JZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHJldHVybiB0eC5nZXRDaGFpbklkKCk7XG4gICAgZWxzZSBpZiAodHguY29tbW9uICYmIHR5cGVvZiB0eC5jb21tb24uY2hhaW5JZEJOID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuIHR4LmNvbW1vbi5jaGFpbklkQk4oKS50b1N0cmluZygxNik7XG4gICAgZWxzZSBpZiAodHlwZW9mIHR4LmNoYWluSWQgPT09ICdudW1iZXInKVxuICAgICAgcmV0dXJuIHR4LmNoYWluSWQudG9TdHJpbmcoMTYpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0eC5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiB0eC5jaGFpbklkO1xuICAgIHJldHVybiAnMSc7XG4gIH1cblxuICBfZ2V0Q3VycmVudFdhbGxldFVJRCgpIHtcbiAgICByZXR1cm4gdGhpcy53YWxsZXRVSUQgfHwgbnVsbDtcbiAgfVxuXG4gIC8vIFRoZSBTREsgaGFzIGFuIGF1dG8tcmV0cnkgbWVjaGFuaXNtIGZvciBhbGwgcmVxdWVzdHMgaWYgYSBcIndyb25nIHdhbGxldFwiXG4gIC8vIGVycm9yIGdldHMgdGhyb3duLiBJbiBzdWNoIGEgY2FzZSwgdGhlIFNESyB3aWxsIHJlLWNvbm5lY3QgdG8gdGhlIGRldmljZSB0b1xuICAvLyBmaW5kIHRoZSBuZXcgd2FsbGV0IFVJRCBhbmQgd2lsbCB0aGVuIHNhdmUgdGhhdCBVSUQgdG8gbWVtb3J5IGFuZCB3aWxsIHJldHJ5XG4gIC8vIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdpdGggdGhhdCBuZXcgd2FsbGV0IFVJRC5cbiAgLy8gVGhlcmVmb3JlLCB3ZSBzaG91bGQgc3luYyB0aGUgd2FsbGV0VUlEIHdpdGggYHRoaXMud2FsbGV0VUlEYCBhZnRlciBlYWNoXG4gIC8vIFNESyByZXF1ZXN0LiBUaGlzIGlzIGEgc3luY2hyb25vdXMgYW5kIGZhc3Qgb3BlcmF0aW9uLlxuICBfc3luY0N1cnJlbnRXYWxsZXRVSUQoKSB7XG4gICAgaWYgKCF0aGlzLnNka1Nlc3Npb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVXYWxsZXQgPSB0aGlzLnNka1Nlc3Npb24uZ2V0QWN0aXZlV2FsbGV0KCk7XG4gICAgaWYgKCFhY3RpdmVXYWxsZXQgfHwgIWFjdGl2ZVdhbGxldC51aWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBuZXdVSUQgPSBhY3RpdmVXYWxsZXQudWlkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAvLyBJZiB3ZSBmZXRjaGVkIGEgd2FsbGV0VUlEIHRoYXQgZG9lcyBub3QgbWF0Y2ggb3VyIGN1cnJlbnQgb25lLFxuICAgIC8vIHJlc2V0IGFjY291bnRzIGFuZCB1cGRhdGUgdGhlIGtub3duIFVJRFxuICAgIGlmIChuZXdVSUQgIT0gdGhpcy53YWxsZXRVSUQpIHtcbiAgICAgIHRoaXMud2FsbGV0VUlEID0gbmV3VUlEO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxsZXRVSUQ7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhbiBTREsgY29ubmVjdGlvbiBhbmQsIHRoZXJlZm9yZSwgYW4gYWN0aXZlIHdhbGxldCBVSUQuXG4gIC8vIElmIHdlIGRvIG5vdCwgZm9yY2UgYW4gdW5sb2NrLCB3aGljaCBhZGRzIH41IHNlY29uZHMgdG8gdGhlIHJlcXVlc3QuXG4gIF9lbnN1cmVDdXJyZW50V2FsbGV0VUlEKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoISF0aGlzLl9nZXRDdXJyZW50V2FsbGV0VUlEKCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCEhdGhpcy5fZ2V0Q3VycmVudFdhbGxldFVJRCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZWplY3QoJ0NvdWxkIG5vdCBhY2Nlc3MgTGF0dGljZSB3YWxsZXQuIFBsZWFzZSByZS1jb25uZWN0LicpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxufVxuXG5MYXR0aWNlS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGVcbm1vZHVsZS5leHBvcnRzID0gTGF0dGljZUtleXJpbmc7IiwiaW1wb3J0IHsgc3RyaWN0IGFzIGFzc2VydCB9IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IG5vcm1hbGl6ZSBhcyBub3JtYWxpemVBZGRyZXNzIH0gZnJvbSAnZXRoLXNpZy11dGlsJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7XG4gIElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCxcbiAgTkVUV09SS19UWVBFX1RPX0lEX01BUCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzJztcbmltcG9ydCB7IExFREdFUl9UUkFOU1BPUlRfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xuaW1wb3J0IHsgTkVUV09SS19FVkVOVFMgfSBmcm9tICcuL25ldHdvcmsnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIge1xuICAvKipcbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJlZmVyZW5jZXNDb250cm9sbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0cyBmb3IgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhpcy5zdG9yZVxuICAgKiBAcHJvcGVydHkge09iamVjdH0gc3RvcmUgVGhlIHN0b3JlZCBvYmplY3QgY29udGFpbmluZyBhIHVzZXJzIHByZWZlcmVuY2VzLCBzdG9yZWQgaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcHJvcGVydHkge0FycmF5fSBzdG9yZS5mcmVxdWVudFJwY0xpc3QgQSBsaXN0IG9mIGN1c3RvbSBycGNzIHRvIHByb3ZpZGUgdGhlIHVzZXJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBzdG9yZS51c2VCbG9ja2llIFRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBibG9ja2llIGlkZW50aWNvbnMgd2l0aGluIHRoZSBVSVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3JlLnVzZU5vbmNlRmllbGQgVGhlIHVzZXJzIHByZWZlcmVuY2UgZm9yIG5vbmNlIGZpZWxkIHdpdGhpbiB0aGUgVUlcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlLmZlYXR1cmVGbGFncyBBIGtleS1ib29sZWFuIG1hcCwgd2hlcmUga2V5cyByZWZlciB0byBmZWF0dXJlcyBhbmQgYm9vbGVhbnMgdG8gd2hldGhlciB0aGVcbiAgICogdXNlciB3aXNoZXMgdG8gc2VlIHRoYXQgZmVhdHVyZS5cbiAgICpcbiAgICogRmVhdHVyZSBmbGFncyBjYW4gYmUgc2V0IGJ5IHRoZSBnbG9iYWwgZnVuY3Rpb24gYHNldFByZWZlcmVuY2UoZmVhdHVyZSwgZW5hYmxlZClgLCBhbmQgc28gc2hvdWxkIG5vdCBleHBvc2UgYW55IHNlbnNpdGl2ZSBiZWhhdmlvci5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0b3JlLmtub3duTWV0aG9kRGF0YSBDb250YWlucyBhbGwgZGF0YSBtZXRob2RzIGtub3duIGJ5IHRoZSB1c2VyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdG9yZS5jdXJyZW50TG9jYWxlIFRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2UgbG9jYWxlIGtleVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3RvcmUuc2VsZWN0ZWRBZGRyZXNzIEEgaGV4IHN0cmluZyB0aGF0IG1hdGNoZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhZGRyZXNzIGluIHRoZSBhcHBcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbDogW10sXG4gICAgICB1c2VCbG9ja2llOiBmYWxzZSxcbiAgICAgIHVzZU5vbmNlRmllbGQ6IGZhbHNlLFxuICAgICAgdXNlUGhpc2hEZXRlY3Q6IHRydWUsXG4gICAgICBkaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOiBmYWxzZSxcblxuICAgICAgLy8gc2V0IHRvIHRydWUgbWVhbnMgdGhlIGR5bmFtaWMgbGlzdCBmcm9tIHRoZSBBUEkgaXMgYmVpbmcgdXNlZFxuICAgICAgLy8gc2V0IHRvIGZhbHNlIHdpbGwgYmUgdXNpbmcgdGhlIHN0YXRpYyBsaXN0IGZyb20gY29udHJhY3QtbWV0YWRhdGFcbiAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgICAgIG9wZW5TZWFFbmFibGVkOiBmYWxzZSxcbiAgICAgIGFkdmFuY2VkR2FzRmVlOiBudWxsLFxuXG4gICAgICAvLyBXQVJOSU5HOiBEbyBub3QgdXNlIGZlYXR1cmUgZmxhZ3MgZm9yIHNlY3VyaXR5LXNlbnNpdGl2ZSB0aGluZ3MuXG4gICAgICAvLyBGZWF0dXJlIGZsYWcgdG9nZ2xpbmcgaXMgYXZhaWxhYmxlIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICAvLyBmb3IgY29udmVuaWVudCB0ZXN0aW5nIG9mIHByZS1yZWxlYXNlIGZlYXR1cmVzLCBhbmQgc2hvdWxkIG5ldmVyXG4gICAgICAvLyBwZXJmb3JtIHNlbnNpdGl2ZSBvcGVyYXRpb25zLlxuICAgICAgZmVhdHVyZUZsYWdzOiB7XG4gICAgICAgIHNob3dJbmNvbWluZ1RyYW5zYWN0aW9uczogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBrbm93bk1ldGhvZERhdGE6IHt9LFxuICAgICAgY3VycmVudExvY2FsZTogb3B0cy5pbml0TGFuZ0NvZGUsXG4gICAgICBpZGVudGl0aWVzOiB7fSxcbiAgICAgIGxvc3RJZGVudGl0aWVzOiB7fSxcbiAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBmYWxzZSxcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGF1dG9Mb2NrVGltZUxpbWl0OiB1bmRlZmluZWQsXG4gICAgICAgIHNob3dGaWF0SW5UZXN0bmV0czogZmFsc2UsXG4gICAgICAgIHNob3dUZXN0TmV0d29ya3M6IGZhbHNlLFxuICAgICAgICB1c2VOYXRpdmVDdXJyZW5jeUFzUHJpbWFyeUN1cnJlbmN5OiB0cnVlLFxuICAgICAgICBoaWRlWmVyb0JhbGFuY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIC8vIEVOUyBkZWNlbnRyYWxpemVkIHdlYnNpdGUgcmVzb2x1dGlvblxuICAgICAgaXBmc0dhdGV3YXk6IElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCxcbiAgICAgIGluZnVyYUJsb2NrZWQ6IG51bGwsXG4gICAgICBsZWRnZXJUcmFuc3BvcnRUeXBlOiB3aW5kb3cubmF2aWdhdG9yLmhpZFxuICAgICAgICA/IExFREdFUl9UUkFOU1BPUlRfVFlQRVMuV0VCSElEXG4gICAgICAgIDogTEVER0VSX1RSQU5TUE9SVF9UWVBFUy5VMkYsXG4gICAgICAuLi5vcHRzLmluaXRTdGF0ZSxcbiAgICB9O1xuXG4gICAgdGhpcy5uZXR3b3JrID0gb3B0cy5uZXR3b3JrO1xuICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIob3B0cy5wcm92aWRlcik7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgICB0aGlzLnN0b3JlLnNldE1heExpc3RlbmVycygxMik7XG4gICAgdGhpcy5vcGVuUG9wdXAgPSBvcHRzLm9wZW5Qb3B1cDtcbiAgICB0aGlzLm1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlID0gb3B0cy5taWdyYXRlQWRkcmVzc0Jvb2tTdGF0ZTtcblxuICAgIHRoaXMuX3N1YnNjcmliZVRvSW5mdXJhQXZhaWxhYmlsaXR5KCk7XG5cbiAgICBnbG9iYWwuc2V0UHJlZmVyZW5jZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRGZWF0dXJlRmxhZyhrZXksIHZhbHVlKTtcbiAgICB9O1xuICB9XG4gIC8vIFBVQkxJQyBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAY29kZSBmb3Jnb3R0ZW5QYXNzd29yZH0gc3RhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3Jnb3R0ZW5QYXNzd29yZCAtIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyBmb3Jnb3R0ZW4gdGhlaXIgcGFzc3dvcmRcbiAgICovXG4gIHNldFBhc3N3b3JkRm9yZ290dGVuKGZvcmdvdHRlblBhc3N3b3JkKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZvcmdvdHRlblBhc3N3b3JkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGB1c2VCbG9ja2llYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHByZWZlcnMgYmxvY2tpZSBpbmRpY2F0b3JzXG4gICAqL1xuICBzZXRVc2VCbG9ja2llKHZhbCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB1c2VCbG9ja2llOiB2YWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYHVzZU5vbmNlRmllbGRgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyB0byBzZXQgbm9uY2VcbiAgICovXG4gIHNldFVzZU5vbmNlRmllbGQodmFsKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZU5vbmNlRmllbGQ6IHZhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgdXNlUGhpc2hEZXRlY3RgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyBwaGlzaGluZyBkb21haW4gcHJvdGVjdGlvblxuICAgKi9cbiAgc2V0VXNlUGhpc2hEZXRlY3QodmFsKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IHVzZVBoaXNoRGV0ZWN0OiB2YWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYHVzZVRva2VuRGV0ZWN0aW9uYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHByZWZlcnMgdG8gdXNlIHRoZSBzdGF0aWMgdG9rZW4gbGlzdCBvciBkeW5hbWljIHRva2VuIGxpc3QgZnJvbSB0aGUgQVBJXG4gICAqL1xuICBzZXRVc2VUb2tlbkRldGVjdGlvbih2YWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdXNlVG9rZW5EZXRlY3Rpb246IHZhbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb25gIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gLSBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBwcmVmZXJzIHRvIGF1dG9kZXRlY3QgY29sbGVjdGlibGVzLlxuICAgKi9cbiAgc2V0VXNlQ29sbGVjdGlibGVEZXRlY3Rpb24odXNlQ29sbGVjdGlibGVEZXRlY3Rpb24pIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYG9wZW5TZWFFbmFibGVkYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5TZWFFbmFibGVkIC0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgcHJlZmVycyB0byB1c2UgdGhlIE9wZW5TZWEgQVBJIGZvciBjb2xsZWN0aWJsZXMgZGF0YS5cbiAgICovXG4gIHNldE9wZW5TZWFFbmFibGVkKG9wZW5TZWFFbmFibGVkKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBvcGVuU2VhRW5hYmxlZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgYWR2YW5jZWRHYXNGZWVgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWwgLSBob2xkcyB0aGUgbWF4QmFzZUZlZSBhbmQgUHJpb3JpdHlGZWUgdGhhdCB0aGUgdXNlciBzZXQgYXMgZGVmYXVsdCBhZHZhbmNlZCBzZXR0aW5ncy5cbiAgICovXG4gIHNldEFkdmFuY2VkR2FzRmVlKHZhbCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBhZHZhbmNlZEdhc0ZlZTogdmFsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGBlaXAxNTU5VjJFbmFibGVkYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsIC0gaG9sZHMgdGhlIGVpcDE1NTlWMkVuYWJsZWQgdGhhdCB0aGUgdXNlciBzZXQgYXMgZXhwZXJpbWVudGFsIHNldHRpbmdzLlxuICAgKi9cbiAgc2V0RUlQMTU1OVYyRW5hYmxlZCh2YWwpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZWlwMTU1OVYyRW5hYmxlZDogdmFsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgbWV0aG9kRGF0YSB0byBzdGF0ZSwgdG8gYXZvaWQgcmVxdWVzdGluZyB0aGlzIGluZm9ybWF0aW9uIGFnYWluIHRocm91Z2ggSW5mdXJhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3VyQnl0ZVByZWZpeCAtIEZvdXItYnl0ZSBtZXRob2Qgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2REYXRhIC0gQ29ycmVzcG9uZGluZyBkYXRhIG1ldGhvZFxuICAgKi9cbiAgYWRkS25vd25NZXRob2REYXRhKGZvdXJCeXRlUHJlZml4LCBtZXRob2REYXRhKSB7XG4gICAgY29uc3QgeyBrbm93bk1ldGhvZERhdGEgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBrbm93bk1ldGhvZERhdGFbZm91ckJ5dGVQcmVmaXhdID0gbWV0aG9kRGF0YTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsga25vd25NZXRob2REYXRhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGBjdXJyZW50TG9jYWxlYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gaGUgcHJlZmVycmVkIGxhbmd1YWdlIGxvY2FsZSBrZXlcbiAgICovXG4gIHNldEN1cnJlbnRMb2NhbGUoa2V5KSB7XG4gICAgY29uc3QgdGV4dERpcmVjdGlvbiA9IFsnYXInLCAnZHYnLCAnZmEnLCAnaGUnLCAna3UnXS5pbmNsdWRlcyhrZXkpXG4gICAgICA/ICdydGwnXG4gICAgICA6ICdhdXRvJztcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGN1cnJlbnRMb2NhbGU6IGtleSxcbiAgICAgIHRleHREaXJlY3Rpb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHREaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBpZGVudGl0aWVzIHRvIG9ubHkgaW5jbHVkZSBzcGVjaWZpZWQgYWRkcmVzc2VzLiBSZW1vdmVzIGlkZW50aXRpZXNcbiAgICogbm90IGluY2x1ZGVkIGluIGFkZHJlc3NlcyBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzZXMgLSBBbiBhcnJheSBvZiBoZXggYWRkcmVzc2VzXG4gICAqL1xuICBzZXRBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3Qgb2xkSWRlbnRpdGllcyA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5pZGVudGl0aWVzO1xuXG4gICAgY29uc3QgaWRlbnRpdGllcyA9IGFkZHJlc3Nlcy5yZWR1Y2UoKGlkcywgYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG9sZElkID0gb2xkSWRlbnRpdGllc1thZGRyZXNzXSB8fCB7fTtcbiAgICAgIGlkc1thZGRyZXNzXSA9IHsgbmFtZTogYEFjY291bnQgJHtpbmRleCArIDF9YCwgYWRkcmVzcywgLi4ub2xkSWQgfTtcbiAgICAgIHJldHVybiBpZHM7XG4gICAgfSwge30pO1xuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGlkZW50aXRpZXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhZGRyZXNzIGZyb20gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBIGhleCBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhZGRyZXNzIHRoYXQgd2FzIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKCFpZGVudGl0aWVzW2FkZHJlc3NdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YWRkcmVzc30gY2FuJ3QgYmUgZGVsZXRlZCBjYXVzZSBpdCB3YXMgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIGRlbGV0ZSBpZGVudGl0aWVzW2FkZHJlc3NdO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpZGVudGl0aWVzIH0pO1xuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGVkIGFjY291bnQgaXMgbm8gbG9uZ2VyIHZhbGlkLFxuICAgIC8vIHNlbGVjdCBhbiBhcmJpdHJhcnkgb3RoZXIgYWNjb3VudDpcbiAgICBpZiAoYWRkcmVzcyA9PT0gdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MoKSkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3Qua2V5cyhpZGVudGl0aWVzKVswXTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRBZGRyZXNzKHNlbGVjdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhZGRyZXNzZXMgdG8gdGhlIGlkZW50aXRpZXMgb2JqZWN0IHdpdGhvdXQgcmVtb3ZpbmcgaWRlbnRpdGllc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzZXMgLSBBbiBhcnJheSBvZiBoZXggYWRkcmVzc2VzXG4gICAqL1xuICBhZGRBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgIC8vIHNraXAgaWYgYWxyZWFkeSBleGlzdHNcbiAgICAgIGlmIChpZGVudGl0aWVzW2FkZHJlc3NdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBtaXNzaW5nIGlkZW50aXR5XG4gICAgICBjb25zdCBpZGVudGl0eUNvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcykubGVuZ3RoO1xuXG4gICAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0geyBuYW1lOiBgQWNjb3VudCAke2lkZW50aXR5Q291bnQgKyAxfWAsIGFkZHJlc3MgfTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgaWRlbnRpdGllcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgaWRlbnRpdHkgZW50cmllcyB3aXRoIGtub3duIGFjY291bnRzLlxuICAgKiBSZW1vdmVzIGFueSB1bmtub3duIGlkZW50aXRpZXMsIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhZGRyZXNzZXMgLSBrbm93biB0byB0aGUgdmF1bHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IHNlbGVjdGVkQWRkcmVzcyB0aGUgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICovXG4gIHN5bmNBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZHJlc3NlcykgfHwgYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tZW1wdHkgYXJyYXkgb2YgYWRkcmVzc2VzLiBFcnJvciAjMTEyMDEnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGlkZW50aXRpZXMsIGxvc3RJZGVudGl0aWVzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCBuZXdseUxvc3QgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKChpZGVudGl0eSkgPT4ge1xuICAgICAgaWYgKCFhZGRyZXNzZXMuaW5jbHVkZXMoaWRlbnRpdHkpKSB7XG4gICAgICAgIG5ld2x5TG9zdFtpZGVudGl0eV0gPSBpZGVudGl0aWVzW2lkZW50aXR5XTtcbiAgICAgICAgZGVsZXRlIGlkZW50aXRpZXNbaWRlbnRpdHldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWRlbnRpdGllcyBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgaWYgKE9iamVjdC5rZXlzKG5ld2x5TG9zdCkubGVuZ3RoID4gMCkge1xuICAgICAgLy8gc3RvcmUgbG9zdCBhY2NvdW50c1xuICAgICAgT2JqZWN0LmtleXMobmV3bHlMb3N0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbG9zdElkZW50aXRpZXNba2V5XSA9IG5ld2x5TG9zdFtrZXldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGlkZW50aXRpZXMsIGxvc3RJZGVudGl0aWVzIH0pO1xuICAgIHRoaXMuYWRkQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgYWNjb3VudCBpcyBubyBsb25nZXIgdmFsaWQsXG4gICAgLy8gc2VsZWN0IGFuIGFyYml0cmFyeSBvdGhlciBhY2NvdW50OlxuICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgaWYgKCFhZGRyZXNzZXMuaW5jbHVkZXMoc2VsZWN0ZWQpKSB7XG4gICAgICBzZWxlY3RlZCA9IGFkZHJlc3Nlc1swXTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRBZGRyZXNzKHNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYHNlbGVjdGVkQWRkcmVzc2AgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9hZGRyZXNzIC0gQSBuZXcgaGV4IGFkZHJlc3MgZm9yIGFuIGFjY291bnRcbiAgICovXG4gIHNldFNlbGVjdGVkQWRkcmVzcyhfYWRkcmVzcykge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKF9hZGRyZXNzKTtcblxuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHNlbGVjdGVkSWRlbnRpdHkgPSBpZGVudGl0aWVzW2FkZHJlc3NdO1xuICAgIGlmICghc2VsZWN0ZWRJZGVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZGVudGl0eSBmb3IgJyR7YWRkcmVzc30gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRJZGVudGl0eS5sYXN0U2VsZWN0ZWQgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBpZGVudGl0aWVzLCBzZWxlY3RlZEFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYHNlbGVjdGVkQWRkcmVzc2AgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGhleCBhZGRyZXNzIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGFjY291bnRcbiAgICovXG4gIGdldFNlbGVjdGVkQWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIGxhYmVsIGZvciBhbiBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50IC0gdGhlIGFjY291bnQgdG8gc2V0IGEgbGFiZWwgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIHRoZSBjdXN0b20gbGFiZWwgZm9yIHRoZSBhY2NvdW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBzZXRBY2NvdW50TGFiZWwoYWNjb3VudCwgbGFiZWwpIHtcbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHNldEFjY291bnRMYWJlbCByZXF1aXJlcyBhIHZhbGlkIGFkZHJlc3MsIGdvdCAke1N0cmluZyhhY2NvdW50KX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MoYWNjb3VudCk7XG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IGlkZW50aXRpZXNbYWRkcmVzc10gfHwge307XG4gICAgaWRlbnRpdGllc1thZGRyZXNzXS5uYW1lID0gbGFiZWw7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGlkZW50aXRpZXMgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsYWJlbCk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlcyBjdXN0b20gUlBDIGRldGFpbHNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld1JwY0RldGFpbHMgLSBPcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1JwY0RldGFpbHMucnBjVXJsIC0gVGhlIFJQQyB1cmwgdG8gYWRkIHRvIGZyZXF1ZW50UnBjTGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1JwY0RldGFpbHMuY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25ld1JwY0RldGFpbHMudGlja2VyXSAtIE9wdGlvbmFsIHRpY2tlciBzeW1ib2wgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmV3UnBjRGV0YWlscy5uaWNrbmFtZV0gLSBPcHRpb25hbCBuaWNrbmFtZSBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtuZXdScGNEZXRhaWxzLnJwY1ByZWZzXSAtIE9wdGlvbmFsIFJQQyBwcmVmZXJlbmNlcywgc3VjaCBhcyB0aGUgYmxvY2sgZXhwbG9yZXIgVVJMXG4gICAqL1xuICBhc3luYyB1cGRhdGVScGMobmV3UnBjRGV0YWlscykge1xuICAgIGNvbnN0IHJwY0xpc3QgPSB0aGlzLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgIGNvbnN0IGluZGV4ID0gcnBjTGlzdC5maW5kSW5kZXgoKGVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50LnJwY1VybCA9PT0gbmV3UnBjRGV0YWlscy5ycGNVcmw7XG4gICAgfSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IHJwY0RldGFpbCA9IHJwY0xpc3RbaW5kZXhdO1xuICAgICAgY29uc3QgdXBkYXRlZFJwYyA9IHsgLi4ucnBjRGV0YWlsLCAuLi5uZXdScGNEZXRhaWxzIH07XG4gICAgICBpZiAocnBjRGV0YWlsLmNoYWluSWQgIT09IHVwZGF0ZWRScGMuY2hhaW5JZCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbklkIGlzIGNoYW5nZWQsIGFzc29jaWF0ZWQgYWRkcmVzcyBib29rIGVudHJpZXMgc2hvdWxkXG4gICAgICAgIC8vIGFsc28gYmUgbWlncmF0ZWQuIFRoZSBhZGRyZXNzIGJvb2sgZW50cmllcyBhcmUga2V5ZWQgYnkgdGhlIGBuZXR3b3JrYCBzdGF0ZSxcbiAgICAgICAgLy8gd2hpY2ggZm9yIGN1c3RvbSBuZXR3b3JrcyBpcyB0aGUgY2hhaW5JZCB3aXRoIGEgZmFsbGJhY2sgdG8gdGhlIG5ldHdvcmtJZFxuICAgICAgICAvLyBpZiB0aGUgY2hhaW5JZCBpcyBub3Qgc2V0LlxuXG4gICAgICAgIGxldCBhZGRyZXNzQm9va0tleSA9IHJwY0RldGFpbC5jaGFpbklkO1xuICAgICAgICBpZiAoIWFkZHJlc3NCb29rS2V5KSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSBuZXR3b3JrSWQgdG8gZGV0ZXJtaW5lIHdoYXQgdGhlc2UgYWRkcmVzc2VzIHdlcmUga2V5ZWQgYnlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWRkcmVzc0Jvb2tLZXkgPSBhd2FpdCB0aGlzLmV0aGVyc1Byb3ZpZGVyLnNlbmQoJ25ldF92ZXJzaW9uJyk7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIGFkZHJlc3NCb29rS2V5ID09PSAnc3RyaW5nJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cud2FybihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBnZXQgbmV0d29ya0lkIGZyb20gJHtycGNEZXRhaWwucnBjVXJsfTsgc2tpcHBpbmcgYWRkcmVzcyBib29rIG1pZ3JhdGlvbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSB0d28gc2VwYXJhdGUgUlBDIGVuZHBvaW50cyBhcmUga2V5ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgLy8gdmFsdWUuIEluIHRoaXMgY2FzZSwgdGhlIGNvbnRhY3QgYm9vayBlbnRyaWVzIGFyZSBkdXBsaWNhdGVkIHNvIHRoYXQgdGhleSByZW1haW5cbiAgICAgICAgLy8gb24gYm90aCBuZXR3b3Jrcywgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGljaCBuZXR3b3JrIGVhY2ggY29udGFjdCBpcyBpbnRlbmRlZCBmb3IuXG5cbiAgICAgICAgbGV0IGR1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBidWlsdEluUHJvdmlkZXJOZXR3b3JrSWRzID0gT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgICBORVRXT1JLX1RZUEVfVE9fSURfTUFQLFxuICAgICAgICApLm1hcCgoaWRzKSA9PiBpZHMubmV0d29ya0lkKTtcbiAgICAgICAgY29uc3Qgb3RoZXJScGNFbnRyaWVzID0gcnBjTGlzdC5maWx0ZXIoXG4gICAgICAgICAgKGVudHJ5KSA9PiBlbnRyeS5ycGNVcmwgIT09IG5ld1JwY0RldGFpbHMucnBjVXJsLFxuICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYnVpbHRJblByb3ZpZGVyTmV0d29ya0lkcy5pbmNsdWRlcyhhZGRyZXNzQm9va0tleSkgfHxcbiAgICAgICAgICBvdGhlclJwY0VudHJpZXMuc29tZSgoZW50cnkpID0+IGVudHJ5LmNoYWluSWQgPT09IGFkZHJlc3NCb29rS2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBkdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taWdyYXRlQWRkcmVzc0Jvb2tTdGF0ZShcbiAgICAgICAgICBhZGRyZXNzQm9va0tleSxcbiAgICAgICAgICB1cGRhdGVkUnBjLmNoYWluSWQsXG4gICAgICAgICAgZHVwbGljYXRlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcnBjTGlzdFtpbmRleF0gPSB1cGRhdGVkUnBjO1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGZyZXF1ZW50UnBjTGlzdERldGFpbDogcnBjTGlzdCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBycGNVcmwsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRpY2tlcixcbiAgICAgICAgbmlja25hbWUsXG4gICAgICAgIHJwY1ByZWZzID0ge30sXG4gICAgICB9ID0gbmV3UnBjRGV0YWlscztcbiAgICAgIHRoaXMuYWRkVG9GcmVxdWVudFJwY0xpc3QocnBjVXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY3VzdG9tIFJQQyB1cmwgdG8gc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBUaGUgUlBDIHVybCB0byBhZGQgdG8gZnJlcXVlbnRScGNMaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjaGFpbklkIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RpY2tlcl0gLSBUaWNrZXIgc3ltYm9sIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25pY2tuYW1lXSAtIE5pY2tuYW1lIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3JwY1ByZWZzXSAtIE9wdGlvbmFsIFJQQyBwcmVmZXJlbmNlcywgc3VjaCBhcyB0aGUgYmxvY2sgZXhwbG9yZXIgVVJMXG4gICAqL1xuICBhZGRUb0ZyZXF1ZW50UnBjTGlzdChcbiAgICBycGNVcmwsXG4gICAgY2hhaW5JZCxcbiAgICB0aWNrZXIgPSAnRVRIJyxcbiAgICBuaWNrbmFtZSA9ICcnLFxuICAgIHJwY1ByZWZzID0ge30sXG4gICkge1xuICAgIGNvbnN0IHJwY0xpc3QgPSB0aGlzLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuXG4gICAgY29uc3QgaW5kZXggPSBycGNMaXN0LmZpbmRJbmRleCgoZWxlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIGVsZW1lbnQucnBjVXJsID09PSBycGNVcmw7XG4gICAgfSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcnBjTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmICghaXNQcmVmaXhlZEZvcm1hdHRlZEhleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQ6IFwiJHtjaGFpbklkfVwiYCk7XG4gICAgfVxuXG4gICAgcnBjTGlzdC5wdXNoKHsgcnBjVXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcyB9KTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZnJlcXVlbnRScGNMaXN0RGV0YWlsOiBycGNMaXN0IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY3VzdG9tIFJQQyB1cmwgZnJvbSBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBSUEMgdXJsIHRvIHJlbW92ZSBmcm9tIGZyZXF1ZW50UnBjTGlzdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBQcm9taXNlIHJlc29sdmluZyB0byB1cGRhdGVkIGZyZXF1ZW50UnBjTGlzdC5cbiAgICovXG4gIHJlbW92ZUZyb21GcmVxdWVudFJwY0xpc3QodXJsKSB7XG4gICAgY29uc3QgcnBjTGlzdCA9IHRoaXMuZ2V0RnJlcXVlbnRScGNMaXN0RGV0YWlsKCk7XG4gICAgY29uc3QgaW5kZXggPSBycGNMaXN0LmZpbmRJbmRleCgoZWxlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIGVsZW1lbnQucnBjVXJsID09PSB1cmw7XG4gICAgfSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcnBjTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgZnJlcXVlbnRScGNMaXN0RGV0YWlsOiBycGNMaXN0IH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocnBjTGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYGZyZXF1ZW50UnBjTGlzdERldGFpbGAgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxBcnJheT59IEFuIGFycmF5IG9mIHJwYyB1cmxzLlxuICAgKi9cbiAgZ2V0RnJlcXVlbnRScGNMaXN0RGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZnJlcXVlbnRScGNMaXN0RGV0YWlsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBmZWF0dXJlRmxhZ3NgIHByb3BlcnR5LCB3aGljaCBpcyBhbiBvYmplY3QuIE9uZSBwcm9wZXJ0eSB3aXRoaW4gdGhhdCBvYmplY3Qgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIEEga2V5IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBVSSBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2YXRlZCAtIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgVUkgZmVhdHVyZSBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFByb21pc2VzIGEgbmV3IG9iamVjdDsgdGhlIHVwZGF0ZWQgZmVhdHVyZUZsYWdzIG9iamVjdC5cbiAgICovXG4gIHNldEZlYXR1cmVGbGFnKGZlYXR1cmUsIGFjdGl2YXRlZCkge1xuICAgIGNvbnN0IGN1cnJlbnRGZWF0dXJlRmxhZ3MgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZmVhdHVyZUZsYWdzO1xuICAgIGNvbnN0IHVwZGF0ZWRGZWF0dXJlRmxhZ3MgPSB7XG4gICAgICAuLi5jdXJyZW50RmVhdHVyZUZsYWdzLFxuICAgICAgW2ZlYXR1cmVdOiBhY3RpdmF0ZWQsXG4gICAgfTtcblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBmZWF0dXJlRmxhZ3M6IHVwZGF0ZWRGZWF0dXJlRmxhZ3MgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVwZGF0ZWRGZWF0dXJlRmxhZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBwcmVmZXJlbmNlc2AgcHJvcGVydHksIHdoaWNoIGlzIGFuIG9iamVjdC4gVGhlc2UgYXJlIHVzZXItY29udHJvbGxlZCBmZWF0dXJlc1xuICAgKiBmb3VuZCBpbiB0aGUgc2V0dGluZ3MgcGFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZlcmVuY2UgLSBUaGUgcHJlZmVyZW5jZSB0byBlbmFibGUgb3IgZGlzYWJsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJlZmVyZW5jZSBzaG91bGQgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZXMgYSBuZXcgb2JqZWN0OyB0aGUgdXBkYXRlZCBwcmVmZXJlbmNlcyBvYmplY3QuXG4gICAqL1xuICBzZXRQcmVmZXJlbmNlKHByZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgY29uc3QgY3VycmVudFByZWZlcmVuY2VzID0gdGhpcy5nZXRQcmVmZXJlbmNlcygpO1xuICAgIGNvbnN0IHVwZGF0ZWRQcmVmZXJlbmNlcyA9IHtcbiAgICAgIC4uLmN1cnJlbnRQcmVmZXJlbmNlcyxcbiAgICAgIFtwcmVmZXJlbmNlXTogdmFsdWUsXG4gICAgfTtcblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBwcmVmZXJlbmNlczogdXBkYXRlZFByZWZlcmVuY2VzIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXBkYXRlZFByZWZlcmVuY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIGBwcmVmZXJlbmNlc2AgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQSBrZXktYm9vbGVhbiBtYXAgb2YgdXNlci1zZWxlY3RlZCBwcmVmZXJlbmNlcy5cbiAgICovXG4gIGdldFByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkucHJlZmVyZW5jZXM7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBgaXBmc0dhdGV3YXlgIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjdXJyZW50IElQRlMgZ2F0ZXdheSBkb21haW5cbiAgICovXG4gIGdldElwZnNHYXRld2F5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuaXBmc0dhdGV3YXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIHRoZSBgaXBmc0dhdGV3YXlgIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW4gLSBUaGUgbmV3IElQRlMgZ2F0ZXdheSBkb21haW5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIG9mIHRoZSB1cGRhdGUgSVBGUyBnYXRld2F5IGRvbWFpblxuICAgKi9cbiAgc2V0SXBmc0dhdGV3YXkoZG9tYWluKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7IGlwZnNHYXRld2F5OiBkb21haW4gfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkb21haW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgYGxlZGdlclRyYW5zcG9ydFR5cGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVkZ2VyVHJhbnNwb3J0VHlwZSAtIEVpdGhlciAnbGVkZ2VyTGl2ZScsICd3ZWJoaWQnIG9yICd1MmYnXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc3BvcnQgdHlwZSB0aGF0IHdhcyBzZXQuXG4gICAqL1xuICBzZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKGxlZGdlclRyYW5zcG9ydFR5cGUpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgbGVkZ2VyVHJhbnNwb3J0VHlwZSB9KTtcbiAgICByZXR1cm4gbGVkZ2VyVHJhbnNwb3J0VHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBmb3IgdGhlIGBsZWRnZXJUcmFuc3BvcnRUeXBlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGN1cnJlbnQgcHJlZmVycmVkIExlZGdlciB0cmFuc3BvcnQgdHlwZS5cbiAgICovXG4gIGdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5sZWRnZXJUcmFuc3BvcnRUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgdXNlciBwcmVmZXJlbmNlIHRvIGRpc21pc3MgdGhlIHNlZWQgcGhyYXNlIGJhY2t1cCByZW1pbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2x9IGRpc21pc3NTZWVkQmFja1VwUmVtaW5kZXIgLSBVc2VyIHByZWZlcmVuY2UgZm9yIGRpc21pc3NpbmcgdGhlIGJhY2sgdXAgcmVtaW5kZXIuXG4gICAqL1xuICBhc3luYyBzZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyKGRpc21pc3NTZWVkQmFja1VwUmVtaW5kZXIpIHtcbiAgICBhd2FpdCB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGRpc21pc3NTZWVkQmFja1VwUmVtaW5kZXIsXG4gICAgfSk7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICBfc3Vic2NyaWJlVG9JbmZ1cmFBdmFpbGFiaWxpdHkoKSB7XG4gICAgdGhpcy5uZXR3b3JrLm9uKE5FVFdPUktfRVZFTlRTLklORlVSQV9JU19CTE9DS0VELCAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRJbmZ1cmFCbG9ja2VkKHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMubmV0d29yay5vbihORVRXT1JLX0VWRU5UUy5JTkZVUkFfSVNfVU5CTE9DS0VELCAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRJbmZ1cmFCbG9ja2VkKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBBIHNldHRlciBmb3IgdGhlIGBpbmZ1cmFCbG9ja2VkYCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQmxvY2tlZCAtIEJvb2wgaW5kaWNhdGluZyB3aGV0aGVyIEluZnVyYSBpcyBibG9ja2VkXG4gICAqL1xuICBfc2V0SW5mdXJhQmxvY2tlZChpc0Jsb2NrZWQpIHtcbiAgICBjb25zdCB7IGluZnVyYUJsb2NrZWQgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGlmIChpbmZ1cmFCbG9ja2VkID09PSBpc0Jsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgaW5mdXJhQmxvY2tlZDogaXNCbG9ja2VkIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgV2ViMyBmcm9tICd3ZWIzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUJJIGZyb20gJ3NpbmdsZS1jYWxsLWJhbGFuY2UtY2hlY2tlci1hYmknO1xuaW1wb3J0IHsgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyB9IGZyb20gJy4uL2NvbnN0YW50cy9jb250cmFjdHMnO1xuaW1wb3J0IHsgTUlOVVRFIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuLi8uLi8uLi91aS9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgTUFJTk5FVF9DSEFJTl9JRCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbi8vIEJ5IGRlZmF1bHQsIHBvbGwgZXZlcnkgMyBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gTUlOVVRFICogMztcblxuLyoqXG4gKiBBIGNvbnRyb2xsZXIgdGhhdCBwb2xscyBmb3IgdG9rZW4gZXhjaGFuZ2VcbiAqIHJhdGVzIGJhc2VkIG9uIGEgdXNlcidzIGN1cnJlbnQgdG9rZW4gbGlzdFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXRlY3RUb2tlbnNDb250cm9sbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEZXRlY3RUb2tlbnNDb250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSAtIE9wdGlvbnMgdG8gY29uZmlndXJlIGNvbnRyb2xsZXJcbiAgICogQHBhcmFtIGNvbmZpZy5pbnRlcnZhbFxuICAgKiBAcGFyYW0gY29uZmlnLnByZWZlcmVuY2VzXG4gICAqIEBwYXJhbSBjb25maWcubmV0d29ya1xuICAgKiBAcGFyYW0gY29uZmlnLmtleXJpbmdNZW1TdG9yZVxuICAgKiBAcGFyYW0gY29uZmlnLnRva2VuTGlzdFxuICAgKiBAcGFyYW0gY29uZmlnLnRva2Vuc0NvbnRyb2xsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUwsXG4gICAgcHJlZmVyZW5jZXMsXG4gICAgbmV0d29yayxcbiAgICBrZXlyaW5nTWVtU3RvcmUsXG4gICAgdG9rZW5MaXN0LFxuICAgIHRva2Vuc0NvbnRyb2xsZXIsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMudG9rZW5zQ29udHJvbGxlciA9IHRva2Vuc0NvbnRyb2xsZXI7XG4gICAgdGhpcy5wcmVmZXJlbmNlcyA9IHByZWZlcmVuY2VzO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgIHRoaXMua2V5cmluZ01lbVN0b3JlID0ga2V5cmluZ01lbVN0b3JlO1xuICAgIHRoaXMudG9rZW5MaXN0ID0gdG9rZW5MaXN0O1xuICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlcz8uc3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgdGhpcy50b2tlbkFkZHJlc3NlcyA9IHRoaXMudG9rZW5zQ29udHJvbGxlcj8uc3RhdGUudG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICAgIHJldHVybiB0b2tlbi5hZGRyZXNzO1xuICAgIH0pO1xuICAgIHRoaXMuaGlkZGVuVG9rZW5zID0gdGhpcy50b2tlbnNDb250cm9sbGVyPy5zdGF0ZS5pZ25vcmVkVG9rZW5zO1xuXG4gICAgcHJlZmVyZW5jZXM/LnN0b3JlLnN1YnNjcmliZSgoeyBzZWxlY3RlZEFkZHJlc3MsIHVzZVRva2VuRGV0ZWN0aW9uIH0pID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgIT09IHNlbGVjdGVkQWRkcmVzcyB8fFxuICAgICAgICB0aGlzLnVzZVRva2VuRGV0ZWN0aW9uICE9PSB1c2VUb2tlbkRldGVjdGlvblxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICB0aGlzLnVzZVRva2VuRGV0ZWN0aW9uID0gdXNlVG9rZW5EZXRlY3Rpb247XG4gICAgICAgIHRoaXMucmVzdGFydFRva2VuRGV0ZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9rZW5zQ29udHJvbGxlcj8uc3Vic2NyaWJlKCh7IHRva2VucyA9IFtdLCBpZ25vcmVkVG9rZW5zID0gW10gfSkgPT4ge1xuICAgICAgdGhpcy50b2tlbkFkZHJlc3NlcyA9IHRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIHJldHVybiB0b2tlbi5hZGRyZXNzO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpZGRlblRva2VucyA9IGlnbm9yZWRUb2tlbnM7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBfZ2V0VG9rZW5CYWxhbmNlcyh0b2tlbnMpIHtcbiAgICBjb25zdCBldGhDb250cmFjdCA9IHRoaXMud2ViMy5ldGhcbiAgICAgIC5jb250cmFjdChTSU5HTEVfQ0FMTF9CQUxBTkNFU19BQkkpXG4gICAgICAuYXQoU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGV0aENvbnRyYWN0LmJhbGFuY2VzKFt0aGlzLnNlbGVjdGVkQWRkcmVzc10sIHRva2VucywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIHRva2VuIGluIHRoZSB0b2tlbmxpc3QgcHJvdmlkZWQgYnkgdGhlIFRva2VuTGlzdENvbnRyb2xsZXIsIGNoZWNrIHNlbGVjdGVkQWRkcmVzcyBiYWxhbmNlLlxuICAgKi9cbiAgYXN5bmMgZGV0ZWN0TmV3VG9rZW5zKCkge1xuICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgdG9rZW5MaXN0IH0gPSB0aGlzLl90b2tlbkxpc3Quc3RhdGU7XG4gICAgLy8gc2luY2UgdGhlIHRva2VuIGRldGVjdGlvbiBpcyBjdXJyZW50bHkgZW5hYmxlZCBvbmx5IG9uIE1haW5uZXRcbiAgICAvLyB3ZSBjYW4gdXNlIHRoZSBjaGFpbklkIGNoZWNrIHRvIGVuc3VyZSB0b2tlbiBkZXRlY3Rpb24gaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIG5ldHdvcmtcbiAgICAvLyBidXQgb25jZSB0aGUgYmFsYW5jZSBjaGVjayBjb250cmFjdCBmb3Igb3RoZXIgbmV0d29ya3MgYXJlIGRlcGxvYXllZCBhbmQgcmVhZHkgdG8gdXNlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGlzIGNoZWNrLlxuICAgIGlmIChcbiAgICAgIHRoaXMuX25ldHdvcmsuc3RvcmUuZ2V0U3RhdGUoKS5wcm92aWRlci5jaGFpbklkICE9PSBNQUlOTkVUX0NIQUlOX0lEIHx8XG4gICAgICBPYmplY3Qua2V5cyh0b2tlbkxpc3QpLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2Vuc1RvRGV0ZWN0ID0gW107XG4gICAgdGhpcy53ZWIzLnNldFByb3ZpZGVyKHRoaXMuX25ldHdvcmsuX3Byb3ZpZGVyKTtcbiAgICBmb3IgKGNvbnN0IHRva2VuQWRkcmVzcyBpbiB0b2tlbkxpc3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMudG9rZW5BZGRyZXNzZXMuZmluZCgoYWRkcmVzcykgPT5cbiAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFkZHJlc3MsIHRva2VuQWRkcmVzcyksXG4gICAgICAgICkgJiZcbiAgICAgICAgIXRoaXMuaGlkZGVuVG9rZW5zLmZpbmQoKGFkZHJlc3MpID0+XG4gICAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShhZGRyZXNzLCB0b2tlbkFkZHJlc3MpLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdG9rZW5zVG9EZXRlY3QucHVzaCh0b2tlbkFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzbGljZU9mVG9rZW5zVG9EZXRlY3QgPSBbXG4gICAgICB0b2tlbnNUb0RldGVjdC5zbGljZSgwLCAxMDAwKSxcbiAgICAgIHRva2Vuc1RvRGV0ZWN0LnNsaWNlKDEwMDAsIHRva2Vuc1RvRGV0ZWN0Lmxlbmd0aCAtIDEpLFxuICAgIF07XG4gICAgZm9yIChjb25zdCB0b2tlbnNTbGljZSBvZiBzbGljZU9mVG9rZW5zVG9EZXRlY3QpIHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXRUb2tlbkJhbGFuY2VzKHRva2Vuc1NsaWNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGFNYXNrIC0gRGV0ZWN0VG9rZW5zQ29udHJvbGxlciBzaW5nbGUgY2FsbCBiYWxhbmNlIGZldGNoIGZhaWxlZGAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5zV2l0aEJhbGFuY2UgPSB0b2tlbnNTbGljZS5maWx0ZXIoKF8sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYmFsYW5jZSAmJiAhYmFsYW5jZS5pc1plcm8oKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgdG9rZW5zV2l0aEJhbGFuY2UubWFwKCh0b2tlbkFkZHJlc3MpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNDb250cm9sbGVyLmFkZFRva2VuKFxuICAgICAgICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuQWRkcmVzc10uc3ltYm9sLFxuICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuQWRkcmVzc10uZGVjaW1hbHMsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0IHRva2VuIGRldGVjdGlvbiBwb2xsaW5nIHBlcmlvZCBhbmQgY2FsbCBkZXRlY3ROZXdUb2tlbnNcbiAgICogaW4gY2FzZSBvZiBhZGRyZXNzIGNoYW5nZSBvciB1c2VyIHNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqL1xuICByZXN0YXJ0VG9rZW5EZXRlY3Rpb24oKSB7XG4gICAgaWYgKCEodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLnNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXRlY3ROZXdUb2tlbnMoKTtcbiAgICB0aGlzLmludGVydmFsID0gREVGQVVMVF9JTlRFUlZBTDtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGFjY2Vzc29yLXBhaXJzICovXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IGludGVydmFsKGludGVydmFsKSB7XG4gICAgdGhpcy5faGFuZGxlICYmIGNsZWFySW50ZXJ2YWwodGhpcy5faGFuZGxlKTtcbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuZGV0ZWN0TmV3VG9rZW5zKCk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzZXQgbmV0d29yayhuZXR3b3JrKSB7XG4gICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgIHRoaXMud2ViMyA9IG5ldyBXZWIzKG5ldHdvcmsuX3Byb3ZpZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBzZXR0ZXIgd2hlbiBpc1VubG9ja2VkIGlzIHVwZGF0ZWQgdG8gdHJ1ZSwgZGV0ZWN0TmV3VG9rZW5zIGFuZCByZXN0YXJ0IHBvbGxpbmdcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHNldCBrZXlyaW5nTWVtU3RvcmUoa2V5cmluZ01lbVN0b3JlKSB7XG4gICAgaWYgKCFrZXlyaW5nTWVtU3RvcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fa2V5cmluZ01lbVN0b3JlID0ga2V5cmluZ01lbVN0b3JlO1xuICAgIHRoaXMuX2tleXJpbmdNZW1TdG9yZS5zdWJzY3JpYmUoKHsgaXNVbmxvY2tlZCB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1VubG9ja2VkICE9PSBpc1VubG9ja2VkKSB7XG4gICAgICAgIHRoaXMuaXNVbmxvY2tlZCA9IGlzVW5sb2NrZWQ7XG4gICAgICAgIGlmIChpc1VubG9ja2VkKSB7XG4gICAgICAgICAgdGhpcy5yZXN0YXJ0VG9rZW5EZXRlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzZXQgdG9rZW5MaXN0KHRva2VuTGlzdCkge1xuICAgIGlmICghdG9rZW5MaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3Rva2VuTGlzdCA9IHRva2VuTGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBpc0FjdGl2ZSBzdGF0ZVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3BlbiAmJiB0aGlzLmlzVW5sb2NrZWQ7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBhY2Nlc3Nvci1wYWlycyAqL1xufVxuIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuY29uc3QgSERLZXkgPSByZXF1aXJlKCdoZGtleScpO1xuY29uc3QgVHJlem9yQ29ubmVjdCA9IHJlcXVpcmUoJ3RyZXpvci1jb25uZWN0JykuZGVmYXVsdDtcbmNvbnN0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xuY29uc3QgdHJhbnNmb3JtVHlwZWREYXRhID0gcmVxdWlyZSgndHJlem9yLWNvbm5lY3QvbGliL3BsdWdpbnMvZXRoZXJldW0vdHlwZWREYXRhJyk7XG5cbmNvbnN0IGhkUGF0aFN0cmluZyA9IGBtLzQ0Jy82MCcvMCcvMGA7XG5jb25zdCBTTElQMDA0NFRlc3RuZXRQYXRoID0gYG0vNDQnLzEnLzAnLzBgO1xuXG5jb25zdCBBTExPV0VEX0hEX1BBVEhTID0ge1xuICBbaGRQYXRoU3RyaW5nXTogdHJ1ZSxcbiAgW1NMSVAwMDQ0VGVzdG5ldFBhdGhdOiB0cnVlLFxufTtcblxuY29uc3Qga2V5cmluZ1R5cGUgPSAnVHJlem9yIEhhcmR3YXJlJztcbmNvbnN0IHBhdGhCYXNlID0gJ20nO1xuY29uc3QgTUFYX0lOREVYID0gMTAwMDtcbmNvbnN0IERFTEFZX0JFVFdFRU5fUE9QVVBTID0gMTAwMDtcbmNvbnN0IFRSRVpPUl9DT05ORUNUX01BTklGRVNUID0ge1xuICBlbWFpbDogJ3N1cHBvcnRAbWV0YW1hc2suaW8nLFxuICBhcHBVcmw6ICdodHRwczovL21ldGFtYXNrLmlvJyxcbn07XG5cbmZ1bmN0aW9uIHdhaXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge19faW1wb3J0X18oJ0BldGhlcmV1bWpzL3R4JykuVHlwZWRUcmFuc2FjdGlvbn0gVHlwZWRUcmFuc2FjdGlvblxuICogQHR5cGVkZWYge0luc3RhbmNlVHlwZTxfX2ltcG9ydF9fKFwiZXRoZXJldW1qcy10eFwiKT59IE9sZEV0aEpzVHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBpcyBtYWRlIHdpdGggZXRoZXJldW1qcy10eCBvciBAZXRoZXJldW1qcy90eFxuICpcbiAqIFRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gKiBnZXRDaGFpbklkIG1ldGhvZCB0aGF0IG5ld2VyIHZlcnNpb25zIGRvIG5vdC5cbiAqIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gKiB3aGlsZSBuZXdlciB2ZXJzaW9ucyBkZWZhdWx0IHRvIGJlaW5nIGltbXV0YWJsZS5cbiAqIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gKiBvZiBkYXRhIGZvciB2LCByIGFuZCBzIGRpZmZlciAoQnVmZmVyIChvbGQpIHZzIEJOIChuZXcpKS5cbiAqXG4gKiBAcGFyYW0ge1R5cGVkVHJhbnNhY3Rpb24gfCBPbGRFdGhKc1RyYW5zYWN0aW9ufSB0eFxuICogQHJldHVybnMge3R4IGlzIE9sZEV0aEpzVHJhbnNhY3Rpb259IFJldHVybnMgYHRydWVgIGlmIHR4IGlzIGFuIG9sZC1zdHlsZSBldGhlcmV1bWpzLXR4IHRyYW5zYWN0aW9uLlxuICovXG5mdW5jdGlvbiBpc09sZFN0eWxlRXRoZXJldW1qc1R4KHR4KSB7XG4gIHJldHVybiB0eXBlb2YgdHguZ2V0Q2hhaW5JZCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY2xhc3MgVHJlem9yS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50eXBlID0ga2V5cmluZ1R5cGU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KCk7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcblxuICAgIFRyZXpvckNvbm5lY3Qub24oJ0RFVklDRV9FVkVOVCcsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnBheWxvYWQgJiYgZXZlbnQucGF5bG9hZC5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLm1vZGVsID0gZXZlbnQucGF5bG9hZC5mZWF0dXJlcy5tb2RlbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBUcmV6b3JDb25uZWN0LmluaXQoeyBtYW5pZmVzdDogVFJFWk9SX0NPTk5FQ1RfTUFOSUZFU1QgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9kZWwsIGlmIGtub3duLlxuICAgKiBUaGlzIG1heSBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgbW9kZWwgaGFzbid0IGJlZW4gbG9hZGVkIHlldC5cbiAgICpcbiAgICogQHJldHVybnMge1wiVFwiIHwgXCIxXCIgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgLy8gVGhpcyByZW1vdmVzIHRoZSBUcmV6b3IgQ29ubmVjdCBpZnJhbWUgZnJvbSB0aGUgRE9NXG4gICAgLy8gVGhpcyBtZXRob2QgaXMgbm90IHdlbGwgZG9jdW1lbnRlZCwgYnV0IHRoZSBjb2RlIGl0IGNhbGxzIGNhbiBiZSBzZWVuXG4gICAgLy8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3RyZXpvci9jb25uZWN0L2Jsb2IvZGVjNGE1NmFmOGE2NWE2MDU5ZmI1ZjYzZmEzYzY2OTBkMmMzN2UwMC9zcmMvanMvaWZyYW1lL2J1aWxkZXIuanMjTDE4MVxuICAgIFRyZXpvckNvbm5lY3QuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgcGFnZTogdGhpcy5wYWdlLFxuICAgICAgcGF0aHM6IHRoaXMucGF0aHMsXG4gICAgICBwZXJQYWdlOiB0aGlzLnBlclBhZ2UsXG4gICAgICB1bmxvY2tlZEFjY291bnQ6IHRoaXMudW5sb2NrZWRBY2NvdW50LFxuICAgIH0pO1xuICB9XG5cbiAgZGVzZXJpYWxpemUob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aCB8fCBoZFBhdGhTdHJpbmc7XG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHMgfHwgW107XG4gICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlIHx8IDA7XG4gICAgdGhpcy5wZXJQYWdlID0gb3B0cy5wZXJQYWdlIHx8IDU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgaXNVbmxvY2tlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhkayAmJiB0aGlzLmhkay5wdWJsaWNLZXkpO1xuICB9XG5cbiAgdW5sb2NrKCkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnYWxyZWFkeSB1bmxvY2tlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgVHJlem9yQ29ubmVjdC5nZXRQdWJsaWNLZXkoe1xuICAgICAgICBwYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgICAgY29pbjogJ0VUSCcsXG4gICAgICB9KVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5oZGsucHVibGljS2V5ID0gQnVmZmVyLmZyb20ocmVzcG9uc2UucGF5bG9hZC5wdWJsaWNLZXksICdoZXgnKTtcbiAgICAgICAgICAgIHRoaXMuaGRrLmNoYWluQ29kZSA9IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLnBheWxvYWQuY2hhaW5Db2RlLCAnaGV4Jyk7XG4gICAgICAgICAgICByZXNvbHZlKCdqdXN0IHVubG9ja2VkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IpIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKChlICYmIGUudG9TdHJpbmcoKSkgfHwgJ1Vua25vd24gZXJyb3InKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0QWNjb3VudFRvVW5sb2NrKGluZGV4KSB7XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICB9XG5cbiAgYWRkQWNjb3VudHMobiA9IDEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy51bmxvY2soKVxuICAgICAgICAudGhlbigoXykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLnVubG9ja2VkQWNjb3VudDtcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgX19nZXRQYWdlKGluY3JlbWVudCkge1xuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgIHRoaXMucGFnZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcblxuICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKTtcbiAgICAgICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoYWNjb3VudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzLnNsaWNlKCkpO1xuICB9XG5cbiAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoXG4gICAgICAoYSkgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIFRyZXpvci5cbiAgICpcbiAgICogQWNjZXB0cyBlaXRoZXIgYW4gZXRoZXJldW1qcy10eCBvciBAZXRoZXJldW1qcy90eCB0cmFuc2FjdGlvbiwgYW5kIHJldHVybnNcbiAgICogdGhlIHNhbWUgdHlwZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtUeXBlZFRyYW5zYWN0aW9uIHwgT2xkRXRoSnNUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBIZXggc3RyaW5nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IC0gSW5zdGFuY2Ugb2YgZWl0aGVyIG5ldy1zdHlsZSBvciBvbGQtc3R5bGUgZXRoZXJldW1qcyB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLCBhbiBpbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZVxuICAgKiBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4KSB7XG4gICAgaWYgKGlzT2xkU3R5bGVFdGhlcmV1bWpzVHgodHgpKSB7XG4gICAgICAvLyBJbiB0aGlzIHZlcnNpb24gb2YgZXRoZXJldW1qcy10eCB3ZSBtdXN0IGFkZCB0aGUgY2hhaW5JZCBpbiBoZXggZm9ybWF0XG4gICAgICAvLyB0byB0aGUgaW5pdGlhbCB2IHZhbHVlLiBUaGUgY2hhaW5JZCBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBzZXJpYWxpemVkXG4gICAgICAvLyB0cmFuc2FjdGlvbiB3aGljaCBpcyBvbmx5IGNvbW11bmljYXRlZCB0byBldGhlcmV1bWpzLXR4IGluIHRoaXNcbiAgICAgIC8vIHZhbHVlLiBJbiBuZXdlciB2ZXJzaW9ucyB0aGUgY2hhaW5JZCBpcyBjb21tdW5pY2F0ZWQgdmlhIHRoZSAnQ29tbW9uJ1xuICAgICAgLy8gb2JqZWN0LlxuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eC5nZXRDaGFpbklkKCksIHR4LCAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0eC52ID0gQnVmZmVyLmZyb20ocGF5bG9hZC52LCAnaGV4Jyk7XG4gICAgICAgIHR4LnIgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnIsICdoZXgnKTtcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25UcmFuc2FjdGlvbihcbiAgICAgIGFkZHJlc3MsXG4gICAgICB0eC5jb21tb24uY2hhaW5JZEJOKCkudG9OdW1iZXIoKSxcbiAgICAgIHR4LFxuICAgICAgKHBheWxvYWQpID0+IHtcbiAgICAgICAgLy8gQmVjYXVzZSB0eCB3aWxsIGJlIGltbXV0YWJsZSwgZmlyc3QgZ2V0IGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAgIC8vIG5vbWVuY2xhdHVyZSBvZiBldGhlcmV1bWpzL3R4LlxuICAgICAgICBjb25zdCB0eERhdGEgPSB0eC50b0pTT04oKTtcbiAgICAgICAgLy8gVGhlIGZyb21UeERhdGEgdXRpbGl0eSBleHBlY3RzIGEgdHlwZSB0byBzdXBwb3J0IHRyYW5zYWN0aW9ucyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIDBcbiAgICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgICB0eERhdGEudiA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQudik7XG4gICAgICAgIHR4RGF0YS5yID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5yKTtcbiAgICAgICAgdHhEYXRhLnMgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnMpO1xuICAgICAgICAvLyBBZG9wdCB0aGUgJ2NvbW1vbicgb3B0aW9uIGZyb20gdGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uIGFuZCBzZXQgdGhlXG4gICAgICAgIC8vIHJldHVybmVkIG9iamVjdCB0byBiZSBmcm96ZW4gaWYgdGhlIG9yaWdpbmFsIGlzIGZyb3plbi5cbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwge1xuICAgICAgICAgIGNvbW1vbjogdHguY29tbW9uLFxuICAgICAgICAgIGZyZWV6ZTogT2JqZWN0LmlzRnJvemVuKHR4KSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUeXBlZFRyYW5zYWN0aW9uIHwgT2xkRXRoSnNUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBIZXggc3RyaW5nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkIC0gQ2hhaW4gSURcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggLSBJbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZSBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0geyhfX2ltcG9ydF9fKCd0cmV6b3ItY29ubmVjdCcpLkV0aGVyZXVtU2lnbmVkVHgpID0+IFRyYW5zYWN0aW9ufSBoYW5kbGVTaWduaW5nIC0gQ29udmVydHMgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIHRvIHRoZSBzYW1lIG5ldy1zdHlsZSBvciBvbGQtc3R5bGUgZXRoZXJldW1qcy10eC5cbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLCBhbiBpbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZVxuICAgKiBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX3NpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCBjaGFpbklkLCB0eCwgaGFuZGxlU2lnbmluZykge1xuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAoaXNPbGRTdHlsZUV0aGVyZXVtanNUeCh0eCkpIHtcbiAgICAgIC8vIGxlZ2FjeSB0cmFuc2FjdGlvbiBmcm9tIGV0aGVyZXVtanMtdHggcGFja2FnZSBoYXMgbm8gLnRvSlNPTigpIGZ1bmN0aW9uLFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IHRvIGhleC1zdHJpbmdzIG1hbnVhbGx5IG1hbnVhbGx5XG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86IHRoaXMuX25vcm1hbGl6ZSh0eC50byksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ub3JtYWxpemUodHgudmFsdWUpLFxuICAgICAgICBkYXRhOiB0aGlzLl9ub3JtYWxpemUodHguZGF0YSksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5vbmNlOiB0aGlzLl9ub3JtYWxpemUodHgubm9uY2UpLFxuICAgICAgICBnYXNMaW1pdDogdGhpcy5fbm9ybWFsaXplKHR4Lmdhc0xpbWl0KSxcbiAgICAgICAgZ2FzUHJpY2U6IHRoaXMuX25vcm1hbGl6ZSh0eC5nYXNQcmljZSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXctc3R5bGUgdHJhbnNhY3Rpb24gZnJvbSBAZXRoZXJldW1qcy90eCBwYWNrYWdlXG4gICAgICAvLyB3ZSBjYW4ganVzdCBjb3B5IHR4LnRvSlNPTigpIGZvciBldmVyeXRoaW5nIGV4Y2VwdCBjaGFpbklkLCB3aGljaCBtdXN0IGJlIGEgbnVtYmVyXG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgLi4udHgudG9KU09OKCksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRvOiB0aGlzLl9ub3JtYWxpemUodHgudG8pLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy51bmxvY2soKTtcbiAgICAgIGF3YWl0IHdhaXQoc3RhdHVzID09PSAnanVzdCB1bmxvY2tlZCcgPyBERUxBWV9CRVRXRUVOX1BPUFVQUyA6IDApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgcGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgbmV3T3JNdXRhdGVkVHggPSBoYW5kbGVTaWduaW5nKHJlc3BvbnNlLnBheWxvYWQpO1xuXG4gICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhcbiAgICAgICAgICBldGhVdGlsLmFkZEhleFByZWZpeChcbiAgICAgICAgICAgIG5ld09yTXV0YXRlZFR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29ycmVjdEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoYWRkcmVzc1NpZ25lZFdpdGggIT09IGNvcnJlY3RBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIGRvZXNuJ3QgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T3JNdXRhdGVkVHg7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IpIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKChlICYmIGUudG9TdHJpbmcoKSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICB9XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgLy8gRm9yIHBlcnNvbmFsX3NpZ24sIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBtZXNzYWdlOlxuICBzaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKHN0YXR1cykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoXykgPT4ge1xuICAgICAgICAgICAgICBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICBoZXg6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGF5bG9hZC5hZGRyZXNzICE9PVxuICAgICAgICAgICAgICAgICAgICAgIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtyZXNwb25zZS5wYXlsb2FkLnNpZ25hdHVyZX1gO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgcG9wdXAgY29sbGlzaW9uXG4gICAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHVubG9jayAmIHNpZ24gdHJlem9yIHBvcHVwc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gJ2p1c3QgdW5sb2NrZWQnID8gREVMQVlfQkVUV0VFTl9QT1BVUFMgOiAwLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRUlQLTcxMiBTaWduIFR5cGVkIERhdGFcbiAgICovXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoYWRkcmVzcywgZGF0YSwgeyB2ZXJzaW9uIH0pIHtcbiAgICBjb25zdCBkYXRhV2l0aEhhc2hlcyA9IHRyYW5zZm9ybVR5cGVkRGF0YShkYXRhLCB2ZXJzaW9uID09PSAnVjQnKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3Igc2lnblR5cGVkRGF0YVxuICAgIC8vIFRyZXpvciBpcyBzdHJpY3RlciB0aGFuIEBtZXRhbWFzay9ldGgtc2lnLXV0aWwgaW4gd2hhdCBpdCBhY2NlcHRzXG4gICAgY29uc3Qge1xuICAgICAgdHlwZXM6IHsgRUlQNzEyRG9tYWluID0gW10sIC4uLm90aGVyVHlwZXMgfSA9IHt9LFxuICAgICAgbWVzc2FnZSA9IHt9LFxuICAgICAgZG9tYWluID0ge30sXG4gICAgICBwcmltYXJ5VHlwZSxcbiAgICAgIC8vIHNuYWtlX2Nhc2Ugc2luY2UgVHJlem9yIHVzZXMgUHJvdG9idWYgbmFtaW5nIGNvbnZlbnRpb25zIGhlcmVcbiAgICAgIGRvbWFpbl9zZXBhcmF0b3JfaGFzaCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIG1lc3NhZ2VfaGFzaCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB9ID0gZGF0YVdpdGhIYXNoZXM7XG5cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBwb3B1cCBjb2xsaXNpb25cbiAgICAvLyBiZXR3ZWVuIHRoZSB1bmxvY2sgJiBzaWduIHRyZXpvciBwb3B1cHNcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLnVubG9jaygpO1xuICAgIGF3YWl0IHdhaXQoc3RhdHVzID09PSAnanVzdCB1bmxvY2tlZCcgPyBERUxBWV9CRVRXRUVOX1BPUFVQUyA6IDApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblR5cGVkRGF0YSh7XG4gICAgICBwYXRoOiB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcyksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGVzOiB7IEVJUDcxMkRvbWFpbiwgLi4ub3RoZXJUeXBlcyB9LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgfSxcbiAgICAgIG1ldGFtYXNrX3Y0X2NvbXBhdDogdHJ1ZSxcbiAgICAgIC8vIFRyZXpvciAxIG9ubHkgc3VwcG9ydHMgYmxpbmRseSBzaWduaW5nIGhhc2hlc1xuICAgICAgZG9tYWluX3NlcGFyYXRvcl9oYXNoLFxuICAgICAgbWVzc2FnZV9oYXNoLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIGlmIChldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpICE9PSByZXNwb25zZS5wYXlsb2FkLmFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgZG9lc250IG1hdGNoIHRoZSByaWdodCBhZGRyZXNzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UucGF5bG9hZC5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICk7XG4gIH1cblxuICBleHBvcnRBY2NvdW50KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKSk7XG4gIH1cblxuICBmb3JnZXREZXZpY2UoKSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KCk7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDA7XG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgSEQgcGF0aCB0byBiZSB1c2VkIGJ5IHRoZSBrZXlyaW5nLiBPbmx5IGtub3duIHN1cHBvcnRlZCBIRCBwYXRocyBhcmUgYWxsb3dlZC5cbiAgICpcbiAgICogSWYgdGhlIGdpdmVuIEhEIHBhdGggaXMgYWxyZWFkeSB0aGUgY3VycmVudCBIRCBwYXRoLCBub3RoaW5nIGhhcHBlbnMuIE90aGVyd2lzZSB0aGUgbmV3IEhEXG4gICAqIHBhdGggaXMgc2V0LCBhbmQgdGhlIHdhbGxldCBzdGF0ZSBpcyBjb21wbGV0ZWx5IHJlc2V0LlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcl0gVGhyb3dzIGlmIHRoZSBIRCBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZFBhdGggLSBUaGUgSEQgcGF0aCB0byBzZXQuXG4gICAqL1xuICBzZXRIZFBhdGgoaGRQYXRoKSB7XG4gICAgaWYgKCFBTExPV0VEX0hEX1BBVEhTW2hkUGF0aF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBzZXRIZFBhdGggbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBIRCBQYXRoIHRvICR7aGRQYXRofWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IEhES2V5IGlmIHRoZSBwYXRoIGNoYW5nZXNcbiAgICBpZiAodGhpcy5oZFBhdGggIT09IGhkUGF0aCkge1xuICAgICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKTtcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwO1xuICAgICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmhkUGF0aCA9IGhkUGF0aDtcbiAgfVxuXG4gIC8qIFBSSVZBVEUgTUVUSE9EUyAqL1xuXG4gIF9ub3JtYWxpemUoYnVmKSB7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b1N0cmluZygpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkge1xuICAgIGNvbnN0IGRrZXkgPSB0aGlzLmhkay5kZXJpdmUoYCR7cGF0aEJhc2V9LyR7aX1gKTtcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYDB4JHthZGRyZXNzfWApO1xuICB9XG5cbiAgX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhdGhzW2NoZWNrc3VtbWVkQWRkcmVzc107XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWA7XG4gIH1cbn1cblxuVHJlem9yS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IFRyZXpvcktleXJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Blcm1pc3Npb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXNvdXJjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VydmljZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NuYXBzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJqZWN0LW1ldGFkYXRhXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vY3JlYXRlTWV0aG9kTWlkZGxld2FyZSc7XG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvZmlyc3QsaW1wb3J0L29yZGVyICovXG5jb25zdCBCb3ggPSBwcm9jZXNzLmVudi5JTl9URVNUXG4gID8gcmVxdWlyZSgnLi4vLi4vLi4vZGV2ZWxvcG1lbnQvbW9jay0zYm94JylcbiAgOiByZXF1aXJlKCczYm94Jyk7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9vcmRlciAqL1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IEpzb25ScGNFbmdpbmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHsgcHJvdmlkZXJGcm9tRW5naW5lIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IE1pZ3JhdG9yIGZyb20gJy4uL2xpYi9taWdyYXRvcic7XG5pbXBvcnQgbWlncmF0aW9ucyBmcm9tICcuLi9taWdyYXRpb25zJztcbmltcG9ydCBjcmVhdGVPcmlnaW5NaWRkbGV3YXJlIGZyb20gJy4uL2xpYi9jcmVhdGVPcmlnaW5NaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUgZnJvbSAnLi9uZXR3b3JrL2NyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZSc7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9maXJzdCAqL1xuXG5jb25zdCBTWU5DX1RJTUVPVVQgPSA2MCAqIDEwMDA7IC8vIG9uZSBtaW51dGVcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGhyZWVCb3hDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAga2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0S2V5cmluZ0NvbnRyb2xsZXJTdGF0ZSxcbiAgICAgIHRyYWNrTWV0YU1ldHJpY3NFdmVudCxcbiAgICB9ID0gb3B0cztcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gcHJlZmVyZW5jZXNDb250cm9sbGVyO1xuICAgIHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyID0gYWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIgPSBrZXlyaW5nQ29udHJvbGxlcjtcbiAgICB0aGlzLnByb3ZpZGVyID0gdGhpcy5fY3JlYXRlUHJvdmlkZXIoe1xuICAgICAgdmVyc2lvbixcbiAgICAgIGdldEFjY291bnRzOiBhc3luYyAoeyBvcmlnaW4gfSkgPT4ge1xuICAgICAgICBpZiAob3JpZ2luICE9PSAnM0JveCcpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc1VubG9ja2VkIH0gPSBnZXRLZXlyaW5nQ29udHJvbGxlclN0YXRlKCk7XG5cbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG5cbiAgICAgICAgaWYgKGlzVW5sb2NrZWQgJiYgYWNjb3VudHNbMF0pIHtcbiAgICAgICAgICBjb25zdCBhcHBLZXlBZGRyZXNzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBcHBLZXlBZGRyZXNzKFxuICAgICAgICAgICAgYWNjb3VudHNbMF0sXG4gICAgICAgICAgICAnd2FsbGV0Oi8vM2JveC5tZXRhbWFzay5pbycsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gW2FwcEtleUFkZHJlc3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzUGVyc29uYWxNZXNzYWdlOiBhc3luYyAobXNnUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgICByZXR1cm4ga2V5cmluZ0NvbnRyb2xsZXIuc2lnblBlcnNvbmFsTWVzc2FnZShcbiAgICAgICAgICB7IC4uLm1zZ1BhcmFtcywgZnJvbTogYWNjb3VudHNbMF0gfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aXRoQXBwS2V5T3JpZ2luOiAnd2FsbGV0Oi8vM2JveC5tZXRhbWFzay5pbycsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50ID0gdHJhY2tNZXRhTWV0cmljc0V2ZW50O1xuXG4gICAgY29uc3QgaW5pdFN0YXRlID0ge1xuICAgICAgdGhyZWVCb3hTeW5jaW5nQWxsb3dlZDogZmFsc2UsXG4gICAgICBzaG93UmVzdG9yZVByb21wdDogdHJ1ZSxcbiAgICAgIHRocmVlQm94TGFzdFVwZGF0ZWQ6IDAsXG4gICAgICAuLi5vcHRzLmluaXRTdGF0ZSxcbiAgICAgIHRocmVlQm94QWRkcmVzczogbnVsbCxcbiAgICAgIHRocmVlQm94U3luY2VkOiBmYWxzZSxcbiAgICAgIHRocmVlQm94RGlzYWJsZWQ6IGZhbHNlLFxuICAgIH07XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoaW5pdFN0YXRlKTtcbiAgICB0aGlzLnJlZ2lzdGVyaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdE1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnZlcnNpb24gLSBiLnZlcnNpb24pXG4gICAgICAuc2xpY2UoLTEpWzBdO1xuXG4gICAgaWYgKGluaXRTdGF0ZS50aHJlZUJveFN5bmNpbmdBbGxvd2VkKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBpbml0KCkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFjY291bnRzWzBdO1xuXG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgIGV2ZW50OiAnM0JveCBJbml0aWF0ZWQnLFxuICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmFkZHJlc3MgJiYgISh0aGlzLmJveCAmJiB0aGlzLnN0b3JlLmdldFN0YXRlKCkudGhyZWVCb3hTeW5jZWQpKSB7XG4gICAgICBhd2FpdCB0aGlzLm5ldzNCb3goKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlM0JveCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB0aHJlZUJveFN5bmNpbmdBbGxvd2VkLCB0aHJlZUJveFN5bmNlZCB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHRocmVlQm94U3luY2luZ0FsbG93ZWQgJiYgdGhyZWVCb3hTeW5jZWQpIHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgYWRkcmVzc0Jvb2s6IHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLnN0YXRlLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGxhc3RNaWdyYXRpb246IHRoaXMubGFzdE1pZ3JhdGlvbixcbiAgICAgICAgfTtcblxuICAgICAgICBhd2FpdCB0aGlzLnNwYWNlLnByaXZhdGUuc2V0KFxuICAgICAgICAgICdtZXRhbWFza0JhY2t1cCcsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLnNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlUHJvdmlkZXIocHJvdmlkZXJPcHRzKSB7XG4gICAgY29uc3QgbWV0YW1hc2tNaWRkbGV3YXJlID0gY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlKHByb3ZpZGVyT3B0cyk7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IEpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaChjcmVhdGVPcmlnaW5NaWRkbGV3YXJlKHsgb3JpZ2luOiAnM0JveCcgfSkpO1xuICAgIGVuZ2luZS5wdXNoKG1ldGFtYXNrTWlkZGxld2FyZSk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cblxuICBfd2FpdEZvck9uU3luY0RvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmJveC5vblN5bmNEb25lKCgpID0+IHtcbiAgICAgICAgbG9nLmRlYnVnKCczQm94IGJveCBzeW5jIGRvbmUnKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbmV3M0JveCgpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEFwcEtleUFkZHJlc3MoXG4gICAgICBhY2NvdW50c1swXSxcbiAgICAgICd3YWxsZXQ6Ly8zYm94Lm1ldGFtYXNrLmlvJyxcbiAgICApO1xuICAgIGxldCBiYWNrdXBFeGlzdHM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRocmVlQm94Q29uZmlnID0gYXdhaXQgQm94LmdldENvbmZpZyh0aGlzLmFkZHJlc3MpO1xuICAgICAgYmFja3VwRXhpc3RzID0gdGhyZWVCb3hDb25maWcuc3BhY2VzICYmIHRocmVlQm94Q29uZmlnLnNwYWNlcy5tZXRhbWFzaztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5tZXNzYWdlLm1hdGNoKC9eRXJyb3I6IEludmFsaWQgcmVzcG9uc2UgXFwoNDA0XFwpL3UpKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICAgICAgZXZlbnQ6ICczQm94IEJhY2t1cCBkb2VzIG5vdCBleGlzdCcsXG4gICAgICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmFja3VwRXhpc3RzID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiAnM0JveCBDb25maWcgRXJyb3InLFxuICAgICAgICAgIGNhdGVnb3J5OiAnM0JveCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFRocmVlQm94U3luY2luZ1N0YXRlKCkgfHwgYmFja3VwRXhpc3RzKSB7XG4gICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdGhyZWVCb3hTeW5jZWQ6IGZhbHNlIH0pO1xuXG4gICAgICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHN5bmNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxvZy5lcnJvcihgM0JveCBzeW5jIHRpbWVkIG91dCBhZnRlciAke1NZTkNfVElNRU9VVH0gbXNgKTtcbiAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICB0aHJlZUJveERpc2FibGVkOiB0cnVlLFxuICAgICAgICAgIHRocmVlQm94U3luY2luZ0FsbG93ZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgIH0sIFNZTkNfVElNRU9VVCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJveCA9IGF3YWl0IEJveC5vcGVuQm94KHRoaXMuYWRkcmVzcywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dhaXRGb3JPblN5bmNEb25lKCk7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBhd2FpdCB0aGlzLmJveC5vcGVuU3BhY2UoJ21ldGFtYXNrJywge1xuICAgICAgICAgIG9uU3luY0RvbmU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlVXBkYXRlID0ge1xuICAgICAgICAgICAgICB0aHJlZUJveFN5bmNlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGhyZWVCb3hBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgIGxvZy5pbmZvKGAzQm94IHN5bmMgY29tcGxldGVkIGFmdGVyIHRpbWVvdXQ7IG5vIGxvbmdlciBkaXNhYmxlZGApO1xuICAgICAgICAgICAgICBzdGF0ZVVwZGF0ZS50aHJlZUJveERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzeW5jVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHN0YXRlVXBkYXRlKTtcblxuICAgICAgICAgICAgbG9nLmRlYnVnKCczQm94IHNwYWNlIHN5bmMgZG9uZScpO1xuXG4gICAgICAgICAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDogJzNCb3ggU3luY2VkJyxcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6ICczQm94JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLl90cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiAnM0JveCBJbml0aWF0aW9uIEVycm9yJyxcbiAgICAgICAgICBjYXRlZ29yeTogJzNCb3gnLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldExhc3RVcGRhdGVkKCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc3BhY2UucHJpdmF0ZS5nZXQoJ21ldGFtYXNrQmFja3VwJyk7XG4gICAgY29uc3QgcGFyc2VkUmVzID0gSlNPTi5wYXJzZShyZXMgfHwgJ3t9Jyk7XG4gICAgcmV0dXJuIHBhcnNlZFJlcy5sYXN0VXBkYXRlZDtcbiAgfVxuXG4gIGFzeW5jIG1pZ3JhdGVCYWNrZWRVcFN0YXRlKGJhY2tlZFVwU3RhdGUpIHtcbiAgICBjb25zdCBtaWdyYXRvciA9IG5ldyBNaWdyYXRvcih7IG1pZ3JhdGlvbnMgfSk7XG4gICAgY29uc3QgeyBwcmVmZXJlbmNlcywgYWRkcmVzc0Jvb2sgfSA9IEpTT04ucGFyc2UoYmFja2VkVXBTdGF0ZSk7XG4gICAgY29uc3QgZm9ybWF0dGVkU3RhdGVCYWNrdXAgPSB7XG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHByZWZlcmVuY2VzLFxuICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiBhZGRyZXNzQm9vayxcbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxNaWdyYXRpb25TdGF0ZSA9IG1pZ3JhdG9yLmdlbmVyYXRlSW5pdGlhbFN0YXRlKFxuICAgICAgZm9ybWF0dGVkU3RhdGVCYWNrdXAsXG4gICAgKTtcbiAgICBjb25zdCBtaWdyYXRlZFN0YXRlID0gYXdhaXQgbWlncmF0b3IubWlncmF0ZURhdGEoaW5pdGlhbE1pZ3JhdGlvblN0YXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJlZmVyZW5jZXM6IG1pZ3JhdGVkU3RhdGUuZGF0YS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBhZGRyZXNzQm9vazogbWlncmF0ZWRTdGF0ZS5kYXRhLkFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcmVzdG9yZUZyb21UaHJlZUJveCgpIHtcbiAgICBjb25zdCBiYWNrZWRVcFN0YXRlID0gYXdhaXQgdGhpcy5zcGFjZS5wcml2YXRlLmdldCgnbWV0YW1hc2tCYWNrdXAnKTtcbiAgICBjb25zdCB7IHByZWZlcmVuY2VzLCBhZGRyZXNzQm9vayB9ID0gYXdhaXQgdGhpcy5taWdyYXRlQmFja2VkVXBTdGF0ZShcbiAgICAgIGJhY2tlZFVwU3RhdGUsXG4gICAgKTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgdGhyZWVCb3hMYXN0VXBkYXRlZDogYmFja2VkVXBTdGF0ZS5sYXN0VXBkYXRlZCB9KTtcbiAgICBwcmVmZXJlbmNlcyAmJiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS51cGRhdGVTdGF0ZShwcmVmZXJlbmNlcyk7XG4gICAgYWRkcmVzc0Jvb2sgJiYgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIudXBkYXRlKGFkZHJlc3NCb29rLCB0cnVlKTtcbiAgICB0aGlzLnNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZSgpO1xuXG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgIGV2ZW50OiAnM0JveCBSZXN0b3JlZCBEYXRhJyxcbiAgICAgIGNhdGVnb3J5OiAnM0JveCcsXG4gICAgfSk7XG4gIH1cblxuICB0dXJuVGhyZWVCb3hTeW5jaW5nT24oKSB7XG4gICAgdGhpcy5fdHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgIGV2ZW50OiAnM0JveCBTeW5jIFR1cm5lZCBPbicsXG4gICAgICBjYXRlZ29yeTogJzNCb3gnLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVnaXN0ZXJVcGRhdGVzKCk7XG4gIH1cblxuICB0dXJuVGhyZWVCb3hTeW5jaW5nT2ZmKCkge1xuICAgIHRoaXMuX3RyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICBldmVudDogJzNCb3ggU3luYyBUdXJuZWQgT2ZmJyxcbiAgICAgIGNhdGVnb3J5OiAnM0JveCcsXG4gICAgfSk7XG5cbiAgICB0aGlzLmJveC5sb2dvdXQoKTtcbiAgfVxuXG4gIHNldFNob3dSZXN0b3JlUHJvbXB0VG9GYWxzZSgpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgc2hvd1Jlc3RvcmVQcm9tcHQ6IGZhbHNlIH0pO1xuICB9XG5cbiAgc2V0VGhyZWVCb3hTeW5jaW5nUGVybWlzc2lvbihuZXdUaHJlZWJveFN5bmNpbmdTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0b3JlLmdldFN0YXRlKCkudGhyZWVCb3hEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRocmVlQm94U3luY2luZ0FsbG93ZWQ6IG5ld1RocmVlYm94U3luY2luZ1N0YXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG5ld1RocmVlYm94U3luY2luZ1N0YXRlICYmIHRoaXMuYm94KSB7XG4gICAgICB0aGlzLnR1cm5UaHJlZUJveFN5bmNpbmdPbigpO1xuICAgIH1cblxuICAgIGlmICghbmV3VGhyZWVib3hTeW5jaW5nU3RhdGUgJiYgdGhpcy5ib3gpIHtcbiAgICAgIHRoaXMudHVyblRocmVlQm94U3luY2luZ09mZigpO1xuICAgIH1cbiAgfVxuXG4gIGdldFRocmVlQm94U3luY2luZ1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkudGhyZWVCb3hTeW5jaW5nQWxsb3dlZDtcbiAgfVxuXG4gIF9yZWdpc3RlclVwZGF0ZXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdGVyaW5nVXBkYXRlcykge1xuICAgICAgY29uc3QgdXBkYXRlUHJlZmVyZW5jZXMgPSB0aGlzLl91cGRhdGUzQm94LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUodXBkYXRlUHJlZmVyZW5jZXMpO1xuICAgICAgY29uc3QgdXBkYXRlQWRkcmVzc0Jvb2sgPSB0aGlzLl91cGRhdGUzQm94LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlci5zdWJzY3JpYmUodXBkYXRlQWRkcmVzc0Jvb2spO1xuICAgICAgdGhpcy5yZWdpc3RlcmluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIFJlZmxlY3QuYXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgYWZ0ZXIgdGltZW91dCBzbyBhcyBub3QgdG8gaW50ZXJydXB0IHRoZSBzdGFja1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcbiAgICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuY2xhc3MgU2FmZUV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZW1pdCh0eXBlLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgICAgICBpZiAoZG9FcnJvcikge1xuICAgICAgICAgICAgbGV0IGVyO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIFtlcl0gPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgICAgICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBVbmhhbmRsZWQgZXJyb3IuJHtlciA/IGAgKCR7ZXIubWVzc2FnZX0pYCA6ICcnfWApO1xuICAgICAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlQXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2FmZUV2ZW50RW1pdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFpbFR4c1RoYXQodmVyc2lvbiwgcmVhc29uLCBjb25kaXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUsIGNvbmRpdGlvbiwgcmVhc29uKTtcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUsIGNvbmRpdGlvbiwgcmVhc29uKSB7XG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcblxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGlmICghY29uZGl0aW9uKHR4TWV0YSkpIHtcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcbiAgICAgIH1cblxuICAgICAgdHhNZXRhLnN0YXR1cyA9IFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRDtcbiAgICAgIHR4TWV0YS5lcnIgPSB7XG4gICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgbm90ZTogYFR4IGF1dG9tYXRpY2FsbHkgZmFpbGVkIGJ5IG1pZ3JhdGlvbiBiZWNhdXNlICR7cmVhc29ufWAsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHhNZXRhO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cbiIsImltcG9ydCBqc29uRGlmZmVyIGZyb20gJ2Zhc3QtanNvbi1wYXRjaCc7XG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuXG4vKipcbiAqIGNvbnZlcnRzIG5vbi1pbml0aWFsIGhpc3RvcnkgZW50cmllcyBpbnRvIGRpZmZzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG9uZ0hpc3RvcnlcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGVGcm9tU25hcHNob3RzVG9EaWZmcyhsb25nSGlzdG9yeSkge1xuICByZXR1cm4gKFxuICAgIGxvbmdIaXN0b3J5XG4gICAgICAvLyBjb252ZXJ0IG5vbi1pbml0aWFsIGhpc3RvcnkgZW50cmllcyBpbnRvIGRpZmZzXG4gICAgICAubWFwKChlbnRyeSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUhpc3RvcnlFbnRyeShsb25nSGlzdG9yeVtpbmRleCAtIDFdLCBlbnRyeSk7XG4gICAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBoaXN0b3J5IG9iamVjdHMgc2Vuc2UgdGhlIHByZXZpb3VzIHN0YXRlLlxuICogVGhlIG9iamVjdCBoYXMgdGhlIGtleXNcbiAqIG9wICh0aGUgb3BlcmF0aW9uIHBlcmZvcm1lZCksXG4gKiBwYXRoICh0aGUga2V5IGFuZCBpZiBhIG5lc3RlZCBvYmplY3QgdGhlbiBlYWNoIGtleSB3aWxsIGJlIHNlcGFyYXRlZCB3aXRoIGEgYC9gKVxuICogdmFsdWVcbiAqIHdpdGggdGhlIGZpcnN0IGVudHJ5IGhhdmluZyB0aGUgbm90ZSBhbmQgYSB0aW1lc3RhbXAgd2hlbiB0aGUgY2hhbmdlIHRvb2sgcGxhY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJldmlvdXNTdGF0ZSAtIHRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbmV3U3RhdGUgLSB0aGUgdXBkYXRlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtub3RlXSAtIGEgb3B0aW9uYWwgbm90ZSBmb3IgdGhlIHN0YXRlIGNoYW5nZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVIaXN0b3J5RW50cnkocHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIG5vdGUpIHtcbiAgY29uc3QgZW50cnkgPSBqc29uRGlmZmVyLmNvbXBhcmUocHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpO1xuICAvLyBBZGQgYSBub3RlIHRvIHRoZSBmaXJzdCBvcCwgc2luY2UgaXQgYnJlYWtzIGlmIHdlIGFwcGVuZCBpdCB0byB0aGUgZW50cnlcbiAgaWYgKGVudHJ5WzBdKSB7XG4gICAgaWYgKG5vdGUpIHtcbiAgICAgIGVudHJ5WzBdLm5vdGUgPSBub3RlO1xuICAgIH1cbiAgICBlbnRyeVswXS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn1cblxuLyoqXG4gKiBSZWNvdmVycyBwcmV2aW91cyB0eE1ldGEgc3RhdGUgb2JqXG4gKlxuICogQHBhcmFtIF9zaG9ydEhpc3RvcnlcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlIaXN0b3J5KF9zaG9ydEhpc3RvcnkpIHtcbiAgY29uc3Qgc2hvcnRIaXN0b3J5ID0gY2xvbmVEZWVwKF9zaG9ydEhpc3RvcnkpO1xuICByZXR1cm4gc2hvcnRIaXN0b3J5LnJlZHVjZShcbiAgICAodmFsLCBlbnRyeSkgPT4ganNvbkRpZmZlci5hcHBseVBhdGNoKHZhbCwgZW50cnkpLm5ld0RvY3VtZW50LFxuICApO1xufVxuXG4vKipcbiAqIFNuYXBzaG90IHtAY29kZSB0eE1ldGF9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eCBtZXRhZGF0YSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGEgZGVlcCBjbG9uZSB3aXRob3V0IGhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90RnJvbVR4TWV0YSh0eE1ldGEpIHtcbiAgY29uc3Qgc2hhbGxvdyA9IHsgLi4udHhNZXRhIH07XG4gIGRlbGV0ZSBzaGFsbG93Lmhpc3Rvcnk7XG4gIHJldHVybiBjbG9uZURlZXAoc2hhbGxvdyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvRGF0YVZpZXcgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGRhdGFgIHRvIGJlIGFuIEFycmF5QnVmZmVyLCBCdWZmZXIsIEludDhBcnJheSwgVWludDhBcnJheSBvciBVaW50OENsYW1wZWRBcnJheScpXG59XG4iLCJjb25zdCBhYmkgPSBbXG4gIHtcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgIG5hbWU6ICdyZXNvbHZlcicsXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBuYW1lOiAnb3duZXInLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2xhYmVsJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICdvd25lcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldFN1Ym5vZGVPd25lcicsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ3R0bCcsIHR5cGU6ICd1aW50NjQnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0VFRMJyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBuYW1lOiAndHRsJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ3VpbnQ2NCcgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ3Jlc29sdmVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0UmVzb2x2ZXInLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICdvd25lcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldE93bmVyJyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICdvd25lcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ1RyYW5zZmVyJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ2xhYmVsJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAnb3duZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdOZXdPd25lcicsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGluZGV4ZWQ6IHRydWUsIG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAncmVzb2x2ZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdOZXdSZXNvbHZlcicsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGluZGV4ZWQ6IHRydWUsIG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAndHRsJywgdHlwZTogJ3VpbnQ2NCcgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdOZXdUVEwnLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG5dO1xuZXhwb3J0IGRlZmF1bHQgYWJpO1xuIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJ9
