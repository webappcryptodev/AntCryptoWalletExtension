LavaPack.loadBundle([
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\resolver.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\ens-ipfs\contracts\resolver.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const abi = [{
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'hash',
    type: 'bytes32'
  }],
  name: 'setContent',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'content',
  outputs: [{
    name: '',
    type: 'bytes32'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'interfaceID',
    type: 'bytes4'
  }],
  name: 'supportsInterface',
  outputs: [{
    name: '',
    type: 'bool'
  }],
  payable: false,
  stateMutability: 'pure',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'key',
    type: 'string'
  }, {
    name: 'value',
    type: 'string'
  }],
  name: 'setText',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'contentTypes',
    type: 'uint256'
  }],
  name: 'ABI',
  outputs: [{
    name: 'contentType',
    type: 'uint256'
  }, {
    name: 'data',
    type: 'bytes'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'x',
    type: 'bytes32'
  }, {
    name: 'y',
    type: 'bytes32'
  }],
  name: 'setPubkey',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'hash',
    type: 'bytes'
  }],
  name: 'setContenthash',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'addr',
  outputs: [{
    name: '',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'key',
    type: 'string'
  }],
  name: 'text',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'contentType',
    type: 'uint256'
  }, {
    name: 'data',
    type: 'bytes'
  }],
  name: 'setABI',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'name',
  outputs: [{
    name: '',
    type: 'string'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'name',
    type: 'string'
  }],
  name: 'setName',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'contenthash',
  outputs: [{
    name: '',
    type: 'bytes'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: true,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }],
  name: 'pubkey',
  outputs: [{
    name: 'x',
    type: 'bytes32'
  }, {
    name: 'y',
    type: 'bytes32'
  }],
  payable: false,
  stateMutability: 'view',
  type: 'function'
}, {
  constant: false,
  inputs: [{
    name: 'node',
    type: 'bytes32'
  }, {
    name: 'addr',
    type: 'address'
  }],
  name: 'setAddr',
  outputs: [],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'function'
}, {
  inputs: [{
    name: 'ensAddr',
    type: 'address'
  }],
  payable: false,
  stateMutability: 'nonpayable',
  type: 'constructor'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'a',
    type: 'address'
  }],
  name: 'AddrChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'name',
    type: 'string'
  }],
  name: 'NameChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: true,
    name: 'contentType',
    type: 'uint256'
  }],
  name: 'ABIChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'x',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'y',
    type: 'bytes32'
  }],
  name: 'PubkeyChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'indexedKey',
    type: 'string'
  }, {
    indexed: false,
    name: 'key',
    type: 'string'
  }],
  name: 'TextChanged',
  type: 'event'
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    name: 'node',
    type: 'bytes32'
  }, {
    indexed: false,
    name: 'hash',
    type: 'bytes'
  }],
  name: 'ContenthashChanged',
  type: 'event'
}];
var _default = abi;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\contracts\\resolver.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\index.js", {"./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js","./profiles":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\src\index.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
}, {package:"@ensdomains\\content-hash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\constants\\contracts.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\constants\contracts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = exports.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = exports.SINGLE_CALL_BALANCES_ADDRESS_KOVAN = exports.SINGLE_CALL_BALANCES_ADDRESS = void 0;
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
exports.SINGLE_CALL_BALANCES_ADDRESS = SINGLE_CALL_BALANCES_ADDRESS;
const SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = '0x9f510b19f1ad66f0dcf6e45559fab0d6752c1db7';
exports.SINGLE_CALL_BALANCES_ADDRESS_RINKEBY = SINGLE_CALL_BALANCES_ADDRESS_RINKEBY;
const SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = '0xb8e671734ce5c8d7dfbbea5574fa4cf39f7a54a4';
exports.SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN = SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN;
const SINGLE_CALL_BALANCES_ADDRESS_KOVAN = '0xb1d3fbb2f83aecd196f474c16ca5d9cffa0d0ffc';
exports.SINGLE_CALL_BALANCES_ADDRESS_KOVAN = SINGLE_CALL_BALANCES_ADDRESS_KOVAN;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\constants\\contracts.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createScaffoldMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\createScaffoldMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware(handlers) {
    return (req, res, next, end) => {
        const handler = handlers[req.method];
        // if no handler, return
        if (handler === undefined) {
            return next();
        }
        // if handler is fn, call as middleware
        if (typeof handler === 'function') {
            return handler(req, res, next, end);
        }
        // if handler is some other value, use as result
        res.result = handler;
        return end();
    };
}
exports.createScaffoldMiddleware = createScaffoldMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createScaffoldMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createAsyncMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\createAsyncMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAsyncMiddleware = void 0;
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 */
function createAsyncMiddleware(asyncMiddleware) {
    return async (req, res, next, end) => {
        // nextPromise is the key to the implementation
        // it is resolved by the return handler passed to the
        // "next" function
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
            resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        // This will be called by the consumer's async middleware.
        const asyncNext = async () => {
            nextWasCalled = true;
            // We pass a return handler to next(). When it is called by the engine,
            // the consumer's async middleware will resume executing.
            // eslint-disable-next-line node/callback-return
            next((runReturnHandlersCallback) => {
                // This callback comes from JsonRpcEngine._runReturnHandlers
                returnHandlerCallback = runReturnHandlersCallback;
                resolveNextPromise();
            });
            await nextPromise;
        };
        try {
            await asyncMiddleware(req, res, asyncNext);
            if (nextWasCalled) {
                await nextPromise; // we must wait until the return handler is called
                returnHandlerCallback(null);
            }
            else {
                end(null);
            }
        }
        catch (error) {
            if (returnHandlerCallback) {
                returnHandlerCallback(error);
            }
            else {
                end(error);
            }
        }
    };
}
exports.createAsyncMiddleware = createAsyncMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\createAsyncMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\getUniqueId.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\getUniqueId.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueId = void 0;
// uint32 (two's complement) max
// more conservative than Number.MAX_SAFE_INTEGER
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\getUniqueId.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\idRemapMiddleware.js", {"./getUniqueId":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\getUniqueId.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\idRemapMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdRemapMiddleware = void 0;
const getUniqueId_1 = require("./getUniqueId");
function createIdRemapMiddleware() {
    return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
            req.id = originalId;
            res.id = originalId;
            done();
        });
    };
}
exports.createIdRemapMiddleware = createIdRemapMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\idRemapMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\mergeMiddleware.js", {"./JsonRpcEngine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\JsonRpcEngine.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\mergeMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMiddleware = void 0;
const JsonRpcEngine_1 = require("./JsonRpcEngine");
function mergeMiddleware(middlewareStack) {
    const engine = new JsonRpcEngine_1.JsonRpcEngine();
    middlewareStack.forEach((middleware) => engine.push(middleware));
    return engine.asMiddleware();
}
exports.mergeMiddleware = mergeMiddleware;

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\mergeMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\JsonRpcEngine.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\json-rpc-engine\dist\JsonRpcEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */
class JsonRpcEngine extends safe_event_emitter_1.default {
    constructor() {
        super();
        this._middleware = [];
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(middleware) {
        this._middleware.push(middleware);
    }
    handle(req, cb) {
        if (cb && typeof cb !== 'function') {
            throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
            if (cb) {
                return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
        }
        if (cb) {
            return this._handle(req, cb);
        }
        return this._promiseHandle(req);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
        return async (req, res, next, end) => {
            try {
                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
                if (isComplete) {
                    await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    return end(middlewareError);
                }
                return next(async (handlerCallback) => {
                    try {
                        await JsonRpcEngine._runReturnHandlers(returnHandlers);
                    }
                    catch (error) {
                        return handlerCallback(error);
                    }
                    return handlerCallback();
                });
            }
            catch (error) {
                return end(error);
            }
        };
    }
    async _handleBatch(reqs, cb) {
        // The order here is important
        try {
            // 2. Wait for all requests to finish, or throw on some kind of fatal
            // error
            const responses = await Promise.all(
            // 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this)));
            // 3. Return batch response
            if (cb) {
                return cb(null, responses);
            }
            return responses;
        }
        catch (error) {
            if (cb) {
                return cb(error);
            }
            throw error;
        }
    }
    /**
     * A promise-wrapped _handle.
     */
    _promiseHandle(req) {
        return new Promise((resolve) => {
            this._handle(req, (_err, res) => {
                // There will always be a response, and it will always have any error
                // that is caught and propagated.
                resolve(res);
            });
        });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
    async _handle(callerReq, cb) {
        if (!callerReq ||
            Array.isArray(callerReq) ||
            typeof callerReq !== 'object') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
            return cb(error, { id: undefined, jsonrpc: '2.0', error });
        }
        if (typeof callerReq.method !== 'string') {
            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
        }
        const req = Object.assign({}, callerReq);
        const res = {
            id: req.id,
            jsonrpc: req.jsonrpc,
        };
        let error = null;
        try {
            await this._processRequest(req, res);
        }
        catch (_error) {
            // A request handler error, a re-thrown middleware error, or something
            // unexpected.
            error = _error;
        }
        if (error) {
            // Ensure no result is present on an errored response
            delete res.result;
            if (!res.error) {
                res.error = eth_rpc_errors_1.serializeError(error);
            }
        }
        return cb(error, res);
    }
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
    async _processRequest(req, res) {
        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        // Throw if "end" was not called, or if the response has neither a result
        // nor an error.
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        // The return handlers should run even if an error was encountered during
        // middleware processing.
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        // Now we re-throw the middleware processing error, if any, to catch it
        // further up the call chain.
        if (error) {
            throw error;
        }
    }
    /**
     * Serially executes the given stack of middleware.
     *
     * @returns An array of any error encountered during middleware execution,
     * a boolean indicating whether the request was completed, and an array of
     * middleware-defined return handlers.
     */
    static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        // Go down stack of middleware, call and collect optional returnHandlers
        for (const middleware of middlewareStack) {
            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
            if (isComplete) {
                break;
            }
        }
        return [error, isComplete, returnHandlers.reverse()];
    }
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
    static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
            const end = (err) => {
                const error = err || res.error;
                if (error) {
                    res.error = eth_rpc_errors_1.serializeError(error);
                }
                // True indicates that the request should end
                resolve([error, true]);
            };
            const next = (returnHandler) => {
                if (res.error) {
                    end(res.error);
                }
                else {
                    if (returnHandler) {
                        if (typeof returnHandler !== 'function') {
                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                `Received "${typeof returnHandler}" for request:\n${jsonify(req)}`, { request: req }));
                        }
                        returnHandlers.push(returnHandler);
                    }
                    // False indicates that the request should not end
                    resolve([null, false]);
                }
            };
            try {
                middleware(req, res, next, end);
            }
            catch (error) {
                end(error);
            }
        });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
    static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
            await new Promise((resolve, reject) => {
                handler((err) => (err ? reject(err) : resolve()));
            });
        }
    }
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
    static _checkForCompletion(req, res, isComplete) {
        if (!('result' in res) && !('error' in res)) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(req)}`, { request: req });
        }
    }
}
exports.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
    return JSON.stringify(request, null, 2);
}

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\JsonRpcEngine.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\ens.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","ethereum-ens-network-map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-ens-network-map\\index.js","ethjs-ens":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\ens\ens.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethjsEns = _interopRequireDefault(require("ethjs-ens"));

var _ethereumEnsNetworkMap = _interopRequireDefault(require("ethereum-ens-network-map"));

class Ens {
  static getNetworkEnsSupport(network) {
    return Boolean(_ethereumEnsNetworkMap.default[network]);
  }

  constructor({
    network,
    provider
  } = {}) {
    this._ethJsEns = new _ethjsEns.default({
      network,
      provider
    });
  }

  lookup(ensName) {
    return this._ethJsEns.lookup(ensName);
  }

  reverse(address) {
    return this._ethJsEns.reverse(address);
  }

}

exports.default = Ens;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\ens\\ens.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\enums.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WALLET_PREFIX = exports.NOTIFICATION_NAMES = exports.LOG_METHOD_TYPES = exports.LOG_LIMIT = exports.LOG_IGNORE_METHODS = void 0;
const WALLET_PREFIX = 'wallet_';
exports.WALLET_PREFIX = WALLET_PREFIX;
const NOTIFICATION_NAMES = {
  accountsChanged: 'metamask_accountsChanged',
  unlockStateChanged: 'metamask_unlockStateChanged',
  chainChanged: 'metamask_chainChanged'
};
exports.NOTIFICATION_NAMES = NOTIFICATION_NAMES;
const LOG_IGNORE_METHODS = ['wallet_registerOnboarding', 'wallet_watchAsset'];
exports.LOG_IGNORE_METHODS = LOG_IGNORE_METHODS;
const LOG_METHOD_TYPES = {
  restricted: 'restricted',
  internal: 'internal'
};
/**
 * The permission activity log size limit.
 */

exports.LOG_METHOD_TYPES = LOG_METHOD_TYPES;
const LOG_LIMIT = 100;
exports.LOG_LIMIT = LOG_LIMIT;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\enums.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\selectors.js", {"../../../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","reselect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\reselect\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\selectors.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPermittedAccountsByOrigin = exports.getChangedAccounts = void 0;

var _reselect = require("reselect");

var _permissions = require("../../../../shared/constants/permissions");

/**
 * This file contains selectors for PermissionController selector event
 * subscriptions, used to detect whenever a subject's accounts change so that
 * we can notify the subject via the `accountsChanged` provider event.
 */

/**
 * @param {Record<string, Record<string, unknown>>} state - The
 * PermissionController state.
 * @returns {Record<string, unknown>} The PermissionController subjects.
 */
const getSubjects = state => state.subjects;
/**
 * Get the permitted accounts for each subject, keyed by origin.
 * The values of the returned map are immutable values from the
 * PermissionController state.
 *
 * @returns {Map<string, string[]>} The current origin:accounts[] map.
 */


const getPermittedAccountsByOrigin = (0, _reselect.createSelector)(getSubjects, subjects => {
  return Object.values(subjects).reduce((originToAccountsMap, subject) => {
    var _subject$permissions, _subject$permissions$;

    const caveat = (_subject$permissions = subject.permissions) === null || _subject$permissions === void 0 ? void 0 : (_subject$permissions$ = _subject$permissions.eth_accounts) === null || _subject$permissions$ === void 0 ? void 0 : _subject$permissions$.caveats.find(({
      type
    }) => type === _permissions.CaveatTypes.restrictReturnedAccounts);

    if (caveat) {
      originToAccountsMap.set(subject.origin, caveat.value);
    }

    return originToAccountsMap;
  }, new Map());
});
/**
 * Given the current and previous exposed accounts for each PermissionController
 * subject, returns a new map containing all accounts that have changed.
 * The values of each map must be immutable values directly from the
 * PermissionController state, or an empty array instantiated in this
 * function.
 *
 * @param {Map<string, string[]>} newAccountsMap - The new origin:accounts[] map.
 * @param {Map<string, string[]>} [previousAccountsMap] - The previous origin:accounts[] map.
 * @returns {Map<string, string[]>} The origin:accounts[] map of changed accounts.
 */

exports.getPermittedAccountsByOrigin = getPermittedAccountsByOrigin;

const getChangedAccounts = (newAccountsMap, previousAccountsMap) => {
  if (previousAccountsMap === undefined) {
    return newAccountsMap;
  }

  const changedAccounts = new Map();

  if (newAccountsMap === previousAccountsMap) {
    return changedAccounts;
  }

  const newOrigins = new Set([...newAccountsMap.keys()]);

  for (const origin of previousAccountsMap.keys()) {
    var _newAccountsMap$get;

    const newAccounts = (_newAccountsMap$get = newAccountsMap.get(origin)) !== null && _newAccountsMap$get !== void 0 ? _newAccountsMap$get : []; // The values of these maps are references to immutable values, which is why
    // a strict equality check is enough for diffing. The values are either from
    // PermissionController state, or an empty array initialized in the previous
    // call to this function. `newAccountsMap` will never contain any empty
    // arrays.

    if (previousAccountsMap.get(origin) !== newAccounts) {
      changedAccounts.set(origin, newAccounts);
    }

    newOrigins.delete(origin);
  } // By now, newOrigins is either empty or contains some number of previously
  // unencountered origins, and all of their accounts have "changed".


  for (const origin of newOrigins.keys()) {
    changedAccounts.set(origin, newAccountsMap.get(origin));
  }

  return changedAccounts;
};

exports.getChangedAccounts = getChangedAccounts;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\selectors.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\caveat-mutators.js", {"../../../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\caveat-mutators.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CaveatMutatorFactories = void 0;

var _snapControllers = require("@metamask/snap-controllers");

var _permissions = require("../../../../shared/constants/permissions");

/**
 * Factories that construct caveat mutator functions that are passed to
 * PermissionController.updatePermissionsByCaveat.
 */
const CaveatMutatorFactories = {
  [_permissions.CaveatTypes.restrictReturnedAccounts]: {
    removeAccount
  }
};
/**
 * Removes the target account from the value arrays of all
 * `restrictReturnedAccounts` caveats. No-ops if the target account is not in
 * the array, and revokes the parent permission if it's the only account in
 * the array.
 *
 * @param {string} targetAccount - The address of the account to remove from
 * all accounts permissions.
 * @param {string[]} existingAccounts - The account address array from the
 * account permissions.
 */

exports.CaveatMutatorFactories = CaveatMutatorFactories;

function removeAccount(targetAccount, existingAccounts) {
  const newAccounts = existingAccounts.filter(address => address !== targetAccount);

  if (newAccounts.length === existingAccounts.length) {
    return {
      operation: _snapControllers.CaveatMutatorOperation.noop
    };
  } else if (newAccounts.length > 0) {
    return {
      operation: _snapControllers.CaveatMutatorOperation.updateValue,
      value: newAccounts
    };
  }

  return {
    operation: _snapControllers.CaveatMutatorOperation.revokePermission
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\caveat-mutators.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\permission-log.js", {"../../../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","./enums":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\enums.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","fast-safe-stringify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-safe-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\permission-log.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PermissionLogController = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _fastSafeStringify = _interopRequireDefault(require("fast-safe-stringify"));

var _permissions = require("../../../../shared/constants/permissions");

var _enums = require("./enums");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Controller with middleware for logging requests and responses to restricted
 * and permissions-related methods.
 */
class PermissionLogController {
  /**
   * @param {{ restrictedMethods: Set<string>, initState: Record<string, unknown> }} options - Options bag.
   */
  constructor({
    restrictedMethods,
    initState
  }) {
    this.restrictedMethods = restrictedMethods;
    this.store = new _obsStore.ObservableStore(_objectSpread({
      permissionHistory: {},
      permissionActivityLog: []
    }, initState));
  }
  /**
   * Get the restricted method activity log.
   *
   * @returns {Array<Object>} The activity log.
   */


  getActivityLog() {
    return this.store.getState().permissionActivityLog;
  }
  /**
   * Update the restricted method activity log.
   *
   * @param {Array<Object>} logs - The new activity log array.
   */


  updateActivityLog(logs) {
    this.store.updateState({
      permissionActivityLog: logs
    });
  }
  /**
   * Get the permission history log.
   *
   * @returns {Object} The permissions history log.
   */


  getHistory() {
    return this.store.getState().permissionHistory;
  }
  /**
   * Update the permission history log.
   *
   * @param {Object} history - The new permissions history log object.
   */


  updateHistory(history) {
    this.store.updateState({
      permissionHistory: history
    });
  }
  /**
   * Updates the exposed account history for the given origin.
   * Sets the 'last seen' time to Date.now() for the given accounts.
   * Does **not** update the 'lastApproved' time for the permission itself.
   * Returns if the accounts array is empty.
   *
   * @param {string} origin - The origin that the accounts are exposed to.
   * @param {Array<string>} accounts - The accounts.
   */


  updateAccountsHistory(origin, accounts) {
    if (accounts.length === 0) {
      return;
    }

    const accountToTimeMap = getAccountToTimeMap(accounts, Date.now());
    this.commitNewHistory(origin, {
      eth_accounts: {
        accounts: accountToTimeMap
      }
    });
  }
  /**
   * Create a permissions log middleware. Records permissions activity and history:
   *
   * Activity: requests and responses for restricted and most wallet_ methods.
   *
   * History: for each origin, the last time a permission was granted, including
   * which accounts were exposed, if any.
   *
   * @returns {JsonRpcEngineMiddleware} The permissions log middleware.
   */


  createMiddleware() {
    return (req, res, next, _end) => {
      let activityEntry, requestedMethods;
      const {
        origin,
        method
      } = req;
      const isInternal = method.startsWith(_enums.WALLET_PREFIX); // we only log certain methods

      if (!_enums.LOG_IGNORE_METHODS.includes(method) && (isInternal || this.restrictedMethods.has(method))) {
        activityEntry = this.logRequest(req, isInternal);

        if (method === `${_enums.WALLET_PREFIX}requestPermissions`) {
          // get the corresponding methods from the requested permissions so
          // that we can record permissions history
          requestedMethods = this.getRequestedMethods(req);
        }
      } else if (method === 'eth_requestAccounts') {
        // eth_requestAccounts is a special case; we need to extract the accounts
        // from it
        activityEntry = this.logRequest(req, isInternal);
        requestedMethods = ['eth_accounts'];
      } else {
        // no-op
        next();
        return;
      } // call next with a return handler for capturing the response


      next(cb => {
        const time = Date.now();
        this.logResponse(activityEntry, res, time);

        if (requestedMethods && !res.error && res.result) {
          // any permissions or accounts changes will be recorded on the response,
          // so we only log permissions history here
          this.logPermissionsHistory(requestedMethods, origin, res.result, time, method === 'eth_requestAccounts');
        }

        cb();
      });
    };
  }
  /**
   * Creates and commits an activity log entry, without response data.
   *
   * @param {Object} request - The request object.
   * @param {boolean} isInternal - Whether the request is internal.
   */


  logRequest(request, isInternal) {
    const activityEntry = {
      id: request.id,
      method: request.method,
      methodType: isInternal ? _enums.LOG_METHOD_TYPES.internal : _enums.LOG_METHOD_TYPES.restricted,
      origin: request.origin,
      request: (0, _fastSafeStringify.default)(request, null, 2),
      requestTime: Date.now(),
      response: null,
      responseTime: null,
      success: null
    };
    this.commitNewActivity(activityEntry);
    return activityEntry;
  }
  /**
   * Adds response data to an existing activity log entry.
   * Entry assumed already committed (i.e., in the log).
   *
   * @param {Object} entry - The entry to add a response to.
   * @param {Object} response - The response object.
   * @param {number} time - Output from Date.now()
   */


  logResponse(entry, response, time) {
    if (!entry || !response) {
      return;
    }

    entry.response = (0, _fastSafeStringify.default)(response, null, 2);
    entry.responseTime = time;
    entry.success = !response.error;
  }
  /**
   * Commit a new entry to the activity log.
   * Removes the oldest entry from the log if it exceeds the log limit.
   *
   * @param {Object} entry - The activity log entry.
   */


  commitNewActivity(entry) {
    const logs = this.getActivityLog(); // add new entry to end of log

    logs.push(entry); // remove oldest log if exceeding size limit

    if (logs.length > _enums.LOG_LIMIT) {
      logs.shift();
    }

    this.updateActivityLog(logs);
  }
  /**
   * Create new permissions history log entries, if any, and commit them.
   *
   * @param {Array<string>} requestedMethods - The method names corresponding to the requested permissions.
   * @param {string} origin - The origin of the permissions request.
   * @param {Array<IOcapLdCapability} result - The permissions request response.result.
   * @param {string} time - The time of the request, i.e. Date.now().
   * @param {boolean} isEthRequestAccounts - Whether the permissions request was 'eth_requestAccounts'.
   */


  logPermissionsHistory(requestedMethods, origin, result, time, isEthRequestAccounts) {
    let accounts, newEntries;

    if (isEthRequestAccounts) {
      accounts = result;
      const accountToTimeMap = getAccountToTimeMap(accounts, time);
      newEntries = {
        eth_accounts: {
          accounts: accountToTimeMap,
          lastApproved: time
        }
      };
    } else {
      // Records new "lastApproved" times for the granted permissions, if any.
      // Special handling for eth_accounts, in order to record the time the
      // accounts were last seen or approved by the origin.
      newEntries = result.map(perm => {
        if (perm.parentCapability === 'eth_accounts') {
          accounts = this.getAccountsFromPermission(perm);
        }

        return perm.parentCapability;
      }).reduce((acc, method) => {
        // all approved permissions will be included in the response,
        // not just the newly requested ones
        if (requestedMethods.includes(method)) {
          if (method === 'eth_accounts') {
            const accountToTimeMap = getAccountToTimeMap(accounts, time);
            acc[method] = {
              lastApproved: time,
              accounts: accountToTimeMap
            };
          } else {
            acc[method] = {
              lastApproved: time
            };
          }
        }

        return acc;
      }, {});
    }

    if (Object.keys(newEntries).length > 0) {
      this.commitNewHistory(origin, newEntries);
    }
  }
  /**
   * Commit new entries to the permissions history log.
   * Merges the history for the given origin, overwriting existing entries
   * with the same key (permission name).
   *
   * @param {string} origin - The requesting origin.
   * @param {Object} newEntries - The new entries to commit.
   */


  commitNewHistory(origin, newEntries) {
    // a simple merge updates most permissions
    const history = this.getHistory();

    const newOriginHistory = _objectSpread(_objectSpread({}, history[origin]), newEntries); // eth_accounts requires special handling, because of information
    // we store about the accounts


    const existingEthAccountsEntry = history[origin] && history[origin].eth_accounts;
    const newEthAccountsEntry = newEntries.eth_accounts;

    if (existingEthAccountsEntry && newEthAccountsEntry) {
      // we may intend to update just the accounts, not the permission
      // itself
      const lastApproved = newEthAccountsEntry.lastApproved || existingEthAccountsEntry.lastApproved; // merge old and new eth_accounts history entries

      newOriginHistory.eth_accounts = {
        lastApproved,
        accounts: _objectSpread(_objectSpread({}, existingEthAccountsEntry.accounts), newEthAccountsEntry.accounts)
      };
    }

    history[origin] = newOriginHistory;
    this.updateHistory(history);
  }
  /**
   * Get all requested methods from a permissions request.
   *
   * @param {Object} request - The request object.
   * @returns {Array<string>} The names of the requested permissions.
   */


  getRequestedMethods(request) {
    if (!request.params || !request.params[0] || typeof request.params[0] !== 'object' || Array.isArray(request.params[0])) {
      return null;
    }

    return Object.keys(request.params[0]);
  }
  /**
   * Get the permitted accounts from an eth_accounts permissions object.
   * Returns an empty array if the permission is not eth_accounts.
   *
   * @param {Object} perm - The permissions object.
   * @returns {Array<string>} The permitted accounts.
   */


  getAccountsFromPermission(perm) {
    if (perm.parentCapability !== 'eth_accounts' || !perm.caveats) {
      return [];
    }

    const accounts = new Set();

    for (const caveat of perm.caveats) {
      if (caveat.type === _permissions.CaveatTypes.restrictReturnedAccounts && Array.isArray(caveat.value)) {
        for (const value of caveat.value) {
          accounts.add(value);
        }
      }
    }

    return [...accounts];
  }

} // helper functions

/**
 * Get a map from account addresses to the given time.
 *
 * @param {Array<string>} accounts - An array of addresses.
 * @param {number} time - A time, e.g. Date.now().
 * @returns {Object} A string:number map of addresses to time.
 */


exports.PermissionLogController = PermissionLogController;

function getAccountToTimeMap(accounts, time) {
  return accounts.reduce((acc, account) => _objectSpread(_objectSpread({}, acc), {}, {
    [account]: time
  }), {});
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\permission-log.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\background-api.js", {"../../../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\index.browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\background-api.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPermissionBackgroundApiMethods = getPermissionBackgroundApiMethods;

var _nanoid = _interopRequireDefault(require("nanoid"));

var _permissions = require("../../../../shared/constants/permissions");

function getPermissionBackgroundApiMethods(permissionController) {
  return {
    addPermittedAccount: (origin, account) => {
      const existing = permissionController.getCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts);

      if (existing.value.includes(account)) {
        throw new Error(`eth_accounts permission for origin "${origin}" already permits account "${account}".`);
      }

      permissionController.updateCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts, [...existing.value, account]);
    },
    removePermittedAccount: (origin, account) => {
      const existing = permissionController.getCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts);

      if (!existing.value.includes(account)) {
        throw new Error(`eth_accounts permission for origin "${origin}" already does not permit account "${account}".`);
      }

      const remainingAccounts = existing.value.filter(existingAccount => existingAccount !== account);

      if (remainingAccounts.length === 0) {
        permissionController.revokePermission(origin, _permissions.RestrictedMethods.eth_accounts);
      } else {
        permissionController.updateCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts, remainingAccounts);
      }
    },
    requestAccountsPermissionWithId: async origin => {
      const id = (0, _nanoid.default)();
      permissionController.requestPermissions({
        origin
      }, {
        eth_accounts: {}
      }, {
        id
      });
      return id;
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\background-api.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\specifications.js", {"../../../../shared/constants/permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\permissions.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\permissions\specifications.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unrestrictedMethods = exports.getPermissionSpecifications = exports.getCaveatSpecifications = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _snapControllers = require("@metamask/snap-controllers");

var _permissions = require("../../../../shared/constants/permissions");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This file contains the specifications of the permissions and caveats
 * that are recognized by our permission system. See the PermissionController
 * README in @metamask/snap-controllers for details.
 */

/**
 * The "keys" of all of permissions recognized by the PermissionController.
 * Permission keys and names have distinct meanings in the permission system.
 */
const PermissionKeys = Object.freeze(_objectSpread({}, _permissions.RestrictedMethods));
/**
 * Factory functions for all caveat types recognized by the
 * PermissionController.
 */

const CaveatFactories = Object.freeze({
  [_permissions.CaveatTypes.restrictReturnedAccounts]: accounts => {
    return {
      type: _permissions.CaveatTypes.restrictReturnedAccounts,
      value: accounts
    };
  }
});
/**
 * A PreferencesController identity object.
 *
 * @typedef {Object} Identity
 * @property {string} address - The address of the identity.
 * @property {string} name - The name of the identity.
 * @property {number} [lastSelected] - Unix timestamp of when the identity was
 * last selected in the UI.
 */

/**
 * Gets the specifications for all caveats that will be recognized by the
 * PermissionController.
 *
 * @param {{
 *   getIdentities: () => Record<string, Identity>,
 * }} options - Options bag.
 */

const getCaveatSpecifications = ({
  getIdentities
}) => {
  return {
    [_permissions.CaveatTypes.restrictReturnedAccounts]: {
      type: _permissions.CaveatTypes.restrictReturnedAccounts,
      decorator: (method, caveat) => {
        return async args => {
          const result = await method(args);
          return result.filter(account => caveat.value.includes(account)).slice(0, 1);
        };
      },
      validator: (caveat, _origin, _target) => validateCaveatAccounts(caveat.value, getIdentities)
    }
  };
};
/**
 * Gets the specifications for all permissions that will be recognized by the
 * PermissionController.
 *
 * @param {{
 *   getAllAccounts: () => Promise<string[]>,
 *   getIdentities: () => Record<string, Identity>,
 * }} options - Options bag.
 * @param options.getAllAccounts - A function that returns all Ethereum accounts
 * in the current MetaMask instance.
 * @param options.getIdentities - A function that returns the
 * `PreferencesController` identity objects for all Ethereum accounts in the
 * @param options.captureKeyringTypesWithMissingIdentities - A function that
 * captures extra error information about the "Missing identity for address"
 * error.
 * current MetaMask instance.
 */


exports.getCaveatSpecifications = getCaveatSpecifications;

const getPermissionSpecifications = ({
  getAllAccounts,
  getIdentities,
  captureKeyringTypesWithMissingIdentities
}) => {
  return {
    [PermissionKeys.eth_accounts]: {
      permissionType: _snapControllers.PermissionType.RestrictedMethod,
      targetKey: PermissionKeys.eth_accounts,
      allowedCaveats: [_permissions.CaveatTypes.restrictReturnedAccounts],
      factory: (permissionOptions, requestData) => {
        if (Array.isArray(permissionOptions.caveats)) {
          throw new Error(`${PermissionKeys.eth_accounts} error: Received unexpected caveats. Any permitted caveats will be added automatically.`);
        } // This value will be further validated as part of the caveat.


        if (!requestData.approvedAccounts) {
          throw new Error(`${PermissionKeys.eth_accounts} error: No approved accounts specified.`);
        }

        return (0, _snapControllers.constructPermission)(_objectSpread(_objectSpread({}, permissionOptions), {}, {
          caveats: [CaveatFactories[_permissions.CaveatTypes.restrictReturnedAccounts](requestData.approvedAccounts)]
        }));
      },
      methodImplementation: async _args => {
        const accounts = await getAllAccounts();
        const identities = getIdentities();
        return accounts.sort((firstAddress, secondAddress) => {
          if (!identities[firstAddress]) {
            captureKeyringTypesWithMissingIdentities(identities, accounts);
            throw new Error(`Missing identity for address: "${firstAddress}".`);
          } else if (!identities[secondAddress]) {
            captureKeyringTypesWithMissingIdentities(identities, accounts);
            throw new Error(`Missing identity for address: "${secondAddress}".`);
          } else if (identities[firstAddress].lastSelected === identities[secondAddress].lastSelected) {
            return 0;
          } else if (identities[firstAddress].lastSelected === undefined) {
            return 1;
          } else if (identities[secondAddress].lastSelected === undefined) {
            return -1;
          }

          return identities[secondAddress].lastSelected - identities[firstAddress].lastSelected;
        });
      },
      validator: (permission, _origin, _target) => {
        const {
          caveats
        } = permission;

        if (!caveats || caveats.length !== 1 || caveats[0].type !== _permissions.CaveatTypes.restrictReturnedAccounts) {
          throw new Error(`${PermissionKeys.eth_accounts} error: Invalid caveats. There must be a single caveat of type "${_permissions.CaveatTypes.restrictReturnedAccounts}".`);
        }
      }
    }
  };
};
/**
 * Validates the accounts associated with a caveat. In essence, ensures that
 * the accounts value is an array of non-empty strings, and that each string
 * corresponds to a PreferencesController identity.
 *
 * @param {string[]} accounts - The accounts associated with the caveat.
 * @param {() => Record<string, Identity>} getIdentities - Gets all
 * PreferencesController identities.
 */


exports.getPermissionSpecifications = getPermissionSpecifications;

function validateCaveatAccounts(accounts, getIdentities) {
  if (!Array.isArray(accounts) || accounts.length === 0) {
    throw new Error(`${PermissionKeys.eth_accounts} error: Expected non-empty array of Ethereum addresses.`);
  }

  const identities = getIdentities();
  accounts.forEach(address => {
    if (!address || typeof address !== 'string') {
      throw new Error(`${PermissionKeys.eth_accounts} error: Expected an array of Ethereum addresses. Received: "${address}".`);
    }

    if (!identities[address]) {
      throw new Error(`${PermissionKeys.eth_accounts} error: Received unrecognized address: "${address}".`);
    }
  });
}
/**
 * All unrestricted methods recognized by the PermissionController.
 * Unrestricted methods are ignored by the permission system, but every
 * JSON-RPC request seen by the permission system must correspond to a
 * restricted or unrestricted method, or the request will be rejected with a
 * "method not found" error.
 */


const unrestrictedMethods = Object.freeze(['eth_blockNumber', 'eth_call', 'eth_chainId', 'eth_coinbase', 'eth_decrypt', 'eth_estimateGas', 'eth_feeHistory', 'eth_gasPrice', 'eth_getBalance', 'eth_getBlockByHash', 'eth_getBlockByNumber', 'eth_getBlockTransactionCountByHash', 'eth_getBlockTransactionCountByNumber', 'eth_getCode', 'eth_getEncryptionPublicKey', 'eth_getFilterChanges', 'eth_getFilterLogs', 'eth_getLogs', 'eth_getProof', 'eth_getStorageAt', 'eth_getTransactionByBlockHashAndIndex', 'eth_getTransactionByBlockNumberAndIndex', 'eth_getTransactionByHash', 'eth_getTransactionCount', 'eth_getTransactionReceipt', 'eth_getUncleByBlockHashAndIndex', 'eth_getUncleByBlockNumberAndIndex', 'eth_getUncleCountByBlockHash', 'eth_getUncleCountByBlockNumber', 'eth_getWork', 'eth_hashrate', 'eth_mining', 'eth_newBlockFilter', 'eth_newFilter', 'eth_newPendingTransactionFilter', 'eth_protocolVersion', 'eth_sendRawTransaction', 'eth_sendTransaction', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v1', 'eth_signTypedData_v3', 'eth_signTypedData_v4', 'eth_submitHashrate', 'eth_submitWork', 'eth_syncing', 'eth_uninstallFilter', 'metamask_getProviderState', 'metamask_watchAsset', 'net_listening', 'net_peerCount', 'net_version', 'personal_ecRecover', 'personal_sign', 'wallet_watchAsset', 'web3_clientVersion', 'web3_sha3']);
exports.unrestrictedMethods = unrestrictedMethods;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\permissions\\specifications.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\cleanErrorStack.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\cleanErrorStack.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanErrorStack;

/**
 * Returns error without stack trace for better UI display
 *
 * @param {Error} err - error
 * @returns {Error} Error with clean stack trace.
 */
function cleanErrorStack(err) {
  let {
    name
  } = err;
  name = name === undefined ? 'Error' : String(name);
  let msg = err.message;
  msg = msg === undefined ? '' : String(msg);

  if (name === '') {
    err.stack = err.message;
  } else if (msg === '') {
    err.stack = err.name;
  } else if (!err.stack) {
    err.stack = `${err.name}: ${err.message}`;
  }

  return err;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\cleanErrorStack.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nonce-tracker\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","await-semaphore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\await-semaphore\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\nonce-tracker\index.js
      return function (require, module, exports) {
const EthQuery = require('ethjs-query')
const assert = require('assert')
const Mutex = require('await-semaphore').Mutex
/**
  @param opts {Object}
    @param {Object} opts.provider a ethereum provider
    @param {Function} opts.getPendingTransactions a function that returns an array of txMeta
    whosee status is `submitted`
    @param {Function} opts.getConfirmedTransactions a function that returns an array of txMeta
    whose status is `confirmed`
  @class
*/
class NonceTracker {

  constructor ({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }) {
    this.provider = provider
    this.blockTracker = blockTracker
    this.ethQuery = new EthQuery(provider)
    this.getPendingTransactions = getPendingTransactions
    this.getConfirmedTransactions = getConfirmedTransactions
    this.lockMap = {}
  }

  /**
    @returns {Promise<Object>} with the key releaseLock (the gloabl mutex)
  */
  async getGlobalLock () {
    const globalMutex = this._lookupMutex('global')
    // await global mutex free
    const releaseLock = await globalMutex.acquire()
    return { releaseLock }
  }

  /**
   * @typedef NonceDetails
   * @property {number} highestLocallyConfirmed - A hex string of the highest nonce on a confirmed transaction.
   * @property {number} nextNetworkNonce - The next nonce suggested by the eth_getTransactionCount method.
   * @property {number} highestSuggested - The maximum between the other two, the number returned.
   */

  /**
  this will return an object with the `nextNonce` `nonceDetails`, and the releaseLock
  Note: releaseLock must be called after adding a signed tx to pending transactions (or discarding).

  @param address {string} the hex string for the address whose nonce we are calculating
  @returns {Promise<NonceDetails>}
  */
  async getNonceLock (address) {
    // await global mutex free
    await this._globalMutexFree()
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address)
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {}
      const networkNonceResult = await this._getNetworkNextNonce(address)
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address)
      const nextNetworkNonce = networkNonceResult.nonce
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed)

      const pendingTxs = this.getPendingTransactions(address)
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested) || 0

      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce,
      }
      nonceDetails.local = localNonceResult
      nonceDetails.network = networkNonceResult

      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce)
      assert(Number.isInteger(nextNonce), `nonce-tracker - nextNonce is not an integer - got: (${typeof nextNonce}) "${nextNonce}"`)

      // return nonce and release cb
      return { nextNonce, nonceDetails, releaseLock }
    } catch (err) {
      // release lock if we encounter an error
      releaseLock()
      throw err
    }
  }

  async _globalMutexFree () {
    const globalMutex = this._lookupMutex('global')
    const releaseLock = await globalMutex.acquire()
    releaseLock()
  }

  async _takeMutex (lockId) {
    const mutex = this._lookupMutex(lockId)
    const releaseLock = await mutex.acquire()
    return releaseLock
  }

  _lookupMutex (lockId) {
    let mutex = this.lockMap[lockId]
    if (!mutex) {
      mutex = new Mutex()
      this.lockMap[lockId] = mutex
    }
    return mutex
  }

  async _getNetworkNextNonce (address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const blockNumber = await this.blockTracker.getLatestBlock()
    const baseCountBN = await this.ethQuery.getTransactionCount(address, blockNumber)
    const baseCount = baseCountBN.toNumber()
    assert(Number.isInteger(baseCount), `nonce-tracker - baseCount is not an integer - got: (${typeof baseCount}) "${baseCount}"`)
    const nonceDetails = { blockNumber, baseCount }
    return { name: 'network', nonce: baseCount, details: nonceDetails }
  }

  _getHighestLocallyConfirmed (address) {
    const confirmedTransactions = this.getConfirmedTransactions(address)
    const highest = this._getHighestNonce(confirmedTransactions)
    return Number.isInteger(highest) ? highest + 1 : 0
  }

  _getHighestNonce (txList) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })
    const highestNonce = Math.max.apply(null, nonces)
    return highestNonce
  }

  /**
    @typedef {object} highestContinuousFrom
    @property {string} - name the name for how the nonce was calculated based on the data used
    @property {number} - nonce the next suggested nonce
    @property {object} - details the provided starting nonce that was used (for debugging)
  */
  /**
    @param txList {array} - list of txMeta's
    @param startPoint {number} - the highest known locally confirmed nonce
    @returns {highestContinuousFrom}
  */
  _getHighestContinuousFrom (txList, startPoint) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })

    let highest = startPoint
    while (nonces.includes(highest)) {
      highest++
    }

    return { name: 'local', nonce: highest, details: { startPoint, highest } }
  }

}

module.exports = NonceTracker

      };
    };
  }
}, {package:"nonce-tracker",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nonce-tracker\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\util.js", {"../../../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../../../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","../../../../../shared/modules/transaction.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\transaction.utils.js","../../../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\lib\util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFinalStates = getFinalStates;
exports.normalizeAndValidateTxParams = normalizeAndValidateTxParams;
exports.normalizeTxParams = normalizeTxParams;
exports.normalizeTxReceiptGasUsed = normalizeTxReceiptGasUsed;
exports.validateConfirmedExternalTransaction = void 0;
exports.validateFrom = validateFrom;
exports.validateRecipient = validateRecipient;
exports.validateTxParams = validateTxParams;

var _ethRpcErrors = require("eth-rpc-errors");

var _util = require("../../../lib/util");

var _transaction = require("../../../../../shared/constants/transaction");

var _transaction2 = require("../../../../../shared/modules/transaction.utils");

var _hexstringUtils = require("../../../../../shared/modules/hexstring-utils");

const normalizers = {
  from: _util.addHexPrefix,
  to: (to, lowerCase) => lowerCase ? (0, _util.addHexPrefix)(to).toLowerCase() : (0, _util.addHexPrefix)(to),
  nonce: _util.addHexPrefix,
  value: _util.addHexPrefix,
  data: _util.addHexPrefix,
  gas: _util.addHexPrefix,
  gasPrice: _util.addHexPrefix,
  maxFeePerGas: _util.addHexPrefix,
  maxPriorityFeePerGas: _util.addHexPrefix,
  type: _util.addHexPrefix,
  estimateSuggested: estimate => estimate,
  estimateUsed: estimate => estimate
};

function normalizeAndValidateTxParams(txParams, lowerCase = true) {
  const normalizedTxParams = normalizeTxParams(txParams, lowerCase);
  validateTxParams(normalizedTxParams);
  return normalizedTxParams;
}
/**
 * Normalizes the given txParams
 *
 * @param {Object} txParams - The transaction params
 * @param {boolean} [lowerCase] - Whether to lowercase the 'to' address.
 * Default: true
 * @returns {Object} the normalized tx params
 */


function normalizeTxParams(txParams, lowerCase = true) {
  // apply only keys in the normalizers
  const normalizedTxParams = {};

  for (const key in normalizers) {
    if (txParams[key]) {
      normalizedTxParams[key] = normalizers[key](txParams[key], lowerCase);
    }
  }

  return normalizedTxParams;
}
/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 *
 * @param {Object} txParams - the transaction parameters object
 * @param {string} fieldBeingValidated - the current field being validated
 * @param {string} mutuallyExclusiveField - the field to ensure is not provided
 * @throws {ethErrors.rpc.invalidParams} Throws if mutuallyExclusiveField is
 *  present in txParams.
 */


function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
  if (typeof txParams[mutuallyExclusiveField] !== 'undefined') {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
  }
}
/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 *
 * @param {Object} txParams - the transaction parameters object
 * @param {string} field - the current field being validated
 * @throws {ethErrors.rpc.invalidParams} Throws if field is not a string
 */


function ensureFieldIsString(txParams, field) {
  if (typeof txParams[field] !== 'string') {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
  }
}
/**
 * Ensures that the provided txParams has the proper 'type' specified for the
 * given field, if it is provided. If types do not match throws an
 * invalidParams error.
 *
 * @param {Object} txParams - the transaction parameters object
 * @param {'gasPrice' | 'maxFeePerGas' | 'maxPriorityFeePerGas'} field - the
 *  current field being validated
 * @throws {ethErrors.rpc.invalidParams} Throws if type does not match the
 *  expectations for provided field.
 */


function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
  switch (field) {
    case 'maxFeePerGas':
    case 'maxPriorityFeePerGas':
      if (txParams.type && txParams.type !== _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but including maxFeePerGas and maxPriorityFeePerGas requires type: "${_transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}"`);
      }

      break;

    case 'gasPrice':
    default:
      if (txParams.type && txParams.type === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas`);
      }

  }
}
/**
 * Validates the given tx parameters
 *
 * @param {Object} txParams - the tx params
 * @param {boolean} eip1559Compatibility - whether or not the current network supports EIP-1559 transactions
 * @throws {Error} if the tx params contains invalid fields
 */


function validateTxParams(txParams, eip1559Compatibility = true) {
  if (!txParams || typeof txParams !== 'object' || Array.isArray(txParams)) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: must be an object.');
  }

  if (!txParams.to && !txParams.data) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: must specify "data" for contract deployments, or "to" (and optionally "data") for all other types of transactions.');
  }

  if ((0, _transaction2.isEIP1559Transaction)({
    txParams
  }) && !eip1559Compatibility) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559');
  }

  Object.entries(txParams).forEach(([key, value]) => {
    // validate types
    switch (key) {
      case 'from':
        validateFrom(txParams);
        break;

      case 'to':
        validateRecipient(txParams);
        break;

      case 'gasPrice':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'gasPrice');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'gasPrice', 'maxPriorityFeePerGas');
        ensureFieldIsString(txParams, 'gasPrice');
        break;

      case 'maxFeePerGas':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxFeePerGas', 'gasPrice');
        ensureFieldIsString(txParams, 'maxFeePerGas');
        break;

      case 'maxPriorityFeePerGas':
        ensureProperTransactionEnvelopeTypeProvided(txParams, 'maxPriorityFeePerGas');
        ensureMutuallyExclusiveFieldsNotProvided(txParams, 'maxPriorityFeePerGas', 'gasPrice');
        ensureFieldIsString(txParams, 'maxPriorityFeePerGas');
        break;

      case 'value':
        ensureFieldIsString(txParams, 'value');

        if (value.toString().includes('-')) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
        }

        if (value.toString().includes('.')) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value of "${value}": number must be in wei.`);
        }

        if (!value.match(/^0x[a-fA-F0-9]+$/u)) {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction value of "${value}": not a valid hex string.`);
        }

        break;

      case 'chainId':
        if (typeof value !== 'number' && typeof value !== 'string') {
          throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);
        }

        break;

      default:
        ensureFieldIsString(txParams, key);
    }
  });
}
/**
 * Validates the {@code from} field in the given tx params
 *
 * @param {Object} txParams
 * @throws {Error} if the from address isn't valid
 */


function validateFrom(txParams) {
  if (!(typeof txParams.from === 'string')) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams(`Invalid "from" address "${txParams.from}": not a string.`);
  }

  if (!(0, _hexstringUtils.isValidHexAddress)(txParams.from, {
    allowNonPrefixed: false
  })) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "from" address.');
  }
}
/**
 * Validates the {@code to} field in the given tx params
 *
 * @param {Object} txParams - the tx params
 * @returns {Object} the tx params
 * @throws {Error} if the recipient is invalid OR there isn't tx data
 */


function validateRecipient(txParams) {
  if (txParams.to === '0x' || txParams.to === null) {
    if (txParams.data) {
      delete txParams.to;
    } else {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "to" address.');
    }
  } else if (txParams.to !== undefined && !(0, _hexstringUtils.isValidHexAddress)(txParams.to, {
    allowNonPrefixed: false
  })) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('Invalid "to" address.');
  }

  return txParams;
}

const validateConfirmedExternalTransaction = ({
  txMeta,
  pendingTransactions,
  confirmedTransactions
} = {}) => {
  if (!txMeta || !txMeta.txParams) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('"txMeta" or "txMeta.txParams" is missing');
  }

  if (txMeta.status !== _transaction.TRANSACTION_STATUSES.CONFIRMED) {
    throw _ethRpcErrors.ethErrors.rpc.invalidParams('External transaction status should be "confirmed"');
  }

  const externalTxNonce = txMeta.txParams.nonce;

  if (pendingTransactions && pendingTransactions.length > 0) {
    const foundPendingTxByNonce = pendingTransactions.find(el => {
      var _el$txParams;

      return ((_el$txParams = el.txParams) === null || _el$txParams === void 0 ? void 0 : _el$txParams.nonce) === externalTxNonce;
    });

    if (foundPendingTxByNonce) {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('External transaction nonce should not be in pending txs');
    }
  }

  if (confirmedTransactions && confirmedTransactions.length > 0) {
    const foundConfirmedTxByNonce = confirmedTransactions.find(el => {
      var _el$txParams2;

      return ((_el$txParams2 = el.txParams) === null || _el$txParams2 === void 0 ? void 0 : _el$txParams2.nonce) === externalTxNonce;
    });

    if (foundConfirmedTxByNonce) {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('External transaction nonce should not be in confirmed txs');
    }
  }
};
/**
 * Returns a list of final states
 *
 * @returns {string[]} the states that can be considered final states
 */


exports.validateConfirmedExternalTransaction = validateConfirmedExternalTransaction;

function getFinalStates() {
  return [_transaction.TRANSACTION_STATUSES.REJECTED, // the user has responded no!
  _transaction.TRANSACTION_STATUSES.CONFIRMED, // the tx has been included in a block.
  _transaction.TRANSACTION_STATUSES.FAILED, // the tx failed for some reason, included on tx data.
  _transaction.TRANSACTION_STATUSES.DROPPED // the tx nonce was already used
  ];
}
/**
 * Normalizes tx receipt gas used to be a hexadecimal string.
 * It seems that sometimes the numerical values being returned from
 * this.query.getTransactionReceipt are BN instances and not strings.
 *
 * @param {string or BN instance} gasUsed
 * @returns normalized gas used as hexadecimal string
 */


function normalizeTxReceiptGasUsed(gasUsed) {
  return typeof gasUsed === 'string' ? gasUsed : gasUsed.toString(16);
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-state-manager.js", {"../../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../../../shared/modules/random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\random-id.js","../../../../shared/modules/transaction.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\transaction.utils.js","../../metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","./lib/tx-state-history-helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","./lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\lib\\util.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\tx-state-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../../shared/modules/random-id"));

var _transaction = require("../../../../shared/constants/transaction");

var _metamaskController = require("../../metamask-controller");

var _transaction2 = require("../../../../shared/modules/transaction.utils");

var _txStateHistoryHelpers = require("./lib/tx-state-history-helpers");

var _util = require("./lib/util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * TransactionStatuses reimported from the shared transaction constants file
 *
 * @typedef {__import__(
 *  '../../../../shared/constants/transaction'
 * ).TransactionStatusString} TransactionStatusString
 */

/**
 * @typedef {__import__('../../../../shared/constants/transaction').TxParams} TxParams
 */

/**
 * @typedef {__import__(
 *  '../../../../shared/constants/transaction'
 * ).TransactionMeta} TransactionMeta
 */

/**
 * @typedef {Object} TransactionState
 * @property {Record<string, TransactionMeta>} transactions - TransactionMeta
 *  keyed by the transaction's id.
 */

/**
 * TransactionStateManager is responsible for the state of a transaction and
 * storing the transaction. It also has some convenience methods for finding
 * subsets of transactions.
 *
 * @param {Object} opts
 * @param {TransactionState} [opts.initState={ transactions: {} }] - initial
 *  transactions list keyed by id
 * @param {number} [opts.txHistoryLimit] - limit for how many finished
 *  transactions can hang around in state
 * @param {Function} opts.getNetwork - return network number
 */
class TransactionStateManager extends _safeEventEmitter.default {
  constructor({
    initState,
    txHistoryLimit,
    getNetwork,
    getCurrentChainId
  }) {
    super();
    this.store = new _obsStore.ObservableStore(_objectSpread({
      transactions: {}
    }, initState));
    this.txHistoryLimit = txHistoryLimit;
    this.getNetwork = getNetwork;
    this.getCurrentChainId = getCurrentChainId;
  }
  /**
   * Generates a TransactionMeta object consisting of the fields required for
   * use throughout the extension. The argument here will override everything
   * in the resulting transaction meta.
   *
   * TODO: Don't overwrite everything?
   *
   * @param {Partial<TransactionMeta>} opts - the object to use when
   *  overwriting default keys of the TransactionMeta
   * @returns {TransactionMeta} the default txMeta object
   */


  generateTxMeta(opts = {}) {
    var _opts$txParams;

    const netId = this.getNetwork();
    const chainId = this.getCurrentChainId();

    if (netId === 'loading') {
      throw new Error('MetaMask is having trouble connecting to the network');
    }

    let dappSuggestedGasFees = null; // If we are dealing with a transaction suggested by a dapp and not
    // an internally created metamask transaction, we need to keep record of
    // the originally submitted gasParams.

    if (opts.txParams && typeof opts.origin === 'string' && opts.origin !== 'metamask') {
      if (typeof opts.txParams.gasPrice !== 'undefined') {
        dappSuggestedGasFees = {
          gasPrice: opts.txParams.gasPrice
        };
      } else if (typeof opts.txParams.maxFeePerGas !== 'undefined' || typeof opts.txParams.maxPriorityFeePerGas !== 'undefined') {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.txParams.maxPriorityFeePerGas,
          maxFeePerGas: opts.txParams.maxFeePerGas
        };
      }

      if (typeof opts.txParams.gas !== 'undefined') {
        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {
          gas: opts.txParams.gas
        });
      }
    }

    return _objectSpread({
      id: (0, _randomId.default)(),
      time: new Date().getTime(),
      status: _transaction.TRANSACTION_STATUSES.UNAPPROVED,
      metamaskNetworkId: netId,
      originalGasEstimate: (_opts$txParams = opts.txParams) === null || _opts$txParams === void 0 ? void 0 : _opts$txParams.gas,
      userEditedGasLimit: false,
      chainId,
      loadingDefaults: true,
      dappSuggestedGasFees
    }, opts);
  }
  /**
   * Get an object containing all unapproved transactions for the current
   * network. This is the only transaction fetching method that returns an
   * object, so it doesn't use getTransactions like everything else.
   *
   * @returns {Record<string, TransactionMeta>} Unapproved transactions keyed
   *  by id
   */


  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork();
    return (0, _lodash.pickBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network));
  }
  /**
   * Get all approved transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getApprovedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.APPROVED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all pending transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getPendingTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.SUBMITTED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all confirmed transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.CONFIRMED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Adds the txMeta to the list of transactions in the store.
   * if the list is over txHistoryLimit it will remove a transaction that
   * is in its final state.
   * it will also add the key `history` to the txMeta with the snap shot of
   * the original object
   *
   * @param {TransactionMeta} txMeta - The TransactionMeta object to add.
   * @returns {TransactionMeta} The same TransactionMeta, but with validated
   *  txParams and transaction history.
   */


  addTransaction(txMeta) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    }

    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    }); // initialize history

    txMeta.history = []; // capture initial snapshot of txMeta for history

    const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this; // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // TODO: we are already limiting what we send to the UI, and in the future
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.

    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce,
        from
      } = tx.txParams;
      const {
        chainId,
        metamaskNetworkId,
        status
      } = tx;
      const key = `${nonce}-${chainId !== null && chainId !== void 0 ? chainId : metamaskNetworkId}-${from}`;

      if (nonceNetworkSet.has(key)) {
        return false;
      } else if (nonceNetworkSet.size < txHistoryLimit - 1 || (0, _util.getFinalStates)().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }

      return true;
    }).map(tx => tx.id);

    this._deleteTransactions(txsToDelete);

    this._addTransactionsToState([txMeta]);

    return txMeta;
  }

  addExternalTransaction(txMeta) {
    var _txMeta$txParams;

    const fromAddress = txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txParams = txMeta.txParams) === null || _txMeta$txParams === void 0 ? void 0 : _txMeta$txParams.from;
    const confirmedTransactions = this.getConfirmedTransactions(fromAddress);
    const pendingTransactions = this.getPendingTransactions(fromAddress);
    (0, _util.validateConfirmedExternalTransaction)({
      txMeta,
      pendingTransactions,
      confirmedTransactions
    });

    this._addTransactionsToState([txMeta]);

    return txMeta;
  }
  /**
   * @param {number} txId
   * @returns {TransactionMeta} the txMeta who matches the given id if none found
   * for the network returns undefined
   */


  getTransaction(txId) {
    const {
      transactions
    } = this.store.getState();
    return transactions[txId];
  }
  /**
   * updates the txMeta in the list and adds a history entry
   *
   * @param {Object} txMeta - the txMeta to update
   * @param {string} [note] - a note about the update for history
   */


  updateTransaction(txMeta, note) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    } // create txMeta snapshot for history


    const currentState = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta); // recover previous tx state obj

    const previousState = (0, _txStateHistoryHelpers.replayHistory)(txMeta.history); // generate history entry and add to history

    const entry = (0, _txStateHistoryHelpers.generateHistoryEntry)(previousState, currentState, note);

    if (entry.length) {
      txMeta.history.push(entry);
    } // commit txMeta to state


    const txId = txMeta.id;
    this.store.updateState({
      transactions: _objectSpread(_objectSpread({}, this.store.getState().transactions), {}, {
        [txId]: txMeta
      })
    });
  }
  /**
   * SearchCriteria can search in any key in TxParams or the base
   * TransactionMeta. This type represents any key on either of those two
   * types.
   *
   * @typedef {TxParams[keyof TxParams] | TransactionMeta[keyof TransactionMeta]} SearchableKeys
   */

  /**
   * Predicates can either be strict values, which is shorthand for using
   * strict equality, or a method that receives he value of the specified key
   * and returns a boolean.
   *
   * @typedef {(v: unknown) => boolean | unknown} FilterPredicate
   */

  /**
   * Retrieve a list of transactions from state. By default this will return
   * the full list of Transactions for the currently selected chain/network.
   * Additional options can be provided to change what is included in the final
   * list.
   *
   * @param opts - options to change filter behavior
   * @param {Record<SearchableKeys, FilterPredicate>} [opts.searchCriteria] -
   *  an object with keys that match keys in TransactionMeta or TxParams, and
   *  values that are predicates. Predicates can either be strict values,
   *  which is shorthand for using strict equality, or a method that receives
   *  the value of the specified key and returns a boolean. The transaction
   *  list will be filtered to only those items that the predicate returns
   *  truthy for. **HINT**: `err: undefined` is like looking for a tx with no
   *  err. so you can also search txs that don't have something as well by
   *  setting the value as undefined.
   * @param {TransactionMeta[]} [opts.initialList] - If provided the filtering
   *  will occur on the provided list. By default this will be the full list
   *  from state sorted by time ASC.
   * @param {boolean} [opts.filterToCurrentNetwork] - Filter transaction
   *  list to only those that occurred on the current chain or network.
   *  Defaults to true.
   * @param {number} [opts.limit] - limit the number of transactions returned
   *  to N unique nonces.
   * @returns {TransactionMeta[]} The TransactionMeta objects that all provided
   *  predicates return truthy for.
   */


  getTransactions({
    searchCriteria = {},
    initialList,
    filterToCurrentNetwork = true,
    limit
  } = {}) {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork(); // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.

    const predicateMethods = (0, _lodash.mapValues)(searchCriteria, predicate => {
      return typeof predicate === 'function' ? predicate : v => v === predicate;
    }); // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.

    const transactionsToFilter = initialList ? (0, _lodash.keyBy)(initialList, 'id') : this.store.getState().transactions; // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.

    const filteredTransactions = (0, _lodash.sortBy)((0, _lodash.pickBy)(transactionsToFilter, transaction => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      if (filterToCurrentNetwork && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network) === false) {
        return false;
      } // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria


      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in transaction.txParams) {
          if (predicate(transaction.txParams[key]) === false) {
            return false;
          }
        } else if (predicate(transaction[key]) === false) {
          return false;
        }
      }

      return true;
    }), 'time');

    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = []; // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.

      for (let i = filteredTransactions.length - 1; i > -1; i--) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.txParams;

        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        } // Push transaction into the beginning of our array to ensure the
        // original order is preserved.


        txs.unshift(txMeta);
      }

      return txs;
    }

    return filteredTransactions;
  }
  /**
   * Update status of the TransactionMeta with provided id to 'rejected'.
   * After setting the status, the TransactionMeta is deleted from state.
   *
   * TODO: Should we show historically rejected transactions somewhere in the
   * UI? Seems like it could be valuable for information purposes. Of course
   * only after limit issues are reduced.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusRejected(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.REJECTED);

    this._deleteTransaction(txId);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'unapproved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusUnapproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.UNAPPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'approved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusApproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.APPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'signed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSigned(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SIGNED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'submitted'
   * and sets the 'submittedTime' property with the current Unix epoch time.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSubmitted(txId) {
    const txMeta = this.getTransaction(txId);
    txMeta.submittedTime = new Date().getTime();
    this.updateTransaction(txMeta, 'txStateManager - add submitted time stamp');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SUBMITTED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'confirmed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusConfirmed(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.CONFIRMED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'dropped'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusDropped(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.DROPPED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'failed' and put
   * the error on the TransactionMeta object.
   *
   * @param {number} txId - the target TransactionMeta's Id
   * @param {Error} err - error object
   */


  setTxStatusFailed(txId, err) {
    var _error$message;

    const error = err || new Error('Internal metamask failure');
    const txMeta = this.getTransaction(txId);
    txMeta.err = {
      message: ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.toString()) || error.toString(),
      rpc: error.value,
      stack: error.stack
    };
    this.updateTransaction(txMeta, 'transactions:tx-state-manager#fail - add error');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.FAILED);
  }
  /**
   * Removes all transactions for the given address on the current network,
   * preferring chainId for comparison over networkId.
   *
   * @param {string} address - hex string of the from address on the txParams
   *  to remove
   */


  wipeTransactions(address) {
    // network only tx
    const {
      transactions
    } = this.store.getState();
    const network = this.getNetwork();
    const chainId = this.getCurrentChainId(); // Update state

    this.store.updateState({
      transactions: (0, _lodash.omitBy)(transactions, transaction => transaction.txParams.from === address && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network))
    });
  }
  /**
   * Filters out the unapproved transactions from state
   */


  clearUnapprovedTxs() {
    this.store.updateState({
      transactions: (0, _lodash.omitBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED)
    });
  } //
  //           PRIVATE METHODS
  //

  /**
   * Updates a transaction's status in state, and then emits events that are
   * subscribed to elsewhere. See below for best guesses on where and how these
   * events are received.
   *
   * @param {number} txId - the TransactionMeta Id
   * @param {TransactionStatusString} status - the status to set on the
   *  TransactionMeta
   * @fires txMeta.id:txMeta.status - every time a transaction's status changes
   *  we emit the change passing along the id. This does not appear to be used
   *  outside of this file, which only listens to this to unsubscribe listeners
   *  of :rejected and :signed statuses when the inverse status changes. Likely
   *  safe to drop.
   * @fires tx:status-update - every time a transaction's status changes we
   *  emit this event and pass txId and status. This event is subscribed to in
   *  the TransactionController and re-broadcast by the TransactionController.
   *  It is used internally within the TransactionController to try and update
   *  pending transactions on each new block (from blockTracker). It's also
   *  subscribed to in metamask-controller to display a browser notification on
   *  confirmed or failed transactions.
   * @fires txMeta.id:finished - When a transaction moves to a finished state
   *  this event is emitted, which is used in the TransactionController to pass
   *  along details of the transaction to the dapp that suggested them. This
   *  pattern is replicated across all of the message managers and can likely
   *  be supplemented or replaced by the ApprovalController.
   * @fires updateBadge - When the number of transactions changes in state,
   *  the badge in the browser extension bar should be updated to reflect the
   *  number of pending transactions. This particular emit doesn't appear to
   *  bubble up anywhere that is actually used. TransactionController emits
   *  this *anytime the state changes*, so this is probably superfluous.
   */


  _setTransactionStatus(txId, status) {
    const txMeta = this.getTransaction(txId);

    if (!txMeta) {
      return;
    }

    txMeta.status = status;

    try {
      this.updateTransaction(txMeta, `txStateManager: setting status to ${status}`);
      this.emit(`${txMeta.id}:${status}`, txId);
      this.emit(`tx:status-update`, txId, status);

      if ([_transaction.TRANSACTION_STATUSES.SUBMITTED, _transaction.TRANSACTION_STATUSES.REJECTED, _transaction.TRANSACTION_STATUSES.FAILED].includes(status)) {
        this.emit(`${txMeta.id}:finished`, txMeta);
      }

      this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
    } catch (error) {
      _loglevel.default.error(error);
    }
  }
  /**
   * Adds one or more transactions into state. This is not intended for
   * external use.
   *
   * @private
   * @param {TransactionMeta[]} transactions - the list of transactions to save
   */


  _addTransactionsToState(transactions) {
    this.store.updateState({
      transactions: transactions.reduce((result, newTx) => {
        result[newTx.id] = newTx;
        return result;
      }, this.store.getState().transactions)
    });
  }
  /**
   * removes one transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number} targetTransactionId - the transaction to delete
   */


  _deleteTransaction(targetTransactionId) {
    const {
      transactions
    } = this.store.getState();
    delete transactions[targetTransactionId];
    this.store.updateState({
      transactions
    });
  }
  /**
   * removes multiple transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number[]} targetTransactionIds - the transactions to delete
   */


  _deleteTransactions(targetTransactionIds) {
    const {
      transactions
    } = this.store.getState();
    targetTransactionIds.forEach(transactionId => {
      delete transactions[transactionId];
    });
    this.store.updateState({
      transactions
    });
  }

}

exports.default = TransactionStateManager;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-state-manager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-gas-utils.js", {"../../lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\tx-gas-utils.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethereumjsUtil = require("ethereumjs-util");

var _lodash = require("lodash");

var _util = require("../../lib/util");

/**
 * Result of gas analysis, including either a gas estimate for a successful analysis, or
 * debug information for a failed analysis.
 *
 * @typedef {Object} GasAnalysisResult
 * @property {string} blockGasLimit - The gas limit of the block used for the analysis
 * @property {string} estimatedGasHex - The estimated gas, in hexadecimal
 * @property {Object} simulationFails - Debug information about why an analysis failed
 */

/**
 * tx-gas-utils are gas utility methods for Transaction manager
 * its passed ethquery
 * and used to do things like calculate gas of a tx.
 *
 * @param {Object} provider - A network provider.
 */
class TxGasUtil {
  constructor(provider) {
    this.query = new _ethjsQuery.default(provider);
  }
  /**
   * @param {Object} txMeta - the txMeta object
   * @returns {GasAnalysisResult} The result of the gas analysis
   */


  async analyzeGasUsage(txMeta) {
    const block = await this.query.getBlockByNumber('latest', false); // fallback to block gasLimit

    const blockGasLimitBN = (0, _util.hexToBn)(block.gasLimit);
    const saferGasLimitBN = (0, _util.BnMultiplyByFraction)(blockGasLimitBN, 19, 20);
    let estimatedGasHex = (0, _util.bnToHex)(saferGasLimitBN);
    let simulationFails;

    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      _loglevel.default.warn(error);

      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.number,
          blockGasLimit: block.gasLimit
        }
      };
    }

    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }
  /**
   * Estimates the tx's gas usage
   *
   * @param {Object} txMeta - the txMeta object
   * @returns {string} the estimated gas limit as a hex string
   */


  async estimateTxGas(txMeta) {
    const txParams = (0, _lodash.cloneDeep)(txMeta.txParams); // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.

    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas; // estimate tx gas requirements

    return await this.query.estimateGas(txParams);
  }
  /**
   * Adds a gas buffer with out exceeding the block gas limit
   *
   * @param {string} initialGasLimitHex - the initial gas limit to add the buffer too
   * @param {string} blockGasLimitHex - the block gas limit
   * @param multiplier
   * @returns {string} the buffered gas limit as a hex string
   */


  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = (0, _util.hexToBn)(initialGasLimitHex);
    const blockGasLimitBn = (0, _util.hexToBn)(blockGasLimitHex);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier); // if initialGasLimit is above blockGasLimit, dont modify it

    if (initialGasLimitBn.gt(upperGasLimitBn)) {
      return (0, _util.bnToHex)(initialGasLimitBn);
    } // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit


    if (bufferedGasLimitBn.lt(upperGasLimitBn)) {
      return (0, _util.bnToHex)(bufferedGasLimitBn);
    } // otherwise use blockGasLimit


    return (0, _util.bnToHex)(upperGasLimitBn);
  }

  async getBufferedGasLimit(txMeta, multiplier) {
    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.analyzeGasUsage(txMeta); // add additional gas buffer to our estimation for safety

    const gasLimit = this.addGasBuffer((0, _ethereumjsUtil.addHexPrefix)(estimatedGasHex), blockGasLimit, multiplier);
    return {
      gasLimit,
      simulationFails
    };
  }

}

exports.default = TxGasUtil;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\tx-gas-utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\pending-tx-tracker.js", {"../../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\transactions\pending-tx-tracker.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _transaction = require("../../../../shared/constants/transaction");

/**
 * Event emitter utility class for tracking the transactions as they
 * go from a pending state to a confirmed (mined in a block) state.
 *
 * As well as continues broadcast while in the pending state.
 */
class PendingTransactionTracker extends _safeEventEmitter.default {
  /**
   * We wait this many blocks before emitting a 'tx:dropped' event
   *
   * This is because we could be talking to a node that is out of sync.
   *
   * @type {number}
   */

  /**
   * A map of transaction hashes to the number of blocks we've seen
   * since first considering it dropped
   *
   * @type {Map<string, number>}
   */

  /**
   * @param {Object} config - Configuration.
   * @param {Function} config.approveTransaction - Approves a transaction.
   * @param {Function} config.confirmTransaction - Set a transaction as confirmed.
   * @param {Function} config.getCompletedTransactions - Returns completed transactions.
   * @param {Function} config.getPendingTransactions - Returns an array of pending transactions,
   * @param {Object} config.nonceTracker - see nonce tracker
   * @param {Object} config.provider - A network provider.
   * @param {Object} config.query - An EthQuery instance.
   * @param {Function} config.publishTransaction - Publishes a raw transaction,
   */
  constructor(config) {
    super();
    (0, _defineProperty2.default)(this, "DROPPED_BUFFER_COUNT", 3);
    (0, _defineProperty2.default)(this, "droppedBlocksBufferByHash", new Map());
    this.query = config.query || new _ethjsQuery.default(config.provider);
    this.nonceTracker = config.nonceTracker;
    this.getPendingTransactions = config.getPendingTransactions;
    this.getCompletedTransactions = config.getCompletedTransactions;
    this.publishTransaction = config.publishTransaction;
    this.approveTransaction = config.approveTransaction;
    this.confirmTransaction = config.confirmTransaction;
  }
  /**
   * checks the network for signed txs and releases the nonce global lock if it is
   */


  async updatePendingTxs() {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();

    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));
    } catch (err) {
      _loglevel.default.error('PendingTransactionTracker - Error updating pending transactions');

      _loglevel.default.error(err);
    }

    nonceGlobalLock.releaseLock();
  }
  /**
   * Resubmits each pending transaction
   *
   * @param {string} blockNumber - the latest block number in hex
   * @fires tx:warning
   * @returns {Promise<void>}
   */


  async resubmitPendingTxs(blockNumber) {
    const pending = this.getPendingTransactions();

    if (!pending.length) {
      return;
    }

    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, blockNumber);
      } catch (err) {
        var _err$value, _err$value$message;

        const errorMessage = ((_err$value = err.value) === null || _err$value === void 0 ? void 0 : (_err$value$message = _err$value.message) === null || _err$value$message === void 0 ? void 0 : _err$value$message.toLowerCase()) || err.message.toLowerCase();
        const isKnownTx = // geth
        errorMessage.includes('replacement transaction underpriced') || errorMessage.includes('known transaction') || // parity
        errorMessage.includes('gas price too low to replace') || errorMessage.includes('transaction with the same hash was already imported') || // other
        errorMessage.includes('gateway timeout') || errorMessage.includes('nonce too low'); // ignore resubmit warnings, return early

        if (isKnownTx) {
          return;
        } // encountered real error - transition to error state


        txMeta.warning = {
          error: errorMessage,
          message: 'There was an error when resubmitting this transaction.'
        };
        this.emit('tx:warning', txMeta, err);
      }
    }
  }
  /**
   * Attempts to resubmit the given transaction with exponential backoff
   *
   * Will only attempt to retry the given tx every {@code 2**(txMeta.retryCount)} blocks.
   *
   * @param {Object} txMeta - the transaction metadata
   * @param {string} latestBlockNumber - the latest block number in hex
   * @returns {Promise<string|undefined>} the tx hash if retried
   * @fires tx:block-update
   * @fires tx:retry
   * @private
   */


  async _resubmitTx(txMeta, latestBlockNumber) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit('tx:block-update', txMeta, latestBlockNumber);
    }

    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);
    const retryCount = txMeta.retryCount || 0; // Exponential backoff to limit retries at publishing (capped at ~15 minutes between retries)

    if (txBlockDistance < Math.min(50, Math.pow(2, retryCount))) {
      return undefined;
    } // Only auto-submit already-signed txs:


    if (!('rawTx' in txMeta)) {
      return this.approveTransaction(txMeta.id);
    }

    const {
      rawTx
    } = txMeta;
    const txHash = await this.publishTransaction(rawTx); // Increment successful tries:

    this.emit('tx:retry', txMeta);
    return txHash;
  }
  /**
   * Query the network to see if the given {@code txMeta} has been included in a block
   *
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<void>}
   * @fires tx:confirmed
   * @fires tx:dropped
   * @fires tx:failed
   * @fires tx:warning
   * @private
   */


  async _checkPendingTx(txMeta) {
    const txHash = txMeta.hash;
    const txId = txMeta.id; // Only check submitted txs

    if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED) {
      return;
    } // extra check in case there was an uncaught error during the
    // signature and submission process


    if (!txHash) {
      const noTxHashErr = new Error('We had an error while submitting this transaction, please try again.');
      noTxHashErr.name = 'NoTxHashError';
      this.emit('tx:failed', txId, noTxHashErr);
      return;
    }

    if (await this._checkIfNonceIsTaken(txMeta)) {
      this.emit('tx:dropped', txId);
      return;
    }

    try {
      const transactionReceipt = await this.query.getTransactionReceipt(txHash);

      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {
        const {
          baseFeePerGas,
          timestamp: blockTimestamp
        } = await this.query.getBlockByHash(transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockHash, false);
        this.emit('tx:confirmed', txId, transactionReceipt, baseFeePerGas, blockTimestamp);
        return;
      }
    } catch (err) {
      txMeta.warning = {
        error: err.message,
        message: 'There was a problem loading this transaction.'
      };
      this.emit('tx:warning', txMeta, err);
      return;
    }

    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit('tx:dropped', txId);
    }
  }
  /**
   * Checks whether the nonce in the given {@code txMeta} is behind the network nonce
   *
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<boolean>}
   * @private
   */


  async _checkIfTxWasDropped(txMeta) {
    const {
      hash: txHash,
      txParams: {
        nonce,
        from
      }
    } = txMeta;
    const networkNextNonce = await this.query.getTransactionCount(from);

    if (parseInt(nonce, 16) >= networkNextNonce.toNumber()) {
      return false;
    }

    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }

    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);

    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }

    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }
  /**
   * Checks whether the nonce in the given {@code txMeta} is correct against the local set of transactions
   *
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<boolean>}
   * @private
   */


  async _checkIfNonceIsTaken(txMeta) {
    const address = txMeta.txParams.from;
    const completed = this.getCompletedTransactions(address);
    return completed.some( // This is called while the transaction is in-flight, so it is possible that the
    // list of completed transactions now includes the transaction we were looking at
    // and if that is the case, don't consider the transaction to have taken its own nonce
    other => !(other.id === txMeta.id) && other.txParams.nonce === txMeta.txParams.nonce);
  }

}

exports.default = PendingTransactionTracker;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\transactions\\pending-tx-tracker.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\index.js", {"./package.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\package.json","@segment/loosely-validate-event":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@segment\\loosely-validate-event\\index.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","axios":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\index.js","axios-retry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\index.js","lodash.isstring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.isstring\\index.js","md5":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\md5\\md5.js","ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ms\\index.js","remove-trailing-slash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\remove-trailing-slash\\index.js","uuid/v4":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\analytics-node\index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'

const assert = require('assert')
const removeSlash = require('remove-trailing-slash')
const looselyValidate = require('@segment/loosely-validate-event')
const axios = require('axios')
const axiosRetry = require('axios-retry')
const ms = require('ms')
const uuid = require('uuid/v4')
const md5 = require('md5')
const version = require('./package.json').version
const isString = require('lodash.isstring')

const setImmediate = global.setImmediate || process.nextTick.bind(process)
const noop = () => {}

class Analytics {
  /**
   * Initialize a new `Analytics` with your Segment project's `writeKey` and an
   * optional dictionary of `options`.
   *
   * @param {String} writeKey
   * @param {Object} [options] (optional)
   *   @property {Number} flushAt (default: 20)
   *   @property {Number} flushInterval (default: 10000)
   *   @property {String} host (default: 'https://api.segment.io')
   *   @property {Boolean} enable (default: true)
   */

  constructor (writeKey, options) {
    options = options || {}

    assert(writeKey, 'You must pass your Segment project\'s write key.')

    this.queue = []
    this.writeKey = writeKey
    this.host = removeSlash(options.host || 'https://api.segment.io')
    this.timeout = options.timeout || false
    this.flushAt = Math.max(options.flushAt, 1) || 20
    this.flushInterval = options.flushInterval || 10000
    this.flushed = false
    Object.defineProperty(this, 'enable', {
      configurable: false,
      writable: false,
      enumerable: true,
      value: typeof options.enable === 'boolean' ? options.enable : true
    })
    this.axiosClient = axios.create()
    axiosRetry(this.axiosClient, {
      retries: options.retryCount || 3,
      retryCondition: this._isErrorRetryable,
      retryDelay: axiosRetry.exponentialDelay
    })
  }

  _validate (message, type) {
    try {
      looselyValidate(message, type)
    } catch (e) {
      if (e.message === 'Your message must be < 32kb.') {
        console.log('Your message must be < 32kb. This is currently surfaced as a warning to allow clients to update. Versions released after August 1, 2018 will throw an error instead. Please update your code before then.', message)
        return
      }
      throw e
    }
  }

  /**
   * Send an identify `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  identify (message, callback) {
    this._validate(message, 'identify')
    this.enqueue('identify', message, callback)
    return this
  }

  /**
   * Send a group `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  group (message, callback) {
    this._validate(message, 'group')
    this.enqueue('group', message, callback)
    return this
  }

  /**
   * Send a track `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  track (message, callback) {
    this._validate(message, 'track')
    this.enqueue('track', message, callback)
    return this
  }

  /**
   * Send a page `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  page (message, callback) {
    this._validate(message, 'page')
    this.enqueue('page', message, callback)
    return this
  }

  /**
   * Send a screen `message`.
   *
   * @param {Object} message
   * @param {Function} fn (optional)
   * @return {Analytics}
   */

  screen (message, callback) {
    this._validate(message, 'screen')
    this.enqueue('screen', message, callback)
    return this
  }

  /**
   * Send an alias `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  alias (message, callback) {
    this._validate(message, 'alias')
    this.enqueue('alias', message, callback)
    return this
  }

  /**
   * Add a `message` of type `type` to the queue and
   * check whether it should be flushed.
   *
   * @param {String} type
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @api private
   */

  enqueue (type, message, callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    message = Object.assign({}, message)
    message.type = type
    message.context = Object.assign({
      library: {
        name: 'analytics-node',
        version
      }
    }, message.context)

    message._metadata = Object.assign({
      nodeVersion: process.versions.node
    }, message._metadata)

    if (!message.timestamp) {
      message.timestamp = new Date()
    }

    if (!message.messageId) {
      // We md5 the messaage to add more randomness. This is primarily meant
      // for use in the browser where the uuid package falls back to Math.random()
      // which is not a great source of randomness.
      // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).
      message.messageId = `node-${md5(JSON.stringify(message))}-${uuid()}`
    }

    // Historically this library has accepted strings and numbers as IDs.
    // However, our spec only allows strings. To avoid breaking compatibility,
    // we'll coerce these to strings if they aren't already.
    if (message.anonymousId && !isString(message.anonymousId)) {
      message.anonymousId = JSON.stringify(message.anonymousId)
    }
    if (message.userId && !isString(message.userId)) {
      message.userId = JSON.stringify(message.userId)
    }

    this.queue.push({ message, callback })

    if (!this.flushed) {
      this.flushed = true
      this.flush()
      return
    }

    if (this.queue.length >= this.flushAt) {
      this.flush()
    }

    if (this.flushInterval && !this.timer) {
      this.timer = setTimeout(this.flush.bind(this), this.flushInterval)
    }
  }

  /**
   * Flush the current queue
   *
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  flush (callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }

    if (!this.queue.length) {
      return setImmediate(callback)
    }

    const items = this.queue.splice(0, this.flushAt)
    const callbacks = items.map(item => item.callback)
    const messages = items.map(item => item.message)

    const data = {
      batch: messages,
      timestamp: new Date(),
      sentAt: new Date()
    }

    const done = err => {
      callbacks.forEach(callback => callback(err))
      callback(err, data)
    }

    // Don't set the user agent if we're not on a browser. The latest spec allows
    // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers
    // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),
    // but browsers such as Chrome and Safari have not caught up.
    const headers = {}
    if (typeof window === 'undefined') {
      headers['user-agent'] = `analytics-node/${version}`
    }

    const req = {
      method: 'POST',
      url: `${this.host}/v1/batch`,
      auth: {
        username: this.writeKey
      },
      data,
      headers
    }

    if (this.timeout) {
      req.timeout = typeof this.timeout === 'string' ? ms(this.timeout) : this.timeout
    }

    this.axiosClient(req)
      .then(() => done())
      .catch(err => {
        if (err.response) {
          const error = new Error(err.response.statusText)
          return done(error)
        }

        done(err)
      })
  }

  _isErrorRetryable (error) {
    // Retry Network Errors.
    if (axiosRetry.isNetworkError(error)) {
      return true
    }

    if (!error.response) {
      // Cannot determine if the request can be retried
      return false
    }

    // Retry Server Errors (5xx).
    if (error.response.status >= 500 && error.response.status <= 599) {
      return true
    }

    // Retry if rate limited.
    if (error.response.status === 429) {
      return true
    }

    return false
  }
}

module.exports = Analytics

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"analytics-node",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\thirdparty.js", {"./index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\index.js","aes-js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\aes-js\\index.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","scryptsy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\scryptsy\\lib\\scrypt.js","utf8":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\utf8\\utf8.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\thirdparty.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Wallet = require('./index.js');
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var scryptsy = require('scryptsy');
var utf8 = require('utf8');
var aesjs = require('aes-js');
var Buffer = require('safe-buffer').Buffer;

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Thirdparty = {};

/*
 * opts:
 * - digest - digest algorithm, defaults to md5
 * - count - hash iterations
 * - keysize - desired key size
 * - ivsize - desired IV size
 *
 * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html
 *
 * FIXME: not optimised at all
 */
function evp_kdf(data, salt, opts) {
  // eslint-disable-line
  // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`
  function iter(block) {
    var hash = crypto.createHash(opts.digest || 'md5');
    hash.update(block);
    hash.update(data);
    hash.update(salt);
    block = hash.digest();

    for (var i = 1; i < (opts.count || 1); i++) {
      hash = crypto.createHash(opts.digest || 'md5');
      hash.update(block);
      block = hash.digest();
    }

    return block;
  }

  var keysize = opts.keysize || 16;
  var ivsize = opts.ivsize || 16;

  var ret = [];

  var i = 0;
  while (Buffer.concat(ret).length < keysize + ivsize) {
    ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);
    i++;
  }

  var tmp = Buffer.concat(ret);

  return {
    key: tmp.slice(0, keysize),
    iv: tmp.slice(keysize, keysize + ivsize)
  };
}

// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with
function decodeCryptojsSalt(input) {
  var ciphertext = Buffer.from(input, 'base64');
  if (ciphertext.slice(0, 8).toString() === 'Salted__') {
    return {
      salt: ciphertext.slice(8, 16),
      ciphertext: ciphertext.slice(16)
    };
  } else {
    return {
      ciphertext: ciphertext
    };
  }
}

/*
 * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts
 * and used on https://www.myetherwallet.com/
 */
Thirdparty.fromEtherWallet = function (input, password) {
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var privKey;
  if (!json.locked) {
    if (json.private.length !== 64) {
      throw new Error('Invalid private key length');
    }

    privKey = Buffer.from(json.private, 'hex');
  } else {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }
    if (password.length < 7) {
      throw new Error('Password must be at least 7 characters');
    }

    // the "encrypted" version has the low 4 bytes
    // of the hash of the address appended
    var cipher = json.encrypted ? json.private.slice(0, 128) : json.private;

    // decode openssl ciphertext + salt encoding
    cipher = decodeCryptojsSalt(cipher);

    if (!cipher.salt) {
      throw new Error('Unsupported EtherWallet key format');
    }

    // derive key/iv using OpenSSL EVP as implemented in CryptoJS
    var evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });

    var decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);
    privKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));

    // NOTE: yes, they've run it through UTF8
    privKey = Buffer.from(utf8.decode(privKey.toString()), 'hex');
  }

  var wallet = new Wallet(privKey);

  if (wallet.getAddressString() !== json.address) {
    throw new Error('Invalid private key or address');
  }

  return wallet;
};

Thirdparty.fromEtherCamp = function (passphrase) {
  return new Wallet(ethUtil.keccak256(Buffer.from(passphrase)));
};

Thirdparty.fromKryptoKit = function (entropy, password) {
  function kryptoKitBrokenScryptSeed(buf) {
    // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer
    //
    // The `buffer`` implementation used does the below transformation (doesn't matches the current version):
    // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js

    function decodeUtf8Char(str) {
      try {
        return decodeURIComponent(str);
      } catch (err) {
        return String.fromCharCode(0xFFFD); // UTF 8 invalid char
      }
    }

    var res = '';
    var tmp = '';

    for (var i = 0; i < buf.length; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }

    return Buffer.from(res + decodeUtf8Char(tmp));
  }

  if (entropy[0] === '#') {
    entropy = entropy.slice(1);
  }

  var type = entropy[0];
  entropy = entropy.slice(1);

  var privKey;
  if (type === 'd') {
    privKey = ethUtil.sha256(Buffer.from(entropy));
  } else if (type === 'q') {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }

    var encryptedSeed = ethUtil.sha256(Buffer.from(entropy.slice(0, 30)));
    var checksum = entropy.slice(30, 46);

    var salt = kryptoKitBrokenScryptSeed(encryptedSeed);
    var aesKey = scryptsy(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32);

    /* FIXME: try to use `crypto` instead of `aesjs`
     // NOTE: ECB doesn't use the IV, so it can be anything
    var decipher = crypto.createDecipheriv("aes-256-ecb", aesKey, Buffer.from(0))
     // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works
    privKey = Buffer.concat([
      decipher.update(encryptedSeed).slice(0, 16),
      decipher.update(encryptedSeed).slice(0, 16),
    ])
    */

    /* eslint-disable new-cap */
    var decipher = new aesjs.ModeOfOperation.ecb(aesKey);
    /* eslint-enable new-cap */
    /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */
    privKey = Buffer.concat([Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))), Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32)))]);

    if (checksum.length > 0) {
      if (checksum !== ethUtil.sha256(ethUtil.sha256(privKey)).slice(0, 8).toString('hex')) {
        throw new Error('Failed to decrypt input - possibly invalid passphrase');
      }
    }
  } else {
    throw new Error('Unsupported or invalid entropy type');
  }

  return new Wallet(privKey);
};

Thirdparty.fromQuorumWallet = function (passphrase, userid) {
  assert(passphrase.length >= 10);
  assert(userid.length >= 10);

  var seed = passphrase + userid;
  seed = crypto.pbkdf2Sync(seed, seed, 2000, 32, 'sha256');

  return new Wallet(seed);
};

module.exports = Thirdparty;
      };
    };
  }
}, {package:"ethereumjs-wallet",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\thirdparty.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\index.js", {"bs58check":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58check\\index.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js","randombytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\randombytes\\browser.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","scryptsy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\scryptsy\\lib\\scrypt.js","uuid/v4":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Buffer = require('safe-buffer').Buffer;
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var randomBytes = require('randombytes');
var scryptsy = require('scryptsy');
var uuidv4 = require('uuid/v4');
var bs58check = require('bs58check');

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Wallet = function Wallet(priv, pub) {
  if (priv && pub) {
    throw new Error('Cannot supply both a private and a public key to the constructor');
  }

  if (priv && !ethUtil.isValidPrivate(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (pub && !ethUtil.isValidPublic(pub)) {
    throw new Error('Invalid public key');
  }

  this._privKey = priv;
  this._pubKey = pub;
};

Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    assert(this._privKey, 'This is a public key only wallet');
    return this._privKey;
  }
});

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = ethUtil.privateToPublic(this.privKey);
    }
    return this._pubKey;
  }
});

Wallet.generate = function (icapDirect) {
  if (icapDirect) {
    var max = new ethUtil.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);
    while (true) {
      var privKey = randomBytes(32);
      if (new ethUtil.BN(ethUtil.privateToAddress(privKey)).lte(max)) {
        return new Wallet(privKey);
      }
    }
  } else {
    return new Wallet(randomBytes(32));
  }
};

Wallet.generateVanityAddress = function (pattern) {
  if ((typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
    pattern = new RegExp(pattern);
  }

  while (true) {
    var privKey = randomBytes(32);
    var address = ethUtil.privateToAddress(privKey);

    if (pattern.test(address.toString('hex'))) {
      return new Wallet(privKey);
    }
  }
};

Wallet.prototype.getPrivateKey = function () {
  return this.privKey;
};

Wallet.prototype.getPrivateKeyString = function () {
  return ethUtil.bufferToHex(this.getPrivateKey());
};

Wallet.prototype.getPublicKey = function () {
  return this.pubKey;
};

Wallet.prototype.getPublicKeyString = function () {
  return ethUtil.bufferToHex(this.getPublicKey());
};

Wallet.prototype.getAddress = function () {
  return ethUtil.publicToAddress(this.pubKey);
};

Wallet.prototype.getAddressString = function () {
  return ethUtil.bufferToHex(this.getAddress());
};

Wallet.prototype.getChecksumAddressString = function () {
  return ethUtil.toChecksumAddress(this.getAddressString());
};

// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
Wallet.prototype.toV3 = function (password, opts) {
  assert(this._privKey, 'This is a public key only wallet');

  opts = opts || {};
  var salt = opts.salt || randomBytes(32);
  var iv = opts.iv || randomBytes(16);

  var derivedKey;
  var kdf = opts.kdf || 'scrypt';
  var kdfparams = {
    dklen: opts.dklen || 32,
    salt: salt.toString('hex')
  };

  if (kdf === 'pbkdf2') {
    kdfparams.c = opts.c || 262144;
    kdfparams.prf = 'hmac-sha256';
    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');
  } else if (kdf === 'scrypt') {
    // FIXME: support progress reporting callback
    kdfparams.n = opts.n || 262144;
    kdfparams.r = opts.r || 8;
    kdfparams.p = opts.p || 1;
    derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else {
    throw new Error('Unsupported kdf');
  }

  var cipher = crypto.createCipheriv(opts.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);
  if (!cipher) {
    throw new Error('Unsupported cipher');
  }

  var ciphertext = runCipherBuffer(cipher, this.privKey);

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')]));

  return {
    version: 3,
    id: uuidv4({ random: opts.uuid || randomBytes(16) }),
    address: this.getAddress().toString('hex'),
    crypto: {
      ciphertext: ciphertext.toString('hex'),
      cipherparams: {
        iv: iv.toString('hex')
      },
      cipher: opts.cipher || 'aes-128-ctr',
      kdf: kdf,
      kdfparams: kdfparams,
      mac: mac.toString('hex')
    }
  };
};

Wallet.prototype.getV3Filename = function (timestamp) {
  /*
   * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting
   * is a pain in Javascript, everbody knows that. We could use moment.js,
   * but decide to do it manually in order to save space.
   *
   * toJSON() returns a pretty close version, so let's use it. It is not UTC though,
   * but does it really matter?
   *
   * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819
   *
   */
  var ts = timestamp ? new Date(timestamp) : new Date();

  return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');
};

Wallet.prototype.toV3String = function (password, opts) {
  return JSON.stringify(this.toV3(password, opts));
};

Wallet.fromPublicKey = function (pub, nonStrict) {
  if (nonStrict) {
    pub = ethUtil.importPublic(pub);
  }
  return new Wallet(null, pub);
};

Wallet.fromExtendedPublicKey = function (pub) {
  assert(pub.slice(0, 4) === 'xpub', 'Not an extended public key');
  pub = bs58check.decode(pub).slice(45);
  // Convert to an Ethereum public key
  return Wallet.fromPublicKey(pub, true);
};

Wallet.fromPrivateKey = function (priv) {
  return new Wallet(priv);
};

Wallet.fromExtendedPrivateKey = function (priv) {
  assert(priv.slice(0, 4) === 'xprv', 'Not an extended private key');
  var tmp = bs58check.decode(priv);
  assert(tmp[45] === 0, 'Invalid extended private key');
  return Wallet.fromPrivateKey(tmp.slice(46));
};

// https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec
Wallet.fromV1 = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  if (json.Version !== '1') {
    throw new Error('Not a V1 wallet');
  }

  if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {
    throw new Error('Unsupported key derivation scheme');
  }

  var kdfparams = json.Crypto.KeyHeader.KdfParams;
  var derivedKey = scryptsy(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);

  var ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));

  if (mac.toString('hex') !== json.Crypto.MAC) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv('aes-128-cbc', ethUtil.keccak256(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

Wallet.fromV3 = function (input, password, nonStrict) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);

  if (json.version !== 3) {
    throw new Error('Not a V3 wallet');
  }

  var derivedKey;
  var kdfparams;
  if (json.crypto.kdf === 'scrypt') {
    kdfparams = json.crypto.kdfparams;

    // FIXME: support progress reporting callback
    derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else if (json.crypto.kdf === 'pbkdf2') {
    kdfparams = json.crypto.kdfparams;

    if (kdfparams.prf !== 'hmac-sha256') {
      throw new Error('Unsupported parameters to PBKDF2');
    }

    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');
  } else {
    throw new Error('Unsupported key derivation scheme');
  }

  var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
  if (mac.toString('hex') !== json.crypto.mac) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

/*
 * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
 * JSON fields: encseed, ethaddr, btcaddr, email
 */
Wallet.fromEthSale = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var encseed = Buffer.from(json.encseed, 'hex');

  // key derivation
  var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);

  // seed decoding (IV is first 16 bytes)
  // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally
  //       see also http://stackoverflow.com/a/31614770/4964819
  var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));
  var seed = runCipherBuffer(decipher, encseed.slice(16));

  var wallet = new Wallet(ethUtil.keccak256(seed));
  if (wallet.getAddress().toString('hex') !== json.ethaddr) {
    throw new Error('Decoded key mismatch - possibly wrong passphrase');
  }
  return wallet;
};

module.exports = Wallet;
      };
    };
  }
}, {package:"ethereumjs-wallet",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\network.js", {"../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../../shared/modules/fetch-with-timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\fetch-with-timeout.js","../../../../shared/modules/network.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js","./createInfuraClient":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createInfuraClient.js","./createJsonRpcClient":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createJsonRpcClient.js","./createMetamaskMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createMetamaskMiddleware.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","swappable-obj-proxy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\network.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NETWORK_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("assert");

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _swappableObjProxy = require("swappable-obj-proxy");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _network = require("../../../../shared/constants/network");

var _time = require("../../../../shared/constants/time");

var _network2 = require("../../../../shared/modules/network.utils");

var _fetchWithTimeout = _interopRequireDefault(require("../../../../shared/modules/fetch-with-timeout"));

var _createMetamaskMiddleware = _interopRequireDefault(require("./createMetamaskMiddleware"));

var _createInfuraClient = _interopRequireDefault(require("./createInfuraClient"));

var _createJsonRpcClient = _interopRequireDefault(require("./createJsonRpcClient"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const env = process.env.METAMASK_ENV;
const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
let defaultProviderConfigOpts;

if (process.env.IN_TEST) {
  defaultProviderConfigOpts = {
    type: _network.NETWORK_TYPE_RPC,
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    nickname: 'Localhost 8545'
  };
} else if (true || env === 'test') {
  defaultProviderConfigOpts = {
    type: _network.RINKEBY,
    chainId: _network.RINKEBY_CHAIN_ID
  };
} else {
  defaultProviderConfigOpts = {
    type: _network.MAINNET,
    chainId: _network.MAINNET_CHAIN_ID
  };
}

const defaultProviderConfig = _objectSpread({
  ticker: 'ETH'
}, defaultProviderConfigOpts);

const defaultNetworkDetailsState = {
  EIPS: {
    1559: undefined
  }
};
const NETWORK_EVENTS = {
  // Fired after the actively selected network is changed
  NETWORK_DID_CHANGE: 'networkDidChange',
  // Fired when the actively selected network *will* change
  NETWORK_WILL_CHANGE: 'networkWillChange',
  // Fired when Infura returns an error indicating no support
  INFURA_IS_BLOCKED: 'infuraIsBlocked',
  // Fired when not using an Infura network or when Infura returns no error, indicating support
  INFURA_IS_UNBLOCKED: 'infuraIsUnblocked'
};
exports.NETWORK_EVENTS = NETWORK_EVENTS;

class NetworkController extends _events.default {
  constructor(opts = {}) {
    super(); // create stores

    this.providerStore = new _obsStore.ObservableStore(opts.provider || _objectSpread({}, defaultProviderConfig));
    this.previousProviderStore = new _obsStore.ObservableStore(this.providerStore.getState());
    this.networkStore = new _obsStore.ObservableStore('loading'); // We need to keep track of a few details about the current network
    // Ideally we'd merge this.networkStore with this new store, but doing so
    // will require a decent sized refactor of how we're accessing network
    // state. Currently this is only used for detecting EIP 1559 support but
    // can be extended to track other network details.

    this.networkDetails = new _obsStore.ObservableStore(opts.networkDetails || _objectSpread({}, defaultNetworkDetailsState));
    this.store = new _obsStore.ComposedStore({
      provider: this.providerStore,
      previousProviderStore: this.previousProviderStore,
      network: this.networkStore,
      networkDetails: this.networkDetails
    }); // provider and block tracker

    this._provider = null;
    this._blockTracker = null; // provider and block tracker proxies - because the network changes

    this._providerProxy = null;
    this._blockTrackerProxy = null;
    this.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, this.lookupNetwork);
  }
  /**
   * Sets the Infura project ID
   *
   * @param {string} projectId - The Infura project ID
   * @throws {Error} If the project ID is not a valid string.
   */


  setInfuraProjectId(projectId) {
    if (!projectId || typeof projectId !== 'string') {
      throw new Error('Invalid Infura project ID');
    }

    this._infuraProjectId = projectId;
  }

  initializeProvider(providerParams) {
    this._baseProviderParams = providerParams;
    const {
      type,
      rpcUrl,
      chainId
    } = this.getProviderConfig();

    this._configureProvider({
      type,
      rpcUrl,
      chainId
    });

    this.lookupNetwork();
  } // return the proxies so the references will always be good


  getProviderAndBlockTracker() {
    const provider = this._providerProxy;
    const blockTracker = this._blockTrackerProxy;
    return {
      provider,
      blockTracker
    };
  }
  /**
   * Method to return the latest block for the current network
   *
   * @returns {Object} Block header
   */


  getLatestBlock() {
    return new Promise((resolve, reject) => {
      const {
        provider
      } = this.getProviderAndBlockTracker();
      const ethQuery = new _ethQuery.default(provider);
      ethQuery.sendAsync({
        method: 'eth_getBlockByNumber',
        params: ['latest', false]
      }, (err, block) => {
        if (err) {
          return reject(err);
        }

        return resolve(block);
      });
    });
  }
  /**
   * Method to check if the block header contains fields that indicate EIP 1559
   * support (baseFeePerGas).
   *
   * @returns {Promise<boolean>} true if current network supports EIP 1559
   */


  async getEIP1559Compatibility() {
    const {
      EIPS
    } = this.networkDetails.getState();

    if (EIPS[1559] !== undefined) {
      return EIPS[1559];
    }

    const latestBlock = await this.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.setNetworkEIPSupport(1559, supportsEIP1559);
    return supportsEIP1559;
  }

  verifyNetwork() {
    // Check network when restoring connectivity:
    if (this.isNetworkLoading()) {
      this.lookupNetwork();
    }
  }

  getNetworkState() {
    return this.networkStore.getState();
  }

  setNetworkState(network) {
    this.networkStore.putState(network);
  }
  /**
   * Set EIP support indication in the networkDetails store
   *
   * @param {number} EIPNumber - The number of the EIP to mark support for
   * @param {boolean} isSupported - True if the EIP is supported
   */


  setNetworkEIPSupport(EIPNumber, isSupported) {
    this.networkDetails.updateState({
      EIPS: {
        [EIPNumber]: isSupported
      }
    });
  }
  /**
   * Reset EIP support to default (no support)
   */


  clearNetworkDetails() {
    this.networkDetails.putState(_objectSpread({}, defaultNetworkDetailsState));
  }

  isNetworkLoading() {
    return this.getNetworkState() === 'loading';
  }

  lookupNetwork() {
    // Prevent firing when provider is not defined.
    if (!this._provider) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing provider');

      return;
    }

    const chainId = this.getCurrentChainId();

    if (!chainId) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing chainId');

      this.setNetworkState('loading'); // keep network details in sync with network state

      this.clearNetworkDetails();
      return;
    } // Ping the RPC endpoint so we can confirm that it works


    const ethQuery = new _ethQuery.default(this._provider);
    const initialNetwork = this.getNetworkState();
    const {
      type
    } = this.getProviderConfig();

    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._checkInfuraAvailability(type);
    } else {
      this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
    }

    ethQuery.sendAsync({
      method: 'net_version'
    }, (err, networkVersion) => {
      const currentNetwork = this.getNetworkState();

      if (initialNetwork === currentNetwork) {
        if (err) {
          this.setNetworkState('loading'); // keep network details in sync with network state

          this.clearNetworkDetails();
          return;
        }

        this.setNetworkState(networkVersion); // look up EIP-1559 support

        this.getEIP1559Compatibility();
      }
    });
  }

  getCurrentChainId() {
    var _NETWORK_TYPE_TO_ID_M;

    const {
      type,
      chainId: configChainId
    } = this.getProviderConfig();
    return ((_NETWORK_TYPE_TO_ID_M = _network.NETWORK_TYPE_TO_ID_MAP[type]) === null || _NETWORK_TYPE_TO_ID_M === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M.chainId) || configChainId;
  }

  setRpcTarget(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs) {
    _assert.strict.ok((0, _network2.isPrefixedFormattedHexString)(chainId), `Invalid chain ID "${chainId}": invalid hex string.`);

    _assert.strict.ok((0, _network2.isSafeChainId)(parseInt(chainId, 16)), `Invalid chain ID "${chainId}": numerical value greater than max safe value.`);

    this.setProviderConfig({
      type: _network.NETWORK_TYPE_RPC,
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
  }

  async setProviderType(type) {
    _assert.strict.notStrictEqual(type, _network.NETWORK_TYPE_RPC, `NetworkController - cannot call "setProviderType" with type "${_network.NETWORK_TYPE_RPC}". Use "setRpcTarget"`);

    _assert.strict.ok(_network.INFURA_PROVIDER_TYPES.includes(type), `Unknown Infura provider type "${type}".`);

    const {
      chainId
    } = _network.NETWORK_TYPE_TO_ID_MAP[type];
    this.setProviderConfig({
      type,
      rpcUrl: '',
      chainId,
      ticker: 'ETH',
      nickname: ''
    });
  }

  resetConnection() {
    this.setProviderConfig(this.getProviderConfig());
  }
  /**
   * Sets the provider config and switches the network.
   *
   * @param config
   */


  setProviderConfig(config) {
    this.previousProviderStore.updateState(this.getProviderConfig());
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  rollbackToPreviousProvider() {
    const config = this.previousProviderStore.getState();
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  getProviderConfig() {
    return this.providerStore.getState();
  }

  getNetworkIdentifier() {
    const provider = this.providerStore.getState();
    return provider.type === _network.NETWORK_TYPE_RPC ? provider.rpcUrl : provider.type;
  } //
  // Private
  //


  async _checkInfuraAvailability(network) {
    const rpcUrl = `https://${network}.infura.io/v3/${this._infuraProjectId}`;
    let networkChanged = false;
    this.once(NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      networkChanged = true;
    });

    try {
      const response = await fetchWithTimeout(rpcUrl, {
        method: 'POST',
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'eth_blockNumber',
          params: [],
          id: 1
        })
      });

      if (networkChanged) {
        return;
      }

      if (response.ok) {
        this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
      } else {
        const responseMessage = await response.json();

        if (networkChanged) {
          return;
        }

        if (responseMessage.error === _network.INFURA_BLOCKED_KEY) {
          this.emit(NETWORK_EVENTS.INFURA_IS_BLOCKED);
        }
      }
    } catch (err) {
      _loglevel.default.warn(`MetaMask - Infura availability check failed`, err);
    }
  }

  _switchNetwork(opts) {
    // Indicate to subscribers that network is about to change
    this.emit(NETWORK_EVENTS.NETWORK_WILL_CHANGE); // Set loading state

    this.setNetworkState('loading'); // Reset network details

    this.clearNetworkDetails(); // Configure the provider appropriately

    this._configureProvider(opts); // Notify subscribers that network has changed


    this.emit(NETWORK_EVENTS.NETWORK_DID_CHANGE, opts.type);
  }

  _configureProvider({
    type,
    rpcUrl,
    chainId
  }) {
    // infura type-based endpoints
    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._configureInfuraProvider(type, this._infuraProjectId); // url-based rpc endpoints

    } else if (type === _network.NETWORK_TYPE_RPC) {
      this._configureStandardProvider(rpcUrl, chainId);
    } else {
      throw new Error(`NetworkController - _configureProvider - unknown type "${type}"`);
    }
  }

  _configureInfuraProvider(type, projectId) {
    _loglevel.default.info('NetworkController - configureInfuraProvider', type);

    const networkClient = (0, _createInfuraClient.default)({
      network: type,
      projectId
    });

    this._setNetworkClient(networkClient);
  }

  _configureStandardProvider(rpcUrl, chainId) {
    _loglevel.default.info('NetworkController - configureStandardProvider', rpcUrl);

    const networkClient = (0, _createJsonRpcClient.default)({
      rpcUrl,
      chainId
    });

    this._setNetworkClient(networkClient);
  }

  _setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const metamaskMiddleware = (0, _createMetamaskMiddleware.default)(this._baseProviderParams);
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    engine.push(metamaskMiddleware);
    engine.push(networkMiddleware);
    const provider = (0, _ethJsonRpcMiddleware.providerFromEngine)(engine);

    this._setProviderAndBlockTracker({
      provider,
      blockTracker
    });
  }

  _setProviderAndBlockTracker({
    provider,
    blockTracker
  }) {
    // update or initialize proxies
    if (this._providerProxy) {
      this._providerProxy.setTarget(provider);
    } else {
      this._providerProxy = (0, _swappableObjProxy.createSwappableProxy)(provider);
    }

    if (this._blockTrackerProxy) {
      this._blockTrackerProxy.setTarget(blockTracker);
    } else {
      this._blockTrackerProxy = (0, _swappableObjProxy.createEventEmitterProxy)(blockTracker, {
        eventFilter: 'skipInternal'
      });
    } // set new provider and blockTracker


    this._provider = provider;
    this._blockTracker = blockTracker;
  }

}

exports.default = NetworkController;


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\network.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","coinstring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\lib\\coinstring.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\hdkey\lib\hdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
}, {package:"hdkey",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\index.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
}, {package:"eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\providerAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\block-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, _res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js", {"btoa":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\fetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable node/global-require,@typescript-eslint/no-require-imports */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable node/global-require,@typescript-eslint/no-require-imports */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./utils/cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\inflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = (0, cache_1.cacheIdentifierForPayload)(req);
        // if not cacheable, skip
        if (!cacheId) {
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = (0, clone_1.default)(handledRes.result);
            res.error = (0, clone_1.default)(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\block-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js", {"./providerFromEngine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\providerFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, providerFromEngine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./utils/cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\retryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            return next();
        }
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            const attemptResponse = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
            // verify result
            if (emptyValues.includes(attemptResponse)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return next();
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            await timeout(1000);
        }
    }
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\providerFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = engine.handle.bind(engine);
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./utils/cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\clone\\clone.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\block-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        const childRes = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return next();
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./utils/cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\block-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!(0, cache_1.canCache)(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = (0, cache_1.blockTagForPayload)(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = (0, cache_1.cacheTypeForPayload)(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = (0, cache_1.blockTagForPayload)(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js", {"eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\eth-sig-util\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\wallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return (0, json_rpc_engine_1.createScaffoldMiddleware)({
        // account lookups
        eth_accounts: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupAccounts),
        eth_coinbase: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(sendTransaction),
        eth_signTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(signTransaction),
        // message signatures
        eth_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(ethSign),
        eth_signTypedData: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedData),
        eth_signTypedData_v3: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV3),
        eth_signTypedData_v4: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV4),
        personal_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(personalSign),
        eth_getEncryptionPublicKey: (0, json_rpc_engine_1.createAsyncMiddleware)(encryptionPublicKey),
        eth_decrypt: (0, json_rpc_engine_1.createAsyncMiddleware)(decryptMessage),
        personal_ecRecover: (0, json_rpc_engine_1.createAsyncMiddleware)(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { sig: signature, data: message });
        const signerAddress = sigUtil.recoverPersonalSignature(msgParams);
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' && address.length > 0) {
            // ensure address is included in provided accounts
            const accounts = await getAccounts(req);
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\SmartTransactionsController.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\utils.js","@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\bignumber.js\\bignumber.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js","lodash/cloneDeep":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\cloneDeep.js","lodash/mapValues":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\mapValues.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\dist\SmartTransactionsController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CANCELLABLE_INTERVAL = exports.DEFAULT_INTERVAL = void 0;
const controllers_1 = require("@metamask/controllers");
const bignumber_js_1 = require("bignumber.js");
const ethers_1 = require("ethers");
const mapValues_1 = __importDefault(require("lodash/mapValues"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const types_1 = require("./types");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const { safelyExecute } = controllers_1.util;
// TODO: JSDoc all methods
// TODO: Remove all comments (* ! ?)
const SECOND = 1000;
const MINUTE = SECOND * 60;
exports.DEFAULT_INTERVAL = SECOND * 10;
exports.CANCELLABLE_INTERVAL = MINUTE;
class SmartTransactionsController extends controllers_1.BaseController {
    constructor({ onNetworkStateChange, getNonceLock, getNetwork, provider, confirmExternalTransaction, trackMetaMetricsEvent, }, config, state) {
        super(config, state);
        this.defaultConfig = {
            interval: exports.DEFAULT_INTERVAL,
            chainId: constants_1.CHAIN_IDS.ETHEREUM,
            clientId: 'default',
            supportedChainIds: [constants_1.CHAIN_IDS.ETHEREUM, constants_1.CHAIN_IDS.RINKEBY],
        };
        this.defaultState = {
            smartTransactionsState: {
                smartTransactions: {},
                userOptIn: undefined,
                fees: undefined,
                liveness: true,
                estimatedGas: {
                    txData: undefined,
                    approvalTxData: undefined,
                },
            },
        };
        this.getNonceLock = getNonceLock;
        this.getNetwork = getNetwork;
        this.ethersProvider = new ethers_1.ethers.providers.Web3Provider(provider);
        this.confirmExternalTransaction = confirmExternalTransaction;
        this.trackMetaMetricsEvent = trackMetaMetricsEvent;
        this.initialize();
        this.initializeSmartTransactionsForChainId();
        onNetworkStateChange(({ provider: newProvider }) => {
            const { chainId } = newProvider;
            this.configure({ chainId });
            this.initializeSmartTransactionsForChainId();
            this.checkPoll(this.state);
            this.ethersProvider = new ethers_1.ethers.providers.Web3Provider(provider);
        });
        this.subscribe((currentState) => this.checkPoll(currentState));
    }
    /* istanbul ignore next */
    async fetch(request, options) {
        const { clientId } = this.config;
        const fetchOptions = Object.assign(Object.assign({}, options), { headers: Object.assign({ 'Content-Type': 'application/json' }, (clientId && { 'X-Client-Id': clientId })) });
        return utils_1.handleFetch(request, fetchOptions);
    }
    checkPoll(state) {
        const { smartTransactions } = state.smartTransactionsState;
        const currentSmartTransactions = smartTransactions[this.config.chainId];
        const pendingTransactions = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.filter(utils_1.isSmartTransactionPending);
        if (!this.timeoutHandle && (pendingTransactions === null || pendingTransactions === void 0 ? void 0 : pendingTransactions.length) > 0) {
            this.poll();
        }
        else if (this.timeoutHandle && (pendingTransactions === null || pendingTransactions === void 0 ? void 0 : pendingTransactions.length) === 0) {
            this.stop();
        }
    }
    initializeSmartTransactionsForChainId() {
        var _a;
        if (this.config.supportedChainIds.includes(this.config.chainId)) {
            const { smartTransactionsState } = this.state;
            this.update({
                smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [this.config.chainId]: (_a = smartTransactionsState.smartTransactions[this.config.chainId]) !== null && _a !== void 0 ? _a : [] }) }),
            });
        }
    }
    async poll(interval) {
        const { chainId, supportedChainIds } = this.config;
        interval && this.configure({ interval }, false, false);
        this.timeoutHandle && clearInterval(this.timeoutHandle);
        if (!supportedChainIds.includes(chainId)) {
            return;
        }
        await safelyExecute(() => this.updateSmartTransactions());
        this.timeoutHandle = setInterval(() => {
            safelyExecute(() => this.updateSmartTransactions());
        }, this.config.interval);
    }
    async stop() {
        this.timeoutHandle && clearInterval(this.timeoutHandle);
        this.timeoutHandle = undefined;
    }
    setOptInState(state) {
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { userOptIn: state }),
        });
    }
    trackStxStatusChange(smartTransaction, prevSmartTransaction) {
        var _a, _b;
        if (!prevSmartTransaction) {
            return; // Don't track the first STX, because it doesn't have all necessary params.
        }
        let updatedSmartTransaction = cloneDeep_1.default(smartTransaction);
        updatedSmartTransaction = Object.assign(Object.assign({}, cloneDeep_1.default(prevSmartTransaction)), updatedSmartTransaction);
        if (!updatedSmartTransaction.swapMetaData ||
            (updatedSmartTransaction.status === prevSmartTransaction.status &&
                prevSmartTransaction.swapMetaData)) {
            return; // If status hasn't changed, don't track it again.
        }
        const sensitiveProperties = {
            stx_status: updatedSmartTransaction.status,
            token_from_address: (_a = updatedSmartTransaction.txParams) === null || _a === void 0 ? void 0 : _a.from,
            token_from_symbol: updatedSmartTransaction.sourceTokenSymbol,
            token_to_address: (_b = updatedSmartTransaction.txParams) === null || _b === void 0 ? void 0 : _b.to,
            token_to_symbol: updatedSmartTransaction.destinationTokenSymbol,
            processing_time: utils_1.getStxProcessingTime(updatedSmartTransaction.time),
            stx_enabled: true,
            stx_user_opt_in: true,
        };
        this.trackMetaMetricsEvent({
            event: 'STX Status Updated',
            category: 'swaps',
            sensitiveProperties,
        });
    }
    isNewSmartTransaction(smartTransactionUuid) {
        const { chainId } = this.config;
        const { smartTransactionsState } = this.state;
        const { smartTransactions } = smartTransactionsState;
        const currentSmartTransactions = smartTransactions[chainId];
        const currentIndex = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.findIndex((stx) => stx.uuid === smartTransactionUuid);
        return currentIndex === -1 || currentIndex === undefined;
    }
    updateSmartTransaction(smartTransaction) {
        const { chainId } = this.config;
        const { smartTransactionsState } = this.state;
        const { smartTransactions } = smartTransactionsState;
        const currentSmartTransactions = smartTransactions[chainId];
        const currentIndex = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.findIndex((stx) => stx.uuid === smartTransaction.uuid);
        const isNewSmartTransaction = this.isNewSmartTransaction(smartTransaction.uuid);
        this.trackStxStatusChange(smartTransaction, isNewSmartTransaction
            ? undefined
            : currentSmartTransactions[currentIndex]);
        if (isNewSmartTransaction) {
            // add smart transaction
            const cancelledNonceIndex = currentSmartTransactions.findIndex((stx) => {
                var _a, _b, _c;
                return ((_a = stx.txParams) === null || _a === void 0 ? void 0 : _a.nonce) === ((_b = smartTransaction.txParams) === null || _b === void 0 ? void 0 : _b.nonce) &&
                    ((_c = stx.status) === null || _c === void 0 ? void 0 : _c.startsWith('cancelled'));
            });
            const snapshot = cloneDeep_1.default(smartTransaction);
            const history = [snapshot];
            const historifiedSmartTransaction = Object.assign(Object.assign({}, smartTransaction), { history });
            const nextSmartTransactions = cancelledNonceIndex > -1
                ? currentSmartTransactions
                    .slice(0, cancelledNonceIndex)
                    .concat(currentSmartTransactions.slice(cancelledNonceIndex + 1))
                    .concat(historifiedSmartTransaction)
                : currentSmartTransactions.concat(historifiedSmartTransaction);
            this.update({
                smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [chainId]: nextSmartTransactions }) }),
            });
            return;
        }
        if ((smartTransaction.status === types_1.SmartTransactionStatuses.SUCCESS ||
            smartTransaction.status === types_1.SmartTransactionStatuses.REVERTED) &&
            !smartTransaction.confirmed) {
            // confirm smart transaction
            const currentSmartTransaction = currentSmartTransactions[currentIndex];
            const nextSmartTransaction = Object.assign(Object.assign({}, currentSmartTransaction), smartTransaction);
            this.confirmSmartTransaction(nextSmartTransaction);
        }
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [chainId]: smartTransactionsState.smartTransactions[chainId].map((item, index) => {
                        return index === currentIndex
                            ? Object.assign(Object.assign({}, item), smartTransaction) : item;
                    }) }) }),
        });
    }
    async updateSmartTransactions() {
        const { smartTransactions } = this.state.smartTransactionsState;
        const { chainId } = this.config;
        const currentSmartTransactions = smartTransactions === null || smartTransactions === void 0 ? void 0 : smartTransactions[chainId];
        const transactionsToUpdate = currentSmartTransactions
            .filter(utils_1.isSmartTransactionPending)
            .map((smartTransaction) => smartTransaction.uuid);
        if (transactionsToUpdate.length > 0) {
            this.fetchSmartTransactionsStatus(transactionsToUpdate);
        }
    }
    async confirmSmartTransaction(smartTransaction) {
        var _a, _b, _c;
        const txHash = (_a = smartTransaction.statusMetadata) === null || _a === void 0 ? void 0 : _a.minedHash;
        try {
            const transactionReceipt = await this.ethersProvider.getTransactionReceipt(txHash);
            const transaction = await this.ethersProvider.getTransaction(txHash);
            const maxFeePerGas = (_b = transaction.maxFeePerGas) === null || _b === void 0 ? void 0 : _b.toHexString();
            const maxPriorityFeePerGas = (_c = transaction.maxPriorityFeePerGas) === null || _c === void 0 ? void 0 : _c.toHexString();
            if (transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockNumber) {
                const blockData = await this.ethersProvider.getBlock(transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockNumber, false);
                const baseFeePerGas = blockData === null || blockData === void 0 ? void 0 : blockData.baseFeePerGas.toHexString();
                const txReceipt = mapValues_1.default(transactionReceipt, (value) => {
                    if (value instanceof ethers_1.ethers.BigNumber) {
                        return value.toHexString();
                    }
                    return value;
                });
                const updatedTxParams = Object.assign(Object.assign({}, smartTransaction.txParams), { maxFeePerGas,
                    maxPriorityFeePerGas });
                // call confirmExternalTransaction
                const originalTxMeta = Object.assign(Object.assign({}, smartTransaction), { id: smartTransaction.uuid, status: 'confirmed', hash: txHash, txParams: updatedTxParams });
                // create txMeta snapshot for history
                const snapshot = utils_1.snapshotFromTxMeta(originalTxMeta);
                // recover previous tx state obj
                const previousState = utils_1.replayHistory(originalTxMeta.history);
                // generate history entry and add to history
                const entry = utils_1.generateHistoryEntry(previousState, snapshot, 'txStateManager: setting status to confirmed');
                const txMeta = entry.length > 0
                    ? Object.assign(Object.assign({}, originalTxMeta), { history: originalTxMeta.history.concat(entry) }) : originalTxMeta;
                this.confirmExternalTransaction(txMeta, txReceipt, baseFeePerGas);
                this.trackMetaMetricsEvent({
                    event: 'STX Confirmed',
                    category: 'swaps',
                });
                this.updateSmartTransaction(Object.assign(Object.assign({}, smartTransaction), { confirmed: true }));
            }
        }
        catch (e) {
            this.trackMetaMetricsEvent({
                event: 'STX Confirmation Failed',
                category: 'swaps',
            });
            console.error('confirm error', e);
        }
    }
    // ! Ask backend API to accept list of uuids as params
    async fetchSmartTransactionsStatus(uuids) {
        const { chainId } = this.config;
        const params = new URLSearchParams({
            uuids: uuids.join(','),
        });
        const url = `${utils_1.getAPIRequestURL(types_1.APIType.BATCH_STATUS, chainId)}?${params.toString()}`;
        const data = await this.fetch(url);
        Object.entries(data).forEach(([uuid, smartTransaction]) => {
            this.updateSmartTransaction({
                statusMetadata: smartTransaction,
                status: utils_1.calculateStatus(smartTransaction),
                uuid,
            });
        });
        return data;
    }
    async addNonceToTransaction(transaction) {
        const nonceLock = await this.getNonceLock(transaction.from);
        const nonce = nonceLock.nextNonce;
        nonceLock.releaseLock();
        return Object.assign(Object.assign({}, transaction), { nonce: `0x${nonce.toString(16)}` });
    }
    async getFees(unsignedTransaction) {
        const { chainId } = this.config;
        const unsignedTransactionWithNonce = await this.addNonceToTransaction(unsignedTransaction);
        const data = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.GET_FEES, chainId), {
            method: 'POST',
            body: JSON.stringify({
                tx: unsignedTransactionWithNonce,
            }),
        });
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { fees: data }),
        });
        return data;
    }
    async estimateGas(unsignedTransaction, approveTxParams) {
        const { chainId } = this.config;
        let approvalTxData;
        if (approveTxParams) {
            const unsignedApprovalTransactionWithNonce = await this.addNonceToTransaction(approveTxParams);
            approvalTxData = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.ESTIMATE_GAS, chainId), {
                method: 'POST',
                body: JSON.stringify({
                    tx: unsignedApprovalTransactionWithNonce,
                }),
            });
        }
        const unsignedTransactionWithNonce = await this.addNonceToTransaction(unsignedTransaction);
        const data = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.ESTIMATE_GAS, chainId), {
            method: 'POST',
            body: JSON.stringify(Object.assign({ tx: unsignedTransactionWithNonce }, (approveTxParams && { pending_txs: [approveTxParams] }))),
        });
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { estimatedGas: {
                    txData: data,
                    approvalTxData,
                } }),
        });
        return data;
    }
    // * After this successful call client must add a nonce representative to
    // * transaction controller external transactions list
    async submitSignedTransactions({ txParams, signedTransactions, signedCanceledTransactions, }) {
        const { chainId } = this.config;
        const data = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.SUBMIT_TRANSACTIONS, chainId), {
            method: 'POST',
            body: JSON.stringify({
                rawTxs: signedTransactions,
                rawCancelTxs: signedCanceledTransactions,
            }),
        });
        const time = Date.now();
        const metamaskNetworkId = this.getNetwork();
        let preTxBalance;
        try {
            const preTxBalanceBN = await this.ethersProvider.getBalance(txParams === null || txParams === void 0 ? void 0 : txParams.from);
            preTxBalance = new bignumber_js_1.BigNumber(preTxBalanceBN.toHexString()).toString(16);
        }
        catch (e) {
            console.error('ethers error', e);
        }
        const nonceLock = await this.getNonceLock(txParams === null || txParams === void 0 ? void 0 : txParams.from);
        const nonce = ethers_1.ethers.utils.hexlify(nonceLock.nextNonce);
        if (txParams && !(txParams === null || txParams === void 0 ? void 0 : txParams.nonce)) {
            txParams.nonce = nonce;
        }
        const { nonceDetails } = nonceLock;
        this.updateSmartTransaction({
            chainId,
            nonceDetails,
            metamaskNetworkId,
            preTxBalance,
            status: types_1.SmartTransactionStatuses.PENDING,
            time,
            txParams,
            uuid: data.uuid,
            cancellable: true,
        });
        setTimeout(() => {
            if (!this.isNewSmartTransaction(data.uuid)) {
                // Only do this for an existing smart transaction. If an STX is not in the list anymore
                // (e.g. because it was cancelled and a new one was submitted, which deletes the first one),
                // do not try to update the old one, because it would create a new one with most
                // of the required STX params missing. It would only have "uuid" and "cancellable" params.
                this.updateSmartTransaction({
                    uuid: data.uuid,
                    cancellable: false,
                });
            }
        }, exports.CANCELLABLE_INTERVAL);
        nonceLock.releaseLock();
        return data;
    }
    // ! This should return if the cancellation was on chain or not (for nonce management)
    // * After this successful call client must update nonce representative
    // * in transaction controller external transactions list
    // ! Ask backend API to make this endpoint a POST
    async cancelSmartTransaction(uuid) {
        const { chainId } = this.config;
        await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.CANCEL, chainId), {
            method: 'POST',
            body: JSON.stringify({ uuid }),
        });
        this.updateSmartTransaction({
            uuid,
            status: types_1.SmartTransactionStatuses.CANCELLED_USER_CANCELLED,
        });
    }
    async fetchLiveness() {
        const { chainId } = this.config;
        let liveness = false;
        try {
            const response = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.LIVENESS, chainId));
            liveness = Boolean(response.lastBlock);
        }
        catch (e) {
            console.log('"fetchLiveness" API call failed');
        }
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { liveness }),
        });
        return liveness;
    }
    async setStatusRefreshInterval(interval) {
        if (interval !== this.config.interval) {
            this.configure({ interval }, false, false);
        }
    }
    getTransactions({ addressFrom, status, }) {
        const { smartTransactions } = this.state.smartTransactionsState;
        const { chainId } = this.config;
        const currentSmartTransactions = smartTransactions === null || smartTransactions === void 0 ? void 0 : smartTransactions[chainId];
        if (!currentSmartTransactions || currentSmartTransactions.length === 0) {
            return [];
        }
        return currentSmartTransactions.filter((stx) => {
            var _a;
            return stx.status === status && ((_a = stx.txParams) === null || _a === void 0 ? void 0 : _a.from) === addressFrom;
        });
    }
}
exports.default = SmartTransactionsController;
//# sourceMappingURL=SmartTransactionsController.js.map
      };
    };
  }
}, {package:"@metamask\\smart-transactions-controller",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\SmartTransactionsController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-lattice-keyring\node_modules\bignumber.js\bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-lattice-keyring\\node_modules\\bignumber.js\\bignumber.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\index.js", {"./client":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\client.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = exports.Client = void 0;
var client_1 = require("./client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "Constants", { enumerable: true, get: function () { return constants_1.EXTERNAL; } });

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","coinstring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\lib\\coinstring.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\hdkey\lib\hdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
}, {package:"hdkey",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js","./env/node":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\index.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\index.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {};
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});

var _node = require("./env/node");

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TrezorConnect = {
  manifest: _node.manifest,
  init: _node.init,
  getSettings: _node.getSettings,
  on: function on(type, fn) {
    _node.eventEmitter.on(type, fn);
  },
  off: function off(type, fn) {
    _node.eventEmitter.removeListener(type, fn);
  },
  removeAllListeners: function removeAllListeners() {
    _node.eventEmitter.removeAllListeners();
  },
  uiResponse: _node.uiResponse,
  // methods
  blockchainGetAccountBalanceHistory: function blockchainGetAccountBalanceHistory(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetAccountBalanceHistory'
    }, params));
  },
  blockchainGetCurrentFiatRates: function blockchainGetCurrentFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetCurrentFiatRates'
    }, params));
  },
  blockchainGetFiatRatesForTimestamps: function blockchainGetFiatRatesForTimestamps(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetFiatRatesForTimestamps'
    }, params));
  },
  blockchainDisconnect: function blockchainDisconnect(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainDisconnect'
    }, params));
  },
  blockchainEstimateFee: function blockchainEstimateFee(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainEstimateFee'
    }, params));
  },
  blockchainGetTransactions: function blockchainGetTransactions(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetTransactions'
    }, params));
  },
  blockchainSetCustomBackend: function blockchainSetCustomBackend(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSetCustomBackend'
    }, params));
  },
  blockchainSubscribe: function blockchainSubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribe'
    }, params));
  },
  blockchainSubscribeFiatRates: function blockchainSubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribeFiatRates'
    }, params));
  },
  blockchainUnsubscribe: function blockchainUnsubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribe'
    }, params));
  },
  blockchainUnsubscribeFiatRates: function blockchainUnsubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribeFiatRates'
    }, params));
  },
  customMessage: function customMessage(params) {
    return (0, _node.customMessage)(params);
  },
  requestLogin: function requestLogin(params) {
    return (0, _node.requestLogin)(params);
  },
  cardanoGetAddress: function cardanoGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'cardanoGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  cardanoGetNativeScriptHash: function cardanoGetNativeScriptHash(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoGetNativeScriptHash'
    }, params));
  },
  cardanoGetPublicKey: function cardanoGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoGetPublicKey'
    }, params));
  },
  cardanoSignTransaction: function cardanoSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoSignTransaction'
    }, params));
  },
  cipherKeyValue: function cipherKeyValue(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cipherKeyValue'
    }, params));
  },
  composeTransaction: function composeTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'composeTransaction'
    }, params));
  },
  ethereumGetAddress: function ethereumGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'ethereumGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  ethereumGetPublicKey: function ethereumGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumGetPublicKey'
    }, params));
  },
  ethereumSignMessage: function ethereumSignMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignMessage'
    }, params));
  },
  ethereumSignTransaction: function ethereumSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignTransaction'
    }, params));
  },
  ethereumSignTypedData: function ethereumSignTypedData(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignTypedData'
    }, params));
  },
  ethereumVerifyMessage: function ethereumVerifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumVerifyMessage'
    }, params));
  },
  getAccountInfo: function getAccountInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getAccountInfo'
    }, params));
  },
  getAddress: function getAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'getAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  getDeviceState: function getDeviceState(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getDeviceState'
    }, params));
  },
  getFeatures: function getFeatures(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getFeatures'
    }, params));
  },
  getPublicKey: function getPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getPublicKey'
    }, params));
  },
  liskGetAddress: function liskGetAddress() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskGetPublicKey: function liskGetPublicKey() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskSignMessage: function liskSignMessage() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskSignTransaction: function liskSignTransaction() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskVerifyMessage: function liskVerifyMessage() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  nemGetAddress: function nemGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'nemGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  nemSignTransaction: function nemSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'nemSignTransaction'
    }, params));
  },
  pushTransaction: function pushTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'pushTransaction'
    }, params));
  },
  rippleGetAddress: function rippleGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'rippleGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  rippleSignTransaction: function rippleSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'rippleSignTransaction'
    }, params));
  },
  signMessage: function signMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signMessage'
    }, params));
  },
  signTransaction: function signTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signTransaction'
    }, params));
  },
  stellarGetAddress: function stellarGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'stellarGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  stellarSignTransaction: function stellarSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'stellarSignTransaction'
    }, params));
  },
  tezosGetAddress: function tezosGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'tezosGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  tezosGetPublicKey: function tezosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosGetPublicKey'
    }, params));
  },
  tezosSignTransaction: function tezosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosSignTransaction'
    }, params));
  },
  eosGetPublicKey: function eosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosGetPublicKey'
    }, params));
  },
  eosSignTransaction: function eosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosSignTransaction'
    }, params));
  },
  binanceGetAddress: function binanceGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'binanceGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  binanceGetPublicKey: function binanceGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceGetPublicKey'
    }, params));
  },
  binanceSignTransaction: function binanceSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceSignTransaction'
    }, params));
  },
  verifyMessage: function verifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'verifyMessage'
    }, params));
  },
  resetDevice: function resetDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'resetDevice'
    }, params));
  },
  wipeDevice: function wipeDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'wipeDevice'
    }, params));
  },
  applyFlags: function applyFlags(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applyFlags'
    }, params));
  },
  applySettings: function applySettings(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applySettings'
    }, params));
  },
  backupDevice: function backupDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'backupDevice'
    }, params));
  },
  changePin: function changePin(params) {
    return (0, _node.call)(_objectSpread({
      method: 'changePin'
    }, params));
  },
  firmwareUpdate: function firmwareUpdate(params) {
    return (0, _node.call)(_objectSpread({
      method: 'firmwareUpdate'
    }, params));
  },
  recoveryDevice: function recoveryDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'recoveryDevice'
    }, params));
  },
  getCoinInfo: function getCoinInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getCoinInfo'
    }, params));
  },
  rebootToBootloader: function rebootToBootloader(params) {
    return (0, _node.call)(_objectSpread({
      method: 'rebootToBootloader'
    }, params));
  },
  dispose: _node.dispose,
  cancel: _node.cancel,
  renderWebUSBButton: _node.renderWebUSBButton,
  disableWebUSB: _node.disableWebUSB
};
var _default = TrezorConnect;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\plugins\\ethereum\\typedData.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\plugins\ethereum\typedData.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// eslint-disable-next-line import/no-unresolved
var sigUtil = require('@metamask/eth-sig-util'); // Sanitization is used for T1 as eth-sig-util does not support BigInt


function sanitizeData(data) {
  switch (Object.prototype.toString.call(data)) {
    case '[object Object]':
      {
        var entries = Object.keys(data).map(function (k) {
          return [k, sanitizeData(data[k])];
        });
        return Object.fromEntries(entries);
      }

    case '[object Array]':
      return data.map(function (v) {
        return sanitizeData(v);
      });

    case '[object BigInt]':
      return data.toString();

    default:
      return data;
  }
}

var transformTypedData = function transformTypedData(data, metamask_v4_compat) {
  if (!metamask_v4_compat) {
    throw new Error('Trezor: Only version 4 of typed data signing is supported');
  }

  var version = sigUtil.SignTypedDataVersion.V4;

  var _sigUtil$TypedDataUti = sigUtil.TypedDataUtils.sanitizeData(data),
      types = _sigUtil$TypedDataUti.types,
      primaryType = _sigUtil$TypedDataUti.primaryType,
      domain = _sigUtil$TypedDataUti.domain,
      message = _sigUtil$TypedDataUti.message;

  var domainSeparatorHash = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', sanitizeData(domain), types, version).toString('hex');
  var messageHash = sigUtil.TypedDataUtils.hashStruct(primaryType, sanitizeData(message), types, version).toString('hex');
  return _objectSpread({
    domain_separator_hash: domainSeparatorHash,
    message_hash: messageHash
  }, data);
};

module.exports = transformTypedData;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\plugins\\ethereum\\typedData.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\index.js", {"./ExternalResourceController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\ExternalResourceController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\resource\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ExternalResourceController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\index.js", {"./SubjectMetadataController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\SubjectMetadataController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\subject-metadata\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SubjectMetadataController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\index.js", {"./Caveat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Caveat.js","./Permission":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Permission.js","./PermissionController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\PermissionController.js","./endowments":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\index.js","./rpc-methods":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\index.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.endowmentPermissionBuilders = exports.permissionRpcMethods = void 0;
__exportStar(require("./Caveat"), exports);
__exportStar(require("./Permission"), exports);
__exportStar(require("./PermissionController"), exports);
__exportStar(require("./utils"), exports);
// TODO: Move these to the appropriate package
exports.permissionRpcMethods = __importStar(require("./rpc-methods"));
var endowments_1 = require("./endowments");
Object.defineProperty(exports, "endowmentPermissionBuilders", { enumerable: true, get: function () { return endowments_1.endowmentPermissionBuilders; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\index.js", {"./SnapController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\SnapController.js","./json-schemas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\index.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SnapController"), exports);
__exportStar(require("./json-schemas"), exports);
__exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\index.js", {"./AbstractExecutionService":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\AbstractExecutionService.js","./ExecutionService":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\ExecutionService.js","./WebWorkerExecutionService":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\WebWorkerExecutionService.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\services\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AbstractExecutionService"), exports);
__exportStar(require("./ExecutionService"), exports);
__exportStar(require("./WebWorkerExecutionService"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\createMethodMiddleware.js", {"../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","./handlers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\index.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/rpc-methods":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\index.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\createMethodMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMethodMiddleware = createMethodMiddleware;

var _lodash = require("lodash");

var _snapControllers = require("@metamask/snap-controllers");

var _rpcMethods = require("@metamask/rpc-methods");

var _ethRpcErrors = require("eth-rpc-errors");

var _network = require("../../../../shared/constants/network");

var _handlers = _interopRequireDefault(require("./handlers"));

const allHandlers = [..._handlers.default, ..._snapControllers.permissionRpcMethods.handlers];
const handlerMap = allHandlers.reduce((map, handler) => {
  for (const methodName of handler.methodNames) {
    map.set(methodName, handler);
  }

  return map;
}, new Map());
const expectedHookNames = Array.from(new Set((0, _lodash.flatten)(allHandlers.map(({
  hookNames
}) => Object.keys(hookNames)))).values());
/**
 * Creates a json-rpc-engine middleware of RPC method implementations.
 *
 * Handlers consume functions that hook into the background, and only depend
 * on their signatures, not e.g. controller internals.
 *
 * @param {Record<string, unknown>} hooks - Required "hooks" into our
 * controllers.
 * @returns {(req: Object, res: Object, next: Function, end: Function) => void}
 */

function createMethodMiddleware(hooks) {
  // Fail immediately if we forgot to provide any expected hooks.
  const missingHookNames = expectedHookNames.filter(hookName => !Object.hasOwnProperty.call(hooks, hookName));

  if (missingHookNames.length > 0) {
    throw new Error(`Missing expected hooks:\n\n${missingHookNames.join('\n')}\n`);
  }

  return async function methodMiddleware(req, res, next, end) {
    // Reject unsupported methods.
    if (_network.UNSUPPORTED_RPC_METHODS.has(req.method)) {
      return end(_ethRpcErrors.ethErrors.rpc.methodNotSupported());
    }

    const handler = handlerMap.get(req.method);

    if (handler) {
      const {
        implementation,
        hookNames
      } = handler;

      try {
        // Implementations may or may not be async, so we must await them.
        return await implementation(req, res, next, end, (0, _rpcMethods.selectHooks)(hooks, hookNames));
      } catch (error) {
        console.error(error);
        return end(error);
      }
    }

    return next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\createMethodMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/base-eth-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\dist\metamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h),{r:g,s:m,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),p=t.toJSON();return p.v=d,p.s=m,p.r=g,p.type=t.type,c.TransactionFactory.fromTxData(p,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\metamask-airgapped-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/base-eth-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\dist\metamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on('keystone-sync_success-hdkey', cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on('keystone-sync_success-account', cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on('keystone-sync_cancel', () => {
          this.resetState();
          reject(new Error('KeystoneError#sync_cancel. Sync process canceled, please retry'));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit('keystone-sync_success-hdkey', cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit('keystone-sync_success-account', cbor);
    };

    this.cancelSync = () => {
      this.emit('keystone-sync_cancel');
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString('hex')
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error('KeystoneError#Tx_canceled. Signing canceled, please retry'));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = 'QR Hardware';
      this.initialized = false; //hd props;

      this.xfp = '';
      this.xpub = '';
      this.hdPath = '';
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\metamask-airgapped-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\development\\mock-3box.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\development\mock-3box.js
      return function (require, module, exports) {
"use strict";

function delay(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

async function loadFromMock3Box(key) {
  const res = await window.fetch(`http://localhost:8889?key=${key}`);
  const text = await res.text();
  return text.length ? JSON.parse(text) : null;
}

async function saveToMock3Box(key, newDataAtKey) {
  const res = await window.fetch('http://localhost:8889', {
    method: 'POST',
    body: JSON.stringify({
      key,
      data: newDataAtKey
    })
  });
  return res.text();
}

class Mock3Box {
  static openBox(address) {
    this.address = address;
    return Promise.resolve({
      onSyncDone: cb => {
        setTimeout(cb, 200);
      },
      openSpace: async (spaceName, config) => {
        const {
          onSyncDone
        } = config;
        this.spaceName = spaceName;
        setTimeout(onSyncDone, 150);
        await delay(50);
        return {
          private: {
            get: async key => {
              await delay(50);
              const res = await loadFromMock3Box(`${this.address}-${this.spaceName}-${key}`);
              return res;
            },
            set: async (key, data) => {
              await saveToMock3Box(`${this.address}-${this.spaceName}-${key}`, data);
              await delay(50);
              return null;
            }
          }
        };
      },
      logout: () => undefined
    });
  }

  static async getConfig(address) {
    const backup = await loadFromMock3Box(`${address}-metamask-metamaskBackup`);
    return backup ? {
      spaces: {
        metamask: {}
      }
    } : {};
  }

}

module.exports = Mock3Box;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\development\\mock-3box.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createMetamaskMiddleware.js", {"./middleware/pending":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\middleware\\pending.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\createMetamaskMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMetamaskMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _pending = require("./middleware/pending");

function createMetamaskMiddleware({
  version,
  getAccounts,
  processTransaction,
  processEthSignMessage,
  processTypedMessage,
  processTypedMessageV3,
  processTypedMessageV4,
  processPersonalMessage,
  processDecryptMessage,
  processEncryptionPublicKey,
  getPendingNonce,
  getPendingTransactionByHash
}) {
  const metamaskMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([(0, _jsonRpcEngine.createScaffoldMiddleware)({
    eth_syncing: false,
    web3_clientVersion: `MetaMask/v${version}`
  }), (0, _ethJsonRpcMiddleware.createWalletMiddleware)({
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processDecryptMessage,
    processEncryptionPublicKey
  }), (0, _pending.createPendingNonceMiddleware)({
    getPendingNonce
  }), (0, _pending.createPendingTxMiddleware)({
    getPendingTransactionByHash
  })]);
  return metamaskMiddleware;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createMetamaskMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3box.js", {"./3id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\index.js","./api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\api.js","./config.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js","./privateStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\privateStore.js","./publicStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\publicStore.js","./space":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\space.js","./utils/id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\id.js","./utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","./verified":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\verified.js","3box-orbitdb-plugins":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/slicedToArray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\slicedToArray.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","ipfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\index.js","orbit-db":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\OrbitDB.js","orbit-db-access-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\index.js","orbit-db-pubsub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\index.js","store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\dist\\store.legacy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\3box.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var AccessControllers = require('orbit-db-access-controllers');

var _require = require('3box-orbitdb-plugins'),
    LegacyIPFS3BoxAccessController = _require.LegacyIPFS3BoxAccessController,
    ThreadAccessController = _require.ThreadAccessController,
    ModeratorAccessController = _require.ModeratorAccessController;

AccessControllers.addAccessController({
  AccessController: LegacyIPFS3BoxAccessController
});
AccessControllers.addAccessController({
  AccessController: ThreadAccessController
});
AccessControllers.addAccessController({
  AccessController: ModeratorAccessController
});

var ThreeId = require('./3id');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var idUtils = require('./utils/id');

var config = require('./config.js');

var API = require('./api');

var ACCOUNT_TYPES = {
  ethereum: 'ethereum',
  ethereumEOA: 'ethereum-eoa'
};
var ADDRESS_SERVER_URL = config.address_server_url;
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = config.ipfs_options;
var ORBITDB_OPTS = config.orbitdb_options;
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(threeId, ethereumProvider, ipfs) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Box);
    this._3id = threeId;
    this._web3provider = ethereumProvider;
    this._ipfs = ipfs;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};

    this._boxSynced = false;
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this["private"] = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    this.verified = new Verified(this);
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    this.spaces = {}; // local store of all pinning server pubsub messages seen related to spaces

    this.spacesPubSubMessages = {};
  }

  (0, _createClass2["default"])(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var _this = this;

        var opts,
            rootStoreName,
            key,
            rootStoreAddress,
            onNewPeer,
            _ref2,
            _ref3,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            spaceMessageFilterActive,
            filterTimeSet,
            onMessageRes,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                rootStoreName = this._3id.muportFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;

                this._ipfs.swarm.connect(this.pinningNode, function () {});

                _context3.t0 = OrbitDB;
                _context3.t1 = this._ipfs;
                _context3.t2 = opts.orbitPath;
                _context3.next = 9;
                return this._3id.getOdbId();

              case 9:
                _context3.t3 = _context3.sent;
                _context3.t4 = {
                  directory: _context3.t2,
                  identity: _context3.t3
                };
                _context3.next = 13;
                return _context3.t0.createInstance.call(_context3.t0, _context3.t1, _context3.t4);

              case 13:
                this._orbitdb = _context3.sent;
                // , { cache })
                globalOrbitDB = this._orbitdb;
                key = this._3id.getKeyringBySpaceName(rootStoreName).getPublicKeys(true).signingKey;
                _context3.next = 18;
                return this._orbitdb.feed(rootStoreName, _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                }));

              case 18:
                this._rootStore = _context3.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context3.t5 = Pubsub;
                _context3.t6 = this._ipfs;
                _context3.next = 24;
                return this._ipfs.id();

              case 24:
                _context3.t7 = _context3.sent.id;
                this._pubsub = new _context3.t5(_context3.t6, _context3.t7);

                onNewPeer =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee(topic, peer) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (peer === _this.pinningNode.split('/').pop()) {
                              _this._pubsub.publish(PINNING_ROOM, {
                                type: 'PIN_DB',
                                odbAddress: rootStoreAddress,
                                did: _this.DID
                              });
                            }

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function onNewPeer(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                this["public"] = new PublicStore(this._orbitdb, this._3id.muportFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this), this._3id);
                this["private"] = new PrivateStore(this._orbitdb, this._3id.muportFingerprint + '.private', this._ensurePinningNodeConnected.bind(this), this._3id);
                _context3.next = 31;
                return Promise.all([this["public"]._load(), this["private"]._load()]);

              case 31:
                _ref2 = _context3.sent;
                _ref3 = (0, _slicedToArray2["default"])(_ref2, 2);
                pubStoreAddress = _ref3[0];
                privStoreAddress = _ref3[1];
                syncPromises = [];
                hasResponse = {}; // Filters and store space related messages for 3secs, the best effort
                // simple approach, until refactor

                spaceMessageFilterActive = true;
                filterTimeSet = false;

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee2(topic, data) {
                    var promises;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!filterTimeSet) {
                              filterTimeSet = true;
                              setTimeout(function () {
                                spaceMessageFilterActive = false;
                              }, 3000);
                            }

                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context2.next = 12;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this["private"]._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this["public"]._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (spaceMessageFilterActive && data.odbAddress.includes('space') === true) {
                              _this.spacesPubSubMessages[data.odbAddress] = data;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context2.next = 12;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context2.next = 10;
                            return Promise.all(promises);

                          case 10:
                            _this._boxSynced = true;

                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function onMessageRes(_x4, _x5) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                _context3.next = 43;
                return this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 43:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _load() {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var _this2 = this;

        var entries, pinAddressLinks;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._rootStore.load();

              case 2:
                _context5.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context5.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

                pinAddressLinks =
                /*#__PURE__*/
                function () {
                  var _ref5 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4() {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            // Filter for address-links, get CID, and get to pin it
                            entries.filter(function (entry) {
                              return entry.payload.value.type === 'address-link';
                            }).map(function (entry) {
                              _this2._ipfs.dag.get(entry.payload.value.data);
                            });

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function pinAddressLinks() {
                    return _ref5.apply(this, arguments);
                  };
                }();

                pinAddressLinks();

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _createRootStore(_x6, _x7, _x8) {
        return _createRootStore2.apply(this, arguments);
      }

      return _createRootStore;
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(name) {
        var opts,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (this.spaces[name]) {
                  _context6.next = 23;
                  break;
                }

                this.spaces[name] = new Space(name, this._3id, this._orbitdb, this._rootStore, this._ensurePinningNodeConnected.bind(this));
                _context6.prev = 3;
                opts = Object.assign({
                  numEntriesMessages: this.spacesPubSubMessages
                }, opts);
                _context6.next = 7;
                return this.spaces[name].open(opts);

              case 7:
                _context6.next = 9;
                return this.isAddressLinked();

              case 9:
                if (_context6.sent) {
                  _context6.next = 11;
                  break;
                }

                this.linkAddress();

              case 11:
                _context6.next = 21;
                break;

              case 13:
                _context6.prev = 13;
                _context6.t0 = _context6["catch"](3);
                delete this.spaces[name];

                if (!_context6.t0.message.includes('User denied message signature.')) {
                  _context6.next = 20;
                  break;
                }

                throw new Error('User denied space consent.');

              case 20:
                throw new Error('An error occured while opening space: ', _context6.t0.message);

              case 21:
                _context6.next = 24;
                break;

              case 23:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 24:
                return _context6.abrupt("return", this.spaces[name]);

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 13]]);
      }));

      function openSpace(_x9) {
        return _openSpace.apply(this, arguments);
      }

      return openSpace;
    }()
    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */

  }, {
    key: "onSyncDone",
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;

      if (this._boxSynced) {
        this._onSyncDoneCB();
      }
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(rootStoreAddress) {
        var addressToken;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context7.sent;
                _context7.prev = 3;
                _context7.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context7.next = 12;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);

                if (_context7.t0.statusCode) {
                  _context7.next = 12;
                  break;
                }

                throw new Error(_context7.t0);

              case 12:
                return _context7.abrupt("return", true);

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function _publishRootStore(_x10) {
        return _publishRootStore2.apply(this, arguments);
      }

      return _publishRootStore;
    }()
    /**
     * @property {String} DID        the DID of the user
     */

  }, {
    key: "linkAddress",

    /**
     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.
     *
     * @param     {Object}    [link]                         Optional link object with type or proof
     * @param     {String}    [link.type='ethereum-eoa']     The type of link (default 'ethereum')
     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)
     */
    value: function () {
      var _linkAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var link,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                link = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                if (!link.proof) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 4;
                return this._writeAddressLink(link.proof);

              case 4:
                return _context8.abrupt("return");

              case 5:
                if (!(!link.type || link.type === ACCOUNT_TYPES.ethereumEOA)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 8;
                return this._linkProfile();

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function linkAddress() {
        return _linkAddress.apply(this, arguments);
      }

      return linkAddress;
    }()
  }, {
    key: "linkAccount",
    value: function () {
      var _linkAccount = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9() {
        var type,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                type = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('linkAccount: deprecated, please use linkAddress going forward');
                _context9.next = 4;
                return this.linkAddress(type);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function linkAccount() {
        return _linkAccount.apply(this, arguments);
      }

      return linkAccount;
    }()
    /**
     * Remove given address link, returns true if successful
     *
     * @param     {String}   address      address that is linked
     */

  }, {
    key: "removeAddressLink",
    value: function () {
      var _removeAddressLink = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(address) {
        var linkExist, payload, oneHour, deleteToken;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                address = address.toLowerCase();
                _context10.next = 3;
                return this.isAddressLinked({
                  address: address
                });

              case 3:
                linkExist = _context10.sent;

                if (linkExist) {
                  _context10.next = 6;
                  break;
                }

                throw new Error('removeAddressLink: link for given address does not exist');

              case 6:
                payload = {
                  address: address,
                  type: "delete-address-link"
                };
                oneHour = 60 * 60;
                _context10.next = 10;
                return this._3id.signJWT(payload, {
                  expiresIn: oneHour
                });

              case 10:
                deleteToken = _context10.sent;
                _context10.prev = 11;
                _context10.next = 14;
                return utils.fetchJson(this._serverUrl + '/linkdelete', {
                  delete_token: deleteToken
                });

              case 14:
                _context10.next = 20;
                break;

              case 16:
                _context10.prev = 16;
                _context10.t0 = _context10["catch"](11);

                if (_context10.t0.statusCode) {
                  _context10.next = 20;
                  break;
                }

                throw new Error(_context10.t0);

              case 20:
                _context10.next = 22;
                return this._deleteAddressLink(address);

              case 22:
                return _context10.abrupt("return", true);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 16]]);
      }));

      function removeAddressLink(_x11) {
        return _removeAddressLink.apply(this, arguments);
      }

      return removeAddressLink;
    }()
    /**
     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true
     *
     * @param     {Object}    [query]            Optional object with address and/or type.
     * @param     {String}    [query.type]       Does the given type of link exist
     * @param     {String}    [query.address]    Is the given adressed linked
     */

  }, {
    key: "isAddressLinked",
    value: function () {
      var _isAddressLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var query,
            links,
            linksQuery,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                query = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};
                if (query.address) query.address = query.address.toLowerCase();
                _context11.next = 4;
                return this._readAddressLinks();

              case 4:
                links = _context11.sent;
                linksQuery = links.find(function (link) {
                  var res = query.address ? link.address === query.address : true;
                  return query.type ? res && link.type === query.type : res;
                });
                return _context11.abrupt("return", Boolean(linksQuery));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function isAddressLinked() {
        return _isAddressLinked.apply(this, arguments);
      }

      return isAddressLinked;
    }()
  }, {
    key: "isAccountLinked",
    value: function () {
      var _isAccountLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        var type,
            _args12 = arguments;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                type = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('isAccountLinked: deprecated, please use isAddressLinked going forward');
                return _context12.abrupt("return", this.isAddressLinked(type));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function isAccountLinked() {
        return _isAccountLinked.apply(this, arguments);
      }

      return isAccountLinked;
    }()
    /**
     * Lists address links associated with this 3Box
     *
     * @return    {Array}                        An array of link objects
     */

  }, {
    key: "listAddressLinks",
    value: function () {
      var _listAddressLinks = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._readAddressLinks();

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", entries.reduce(function (list, entry) {
                  var item = Object.assign({}, entry);
                  item.linkId = item.entry.hash;
                  delete item.entry;
                  return item;
                }, []));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function listAddressLinks() {
        return _listAddressLinks.apply(this, arguments);
      }

      return listAddressLinks;
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var address, linkData, did, consent;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                address = this._3id.managementAddress;
                _context14.next = 3;
                return this._readAddressLink(address);

              case 3:
                linkData = _context14.sent;

                if (linkData) {
                  _context14.next = 19;
                  break;
                }

                did = this.DID;
                _context14.prev = 6;
                _context14.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context14.sent;
                _context14.next = 16;
                break;

              case 12:
                _context14.prev = 12;
                _context14.t0 = _context14["catch"](6);
                console.log(_context14.t0);
                throw new Error('Link consent message must be signed before adding data, to link address to store');

              case 16:
                linkData = {
                  version: 1,
                  type: ACCOUNT_TYPES.ethereumEOA,
                  message: consent.msg,
                  signature: consent.sig,
                  timestamp: consent.timestamp
                };
                _context14.next = 19;
                return this._writeAddressLink(linkData);

              case 19:
                _context14.next = 21;
                return this["public"].get('proof_did');

              case 21:
                if (_context14.sent) {
                  _context14.next = 29;
                  break;
                }

                _context14.t1 = this["public"];
                _context14.next = 25;
                return this._3id.signJWT();

              case 25:
                _context14.t2 = _context14.sent;
                _context14.t3 = {
                  noLink: true
                };
                _context14.next = 29;
                return _context14.t1.set.call(_context14.t1, 'proof_did', _context14.t2, _context14.t3);

              case 29:
                // Send consentSignature to 3box-address-server to link profile with ethereum address
                utils.fetchJson(this._serverUrl + '/link', linkData)["catch"](console.error);

              case 30:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[6, 12]]);
      }));

      function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      }

      return _linkProfile;
    }()
  }, {
    key: "_writeAddressLink",
    value: function () {
      var _writeAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(proof) {
        var data, linkExist, link;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._ipfs.dag.put(proof);

              case 2:
                data = _context15.sent.toBaseEncodedString();
                _context15.next = 5;
                return this._linkCIDExists(data);

              case 5:
                linkExist = _context15.sent;

                if (!linkExist) {
                  _context15.next = 8;
                  break;
                }

                return _context15.abrupt("return");

              case 8:
                link = {
                  type: 'address-link',
                  data: data
                };
                _context15.next = 11;
                return this._rootStore.add(link);

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _writeAddressLink(_x12) {
        return _writeAddressLink2.apply(this, arguments);
      }

      return _writeAddressLink;
    }()
  }, {
    key: "_linkCIDExists",
    value: function () {
      var _linkCIDExists2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(cid) {
        var entries, linkEntries;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context16.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                return _context16.abrupt("return", linkEntries.find(function (entry) {
                  return entry.data === cid;
                }));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _linkCIDExists(_x13) {
        return _linkCIDExists2.apply(this, arguments);
      }

      return _linkCIDExists;
    }()
  }, {
    key: "_deleteAddressLink",
    value: function () {
      var _deleteAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(address) {
        var link;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                address = address.toLowerCase();
                _context17.next = 3;
                return this._readAddressLink(address);

              case 3:
                link = _context17.sent;

                if (link) {
                  _context17.next = 6;
                  break;
                }

                throw new Error('_deleteAddressLink: link for given address does not exist');

              case 6:
                return _context17.abrupt("return", this._rootStore.remove(link.entry.hash));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _deleteAddressLink(_x14) {
        return _deleteAddressLink2.apply(this, arguments);
      }

      return _deleteAddressLink;
    }()
  }, {
    key: "_readAddressLinks",
    value: function () {
      var _readAddressLinks2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var _this3 = this;

        var entries, linkEntries, resolveLinks;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context19.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                resolveLinks = linkEntries.map(
                /*#__PURE__*/
                function () {
                  var _ref6 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee18(entry) {
                    var obj;
                    return _regenerator["default"].wrap(function _callee18$(_context18) {
                      while (1) {
                        switch (_context18.prev = _context18.next) {
                          case 0:
                            _context18.next = 2;
                            return _this3._ipfs.dag.get(entry.payload.value.data);

                          case 2:
                            obj = _context18.sent.value;

                            if (obj.address) {
                              _context18.next = 7;
                              break;
                            }

                            _context18.next = 6;
                            return utils.recoverPersonalSign(obj.message, obj.signature);

                          case 6:
                            obj.address = _context18.sent;

                          case 7:
                            obj.entry = entry;
                            return _context18.abrupt("return", obj);

                          case 9:
                          case "end":
                            return _context18.stop();
                        }
                      }
                    }, _callee18);
                  }));

                  return function (_x15) {
                    return _ref6.apply(this, arguments);
                  };
                }());
                return _context19.abrupt("return", Promise.all(resolveLinks));

              case 6:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _readAddressLinks() {
        return _readAddressLinks2.apply(this, arguments);
      }

      return _readAddressLinks;
    }()
  }, {
    key: "_readAddressLink",
    value: function () {
      var _readAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee20(address) {
        var links;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                address = address.toLowerCase();
                _context20.next = 3;
                return this._readAddressLinks();

              case 3:
                links = _context20.sent;
                return _context20.abrupt("return", links.find(function (link) {
                  return link.address.toLowerCase() === address;
                }));

              case 5:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _readAddressLink(_x16) {
        return _readAddressLink2.apply(this, arguments);
      }

      return _readAddressLink;
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee21(odbAddress, isThread) {
        var _this4 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context21.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this4.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  if (isThread) {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'SYNC_DB',
                      odbAddress: odbAddress,
                      thread: true
                    });
                  } else {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'PIN_DB',
                      odbAddress: rootStoreAddress
                    });
                  }
                }

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _ensurePinningNodeConnected(_x17, _x18) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      }

      return _ensurePinningNodeConnected;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee22() {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context22.next = 4;
                return this._pubsub.disconnect();

              case 4:
                globalOrbitDB = null;

              case 5:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee23() {
        var address;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.close();

              case 2:
                this._3id.logout();

                address = this._3id.managementAddress;
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }, {
    key: "DID",
    get: function get() {
      return this._3id.muportDID;
    }
  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee24(address) {
        var opts,
            metadata,
            profile,
            normalizedAddress,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};
                metadata = opts.metadata;
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context24.next = 9;
                  break;
                }

                _context24.next = 6;
                return API.getProfile(address, opts.profileServer, {
                  metadata: metadata
                });

              case 6:
                profile = _context24.sent;
                _context24.next = 15;
                break;

              case 9:
                if (!metadata) {
                  _context24.next = 11;
                  break;
                }

                throw new Error('getting metadata is not yet supported outside of the API');

              case 11:
                normalizedAddress = address.toLowerCase();
                _context24.next = 14;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 14:
                profile = _context24.sent;

              case 15:
                return _context24.abrupt("return", profile);

              case 16:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getProfile(_x19) {
        return _getProfile.apply(this, arguments);
      }

      return getProfile;
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee25(addressArray) {
        var opts,
            _args25 = arguments;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                opts = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : {};
                return _context25.abrupt("return", API.getProfiles(addressArray, opts));

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function getProfiles(_x20) {
        return _getProfiles.apply(this, arguments);
      }

      return getProfiles;
    }()
    /**
     * Get the public data in a space of a given address with the given name
     *
     * @param     {String}    address                 An ethereum address
     * @param     {String}    name                    A space name
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the public space data
     */

  }, {
    key: "getSpace",
    value: function () {
      var _getSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee26(address, name) {
        var opts,
            _args26 = arguments;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                opts = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : {};
                return _context26.abrupt("return", API.getSpace(address, name, opts.profileServer, opts));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      }));

      function getSpace(_x21, _x22) {
        return _getSpace.apply(this, arguments);
      }

      return getSpace;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    space                   The name of the space the thread is in
     * @param     {String}    name                    The name of the thread
     * @param     {String}    firstModerator          The DID (or ethereum address) of the first moderator
     * @param     {Boolean}   members                 True if only members are allowed to post
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThread",
    value: function () {
      var _getThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee27(space, name, firstModerator, members) {
        var opts,
            _args27 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                opts = _args27.length > 4 && _args27[4] !== undefined ? _args27[4] : {};
                return _context27.abrupt("return", API.getThread(space, name, firstModerator, members, opts));

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function getThread(_x23, _x24, _x25, _x26) {
        return _getThread.apply(this, arguments);
      }

      return getThread;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    address                 The orbitdb-address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThreadByAddress",
    value: function () {
      var _getThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee28(address) {
        var opts,
            _args28 = arguments;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                opts = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : {};
                return _context28.abrupt("return", API.getThreadByAddress(address, opts));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function getThreadByAddress(_x27) {
        return _getThreadByAddress.apply(this, arguments);
      }

      return getThreadByAddress;
    }()
    /**
     * Get the configuration of a users 3Box
     *
     * @param     {String}    address                 The ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee29(address) {
        var opts,
            _args29 = arguments;
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                opts = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : {};
                return _context29.abrupt("return", API.getConfig(address, opts));

              case 2:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function getConfig(_x28) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Get the names of all spaces a user has
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            an array with all spaces as strings
     */

  }, {
    key: "listSpaces",
    value: function () {
      var _listSpaces = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee30(address) {
        var opts,
            _args30 = arguments;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : {};
                return _context30.abrupt("return", API.listSpaces(address, opts.profileServer));

              case 2:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function listSpaces(_x29) {
        return _listSpaces.apply(this, arguments);
      }

      return listSpaces;
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee32(address) {
        var opts,
            rootStoreAddress,
            usingGlobalIPFS,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args32 = arguments;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                opts = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : {};

                if (!idUtils.isMuportDID(address)) {
                  _context32.next = 3;
                  break;
                }

                throw new Error('DID are supported in the cached version only');

              case 3:
                _context32.next = 5;
                return API.getRootStoreAddress(address.toLowerCase(), opts.addressServer);

              case 5:
                rootStoreAddress = _context32.sent;
                usingGlobalIPFS = false; // let usingGlobalOrbitDB = false

                if (!globalIPFS) {
                  _context32.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context32.next = 15;
                break;

              case 12:
                _context32.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context32.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context32.next = 41;
                  break;
                }

                _context32.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context32.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context32.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context32.next = 30;
                  break;
                }

                _context32.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context32.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context32.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee31() {
                    return _regenerator["default"].wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return rootStore.close();

                          case 2:
                            _context31.next = 4;
                            return publicStore.close();

                          case 4:
                            // if (!usingGlobalOrbitDB) await orbitdb.stop()
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 5:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31);
                  }));

                  return function closeAll() {
                    return _ref7.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context32.abrupt("return", profile);

              case 41:
                return _context32.abrupt("return", null);

              case 42:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32);
      }));

      function _getProfileOrbit(_x30) {
        return _getProfileOrbit2.apply(this, arguments);
      }

      return _getProfileOrbit;
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee33(query) {
        var opts,
            _args33 = arguments;
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                opts = _args33.length > 1 && _args33[1] !== undefined ? _args33[1] : {};
                return _context33.abrupt("return", API.profileGraphQL(query, opts.graphqlServer));

              case 2:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33);
      }));

      function profileGraphQL(_x31) {
        return _profileGraphQL.apply(this, arguments);
      }

      return profileGraphQL;
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee34(profile) {
        return _regenerator["default"].wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                return _context34.abrupt("return", API.getVerifiedAccounts(profile));

              case 1:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34);
      }));

      function getVerifiedAccounts(_x32) {
        return _getVerifiedAccounts.apply(this, arguments);
      }

      return getVerifiedAccounts;
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee35(address, ethereumProvider) {
        var opts,
            ipfs,
            _3id,
            box,
            _args35 = arguments;

        return _regenerator["default"].wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                opts = _args35.length > 2 && _args35[2] !== undefined ? _args35[2] : {};
                _context35.t0 = globalIPFS;

                if (_context35.t0) {
                  _context35.next = 6;
                  break;
                }

                _context35.next = 5;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 5:
                _context35.t0 = _context35.sent;

              case 6:
                ipfs = _context35.t0;
                globalIPFS = ipfs;
                _context35.next = 10;
                return ThreeId.getIdFromEthAddress(address, ethereumProvider, ipfs, opts);

              case 10:
                _3id = _context35.sent;
                box = new Box(_3id, ethereumProvider, ipfs, opts);
                _context35.next = 14;
                return box._load(opts);

              case 14:
                return _context35.abrupt("return", box);

              case 15:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35);
      }));

      function openBox(_x33, _x34) {
        return _openBox.apply(this, arguments);
      }

      return openBox;
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return ThreeId.isLoggedIn(address);
    }
  }]);
  return Box;
}();

function initIPFS(_x35, _x36, _x37) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee36(ipfs, iframeStore, ipfsOptions) {
    return _regenerator["default"].wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context36.next = 5;
              break;
            }

            return _context36.abrupt("return", ipfs);

          case 5:
            return _context36.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));
  return _initIPFS.apply(this, arguments);
}

Box.idUtils = idUtils;
module.exports = Box;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3box.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\duplex.js", {"./core":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\core.js","./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fast-json-patch\lib\duplex.js
      return function (require, module, exports) {
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var helpers_1 = require("./helpers");
var core_1 = require("./core");
/* export all core functions and types */
var core_2 = require("./core");
exports.applyOperation = core_2.applyOperation;
exports.applyPatch = core_2.applyPatch;
exports.applyReducer = core_2.applyReducer;
exports.getValueByPointer = core_2.getValueByPointer;
exports.validate = core_2.validate;
exports.validator = core_2.validator;
/* export some helpers */
var helpers_2 = require("./helpers");
exports.JsonPatchError = helpers_2.PatchError;
exports.deepClone = helpers_2._deepClone;
exports.escapePathComponent = helpers_2.escapePathComponent;
exports.unescapePathComponent = helpers_2.unescapePathComponent;
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_1._objectKeys(obj);
    var oldKeys = helpers_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;
/**
 * Default export for backwards compat
 */
// import just to re-export as default
var core = require("./core");
var helpers_3 = require("./helpers");
exports.default = __assign({}, core, { 
    // duplex
    unobserve: unobserve,
    observe: observe,
    generate: generate,
    compare: compare,
    // helpers
    JsonPatchError: helpers_3.PatchError, deepClone: helpers_1._deepClone, escapePathComponent: helpers_1.escapePathComponent,
    unescapePathComponent: helpers_3.unescapePathComponent });

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\duplex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js", {"cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\src\helpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
}, {package:"@ensdomains\\content-hash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js","web-encoding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multihashes\src\index.js
      return function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

      };
    };
  }
}, {package:"multihashes",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\index.js","js-base64":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-base64\\base64.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\src\profiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@ensdomains\\content-hash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js","./int-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js","./print":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js","./varint-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js","uint8arrays/concat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\index.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\package.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\analytics-node\package.json
      return function (require, module, exports) {
module.exports={
  "name": "analytics-node",
  "version": "3.4.0-beta.3",
  "description": "The hassle-free way to integrate analytics into any Node.js application",
  "license": "MIT",
  "repository": "segmentio/analytics-node",
  "author": {
    "name": "Segment",
    "email": "tools+npm@segment.com",
    "url": "https://segment.com"
  },
  "engines": {
    "node": ">=4"
  },
  "size-limit": [
    {
      "limit": "25 KB",
      "path": "index.js"
    }
  ],
  "scripts": {
    "circle-lint": ".buildscript/circle.sh",
    "dependencies": "yarn",
    "size": "size-limit",
    "test": "standard && nyc ava --timeout=20s&& .buildscript/e2e.sh",
    "report-coverage": "nyc report --reporter=lcov > coverage.lcov && codecov",
    "np": "np --no-publish",
    "release": "yarn run np"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "analytics",
    "stats",
    "segment.io",
    "segmentio",
    "segment",
    "client",
    "driver"
  ],
  "dependencies": {
    "@segment/loosely-validate-event": "^2.0.0",
    "axios": "^0.19.2",
    "axios-retry": "^3.0.2",
    "lodash.isstring": "^4.0.1",
    "md5": "^2.2.1",
    "ms": "^2.0.0",
    "remove-trailing-slash": "^0.1.0",
    "uuid": "^3.2.1"
  },
  "devDependencies": {
    "ava": "^0.25.0",
    "basic-auth": "^2.0.1",
    "body-parser": "^1.17.1",
    "codecov": "^3.0.0",
    "commander": "^2.9.0",
    "delay": "^4.2.0",
    "express": "^4.15.2",
    "husky": "^3.0.4",
    "nyc": "^14.1.1",
    "pify": "^4.0.1",
    "sinon": "^7.3.2",
    "size-limit": "^1.3.5",
    "snyk": "^1.171.1",
    "standard": "^12.0.1"
  }
}

      };
    };
  }
}, {package:"analytics-node",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\package.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\remove-trailing-slash\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\remove-trailing-slash\index.js
      return function (require, module, exports) {

/**
 * Remove trailing slashes from the given `str`
 *
 * @api public
 * @param {String} str
 * @return {String}
 */
exports = module.exports = function (str) {
  return String(str).replace(exports.expr, '');
};

/**
 * Expose the regex
 *
 * @api private
 * @type {RegExp}
 */
exports.expr = /\/+$/;

      };
    };
  }
}, {package:"remove-trailing-slash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\remove-trailing-slash\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ms\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ms\index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

      };
    };
  }
}, {package:"ms",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ms\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.isstring\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash.isstring\index.js
      return function (require, module, exports) {
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

      };
    };
  }
}, {package:"lodash.isstring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.isstring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\v4.js", {"./lib/bytesToUuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\bytesToUuid.js","./lib/rng":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\analytics-node\node_modules\uuid\v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\v4.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\md5\\md5.js", {"charenc":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\charenc\\charenc.js","crypt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypt\\crypt.js","is-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\md5\md5.js
      return function (require, module, exports) {
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      isBuffer = require('is-buffer'),
      bin = require('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

      };
    };
  }
}, {package:"md5",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\md5\\md5.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@segment\\loosely-validate-event\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","component-type":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-type\\index.js","join-component":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\join-component\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@segment\loosely-validate-event\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var type = require('component-type')
var join = require('join-component')
var assert = require('assert')

// Segment messages can be a maximum of 32kb.
var MAX_SIZE = 32 << 10

module.exports = looselyValidateEvent

/**
 * Validate an event.
 */

function looselyValidateEvent (event, type) {
  validateGenericEvent(event)
  type = type || event.type
  assert(type, 'You must pass an event type.')
  switch (type) {
    case 'track':
      return validateTrackEvent(event)
    case 'group':
      return validateGroupEvent(event)
    case 'identify':
      return validateIdentifyEvent(event)
    case 'page':
      return validatePageEvent(event)
    case 'screen':
      return validateScreenEvent(event)
    case 'alias':
      return validateAliasEvent(event)
    default:
      assert(0, 'Invalid event type: "' + type + '"')
  }
}

/**
 * Validate a "track" event.
 */

function validateTrackEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.event, 'You must pass an "event".')
}

/**
 * Validate a "group" event.
 */

function validateGroupEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.groupId, 'You must pass a "groupId".')
}

/**
 * Validate a "identify" event.
 */

function validateIdentifyEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "page" event.
 */

function validatePageEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "screen" event.
 */

function validateScreenEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate an "alias" event.
 */

function validateAliasEvent (event) {
  assert(event.userId, 'You must pass a "userId".')
  assert(event.previousId, 'You must pass a "previousId".')
}

/**
 * Validation rules.
 */

var genericValidationRules = {
  anonymousId: [ 'string', 'number' ],
  category: 'string',
  context: 'object',
  event: 'string',
  groupId: [ 'string', 'number' ],
  integrations: 'object',
  name: 'string',
  previousId: [ 'string', 'number' ],
  timestamp: 'date',
  userId: [ 'string', 'number' ],
  type: 'string'
}

/**
 * Validate an event object.
 */

function validateGenericEvent (event) {
  assert(type(event) === 'object', 'You must pass a message object.')
  var json = JSON.stringify(event)
  // Strings are variable byte encoded, so json.length is not sufficient.
  assert(Buffer.byteLength(json, 'utf8') < MAX_SIZE, 'Your message must be < 32kb.')

  for (var key in genericValidationRules) {
    var val = event[key]
    if (!val) continue
    var rule = genericValidationRules[key]
    if (type(rule) !== 'array') {
      rule = [ rule ]
    }
    var a = rule[0] === 'object' ? 'an' : 'a'
    assert(
      rule.some(function (e) { return type(val) === e }),
      '"' + key + '" must be ' + a + ' ' + join(rule, 'or') + '.'
    )
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@segment\\loosely-validate-event",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@segment\\loosely-validate-event\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\index.js", {"./lib/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios-retry\index.js
      return function (require, module, exports) {
module.exports = require('./lib/index').default;
      };
    };
  }
}, {package:"axios-retry",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\index.js", {"./lib/axios":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\axios.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\index.js
      return function (require, module, exports) {
module.exports = require('./lib/axios');
      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js", {"./account":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js","./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js","./secp256k1v3-adapter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","./signature":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\scryptsy\\lib\\scrypt.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","pbkdf2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pbkdf2\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\scryptsy\lib\scrypt.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var pbkdf2Sync = require('pbkdf2').pbkdf2Sync

var MAX_VALUE = 0x7fffffff

// N = Cpu cost, r = Memory cost, p = parallelization cost
function scrypt (key, salt, N, r, p, dkLen, progressCallback) {
  if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

  if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
  if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

  var XY = new Buffer(256 * r)
  var V = new Buffer(128 * r * N)

  // pseudo global
  var B32 = new Int32Array(16) // salsa20_8
  var x = new Int32Array(16) // salsa20_8
  var _X = new Buffer(64) // blockmix_salsa8

  // pseudo global
  var B = pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')

  var tickCallback
  if (progressCallback) {
    var totalOps = p * N * 2
    var currentOp = 0

    tickCallback = function () {
      ++currentOp

      // send progress notifications once every 1,000 ops
      if (currentOp % 1000 === 0) {
        progressCallback({
          current: currentOp,
          total: totalOps,
          percent: (currentOp / totalOps) * 100.0
        })
      }
    }
  }

  for (var i = 0; i < p; i++) {
    smix(B, i * 128 * r, r, N, V, XY)
  }

  return pbkdf2Sync(key, B, 1, dkLen, 'sha256')

  // all of these functions are actually moved to the top
  // due to function hoisting

  function smix (B, Bi, r, N, V, XY) {
    var Xi = 0
    var Yi = 128 * r
    var i

    B.copy(XY, Xi, Bi, Bi + Yi)

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    for (i = 0; i < N; i++) {
      var offset = Xi + (2 * r - 1) * 64
      var j = XY.readUInt32LE(offset) & (N - 1)
      blockxor(V, j * Yi, XY, Xi, Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    XY.copy(B, Bi, Xi, Xi + Yi)
  }

  function blockmix_salsa8 (BY, Bi, Yi, r) {
    var i

    arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64)
      salsa20_8(_X)
      arraycopy(_X, 0, BY, Yi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)
    }
  }

  function R (a, b) {
    return (a << b) | (a >>> (32 - b))
  }

  function salsa20_8 (B) {
    var i

    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 0xff) << 0
      B32[i] |= (B[i * 4 + 1] & 0xff) << 8
      B32[i] |= (B[i * 4 + 2] & 0xff) << 16
      B32[i] |= (B[i * 4 + 3] & 0xff) << 24
      // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
    }

    arraycopy(B32, 0, x, 0, 16)

    for (i = 8; i > 0; i -= 2) {
      x[ 4] ^= R(x[ 0] + x[12], 7)
      x[ 8] ^= R(x[ 4] + x[ 0], 9)
      x[12] ^= R(x[ 8] + x[ 4], 13)
      x[ 0] ^= R(x[12] + x[ 8], 18)
      x[ 9] ^= R(x[ 5] + x[ 1], 7)
      x[13] ^= R(x[ 9] + x[ 5], 9)
      x[ 1] ^= R(x[13] + x[ 9], 13)
      x[ 5] ^= R(x[ 1] + x[13], 18)
      x[14] ^= R(x[10] + x[ 6], 7)
      x[ 2] ^= R(x[14] + x[10], 9)
      x[ 6] ^= R(x[ 2] + x[14], 13)
      x[10] ^= R(x[ 6] + x[ 2], 18)
      x[ 3] ^= R(x[15] + x[11], 7)
      x[ 7] ^= R(x[ 3] + x[15], 9)
      x[11] ^= R(x[ 7] + x[ 3], 13)
      x[15] ^= R(x[11] + x[ 7], 18)
      x[ 1] ^= R(x[ 0] + x[ 3], 7)
      x[ 2] ^= R(x[ 1] + x[ 0], 9)
      x[ 3] ^= R(x[ 2] + x[ 1], 13)
      x[ 0] ^= R(x[ 3] + x[ 2], 18)
      x[ 6] ^= R(x[ 5] + x[ 4], 7)
      x[ 7] ^= R(x[ 6] + x[ 5], 9)
      x[ 4] ^= R(x[ 7] + x[ 6], 13)
      x[ 5] ^= R(x[ 4] + x[ 7], 18)
      x[11] ^= R(x[10] + x[ 9], 7)
      x[ 8] ^= R(x[11] + x[10], 9)
      x[ 9] ^= R(x[ 8] + x[11], 13)
      x[10] ^= R(x[ 9] + x[ 8], 18)
      x[12] ^= R(x[15] + x[14], 7)
      x[13] ^= R(x[12] + x[15], 9)
      x[14] ^= R(x[13] + x[12], 13)
      x[15] ^= R(x[14] + x[13], 18)
    }

    for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]

    for (i = 0; i < 16; i++) {
      var bi = i * 4
      B[bi + 0] = (B32[i] >> 0 & 0xff)
      B[bi + 1] = (B32[i] >> 8 & 0xff)
      B[bi + 2] = (B32[i] >> 16 & 0xff)
      B[bi + 3] = (B32[i] >> 24 & 0xff)
      // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor (S, Si, D, Di, len) {
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i]
    }
  }
}

function arraycopy (src, srcPos, dest, destPos, length) {
  if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
    src.copy(dest, destPos, srcPos, srcPos + length)
  } else {
    while (length--) {
      dest[destPos++] = src[srcPos++]
    }
  }
}

module.exports = scrypt

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"scryptsy",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\scryptsy\\lib\\scrypt.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js", {"./lib/bytesToUuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js","./lib/rng":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\uuid\v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\v4.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\index.js", {"./createEventEmitterProxy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createEventEmitterProxy.js","./createSwappableProxy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createSwappableProxy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\swappable-obj-proxy\src\index.js
      return function (require, module, exports) {
const createSwappableProxy = require('./createSwappableProxy')
const createEventEmitterProxy = require('./createEventEmitterProxy')

module.exports = {
  createSwappableProxy,
  createEventEmitterProxy,
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createJsonRpcClient.js", {"../../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","eth-block-tracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\index.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\createJsonRpcClient.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createJsonRpcClient;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethBlockTracker = require("eth-block-tracker");

var _time = require("../../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const inTest = process.env.IN_TEST;
const blockTrackerOpts = inTest ? {
  pollingInterval: _time.SECOND
} : {};

const getTestMiddlewares = () => {
  return inTest ? [createEstimateGasDelayTestMiddleware()] : [];
};

function createJsonRpcClient({
  rpcUrl,
  chainId
}) {
  const fetchMiddleware = (0, _ethJsonRpcMiddleware.createFetchMiddleware)({
    rpcUrl
  });
  const blockProvider = (0, _ethJsonRpcMiddleware.providerFromMiddleware)(fetchMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker(_objectSpread(_objectSpread({}, blockTrackerOpts), {}, {
    provider: blockProvider
  }));
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([...getTestMiddlewares(), createChainIdMiddleware(chainId), (0, _ethJsonRpcMiddleware.createBlockRefRewriteMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createBlockCacheMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createInflightCacheMiddleware)(), (0, _ethJsonRpcMiddleware.createBlockTrackerInspectorMiddleware)({
    blockTracker
  }), fetchMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === 'eth_chainId') {
      res.result = chainId;
      return end();
    }

    return next();
  };
}
/**
 * For use in tests only.
 * Adds a delay to `eth_estimateGas` calls.
 */


function createEstimateGasDelayTestMiddleware() {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, _, next) => {
    if (req.method === 'eth_estimateGas') {
      await new Promise(resolve => setTimeout(resolve, _time.SECOND * 2));
    }

    return next();
  });
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createJsonRpcClient.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createInfuraClient.js", {"../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","eth-block-tracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\index.js","eth-json-rpc-infura":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-infura\\src\\index.js","eth-json-rpc-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\createInfuraClient.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createInfuraClient;

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethJsonRpcInfura = _interopRequireDefault(require("eth-json-rpc-infura"));

var _ethBlockTracker = require("eth-block-tracker");

var _network = require("../../../../shared/constants/network");

function createInfuraClient({
  network,
  projectId
}) {
  const infuraMiddleware = (0, _ethJsonRpcInfura.default)({
    network,
    projectId,
    maxAttempts: 5,
    source: 'metamask'
  });
  const infuraProvider = (0, _ethJsonRpcMiddleware.providerFromMiddleware)(infuraMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker({
    provider: infuraProvider
  });
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([createNetworkAndChainIdMiddleware({
    network
  }), (0, _ethJsonRpcMiddleware.createBlockCacheMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createInflightCacheMiddleware)(), (0, _ethJsonRpcMiddleware.createBlockRefMiddleware)({
    blockTracker,
    provider: infuraProvider
  }), (0, _ethJsonRpcMiddleware.createRetryOnEmptyMiddleware)({
    blockTracker,
    provider: infuraProvider
  }), (0, _ethJsonRpcMiddleware.createBlockTrackerInspectorMiddleware)({
    blockTracker
  }), infuraMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createNetworkAndChainIdMiddleware({
  network
}) {
  if (!_network.NETWORK_TYPE_TO_ID_MAP[network]) {
    throw new Error(`createInfuraClient - unknown network "${network}"`);
  }

  const {
    chainId,
    networkId
  } = _network.NETWORK_TYPE_TO_ID_MAP[network];
  return (0, _jsonRpcEngine.createScaffoldMiddleware)({
    eth_chainId: chainId,
    net_version: networkId
  });
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\createInfuraClient.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\lib\\coinstring.js", {"bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\node_modules\\bs58\\lib\\bs58.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\coinstring\lib\coinstring.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var base58 = require('bs58')
var createHash = require('create-hash')

function encode (payload, version) {
  if (Array.isArray(payload) || payload instanceof Uint8Array) {
    payload = new Buffer(payload)
  }

  var buf
  if (version != null) {
    if (typeof version === 'number') {
      version = new Buffer([version])
    }
    buf = Buffer.concat([version, payload])
  } else {
    buf = payload
  }

  var checksum = sha256x2(buf).slice(0, 4)
  var result = Buffer.concat([buf, checksum])
  return base58.encode(result)
}

function decode (base58str, version) {
  var arr = base58.decode(base58str)
  var buf = new Buffer(arr)
  var versionLength

  if (version == null) {
    versionLength = 0
  } else {
    if (typeof version === 'number') version = new Buffer([version])

    versionLength = version.length
    var versionCompare = buf.slice(0, versionLength)
    if (versionCompare.toString('hex') !== version.toString('hex')) {
      throw new Error('Invalid version')
    }
  }

  var checksum = buf.slice(-4)
  var endPos = buf.length - 4
  var bytes = buf.slice(0, endPos)

  var newChecksum = sha256x2(bytes).slice(0, 4)
  if (checksum.toString('hex') !== newChecksum.toString('hex')) {
    throw new Error('Invalid checksum')
  }

  return bytes.slice(versionLength)
}

function isValid (base58str, version) {
  try {
    decode(base58str, version)
  } catch (e) {
    return false
  }

  return true
}

function createEncoder (version) {
  return function (payload) {
    return encode(payload, version)
  }
}

function createDecoder (version) {
  return function (base58str) {
    return decode(base58str, version)
  }
}

function createValidator (version) {
  return function (base58str) {
    return isValid(base58str, version)
  }
}

function sha256x2 (buffer) {
  var sha = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(sha).digest()
}

module.exports = {
  encode: encode,
  decode: decode,
  isValid: isValid,
  createEncoder: createEncoder,
  createDecoder: createDecoder,
  createValidator: createValidator
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"coinstring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\lib\\coinstring.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js", {"./lib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\elliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js","keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\js.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"json-stable-stringify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\dist\utils\cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${(0, json_stable_stringify_1.default)(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\pify\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\pify\index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"pify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\pify\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\eth-sig-util\\index.js", {"ethereumjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\eth-sig-util\index.js
      return function (require, module, exports) {
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')

module.exports = {

  concatSig: function (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize: function (input) {
    if (!input) return

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ' received ' + (typeof input) + ': ' + input
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign: function (privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data)
    var msgHash = ethUtil.hashPersonalMessage(message)
    var sig = ethUtil.ecsign(msgHash, privateKey)
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return '0x' + publicKey.toString('hex')
  },

  typedSignatureHash: function (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedData: function (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature: function (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  }

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data)
    ]
  )
}

function recoverPublicKey(hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  var myString = '' + number
  while (myString.length < length) {
    myString = '0' + myString
  }
  return myString
}

      };
    };
  }
}, {package:"eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\eth-sig-util\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\dist\types.js
      return function (require, module, exports) {
"use strict";
/** API */
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancellationReasonToStatusMap = exports.SmartTransactionStatuses = exports.SmartTransactionCancellationReason = exports.SmartTransactionMinedTx = exports.APIType = void 0;
var APIType;
(function (APIType) {
    APIType[APIType["GET_FEES"] = 0] = "GET_FEES";
    APIType[APIType["ESTIMATE_GAS"] = 1] = "ESTIMATE_GAS";
    APIType[APIType["SUBMIT_TRANSACTIONS"] = 2] = "SUBMIT_TRANSACTIONS";
    APIType[APIType["CANCEL"] = 3] = "CANCEL";
    APIType[APIType["BATCH_STATUS"] = 4] = "BATCH_STATUS";
    APIType[APIType["LIVENESS"] = 5] = "LIVENESS";
})(APIType = exports.APIType || (exports.APIType = {}));
/** SmartTransactions */
var SmartTransactionMinedTx;
(function (SmartTransactionMinedTx) {
    SmartTransactionMinedTx["NOT_MINED"] = "not_mined";
    SmartTransactionMinedTx["SUCCESS"] = "success";
    SmartTransactionMinedTx["CANCELLED"] = "cancelled";
    SmartTransactionMinedTx["REVERTED"] = "reverted";
    SmartTransactionMinedTx["UNKNOWN"] = "unknown";
})(SmartTransactionMinedTx = exports.SmartTransactionMinedTx || (exports.SmartTransactionMinedTx = {}));
var SmartTransactionCancellationReason;
(function (SmartTransactionCancellationReason) {
    SmartTransactionCancellationReason["WOULD_REVERT"] = "would_revert";
    SmartTransactionCancellationReason["TOO_CHEAP"] = "too_cheap";
    SmartTransactionCancellationReason["DEADLINE_MISSED"] = "deadline_missed";
    SmartTransactionCancellationReason["INVALID_NONCE"] = "invalid_nonce";
    SmartTransactionCancellationReason["USER_CANCELLED"] = "user_cancelled";
    SmartTransactionCancellationReason["NOT_CANCELLED"] = "not_cancelled";
})(SmartTransactionCancellationReason = exports.SmartTransactionCancellationReason || (exports.SmartTransactionCancellationReason = {}));
var SmartTransactionStatuses;
(function (SmartTransactionStatuses) {
    SmartTransactionStatuses["PENDING"] = "pending";
    SmartTransactionStatuses["SUCCESS"] = "success";
    SmartTransactionStatuses["REVERTED"] = "reverted";
    SmartTransactionStatuses["UNKNOWN"] = "unknown";
    SmartTransactionStatuses["CANCELLED_WOULD_REVERT"] = "cancelled_would_revert";
    SmartTransactionStatuses["CANCELLED_TOO_CHEAP"] = "cancelled_too_cheap";
    SmartTransactionStatuses["CANCELLED_DEADLINE_MISSED"] = "cancelled_deadline_missed";
    SmartTransactionStatuses["CANCELLED_INVALID_NONCE"] = "cancelled_invalid_nonce";
    SmartTransactionStatuses["CANCELLED_USER_CANCELLED"] = "cancelled_user_cancelled";
    SmartTransactionStatuses["RESOLVED"] = "resolved";
})(SmartTransactionStatuses = exports.SmartTransactionStatuses || (exports.SmartTransactionStatuses = {}));
exports.cancellationReasonToStatusMap = {
    [SmartTransactionCancellationReason.WOULD_REVERT]: SmartTransactionStatuses.CANCELLED_WOULD_REVERT,
    [SmartTransactionCancellationReason.TOO_CHEAP]: SmartTransactionStatuses.CANCELLED_TOO_CHEAP,
    [SmartTransactionCancellationReason.DEADLINE_MISSED]: SmartTransactionStatuses.CANCELLED_DEADLINE_MISSED,
    [SmartTransactionCancellationReason.INVALID_NONCE]: SmartTransactionStatuses.CANCELLED_INVALID_NONCE,
    [SmartTransactionCancellationReason.USER_CANCELLED]: SmartTransactionStatuses.CANCELLED_USER_CANCELLED,
};
//# sourceMappingURL=types.js.map
      };
    };
  }
}, {package:"@metamask\\smart-transactions-controller",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\dist\constants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHAIN_IDS = exports.API_BASE_URL = void 0;
exports.API_BASE_URL = 'https://transaction.metaswap.codefi.network';
exports.CHAIN_IDS = {
    ETHEREUM: '0x1',
    RINKEBY: '0x4',
    BSC: '0x38',
};
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"@metamask\\smart-transactions-controller",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\node_modules\bignumber.js\bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\bignumber.js\\bignumber.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\utils.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js","fast-json-patch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\dist\utils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFetch = exports.getStxProcessingTime = exports.snapshotFromTxMeta = exports.replayHistory = exports.generateHistoryEntry = exports.calculateStatus = exports.getAPIRequestURL = exports.isSmartTransactionStatusResolved = exports.isSmartTransactionPending = void 0;
const fast_json_patch_1 = __importDefault(require("fast-json-patch"));
const lodash_1 = require("lodash");
const types_1 = require("./types");
const constants_1 = require("./constants");
function isSmartTransactionPending(smartTransaction) {
    return smartTransaction.status === types_1.SmartTransactionStatuses.PENDING;
}
exports.isSmartTransactionPending = isSmartTransactionPending;
const isSmartTransactionStatusResolved = (status) => status === 'uuid_not_found';
exports.isSmartTransactionStatusResolved = isSmartTransactionStatusResolved;
// TODO use actual url once API is defined
function getAPIRequestURL(apiType, chainId) {
    const chainIdDec = parseInt(chainId, 16);
    switch (apiType) {
        case types_1.APIType.GET_FEES: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/getFees`;
        }
        case types_1.APIType.ESTIMATE_GAS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/estimateGas`;
        }
        case types_1.APIType.SUBMIT_TRANSACTIONS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/submitTransactions`;
        }
        case types_1.APIType.CANCEL: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/cancel`;
        }
        case types_1.APIType.BATCH_STATUS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/batchStatus`;
        }
        case types_1.APIType.LIVENESS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/health`;
        }
        default: {
            throw new Error(`Invalid APIType`); // It can never get here thanks to TypeScript.
        }
    }
}
exports.getAPIRequestURL = getAPIRequestURL;
const calculateStatus = (status) => {
    if (exports.isSmartTransactionStatusResolved(status)) {
        return types_1.SmartTransactionStatuses.RESOLVED;
    }
    const cancellations = [
        types_1.SmartTransactionCancellationReason.WOULD_REVERT,
        types_1.SmartTransactionCancellationReason.TOO_CHEAP,
        types_1.SmartTransactionCancellationReason.DEADLINE_MISSED,
        types_1.SmartTransactionCancellationReason.INVALID_NONCE,
        types_1.SmartTransactionCancellationReason.USER_CANCELLED,
    ];
    if ((status === null || status === void 0 ? void 0 : status.minedTx) === types_1.SmartTransactionMinedTx.NOT_MINED) {
        if (status.cancellationReason ===
            types_1.SmartTransactionCancellationReason.NOT_CANCELLED) {
            return types_1.SmartTransactionStatuses.PENDING;
        }
        const isCancellation = cancellations.findIndex((cancellation) => cancellation === status.cancellationReason) > -1;
        if (status.cancellationReason && isCancellation) {
            return types_1.cancellationReasonToStatusMap[status.cancellationReason];
        }
    }
    else if ((status === null || status === void 0 ? void 0 : status.minedTx) === types_1.SmartTransactionMinedTx.SUCCESS) {
        return types_1.SmartTransactionStatuses.SUCCESS;
    }
    else if ((status === null || status === void 0 ? void 0 : status.minedTx) === types_1.SmartTransactionMinedTx.REVERTED) {
        return types_1.SmartTransactionStatuses.REVERTED;
    }
    else if ((status === null || status === void 0 ? void 0 : status.minedTx) === types_1.SmartTransactionMinedTx.UNKNOWN) {
        return types_1.SmartTransactionStatuses.UNKNOWN;
    }
    return types_1.SmartTransactionStatuses.UNKNOWN;
};
exports.calculateStatus = calculateStatus;
/**
  Generates an array of history objects sense the previous state.
  The object has the keys
    op (the operation performed),
    path (the key and if a nested object then each key will be separated with a `/`)
    value
  with the first entry having the note and a timestamp when the change took place
  @param {Object} previousState - the previous state of the object
  @param {Object} newState - the update object
  @param {string} [note] - a optional note for the state change
  @returns {Array}
*/
function generateHistoryEntry(previousState, newState, note) {
    const entry = fast_json_patch_1.default.compare(previousState, newState);
    // Add a note to the first op, since it breaks if we append it to the entry
    if (entry[0]) {
        if (note) {
            entry[0].note = note;
        }
        entry[0].timestamp = Date.now();
    }
    return entry;
}
exports.generateHistoryEntry = generateHistoryEntry;
/**
  Recovers previous txMeta state obj
  @returns {Object}
*/
function replayHistory(_shortHistory) {
    const shortHistory = lodash_1.cloneDeep(_shortHistory);
    return shortHistory.reduce((val, entry) => fast_json_patch_1.default.applyPatch(val, entry).newDocument);
}
exports.replayHistory = replayHistory;
/**
 * Snapshot {@code txMeta}
 * @param {Object} txMeta - the tx metadata object
 * @returns {Object} a deep clone without history
 */
function snapshotFromTxMeta(txMeta) {
    const shallow = Object.assign({}, txMeta);
    delete shallow.history;
    return lodash_1.cloneDeep(shallow);
}
exports.snapshotFromTxMeta = snapshotFromTxMeta;
/**
 * Returns processing time for an STX in seconds.
 * @param {number} smartTransactionSubmittedtime
 * @returns {number} Processing time in seconds.
 */
const getStxProcessingTime = (smartTransactionSubmittedtime) => {
    if (!smartTransactionSubmittedtime) {
        return undefined;
    }
    return Math.round((Date.now() - smartTransactionSubmittedtime) / 1000);
};
exports.getStxProcessingTime = getStxProcessingTime;
async function handleFetch(request, options) {
    const response = await fetch(request, options);
    const json = await response.json();
    if (!response.ok) {
        const { error: type, error_details: message } = json;
        console.log(`response`, response);
        throw new Error(`Fetch error:${JSON.stringify({
            status: response.status,
            type,
            message,
        })}`);
    }
    return json;
}
exports.handleFetch = handleFetch;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask\\smart-transactions-controller",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\dist\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\cloneDeep.js", {"./_baseClone":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseClone.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\cloneDeep.js
      return function (require, module, exports) {
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\cloneDeep.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\constants.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ETH_ABI_LATTICE_FW_TYPE_MAP = exports.MAX_CHAIN_ID_BYTES = exports.HANDLE_LARGER_CHAIN_ID = exports.HARDENED_OFFSET = exports.VERSION_BYTE = exports.REQUEST_TYPE_BYTE = exports.signingSchema = exports.responseMsgs = exports.responseCodes = exports.messageConstants = exports.ethMsgProtocol = exports.encReqCodes = exports.deviceCodes = exports.decResLengths = exports.addressSizes = exports.ENC_MSG_LEN = exports.BASE_URL = exports.BIP_CONSTANTS = exports.AES_IV = exports.ADDR_STR_LEN = exports.getFwVersionConst = exports.ASCII_REGEX = exports.EXTERNAL = void 0;
// Consistent with Lattice's IV
var AES_IV = [
    0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x70, 0x61, 0x73, 0x73, 0x77,
    0x6f, 0x72, 0x64,
];
exports.AES_IV = AES_IV;
var ADDR_STR_LEN = 129; // 128-char strings (null terminated)
exports.ADDR_STR_LEN = ADDR_STR_LEN;
// Decrypted response lengths will be fixed for any given message type.
// These are defined in the Lattice spec.
// Every decrypted response should have a 65-byte pubkey prefixing it (and a 4-byte request ID)
// These are NOT counted in `decResLengths`, meaning these values are 69-bytes smaller than the
// corresponding structs in firmware.
var decResLengths = {
    empty: 0,
    getAddresses: 10 * ADDR_STR_LEN,
    sign: 1090,
    getWallets: 142,
    addAbiDefs: 8,
    getKvRecords: 1395,
    getAbiRecords: 1215,
    removeAbiRecords: 1,
    test: 1646, // Max size of test response payload
};
exports.decResLengths = decResLengths;
// Every corresponding decrypted response struct in firmware has a pubkey
// and checksum added. These are not included in `decResLengths`
var DES_RES_EXTRADATA_LEN = 69;
// Encrypted responses also have metadata
// Prefix:
// * protocol version (1 byte)
// * response type, reserved (1 byte) -- not used
// * response id (4 bytes) -- not used
// * payload length (2 bytes)
// * response code (1 byte)
// Suffix:
// * checksum (4 bytes) -- NOT the same checksum as inside the decrypted msg
var ENC_MSG_METADATA_LEN = 13;
var ENC_MSG_EXTRA_LEN = DES_RES_EXTRADATA_LEN + ENC_MSG_METADATA_LEN;
// Per Lattice spec, all encrypted messages must fit in a buffer of this size.
// The length comes from the largest request/response data type size
// We also add the prefix length
var ENC_MSG_LEN = 0;
exports.ENC_MSG_LEN = ENC_MSG_LEN;
Object.keys(decResLengths).forEach(function (k) {
    if (decResLengths[k] + ENC_MSG_EXTRA_LEN > ENC_MSG_LEN)
        exports.ENC_MSG_LEN = ENC_MSG_LEN = decResLengths[k] + ENC_MSG_EXTRA_LEN;
});
var deviceCodes = {
    CONNECT: 1,
    ENCRYPTED_REQUEST: 2,
};
exports.deviceCodes = deviceCodes;
var encReqCodes = {
    FINALIZE_PAIRING: 0,
    GET_ADDRESSES: 1,
    ADD_PERMISSION: 2,
    SIGN_TRANSACTION: 3,
    GET_WALLETS: 4,
    ADD_PERMISSION_V0: 5,
    ADD_ABI_DEFS: 6,
    GET_KV_RECORDS: 7,
    ADD_KV_RECORDS: 8,
    REMOVE_KV_RECORDS: 9,
    GET_ABI_RECORDS: 10,
    REMOVE_ABI_RECORDS: 11,
    TEST: 12,
};
exports.encReqCodes = encReqCodes;
var messageConstants = {
    NOT_PAIRED: 0x00,
    PAIRED: 0x01,
};
exports.messageConstants = messageConstants;
var addressSizes = {
    BTC: 20,
    ETH: 20, // 20 byte address not including 0x prefix
};
exports.addressSizes = addressSizes;
var responseCodes = {
    RESP_SUCCESS: 0x00,
    RESP_ERR_INVALID_MSG: 0x80,
    RESP_ERR_UNSUPPORTED_VER: 0x81,
    RESP_ERR_DEV_BUSY: 0x82,
    RESP_ERR_USER_TIMEOUT: 0x83,
    RESP_ERR_USER_DECLINED: 0x84,
    RESP_ERR_PAIR_FAIL: 0x85,
    RESP_ERR_PAIR_DISABLED: 0x86,
    RESP_ERR_PERMISSION_DISABLED: 0x87,
    RESP_ERR_INTERNAL: 0x88,
    RESP_ERR_GCE_TIMEOUT: 0x89,
    RESP_ERR_WRONG_WALLET: 0x8a,
    RESP_ERR_DEV_LOCKED: 0x8b,
    RESP_ERR_DISABLED: 0x8c,
    RESP_ERR_ALREADY: 0x8d,
    RESP_ERR_INVALID_EPHEM_ID: 0x8e,
};
exports.responseCodes = responseCodes;
var responseMsgs = (_a = {},
    _a[responseCodes.RESP_SUCCESS] = 0x00,
    _a[responseCodes.RESP_ERR_INVALID_MSG] = 'Invalid request',
    _a[responseCodes.RESP_ERR_UNSUPPORTED_VER] = 'Unsupported version',
    _a[responseCodes.RESP_ERR_DEV_BUSY] = 'Device busy',
    _a[responseCodes.RESP_ERR_USER_TIMEOUT] = 'Timeout waiting for user',
    _a[responseCodes.RESP_ERR_USER_DECLINED] = 'Request declined by user',
    _a[responseCodes.RESP_ERR_PAIR_FAIL] = 'Pairing failed',
    _a[responseCodes.RESP_ERR_PAIR_DISABLED] = 'Pairing is currently disabled',
    _a[responseCodes.RESP_ERR_PERMISSION_DISABLED] = 'Automated signing is currently disabled',
    _a[responseCodes.RESP_ERR_INTERNAL] = 'Device error',
    _a[responseCodes.RESP_ERR_GCE_TIMEOUT] = 'Timeout',
    _a[responseCodes.RESP_ERR_WRONG_WALLET] = 'Active wallet does not match request',
    _a[responseCodes.RESP_ERR_DEV_LOCKED] = 'Device locked',
    _a[responseCodes.RESP_ERR_DISABLED] = 'Disabled',
    _a[responseCodes.RESP_ERR_ALREADY] = 'Record already exists. You must first remove it on your device.',
    _a[responseCodes.RESP_ERR_INVALID_EPHEM_ID] = 'Could not find requester. Please reconnect.',
    _a);
exports.responseMsgs = responseMsgs;
var signingSchema = {
    BTC_TRANSFER: 0,
    ETH_TRANSFER: 1,
    ERC20_TRANSFER: 2,
    ETH_MSG: 3,
    EXTRA_DATA: 4,
    GENERAL_SIGNING: 5,
};
exports.signingSchema = signingSchema;
var HARDENED_OFFSET = 0x80000000; // Hardened offset
exports.HARDENED_OFFSET = HARDENED_OFFSET;
var BIP_CONSTANTS = {
    PURPOSES: {
        ETH: HARDENED_OFFSET + 44,
        BTC_LEGACY: HARDENED_OFFSET + 44,
        BTC_WRAPPED_SEGWIT: HARDENED_OFFSET + 49,
        BTC_SEGWIT: HARDENED_OFFSET + 84,
    },
    COINS: {
        ETH: HARDENED_OFFSET + 60,
        BTC: HARDENED_OFFSET,
        BTC_TESTNET: HARDENED_OFFSET + 1,
    },
};
exports.BIP_CONSTANTS = BIP_CONSTANTS;
var REQUEST_TYPE_BYTE = 0x02; // For all HSM-bound requests
exports.REQUEST_TYPE_BYTE = REQUEST_TYPE_BYTE;
var VERSION_BYTE = 1;
exports.VERSION_BYTE = VERSION_BYTE;
var HANDLE_LARGER_CHAIN_ID = 255; // ChainId value to signify larger chainID is in data buffer
exports.HANDLE_LARGER_CHAIN_ID = HANDLE_LARGER_CHAIN_ID;
var MAX_CHAIN_ID_BYTES = 8; // Max number of bytes to contain larger chainID in data buffer
exports.MAX_CHAIN_ID_BYTES = MAX_CHAIN_ID_BYTES;
var BASE_URL = 'https://signing.gridpl.us';
exports.BASE_URL = BASE_URL;
var EIP712_ABI_LATTICE_FW_TYPE_MAP = {
    address: 1,
    bool: 2,
    uint8: 3,
    uint16: 4,
    uint24: 5,
    uint32: 6,
    uint40: 7,
    uint48: 8,
    uint56: 9,
    uint64: 10,
    uint72: 11,
    uint80: 12,
    uint88: 13,
    uint96: 14,
    uint104: 15,
    uint112: 16,
    uint120: 17,
    uint128: 18,
    uint136: 19,
    uint144: 20,
    uint152: 21,
    uint160: 22,
    uint168: 23,
    uint176: 24,
    uint184: 25,
    uint192: 26,
    uint200: 27,
    uint208: 28,
    uint216: 29,
    uint224: 30,
    uint232: 31,
    uint240: 32,
    uint248: 33,
    uint256: 34,
    int8: 35,
    int16: 36,
    int24: 37,
    int32: 38,
    int40: 39,
    int48: 40,
    int56: 41,
    int64: 42,
    int72: 43,
    int80: 44,
    int88: 45,
    int96: 46,
    int104: 47,
    int112: 48,
    int120: 49,
    int128: 50,
    int136: 51,
    int144: 52,
    int152: 53,
    int160: 54,
    int168: 55,
    int176: 56,
    int184: 57,
    int192: 58,
    int200: 59,
    int208: 60,
    int216: 61,
    int224: 62,
    int232: 63,
    int240: 64,
    int248: 65,
    int256: 66,
    uint: 67,
    bytes1: 69,
    bytes2: 70,
    bytes3: 71,
    bytes4: 72,
    bytes5: 73,
    bytes6: 74,
    bytes7: 75,
    bytes8: 76,
    bytes9: 77,
    bytes10: 78,
    bytes11: 79,
    bytes12: 80,
    bytes13: 81,
    bytes14: 82,
    bytes15: 83,
    bytes16: 84,
    bytes17: 85,
    bytes18: 86,
    bytes19: 87,
    bytes20: 88,
    bytes21: 89,
    bytes22: 90,
    bytes23: 91,
    bytes24: 92,
    bytes25: 93,
    bytes26: 94,
    bytes27: 95,
    bytes28: 96,
    bytes29: 97,
    bytes30: 98,
    bytes31: 99,
    bytes32: 100,
    bytes: 101,
    string: 102,
};
var ETH_ABI_LATTICE_FW_TYPE_MAP = __assign(__assign({}, EIP712_ABI_LATTICE_FW_TYPE_MAP), { tuple1: 103, tuple2: 104, tuple3: 105, tuple4: 106, tuple5: 107, tuple6: 108, tuple7: 109, tuple8: 110, tuple9: 111, tuple10: 112, tuple11: 113, tuple12: 114, tuple13: 115, tuple14: 116, tuple15: 117, tuple16: 118, tuple17: 119 });
exports.ETH_ABI_LATTICE_FW_TYPE_MAP = ETH_ABI_LATTICE_FW_TYPE_MAP;
var ethMsgProtocol = {
    SIGN_PERSONAL: {
        str: 'signPersonal',
        enumIdx: 0, // Enum index of this protocol in Lattice firmware
    },
    TYPED_DATA: {
        str: 'typedData',
        enumIdx: 1,
        rawDataMaxLen: 1629,
        typeCodes: EIP712_ABI_LATTICE_FW_TYPE_MAP, // Enum indices of data types in Lattice firmware
    },
};
exports.ethMsgProtocol = ethMsgProtocol;
//======================================================
// EXTERNALLY EXPORTED CONSTANTS
// These are used for building requests
//======================================================
exports.EXTERNAL = {
    // Optional flags for `getAddresses`
    GET_ADDR_FLAGS: {
        SECP256K1_PUB: 3,
        ED25519_PUB: 4,
    },
    // Options for building general signing requests
    SIGNING: {
        HASHES: {
            NONE: 0,
            KECCAK256: 1,
            SHA256: 2,
        },
        CURVES: {
            SECP256K1: 0,
            ED25519: 1
        },
        ENCODINGS: {
            ASCII: 0,
            HEX: 1,
            SOLANA: 2,
        }
    }
};
function getFwVersionConst(v) {
    var c = {
        extraDataFrameSz: 0,
        extraDataMaxFrames: 0,
    };
    function gte(v, exp) {
        // Note that `v` fields come in as [fix|minor|major]
        return (v[2] > exp[0] ||
            (v[2] === exp[0] && v[1] > exp[1]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] > exp[2]) ||
            (v[2] === exp[0] && v[1] === exp[1] && v[0] === exp[2]));
    }
    // Very old legacy versions do not give a version number
    var legacy = v.length === 0;
    // BASE FIELDS
    //--------------------------------------
    // Various size constants have changed on the firmware side over time and
    // are captured here
    if (!legacy && gte(v, [0, 10, 4])) {
        // >=0.10.3
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else if (!legacy && gte(v, [0, 10, 0])) {
        // >=0.10.0
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    }
    else {
        // Legacy or <0.10.0
        c.reqMaxDataSz = 1152;
        c.ethMaxGasPrice = 500000000000; // 500 gwei
        c.addrFlagsAllowed = false;
    }
    // These transformations apply to all versions. The subtraction
    // of 128 bytes accounts for metadata and is for legacy reasons.
    // For all modern versions, these are 1550 bytes.
    // NOTE: Non-legacy ETH txs (e.g. EIP1559) will shrink
    // this number.
    // See `ETH_BASE_TX_MAX_DATA_SZ` and `ETH_MAX_BASE_MSG_SZ` in firmware
    c.ethMaxDataSz = c.reqMaxDataSz - 128;
    c.ethMaxMsgSz = c.ethMaxDataSz;
    // Max number of params in an EIP712 type. This was added to firmware
    // to avoid blowing stack size.
    c.eip712MaxTypeParams = 18;
    // EXTRA FIELDS ADDED IN LATER VERSIONS
    //-------------------------------------
    // V0.14.0 added support for a more robust API around ABI definitions
    // and generic signing functionality
    if (!legacy && gte(v, [0, 13, 0])) {
        // Size of `category` buffer. Inclusive of null terminator byte.
        c.abiCategorySz = 32;
        c.abiMaxRmv = 200; // Max number of ABI defs that can be removed with
        // a single request
        if (!c.genericSigning) {
            c.genericSigning = {};
        }
        // See `sizeof(GenericSigningRequest_t)` in firmware
        c.genericSigning.baseReqSz = 1552;
        // See `GENERIC_SIGNING_BASE_MSG_SZ` in firmware
        c.genericSigning.baseDataSz = 1519;
        c.genericSigning.hashTypes = exports.EXTERNAL.SIGNING.HASHES;
        c.genericSigning.curveTypes = exports.EXTERNAL.SIGNING.CURVES;
        c.genericSigning.encodingTypes = exports.EXTERNAL.SIGNING.ENCODINGS;
        // Supported flags for `getAddresses`
        c.getAddressFlags = [
            exports.EXTERNAL.GET_ADDR_FLAGS.ED25519_PUB,
            exports.EXTERNAL.GET_ADDR_FLAGS.SECP256K1_PUB
        ];
        // We updated the max number of params in EIP712 types
        c.eip712MaxTypeParams = 36;
    }
    // V0.13.0 added native segwit addresses and fixed a bug in exporting
    // legacy bitcoin addresses
    if (!legacy && gte(v, [0, 13, 0])) {
        c.allowBtcLegacyAndSegwitAddrs = true;
        // Random address to be used when trying to deploy a contract
        c.contractDeployKey = '0x08002e0fec8e6acf00835f43c9764f7364fa3f42';
    }
    // V0.12.0 added an API for creating, removing, and fetching key-val file
    // records. For the purposes of this SDK, we only hook into one type of kv
    // file: address names.
    if (!legacy && gte(v, [0, 12, 0])) {
        c.kvActionsAllowed = true;
        c.kvKeyMaxStrSz = 63;
        c.kvValMaxStrSz = 63;
        c.kvActionMaxNum = 10;
        c.kvRemoveMaxNum = 100;
    }
    // V0.11.2 changed how messages are displayed. For personal_sign messages
    // we now write the header (`Signer: <path>`) into the main body of the screen.
    // This means personal sign message max size is slightly smaller than for
    // EIP712 messages because in the latter case there is no header
    // Note that `<path>` has max size of 62 bytes (`m/X/X/...`)
    if (!legacy && gte(v, [0, 11, 2])) {
        c.personalSignHeaderSz = 72;
    }
    // V0.11.0 allows new ETH transaction types
    if (!legacy && gte(v, [0, 11, 0])) {
        c.allowedEthTxTypesVersion = 1;
        c.allowedEthTxTypes = [
            1,
            2, // eip1559
        ];
        c.totalExtraEthTxDataSz = 10;
    }
    // V0.10.10 allows a user to sign a prehashed ETH message if payload too big
    if (!legacy && gte(v, [0, 10, 10])) {
        c.ethMsgPreHashAllowed = true;
    }
    // V0.10.8 allows a user to sign a prehashed transaction if the payload
    // is too big
    if (!legacy && gte(v, [0, 10, 8])) {
        c.prehashAllowed = true;
    }
    // V0.10.5 added the ability to use flexible address path sizes, which
    // changes the `getAddress` API. It also added support for EIP712
    if (!legacy && gte(v, [0, 10, 5])) {
        c.varAddrPathSzAllowed = true;
        c.eip712Supported = true;
    }
    // V0.10.4 introduced the ability to send signing requests over multiple
    // data frames (i.e. in multiple requests)
    if (!legacy && gte(v, [0, 10, 4])) {
        c.extraDataFrameSz = 1500; // 1500 bytes per frame of extraData allowed
        c.extraDataMaxFrames = 1; // 1 frame of extraData allowed
    }
    return c;
}
exports.getFwVersionConst = getFwVersionConst;
var ASCII_REGEX = /^[\x00-\x7F]+$/;
exports.ASCII_REGEX = ASCII_REGEX;

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\client.js", {"./bitcoin":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\bitcoin.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","./ethereum":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereum.js","./ethereumAbi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereumAbi.js","./genericSigning":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\genericSigning.js","./index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\index.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\util.js","bitwise":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\index.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hash.js\\lib\\hash\\sha.js","superagent":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\client.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\client.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var bitwise_1 = __importDefault(require("bitwise"));
var buffer_1 = require("buffer/");
var superagent_1 = __importDefault(require("superagent"));
var bitcoin_1 = __importDefault(require("./bitcoin"));
var sha_1 = require("hash.js/lib/hash/sha");
var index_1 = require("./index");
var constants_1 = require("./constants");
var ethereum_1 = __importDefault(require("./ethereum"));
var ethereumAbi_1 = require("./ethereumAbi");
var genericSigning_1 = require("./genericSigning");
var util_1 = require("./util");
var EMPTY_WALLET_UID = buffer_1.Buffer.alloc(32);
/**
 * `Client` is a class-based interface for managing a Lattice device.
 */
var Client = /** @class */ (function () {
    /**
     * @param params - Parameters are passed as an object.
     */
    function Client(_a) {
        var baseUrl = _a.baseUrl, name = _a.name, privKey = _a.privKey, stateData = _a.stateData, timeout = _a.timeout, retryCount = _a.retryCount;
        // Default state params
        // -----
        this.ephemeralPub = null;
        this.deviceId = null;
        this.isPaired = false;
        this.activeWallets = {
            internal: {
                uid: EMPTY_WALLET_UID,
                name: null,
                capabilities: null,
                external: false,
            },
            external: {
                uid: EMPTY_WALLET_UID,
                name: null,
                capabilities: null,
                external: true,
            },
        };
        // The user may pass in state data to rehydrate a session that was previously cached
        // -----
        if (stateData) {
            this._unpackAndApplyStateData(stateData);
            return;
        }
        // Other params to check if `stateData` is not included
        // -----
        // `baseUrl` describes where to send HTTP requests
        this.baseUrl = baseUrl || constants_1.BASE_URL;
        // `name` is a human readable string associated with this app on the Lattice
        if (name && (name.length < 5 || name.length > 24)) {
            throw new Error('`name` must be 5-24 characters');
        }
        this.name = name || 'Unknown';
        // `privKey` is used to generate a keypair, which is used for maintaining
        // an encrypted messaging channel with the target Lattice
        this.privKey = privKey || (0, util_1.randomBytes)(32);
        this.key = (0, util_1.getP256KeyPair)(this.privKey);
        // `retryCount` defines the number of automatic retries for asynchronous requests.
        // Retries only happen for certain device errors which indicate retrying is allowed.
        this.retryCount = retryCount || 3;
        // `timeout` is the number of milliseconds allowed before terminating
        // asynchronous requests if no response is returned in time
        this.timeout = timeout || 60000;
    }
    /**
     * Get a JSON string containing state data that can be used to rehydrate a session.
     * Pass the contents of this to the constructor as `stateData` to rehydrate.
     */
    Client.prototype.getStateData = function () {
        return this._packStateData();
    };
    //=======================================================================
    // LATTICE FUNCTIONS
    //=======================================================================
    /**
     * `connect` will attempt to contact a device based on its deviceId. The response should include
     * an ephemeral public key, which is used to pair with the device in a later request.
     * @category Lattice
     */
    Client.prototype.connect = function (deviceId, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            // User may "re-connect" if a device ID has previously been stored
            if (typeof deviceId === 'function') {
                if (!_this.deviceId)
                    return cb('No device ID has been stored. Please connect with your device ID first.');
                cb = deviceId;
            }
            else {
                // If the user passes in a device ID, connect to that device and save
                // the new ID for future use.
                _this.deviceId = deviceId;
            }
            var param = _this._buildRequest(constants_1.deviceCodes.CONNECT, _this.pubKeyBytes());
            _this._request(param, null, function (err, res) {
                if (err)
                    return cb(err);
                _this.isPaired = _this._handleConnect(res) || false;
                // Check for an active wallet. This will get bypassed if we are not paired.
                if (_this.isPaired) {
                    _this._getActiveWallet(function (err) {
                        return cb(err, _this.isPaired);
                    }, true);
                }
                else {
                    return cb(null, false);
                }
            });
        });
    };
    /**
     * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
     * pairing secret. It then sends the name and signature to the device. If no pairing secret is
     * provided, `pair` sends a zero-length name buffer to the device.
     * @category Lattice
     * @returns The active wallet object.
     */
    Client.prototype.pair = function (pairingSecret, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            // Build the secret hash from the salt
            var pubKey = _this.pubKeyBytes();
            var nameBuf = buffer_1.Buffer.alloc(25);
            if (_this.name.length < 5 || _this.name.length > 24) {
                return cb('Invalid length for name provided. Must be 5-24 characters.');
            }
            if (pairingSecret.length > 0) {
                // If a pairing secret of zero length is passed in, it usually indicates
                // we want to cancel the pairing attempt. In this case we pass a zero-length
                // name buffer so the firmware can know not to draw the error screen.
                // Note that we still expect an error to come back (RESP_ERR_PAIR_FAIL)
                nameBuf.write(_this.name);
            }
            // Make sure we add a null termination byte to the pairing secret
            var preImage = buffer_1.Buffer.concat([
                pubKey,
                nameBuf,
                buffer_1.Buffer.from(pairingSecret),
            ]);
            var hash = buffer_1.Buffer.from((0, sha_1.sha256)().update(preImage).digest('hex'), 'hex');
            var sig = _this.key.sign(hash); // returns an array, not a buffer
            var derSig = (0, util_1.toPaddedDER)(sig);
            var payload = buffer_1.Buffer.concat([nameBuf, derSig]);
            // Build the request
            _this._request(payload, 'FINALIZE_PAIRING', function (err, res) {
                if (err)
                    return cb(err);
                // Recover the ephemeral key
                var errStr = _this._handlePair(res);
                if (errStr)
                    return cb(errStr);
                // Try to get the active wallet once pairing is successful
                _this._getActiveWallet(function (err) {
                    if (err)
                        return cb(err);
                    return cb(null, _this.hasActiveWallet());
                }, true);
            });
        });
    };
    /**
     * `test` takes a data object with a testID and a payload, and sends them to the device.
     * @category Lattice
     */
    Client.prototype.test = function (data, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            if (!data.payload)
                return cb('First argument must contain `testID` and `payload` fields.');
            var TEST_DATA_SZ = 500;
            var payload = buffer_1.Buffer.alloc(TEST_DATA_SZ + 6);
            payload.writeUInt32BE(data.testID, 0);
            payload.writeUInt16BE(data.payload.length, 4);
            data.payload.copy(payload, 6);
            _this._request(payload, 'TEST', function (err, res) {
                if (err)
                    return cb(err);
                var decrypted = _this._handleEncResponse(res, constants_1.decResLengths.test);
                if (decrypted.err !== null)
                    return cb(decrypted.err);
                return cb(null, decrypted.data.slice(65)); // remove ephem pub
            });
        });
    };
    /**
     * `getAddresses` takes a starting path and a number to get the addresses associated with the
     * active wallet.
     * @category Lattice
     * @returns An array of addresses.
     */
    Client.prototype.getAddresses = function (opts, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var MAX_ADDR = 10;
            var startPath = opts.startPath, n = opts.n, _a = opts.flag, flag = _a === void 0 ? 0 : _a;
            if (startPath === undefined || n === undefined)
                return cb('Please provide `startPath` and `n` options');
            if (startPath.length < 2 || startPath.length > 5)
                return cb('Path must include between 2 and 5 indices');
            if (n > MAX_ADDR)
                return cb("You may only request ".concat(MAX_ADDR, " addresses at once."));
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (!(0, util_1.isValidAssetPath)(startPath, fwConstants))
                return cb('Parent derivation path is not supported');
            var sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag
            if (fwConstants.varAddrPathSzAllowed) {
                sz += 1; // pathDepth
            }
            else if (startPath.length !== 5) {
                return cb('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.');
            }
            var payload = buffer_1.Buffer.alloc(sz);
            var off = 0;
            // WalletUID
            var wallet = _this.getActiveWallet();
            if (wallet === null)
                return cb('No active wallet.');
            wallet.uid.copy(payload, off);
            off += 32;
            // Build the start path (5x u32 indices)
            if (fwConstants.varAddrPathSzAllowed) {
                payload.writeUInt8(startPath.length, off);
                off += 1;
            }
            for (var i = 0; i < 5; i++) {
                if (i <= startPath.length)
                    payload.writeUInt32BE(startPath[i], off);
                off += 4;
            }
            // Specify the number of subsequent addresses to request.
            // We also allow the user to skip the cache and request any address related to the asset
            // in the wallet.
            var val, flagVal = 0;
            if (fwConstants.addrFlagsAllowed) {
                // A 4-bit flag can be used for non-standard address requests
                // This needs to be combined with `n` as a 4 bit value
                flagVal = (fwConstants.getAddressFlags &&
                    fwConstants.getAddressFlags.indexOf(flag) > -1)
                    ? flag : 0;
                var flagBits = bitwise_1.default.nibble.read(flagVal);
                var countBits = bitwise_1.default.nibble.read(n);
                val = bitwise_1.default.byte.write(flagBits.concat(countBits));
            }
            else {
                // Very old firmware does not support this flag. We can deprecate this soon.
                val = n;
            }
            payload.writeUInt8(val, off);
            off++;
            return _this._request(payload, 'GET_ADDRESSES', function (err, res) {
                if (err)
                    return cb(err);
                var parsedRes = _this._handleGetAddresses(res, flagVal);
                if (parsedRes.err)
                    return cb(parsedRes.err);
                return cb(null, parsedRes.data);
            });
        });
    };
    /**
     * `sign` builds and sends a request for signing to the device.
     * @category Lattice
     * @returns The response from the device.
     */
    Client.prototype.sign = function (opts, _cb, cachedData, nextCode) {
        var _this = this;
        if (cachedData === void 0) { cachedData = null; }
        if (nextCode === void 0) { nextCode = null; }
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var currency = opts.currency;
            var data = opts.data;
            if (!data) {
                return cb('You must provide `data`');
            }
            // All transaction requests must be put into the same sized buffer.
            // This comes from sizeof(GpTransactionRequest_t), but note we remove
            // the 2-byte schemaId since it is not returned from our resolver.
            // Note that different firmware versions may have different data sizes.
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            // Build the signing request payload to send to the device. If we catch
            // bad params, return an error instead
            data = __assign({ fwConstants: fwConstants }, data);
            var req, reqPayload;
            var schema;
            if (cachedData !== null && nextCode !== null) {
                req = cachedData;
                reqPayload = buffer_1.Buffer.concat([nextCode, req.extraDataPayloads.shift()]);
                schema = constants_1.signingSchema.EXTRA_DATA;
            }
            else {
                try {
                    if (currency === 'ETH') {
                        req = ethereum_1.default.buildEthereumTxRequest(data);
                    }
                    else if (currency === 'ETH_MSG') {
                        req = ethereum_1.default.buildEthereumMsgRequest(data);
                    }
                    else if (currency === 'BTC') {
                        req = bitcoin_1.default.buildBitcoinTxRequest(data);
                    }
                    else {
                        req = (0, genericSigning_1.buildGenericSigningMsgRequest)(data);
                    }
                }
                catch (err) {
                    return cb("Error building signing request: ".concat(err.message));
                }
                if (req.err !== undefined)
                    return cb(req.err);
                if (req.payload.length > fwConstants.reqMaxDataSz)
                    return cb('Transaction is too large');
                reqPayload = req.payload;
                schema = req.schema;
            }
            // Build the payload
            var payload = buffer_1.Buffer.alloc(2 + fwConstants.reqMaxDataSz);
            var off = 0;
            // Whether there will be follow up requests
            var hasExtraPayloads = req.extraDataPayloads && Number(req.extraDataPayloads.length > 0);
            payload.writeUInt8(hasExtraPayloads, off);
            off += 1;
            // Copy request schema (e.g. ETH or BTC transfer)
            payload.writeUInt8(schema, off);
            off += 1;
            // Copy the wallet UID
            var wallet = _this.getActiveWallet();
            if (wallet === null)
                return cb('No active wallet.');
            wallet.uid.copy(payload, off);
            off += wallet.uid.length;
            // Build data based on the type of request
            // Copy the payload of the request
            reqPayload.copy(payload, off);
            // Construct the encrypted request and send it
            return _this._request(payload, 'SIGN_TRANSACTION', function (err, res) {
                if (err) {
                    // If there was another error caught, return it
                    if (err)
                        return cb(err);
                }
                else if (hasExtraPayloads) {
                    var decrypted = _this._handleEncResponse(res, constants_1.decResLengths.sign);
                    nextCode = decrypted.data.slice(65, 73);
                    if (!cachedData)
                        cachedData = req;
                    return _this.sign(opts, cb, cachedData, nextCode);
                }
                else {
                    // Correct wallet and no errors -- handle the response
                    try {
                        var parsedRes = _this._handleSign(res, currency, req);
                        return cb(null, parsedRes);
                    }
                    catch (err) {
                        return cb(err.message);
                    }
                }
            });
        });
    };
    /**
     * `addAbiDefs` sends a list of ABI definitions to the device in chunks of up to `MAX_ABI_DEFS`.
     * @category Lattice
     * @returns The decrypted response.
     */
    Client.prototype.addAbiDefs = function (defs, _cb, nextCode) {
        var _this = this;
        if (nextCode === void 0) { nextCode = null; }
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var defsToAdd = defs.slice(0, ethereumAbi_1.MAX_ABI_DEFS);
            defs = defs.slice(ethereumAbi_1.MAX_ABI_DEFS);
            var abiPayload;
            try {
                abiPayload = (0, ethereumAbi_1.buildAddAbiPayload)(defsToAdd);
            }
            catch (err) {
                return cb(err);
            }
            var payload = buffer_1.Buffer.alloc(abiPayload.length + 10);
            // Let the firmware know how many defs are remaining *after this one*.
            // If this is a positive number, firmware will send us a temporary code
            // to bypass user authorization if the user has configured easy ABI loading.
            payload.writeUInt16LE(defs.length, 0);
            // If this is a follow-up request, we don't need to ask for user authorization
            // if we use the correct temporary u64
            if (nextCode !== null)
                nextCode.copy(payload, 2);
            abiPayload.copy(payload, 10);
            return _this._request(payload, 'ADD_ABI_DEFS', function (err, res, responseCode) {
                if (responseCode && responseCode !== constants_1.responseCodes.RESP_SUCCESS)
                    return cb('Error making request.');
                else if (err)
                    return cb(err);
                var decrypted = _this._handleEncResponse(res, constants_1.decResLengths.addAbiDefs);
                // Grab the 8 byte code to fast track our next request, if needed
                nextCode = decrypted.data.slice(65, 73);
                // No defs left? Return success
                if (defs.length === 0)
                    return cb(null);
                // Add the next set
                _this.addAbiDefs(defs, cb, nextCode);
            });
        });
    };
    /**
     * `getAbiRecords` fetches a set of ABI records saved on the Lattice. You can fetch
     * sequential records based on a starting index and count.
     * @category Lattice
     * @returns The decrypted response.
     */
    Client.prototype.getAbiRecords = function (opts, _cb, fetched) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var _a = opts.n, n = _a === void 0 ? 1 : _a, _b = opts.startIdx, startIdx = _b === void 0 ? 0 : _b, _c = opts.category, category = _c === void 0 ? '' : _c;
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (n < 1) {
                return cb('Must request at least one record (n=0)');
            }
            else if (n < 0 || startIdx < 0) {
                return cb('Both `n` and `startIdx` must be >=0');
            }
            else if (!fwConstants.abiCategorySz) {
                return cb('Outdated Lattice firmware. Please update.');
            }
            else if (category.length >= fwConstants.abiCategorySz) {
                return cb("category must be <".concat(fwConstants.abiCategorySz - 1, " characters, got ").concat(category.length));
            }
            if (!fetched) {
                fetched = {
                    startIdx: startIdx,
                    numRemaining: null,
                    numFetched: null,
                    records: [],
                };
            }
            var payload = buffer_1.Buffer.alloc(4 + fwConstants.abiCategorySz);
            payload.writeUInt16LE(startIdx, 0);
            payload.writeUInt16LE(n, 2);
            buffer_1.Buffer.from(category).copy(payload, 4);
            return _this._request(payload, 'GET_ABI_RECORDS', function (err, res) {
                if (err) {
                    return cb(err);
                }
                // Correct wallet and no errors -- handle the response
                var d = _this._handleEncResponse(res, constants_1.decResLengths.getAbiRecords);
                if (d.err)
                    return cb(d.err);
                // Decode the response
                var off = 65; // Skip 65 byte pubkey prefix
                var numRemaining = d.data.readUInt32LE(off);
                off += 4;
                var numReturned = d.data.readUInt8(off);
                off += 1;
                // Start adding data if there is data to add
                fetched.numRemaining = numRemaining;
                if (!fetched.records) {
                    fetched.records = [];
                }
                for (var i = 0; i < numReturned; i++) {
                    // Parse and add the def
                    var packedDef = d.data.slice(off, off + ethereumAbi_1.ABI_DEF_SZ);
                    off += ethereumAbi_1.ABI_DEF_SZ;
                    fetched.records.push((0, ethereumAbi_1.unpackAbiDef)(packedDef));
                }
                // Decrement the total counter
                opts.n -= numReturned;
                if (opts.n < 1 || numReturned < 1) {
                    fetched.numFetched = fetched.records.length;
                    return cb(null, fetched);
                }
                else {
                    // Recurse if there is more to fetch
                    opts.startIdx += numReturned;
                    return _this.getAbiRecords(opts, cb, fetched);
                }
            });
        });
    };
    /**
     * `removeAbiRecords` requests removal of ABI records on the device. You can request
     * removal based on a desired set of function signatures.
     * @category Lattice
     * @returns The decrypted response.
     */
    Client.prototype.removeAbiRecords = function (opts, _cb, cbData) {
        var _this = this;
        if (cbData === void 0) { cbData = { numRemoved: 0, numTried: 0 }; }
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var sigs = opts.sigs;
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (!fwConstants.abiMaxRmv) {
                return cb('Outdated Lattice firmware. Please update.');
            }
            else if (sigs.length === 0) {
                return cb('At least one signature in `sigs` must be provided.');
            }
            var sigsSlice = sigs.slice(cbData.numTried, cbData.numTried + fwConstants.abiMaxRmv);
            var payload = buffer_1.Buffer.alloc(1 + (4 * fwConstants.abiMaxRmv));
            var off = 0;
            payload.writeUInt8(sigsSlice.length, off);
            off += 1;
            sigsSlice.forEach(function (sig) {
                try {
                    var sigBuf = ethereum_1.default.ensureHexBuffer(sig);
                    if (sigBuf.length !== 4) {
                        return cb('Signatures must be 4 bytes.');
                    }
                    sigBuf.copy(payload, off);
                    off += 4;
                }
                catch (err) {
                    return cb("Error writing signature: ".concat(err.message));
                }
            });
            return _this._request(payload, 'REMOVE_ABI_RECORDS', function (err, res) {
                if (err) {
                    return cb(err);
                }
                // Correct wallet and no errors -- handle the response
                var d = _this._handleEncResponse(res, constants_1.decResLengths.removeAbiRecords);
                if (d.err)
                    return cb(d.err);
                // Decode the response
                var off = 65; // Skip 65 byte pubkey prefix
                var rmv = d.data.readUInt8(off);
                off += 1;
                cbData.numRemoved += rmv;
                cbData.numTried += sigsSlice.length;
                if (cbData.numTried >= opts.sigs.length) {
                    return cb(null, cbData);
                }
                else {
                    // Recurse if there are more to remove
                    return _this.removeAbiRecords(opts, cb, cbData);
                }
            });
        });
    };
    /**
     * `addPermissionV0` takes in a currency, time window, spending limit, and decimals, and builds a
     * payload to send to the Lattice.
     * @category Lattice
     */
    Client.prototype.addPermissionV0 = function (opts, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var currency = opts.currency, timeWindow = opts.timeWindow, limit = opts.limit, decimals = opts.decimals, asset = opts.asset;
            if (!currency ||
                timeWindow === undefined ||
                limit === undefined ||
                decimals === undefined ||
                timeWindow === null ||
                limit === null ||
                decimals === null)
                return cb('currency, timeWindow, decimals, and limit are all required options.');
            else if (timeWindow === 0 || limit === 0)
                return cb('Time window and spending limit must be positive.');
            // Build the name of the permission
            var name = currency;
            if (asset)
                name += "_".concat(asset);
            // Start building the payload
            var payload = buffer_1.Buffer.alloc(293);
            // Copy the name
            if (buffer_1.Buffer.from(name).length > 255)
                return cb('Asset name too long.');
            buffer_1.Buffer.from(name).copy(payload, 0);
            // Convert the limit to a 32 byte hex buffer and copy it in
            var limitBuf = ethereum_1.default.ensureHexBuffer(limit);
            if (limitBuf.length > 32)
                return cb('Limit too large.');
            limitBuf.copy(payload, 256 + (32 - limitBuf.length));
            // Copy the time window (seconds)
            payload.writeUInt32BE(timeWindow, 288);
            payload.writeUInt8(decimals, 292);
            // Encrypt the request and send it to the Lattice.
            return _this._request(payload, 'ADD_PERMISSION_V0', function (err, res) {
                if (err) {
                    // If there was another error caught, return it
                    if (err)
                        return cb(err);
                }
                else {
                    // Correct wallet and no errors -- handle the response
                    var d = _this._handleEncResponse(res, constants_1.decResLengths.empty);
                    if (d.err)
                        return cb(d.err);
                    return cb(null);
                }
            });
        });
    };
    /**
     * `getKvRecords` fetches a list of key-value records from the Lattice.
     * @category Lattice
     */
    Client.prototype.getKvRecords = function (opts, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var _a = opts.type, type = _a === void 0 ? 0 : _a, _b = opts.n, n = _b === void 0 ? 1 : _b, _c = opts.start, start = _c === void 0 ? 0 : _c;
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (!fwConstants.kvActionsAllowed) {
                return cb('Unsupported. Please update firmware.');
            }
            else if (n < 1) {
                return cb('You must request at least one record.');
            }
            else if (n > fwConstants.kvActionMaxNum) {
                return cb("You may only request up to ".concat(fwConstants.kvActionMaxNum, " records at once."));
            }
            var payload = buffer_1.Buffer.alloc(9);
            payload.writeUInt32LE(type, 0);
            payload.writeUInt8(n, 4);
            payload.writeUInt32LE(start, 5);
            // Encrypt the request and send it to the Lattice.
            return _this._request(payload, 'GET_KV_RECORDS', function (err, res) {
                if (err) {
                    // If there was another error caught, return it
                    if (err)
                        return cb(err);
                }
                else {
                    // Correct wallet and no errors -- handle the response
                    var d = _this._handleEncResponse(res, constants_1.decResLengths.getKvRecords);
                    if (d.err)
                        return cb(d.err);
                    // Decode the response
                    var off = 65; // Skip 65 byte pubkey prefix
                    var nTotal = parseInt(d.data.slice(off, off + 4).toString('hex'), 16);
                    off += 4;
                    var nFetched = parseInt(d.data.slice(off, off + 1).toString('hex'), 16);
                    off += 1;
                    if (nFetched > fwConstants.kvActionMaxNum)
                        return cb('Too many records fetched. Firmware error.');
                    var records = [];
                    for (var i = 0; i < nFetched; i++) {
                        var r = {};
                        r.id = parseInt(d.data.slice(off, off + 4).toString('hex'), 16);
                        off += 4;
                        r.type = parseInt(d.data.slice(off, off + 4).toString('hex'), 16);
                        off += 4;
                        r.caseSensitive =
                            parseInt(d.data.slice(off, off + 1).toString('hex'), 16) === 1
                                ? true
                                : false;
                        off += 1;
                        var keySz = parseInt(d.data.slice(off, off + 1).toString('hex'), 16);
                        off += 1;
                        r.key = d.data.slice(off, off + keySz - 1).toString();
                        off += fwConstants.kvKeyMaxStrSz + 1;
                        var valSz = parseInt(d.data.slice(off, off + 1).toString('hex'), 16);
                        off += 1;
                        r.val = d.data.slice(off, off + valSz - 1).toString();
                        off += fwConstants.kvValMaxStrSz + 1;
                        records.push(r);
                    }
                    return cb(null, { records: records, total: nTotal, fetched: nFetched });
                }
            });
        });
    };
    /**
     * `addKvRecords` takes in a set of key-value records and sends a request to add them to the
     * Lattice.
     * @category Lattice
     * @returns A callback with an error or null.
     */
    Client.prototype.addKvRecords = function (opts, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var _a = opts.type, type = _a === void 0 ? 0 : _a, _b = opts.records, records = _b === void 0 ? {} : _b, _c = opts.caseSensitive, caseSensitive = _c === void 0 ? false : _c;
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (!fwConstants.kvActionsAllowed) {
                return cb('Unsupported. Please update firmware.');
            }
            else if (typeof records !== 'object' ||
                Object.keys(records).length === 0) {
                return cb('One or more key-value mapping must be provided in `records` param.');
            }
            else if (Object.keys(records).length > fwConstants.kvActionMaxNum) {
                return cb("Too many keys provided. Please only provide up to ".concat(fwConstants.kvActionMaxNum, "."));
            }
            else if (Object.keys(records).length < 1) {
                return cb('You must provide at least one key to add.');
            }
            var payload = buffer_1.Buffer.alloc(1 + 139 * fwConstants.kvActionMaxNum);
            payload.writeUInt8(Object.keys(records).length, 0);
            var off = 1;
            try {
                Object.keys(records).forEach(function (key) {
                    if (typeof key !== 'string' ||
                        String(key).length > fwConstants.kvKeyMaxStrSz) {
                        throw new Error("Key ".concat(key, " too large. Must be <=").concat(fwConstants.kvKeyMaxStrSz, " characters."));
                    }
                    else if (typeof records[key] !== 'string' ||
                        String(records[key]).length > fwConstants.kvValMaxStrSz) {
                        throw new Error("Value ".concat(records[key], " too large. Must be <=").concat(fwConstants.kvValMaxStrSz, " characters."));
                    }
                    else if (String(key).length === 0 ||
                        String(records[key]).length === 0) {
                        throw new Error('Keys and values must be >0 characters.');
                    }
                    else if (!constants_1.ASCII_REGEX.test(key) || !constants_1.ASCII_REGEX.test(records[key])) {
                        throw new Error('Unicode characters are not supported.');
                    }
                    // Skip the ID portion. This will get added by firmware.
                    payload.writeUInt32LE(0, off);
                    off += 4;
                    payload.writeUInt32LE(type, off);
                    off += 4;
                    payload.writeUInt8(caseSensitive ? 1 : 0, off);
                    off += 1;
                    payload.writeUInt8(String(key).length + 1, off);
                    off += 1;
                    buffer_1.Buffer.from(String(key)).copy(payload, off);
                    off += fwConstants.kvKeyMaxStrSz + 1;
                    payload.writeUInt8(String(records[key]).length + 1, off);
                    off += 1;
                    buffer_1.Buffer.from(String(records[key])).copy(payload, off);
                    off += fwConstants.kvValMaxStrSz + 1;
                });
            }
            catch (err) {
                return cb("Error building request: ".concat(err.message));
            }
            // Encrypt the request and send it to the Lattice.
            return _this._request(payload, 'ADD_KV_RECORDS', function (err, res) {
                if (err) {
                    // If there was another error caught, return it
                    if (err)
                        return cb(err);
                }
                else {
                    // Correct wallet and no errors -- handle the response
                    var d = _this._handleEncResponse(res, constants_1.decResLengths.empty);
                    if (d.err)
                        return cb(d.err);
                    return cb(null);
                }
            });
        });
    };
    /**
     * `removeKvRecords` takes in an array of ids and sends a request to remove them from the Lattice.
     * @category Lattice
     * @returns A callback with an error or null.
     */
    Client.prototype.removeKvRecords = function (opts, _cb) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var cb = (0, util_1.promisifyCb)(resolve, reject, _cb);
            var _a = opts.type, type = _a === void 0 ? 0 : _a, _b = opts.ids, ids = _b === void 0 ? [] : _b;
            var fwConstants = (0, constants_1.getFwVersionConst)(_this.fwVersion);
            if (!fwConstants.kvActionsAllowed) {
                return cb('Unsupported. Please update firmware.');
            }
            else if (!Array.isArray(ids) || ids.length < 1) {
                return cb('You must include one or more `ids` to removed.');
            }
            else if (ids.length > fwConstants.kvRemoveMaxNum) {
                return cb("Only up to ".concat(fwConstants.kvRemoveMaxNum, " records may be removed at once."));
            }
            var payload = buffer_1.Buffer.alloc(5 + 4 * fwConstants.kvRemoveMaxNum);
            payload.writeUInt32LE(type, 0);
            payload.writeUInt8(ids.length, 4);
            for (var i = 0; i < ids.length; i++) {
                payload.writeUInt32LE(ids[i], 5 + 4 * i);
            }
            // Encrypt the request and send it to the Lattice.
            return _this._request(payload, 'REMOVE_KV_RECORDS', function (err, res) {
                if (err) {
                    // If there was another error caught, return it
                    if (err)
                        return cb(err);
                }
                else {
                    // Correct wallet and no errors -- handle the response
                    var d = _this._handleEncResponse(res, constants_1.decResLengths.empty);
                    if (d.err)
                        return cb(d.err);
                    return cb(null);
                }
            });
        });
    };
    //=======================================================================
    // INTERNAL FUNCTIONS
    // These handle the logic around building requests and consuming
    // responses. They take into account the Lattice's serialization scheme
    // among other protocols.
    //=======================================================================
    /**
     * Get the active wallet in the device. If we already have one recorded, we don't need to do
     * anything
     * @internal
     * @returns callback
     */
    Client.prototype._getActiveWallet = function (cb, forceRefresh) {
        var _this = this;
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (forceRefresh !== true &&
            (this.hasActiveWallet() === true || this.isPaired !== true)) {
            // If the active wallet already exists, or if we are not paired, skip the request
            return cb(null);
        }
        else {
            // No active wallet? Get it from the device
            var payload = buffer_1.Buffer.alloc(0);
            return this._request(payload, 'GET_WALLETS', function (err, res) {
                if (err) {
                    _this._resetActiveWallets();
                    return cb(err);
                }
                return cb(_this._handleGetWallets(res));
            });
        }
    };
    /**
     * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
     * @internal
     * @returns Buffer
     */
    Client.prototype._getSharedSecret = function () {
        // Once every ~256 attempts, we will get a key that starts with a `00` byte, which
        // can lead to problems initializing AES if we don't force a 32 byte BE buffer.
        return buffer_1.Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));
    };
    /**
     * Get the ephemeral id, which is the first 4 bytes of the shared secret generated from the local
     * private key and the ephemeral public key from the device.
     * @internal
     * @returns Buffer
     */
    Client.prototype._getEphemId = function () {
        if (this.ephemeralPub === null)
            return null;
        // EphemId is the first 4 bytes of the hash of the shared secret
        var secret = this._getSharedSecret();
        var hash = buffer_1.Buffer.from((0, sha_1.sha256)().update(secret).digest('hex'), 'hex');
        return hash.slice(0, 4);
    };
    /**
     * Builds an encrypted request
     * @internal
     */
    Client.prototype._buildEncRequest = function (enc_request_code, payload) {
        // Get the ephemeral id - all encrypted requests require there to be an
        // epehemeral public key in order to send
        var ephemId = parseInt(this._getEphemId().toString('hex'), 16);
        // Build the payload and checksum
        var payloadPreCs = buffer_1.Buffer.concat([
            buffer_1.Buffer.from([enc_request_code]),
            payload,
        ]);
        var cs = (0, util_1.checksum)(payloadPreCs);
        var payloadBuf = buffer_1.Buffer.alloc(payloadPreCs.length + 4);
        // Lattice validates checksums in little endian
        payloadPreCs.copy(payloadBuf, 0);
        payloadBuf.writeUInt32LE(cs, payloadPreCs.length);
        // Encrypt this payload
        var secret = this._getSharedSecret();
        var newEncPayload = (0, util_1.aes256_encrypt)(payloadBuf, secret);
        // Write to the overall payload. We must use the same length
        // for every encrypted request and must include a 32-bit ephemId
        // along with the encrypted data
        var newPayload = buffer_1.Buffer.alloc(constants_1.ENC_MSG_LEN + 4);
        // First 4 bytes are the ephemeral id (in little endian)
        newPayload.writeUInt32LE(ephemId, 0);
        // Next N bytes
        newEncPayload.copy(newPayload, 4);
        return this._buildRequest(constants_1.deviceCodes.ENCRYPTED_REQUEST, newPayload);
    };
    /**
     * Build a request to send to the device.
     * @internal
     * @param request_code {uint8} - 8-bit unsigned integer representing the message request code
     * @param id {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)
     * @param payload {buffer} - serialized payload
     * @returns {buffer}
     */
    Client.prototype._buildRequest = function (request_code, payload) {
        // Length of payload;
        // we add 1 to the payload length to account for the request_code byte
        var L = payload && buffer_1.Buffer.isBuffer(payload) ? payload.length + 1 : 1;
        if (request_code === constants_1.deviceCodes.ENCRYPTED_REQUEST) {
            L = 1 + payload.length;
        }
        var i = 0;
        var preReq = buffer_1.Buffer.alloc(L + 8);
        // Build the header
        i = preReq.writeUInt8(constants_1.VERSION_BYTE, i);
        i = preReq.writeUInt8(constants_1.REQUEST_TYPE_BYTE, i);
        var id = (0, util_1.randomBytes)(4);
        i = preReq.writeUInt32BE(parseInt("0x".concat(id.toString('hex'))), i);
        i = preReq.writeUInt16BE(L, i);
        // Build the payload
        i = preReq.writeUInt8(request_code, i);
        if (L > 1)
            i = payload.copy(preReq, i);
        // Add the checksum
        var cs = (0, util_1.checksum)(preReq);
        var req = buffer_1.Buffer.alloc(preReq.length + 4); // 4-byte checksum
        i = preReq.copy(req);
        req.writeUInt32BE(cs, i);
        return req;
    };
    /**
     * Send a request to the device and wait for a response.
     * @internal
     * @returns The response code.
     */
    Client.prototype._request = function (payload, encReqCode, cb, retryCount) {
        var _this = this;
        if (retryCount === void 0) { retryCount = this.retryCount; }
        if (!this.deviceId) {
            return cb('Device ID is not set. Please set it and try again.');
        }
        else if (encReqCode && constants_1.encReqCodes[encReqCode] === undefined) {
            return cb('Unknown encrypted request code.');
        }
        // Encrypt the data if appropriate. Most requests are end-to-end encrypted,
        // but some (e.g. CONNNECT) are not encrypted.
        var data = encReqCode
            ? this._buildEncRequest(constants_1.encReqCodes[encReqCode], payload)
            : payload;
        var url = "".concat(this.baseUrl, "/").concat(this.deviceId);
        superagent_1.default
            .post(url)
            .timeout(this.timeout)
            .send({ data: data })
            .then(function (res) {
            // Handle formatting or generic HTTP errors
            if (!res || !res.body) {
                return cb("Invalid response: ".concat(res));
            }
            else if (res.body.status !== 200) {
                return cb("Error code ".concat(res.body.status, ": ").concat(res.body.message));
            }
            // Handle retry logic
            var parsed = (0, util_1.parseLattice1Response)(res.body.message);
            var deviceBusy = parsed.responseCode === constants_1.responseCodes.RESP_ERR_DEV_BUSY ||
                parsed.responseCode === constants_1.responseCodes.RESP_ERR_GCE_TIMEOUT;
            var wrongWallet = parsed.responseCode === constants_1.responseCodes.RESP_ERR_WRONG_WALLET;
            var invalidEphemId = parsed.responseCode === constants_1.responseCodes.RESP_ERR_INVALID_EPHEM_ID;
            var canRetry = retryCount > 0;
            // Re-connect and/or retry request if needed
            if (canRetry && deviceBusy) {
                // Wait a few seconds and retry
                setTimeout(function () {
                    _this._request(payload, encReqCode, cb, retryCount - 1);
                }, 3000);
            }
            else if (canRetry && invalidEphemId) {
                // Encrypted channel got out of sync. Reconnect and retry.
                _this.connect(_this.deviceId, function (err, isPaired) {
                    if (err) {
                        // Abort on connection error
                        return cb(err);
                    }
                    else if (!isPaired) {
                        // Abort if we are not paired
                        return cb('Not paired to device.');
                    }
                    _this._request(payload, encReqCode, cb, retryCount - 1);
                });
            }
            else if (canRetry && wrongWallet) {
                // Incorrect wallet being requested. Clear wallet state.
                _this._resetActiveWallets();
                // Reconnect, update wallet UID, and retry
                _this.connect(_this.deviceId, function (err, isPaired) {
                    if (err) {
                        // Abort on connection error
                        return cb(err);
                    }
                    else if (!isPaired) {
                        // Abort if we are not paired
                        return cb('Not paired to device.');
                    }
                    // Include the new wallet UID in the payload and retry
                    payload = _this._replaceWalletUID(encReqCode, payload);
                    if (!payload) {
                        // Not allowed to retry. Exit here.
                        return cb('Wrong wallet. Failed to switch. Please reconnect.');
                    }
                    _this._request(payload, encReqCode, cb, retryCount - 1);
                });
            }
            else if (parsed.responseCode || parsed.err) {
                if (parsed.err) {
                    return cb(parsed.err);
                }
                cb(constants_1.responseMsgs[parsed.responseCode] || 'Unknown request failure');
            }
            else {
                // All good
                cb(null, parsed.data, parsed.responseCode);
            }
        })
            .catch(function (err) {
            var isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';
            if (isTimeout)
                return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');
            else
                return cb("Failed to make request to device: ".concat(err.message));
        });
    };
    // ----- Device response -----
    /**
    * `_handleConnect` will call `StartPairingMode` on the device, which gives the user 60 seconds to finalize
    * the pairing. This will return an ephemeral public key, which is needed for the next request.
    * - If the device is already paired, this ephemPub is simply used to encrypt the next request.
    * - If the device is not paired, it is needed to pair the device within 60 seconds.
    * @category Device Response
    * @internal
    * @returns true if we are paired to the device already
    */
    Client.prototype._handleConnect = function (res) {
        var off = 0;
        var pairingStatus = res.readUInt8(off);
        off++;
        // If we are already paired, we get the next ephemeral key
        var pub = res.slice(off, off + 65).toString('hex');
        off += 65;
        // Grab the firmware version (will be 0-length for older fw versions)
        // It is of format |fix|minor|major|reserved|
        this.fwVersion = res.slice(off, off + 4);
        // Set the public key
        this.ephemeralPub = (0, util_1.getP256KeyPairFromPub)(pub);
        // return the state of our pairing
        return pairingStatus === constants_1.messageConstants.PAIRED;
    };
    /**
     * All encrypted responses must be decrypted with the previous shared secret. Per specification,
     * decrypted responses will all contain a 65-byte public key as the prefix, which becomes the new
     * `ephemeralPub`.
     * @category Device Response
     * @internal
     */
    Client.prototype._handleEncResponse = function (encRes, len) {
        // Decrypt response
        var secret = this._getSharedSecret();
        var encData = encRes.slice(0, constants_1.ENC_MSG_LEN);
        var res = (0, util_1.aes256_decrypt)(encData, secret);
        // len does not include a 65-byte pubkey that prefies each encResponse
        len += 65;
        // Validate checksum. It will be the last 4 bytes of the decrypted payload.
        // The length of the decrypted payload will be fixed for each given message type.
        var toCheck = res.slice(0, len);
        var cs = parseInt("0x".concat(res.slice(len, len + 4).toString('hex')));
        var csCheck = (0, util_1.checksum)(toCheck);
        if (cs !== csCheck)
            return {
                err: "Checksum mismatch in response from Lattice (calculated ".concat(csCheck, ", wanted ").concat(cs, ")"),
            };
        // First 65 bytes is the next ephemeral pubkey
        var pub = res.slice(0, 65).toString('hex');
        try {
            this.ephemeralPub = (0, util_1.getP256KeyPairFromPub)(pub);
            return { err: null, data: res };
        }
        catch (e) {
            return { err: "Error handling getAddresses response: ".concat(e.toString()) };
        }
    };
    /**
     * Pair will create a new pairing if the user successfully enters the secret into the device in
     * time. If successful (`status=0`), the device will return a new ephemeral public key, which is
     * used to derive a shared secret for the next request
     * @category Device Response
     * @internal
     * @returns error (or null)
     */
    Client.prototype._handlePair = function (encRes) {
        var d = this._handleEncResponse(encRes, constants_1.decResLengths.empty);
        if (d.err)
            return d.err;
        this.isPaired = true;
        return null;
    };
    /**
     * @category Device Response
     * @internal
     * @return an array of address strings
     */
    Client.prototype._handleGetAddresses = function (encRes, flag) {
        // Handle the encrypted response
        var decrypted = this._handleEncResponse(encRes, constants_1.decResLengths.getAddresses);
        if (decrypted.err !== null)
            return decrypted;
        var addrData = decrypted.data;
        var off = 65; // Skip 65 byte pubkey prefix
        // Look for addresses until we reach the end (a 4 byte checksum)
        var addrs = [];
        // Pubkeys are formatted differently in the response
        var _a = index_1.Constants.GET_ADDR_FLAGS, ED25519_PUB = _a.ED25519_PUB, SECP256K1_PUB = _a.SECP256K1_PUB;
        var arePubkeys = flag === ED25519_PUB ||
            flag === SECP256K1_PUB;
        if (arePubkeys) {
            off += 1; // skip uint8 representing pubkey type
        }
        while (off + 4 < constants_1.decResLengths.getAddresses) {
            if (arePubkeys) {
                // Pubkeys are shorter and are returned as buffers
                var pubBytes = addrData.slice(off, off + 65);
                var isEmpty = pubBytes.every(function (byte) { return byte === 0x00; });
                if (!isEmpty && flag === ED25519_PUB) {
                    // ED25519 pubkeys are 32 bytes
                    addrs.push(pubBytes.slice(0, 32));
                }
                else if (!isEmpty) {
                    // Only other returned pubkeys are ECC, or 65 bytes
                    // Note that we return full (uncompressed) ECC pubkeys
                    addrs.push(pubBytes);
                }
                off += 65;
            }
            else {
                // Otherwise we are dealing with address strings
                var addrBytes = addrData.slice(off, off + constants_1.ADDR_STR_LEN);
                off += constants_1.ADDR_STR_LEN;
                // Return the UTF-8 representation
                var len = addrBytes.indexOf(0); // First 0 is the null terminator
                if (len > 0) {
                    addrs.push(addrBytes.slice(0, len).toString());
                }
            }
        }
        return { data: addrs, err: null };
    };
    /**
     * If there is an active wallet, return null. Otherwise, return an error message.
     * @category Device Response
     * @internal
     * @param encRes - The encrypted response from the device.
     */
    Client.prototype._handleGetWallets = function (encRes) {
        var decrypted = this._handleEncResponse(encRes, constants_1.decResLengths.getWallets);
        if (decrypted.err !== null)
            return decrypted;
        var res = decrypted.data;
        var walletUID;
        // Read the external wallet data first. If it is non-null, the external wallet will
        // be the active wallet of the device and we should save it.
        // If the external wallet is blank, it means there is no card present and we should
        // save and use the interal wallet.
        // If both wallets are empty, it means the device still needs to be set up.
        var walletDescriptorLen = 71;
        // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name
        var off = 65;
        // Internal first
        var hasActiveWallet = false;
        walletUID = res.slice(off, off + 32);
        this.activeWallets.internal.uid = walletUID;
        this.activeWallets.internal.capabilities = res.readUInt32BE(off + 32);
        this.activeWallets.internal.name = res.slice(off + 36, off + walletDescriptorLen);
        if (!walletUID.equals(EMPTY_WALLET_UID))
            hasActiveWallet = true;
        // Offset the first item
        off += walletDescriptorLen;
        // External
        walletUID = res.slice(off, off + 32);
        this.activeWallets.external.uid = walletUID;
        this.activeWallets.external.capabilities = res.readUInt32BE(off + 32);
        this.activeWallets.external.name = res.slice(off + 36, off + walletDescriptorLen);
        if (!walletUID.equals(EMPTY_WALLET_UID))
            hasActiveWallet = true;
        if (hasActiveWallet === true)
            return null;
        else
            return 'No active wallet.';
    };
    /**
     * `_handleSign` takes the encrypted response from the device and decrypts it. It then parses the
     * decrypted response and returns the data.
     * @category Device Response
     * @internal
     * @param encRes - The encrypted response from the server
     * @param currencyType - The type of currency being signed.
     * @param req - The original request data
     * @returns The transaction data, the transaction hash, and the signature.
     */
    Client.prototype._handleSign = function (encRes, currencyType, req) {
        if (req === void 0) { req = null; }
        // Handle the encrypted response
        var decrypted = this._handleEncResponse(encRes, constants_1.decResLengths.sign);
        if (decrypted.err !== null)
            return { err: decrypted.err };
        var PUBKEY_PREFIX_LEN = 65;
        var PKH_PREFIX_LEN = 20;
        var off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix
        var res = decrypted.data;
        // Get the change data if we are making a BTC transaction
        var changeRecipient;
        if (currencyType === 'BTC') {
            var changeVersion = bitcoin_1.default.getAddressFormat(req.origData.changePath);
            var changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN);
            off += PKH_PREFIX_LEN;
            changeRecipient = bitcoin_1.default.getBitcoinAddress(changePubkeyhash, changeVersion);
        }
        var DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long
        var SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots
        var PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;
        if (currencyType === 'BTC') {
            var compressedPubLength = 33; // Size of compressed public key
            var pubkeys = [];
            var sigs = [];
            var n = 0;
            // Parse the signature for each output -- they are returned
            // in the serialized payload in form [pubkey, sig]
            // There is one signature per output
            while (off < res.length) {
                // Exit out if we have seen all the returned sigs and pubkeys
                if (res[off] !== 0x30)
                    break;
                // Otherwise grab another set
                // Note that all DER sigs returned fill the maximum 74 byte buffer, but also
                // contain a length at off+1, which we use to parse the non-zero data.
                // First get the signature from its slot
                var sigStart = off;
                var sigEnd = off + 2 + res[off + 1];
                sigs.push(res.slice(sigStart, sigEnd));
                // Next, shift by the full set of signatures to hit the respective pubkey
                // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]
                var pubStart = n * compressedPubLength + PUBKEYS_OFFSET;
                var pubEnd = (n + 1) * compressedPubLength + PUBKEYS_OFFSET;
                pubkeys.push(res.slice(pubStart, pubEnd));
                // Update offset to hit the next signature slot
                off += DERLength;
                n += 1;
            }
            // Build the transaction data to be serialized
            var preSerializedData = {
                inputs: [],
                outputs: [],
            };
            // First output comes from request dta
            preSerializedData.outputs.push({
                value: req.origData.value,
                recipient: req.origData.recipient,
            });
            if (req.changeData.value > 0) {
                // Second output comes from change data
                preSerializedData.outputs.push({
                    value: req.changeData.value,
                    recipient: changeRecipient,
                });
            }
            // Add the inputs
            for (var i = 0; i < sigs.length; i++) {
                preSerializedData.inputs.push({
                    hash: req.origData.prevOuts[i].txHash,
                    index: req.origData.prevOuts[i].index,
                    sig: sigs[i],
                    pubkey: pubkeys[i],
                    signerPath: req.origData.prevOuts[i].signerPath,
                });
            }
            // Finally, serialize the transaction
            var serializedTx = bitcoin_1.default.serializeTx(preSerializedData);
            // Generate the transaction hash so the user can look this transaction up later
            var preImageTxHash = serializedTx;
            var txHashPre = buffer_1.Buffer.from((0, sha_1.sha256)().update(buffer_1.Buffer.from(preImageTxHash, 'hex')).digest('hex'), 'hex');
            // Add extra data for debugging/lookup purposes
            return {
                tx: serializedTx,
                txHash: (0, sha_1.sha256)().update(txHashPre).digest('hex'),
                changeRecipient: changeRecipient,
                sigs: sigs,
            };
        }
        else if (currencyType === 'ETH') {
            var sig = (0, util_1.parseDER)(res.slice(off, off + 2 + res[off + 1]));
            off += DERLength;
            var ethAddr = res.slice(off, off + 20);
            // Determine the `v` param and add it to the sig before returning
            var _a = ethereum_1.default.buildEthRawTx(req, sig, ethAddr), rawTx = _a.rawTx, sigWithV = _a.sigWithV;
            return {
                tx: "0x".concat(rawTx),
                txHash: "0x".concat(ethereum_1.default.hashTransaction(rawTx)),
                sig: {
                    v: sigWithV.v,
                    r: sigWithV.r.toString('hex'),
                    s: sigWithV.s.toString('hex'),
                },
                signer: ethAddr,
            };
        }
        else if (currencyType === 'ETH_MSG') {
            var sig = (0, util_1.parseDER)(res.slice(off, off + 2 + res[off + 1]));
            off += DERLength;
            var signer = res.slice(off, off + 20);
            var validatedSig = ethereum_1.default.validateEthereumMsgResponse({ signer: signer, sig: sig }, req);
            return {
                sig: {
                    v: validatedSig.v,
                    r: validatedSig.r.toString('hex'),
                    s: validatedSig.s.toString('hex'),
                },
                signer: signer,
            };
        }
        else {
            // Generic signing request
            return (0, genericSigning_1.parseGenericSigningResponse)(res, off, req.curveType, req.omitPubkey);
        }
    };
    /**
     * Reset the active wallets to empty values.
     * @category Device Response
     * @internal
     */
    Client.prototype._resetActiveWallets = function () {
        this.activeWallets.internal.uid = EMPTY_WALLET_UID;
        this.activeWallets.internal.name = null;
        this.activeWallets.internal.capabilities = null;
        this.activeWallets.external.uid = EMPTY_WALLET_UID;
        this.activeWallets.external.name = null;
        this.activeWallets.external.capabilities = null;
        return;
    };
    /**
     * Update the payload with the current wallet UID.
     * Some (not all) requests require the active wallet UID
     * in order for Lattice firmware to accept them. If we get
     * a "wrong wallet" error, the SDK will automatically request
     * the current wallet UID from the device and may retry the
     * request, but the original request payload must be modified.
     */
    Client.prototype._replaceWalletUID = function (encReqCode, payload) {
        var wallet = this.getActiveWallet();
        if (!wallet) {
            return null;
        }
        // See if we can modify the payload and retry
        if (encReqCode === 'GET_ADDRESSES') {
            wallet.uid.copy(payload, 0);
            return payload;
        }
        else if (encReqCode === 'SIGN_TRANSACTION') {
            wallet.uid.copy(payload, 2);
            return payload;
        }
        // Not allowed to retry
        return null;
    };
    /**
     * Return JSON-stringified version of state data. Can be used to
     * rehydrate an SDK session without reconnecting to the target Lattice.
     */
    Client.prototype._packStateData = function () {
        try {
            var data = {
                activeWallets: {
                    internal: {
                        uid: this.activeWallets.internal.uid.toString('hex'),
                        name: this.activeWallets.internal.name.toString(),
                        capabilities: this.activeWallets.internal.capabilities,
                    },
                    external: {
                        uid: this.activeWallets.external.uid.toString('hex'),
                        name: this.activeWallets.external.name.toString(),
                        capabilities: this.activeWallets.external.capabilities,
                    }
                },
                ephemeralPub: this.ephemeralPub.getPublic().encode('hex'),
                fwVersion: this.fwVersion.toString('hex'),
                deviceId: this.deviceId,
                name: this.name,
                baseUrl: this.baseUrl,
                privKey: this.privKey.toString('hex'),
                retryCount: this.retryCount,
                timeout: this.timeout,
            };
            return JSON.stringify(data);
        }
        catch (err) {
            console.warn('Could not pack state data.');
            return null;
        }
    };
    /**
     * Unpack a JSON-stringified version of state data and apply it to state.
     * This will allow us to rehydrate an old session.
     */
    Client.prototype._unpackAndApplyStateData = function (data) {
        try {
            var unpacked = JSON.parse(data);
            // Attempty to parse the data
            var internalWallet = {
                uid: buffer_1.Buffer.from(unpacked.activeWallets.internal.uid, 'hex'),
                name: buffer_1.Buffer.from(unpacked.activeWallets.internal.name),
                capabilities: unpacked.activeWallets.internal.capabilities,
                external: false,
            };
            var externalWallet = {
                uid: buffer_1.Buffer.from(unpacked.activeWallets.external.uid, 'hex'),
                name: buffer_1.Buffer.from(unpacked.activeWallets.external.name),
                capabilities: unpacked.activeWallets.external.capabilities,
                external: true,
            };
            var ephemeralPubBytes = buffer_1.Buffer.from(unpacked.ephemeralPub, 'hex');
            var fwVersionBytes = buffer_1.Buffer.from(unpacked.fwVersion, 'hex');
            var privKeyBytes = buffer_1.Buffer.from(unpacked.privKey, 'hex');
            // Apply unpacked params
            this.activeWallets.internal = internalWallet;
            this.activeWallets.external = externalWallet;
            this.ephemeralPub = (0, util_1.getP256KeyPairFromPub)(ephemeralPubBytes);
            this.fwVersion = fwVersionBytes;
            this.deviceId = unpacked.deviceId;
            this.name = unpacked.name;
            this.baseUrl = unpacked.baseUrl;
            this.privKey = privKeyBytes;
            this.key = (0, util_1.getP256KeyPair)(this.privKey);
            this.retryCount = unpacked.retryCount;
            this.timeout = unpacked.timeout;
        }
        catch (err) {
            console.warn('Could not apply state data.');
        }
    };
    /**
     * Get the active wallet.
     * @returns The active wallet.
     */
    Client.prototype.getActiveWallet = function () {
        if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {
            return this.activeWallets.external;
        }
        else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {
            return this.activeWallets.internal;
        }
        else {
            return null;
        }
    };
    /**
     * Check if the user has an active wallet"
     * @returns true is user has active wallet
     */
    Client.prototype.hasActiveWallet = function () {
        return this.getActiveWallet() !== null;
    };
    /**
     * Get 64 bytes representing the public key
     * This is the uncompressed key without the leading 04 byte
     * @param LE - Whether to return the public key in little endian format.
     * @returns A Buffer containing the public key.
     */
    Client.prototype.pubKeyBytes = function (LE) {
        if (LE === void 0) { LE = false; }
        var k = this.key.getPublic();
        var p = k.encode('hex');
        var pb = buffer_1.Buffer.from(p, 'hex');
        if (LE === true) {
            // Need to flip X and Y components to little endian
            var x = pb.slice(1, 33).reverse();
            var y = pb.slice(33, 65).reverse();
            // @ts-expect-error - TODO: Find out why Buffer won't accept pb[0]
            return buffer_1.Buffer.concat([pb[0], x, y]);
        }
        else {
            return pb;
        }
    };
    /**
     * TODO: Find a better way to export this.
     * `parseAbi` takes a source and data as arguments, and returns the parsed ABI.
     * @param source - The name of the source of the ABI data.
     * @param data - The data to parse.
     * @param skipErrors - If true, errors will be skipped and the function will return an object with
     * an error property.
     * @returns The parsed ABI.
     */
    Client.prototype.parseAbi = function (source, data, skipErrors) {
        if (skipErrors === void 0) { skipErrors = false; }
        switch (source) {
            case 'etherscan':
                return ethereumAbi_1.abiParsers[source](data, skipErrors);
            default:
                return { err: "No ".concat(source, " parser available.") };
        }
    };
    return Client;
}());
exports.Client = Client;

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\client.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js", {"./lib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\elliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\index.js", {"./account":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\account.js","./api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\api.js","./backend/blockchain":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js","./backend/transactions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\transactions.js","./events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\events.js","./misc":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\misc.js","./networks/binance":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js","./networks/bitcoin":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js","./networks/cardano":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js","./networks/coinInfo":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js","./networks/eos":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js","./networks/ethereum":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js","./networks/nem":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js","./networks/ripple":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js","./networks/stellar":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js","./networks/tezos":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js","./params":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\params.js","./trezor/device":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js","./trezor/management":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;

var _api = require("./api");

Object.keys(_api).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _api[key]) return;
  exports[key] = _api[key];
});

var _events = require("./events");

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _events[key]) return;
  exports[key] = _events[key];
});

var _misc = require("./misc");

Object.keys(_misc).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _misc[key]) return;
  exports[key] = _misc[key];
});

var _params = require("./params");

Object.keys(_params).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _params[key]) return;
  exports[key] = _params[key];
});

var _account = require("./account");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _account[key]) return;
  exports[key] = _account[key];
});

var _device = require("./trezor/device");

Object.keys(_device).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _device[key]) return;
  exports[key] = _device[key];
});

var _management = require("./trezor/management");

Object.keys(_management).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _management[key]) return;
  exports[key] = _management[key];
});

var _bitcoin = require("./networks/bitcoin");

Object.keys(_bitcoin).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bitcoin[key]) return;
  exports[key] = _bitcoin[key];
});

var _binance = require("./networks/binance");

Object.keys(_binance).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _binance[key]) return;
  exports[key] = _binance[key];
});

var _cardano = require("./networks/cardano");

Object.keys(_cardano).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cardano[key]) return;
  exports[key] = _cardano[key];
});

var _coinInfo = require("./networks/coinInfo");

Object.keys(_coinInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _coinInfo[key]) return;
  exports[key] = _coinInfo[key];
});

var _eos = require("./networks/eos");

Object.keys(_eos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eos[key]) return;
  exports[key] = _eos[key];
});

var _ethereum = require("./networks/ethereum");

Object.keys(_ethereum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ethereum[key]) return;
  exports[key] = _ethereum[key];
});

var _nem = require("./networks/nem");

Object.keys(_nem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nem[key]) return;
  exports[key] = _nem[key];
});

var _ripple = require("./networks/ripple");

Object.keys(_ripple).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ripple[key]) return;
  exports[key] = _ripple[key];
});

var _stellar = require("./networks/stellar");

Object.keys(_stellar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stellar[key]) return;
  exports[key] = _stellar[key];
});

var _tezos = require("./networks/tezos");

Object.keys(_tezos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _tezos[key]) return;
  exports[key] = _tezos[key];
});

var _blockchain = require("./backend/blockchain");

Object.keys(_blockchain).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _blockchain[key]) return;
  exports[key] = _blockchain[key];
});

var _transactions = require("./backend/transactions");

Object.keys(_transactions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactions[key]) return;
  exports[key] = _transactions[key];
});
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js", {"./blockchain":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\blockchain.js","./cardano":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\cardano.js","./device":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\device.js","./errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\errors.js","./iframe":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\iframe.js","./network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\network.js","./popup":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\popup.js","./transport":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\transport.js","./ui":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\ui.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CARDANO = exports.UI = exports.TRANSPORT = exports.POPUP = exports.NETWORK = exports.IFRAME = exports.ERRORS = exports.DEVICE = exports.BLOCKCHAIN = exports.BLOCKCHAIN_EVENT = exports.RESPONSE_EVENT = exports.TRANSPORT_EVENT = exports.DEVICE_EVENT = exports.UI_EVENT = exports.CORE_EVENT = void 0;

var BLOCKCHAIN = _interopRequireWildcard(require("./blockchain"));

exports.BLOCKCHAIN = BLOCKCHAIN;

var DEVICE = _interopRequireWildcard(require("./device"));

exports.DEVICE = DEVICE;

var ERRORS = _interopRequireWildcard(require("./errors"));

exports.ERRORS = ERRORS;

var IFRAME = _interopRequireWildcard(require("./iframe"));

exports.IFRAME = IFRAME;

var NETWORK = _interopRequireWildcard(require("./network"));

exports.NETWORK = NETWORK;

var POPUP = _interopRequireWildcard(require("./popup"));

exports.POPUP = POPUP;

var TRANSPORT = _interopRequireWildcard(require("./transport"));

exports.TRANSPORT = TRANSPORT;

var UI = _interopRequireWildcard(require("./ui"));

exports.UI = UI;

var CARDANO = _interopRequireWildcard(require("./cardano"));

exports.CARDANO = CARDANO;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var CORE_EVENT = 'CORE_EVENT';
exports.CORE_EVENT = CORE_EVENT;
var UI_EVENT = 'UI_EVENT';
exports.UI_EVENT = UI_EVENT;
var DEVICE_EVENT = 'DEVICE_EVENT';
exports.DEVICE_EVENT = DEVICE_EVENT;
var TRANSPORT_EVENT = 'TRANSPORT_EVENT';
exports.TRANSPORT_EVENT = TRANSPORT_EVENT;
var RESPONSE_EVENT = 'RESPONSE_EVENT';
exports.RESPONSE_EVENT = RESPONSE_EVENT;
var BLOCKCHAIN_EVENT = 'BLOCKCHAIN_EVENT';
exports.BLOCKCHAIN_EVENT = BLOCKCHAIN_EVENT;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\index.js", {"../../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js","../../data/ConnectSettings":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\data\\ConnectSettings.js","../../iframe/builder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\builder.js","../../message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\index.js","../../message/builder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\builder.js","../../popup/PopupManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\PopupManager.js","../../types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\index.js","../../utils/debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\debug.js","../../webusb/button":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\webusb\\button.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\env\browser\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.disableWebUSB = exports.requestLogin = exports.customMessage = exports.getSettings = exports.renderWebUSBButton = exports.uiResponse = exports.call = exports.init = exports.cancel = exports.dispose = exports.manifest = exports.eventEmitter = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _events = _interopRequireDefault(require("events"));

var _PopupManager = _interopRequireDefault(require("../../popup/PopupManager"));

var iframe = _interopRequireWildcard(require("../../iframe/builder"));

var _button = _interopRequireDefault(require("../../webusb/button"));

var _message = require("../../message");

var _builder2 = require("../../message/builder");

var _ConnectSettings = require("../../data/ConnectSettings");

var _debug = require("../../utils/debug");

var _constants = require("../../constants");

var $T = _interopRequireWildcard(require("../../types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var eventEmitter = new _events["default"]();
exports.eventEmitter = eventEmitter;

var _log = (0, _debug.initLog)('[trezor-connect.js]');

var _settings;

var _popupManager;

var initPopupManager = function initPopupManager() {
  var pm = new _PopupManager["default"](_settings);
  pm.on(_constants.POPUP.CLOSED, function (error) {
    iframe.postMessage({
      type: _constants.POPUP.CLOSED,
      payload: error ? {
        error: error
      } : null
    }, false);
  });
  return pm;
};

var manifest = function manifest(data) {
  _settings = (0, _ConnectSettings.parse)({
    manifest: data
  });
};

exports.manifest = manifest;

var dispose = function dispose() {
  eventEmitter.removeAllListeners();
  iframe.dispose();

  if (_popupManager) {
    _popupManager.close();
  }
};

exports.dispose = dispose;

var cancel = function cancel(error) {
  if (_popupManager) {
    _popupManager.emit(_constants.POPUP.CLOSED, error);
  }
}; // handle message received from iframe


exports.cancel = cancel;

var handleMessage = function handleMessage(messageEvent) {
  // ignore messages from domain other then iframe origin
  if (messageEvent.origin !== iframe.origin) return;
  var message = (0, _message.parseMessage)(messageEvent.data);
  var event = message.event,
      type = message.type,
      payload = message.payload;
  var id = message.id || 0;

  _log.log('handleMessage', message);

  switch (event) {
    case _constants.RESPONSE_EVENT:
      if (iframe.messagePromises[id]) {
        // resolve message promise (send result of call method)
        iframe.messagePromises[id].resolve({
          id: id,
          success: message.success,
          payload: payload
        });
        delete iframe.messagePromises[id];
      } else {
        _log.warn("Unknown message id " + id);
      }

      break;

    case _constants.DEVICE_EVENT:
      // pass DEVICE event up to html
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload); // DEVICE_EVENT also emit single events (connect/disconnect...)

      break;

    case _constants.TRANSPORT_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.BLOCKCHAIN_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.UI_EVENT:
      if (type === _constants.IFRAME.BOOTSTRAP) {
        iframe.clearTimeout();
        break;
      }

      if (type === _constants.IFRAME.LOADED) {
        iframe.initPromise.resolve();
      }

      if (type === _constants.IFRAME.ERROR) {
        iframe.initPromise.reject(payload.error);
      } // pass UI event up


      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    default:
      _log.log('Undefined message', event, messageEvent);

  }
};

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (settings === void 0) {
              settings = {};
            }

            if (!iframe.instance) {
              _context.next = 3;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_AlreadyInitialized');

          case 3:
            if (!_settings) {
              _settings = (0, _ConnectSettings.parse)(settings);
            }

            if (_settings.manifest) {
              _context.next = 6;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_ManifestMissing');

          case 6:
            if (!_settings.lazyLoad) {
              _context.next = 9;
              break;
            }

            // reset "lazyLoad" after first use
            _settings.lazyLoad = false;
            return _context.abrupt("return");

          case 9:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _log.enabled = !!_settings.debug;
            window.addEventListener('message', handleMessage);
            window.addEventListener('unload', dispose);
            _context.next = 15;
            return iframe.init(_settings);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var call = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
    var response;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!iframe.instance && !iframe.timeout)) {
              _context2.next = 15;
              break;
            }

            // init popup with lazy loading before iframe initialization
            _settings = (0, _ConnectSettings.parse)(_settings);

            if (_settings.manifest) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 4:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _popupManager.request(true); // auto init with default settings


            _context2.prev = 6;
            _context2.next = 9;
            return init(_settings);

          case 9:
            _context2.next = 15;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](6);

            if (_popupManager) {
              // Catch fatal iframe errors (not loading)
              if (['Init_IframeBlocked', 'Init_IframeTimeout'].includes(_context2.t0.code)) {
                _popupManager.postMessage((0, _builder2.UiMessage)(_constants.UI.IFRAME_FAILURE));
              } else {
                _popupManager.close();
              }
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t0));

          case 15:
            if (!iframe.timeout) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 17:
            if (!iframe.error) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(iframe.error));

          case 19:
            // request popup window it might be used in the future
            if (_settings.popup && _popupManager) {
              _popupManager.request();
            } // post message to iframe


            _context2.prev = 20;
            _context2.next = 23;
            return iframe.postMessage({
              type: _constants.IFRAME.CALL,
              payload: params
            });

          case 23:
            response = _context2.sent;

            if (!response) {
              _context2.next = 27;
              break;
            }

            if (!response.success && response.payload.code !== 'Device_CallInProgress' && _popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", response);

          case 27:
            if (_popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_NoResponse')));

          case 31:
            _context2.prev = 31;
            _context2.t1 = _context2["catch"](20);

            _log.error('__call error', _context2.t1);

            if (_popupManager) {
              _popupManager.close();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t1));

          case 36:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[6, 11], [20, 31]]);
  }));

  return function call(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports.call = call;

var customMessageResponse = function customMessageResponse(payload) {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.UI.CUSTOM_MESSAGE_RESPONSE,
    payload: payload
  });
};

var uiResponse = function uiResponse(response) {
  var type = response.type,
      payload = response.payload;
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  });
};

exports.uiResponse = uiResponse;

var renderWebUSBButton = function renderWebUSBButton(className) {
  (0, _button["default"])(className, _settings.webusbSrc, iframe.origin);
};

exports.renderWebUSBButton = renderWebUSBButton;

var getSettings = function getSettings() {
  if (!iframe.instance) {
    return Promise.resolve((0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_NotInitialized')));
  }

  return call({
    method: 'getSettings'
  });
};

exports.getSettings = getSettings;

var customMessage = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(params) {
    var callback, customMessageListener, response;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(typeof params.callback !== 'function')) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_CustomMessage_Callback')));

          case 2:
            // TODO: set message listener only if iframe is loaded correctly
            callback = params.callback;

            customMessageListener = /*#__PURE__*/function () {
              var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.CUSTOM_MESSAGE_REQUEST)) {
                          _context3.next = 6;
                          break;
                        }

                        _context3.next = 4;
                        return callback(data.payload);

                      case 4:
                        payload = _context3.sent;

                        if (payload) {
                          customMessageResponse(payload);
                        } else {
                          customMessageResponse({
                            message: 'release'
                          });
                        }

                      case 6:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function customMessageListener(_x4) {
                return _ref4.apply(this, arguments);
              };
            }();

            window.addEventListener('message', customMessageListener, false);
            _context4.next = 7;
            return call(_objectSpread(_objectSpread({
              method: 'customMessage'
            }, params), {}, {
              callback: null
            }));

          case 7:
            response = _context4.sent;
            window.removeEventListener('message', customMessageListener);
            return _context4.abrupt("return", response);

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function customMessage(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

exports.customMessage = customMessage;

var requestLogin = /*#__PURE__*/function () {
  var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(params) {
    var callback, loginChallengeListener, response;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(typeof params.callback === 'function')) {
              _context6.next = 9;
              break;
            }

            callback = params.callback; // TODO: set message listener only if iframe is loaded correctly

            loginChallengeListener = /*#__PURE__*/function () {
              var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.LOGIN_CHALLENGE_REQUEST)) {
                          _context5.next = 12;
                          break;
                        }

                        _context5.prev = 2;
                        _context5.next = 5;
                        return callback();

                      case 5:
                        payload = _context5.sent;
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: payload
                        });
                        _context5.next = 12;
                        break;

                      case 9:
                        _context5.prev = 9;
                        _context5.t0 = _context5["catch"](2);
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: _context5.t0.message
                        });

                      case 12:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, null, [[2, 9]]);
              }));

              return function loginChallengeListener(_x6) {
                return _ref6.apply(this, arguments);
              };
            }();

            window.addEventListener('message', loginChallengeListener, false);
            _context6.next = 6;
            return call(_objectSpread(_objectSpread({
              method: 'requestLogin'
            }, params), {}, {
              asyncChallenge: true,
              callback: null
            }));

          case 6:
            response = _context6.sent;
            window.removeEventListener('message', loginChallengeListener);
            return _context6.abrupt("return", response);

          case 9:
            return _context6.abrupt("return", call(_objectSpread({
              method: 'requestLogin'
            }, params)));

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function requestLogin(_x5) {
    return _ref5.apply(this, arguments);
  };
}();

exports.requestLogin = requestLogin;

var disableWebUSB = function disableWebUSB() {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.TRANSPORT.DISABLE_WEBUSB
  });
};

exports.disableWebUSB = disableWebUSB;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js", {"./encryption":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js","./personal-sign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js","./sign-typed-data":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.concatSig = void 0;
__exportStar(require("./personal-sign"), exports);
__exportStar(require("./sign-typed-data"), exports);
__exportStar(require("./encryption"), exports);
var utils_1 = require("./utils");
Object.defineProperty(exports, "concatSig", { enumerable: true, get: function () { return utils_1.concatSig; } });
Object.defineProperty(exports, "normalize", { enumerable: true, get: function () { return utils_1.normalize; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\ExternalResourceController.js", {"@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\resource\ExternalResourceController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalResourceController = void 0;
const obs_store_1 = require("@metamask/obs-store");
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const alwaysRequiredFields = ['fromDomain'];
const computeState = (storageKey, initialResources) => {
    return { [storageKey]: initialResources };
};
const getUnauthorizedMessage = (id) => `Not authorized to access resource with id "${id}".`;
/**
 * A class intended to describe a particular resource that is managed by snaps.
 * Example resources are assets.
 *
 * These are things that MetaMask treats as first-class objects with distinct properties within its own UI.
 */
class ExternalResourceController extends safe_event_emitter_1.default {
    constructor({ storageKey, requiredFields, initialResources, }) {
        super();
        this.requiredFields = requiredFields;
        this.storageKey = storageKey;
        this.store = new obs_store_1.ObservableStore(computeState(storageKey, initialResources));
    }
    getResources() {
        return Object.assign({}, this.store.getState()[this.storageKey]);
    }
    setResources(resources) {
        this.store.updateState({
            [this.storageKey]: resources,
        });
    }
    clearResources() {
        this.setResources({});
    }
    deleteResourcesFor(fromDomain) {
        const resources = this.getResources();
        const newResources = Object.entries(resources).reduce((acc, [id, resource]) => {
            if (resource.fromDomain !== fromDomain) {
                acc[id] = resource;
            }
            return acc;
        }, {});
        this.setResources(newResources);
    }
    get(fromDomain, id) {
        const resource = this.getResources()[id];
        if (resource && resource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        return resource ? Object.assign({}, resource) : null;
    }
    getAllResources(fromDomain) {
        return Object.values(this.getResources()).filter((resource) => {
            return resource.fromDomain === fromDomain;
        });
    }
    add(fromDomain, resource) {
        const newResource = this.processNewResource(fromDomain, resource);
        const { id } = newResource;
        const resources = this.getResources();
        if (resources[id]) {
            throw new Error(`Resource with id "${id}" already exists.`);
        }
        else {
            resources[id] = newResource;
            this.setResources(resources);
        }
        return newResource.id;
    }
    update(fromDomain, resource) {
        const { id } = resource;
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceNotFound({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        resources[id] = this.processNewResource(fromDomain, Object.assign(Object.assign({}, resources[id]), resource));
        this.setResources(resources);
        return id;
    }
    processNewResource(fromDomain, resource) {
        this.requiredFields.forEach((requiredField) => {
            if (!(requiredField in resource)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Resource from "${fromDomain}" missing required field: ${requiredField}`);
            }
        });
        return Object.assign(Object.assign({}, resource), { fromDomain, id: resource.id || nanoid_1.nanoid() });
    }
    delete(fromDomain, id) {
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        delete resources[id];
        this.setResources(resources);
        return null;
    }
    handleRpcRequest(fromDomain, method, arg) {
        if (!fromDomain || typeof fromDomain !== 'string') {
            throw new Error('Invalid fromDomain.');
        }
        switch (method) {
            case 'get':
                return this.get(fromDomain, arg);
            case 'getAll':
                return this.getAllResources(fromDomain);
            case 'add':
                return this.add(fromDomain, arg);
            case 'update':
                return this.update(fromDomain, arg);
            case 'delete':
                return this.delete(fromDomain, arg);
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                    message: `Not an asset method: ${method}`,
                });
        }
    }
}
exports.ExternalResourceController = ExternalResourceController;
//# sourceMappingURL=ExternalResourceController.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\resource\\ExternalResourceController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\SubjectMetadataController.js", {"@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\subject-metadata\SubjectMetadataController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectMetadataController = void 0;
const controllers_1 = require("@metamask/controllers");
const controllerName = 'SubjectMetadataController';
const stateMetadata = {
    subjectMetadata: { persist: true, anonymous: false },
};
const defaultState = {
    subjectMetadata: {},
};
/**
 * A controller for storing metadata associated with permission subjects. More
 * or less, a cache.
 */
class SubjectMetadataController extends controllers_1.BaseControllerV2 {
    constructor({ messenger, subjectCacheLimit, state = {}, }) {
        if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {
            throw new Error(`subjectCacheLimit must be a positive integer. Received: "${subjectCacheLimit}"`);
        }
        const hasPermissions = (origin) => {
            return messenger.call('PermissionController:hasPermissions', origin);
        };
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign({}, SubjectMetadataController.getTrimmedState(state, hasPermissions)),
        });
        this.subjectHasPermissions = hasPermissions;
        this.subjectCacheLimit = subjectCacheLimit;
        this.subjectsWithoutPermissionsEcounteredSinceStartup = new Set();
    }
    /**
     * Clears the state of this controller. Also resets the cache of subjects
     * encountered since startup, so as to not prematurely reach the cache limit.
     */
    clearState() {
        this.subjectsWithoutPermissionsEcounteredSinceStartup.clear();
        this.update((_draftState) => {
            return Object.assign({}, defaultState);
        });
    }
    /**
     * Stores domain metadata for the given origin (subject). Deletes metadata for
     * subjects without permissions in a FIFO manner once more than
     * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have
     * been added since boot.
     *
     * In order to prevent a degraded user experience,
     * metadata is never deleted for subjects with permissions, since metadata
     * cannot yet be requested on demand.
     *
     * @param metadata - The subject metadata to store.
     */
    addSubjectMetadata(metadata) {
        const { origin } = metadata;
        const newMetadata = Object.assign(Object.assign({}, metadata), { extensionId: metadata.extensionId || null, iconUrl: metadata.iconUrl || null, name: metadata.name || null });
        let originToForget = null;
        // We only delete the oldest encountered subject from the cache, again to
        // ensure that the user's experience isn't degraded by missing icons etc.
        if (this.subjectsWithoutPermissionsEcounteredSinceStartup.size >=
            this.subjectCacheLimit) {
            const cachedOrigin = this.subjectsWithoutPermissionsEcounteredSinceStartup
                .values()
                .next().value;
            this.subjectsWithoutPermissionsEcounteredSinceStartup.delete(cachedOrigin);
            if (!this.subjectHasPermissions(cachedOrigin)) {
                originToForget = cachedOrigin;
            }
        }
        this.subjectsWithoutPermissionsEcounteredSinceStartup.add(origin);
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.subjectMetadata[origin] = newMetadata;
            if (typeof originToForget === 'string') {
                delete draftState.subjectMetadata[originToForget];
            }
        });
    }
    /**
     * Deletes all subjects without permissions from the controller's state.
     */
    trimMetadataState() {
        this.update((draftState) => {
            return SubjectMetadataController.getTrimmedState(
            // Typecast: ts(2589)
            draftState, this.subjectHasPermissions);
        });
    }
    /**
     * Returns a new state object that only includes subjects with permissions.
     * This method is static because we want to call it in the constructor, before
     * the controller's state is initialized.
     *
     * @param state - The state object to trim.
     * @param hasPermissions - A function that returns a boolean indicating
     * whether a particular subject (identified by its origin) has any
     * permissions.
     * @returns The new state object. If the specified `state` object has no
     * subject metadata, the returned object will be equivalent to the default
     * state of this controller.
     */
    static getTrimmedState(state, hasPermissions) {
        const { subjectMetadata = {} } = state;
        return {
            subjectMetadata: Object.keys(subjectMetadata).reduce((newSubjectMetadata, origin) => {
                if (hasPermissions(origin)) {
                    newSubjectMetadata[origin] = subjectMetadata[origin];
                }
                return newSubjectMetadata;
            }, {}),
        };
    }
}
exports.SubjectMetadataController = SubjectMetadataController;
//# sourceMappingURL=SubjectMetadataController.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\subject-metadata\\SubjectMetadataController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodNames = void 0;
var MethodNames;
(function (MethodNames) {
    MethodNames["requestPermissions"] = "wallet_requestPermissions";
    MethodNames["getPermissions"] = "wallet_getPermissions";
})(MethodNames = exports.MethodNames || (exports.MethodNames = {}));
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Permission.js", {"nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\Permission.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasSpecificationType = exports.PermissionType = exports.findCaveat = exports.constructPermission = void 0;
const nanoid_1 = require("nanoid");
/**
 * The default permission factory function. Naively constructs a permission from
 * the inputs. Sets a default, random `id` if none is provided.
 *
 * @see {@link Permission} For more details.
 *
 * @template TargetPermission - The {@link Permission} that will be constructed.
 * @param options - The options for the permission.
 * @returns The new permission object.
 */
function constructPermission(options) {
    const { caveats = null, invoker, target } = options;
    return {
        id: nanoid_1.nanoid(),
        parentCapability: target,
        invoker,
        caveats,
        date: new Date().getTime(),
    };
}
exports.constructPermission = constructPermission;
/**
 * Gets the caveat of the specified type belonging to the specified permission.
 *
 * @param permission The permission whose caveat to retrieve.
 * @param caveatType The type of the caveat to retrieve.
 * @returns The caveat, or undefined if no such caveat exists.
 */
function findCaveat(permission, caveatType) {
    var _a;
    return (_a = permission.caveats) === null || _a === void 0 ? void 0 : _a.find((caveat) => caveat.type === caveatType);
}
exports.findCaveat = findCaveat;
/**
 * The different possible types of permissions.
 */
var PermissionType;
(function (PermissionType) {
    /**
     * A restricted JSON-RPC method. A subject must have the requisite permission
     * to call a restricted JSON-RPC method.
     */
    PermissionType["RestrictedMethod"] = "RestrictedMethod";
    /**
     * An "endowment" granted to subjects that possess the requisite permission,
     * such as a global environment variable exposing a restricted API, etc.
     */
    PermissionType["Endowment"] = "Endowment";
})(PermissionType = exports.PermissionType || (exports.PermissionType = {}));
/**
 * Checks that the specification has the expected permission type.
 *
 * @param specification - The specification to check.
 * @param expectedType - The expected permission type.
 * @template Specification - The specification to check.
 * @template Type - The expected permission type.
 * @returns Whether or not the specification is of the expected type.
 */
function hasSpecificationType(specification, expectedType) {
    return specification.permissionType === expectedType;
}
exports.hasSpecificationType = hasSpecificationType;
//# sourceMappingURL=Permission.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Permission.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\index.js", {"./network-access":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\network-access.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\endowments\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endowmentPermissionBuilders = void 0;
const network_access_1 = require("./network-access");
exports.endowmentPermissionBuilders = {
    [network_access_1.networkAccessEndowmentBuilder.targetKey]: network_access_1.networkAccessEndowmentBuilder,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\PermissionController.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js","./Caveat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Caveat.js","./Permission":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Permission.js","./errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js","./permission-middleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\permission-middleware.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js","@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","deep-freeze-strict":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-freeze-strict\\index.js","immer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\immer\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\PermissionController.js
      return function (require, module, exports) {
"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionController = exports.CaveatMutatorOperation = void 0;
const controllers_1 = require("@metamask/controllers");
/* eslint-enable @typescript-eslint/no-unused-vars */
const deep_freeze_strict_1 = __importDefault(require("deep-freeze-strict"));
const immer_1 = require("immer");
const nanoid_1 = require("nanoid");
const utils_1 = require("../utils");
const Caveat_1 = require("./Caveat");
const errors_1 = require("./errors");
const Permission_1 = require("./Permission");
const permission_middleware_1 = require("./permission-middleware");
const utils_2 = require("./utils");
/**
 * The name of the {@link PermissionController}.
 */
const controllerName = 'PermissionController';
/**
 * Get the state metadata of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getStateMetadata() {
    return { subjects: { anonymous: true, persist: true } };
}
/**
 * Get the default state of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getDefaultState() {
    return { subjects: {} };
}
/**
 * Describes the possible results of a {@link CaveatMutator} function.
 */
var CaveatMutatorOperation;
(function (CaveatMutatorOperation) {
    CaveatMutatorOperation[CaveatMutatorOperation["noop"] = 0] = "noop";
    CaveatMutatorOperation[CaveatMutatorOperation["updateValue"] = 1] = "updateValue";
    CaveatMutatorOperation[CaveatMutatorOperation["deleteCaveat"] = 2] = "deleteCaveat";
    CaveatMutatorOperation[CaveatMutatorOperation["revokePermission"] = 3] = "revokePermission";
})(CaveatMutatorOperation = exports.CaveatMutatorOperation || (exports.CaveatMutatorOperation = {}));
/**
 * The permission controller. See the README for details.
 *
 * Assumes the existence of an {@link ApprovalController} reachable via the
 * {@link ControllerMessenger}.
 *
 * @template ControllerPermissionSpecification - A union of the types of all
 * permission specifications available to the controller. Any referenced caveats
 * must be included in the controller's caveat specifications.
 * @template ControllerCaveatSpecification - A union of the types of all
 * caveat specifications available to the controller.
 */
class PermissionController extends controllers_1.BaseControllerV2 {
    /**
     * @param options - Permission controller options.
     * @param options.caveatSpecifications - The specifications of all caveats
     * available to the controller. See {@link CaveatSpecificationMap} and the
     * documentation for more details.
     * @param options.permissionSpecifications - The specifications of all
     * permissions available to the controller. See
     * {@link PermissionSpecificationMap} and the README for more details.
     * @param options.unrestrictedMethods - The callable names of all JSON-RPC
     * methods ignored by the new controller.
     * @param options.messenger - The controller messenger. See
     * {@link BaseController} for more information.
     * @param options.state - Existing state to hydrate the controller with at
     * initialization.
     */
    constructor(options) {
        const { caveatSpecifications, permissionSpecifications, unrestrictedMethods, messenger, state = {}, } = options;
        super({
            name: controllerName,
            metadata: getStateMetadata(),
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._unrestrictedMethods = new Set(unrestrictedMethods);
        this._caveatSpecifications = deep_freeze_strict_1.default(Object.assign({}, caveatSpecifications));
        this.validatePermissionSpecifications(permissionSpecifications, this._caveatSpecifications);
        this._permissionSpecifications = deep_freeze_strict_1.default(Object.assign({}, permissionSpecifications));
        this.registerMessageHandlers();
        this.createPermissionMiddleware = permission_middleware_1.getPermissionMiddlewareFactory({
            executeRestrictedMethod: this._executeRestrictedMethod.bind(this),
            getRestrictedMethod: this.getRestrictedMethod.bind(this),
            isUnrestrictedMethod: this.unrestrictedMethods.has.bind(this.unrestrictedMethods),
        });
    }
    /**
     * The names of all JSON-RPC methods that will be ignored by the controller.
     */
    get unrestrictedMethods() {
        return this._unrestrictedMethods;
    }
    /**
     * Gets a permission specification.
     *
     * @param targetKey - The target key of the permission specification to get.
     * @returns The permission specification with the specified target key.
     */
    getPermissionSpecification(targetKey) {
        return this._permissionSpecifications[targetKey];
    }
    /**
     * Gets a caveat specification.
     *
     * @param caveatType - The type of the caveat specification to get.
     * @returns The caveat specification with the specified type.
     */
    getCaveatSpecification(caveatType) {
        return this._caveatSpecifications[caveatType];
    }
    /**
     * Constructor helper for validating permission specifications. This is
     * intended to prevent the use of invalid target keys which, while impossible
     * to add in TypeScript, could rather easily occur in plain JavaScript.
     *
     * Throws an error if validation fails.
     *
     * @param permissionSpecifications - The permission specifications passed to
     * this controller's constructor.
     * @param caveatSpecifications - The caveat specifications passed to this
     * controller.
     */
    validatePermissionSpecifications(permissionSpecifications, caveatSpecifications) {
        Object.entries(permissionSpecifications).forEach(([targetKey, { permissionType, targetKey: innerTargetKey, allowedCaveats },]) => {
            if (!permissionType || !utils_1.hasProperty(Permission_1.PermissionType, permissionType)) {
                throw new Error(`Invalid permission type: "${permissionType}"`);
            }
            // Check if the target key is the empty string, ends with "_", or ends
            // with "*" but not "_*"
            if (!targetKey || /_$/u.test(targetKey) || /[^_]\*$/u.test(targetKey)) {
                throw new Error(`Invalid permission target key: "${targetKey}"`);
            }
            if (targetKey !== innerTargetKey) {
                throw new Error(`Invalid permission specification: key "${targetKey}" must match specification.target value "${innerTargetKey}".`);
            }
            if (allowedCaveats) {
                allowedCaveats.forEach((caveatType) => {
                    if (!utils_1.hasProperty(caveatSpecifications, caveatType)) {
                        throw new errors_1.UnrecognizedCaveatTypeError(caveatType);
                    }
                });
            }
        });
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearPermissions`, () => this.clearState());
        this.messagingSystem.registerActionHandler(`${controllerName}:getEndowments`, (origin, targetName, requestData) => this.getEndowments(origin, targetName, requestData));
        this.messagingSystem.registerActionHandler(`${controllerName}:getSubjectNames`, () => this.getSubjectNames());
        this.messagingSystem.registerActionHandler(`${controllerName}:getPermissions`, (origin) => this.getPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermission`, (origin, targetName) => this.hasPermission(origin, targetName));
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermissions`, (origin) => this.hasPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:revokeAllPermissions`, (origin) => this.revokeAllPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:requestPermissions`, (subject, permissions) => this.requestPermissions(subject, permissions));
    }
    /**
     * Clears the state of the controller.
     */
    clearState() {
        this.update((_draftState) => {
            return Object.assign({}, getDefaultState());
        });
    }
    /**
     * Gets the permission specification corresponding to the given permission
     * type and target name. Throws an error if the target name does not
     * correspond to a permission, or if the specification is not of the
     * given permission type.
     *
     * @template Type - The type of the permission specification to get.
     * @param permissionType - The type of the permission specification to get.
     * @param targetName - The name of the permission whose specification to get.
     * @param requestingOrigin - The origin of the requesting subject, if any.
     * Will be added to any thrown errors.
     * @returns The specification object corresponding to the given type and
     * target name.
     */
    getTypedPermissionSpecification(permissionType, targetName, requestingOrigin) {
        const failureError = permissionType === Permission_1.PermissionType.RestrictedMethod
            ? errors_1.methodNotFound(targetName, requestingOrigin ? { origin: requestingOrigin } : undefined)
            : new errors_1.EndowmentPermissionDoesNotExistError(targetName, requestingOrigin);
        const targetKey = this.getTargetKey(targetName);
        if (!targetKey) {
            throw failureError;
        }
        const specification = this.getPermissionSpecification(targetKey);
        if (!Permission_1.hasSpecificationType(specification, permissionType)) {
            throw failureError;
        }
        return specification;
    }
    /**
     * Gets the implementation of the specified restricted method.
     *
     * A JSON-RPC error is thrown if the method does not exist.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for internal usage.
     * @param method - The name of the restricted method.
     * @param origin - The origin associated with the request for the restricted
     * method, if any.
     * @returns The restricted method implementation.
     */
    getRestrictedMethod(method, origin) {
        return this.getTypedPermissionSpecification(Permission_1.PermissionType.RestrictedMethod, method, origin).methodImplementation;
    }
    /**
     * @returns The origins (i.e. IDs) of all subjects.
     */
    getSubjectNames() {
        return Object.keys(this.state.subjects);
    }
    /**
     * Gets the permission for the specified target of the subject corresponding
     * to the specified origin.
     *
     * @param origin - The origin of the subject.
     * @param targetName - The method name as invoked by a third party (i.e., not
     * a method key).
     * @returns The permission if it exists, or undefined otherwise.
     */
    getPermission(origin, targetName) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[targetName];
    }
    /**
     * Gets all permissions for the specified subject, if any.
     *
     * @param origin - The origin of the subject.
     * @returns The permissions of the subject, if any.
     */
    getPermissions(origin) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions;
    }
    /**
     * Checks whether the subject with the specified origin has the specified
     * permission.
     *
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @returns Whether the subject has the permission.
     */
    hasPermission(origin, target) {
        return Boolean(this.getPermission(origin, target));
    }
    /**
     * Checks whether the subject with the specified origin has any permissions.
     * Use this if you want to know if a subject "exists".
     *
     * @param origin - The origin of the subject to check.
     * @returns Whether the subject has any permissions.
     */
    hasPermissions(origin) {
        return Boolean(this.state.subjects[origin]);
    }
    /**
     * Revokes all permissions from the specified origin.
     *
     * Throws an error of the origin has no permissions.
     *
     * @param origin - The origin whose permissions to revoke.
     */
    revokeAllPermissions(origin) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            delete draftState.subjects[origin];
        });
    }
    /**
     * Revokes the specified permission from the subject with the specified
     * origin.
     *
     * Throws an error if the subject or the permission does not exist.
     *
     * @param origin - The origin of the subject whose permission to revoke.
     * @param target - The target name of the permission to revoke.
     */
    revokePermission(origin, target) {
        this.revokePermissions({ [origin]: [target] });
    }
    /**
     * Revokes the specified permissions from the specified subjects.
     *
     * Throws an error if any of the subjects or permissions do not exist.
     *
     * @param subjectsAndPermissions - An object mapping subject origins
     * to arrays of permission target names to revoke.
     */
    revokePermissions(subjectsAndPermissions) {
        this.update((draftState) => {
            Object.keys(subjectsAndPermissions).forEach((origin) => {
                if (!utils_1.hasProperty(draftState.subjects, origin)) {
                    throw new errors_1.UnrecognizedSubjectError(origin);
                }
                subjectsAndPermissions[origin].forEach((target) => {
                    const { permissions } = draftState.subjects[origin];
                    if (!utils_1.hasProperty(permissions, target)) {
                        throw new errors_1.PermissionDoesNotExistError(origin, target);
                    }
                    this.deletePermission(draftState.subjects, origin, target);
                });
            });
        });
    }
    /**
     * Revokes all permissions corresponding to the specified target for all subjects.
     * Does nothing if no subjects or no such permission exists.
     *
     * @param target - The name of the target to revoke all permissions for.
     */
    revokePermissionForAllSubjects(target) {
        if (this.getSubjectNames().length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.entries(draftState.subjects).forEach(([origin, subject]) => {
                const { permissions } = subject;
                if (utils_1.hasProperty(permissions, target)) {
                    this.deletePermission(draftState.subjects, origin, target);
                }
            });
        });
    }
    /**
     * Deletes the permission identified by the given origin and target. If the
     * permission is the single remaining permission of its subject, the subject
     * is also deleted.
     *
     * @param subjects - The draft permission controller subjects.
     * @param origin - The origin of the subject associated with the permission
     * to delete.
     * @param target - The target name of the permission to delete.
     */
    deletePermission(subjects, origin, target) {
        const { permissions } = subjects[origin];
        if (Object.keys(permissions).length > 1) {
            delete permissions[target];
        }
        else {
            delete subjects[origin];
        }
    }
    /**
     * Checks whether the permission of the subject corresponding to the given
     * origin has a caveat of the specified type.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to check for.
     * @returns Whether the permission has the specified caveat.
     */
    hasCaveat(origin, target, caveatType) {
        return Boolean(this.getCaveat(origin, target, caveatType));
    }
    /**
     * Gets the caveat of the specified type, if any, for the permission of
     * the subject corresponding to the given origin.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to get.
     * @returns The caveat, or `undefined` if no such caveat exists.
     */
    getCaveat(origin, target, caveatType) {
        const permission = this.getPermission(origin, target);
        if (!permission) {
            throw new errors_1.PermissionDoesNotExistError(origin, target);
        }
        return Permission_1.findCaveat(permission, caveatType);
    }
    /**
     * Adds a caveat of the specified type, with the specified caveat value, to
     * the permission corresponding to the given subject origin and permission
     * target.
     *
     * For modifying existing caveats, use
     * {@link PermissionController.updateCaveat}.
     *
     * Throws an error if no such permission exists, or if the caveat already
     * exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to add.
     * @param caveatValue - The value of the caveat to add.
     */
    addCaveat(origin, target, caveatType, caveatValue) {
        if (this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatAlreadyExistsError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Updates the value of the caveat of the specified type belonging to the
     * permission corresponding to the given subject origin and permission
     * target.
     *
     * For adding new caveats, use
     * {@link PermissionController.addCaveat}.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to update.
     * @param caveatValue - The new value of the caveat.
     */
    updateCaveat(origin, target, caveatType, caveatValue) {
        if (!this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Sets the specified caveat on the specified permission. Overwrites existing
     * caveats of the same type in-place (preserving array order), and adds the
     * caveat to the end of the array otherwise.
     *
     * Throws an error if the permission does not exist or fails to validate after
     * its caveats have been modified.
     *
     * @see {@link PermissionController.addCaveat}
     * @see {@link PermissionController.updateCaveat}
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to set.
     * @param caveatValue - The value of the caveat to set.
     */
    setCaveat(origin, target, caveatType, caveatValue) {
        this.update((draftState) => {
            const subject = draftState.subjects[origin];
            // Unreachable because `hasCaveat` is always called before this, and it
            // throws if permissions are missing. TypeScript needs this, however.
            /* istanbul ignore if */
            if (!subject) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            const permission = subject.permissions[target];
            /* istanbul ignore if: practically impossible, but TypeScript wants it */
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            const caveat = {
                type: caveatType,
                value: caveatValue,
            };
            this.validateCaveat(caveat, origin, target);
            if (permission.caveats) {
                const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveat.type);
                if (caveatIndex === -1) {
                    permission.caveats.push(caveat);
                }
                else {
                    permission.caveats.splice(caveatIndex, 1, caveat);
                }
            }
            else {
                // Typecast: At this point, we don't know if the specific permission
                // is allowed to have caveats, but it should be impossible to call
                // this method for a permission that may not have any caveats.
                // If all else fails, the permission validator is also called.
                permission.caveats = [caveat];
            }
            this.validateModifiedPermission(permission, origin, target);
        });
    }
    /**
     * Updates all caveats with the specified type for all subjects and
     * permissions by applying the specified mutator function to them.
     *
     * **ATTN:** Permissions can be revoked entirely by the action of this method,
     * read on for details.
     *
     * Caveat mutators are functions that receive a caveat value and return a
     * tuple consisting of a {@link CaveatMutatorOperation} and, optionally, a new
     * value to update the existing caveat with.
     *
     * For each caveat, depending on the mutator result, this method will:
     * - Do nothing ({@link CaveatMutatorOperation.noop})
     * - Update the value of the caveat ({@link CaveatMutatorOperation.updateValue})
     *   - The caveat specification validator, if any, will be called after
     *     updating the value.
     * - Delete the caveat ({@link CaveatMutatorOperation.deleteCaveat})
     *   - The permission specification validator, if any, will be called after
     *     deleting the caveat.
     * - Revoke the parent permission ({@link CaveatMutatorOperation.revokePermission})
     *
     * This method throws if the validation of any caveat or permission fails.
     *
     * @param targetCaveatType - The type of the caveats to update.
     * @param mutator - The mutator function which will be applied to all caveat
     * values.
     */
    updatePermissionsByCaveat(targetCaveatType, mutator) {
        if (Object.keys(this.state.subjects).length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.values(draftState.subjects).forEach((subject) => {
                Object.values(subject.permissions).forEach((permission) => {
                    const { caveats } = permission;
                    const targetCaveat = caveats === null || caveats === void 0 ? void 0 : caveats.find(({ type }) => type === targetCaveatType);
                    if (!targetCaveat) {
                        return;
                    }
                    // The mutator may modify the caveat value in place, and must always
                    // return a valid mutation result.
                    const mutatorResult = mutator(targetCaveat.value);
                    switch (mutatorResult.operation) {
                        case CaveatMutatorOperation.noop:
                            break;
                        case CaveatMutatorOperation.updateValue:
                            // Typecast: `Mutable` is used here to assign to a readonly
                            // property. `targetConstraint` should already be mutable because
                            // it's part of a draft, but for some reason it's not. We can't
                            // use the more-correct `Draft` type here either because it
                            // results in an error.
                            targetCaveat.value =
                                mutatorResult.value;
                            this.validateCaveat(targetCaveat, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.deleteCaveat:
                            this.deleteCaveat(permission, targetCaveatType, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.revokePermission:
                            this.deletePermission(draftState.subjects, subject.origin, permission.parentCapability);
                            break;
                        default: {
                            // This type check ensures that the switch statement is
                            // exhaustive.
                            const _exhaustiveCheck = mutatorResult;
                            throw new Error(`Unrecognized mutation result: "${_exhaustiveCheck.operation}"`);
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the caveat of the specified type from the permission corresponding
     * to the given subject origin and target name.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to remove.
     */
    removeCaveat(origin, target, caveatType) {
        this.update((draftState) => {
            var _a;
            const permission = (_a = draftState.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[target];
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            if (!permission.caveats) {
                throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
            }
            this.deleteCaveat(permission, caveatType, origin, target);
        });
    }
    /**
     * Deletes the specified caveat from the specified permission. If no caveats
     * remain after deletion, the permission's caveat property is set to `null`.
     * The permission is validated after being modified.
     *
     * Throws an error if the permission does not have a caveat with the specified
     * type.
     *
     * @param permission - The permission whose caveat to delete.
     * @param caveatType - The type of the caveat to delete.
     * @param origin - The origin the permission subject.
     * @param target - The name of the permission target.
     */
    deleteCaveat(permission, caveatType, origin, target) {
        /* istanbul ignore if: not possible in our usage */
        if (!permission.caveats) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveatType);
        if (caveatIndex === -1) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        if (permission.caveats.length === 1) {
            permission.caveats = null;
        }
        else {
            permission.caveats.splice(caveatIndex, 1);
        }
        this.validateModifiedPermission(permission, origin, target);
    }
    /**
     * Validates the specified modified permission. Should **always** be invoked
     * on a permission after its caveats have been modified.
     *
     * Just like {@link PermissionController.validatePermission}, except that the
     * corresponding target key and specification are retrieved first, and an
     * error is thrown if the target key does not exist.
     *
     * @param permission - The modified permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name name of the permission.
     */
    validateModifiedPermission(permission, origin, targetName) {
        const targetKey = this.getTargetKey(permission.parentCapability);
        /* istanbul ignore if: this should be impossible */
        if (!targetKey) {
            throw new Error(`Fatal: Existing permission target key "${targetKey}" has no specification.`);
        }
        this.validatePermission(this.getPermissionSpecification(targetKey), permission, origin, targetName);
    }
    /**
     * Gets the key for the specified permission target.
     *
     * Used to support our namespaced permission target feature, which is used
     * to implement namespaced restricted JSON-RPC methods.
     *
     * @param target - The requested permission target.
     * @returns The internal key of the permission target.
     */
    getTargetKey(target) {
        if (utils_1.hasProperty(this._permissionSpecifications, target)) {
            return target;
        }
        const namespacedTargetsWithoutWildcard = {};
        for (const targetKey of Object.keys(this._permissionSpecifications)) {
            const wildCardMatch = targetKey.match(/(.+)\*$/u);
            if (wildCardMatch) {
                namespacedTargetsWithoutWildcard[wildCardMatch[1]] = true;
            }
        }
        // Check for potentially nested namespaces:
        // Ex: wildzone_
        // Ex: eth_plugin_
        const segments = target.split('_');
        let targetKey = '';
        while (segments.length > 0 &&
            !utils_1.hasProperty(this._permissionSpecifications, targetKey) &&
            !namespacedTargetsWithoutWildcard[targetKey]) {
            targetKey += `${segments.shift()}_`;
        }
        if (namespacedTargetsWithoutWildcard[targetKey]) {
            return `${targetKey}*`;
        }
        return undefined;
    }
    /**
     * Grants _approved_ permissions to the specified subject. Every permission and
     * caveat is stringently validated – including by calling every specification
     * validator – and an error is thrown if any validation fails.
     *
     * **ATTN:** This method does **not** prompt the user for approval.
     *
     * @see {@link PermissionController.requestPermissions} For initiating a
     * permissions request requiring user approval.
     * @param options - Options bag.
     * @param options.approvedPermissions - The requested permissions approved by
     * the user.
     * @param options.requestData - Permission request data. Passed to permission
     * factory functions.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions.
     * @param options.subject - The subject to grant permissions to.
     * @returns The granted permissions.
     */
    grantPermissions({ approvedPermissions, requestData, preserveExistingPermissions = true, subject, }) {
        const { origin } = subject;
        if (!origin || typeof origin !== 'string') {
            throw new errors_1.InvalidSubjectIdentifierError(origin);
        }
        const permissions = (preserveExistingPermissions
            ? Object.assign({}, this.getPermissions(origin)) : {});
        for (const [requestedTarget, approvedPermission] of Object.entries(approvedPermissions)) {
            const targetKey = this.getTargetKey(requestedTarget);
            if (!targetKey) {
                throw errors_1.methodNotFound(requestedTarget);
            }
            if (approvedPermission.parentCapability !== undefined &&
                requestedTarget !== approvedPermission.parentCapability) {
                throw new errors_1.InvalidApprovedPermissionError(origin, requestedTarget, approvedPermission);
            }
            // The requested target must be a valid target name if we found its key.
            // We reassign it to change its type.
            const targetName = requestedTarget;
            const specification = this.getPermissionSpecification(targetKey);
            // The requested caveats are validated here.
            const caveats = this.constructCaveats(origin, targetName, approvedPermission.caveats);
            const permissionOptions = {
                caveats,
                invoker: origin,
                target: targetName,
            };
            let permission;
            if (specification.factory) {
                permission = specification.factory(permissionOptions, requestData);
                // Full caveat and permission validation is performed here since the
                // factory function can arbitrarily modify the entire permission object,
                // including its caveats.
                this.validatePermission(specification, permission, origin, targetName);
            }
            else {
                permission = Permission_1.constructPermission(permissionOptions);
                // We do not need to validate caveats in this case, because the plain
                // permission constructor function does not modify the caveats, which
                // were already validated by `constructCaveats` above.
                this.validatePermission(specification, permission, origin, targetName, {
                    invokePermissionValidator: true,
                    performCaveatValidation: false,
                });
            }
            permissions[targetName] = permission;
        }
        this.setValidatedPermissions(origin, permissions);
        return permissions;
    }
    /**
     * Validates the specified permission by:
     * - Ensuring that its `caveats` property is either `null` or a non-empty
     *   array.
     * - Ensuring that it only includes caveats allowed by its specification.
     * - Ensuring that it includes no duplicate caveats (by caveat type).
     * - Validating each caveat object, if `performCaveatValidation` is `true`.
     * - Calling the validator of its specification, if one exists and
     *   `invokePermissionValidator` is `true`.
     *
     * An error is thrown if validation fails.
     *
     * @param specification - The specification of the permission.
     * @param permission - The permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name of the permission.
     * @param validationOptions - Validation options.
     * @param validationOptions.invokePermissionValidator - Whether to invoke the
     * permission's consumer-specified validator function, if any.
     * @param validationOptions.performCaveatValidation - Whether to invoke
     * {@link PermissionController.validateCaveat} on each of the permission's
     * caveats.
     */
    validatePermission(specification, permission, origin, targetName, { invokePermissionValidator, performCaveatValidation } = {
        invokePermissionValidator: true,
        performCaveatValidation: true,
    }) {
        const { allowedCaveats, validator } = specification;
        if (utils_1.hasProperty(permission, 'caveats')) {
            const { caveats } = permission;
            if (caveats !== null && !(Array.isArray(caveats) && caveats.length > 0)) {
                throw new errors_1.InvalidCaveatsPropertyError(origin, targetName, caveats);
            }
            const seenCaveatTypes = new Set();
            caveats === null || caveats === void 0 ? void 0 : caveats.forEach((caveat) => {
                if (performCaveatValidation) {
                    this.validateCaveat(caveat, origin, targetName);
                }
                if (!(allowedCaveats === null || allowedCaveats === void 0 ? void 0 : allowedCaveats.includes(caveat.type))) {
                    throw new errors_1.ForbiddenCaveatError(caveat.type, origin, targetName);
                }
                if (seenCaveatTypes.has(caveat.type)) {
                    throw new errors_1.DuplicateCaveatError(caveat.type, origin, targetName);
                }
                seenCaveatTypes.add(caveat.type);
            });
        }
        if (invokePermissionValidator && validator) {
            validator(permission, origin, targetName);
        }
    }
    /**
     * Assigns the specified permissions to the subject with the given origin.
     * Overwrites all existing permissions, and creates a subject entry if it
     * doesn't already exist.
     *
     * **ATTN:** Assumes that the new permissions have been validated.
     *
     * @param origin - The origin of the grantee subject.
     * @param permissions - The new permissions for the grantee subject.
     */
    setValidatedPermissions(origin, permissions) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                draftState.subjects[origin] = { origin, permissions: {} };
            }
            draftState.subjects[origin].permissions = immer_1.castDraft(permissions);
        });
    }
    /**
     * Validates the requested caveats for the permission of the specified
     * subject origin and target name and returns the validated caveat array.
     *
     * Throws an error if validation fails.
     *
     * @param origin - The origin of the permission subject.
     * @param target - The permission target name.
     * @param requestedCaveats - The requested caveats to construct.
     * @returns The constructed caveats.
     */
    constructCaveats(origin, target, requestedCaveats) {
        const caveatArray = requestedCaveats === null || requestedCaveats === void 0 ? void 0 : requestedCaveats.map((requestedCaveat) => {
            this.validateCaveat(requestedCaveat, origin, target);
            // Reassign so that we have a fresh object.
            const { type, value } = requestedCaveat;
            return { type, value };
        });
        return caveatArray && utils_1.isNonEmptyArray(caveatArray)
            ? caveatArray
            : undefined;
    }
    /**
     * This methods validates that the specified caveat is an object with the
     * expected properties and types. It also ensures that a caveat specification
     * exists for the requested caveat type, and calls the specification
     * validator, if it exists, on the caveat object.
     *
     * Throws an error if validation fails.
     *
     * @param caveat - The caveat object to validate.
     * @param origin - The origin associated with the subject of the parent
     * permission.
     * @param target - The target name associated with the parent permission.
     */
    validateCaveat(caveat, origin, target) {
        var _a;
        if (!utils_1.isPlainObject(caveat)) {
            throw new errors_1.InvalidCaveatError(caveat, origin, target);
        }
        if (Object.keys(caveat).length !== 2) {
            throw new errors_1.InvalidCaveatFieldsError(caveat, origin, target);
        }
        if (typeof caveat.type !== 'string') {
            throw new errors_1.InvalidCaveatTypeError(caveat, origin, target);
        }
        const specification = this.getCaveatSpecification(caveat.type);
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type, origin, target);
        }
        if (!utils_1.hasProperty(caveat, 'value') || caveat.value === undefined) {
            throw new errors_1.CaveatMissingValueError(caveat, origin, target);
        }
        if (!utils_1.isValidJson(caveat.value)) {
            throw new errors_1.CaveatInvalidJsonError(caveat, origin, target);
        }
        // Typecast: TypeScript still believes that the caveat is a PlainObject.
        (_a = specification.validator) === null || _a === void 0 ? void 0 : _a.call(specification, caveat, origin, target);
    }
    /**
     * Initiates a permission request that requires user approval. This should
     * always be used to grant additional permissions to a subject, unless user
     * approval has been obtained through some other means.
     *
     * Permissions are validated at every step of the approval process, and this
     * method will reject if validation fails.
     *
     * @see {@link ApprovalController} For the user approval logic.
     * @see {@link PermissionController.acceptPermissionsRequest} For the method
     * that _accepts_ the request and resolves the user approval promise.
     * @see {@link PermissionController.rejectPermissionsRequest} For the method
     * that _rejects_ the request and the user approval promise.
     * @param subject - The grantee subject.
     * @param requestedPermissions - The requested permissions.
     * @param options - Additional options.
     * @param options.id - The id of the permissions request. Defaults to a unique
     * id.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions. Defaults to `true`.
     * @returns The granted permissions and request metadata.
     */
    async requestPermissions(subject, requestedPermissions, options = {}) {
        const { origin } = subject;
        const { id = nanoid_1.nanoid(), preserveExistingPermissions = true } = options;
        this.validateRequestedPermissions(origin, requestedPermissions);
        const metadata = {
            id,
            origin,
        };
        const permissionsRequest = {
            metadata,
            permissions: requestedPermissions,
        };
        const _a = await this.requestUserApproval(permissionsRequest), { permissions: approvedPermissions } = _a, requestData = __rest(_a, ["permissions"]);
        return [
            this.grantPermissions({
                subject,
                approvedPermissions,
                preserveExistingPermissions,
                requestData,
            }),
            metadata,
        ];
    }
    /**
     * Validates requested permissions. Throws if validation fails.
     *
     * This method ensures that the requested permissions are a properly
     * formatted {@link RequestedPermissions} object, and performs the same
     * validation as {@link PermissionController.grantPermissions}, except that
     * consumer-specified permission validator functions are not called, since
     * they are only called on fully constructed, approved permissions that are
     * otherwise completely valid.
     *
     * Unrecognzied properties on requested permissions are ignored.
     *
     * @param origin - The origin of the grantee subject.
     * @param requestedPermissions - The requested permissions.
     */
    validateRequestedPermissions(origin, requestedPermissions) {
        if (!utils_1.isPlainObject(requestedPermissions)) {
            throw errors_1.invalidParams({
                message: `Requested permissions for origin "${origin}" is not a plain object.`,
                data: { origin, requestedPermissions },
            });
        }
        if (Object.keys(requestedPermissions).length === 0) {
            throw errors_1.invalidParams({
                message: `Permissions request for origin "${origin}" contains no permissions.`,
                data: { requestedPermissions },
            });
        }
        for (const targetName of Object.keys(requestedPermissions)) {
            const permission = requestedPermissions[targetName];
            const targetKey = this.getTargetKey(targetName);
            if (!targetKey) {
                throw errors_1.methodNotFound(targetName, { origin, requestedPermissions });
            }
            if (!utils_1.isPlainObject(permission) ||
                (permission.parentCapability !== undefined &&
                    targetName !== permission.parentCapability)) {
                throw errors_1.invalidParams({
                    message: `Permissions request for origin "${origin}" contains invalid requested permission(s).`,
                    data: { origin, requestedPermissions },
                });
            }
            // Here we validate the permission without invoking its validator, if any.
            // The validator will be invoked after the permission has been approved.
            this.validatePermission(this.getPermissionSpecification(targetKey), 
            // Typecast: The permission is still a "PlainObject" here.
            permission, origin, targetName, { invokePermissionValidator: false, performCaveatValidation: true });
        }
    }
    /**
     * Adds a request to the {@link ApprovalController} using the
     * {@link AddApprovalRequest} action. Also validates the resulting approved
     * permissions request, and throws an error if validation fails.
     *
     * @param permissionsRequest - The permissions request object.
     * @returns The approved permissions request object.
     */
    async requestUserApproval(permissionsRequest) {
        const { origin, id } = permissionsRequest.metadata;
        const approvedRequest = await this.messagingSystem.call('ApprovalController:addRequest', {
            id,
            origin,
            requestData: permissionsRequest,
            type: utils_2.MethodNames.requestPermissions,
        }, true);
        this.validateApprovedPermissions(approvedRequest, { id, origin });
        return approvedRequest;
    }
    /**
     * Validates an approved {@link PermissionsRequest} object. The approved
     * request must have the required `metadata` and `permissions` properties,
     * the `id` and `origin` of the `metadata` must match the original request
     * metadata, and the requested permissions must be valid per
     * {@link PermissionController.validateRequestedPermissions}. Any extra
     * metadata properties are ignored.
     *
     * An error is thrown if validation fails.
     *
     * @param approvedRequest - The approved permissions request object.
     * @param originalMetadata - The original request metadata.
     */
    validateApprovedPermissions(approvedRequest, originalMetadata) {
        const { id, origin } = originalMetadata;
        if (!utils_1.isPlainObject(approvedRequest) ||
            !utils_1.isPlainObject(approvedRequest.metadata)) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" is invalid.`, { data: { approvedRequest } });
        }
        const { metadata: { id: newId, origin: newOrigin }, permissions, } = approvedRequest;
        if (newId !== id) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its id.`, { originalId: id, mutatedId: newId });
        }
        if (newOrigin !== origin) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its origin.`, { originalOrigin: origin, mutatedOrigin: newOrigin });
        }
        try {
            this.validateRequestedPermissions(origin, permissions);
        }
        catch (error) {
            // Re-throw as an internal error; we should never receive invalid approved
            // permissions.
            throw errors_1.internalError(`Invalid approved permissions request: ${error.message}`, error.data);
        }
    }
    /**
     * Accepts a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param request - The permissions request.
     */
    async acceptPermissionsRequest(request) {
        const { id } = request.metadata;
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        if (Object.keys(request.permissions).length === 0) {
            this._rejectPermissionsRequest(id, errors_1.invalidParams({
                message: 'Must request at least one permission.',
            }));
            return;
        }
        try {
            this.messagingSystem.call('ApprovalController:acceptRequest', id, request);
        }
        catch (error) {
            // If accepting unexpectedly fails, reject the request and re-throw the
            // error
            this._rejectPermissionsRequest(id, error);
            throw error;
        }
    }
    /**
     * Rejects a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param id - The id of the request to be rejected.
     */
    async rejectPermissionsRequest(id) {
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        this._rejectPermissionsRequest(id, errors_1.userRejectedRequest());
    }
    /**
     * Checks whether the {@link ApprovalController} has a particular permissions
     * request.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param options - The {@link HasApprovalRequest} options.
     * @param options.id - The id of the approval request to check for.
     * @returns Whether the specified request exists.
     */
    hasApprovalRequest(options) {
        return this.messagingSystem.call('ApprovalController:hasRequest', 
        // Typecast: For some reason, the type here expects all of the possible
        // HasApprovalRequest options to be specified, when they're actually all
        // optional. Passing just the id is definitely valid, so we just cast it.
        options);
    }
    /**
     * Rejects the permissions request with the specified id, with the specified
     * error as the reason. This method is effectively a wrapper around a
     * messenger call for the `ApprovalController:rejectRequest` action.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param id - The id of the request to reject.
     * @param error - The error associated with the rejection.
     */
    _rejectPermissionsRequest(id, error) {
        return this.messagingSystem.call('ApprovalController:rejectRequest', id, error);
    }
    /**
     * Gets the subject's endowments per the specified endowment permission.
     * Throws if the subject does not have the required permission or if the
     * permission is not an endowment permission.
     *
     * @param origin - The origin of the subject whose endowments to retrieve.
     * @param targetName - The name of the endowment permission. This must be a
     * valid permission target name.
     * @param requestData - Additional data associated with the request, if any.
     * Forwarded to the endowment getter function for the permission.
     * @returns The endowments, if any.
     */
    async getEndowments(origin, targetName, requestData) {
        if (!this.hasPermission(origin, targetName)) {
            throw errors_1.unauthorized({ data: { origin, targetName } });
        }
        return this.getTypedPermissionSpecification(Permission_1.PermissionType.Endowment, targetName, origin).endowmentGetter({ origin, requestData });
    }
    /**
     * Executes a restricted method as the subject with the given origin.
     * The specified params, if any, will be passed to the method implementation.
     *
     * **ATTN:** Great caution should be exercised in the use of this method.
     * Methods that cause side effects or affect application state should
     * be avoided.
     *
     * This method will first attempt to retrieve the requested restricted method
     * implementation, throwing if it does not exist. The method will then be
     * invoked as though the subject with the specified origin had invoked it with
     * the specified parameters. This means that any existing caveats will be
     * applied to the restricted method, and this method will throw if the
     * restricted method or its caveat decorators throw.
     *
     * In addition, this method will throw if the subject does not have a
     * permission for the specified restricted method.
     *
     * @param origin - The origin of the subject to execute the method on behalf
     * of.
     * @param targetName - The name of the method to execute. This must be a valid
     * permission target name.
     * @param params - The parameters to pass to the method implementation.
     * @returns The result of the executed method.
     */
    async executeRestrictedMethod(origin, targetName, params) {
        // Throws if the method does not exist
        const methodImplementation = this.getRestrictedMethod(targetName, origin);
        const result = await this._executeRestrictedMethod(methodImplementation, { origin }, targetName, params);
        if (result === undefined) {
            throw new Error(`Internal request for method "${targetName}" as origin "${origin}" returned no result.`);
        }
        return result;
    }
    /**
     * An internal method used in the controller's `json-rpc-engine` middleware
     * and {@link PermissionController.executeRestrictedMethod}. Calls the
     * specified restricted method implementation after decorating it with the
     * caveats of its permission. Throws if the subject does not have the
     * requisite permission.
     *
     * **ATTN:** Parameter validation is the responsibility of the caller, or
     * the restricted method implementation in the case of `params`.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for usage.
     * @param methodImplementation - The implementation of the method to call.
     * @param subject - Metadata about the subject that made the request.
     * @param req - The request object associated with the request.
     * @returns
     */
    _executeRestrictedMethod(methodImplementation, subject, method, params = []) {
        const { origin } = subject;
        const permission = this.getPermission(origin, method);
        if (!permission) {
            throw errors_1.unauthorized({ data: { origin, method } });
        }
        return Caveat_1.decorateWithCaveats(methodImplementation, permission, this._caveatSpecifications)({ method, params, context: { origin } });
    }
}
exports.PermissionController = PermissionController;
//# sourceMappingURL=PermissionController.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\PermissionController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Caveat.js", {"./errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\Caveat.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateWithCaveats = void 0;
const errors_1 = require("./errors");
/**
 * Decorate a restricted method implementation with its caveats.
 *
 * Note that all caveat functions (i.e. the argument and return value of the
 * decorator) must be awaited.
 */
function decorateWithCaveats(methodImplementation, permission, // bound to the requesting origin
caveatSpecifications) {
    const { caveats } = permission;
    if (!caveats) {
        return methodImplementation;
    }
    let decorated = async (args) => methodImplementation(args);
    for (const caveat of caveats) {
        const specification = caveatSpecifications[caveat.type];
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type);
        }
        decorated = specification.decorator(decorated, caveat);
    }
    return decorated;
}
exports.decorateWithCaveats = decorateWithCaveats;
//# sourceMappingURL=Caveat.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Caveat.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\index.js", {"./getPermissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\getPermissions.js","./requestPermissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\requestPermissions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\rpc-methods\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const requestPermissions_1 = require("./requestPermissions");
const getPermissions_1 = require("./getPermissions");
exports.handlers = [requestPermissions_1.requestPermissionsHandler, getPermissions_1.getPermissionsHandler];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\SnapController.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js","./json-schemas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\index.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\utils.js","@metamask/controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs","semver/functions/valid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\semver\\functions\\valid.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\SnapController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.SNAP_PREFIX_REGEX = exports.SNAP_PREFIX = exports.controllerName = void 0;
const controllers_1 = require("@metamask/controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const valid_1 = __importDefault(require("semver/functions/valid"));
const utils_1 = require("../utils");
const json_schemas_1 = require("./json-schemas");
const utils_2 = require("./utils");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX = 'wallet_snap_';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${exports.SNAP_PREFIX}`, 'u');
const TRUNCATED_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'id',
    'permissionName',
    'version',
]);
const defaultState = {
    snapErrors: {},
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ closeAllConnections, executeSnap, getRpcMessageHandler, messenger, state, terminateAllSnaps, terminateSnap, endowmentPermissionNames = [], npmRegistryUrl, idleTimeCheckInterval = 5000, maxIdleTime = 30000, maxRequestTime = 60000, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return Object.assign(Object.assign({}, snap), { 
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped });
                        })
                            .reduce((memo, snap) => {
                            memo[snap.id] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this._closeAllConnections = closeAllConnections;
        this._endowmentPermissionNames = endowmentPermissionNames;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._onUnresponsiveSnap = this._onUnresponsiveSnap.bind(this);
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._lastRequestMap = new Map();
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._pollForLastRequestStatus();
        this._rpcHandlerMap = new Map();
        this._snapsBeingAdded = new Map();
        this._npmRegistryUrl = npmRegistryUrl;
        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.subscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:add`, (...args) => this.add(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getRpcMessageHandler`, (...args) => this.getRpcMessageHandler(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getSnapState`, (...args) => this.getSnapState(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateSnapState`, (...args) => this.updateSnapState(...args));
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    _stopSnapsLastRequestPastMax() {
        this._lastRequestMap.forEach(async (timestamp, snapId) => {
            if (this._maxIdleTime && utils_1.timeSince(timestamp) > this._maxIdleTime) {
                this.stopSnap(snapId);
            }
        });
    }
    _onUnresponsiveSnap(snapId) {
        this._transitionSnapState(snapId, SnapStatusEvent.crash);
        this._stopSnap(snapId, false);
        this.addSnapError({
            code: -32001,
            message: 'Snap Unresponsive',
            data: {
                snapId,
            },
        });
    }
    _onUnhandledSnapError(snapId, error) {
        this._transitionSnapState(snapId, SnapStatusEvent.crash);
        this._stopSnap(snapId, false);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     *
     * @param snapId - The id of the snap to transition
     * @param event - The event enum to use to transition
     */
    _transitionSnapState(snapId, event) {
        var _a;
        const snapStatus = this.state.snaps[snapId].status;
        let nextStatus = (_a = snapStatusStateMachineConfig.states[snapStatus].on[event]) !== null && _a !== void 0 ? _a : snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapId]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapId}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapId].status = nextStatus;
        });
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapId - The id of the Snap to start.
     */
    async startSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (this.state.snaps[snapId].enabled === false) {
            throw new Error(`Snap "${snapId}" is disabled.`);
        }
        await this._startSnap({
            snapId,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to enable.
     */
    enableSnap(snapId) {
        this.update((state) => {
            state.snaps[snapId].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapId - The id of the Snap to disable.
     */
    disableSnap(snapId) {
        if (this.isRunning(snapId)) {
            this.stopSnap(snapId);
        }
        this.update((state) => {
            state.snaps[snapId].enabled = false;
        });
    }
    /**
     * Stops the given snap. Throws an error if no such snap exists
     * or if it is already stopped.
     *
     * @param snapId - The id of the Snap to stop.
     */
    stopSnap(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        if (!this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" already stopped.`);
        }
        this._stopSnap(snapId);
        console.log(`Snap "${snapId}" stopped.`);
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapId - The id of the Snap to stop.
     * @param setNotRunning - Whether to mark the snap as not running.
     * Should only be set to false if the snap is about to be deleted.
     */
    _stopSnap(snapId, setNotRunning = true) {
        this._lastRequestMap.delete(snapId);
        this._closeAllConnections(snapId);
        this._terminateSnap(snapId);
        if (setNotRunning) {
            this._transitionSnapState(snapId, SnapStatusEvent.stop);
        }
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapId - The id of the Snap to check.
     */
    isRunning(snapId) {
        const snap = this.get(snapId);
        if (!snap) {
            throw new Error(`Snap "${snapId}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapId - The id of the Snap to check for.
     */
    has(snapId) {
        return Boolean(this.get(snapId));
    }
    /**
     * Gets the snap with the given id if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapId - The id of the Snap to get.
     */
    get(snapId) {
        return this.state.snaps[snapId];
    }
    /**
     * Gets the snap with the given id if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapId - The id of the Snap to get.
     */
    getTruncated(snapId) {
        const snap = this.get(snapId);
        return snap
            ? Object.keys(snap).reduce((serialized, key) => {
                if (TRUNCATED_SNAP_PROPERTIES.has(key)) {
                    serialized[key] = snap[key];
                }
                return serialized;
            }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapId, newSnapState) {
        this.update((state) => {
            state.snapStates[snapId] = newSnapState;
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    async addSnapError(snapError) {
        this.update((state) => {
            const id = nanoid_1.nanoid();
            state.snapErrors[id] = Object.assign(Object.assign({}, snapError), { internalID: id });
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given id.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapId - The id of the Snap whose state to get.
     */
    async getSnapState(snapId) {
        var _a;
        return (_a = this.state.snapStates[snapId]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapIds = Object.keys(this.state.snaps);
        snapIds.forEach((snapId) => {
            this._closeAllConnections(snapId);
        });
        this._terminateAllSnaps();
        snapIds.forEach((snapId) => this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId));
        this.update((state) => {
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapId - The id of the Snap.
     */
    removeSnap(snapId) {
        this.removeSnaps([snapId]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param snapIds - The ids of the Snaps.
     */
    removeSnaps(snapIds) {
        if (!Array.isArray(snapIds)) {
            throw new Error('Expected array of snap ids.');
        }
        this.update((state) => {
            snapIds.forEach((snapId) => {
                this._stopSnap(snapId, false);
                this._rpcHandlerMap.delete(snapId);
                delete state.snaps[snapId];
                delete state.snapStates[snapId];
                this.messagingSystem.publish(`SnapController:snapRemoved`, snapId);
            });
        });
        snapIds.forEach((snapId) => this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId));
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        var _a;
        return Object.values((_a = this.messagingSystem.call('PermissionController:getPermissions', origin)) !== null && _a !== void 0 ? _a : {}).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(exports.SNAP_PREFIX)) {
                const snapId = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getTruncated(snapId);
                permittedSnaps[snapId] = snap || {
                    error: eth_rpc_errors_1.serializeError(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap ids and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        await Promise.all(Object.entries(requestedSnaps).map(async ([snapId, { version = 'latest' }]) => {
            const permissionName = exports.SNAP_PREFIX + snapId;
            if (!isValidSnapVersion(version)) {
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.rpc.invalidParams(`The "version" field must be a valid SemVer version or the string "latest" if specified. Received: "${version}".`),
                };
                return;
            }
            if (this.messagingSystem.call('PermissionController:hasPermission', origin, permissionName)) {
                // Attempt to install and run the snap, storing any errors that
                // occur during the process.
                result[snapId] = Object.assign({}, (await this.processRequestedSnap(snapId, version)));
            }
            else {
                // only allow the installation of permitted snaps
                result[snapId] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap "${snapId}". Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param snapId - The id of the snap.
     * @param version - The version of the snap to install.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(snapId, version) {
        const existingSnap = this.getTruncated(snapId);
        if (existingSnap) {
            return existingSnap;
        }
        try {
            const { sourceCode } = await this.add({
                id: snapId,
                version,
            });
            await this.authorize(snapId);
            await this._startSnap({
                snapId,
                sourceCode,
            });
            this.messagingSystem.publish(`SnapController:snapInstalled`, snapId);
            return this.getTruncated(snapId);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            if (this.has(snapId)) {
                this.removeSnap(snapId);
            }
            return { error: eth_rpc_errors_1.serializeError(err) };
        }
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapId - The id of the Snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args) {
        const { id: _snapId } = args;
        this.validateSnapId(_snapId);
        const snapId = _snapId;
        if (!args ||
            !('id' in args) ||
            (!('manifest' in args) && 'sourceCode' in args) ||
            ('manifest' in args && !('sourceCode' in args))) {
            throw new Error(`Invalid add snap args for snap "${snapId}".`);
        }
        if (!this._snapsBeingAdded.has(snapId)) {
            console.log(`Adding snap: ${snapId}`);
            this._snapsBeingAdded.set(snapId, this._add(args));
        }
        return this._snapsBeingAdded.get(snapId);
    }
    validateSnapId(snapId) {
        if (!snapId || typeof snapId !== 'string') {
            throw new Error(`Invalid snap id: Not a string. Received "${snapId}"`);
        }
        for (const prefix of Object.values(utils_2.SnapIdPrefixes)) {
            if (snapId.startsWith(prefix) && snapId.replace(prefix, '').length > 0) {
                return;
            }
        }
        throw new Error(`Invalid snap id. Received: "${snapId}"`);
    }
    async _startSnap(snapData) {
        const { snapId } = snapData;
        if (this.isRunning(snapId)) {
            throw new Error(`Snap "${snapId}" is already started.`);
        }
        const result = await this._executeSnap(Object.assign(Object.assign({}, snapData), { endowments: await this._getEndowments(snapId) }));
        this._transitionSnapState(snapId, SnapStatusEvent.start);
        return result;
    }
    /**
     * Gets the names of all endowments that will be added to the Snap's
     * Compartment when it executes. These should be the names of global
     * JavaScript APIs accessible in the root realm of the execution environment.
     *
     * Throws an error if the endowment getter for a permission returns a truthy
     * value that is not an array of strings.
     *
     * @param snapId - The id of the snap whose SES endowments to get.
     * @returns An array of the names of the endowments, if any.
     */
    async _getEndowments(snapId) {
        let allEndowments = [];
        for (const permissionName of this._endowmentPermissionNames) {
            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
                if (endowments) {
                    // We don't have any guarantees about the type of the endowments
                    // value, so we have to guard at runtime.
                    if (!Array.isArray(endowments) ||
                        endowments.some((value) => typeof value !== 'string')) {
                        throw new Error('Expected an array of string endowment names.');
                    }
                    allEndowments = allEndowments.concat(endowments);
                }
            }
        }
        return allEndowments.length > 0 ? allEndowments : undefined;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param snapId - The id of the Snap.
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _add(args) {
        const { id: snapId, version } = args;
        let manifest, sourceCode, svgIcon;
        if ('manifest' in args) {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
            json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, manifest);
        }
        else {
            ({ manifest, sourceCode, svgIcon } = await this._fetchSnap(snapId, version));
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapId}".`);
        }
        const initialPermissions = manifest === null || manifest === void 0 ? void 0 : manifest.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapId}".`);
        }
        let snap = {
            enabled: true,
            id: snapId,
            initialPermissions,
            manifest,
            permissionName: exports.SNAP_PREFIX + snapId,
            sourceCode,
            status: snapStatusStateMachineConfig.initial,
            version: manifest.version,
        };
        const snapsState = this.state.snaps;
        // restore relevant snap state if it exists
        if (snapsState[snapId]) {
            snap = Object.assign(Object.assign({}, snapsState[snapId]), snap);
        }
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapId] = snap;
        });
        this.messagingSystem.publish(`SnapController:snapAdded`, snapId, snap, svgIcon);
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param snapId - The id of the Snap.
     * @param version - The version of the Snap to fetch.
     * @returns A tuple of the Snap manifest object and the Snap source code.
     */
    async _fetchSnap(snapId, version) {
        try {
            if (snapId.startsWith(utils_2.SnapIdPrefixes.local)) {
                return this._fetchLocalSnap(snapId.replace(utils_2.SnapIdPrefixes.local, ''));
            }
            else if (snapId.startsWith(utils_2.SnapIdPrefixes.npm)) {
                return this._fetchNpmSnap(snapId.replace(utils_2.SnapIdPrefixes.npm, ''), version);
            }
            // This should be impossible.
            /* istanbul ignore next */
            throw new Error(`Invalid Snap id: "${snapId}"`);
        }
        catch (error) {
            throw new Error(`Failed to fetch Snap "${snapId}": ${error.message}`);
        }
    }
    async _fetchNpmSnap(packageName, version) {
        if (!isValidSnapVersion(version)) {
            throw new Error(`Received invalid Snap version: "${version}".`);
        }
        const { manifest, sourceCode, svgIcon } = await utils_2.fetchNpmSnap(packageName, version, this._npmRegistryUrl);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Fetches the manifest and source code of a local snap.
     *
     * @param localhostUrl - The localhost URL to download from.
     * @returns The validated manifest and the source code.
     */
    async _fetchLocalSnap(localhostUrl) {
        const manifestUrl = new URL(utils_2.NpmSnapFileNames.Manifest, localhostUrl);
        if (!utils_2.LOCALHOST_HOSTNAMES.has(manifestUrl.hostname)) {
            throw new Error(`Invalid URL: Locally hosted Snaps must be hosted on localhost. Received URL: "${manifestUrl.toString()}"`);
        }
        const _manifest = await utils_2.fetchContent(manifestUrl, 'json');
        json_schemas_1.validateSnapJsonFile(utils_2.NpmSnapFileNames.Manifest, _manifest);
        const manifest = _manifest;
        const { source: { location: { npm: { filePath, iconPath }, }, }, } = manifest;
        const [sourceCode, svgIcon] = await Promise.all([
            utils_2.fetchContent(new URL(filePath, localhostUrl), 'text'),
            iconPath
                ? utils_2.fetchContent(new URL(iconPath, localhostUrl), 'text')
                : undefined,
        ]);
        utils_2.validateSnapShasum(manifest, sourceCode);
        return { manifest, sourceCode, svgIcon };
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapId - The id of the Snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapId) {
        console.log(`Authorizing snap: ${snapId}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapId];
        const { initialPermissions } = snap;
        // Don't prompt if there are no permissions requested:
        if (Object.keys(initialPermissions).length === 0) {
            return [];
        }
        if (initialPermissions === null) {
            return [];
        }
        try {
            const [approvedPermissions] = await this.messagingSystem.call('PermissionController:requestPermissions', { origin: snapId }, initialPermissions);
            return Object.values(approvedPermissions).map((perm) => perm.parentCapability);
        }
        finally {
            this._snapsBeingAdded.delete(snapId);
        }
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.unsubscribe('ExecutionService:unresponsive', this._onUnresponsiveSnap);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        const existingHandler = this._rpcHandlerMap.get(snapId);
        if (existingHandler) {
            return existingHandler;
        }
        const rpcHandler = async (origin, request) => {
            let handler = await this._getRpcMessageHandler(snapId);
            if (this.state.snaps[snapId].enabled === false) {
                throw new Error(`Snap "${snapId}" is disabled.`);
            }
            if (this.state.snaps[snapId].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapId}" has not been started yet.`);
            }
            if (!handler && this.isRunning(snapId) === false) {
                // cold start
                await this.startSnap(snapId);
                handler = await this._getRpcMessageHandler(snapId);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapId}".`);
            }
            this._recordSnapRpcRequest(snapId);
            // Handle max request time
            let timeout;
            const timeoutPromise = new Promise((_resolve, reject) => {
                timeout = setTimeout(() => {
                    this._stopSnap(snapId);
                    reject(new Error('The request timed out.'));
                }, this._maxRequestTime);
            });
            // This will either get the result or reject due to the timeout.
            const result = await Promise.race([
                handler(origin, request),
                timeoutPromise,
            ]);
            clearTimeout(timeout);
            return result;
        };
        this._rpcHandlerMap.set(snapId, rpcHandler);
        return rpcHandler;
    }
    _recordSnapRpcRequest(snapId) {
        this._lastRequestMap.set(snapId, Date.now());
    }
}
exports.SnapController = SnapController;
function isValidSnapVersion(version) {
    return Boolean(typeof version === 'string' &&
        (version === 'latest' || valid_1.default(version)));
}
//# sourceMappingURL=SnapController.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\SnapController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\index.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\utils.js","./validateNpmSnapPackageJson.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateNpmSnapPackageJson.js","./validateSnapManifest.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateSnapManifest.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\json-schemas\index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSnapJsonFile = void 0;
const validateNpmSnapPackageJson_js_1 = __importDefault(require("./validateNpmSnapPackageJson.js"));
const validateSnapManifest_js_1 = __importDefault(require("./validateSnapManifest.js"));
const utils_1 = require("../utils");
/**
 * Validates a Snap JSON file. Throws a human-readable list of errors if
 * validation fails.
 *
 * @param fileName - The name of Snap JSON file to validate.
 * @param content - The contents of the file.
 */
function validateSnapJsonFile(fileName, content) {
    let errors;
    switch (fileName) {
        case utils_1.NpmSnapFileNames.Manifest:
            if (content && typeof content === 'object' && !Array.isArray(content)) {
                if (content.repository === undefined) {
                    // We do this to allow consumers to omit this field. We cannot omit
                    // it internally due to TS@<4.4 limitations.
                    content.repository = null;
                }
            }
            errors = validateSnapManifest_js_1.default(content);
            break;
        case utils_1.NpmSnapFileNames.PackageJson:
            errors = validateNpmSnapPackageJson_js_1.default(content);
            break;
        default:
            throw new Error(`Unrecognized file name "${fileName}".`);
    }
    if (errors && errors.length !== 0) {
        throw new Error(`${errors.reduce((allErrors, errorObject = {}) => {
            const { instancePath, message = 'unknown error' } = errorObject;
            const currentString = instancePath
                ? `\t${instancePath}\n\t${message}\n\n`
                : `\t${message}\n\n`;
            return `${allErrors}${currentString}`;
        }, '').replace(/\n$/u, '')}`);
    }
}
exports.validateSnapJsonFile = validateSnapJsonFile;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\utils.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js","./json-schemas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","concat-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\index.js","crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js","fast-deep-equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-deep-equal\\index.js","gunzip-maybe":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\index.js","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pump\\index.js","readable-web-to-node-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\lib\\index.js","tar-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSnapShasum = exports.validateNpmSnapManifest = exports.validateNpmSnap = exports.ProgrammaticallyFixableSnapError = exports.SnapValidationFailureReason = exports.fetchNpmSnap = exports.getSnapSourceShasum = exports.fetchContent = exports.PROPOSED_NAME_REGEX = exports.DEFAULT_NPM_REGISTRY = exports.LOCALHOST_HOSTNAMES = exports.NpmSnapFileNames = exports.SnapIdPrefixes = void 0;
const crypto_1 = require("crypto");
const concat_stream_1 = __importDefault(require("concat-stream"));
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const gunzip_maybe_1 = __importDefault(require("gunzip-maybe"));
const pump_1 = __importDefault(require("pump"));
const readable_web_to_node_stream_1 = require("readable-web-to-node-stream");
const tar_stream_1 = require("tar-stream");
const utils_1 = require("../utils");
const json_schemas_1 = require("./json-schemas");
var SnapIdPrefixes;
(function (SnapIdPrefixes) {
    SnapIdPrefixes["npm"] = "npm:";
    SnapIdPrefixes["local"] = "local:";
})(SnapIdPrefixes = exports.SnapIdPrefixes || (exports.SnapIdPrefixes = {}));
var NpmSnapFileNames;
(function (NpmSnapFileNames) {
    NpmSnapFileNames["PackageJson"] = "package.json";
    NpmSnapFileNames["Manifest"] = "snap.manifest.json";
})(NpmSnapFileNames = exports.NpmSnapFileNames || (exports.NpmSnapFileNames = {}));
exports.LOCALHOST_HOSTNAMES = new Set(['localhost', '127.0.0.1']);
exports.DEFAULT_NPM_REGISTRY = 'https://registry.npmjs.org';
const SVG_MAX_BYTE_SIZE = 100000;
const SVG_MAX_BYTE_SIZE_TEXT = `${Math.floor(SVG_MAX_BYTE_SIZE / 1000)}kb`;
// This RegEx matches valid npm package names (with some exceptions) and space-
// separated alphanumerical words, optionally with dashes and underscores.
// The RegEx consists of two parts. The first part matches space-separated
// words. It is based on the following Stackoverflow answer:
// https://stackoverflow.com/a/34974982
// The second part, after the pipe operator, is the same RegEx used for the
// `name` field of the official package.json JSON Schema, except that we allow
// mixed-case letters. It was originally copied from:
// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138
exports.PROPOSED_NAME_REGEX = /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;
/**
 * @param url - The URL to fetch.
 * @param contentType - The content type of the response body.
 * @returns The response body as the specified content type.
 */
async function fetchContent(url, contentType, fetchFunction = fetch) {
    const response = await fetchFunction(typeof url === 'string' ? url : url.toString());
    return await response[contentType]();
}
exports.fetchContent = fetchContent;
/**
 * Calculates the Base64-econded SHA-256 digest of a Snap source code string.
 *
 * @param sourceCode - The UTF-8 string source code of a Snap.
 * @returns The Base64-encoded SHA-256 digest of the source code.
 */
function getSnapSourceShasum(sourceCode) {
    return crypto_1.createHash('sha256').update(sourceCode, 'utf8').digest('base64');
}
exports.getSnapSourceShasum = getSnapSourceShasum;
// npm fetch stuff
const ExpectedSnapFiles = ['manifest', 'packageJson', 'sourceCode'];
const SnapFileNameFromKey = {
    manifest: NpmSnapFileNames.Manifest,
    packageJson: NpmSnapFileNames.PackageJson,
    sourceCode: 'source code bundle',
};
/**
 * Fetches a Snap from the public npm registry.
 *
 * @param packageName - The name of the package whose tarball to fetch.
 * @param version - The version of the package to fetch, or the string `latest`
 * to fetch the latest version.
 * @param fetchFunction - The fetch function to use. Defaults to the global
 * {@link fetch}. Useful for Node.js compatibility.
 * @returns A tuple of the Snap manifest object and the Snap source code.
 */
async function fetchNpmSnap(packageName, version, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
    const [tarballResponse, actualVersion] = await fetchNpmTarball(packageName, version, registryUrl, fetchFunction);
    // Extract the tarball and get the necessary files from it.
    const snapFiles = {};
    await new Promise((resolve, reject) => {
        pump_1.default(getResponseBodyStream(tarballResponse), 
        // The "gz" in "tgz" stands for "gzip". The tarball needs to be decompressed
        // before we can actually grab any files from it.
        gunzip_maybe_1.default(), createTarballExtractionStream(snapFiles), (error) => {
            error ? reject(error) : resolve();
        });
    });
    // At this point, the necessary files will have been added to the snapFiles
    // object if they exist.
    return validateNpmSnap(snapFiles, `npm Snap "${packageName}@${actualVersion}" validation error: `);
}
exports.fetchNpmSnap = fetchNpmSnap;
/**
 * Snap validation failure reason codes that are programmatically fixable
 * if validation occurs during development.
 */
var SnapValidationFailureReason;
(function (SnapValidationFailureReason) {
    SnapValidationFailureReason["NameMismatch"] = "\"name\" field mismatch";
    SnapValidationFailureReason["VersionMismatch"] = "\"version\" field mismatch";
    SnapValidationFailureReason["RepositoryMismatch"] = "\"repository\" field mismatch";
    SnapValidationFailureReason["ShasumMismatch"] = "\"shasum\" field mismatch";
})(SnapValidationFailureReason = exports.SnapValidationFailureReason || (exports.SnapValidationFailureReason = {}));
/**
 * An error indicating that a Snap validation failure is programmatically
 * fixable during development.
 */
class ProgrammaticallyFixableSnapError extends Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
    }
}
exports.ProgrammaticallyFixableSnapError = ProgrammaticallyFixableSnapError;
/**
 * Validates the files extracted from an npm Snap package tarball by ensuring
 * that they're non-empty and that the Json files match their respective schemas
 * and the Snaps publishing specification.
 *
 * @param snapFiles - The object containing the expected Snap file contents,
 * if any.
 * @param packageName - The name of the package whose tarball to fetch.
 * @param version - The version of the package to fetch, or the string `latest`.
 * @param errorPrefix - The prefix of the error message.
 * @returns A tuple of the Snap manifest object and the Snap source code.
 */
function validateNpmSnap(snapFiles, errorPrefix) {
    ExpectedSnapFiles.forEach((key) => {
        if (!snapFiles[key]) {
            throw new Error(`${errorPrefix}Missing file "${SnapFileNameFromKey[key]}".`);
        }
    });
    // Typecast: We are assured that the required files exist if we get here.
    const { manifest, packageJson, sourceCode, svgIcon } = snapFiles;
    try {
        json_schemas_1.validateSnapJsonFile(NpmSnapFileNames.Manifest, manifest);
    }
    catch (error) {
        throw new Error(`${errorPrefix}"${NpmSnapFileNames.Manifest}" is invalid:\n${error.message}`);
    }
    const validatedManifest = manifest;
    const { iconPath } = validatedManifest.source.location.npm;
    if (iconPath && !svgIcon) {
        throw new Error(`${errorPrefix}Missing file "${iconPath}".`);
    }
    try {
        json_schemas_1.validateSnapJsonFile(NpmSnapFileNames.PackageJson, packageJson);
    }
    catch (error) {
        throw new Error(`${errorPrefix}"${NpmSnapFileNames.PackageJson}" is invalid:\n${error.message}`);
    }
    const validatedPackageJson = packageJson;
    validateNpmSnapManifest({
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
    }, errorPrefix);
    if (svgIcon) {
        if (Buffer.byteLength(svgIcon, 'utf8') > SVG_MAX_BYTE_SIZE) {
            throw new Error(`${errorPrefix}The specified SVG icon exceeds the maximum size of ${SVG_MAX_BYTE_SIZE_TEXT}.`);
        }
    }
    return {
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
        svgIcon,
    };
}
exports.validateNpmSnap = validateNpmSnap;
/**
 * Validates the fields of an npm Snap manifest that has already passed JSON
 * Schema validation.
 *
 * @param manifest - The npm Snap manifest to validate.
 * @param packageJson - The npm Snap's `package.json`.
 * @param sourceCode - The Snap's source code.
 * @param errorPrefix - The prefix for error messages.
 */
function validateNpmSnapManifest({ manifest, packageJson, sourceCode }, errorPrefix) {
    const packageJsonName = packageJson.name;
    const packageJsonVersion = packageJson.version;
    const packageJsonRepository = packageJson.repository;
    const manifestPackageName = manifest.source.location.npm.packageName;
    const manifestPackageVersion = manifest.version;
    const manifestRepository = manifest.repository;
    if (packageJsonName !== manifestPackageName) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" npm package name ("${manifestPackageName}") does not match the "${NpmSnapFileNames.PackageJson}" "name" field ("${packageJsonName}").`, SnapValidationFailureReason.NameMismatch);
    }
    if (packageJsonVersion !== manifestPackageVersion) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" npm package version ("${manifestPackageVersion}") does not match the "${NpmSnapFileNames.PackageJson}" "version" field ("${packageJsonVersion}").`, SnapValidationFailureReason.VersionMismatch);
    }
    if (
    // The repository may be `undefined` in package.json but can only be defined
    // or `null` in the Snap manifest due to TS@<4.4 issues.
    (packageJsonRepository || manifestRepository) &&
        !fast_deep_equal_1.default(packageJsonRepository, manifestRepository)) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" "repository" field does not match the "${NpmSnapFileNames.PackageJson}" "repository" field.`, SnapValidationFailureReason.RepositoryMismatch);
    }
    validateSnapShasum(manifest, sourceCode, `${errorPrefix}"${NpmSnapFileNames.Manifest}" "shasum" field does not match computed shasum.`);
    return [manifest, sourceCode, packageJson];
}
exports.validateNpmSnapManifest = validateNpmSnapManifest;
/**
 * Fetches the tarball (`.tgz` file) of the specified package and version from
 * the public npm registry. Throws an error if fetching fails.
 *
 * @param packageName - The name of the package whose tarball to fetch.
 * @param version - The version of the package to fetch, or the string `latest`
 * to fetch the latest version.
 * @param fetchFunction - The fetch function to use. Defaults to the global
 * {@link fetch}. Useful for Node.js compatibility.
 * @returns A tuple of the {@link Response} for the package tarball and the
 * actual version of the package.
 */
async function fetchNpmTarball(packageName, version, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
    var _a, _b, _c, _d;
    const packageMetadata = await fetchContent(new URL(packageName, registryUrl), 'json', fetchFunction);
    if (!utils_1.isPlainObject(packageMetadata)) {
        throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
    }
    const targetVersion = version === 'latest'
        ? (_a = packageMetadata['dist-tags']) === null || _a === void 0 ? void 0 : _a.latest
        : version;
    const tarballUrlString = (_d = (_c = (_b = packageMetadata.versions) === null || _b === void 0 ? void 0 : _b[targetVersion]) === null || _c === void 0 ? void 0 : _c.dist) === null || _d === void 0 ? void 0 : _d.tarball;
    if (!isValidUrl(tarballUrlString) || !tarballUrlString.endsWith('.tgz')) {
        throw new Error(`Failed to find valid tarball URL in npm metadata for package "${packageName}".`);
    }
    // Override the tarball hostname/protocol with registryUrl hostname/protocol
    const newRegistryUrl = new URL(registryUrl);
    const newTarballUrl = new URL(tarballUrlString);
    newTarballUrl.hostname = newRegistryUrl.hostname;
    newTarballUrl.protocol = newRegistryUrl.protocol;
    // Perform a raw fetch because we want the Response object itself.
    const tarballResponse = await fetchFunction(newTarballUrl.toString());
    if (!tarballResponse.ok || !tarballResponse.body) {
        throw new Error(`Failed to fetch tarball for package "${packageName}".`);
    }
    return [tarballResponse, targetVersion];
}
// The paths of files within npm tarballs appear to always be prefixed with
// "package/".
const NPM_TARBALL_PATH_PREFIX = /^package\//u;
/**
 * Creates a `tar-stream` that will get the necessary files from an npm Snap
 * package tarball (`.tgz` file).
 *
 * @param snapFiles - An object to write target file contents to.
 * @returns The {@link Writable} tarball extraction stream.
 */
function createTarballExtractionStream(snapFiles) {
    // `tar-stream` is pretty old-school, so we create it first and then
    // instrument it by adding event listeners.
    const extractStream = tar_stream_1.extract();
    // `tar-stream` reads every file in the tarball serially. We already know
    // where to look for package.json and the Snap manifest, but we don't know
    // where the source code is. Therefore, we cache the contents of each .js
    // file in the tarball and pick out the correct one when the stream has ended.
    const jsFileCache = new Map();
    // "entry" is fired for every discreet entity in the tarball. This includes
    // files and folders.
    extractStream.on('entry', (header, entryStream, next) => {
        const { name: headerName, type: headerType } = header;
        if (headerType === 'file') {
            // The name is a path if the header type is "file".
            const filePath = headerName.replace(NPM_TARBALL_PATH_PREFIX, '');
            // Note the use of `concat-stream` since the data for each file may be
            // chunked.
            if (filePath === NpmSnapFileNames.PackageJson) {
                return entryStream.pipe(concat_stream_1.default((data) => {
                    try {
                        snapFiles.packageJson = JSON.parse(data.toString());
                    }
                    catch (_error) {
                        return extractStream.destroy(new Error(`Failed to parse "${NpmSnapFileNames.PackageJson}".`));
                    }
                    return next();
                }));
            }
            else if (filePath === NpmSnapFileNames.Manifest) {
                return entryStream.pipe(concat_stream_1.default((data) => {
                    try {
                        snapFiles.manifest = JSON.parse(data.toString());
                    }
                    catch (_error) {
                        return extractStream.destroy(new Error(`Failed to parse "${NpmSnapFileNames.Manifest}".`));
                    }
                    return next();
                }));
            }
            else if (/\w+\.(?:js|svg)$/u.test(filePath)) {
                return entryStream.pipe(concat_stream_1.default((data) => {
                    jsFileCache.set(filePath, data);
                    return next();
                }));
            }
        }
        // If we get here, the entry is not a file, and we want to ignore. The entry
        // stream must be drained, or the extractStream will stop reading. This is
        // effectively a no-op for the current entry.
        entryStream.on('end', () => next());
        return entryStream.resume();
    });
    // When we've read the entire tarball, attempt to grab the bundle file
    // contents from the .js file cache.
    extractStream.on('finish', () => {
        var _a, _b, _c, _d, _e;
        if (utils_1.isPlainObject(snapFiles.manifest)) {
            /* istanbul ignore next: optional chaining */
            const { filePath: bundlePath, iconPath } = (_c = (_b = (_a = snapFiles.manifest.source) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.npm) !== null && _c !== void 0 ? _c : {};
            if (bundlePath) {
                snapFiles.sourceCode = (_d = jsFileCache.get(bundlePath)) === null || _d === void 0 ? void 0 : _d.toString('utf8');
            }
            if (typeof iconPath === 'string' && iconPath.endsWith('.svg')) {
                snapFiles.svgIcon = (_e = jsFileCache.get(iconPath)) === null || _e === void 0 ? void 0 : _e.toString('utf8');
            }
        }
        jsFileCache.clear();
    });
    return extractStream;
}
/**
 * Checks whether the source.shasum property of the specified Snap manifest
 * matches the shasum of the specified snap source code string.
 *
 * @param manifest - The manifest whose shasum to validate.
 * @param sourceCode - The source code of the snap.
 */
function validateSnapShasum(manifest, sourceCode, errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.') {
    if (manifest.source.shasum !== getSnapSourceShasum(sourceCode)) {
        throw new ProgrammaticallyFixableSnapError(errorMessage, SnapValidationFailureReason.ShasumMismatch);
    }
}
exports.validateSnapShasum = validateSnapShasum;
/**
 * Gets the body of a {@link fetch} response as a Node.js {@link Readable}
 * stream. Returns the stream directly if it is already a Node.js stream.
 * We can't use the native Web {@link ReadableStream} directly because the
 * other stream libraries we use expect Node.js streams.
 *
 * @param response - The response whose body stream to get.
 * @returns The response body stream, as a Node.js Readable stream.
 */
function getResponseBodyStream(response) {
    const { body } = response;
    if (typeof body.getReader !== 'function') {
        return body;
    }
    return new readable_web_to_node_stream_1.ReadableWebToNodeStream(response.body);
}
/**
 * @param maybeUrl - The string to check.
 * @returns Whether the specified string is a valid URL.
 */
function isValidUrl(maybeUrl) {
    try {
        return Boolean(new URL(maybeUrl));
    }
    catch (_error) {
        return false;
    }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\ExecutionService.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\services\ExecutionService.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ExecutionService.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\ExecutionService.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\AbstractExecutionService.js", {"@metamask/object-multiplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\services\AbstractExecutionService.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMultiplex = exports.AbstractExecutionService = void 0;
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
class AbstractExecutionService {
    constructor({ setupSnapProvider, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        this._snapRpcHooks = new Map();
        this.jobs = new Map();
        this.setupSnapProvider = setupSnapProvider;
        this.snapToJobMap = new Map();
        this.jobToSnapMap = new Map();
        this._messenger = messenger;
        this._unresponsivePollingInterval = unresponsivePollingInterval;
        this._unresponsiveTimeout = unresponsiveTimeout;
        this._timeoutForUnresponsiveMap = new Map();
    }
    async terminateSnap(snapId) {
        const jobId = this.snapToJobMap.get(snapId);
        if (!jobId) {
            throw new Error(`Job not found for snap with id "${snapId}".`);
        }
        this.terminate(jobId);
    }
    async terminateAllSnaps() {
        for (const workerId of this.jobs.keys()) {
            this.terminate(workerId);
        }
        this._snapRpcHooks.clear();
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapId - The id of the Snap whose message handler to get.
     */
    async getRpcMessageHandler(snapId) {
        return this._snapRpcHooks.get(snapId);
    }
    async executeSnap(snapData) {
        if (this.snapToJobMap.has(snapData.snapId)) {
            throw new Error(`Snap "${snapData.snapId}" is already being executed.`);
        }
        const job = await this._initJob();
        this._mapSnapAndJob(snapData.snapId, job.id);
        this.setupSnapProvider(snapData.snapId, job.streams.rpc);
        const result = await this._command(job.id, {
            jsonrpc: '2.0',
            method: 'executeSnap',
            params: snapData,
            id: nanoid_1.nanoid(),
        });
        // set up poll/ping for status to see if its up, if its not then emit event that it cant be reached
        this._pollForJobStatus(snapData.snapId);
        this._createSnapHooks(snapData.snapId, job.id);
        return result;
    }
    async _command(jobId, message) {
        if (typeof message !== 'object') {
            throw new Error('Must send object.');
        }
        const job = this.jobs.get(jobId);
        if (!job) {
            throw new Error(`Job with id "${jobId}" not found.`);
        }
        console.log('Parent: Sending Command', message);
        const response = await job.rpcEngine.handle(message);
        if (response.error) {
            throw new Error(response.error.message);
        }
        return response.result;
    }
    _removeSnapHooks(snapId) {
        this._snapRpcHooks.delete(snapId);
    }
    _createSnapHooks(snapId, workerId) {
        const rpcHook = async (origin, request) => {
            return await this._command(workerId, {
                id: nanoid_1.nanoid(),
                jsonrpc: '2.0',
                method: 'snapRpc',
                params: {
                    origin,
                    request,
                    target: snapId,
                },
            });
        };
        this._snapRpcHooks.set(snapId, rpcHook);
    }
    _pollForJobStatus(snapId) {
        const jobId = this.snapToJobMap.get(snapId);
        if (!jobId) {
            throw new Error('no job id found for snap');
        }
        const timeout = setTimeout(async () => {
            this._getJobStatus(jobId)
                .then(() => {
                this._pollForJobStatus(snapId);
            })
                .catch(() => {
                this._messenger.publish('ExecutionService:unresponsive', snapId);
            });
        }, this._unresponsivePollingInterval);
        this._timeoutForUnresponsiveMap.set(snapId, timeout);
    }
    async _getJobStatus(jobId) {
        let resolve;
        let reject;
        const timeoutPromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        const timeout = setTimeout(() => {
            reject(new Error('ping request timed out'));
        }, this._unresponsiveTimeout);
        return Promise.race([
            this._command(jobId, {
                jsonrpc: '2.0',
                method: 'ping',
                params: [],
                id: nanoid_1.nanoid(),
            }).then(() => {
                clearTimeout(timeout);
                resolve();
            }),
            timeoutPromise,
        ]);
    }
    /**
     * @returns The ID of the snap's job.
     */
    _getJobForSnap(snapId) {
        return this.snapToJobMap.get(snapId);
    }
    /**
     * @returns The ID jobs's snap.
     */
    _getSnapForJob(jobId) {
        return this.jobToSnapMap.get(jobId);
    }
    _mapSnapAndJob(snapId, jobId) {
        this.snapToJobMap.set(snapId, jobId);
        this.jobToSnapMap.set(jobId, snapId);
    }
    _removeSnapAndJobMapping(jobId) {
        const snapId = this.jobToSnapMap.get(jobId);
        if (!snapId) {
            throw new Error(`job: "${jobId}" has no mapped snap.`);
        }
        this.jobToSnapMap.delete(jobId);
        this.snapToJobMap.delete(snapId);
        this._removeSnapHooks(snapId);
    }
}
exports.AbstractExecutionService = AbstractExecutionService;
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param connectionStream - the stream to mux
 * @param streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex(connectionStream, streamName) {
    const mux = new object_multiplex_1.default();
    pump_1.default(connectionStream, 
    // Typecast: stream type mismatch
    mux, connectionStream, (err) => {
        if (err) {
            streamName
                ? console.error(`"${streamName}" stream failure.`, err)
                : console.error(err);
        }
    });
    return mux;
}
exports.setupMultiplex = setupMultiplex;
//# sourceMappingURL=AbstractExecutionService.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\AbstractExecutionService.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\WebWorkerExecutionService.js", {"./AbstractExecutionService":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\AbstractExecutionService.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/post-message-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\index.js","@metamask/snap-workers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\index.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js","json-rpc-middleware-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\services\WebWorkerExecutionService.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebWorkerExecutionService = void 0;
const obs_store_1 = require("@metamask/obs-store");
const post_message_stream_1 = require("@metamask/post-message-stream");
const snap_workers_1 = require("@metamask/snap-workers");
const json_rpc_engine_1 = require("json-rpc-engine");
const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
const AbstractExecutionService_1 = require("./AbstractExecutionService");
class WebWorkerExecutionService extends AbstractExecutionService_1.AbstractExecutionService {
    constructor({ setupSnapProvider, workerUrl, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        super({
            setupSnapProvider,
            messenger,
            unresponsivePollingInterval,
            unresponsiveTimeout,
        });
        this.workerUrl = workerUrl;
        this.store = new obs_store_1.ObservableStore({ workers: {} });
    }
    _setWorker(workerId, workerWrapper) {
        this.jobs.set(workerId, workerWrapper);
        const newWorkerState = Object.assign(Object.assign({}, this.store.getState().workers), { [workerId]: workerWrapper });
        this.store.updateState({ workers: newWorkerState });
    }
    _deleteWorker(workerId) {
        this.jobs.delete(workerId);
        const newWorkerState = Object.assign({}, this.store.getState().workers);
        delete newWorkerState[workerId];
        this.store.updateState({ workers: newWorkerState });
    }
    terminate(workerId) {
        const workerWrapper = this.jobs.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id "${workerId}" not found.`);
        }
        const snapId = this._getSnapForJob(workerId);
        if (!snapId) {
            throw new Error(`Failed to find a snap for worker with id "${workerId}".`);
        }
        Object.values(workerWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.log('Error while destroying stream', err);
            }
        });
        workerWrapper.worker.terminate();
        this._removeSnapAndJobMapping(workerId);
        this._deleteWorker(workerId);
        clearTimeout(this._timeoutForUnresponsiveMap.get(workerId));
        this._timeoutForUnresponsiveMap.delete(workerId);
        console.log(`worker:${workerId} terminated`);
    }
    async _initJob() {
        const workerId = nanoid_1.nanoid();
        const worker = new Worker(this.workerUrl, {
            name: workerId,
        });
        // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.
        const errorHandler = (ev) => {
            if (this._messenger) {
                const snapId = this.jobToSnapMap.get(workerId);
                if (snapId) {
                    this._messenger.publish('ExecutionService:unhandledError', snapId, {
                        code: ev.error.code,
                        message: ev.error.message,
                        data: ev.error.data,
                    });
                }
            }
        };
        worker.addEventListener('error', errorHandler, { once: true });
        const streams = this._initWorkerStreams(worker, workerId);
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        const jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();
        pump_1.default(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);
        rpcEngine.push(jsonRpcConnection.middleware);
        const workerWrapper = {
            id: workerId,
            streams,
            rpcEngine,
            worker,
        };
        this._setWorker(workerId, workerWrapper);
        await this._command(workerId, {
            jsonrpc: '2.0',
            method: 'ping',
            id: nanoid_1.nanoid(),
        });
        return workerWrapper;
    }
    _initWorkerStreams(worker, workerId) {
        const workerStream = new post_message_stream_1.WorkerParentPostMessageStream({ worker });
        // Typecast justification: stream type mismatch
        const mux = AbstractExecutionService_1.setupMultiplex(workerStream, `Worker:${workerId}`);
        const commandStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.COMMAND);
        const rpcStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.JSON_RPC);
        // Typecast: stream type mismatch
        return {
            command: commandStream,
            rpc: rpcStream,
            _connection: workerStream,
        };
    }
}
exports.WebWorkerExecutionService = WebWorkerExecutionService;
//# sourceMappingURL=WebWorkerExecutionService.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\services\\WebWorkerExecutionService.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\index.js", {"./add-ethereum-chain":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\add-ethereum-chain.js","./eth-accounts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\eth-accounts.js","./get-provider-state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\get-provider-state.js","./log-web3-shim-usage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\log-web3-shim-usage.js","./request-accounts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\request-accounts.js","./send-metadata":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\send-metadata.js","./switch-ethereum-chain":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\switch-ethereum-chain.js","./watch-asset":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\watch-asset.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _addEthereumChain = _interopRequireDefault(require("./add-ethereum-chain"));

var _ethAccounts = _interopRequireDefault(require("./eth-accounts"));

var _getProviderState = _interopRequireDefault(require("./get-provider-state"));

var _logWeb3ShimUsage = _interopRequireDefault(require("./log-web3-shim-usage"));

var _requestAccounts = _interopRequireDefault(require("./request-accounts"));

var _sendMetadata = _interopRequireDefault(require("./send-metadata"));

var _switchEthereumChain = _interopRequireDefault(require("./switch-ethereum-chain"));

var _watchAsset = _interopRequireDefault(require("./watch-asset"));

const handlers = [_addEthereumChain.default, _ethAccounts.default, _getProviderState.default, _logWeb3ShimUsage.default, _requestAccounts.default, _sendMetadata.default, _switchEthereumChain.default, _watchAsset.default];
var _default = handlers;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\index.js", {"./permitted":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\index.js","./restricted":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\index.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectHooks = exports.restrictedMethodPermissionBuilders = exports.permittedMethods = void 0;
var permitted_1 = require("./permitted");
Object.defineProperty(exports, "permittedMethods", { enumerable: true, get: function () { return permitted_1.handlers; } });
var restricted_1 = require("./restricted");
Object.defineProperty(exports, "restrictedMethodPermissionBuilders", { enumerable: true, get: function () { return restricted_1.builders; } });
var utils_1 = require("./utils");
Object.defineProperty(exports, "selectHooks", { enumerable: true, get: function () { return utils_1.selectHooks; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@keystonehq\bc-ur-registry-eth\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq\\bc-ur-registry-eth",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js", {"./base-eth-keyring.cjs.development.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\base-eth-keyring\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq\\base-eth-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\middleware\\pending.js", {"../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\util.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\middleware\pending.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPendingNonceMiddleware = createPendingNonceMiddleware;
exports.createPendingTxMiddleware = createPendingTxMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _util = require("../util");

function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionCount') {
      next();
      return;
    }

    const [param, blockRef] = params;

    if (blockRef !== 'pending') {
      next();
      return;
    }

    res.result = await getPendingNonce(param);
  });
}

function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionByHash') {
      next();
      return;
    }

    const [hash] = params;
    const txMeta = getPendingTransactionByHash(hash);

    if (!txMeta) {
      next();
      return;
    }

    res.result = (0, _util.formatTxMetaForRpcResult)(txMeta);
  });
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\middleware\\pending.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\privateStore.js", {"./keyValueStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\keyValueStore.js","./utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/get":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\get.js","@babel/runtime/helpers/getPrototypeOf":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js","@babel/runtime/helpers/inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\inherits.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/possibleConstructorReturn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\possibleConstructorReturn.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\privateStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get3 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var utils = require('./utils/index');

var ENC_BLOCK_SIZE = 24;

var PrivateStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(PrivateStore, _KeyValueStore);

  function PrivateStore(orbitdb, name, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, PrivateStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PrivateStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this.keyring = _3id.getKeyringBySpaceName(name);
    _this._salt = _this.keyring.getDBSalt();
    return _this;
  }

  (0, _createClass2["default"])(PrivateStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            entry,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "get", this).call(this, this._genDbKey(key), opts);

              case 3:
                entry = _context.sent;

                if (entry) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", _objectSpread({}, entry, {
                  value: this._decryptEntry(entry.value)
                }));

              case 8:
                return _context.abrupt("return", this._decryptEntry(entry));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "getMetadata", this).call(this, this._genDbKey(key)));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                value = this._encryptEntry(value);
                key = this._genDbKey(key);
                return _context3.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "set", this).call(this, key, value));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(keys, values) {
        var dbKeys, encryptedValues;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                utils.throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(this._genDbKey, this);
                encryptedValues = values.map(this._encryptEntry, this);
                return _context4.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "setMultiple", this).call(this, dbKeys, encryptedValues));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(key) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                key = this._genDbKey(key);
                return _context5.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "remove", this).call(this, key));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function remove(_x7) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store. Key is hashed, so key is
     * not available from the private store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: ...., value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "_genDbKey",
    value: function _genDbKey(key) {
      utils.throwIfUndefined(key, 'key');
      return utils.sha256Multihash(this._salt + key);
    }
  }, {
    key: "_encryptEntry",
    value: function _encryptEntry(entry) {
      if (typeof entry === 'undefined') throw new Error('Entry to encrypt cannot be undefined');
      return this.keyring.symEncrypt(this._pad(JSON.stringify(entry)));
    }
  }, {
    key: "_decryptEntry",
    value: function _decryptEntry(_ref) {
      var ciphertext = _ref.ciphertext,
          nonce = _ref.nonce;
      return JSON.parse(this._unpad(this.keyring.symDecrypt(ciphertext, nonce)));
    }
  }, {
    key: "_pad",
    value: function _pad(val) {
      var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
      var blockDiff = (blockSize - val.length % blockSize) % blockSize;
      return "".concat(val).concat('\0'.repeat(blockDiff));
    }
  }, {
    key: "_unpad",
    value: function _unpad(padded) {
      return padded.replace(/\0+$/, '');
    }
  }, {
    key: "log",
    get: function get() {
      var _this2 = this;

      return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "log", this).map(function (obj) {
        return Object.assign(obj, {
          value: obj.value ? _this2._decryptEntry(obj.value) : null
        });
      });
    }
  }]);
  return PrivateStore;
}(KeyValueStore);

module.exports = PrivateStore;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\privateStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\dist\\store.legacy.js", {"../plugins/json2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\json2.js","../src/store-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\store-engine.js","../storages/all":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\all.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\dist\store.legacy.js
      return function (require, module, exports) {
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\dist\\store.legacy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\api.js", {"./config.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js","./utils/id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\id.js","./utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","./utils/verifier":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\verifier.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","graphql-request":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\api.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var graphQLRequest = require('graphql-request').request;

var utils = require('./utils/index');

var verifier = require('./utils/verifier');

var _require = require('./utils/id'),
    isMuportDID = _require.isMuportDID;

var config = require('./config.js');

var GRAPHQL_SERVER_URL = config.graphql_server_url;
var PROFILE_SERVER_URL = config.profile_server_url;
var ADDRESS_SERVER_URL = config.address_server_url;

function getRootStoreAddress(_x) {
  return _getRootStoreAddress.apply(this, arguments);
}

function _getRootStoreAddress() {
  _getRootStoreAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(identifier) {
    var serverUrl,
        res,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            serverUrl = _args.length > 1 && _args[1] !== undefined ? _args[1] : ADDRESS_SERVER_URL;
            _context.next = 3;
            return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);

          case 3:
            res = _context.sent;
            return _context.abrupt("return", res.data.rootStoreAddress);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getRootStoreAddress.apply(this, arguments);
}

function listSpaces(_x2) {
  return _listSpaces.apply(this, arguments);
}

function _listSpaces() {
  _listSpaces = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(address) {
    var serverUrl,
        _args2 = arguments;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            serverUrl = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : PROFILE_SERVER_URL;
            _context2.prev = 1;

            if (!isMuportDID(address)) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return utils.fetchJson(serverUrl + '/list-spaces?did=' + encodeURIComponent(address));

          case 5:
            return _context2.abrupt("return", _context2.sent);

          case 8:
            _context2.next = 10;
            return utils.fetchJson(serverUrl + '/list-spaces?address=' + encodeURIComponent(address));

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](1);
            return _context2.abrupt("return", []);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 13]]);
  }));
  return _listSpaces.apply(this, arguments);
}

function getSpace(_x3, _x4) {
  return _getSpace.apply(this, arguments);
} // TODO consumes address now, could also give root DID to get space DID


function _getSpace() {
  _getSpace = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(address, name) {
    var serverUrl,
        _ref,
        metadata,
        blocklist,
        url,
        _args3 = arguments;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            serverUrl = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : PROFILE_SERVER_URL;
            _ref = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {}, metadata = _ref.metadata, blocklist = _ref.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context3.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/space");
            _context3.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add name:


            url = "".concat(url, "&name=").concat(encodeURIComponent(name)); // Add metadata:

            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context3.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context3.abrupt("return", _context3.sent);

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](5);
            return _context3.abrupt("return", {});

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 14]]);
  }));
  return _getSpace.apply(this, arguments);
}

function getSpaceDID(_x5, _x6) {
  return _getSpaceDID.apply(this, arguments);
}

function _getSpaceDID() {
  _getSpaceDID = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee4(address, space) {
    var opts,
        conf,
        _args4 = arguments;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
            _context4.next = 3;
            return getConfig(address, opts);

          case 3:
            conf = _context4.sent;

            if (!(!conf.spaces[space] || !conf.spaces[space].DID)) {
              _context4.next = 6;
              break;
            }

            throw new Error("Could not find appropriate DID for address ".concat(address));

          case 6:
            return _context4.abrupt("return", conf.spaces[space].DID);

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getSpaceDID.apply(this, arguments);
}

function getThread(_x7, _x8, _x9, _x10) {
  return _getThread.apply(this, arguments);
}

function _getThread() {
  _getThread = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee5(space, name, firstModerator, members) {
    var opts,
        serverUrl,
        url,
        _args5 = arguments;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            opts = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;

            if (!firstModerator.startsWith('0x')) {
              _context5.next = 6;
              break;
            }

            _context5.next = 5;
            return getSpaceDID(firstModerator, space, opts);

          case 5:
            firstModerator = _context5.sent;

          case 6:
            _context5.prev = 6;
            url = "".concat(serverUrl, "/thread?space=").concat(encodeURIComponent(space), "&name=").concat(encodeURIComponent(name));
            url += "&mod=".concat(encodeURIComponent(firstModerator), "&members=").concat(encodeURIComponent(members));
            _context5.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context5.abrupt("return", _context5.sent);

          case 14:
            _context5.prev = 14;
            _context5.t0 = _context5["catch"](6);
            throw new Error(_context5.t0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[6, 14]]);
  }));
  return _getThread.apply(this, arguments);
}

function getThreadByAddress(_x11) {
  return _getThreadByAddress.apply(this, arguments);
}

function _getThreadByAddress() {
  _getThreadByAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(address) {
    var opts,
        serverUrl,
        _args6 = arguments;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context6.prev = 2;
            _context6.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/thread?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](2);
            throw new Error(_context6.t0);

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[2, 8]]);
  }));
  return _getThreadByAddress.apply(this, arguments);
}

function getConfig(_x12) {
  return _getConfig.apply(this, arguments);
}

function _getConfig() {
  _getConfig = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee7(address) {
    var opts,
        serverUrl,
        _args7 = arguments;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context7.prev = 2;
            _context7.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/config?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context7.abrupt("return", _context7.sent);

          case 8:
            _context7.prev = 8;
            _context7.t0 = _context7["catch"](2);
            throw new Error(_context7.t0);

          case 11:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[2, 8]]);
  }));
  return _getConfig.apply(this, arguments);
}

function getProfile(_x13) {
  return _getProfile.apply(this, arguments);
}

function _getProfile() {
  _getProfile = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee8(address) {
    var serverUrl,
        _ref2,
        metadata,
        blocklist,
        url,
        _args8 = arguments;

    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            serverUrl = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : PROFILE_SERVER_URL;
            _ref2 = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {}, metadata = _ref2.metadata, blocklist = _ref2.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context8.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/profile");
            _context8.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add metadata:


            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context8.next = 10;
            return utils.fetchJson(url);

          case 10:
            return _context8.abrupt("return", _context8.sent);

          case 13:
            _context8.prev = 13;
            _context8.t0 = _context8["catch"](5);
            return _context8.abrupt("return", {});

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[5, 13]]);
  }));
  return _getProfile.apply(this, arguments);
}

function getProfiles(_x14) {
  return _getProfiles.apply(this, arguments);
}

function _getProfiles() {
  _getProfiles = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee9(addressArray) {
    var opts,
        req,
        url,
        _args9 = arguments;
    return _regenerator["default"].wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            opts = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
            opts = Object.assign({
              profileServer: PROFILE_SERVER_URL
            }, opts);
            req = {
              addressList: [],
              didList: [] // Split addresses on ethereum / dids

            };
            addressArray.forEach(function (address) {
              if (isMuportDID(address)) {
                req.didList.push(address);
              } else {
                req.addressList.push(address);
              }
            });
            url = "".concat(opts.profileServer, "/profileList");
            return _context9.abrupt("return", utils.fetchJson(url, req));

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _getProfiles.apply(this, arguments);
}

function profileGraphQL(_x15) {
  return _profileGraphQL.apply(this, arguments);
}

function _profileGraphQL() {
  _profileGraphQL = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee10(query) {
    var opts,
        _args10 = arguments;
    return _regenerator["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
            opts = Object.assign({
              graphqlServer: GRAPHQL_SERVER_URL
            }, opts);
            return _context10.abrupt("return", graphQLRequest(opts.graphqlServer, query));

          case 3:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _profileGraphQL.apply(this, arguments);
}

function getVerifiedAccounts(_x16) {
  return _getVerifiedAccounts.apply(this, arguments);
}

function _getVerifiedAccounts() {
  _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee11(profile) {
    var verifs, did;
    return _regenerator["default"].wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            verifs = {};
            _context11.prev = 1;
            _context11.next = 4;
            return verifier.verifyDID(profile.proof_did);

          case 4:
            did = _context11.sent;
            verifs.did = did;

            if (!profile.proof_github) {
              _context11.next = 15;
              break;
            }

            _context11.prev = 7;
            _context11.next = 10;
            return verifier.verifyGithub(did, profile.proof_github);

          case 10:
            verifs.github = _context11.sent;
            _context11.next = 15;
            break;

          case 13:
            _context11.prev = 13;
            _context11.t0 = _context11["catch"](7);

          case 15:
            if (!profile.proof_twitter) {
              _context11.next = 24;
              break;
            }

            _context11.prev = 16;
            _context11.next = 19;
            return verifier.verifyTwitter(did, profile.proof_twitter);

          case 19:
            verifs.twitter = _context11.sent;
            _context11.next = 24;
            break;

          case 22:
            _context11.prev = 22;
            _context11.t1 = _context11["catch"](16);

          case 24:
            if (!profile.ethereum_proof) {
              _context11.next = 33;
              break;
            }

            _context11.prev = 25;
            _context11.next = 28;
            return verifier.verifyEthereum(profile.ethereum_proof, did);

          case 28:
            verifs.ethereum = _context11.sent;
            _context11.next = 33;
            break;

          case 31:
            _context11.prev = 31;
            _context11.t2 = _context11["catch"](25);

          case 33:
            _context11.next = 37;
            break;

          case 35:
            _context11.prev = 35;
            _context11.t3 = _context11["catch"](1);

          case 37:
            return _context11.abrupt("return", verifs);

          case 38:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, null, [[1, 35], [7, 13], [16, 22], [25, 31]]);
  }));
  return _getVerifiedAccounts.apply(this, arguments);
}

module.exports = {
  profileGraphQL: profileGraphQL,
  getProfile: getProfile,
  getSpace: getSpace,
  listSpaces: listSpaces,
  getThread: getThread,
  getThreadByAddress: getThreadByAddress,
  getConfig: getConfig,
  getRootStoreAddress: getRootStoreAddress,
  getProfiles: getProfiles,
  getVerifiedAccounts: getVerifiedAccounts,
  getSpaceDID: getSpaceDID
};
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\api.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\space.js", {"./keyValueStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\keyValueStore.js","./thread":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\thread.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","orbit-db/src/orbit-db-address":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\orbit-db-address.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\space.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var Thread = require('./thread');

var _require = require('./utils'),
    sha256Multihash = _require.sha256Multihash,
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var OrbitDBAddress = require('orbit-db/src/orbit-db-address');

var ENC_BLOCK_SIZE = 24;

var nameToSpaceName = function nameToSpaceName(name) {
  return "3box.space.".concat(name, ".keyvalue");
};

var namesTothreadName = function namesTothreadName(spaceName, threadName) {
  return "3box.thread.".concat(spaceName, ".").concat(threadName);
};

var Space =
/*#__PURE__*/
function () {
  /**
   * Please use **box.openSpace** to get the instance of this class
   */
  function Space(name, threeId, orbitdb, rootStore, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Space);
    this._name = name;
    this._3id = threeId;
    this._ensureConnected = ensureConnected;
    this._store = new KeyValueStore(orbitdb, nameToSpaceName(this._name), this._ensureConnected, this._3id);
    this._orbitdb = orbitdb;
    this._activeThreads = {};
    this._rootStore = rootStore;
    /**
     * @property {KeyValueStore} public         access the profile store of the space
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the space
     */

    this["private"] = null;
  }
  /**
   * @property {String} DID        the did of the user in this space
   */


  (0, _createClass2["default"])(Space, [{
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var _this = this;

        var opts,
            consentNeeded,
            spaceAddress,
            entries,
            entry,
            hasNumEntries,
            numEntries,
            syncSpace,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                if (this._store._db) {
                  _context2.next = 29;
                  break;
                }

                _context2.next = 4;
                return this._3id.initKeyringByName(this._name);

              case 4:
                consentNeeded = _context2.sent;
                if (opts.consentCallback) opts.consentCallback(consentNeeded, this._name);
                _context2.next = 8;
                return this._store._load();

              case 8:
                spaceAddress = _context2.sent;
                _context2.next = 11;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 11:
                entries = _context2.sent;
                entry = entries.find(function (entry) {
                  return entry.payload.value.odbAddress && entry.payload.value.odbAddress.indexOf(nameToSpaceName(_this._name)) !== -1;
                });

                if (entry) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 16;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 16:
                _context2.next = 23;
                break;

              case 18:
                if (entry.payload.value.type) {
                  _context2.next = 23;
                  break;
                }

                _context2.next = 21;
                return this._rootStore.del(entry.hash);

              case 21:
                _context2.next = 23;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 23:
                hasNumEntries = opts.numEntriesMessages && opts.numEntriesMessages[spaceAddress];
                numEntries = hasNumEntries ? opts.numEntriesMessages[spaceAddress].numEntries : undefined;

                syncSpace =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee() {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return _this._store._sync(numEntries);

                          case 2:
                            if (opts.onSyncDone) opts.onSyncDone();

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function syncSpace() {
                    return _ref.apply(this, arguments);
                  };
                }();

                this._syncSpacePromise = syncSpace();
                this["public"] = publicStoreReducer(this._store);
                this["private"] = privateStoreReducer(this._store, this._3id.getKeyringBySpaceName(nameToSpaceName(this._name)));

              case 29:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function open() {
        return _open.apply(this, arguments);
      }

      return open;
    }()
    /**
     * Join a thread. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    name                    The name of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator
     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThread",
    value: function () {
      var _joinThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(name) {
        var opts,
            subscribeFn,
            thread,
            address,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                if (!opts.firstModerator) opts.firstModerator = this._3id.getSubDID(this._name);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, name), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context3.next = 6;
                return thread._getThreadAddress();

              case 6:
                address = _context3.sent;

                if (!this._activeThreads[address]) {
                  _context3.next = 9;
                  break;
                }

                return _context3.abrupt("return", this._activeThreads[address]);

              case 9:
                _context3.next = 11;
                return thread._load();

              case 11:
                this._activeThreads[address] = thread;
                return _context3.abrupt("return", thread);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function joinThread(_x) {
        return _joinThread.apply(this, arguments);
      }

      return joinThread;
    }()
    /**
     * Join a thread by full thread address. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    address                 The full address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThreadByAddress",
    value: function () {
      var _joinThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(address) {
        var opts,
            threadSpace,
            threadName,
            subscribeFn,
            thread,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error('joinThreadByAddress: valid orbitdb address required');

              case 3:
                threadSpace = address.split('.')[2];
                threadName = address.split('.')[3];

                if (!(threadSpace !== this._name)) {
                  _context4.next = 7;
                  break;
                }

                throw new Error('joinThreadByAddress: attempting to open thread from different space, must open within same space');

              case 7:
                if (!this._activeThreads[address]) {
                  _context4.next = 9;
                  break;
                }

                return _context4.abrupt("return", this._activeThreads[address]);

              case 9:
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, threadName), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context4.next = 13;
                return thread._load(address);

              case 13:
                this._activeThreads[address] = thread;
                return _context4.abrupt("return", thread);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function joinThreadByAddress(_x2) {
        return _joinThreadByAddress.apply(this, arguments);
      }

      return joinThreadByAddress;
    }()
    /**
     * Subscribe to the given thread, if not already subscribed
     *
     * @param     {String}    address                The address of the thread
     * @param     {Object}    config                configuration and thread meta data
     * @param     {String}    opts.name             Name of thread
     * @param     {String}    opts.firstModerator   DID of the first moderator
     * @param     {String}    opts.members          Boolean string, true if a members only thread
     */

  }, {
    key: "subscribeThread",
    value: function () {
      var _subscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(address) {
        var config,
            threadKey,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                config = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('subscribeThread: must subscribe to valid thread/orbitdb address');

              case 3:
                threadKey = "thread-".concat(address);
                _context5.next = 6;
                return this._syncSpacePromise;

              case 6:
                _context5.next = 8;
                return this["public"].get(threadKey);

              case 8:
                if (_context5.sent) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this["public"].set(threadKey, Object.assign({}, config, {
                  address: address
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function subscribeThread(_x3) {
        return _subscribeThread.apply(this, arguments);
      }

      return subscribeThread;
    }()
    /**
     * Unsubscribe from the given thread, if subscribed
     *
     * @param     {String}    address     The address of the thread
     */

  }, {
    key: "unsubscribeThread",
    value: function () {
      var _unsubscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(address) {
        var threadKey;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                threadKey = "thread-".concat(address);
                _context6.next = 3;
                return this["public"].get(threadKey);

              case 3:
                if (!_context6.sent) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 6;
                return this["public"].remove(threadKey);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function unsubscribeThread(_x4) {
        return _unsubscribeThread.apply(this, arguments);
      }

      return unsubscribeThread;
    }()
    /**
     * Get a list of all the threads subscribed to in this space
     *
     * @return    {Array<Objects>}    A list of thread objects as { address, firstModerator, members, name}
     */

  }, {
    key: "subscribedThreads",
    value: function () {
      var _subscribedThreads = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7() {
        var allEntries;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this["public"].all();

              case 2:
                allEntries = _context7.sent;
                return _context7.abrupt("return", Object.keys(allEntries).reduce(function (threads, key) {
                  if (key.startsWith('thread')) {
                    // ignores experimental threads (v1)
                    var address = key.split('thread-')[1];

                    if (OrbitDBAddress.isValid(address)) {
                      threads.push(allEntries[key]);
                    }
                  }

                  return threads;
                }, []));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function subscribedThreads() {
        return _subscribedThreads.apply(this, arguments);
      }

      return subscribedThreads;
    }()
  }, {
    key: "DID",
    get: function get() {
      return this._3id.getSubDID(this._name);
    }
  }]);
  return Space;
}();

module.exports = Space;

var publicStoreReducer = function publicStoreReducer(store) {
  var PREFIX = 'pub_';
  return {
    get: function () {
      var _get = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(key) {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                return _context8.abrupt("return", store.get(PREFIX + key, opts));

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function get(_x5) {
        return _get.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(key) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", store.getMetadata(PREFIX + key));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function getMetadata(_x6) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(key, value) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context10.abrupt("return", store.set(PREFIX + key, value));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      function set(_x7, _x8) {
        return _set.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(keys, values) {
        var prefixedKeys;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                prefixedKeys = keys.map(function (key) {
                  return PREFIX + key;
                });
                return _context11.abrupt("return", store.setMultiple(prefixedKeys, values));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      function setMultiple(_x9, _x10) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(key) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context12.abrupt("return", store.remove(PREFIX + key));

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }));

      function remove(_x11) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          entry.key = entry.key.slice(4);
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(opts) {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return store.all(opts);

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    newAll[key.slice(4)] = entries[key];
                  }

                  return newAll;
                }, {}));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));

      function all(_x12) {
        return _all.apply(this, arguments);
      }

      return all;
    }()
  };
};

var privateStoreReducer = function privateStoreReducer(store, keyring) {
  var PREFIX = 'priv_';
  var SALT = keyring.getDBSalt();

  var dbKey = function dbKey(key) {
    throwIfUndefined(key, 'key');
    return PREFIX + sha256Multihash(SALT + key);
  };

  var pad = function pad(val) {
    var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
    var blockDiff = (blockSize - val.length % blockSize) % blockSize;
    return "".concat(val).concat('\0'.repeat(blockDiff));
  };

  var unpad = function unpad(padded) {
    return padded.replace(/\0+$/, '');
  };

  var encryptEntry = function encryptEntry(entry) {
    return keyring.symEncrypt(pad(JSON.stringify(entry)));
  };

  var decryptEntry = function decryptEntry(_ref2) {
    var ciphertext = _ref2.ciphertext,
        nonce = _ref2.nonce;
    return JSON.parse(unpad(keyring.symDecrypt(ciphertext, nonce)));
  };

  return {
    get: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14(key) {
        var opts,
            entry,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                _context14.next = 3;
                return store.get(dbKey(key), opts);

              case 3:
                entry = _context14.sent;

                if (entry) {
                  _context14.next = 6;
                  break;
                }

                return _context14.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context14.next = 8;
                  break;
                }

                return _context14.abrupt("return", _objectSpread({}, entry, {
                  value: decryptEntry(entry.value).value
                }));

              case 8:
                return _context14.abrupt("return", decryptEntry(entry).value);

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14);
      }));

      function get(_x13) {
        return _get2.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(key) {
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", store.getMetadata(dbKey(key)));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      function getMetadata(_x14) {
        return _getMetadata2.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(key, value) {
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", store.set(dbKey(key), encryptEntry({
                  key: key,
                  value: value
                })));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function set(_x15, _x16) {
        return _set2.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(keys, values) {
        var dbKeys, encryptedEntries;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(dbKey);
                encryptedEntries = values.map(function (value, index) {
                  return encryptEntry({
                    key: keys[index],
                    value: value
                  });
                });
                return _context17.abrupt("return", store.setMultiple(dbKeys, encryptedEntries));

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function setMultiple(_x17, _x18) {
        return _setMultiple2.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(key) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", store.remove(dbKey(key)));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function remove(_x19) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          var decEntry = decryptEntry(entry.value);
          entry.key = decEntry.key;
          entry.value = decEntry.value;
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var opts,
            entries,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                opts = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : {};
                _context19.next = 3;
                return store.all(opts);

              case 3:
                entries = _context19.sent;
                return _context19.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    var entry = entries[key];

                    if (opts.metadata) {
                      var decEntry = decryptEntry(entry.value);
                      newAll[decEntry.key] = _objectSpread({}, entry, {
                        value: decEntry.value
                      });
                    } else {
                      var _decEntry = decryptEntry(entry);

                      newAll[_decEntry.key] = _decEntry.value;
                    }
                  }

                  return newAll;
                }, {}));

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      function all() {
        return _all2.apply(this, arguments);
      }

      return all;
    }()
  };
};
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\space.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js","js-sha256":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha256\\src\\sha256.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js","node-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\utils\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fetch = typeof window !== 'undefined' ? window.fetch : require('node-fetch');

var Multihash = require('multihashes');

var sha256 = require('js-sha256').sha256;

var ethers = require('ethers');

var HTTPError = function HTTPError(status, message) {
  var e = new Error(message);
  e.statusCode = status;
  return e;
};

var getMessageConsent = function getMessageConsent(did, timestamp) {
  var msg = 'Create a new 3Box profile' + '\n\n' + '- \n' + 'Your unique profile ID is ' + did;
  if (timestamp) msg += ' \n' + 'Timestamp: ' + timestamp;
  return msg;
};

var safeEthSend = function safeEthSend(ethereum, data, callback) {
  var send = (Boolean(ethereum.sendAsync) ? ethereum.sendAsync : ethereum.send).bind(ethereum);
  return new Promise(function (resolve, reject) {
    send(data, function (err, result) {
      if (err) reject(err);
      if (result.error) reject(result.error);
      resolve(result.result);
    });
  });
};

module.exports = {
  getMessageConsent: getMessageConsent,
  recoverPersonalSign: function () {
    var _recoverPersonalSign = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(msg, personalSig) {
      var msgParams;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!msg || !personalSig)) {
                _context.next = 2;
                break;
              }

              throw new Error('recoverPersonalSign: missing arguments, msg and/or personalSig');

            case 2:
              msgParams = {
                data: msg,
                sig: personalSig
              };
              return _context.abrupt("return", ethers.utils.verifyMessage(msg, personalSig));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function recoverPersonalSign(_x, _x2) {
      return _recoverPersonalSign.apply(this, arguments);
    }

    return recoverPersonalSign;
  }(),
  openBoxConsent: function openBoxConsent(fromAddress, ethereum) {
    var text = 'This app wants to view and update your 3Box profile.';
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  openSpaceConsent: function openSpaceConsent(fromAddress, ethereum, name) {
    var text = "Allow this app to open your ".concat(name, " space.");
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  getLinkConsent: function () {
    var _getLinkConsent = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(fromAddress, toDID, ethereum) {
      var timestamp, text, msg, params, method, sig;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              timestamp = Math.floor(new Date().getTime() / 1000);
              text = getMessageConsent(toDID, timestamp);
              msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
              params = [msg, fromAddress];
              method = 'personal_sign';
              _context2.next = 7;
              return safeEthSend(ethereum, {
                jsonrpc: '2.0',
                id: 0,
                method: method,
                params: params,
                fromAddress: fromAddress
              });

            case 7:
              sig = _context2.sent;
              return _context2.abrupt("return", {
                msg: text,
                sig: sig,
                timestamp: timestamp
              });

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function getLinkConsent(_x3, _x4, _x5) {
      return _getLinkConsent.apply(this, arguments);
    }

    return getLinkConsent;
  }(),
  fetchJson: function () {
    var _fetchJson = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(url, body) {
      var opts, r;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (body) {
                opts = {
                  body: JSON.stringify(body),
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                };
              }

              _context3.next = 3;
              return fetch(url, opts);

            case 3:
              r = _context3.sent;

              if (!r.ok) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", r.json());

            case 8:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function fetchJson(_x6, _x7) {
      return _fetchJson.apply(this, arguments);
    }

    return fetchJson;
  }(),
  fetchText: function () {
    var _fetchText = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(url, opts) {
      var r;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return fetch(url, opts);

            case 2:
              r = _context4.sent;

              if (!r.ok) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", r.text());

            case 7:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function fetchText(_x8, _x9) {
      return _fetchText.apply(this, arguments);
    }

    return fetchText;
  }(),
  throwIfUndefined: function throwIfUndefined(arg, name) {
    if (arg === undefined || arg === null) {
      throw new Error("".concat(name, " is a required argument"));
    }
  },
  throwIfNotEqualLenArrays: function throwIfNotEqualLenArrays(arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
      throw new Error('One or more arguments are not an array');
    }

    if (arr1.length !== arr2.length) {
      throw new Error('Arrays must be of the same length');
    }
  },
  sha256Multihash: function sha256Multihash(str) {
    var digest = Buffer.from(sha256.digest(str));
    return Multihash.encode(digest, 'sha2-256').toString('hex');
  },
  sha256: sha256
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\index.js", {"./src/ipfs-pubsub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\src\\ipfs-pubsub.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-pubsub\index.js
      return function (require, module, exports) {
module.exports = require('./src/ipfs-pubsub')

      };
    };
  }
}, {package:"orbit-db-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","ipfs-log":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\config.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var Log = require('ipfs-log');

var IFRAME_STORE_VERSION = '0.0.3';
module.exports = {
  address_server_url: process.env.ADDRESS_SERVER_URL || 'https://beta.3box.io/address-server',
  pinning_node: process.env.PINNING_NODE || '/dnsaddr/ipfs.3box.io/tcp/443/wss/ipfs/QmZvxEpiVNjmNbEKyQGvFzAY1BwmGuuvdUTmcTstQPhyVC',
  pinning_room: process.env.PINNING_ROOM || '3box-pinning',
  iframe_store_version: process.env.IFRAME_STORE_VERSION || IFRAME_STORE_VERSION,
  iframe_store_url: process.env.IFRAME_STORE_URL || "https://iframe.3box.io/".concat(IFRAME_STORE_VERSION, "/iframe.html"),
  ipfs_options: {
    EXPERIMENTAL: {
      pubsub: true
    },
    preload: {
      enabled: false
    },
    config: {
      Bootstrap: []
    }
  },
  orbitdb_options: {
    syncLocal: true,
    sortFn: Log.Sorting.SortByEntryHash // this option is required now but will likely not be in the future.

  },
  graphql_server_url: process.env.GRAPHQL_SERVER_URL || 'https://api.3box.io/graph/',
  profile_server_url: process.env.PROFILE_SERVER_URL || 'https://ipfs.3box.io',
  muport_ipfs_host: process.env.MUPORT_IPFS_HOST || 'ipfs.infura.io',
  muport_ipfs_port: process.env.MUPORT_IPFS_PORT || 5001,
  muport_ipfs_protocol: process.env.MUPORT_IPFS_PROTOCOL || 'https'
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\index.js", {"../config.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js","../utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","./keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\keyring.js","3box-orbitdb-plugins":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\index.js","3id-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3id-resolver\\lib\\register.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js","ipfs-did-document":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-did-document\\index.js","ipfs-mini":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\index.js","orbit-db-identity-provider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\index.js","store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\dist\\store.legacy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\3id\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var didJWT = require('did-jwt');

var DidDocument = require('ipfs-did-document');

var IpfsMini = require('ipfs-mini');

var localstorage = require('store');

var Identities = require('orbit-db-identity-provider');

var _require = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require.OdbIdentityProvider;

Identities.addIdentityProvider(OdbIdentityProvider);

var registerResolver = require('3id-resolver');

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var DID_METHOD_NAME = '3';
var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};

var ThreeId =
/*#__PURE__*/
function () {
  function ThreeId(serializeState, ethereum, ipfs, opts) {
    (0, _classCallCheck2["default"])(this, ThreeId);
    this._ethereum = ethereum;
    this._ipfs = ipfs;
    this._keyrings = {};

    this._initKeys(serializeState, opts);

    registerResolver(ipfs);
    localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
  }

  (0, _createClass2["default"])(ThreeId, [{
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(payload) {
        var _ref,
            use3ID,
            space,
            expiresIn,
            keyring,
            issuer,
            settings,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, use3ID = _ref.use3ID, space = _ref.space, expiresIn = _ref.expiresIn;
                keyring = space ? this._keyrings[space] : this._mainKeyring;
                issuer = this.muportDID;

                if (use3ID) {
                  issuer = this.DID;
                } else if (space) {
                  issuer = this._subDIDs[space];
                }

                settings = {
                  signer: keyring.getJWTSigner(),
                  issuer: issuer,
                  expiresIn: expiresIn
                };
                return _context.abrupt("return", didJWT.createJWT(payload, settings));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signJWT(_x) {
        return _signJWT.apply(this, arguments);
      }

      return signJWT;
    }()
  }, {
    key: "getSubDID",
    value: function getSubDID(space) {
      return this._subDIDs[space];
    }
  }, {
    key: "getOdbId",
    value: function () {
      var _getOdbId = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(space) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Identities.createIdentity({
                  type: '3ID',
                  threeId: this,
                  space: space
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getOdbId(_x2) {
        return _getOdbId.apply(this, arguments);
      }

      return getOdbId;
    }()
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this = this;

      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_initKeys",
    value: function _initKeys(serializeState) {
      var _this2 = this;

      var state = JSON.parse(serializeState); // TODO remove toLowerCase() in future, should be sanitized elsewhere
      //      this forces existing state to correct state so that address <->
      //      rootstore relation holds

      this.managementAddress = state.managementAddress.toLowerCase();
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this2._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
    }
  }, {
    key: "_initDID",
    value: function () {
      var _initDID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(muportIpfs) {
        var _this3 = this;

        var muportPromise, spaces, subDIDs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                muportPromise = this._initMuport(muportIpfs);
                _context3.next = 3;
                return this._init3ID();

              case 3:
                this._rootDID = _context3.sent;
                spaces = Object.keys(this._keyrings);
                _context3.next = 7;
                return Promise.all(spaces.map(function (space) {
                  return _this3._init3ID(space);
                }));

              case 7:
                subDIDs = _context3.sent;
                this._subDIDs = {};
                spaces.map(function (space, i) {
                  _this3._subDIDs[space] = subDIDs[i];
                });
                _context3.next = 12;
                return muportPromise;

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _initDID(_x3) {
        return _initDID2.apply(this, arguments);
      }

      return _initDID;
    }()
  }, {
    key: "_init3ID",
    value: function () {
      var _init3ID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(spaceName) {
        var doc, pubkeys, _pubkeys, payload, signature;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);

                if (spaceName) {
                  _context4.next = 9;
                  break;
                }

                pubkeys = this._mainKeyring.getPublicKeys(true);
                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', this.managementAddress);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
                _context4.next = 20;
                break;

              case 9:
                _pubkeys = this._keyrings[spaceName].getPublicKeys(true);
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', _pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', _pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', spaceName);
                doc.addCustomProperty('root', this.DID);
                payload = {
                  subSigningKey: _pubkeys.signingKey,
                  subEncryptionKey: _pubkeys.asymEncryptionKey,
                  space: spaceName,
                  iat: null
                };
                _context4.next = 18;
                return this.signJWT(payload, {
                  use3ID: true
                });

              case 18:
                signature = _context4.sent.split('.')[2];
                doc.addCustomProperty('proof', {
                  alg: 'ES256K',
                  signature: signature
                });

              case 20:
                _context4.next = 22;
                return doc.commit({
                  noTimestamp: true
                });

              case 22:
                return _context4.abrupt("return", doc.DID);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _init3ID(_x4) {
        return _init3ID2.apply(this, arguments);
      }

      return _init3ID;
    }()
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(muportIpfs) {
        var keys, doc, docHash, publishToInfura;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                keys = this._mainKeyring.getPublicKeys();
                doc = createMuportDocument(keys.signingKey, this.managementAddress, keys.asymEncryptionKey);
                _context6.next = 4;
                return this._ipfs.add(Buffer.from(JSON.stringify(doc)));

              case 4:
                docHash = _context6.sent[0].hash;
                this._muportDID = 'did:muport:' + docHash;
                this.muportFingerprint = utils.sha256Multihash(this.muportDID);

                publishToInfura =
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee5() {
                    var ipfsMini;
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            ipfsMini = new IpfsMini(muportIpfs);
                            ipfsMini.addJSON(doc, function (err, res) {
                              if (err) console.error(err);
                            });

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function publishToInfura() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                publishToInfura();

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _initMuport(_x5) {
        return _initMuport2.apply(this, arguments);
      }

      return _initMuport;
    }()
  }, {
    key: "getKeyringBySpaceName",
    value: function getKeyringBySpaceName(name) {
      var split = name.split('.');

      if (split[0] === this.muportFingerprint) {
        return this._mainKeyring;
      } else {
        return this._keyrings[split[2]];
      }
    }
  }, {
    key: "initKeyringByName",
    value: function () {
      var _initKeyringByName = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(name) {
        var sig, entropy, seed;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._keyrings[name]) {
                  _context7.next = 14;
                  break;
                }

                _context7.next = 3;
                return utils.openSpaceConsent(this.managementAddress, this._ethereum, name);

              case 3:
                sig = _context7.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = HDNode.mnemonicToSeed(HDNode.entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                _context7.next = 9;
                return this._init3ID(name);

              case 9:
                this._subDIDs[name] = _context7.sent;
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context7.abrupt("return", true);

              case 14:
                return _context7.abrupt("return", false);

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initKeyringByName(_x6) {
        return _initKeyringByName.apply(this, arguments);
      }

      return initKeyringByName;
    }()
  }, {
    key: "logout",
    value: function logout() {
      localstorage.remove(STORAGE_KEY + this.managementAddress);
    }
  }, {
    key: "DID",
    get: function get() {
      return this._rootDID;
    }
  }, {
    key: "muportDID",
    get: function get() {
      return this._muportDID;
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(address, ethereum, ipfs) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            _3id,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context8.next = 7;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context8.next = 19;
                break;

              case 7:
                if (!opts.contentSignature) {
                  _context8.next = 11;
                  break;
                }

                sig = opts.contentSignature;
                _context8.next = 14;
                break;

              case 11:
                _context8.next = 13;
                return utils.openBoxConsent(normalizedAddress, ethereum);

              case 13:
                sig = _context8.sent;

              case 14:
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                seed = HDNode.mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: normalizedAddress,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 19:
                _3id = new ThreeId(serialized3id, ethereum, ipfs, opts);
                _context8.next = 22;
                return _3id._initDID(opts.muportIpfs || MUPORT_IPFS);

              case 22:
                return _context8.abrupt("return", _3id);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function getIdFromEthAddress(_x7, _x8, _x9) {
        return _getIdFromEthAddress.apply(this, arguments);
      }

      return getIdFromEthAddress;
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\verified.js", {"./utils/verifier":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\verifier.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\verified.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var verifier = require('./utils/verifier');

var Verified =
/*#__PURE__*/
function () {
  /**
   * Please use **box.verified** to get the instance of this class
   */
  function Verified(box) {
    (0, _classCallCheck2["default"])(this, Verified);
    this._box = box;
    this._did = box._3id.muportDID;
  }

  (0, _createClass2["default"])(Verified, [{
    key: "_addVerifiedPublicAccount",
    value: function () {
      var _addVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context.sent;
                _context.next = 5;
                return this._box["public"].set('proof_' + key, proof);

              case 5:
                return _context.abrupt("return", account);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _addVerifiedPublicAccount(_x, _x2, _x3) {
        return _addVerifiedPublicAccount2.apply(this, arguments);
      }

      return _addVerifiedPublicAccount;
    }()
  }, {
    key: "_getVerifiedPublicAccount",
    value: function () {
      var _getVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._box["public"].get('proof_' + key);

              case 2:
                proof = _context2.sent;
                return _context2.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getVerifiedPublicAccount(_x4, _x5) {
        return _getVerifiedPublicAccount2.apply(this, arguments);
      }

      return _getVerifiedPublicAccount;
    }()
  }, {
    key: "_addVerifiedPrivateAccount",
    value: function () {
      var _addVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context3.sent;
                _context3.next = 5;
                return this._box["private"].set('proof_' + key, proof);

              case 5:
                return _context3.abrupt("return", account);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _addVerifiedPrivateAccount(_x6, _x7, _x8) {
        return _addVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _addVerifiedPrivateAccount;
    }()
  }, {
    key: "_getVerifiedPrivateAccount",
    value: function () {
      var _getVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._box["private"].get('proof_' + key);

              case 2:
                proof = _context4.sent;
                return _context4.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getVerifiedPrivateAccount(_x9, _x10) {
        return _getVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _getVerifiedPrivateAccount;
    }()
    /**
     * Returns the verified DID of the user
     *
     * @return    {String}                            The DID of the user
     */

  }, {
    key: "DID",
    value: function () {
      var _DID = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this._did);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function DID() {
        return _DID.apply(this, arguments);
      }

      return DID;
    }()
    /**
     * Verifies that the user has a valid github account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "github",
    value: function () {
      var _github = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this._getVerifiedPublicAccount('github', verifier.verifyGithub));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function github() {
        return _github.apply(this, arguments);
      }

      return github;
    }()
    /**
     * Adds a github verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {Object}            gistUrl         URL of the proof
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "addGithub",
    value: function () {
      var _addGithub = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(gistUrl) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this._addVerifiedPublicAccount('github', gistUrl, verifier.verifyGithub));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addGithub(_x11) {
        return _addGithub.apply(this, arguments);
      }

      return addGithub;
    }()
    /**
     * Verifies that the user has a valid twitter account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "twitter",
    value: function () {
      var _twitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this._getVerifiedPublicAccount('twitter', verifier.verifyTwitter));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function twitter() {
        return _twitter.apply(this, arguments);
      }

      return twitter;
    }()
    /**
     * Adds a twitter verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of a twitter username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addTwitter",
    value: function () {
      var _addTwitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(claim) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this._addVerifiedPublicAccount('twitter', claim, verifier.verifyTwitter));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function addTwitter(_x12) {
        return _addTwitter.apply(this, arguments);
      }

      return addTwitter;
    }()
    /**
    * Verifies that the user has a verified email account
    * Throws an error otherwise.
    *
    * @return    {Object}                            Object containing username, proof, and the verifier
    */

  }, {
    key: "email",
    value: function () {
      var _email = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this._getVerifiedPrivateAccount('email', verifier.verifyEmail));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function email() {
        return _email.apply(this, arguments);
      }

      return email;
    }()
    /**
     * Adds an email verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of an email username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addEmail",
    value: function () {
      var _addEmail = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(claim) {
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this._addVerifiedPrivateAccount('email', claim, verifier.verifyEmail));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function addEmail(_x13) {
        return _addEmail.apply(this, arguments);
      }

      return addEmail;
    }()
  }]);
  return Verified;
}();

module.exports = Verified;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\verified.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\id.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\utils\id.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * A module to verify & validate claims
 *
 * @name idUtils
 * @memberof Box
 */
var didJWT = require('did-jwt');

var DID_MUPORT_PREFIX = 'did:muport:';
module.exports = {
  /**
   * Check whether a string is a muport did or not
   *
   * @memberOf Box.idUtils
   * @param   {String}     address  A string containing a user profile address
   * @return  {*|boolean}           Whether the address is a muport did or not
   */
  isMuportDID: function isMuportDID(address) {
    return address.startsWith(DID_MUPORT_PREFIX);
  },

  /**
   * Check whether a string is a valid claim or not
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the audience of the JWT
   * @return {Promise<boolean>}                   whether the parameter is an actual claim
   */
  isClaim: function () {
    var _isClaim = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(claim) {
      var opts,
          _args = arguments;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.prev = 1;
              _context.next = 4;
              return didJWT.decodeJWT(claim, opts);

            case 4:
              return _context.abrupt("return", true);

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              return _context.abrupt("return", false);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 7]]);
    }));

    function isClaim(_x) {
      return _isClaim.apply(this, arguments);
    }

    return isClaim;
  }(),

  /**
   * Verify a claim and return its content.
   * See https://github.com/uport-project/did-jwt/ for more details.
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the JWT's audience
   * @return {Object}                             The validated claim
   */
  verifyClaim: didJWT.verifyJWT
};
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\id.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\index.js", {"./src/access-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controllers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\index.js
      return function (require, module, exports) {
const AccessControllers = require('./src/access-controllers')
module.exports = AccessControllers

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\publicStore.js", {"./keyValueStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\keyValueStore.js","./utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/get":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\get.js","@babel/runtime/helpers/getPrototypeOf":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js","@babel/runtime/helpers/inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\inherits.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/possibleConstructorReturn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\possibleConstructorReturn.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\publicStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var KeyValueStore = require('./keyValueStore');

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var ProfileStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(ProfileStore, _KeyValueStore);

  function ProfileStore(orbitdb, name, linkProfile, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, ProfileStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ProfileStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this._linkProfile = linkProfile;
    return _this;
  }

  (0, _createClass2["default"])(ProfileStore, [{
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, value) {
        var opts,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                throwIfUndefined(key, 'key'); // if this is the noLink call we shouldn't call _linkProfile.

                if (opts.noLink) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return this._linkProfile();

              case 5:
                return _context.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "set", this).call(this, key, value));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function set(_x, _x2) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(keys, values) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                _context2.next = 3;
                return this._linkProfile();

              case 3:
                return _context2.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "setMultiple", this).call(this, keys, values));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setMultiple(_x3, _x4) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }]);
  return ProfileStore;
}(KeyValueStore);

module.exports = ProfileStore;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\publicStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\index.js", {"./legacyIpfs3boxAccessController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\legacyIpfs3boxAccessController.js","./moderatorAccessController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\moderatorAccessController.js","./odbIdentityProvider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\odbIdentityProvider.js","./threadAccessController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\threadAccessController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box-orbitdb-plugins\src\index.js
      return function (require, module, exports) {
const OdbIdentityProvider = require('./odbIdentityProvider')
const ModeratorAccessController = require('./moderatorAccessController')
const ThreadAccessController = require('./threadAccessController')
const LegacyIPFS3BoxAccessController = require('./legacyIpfs3boxAccessController')

module.exports = { OdbIdentityProvider, ModeratorAccessController, ThreadAccessController, LegacyIPFS3BoxAccessController  }

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\OrbitDB.js", {"./db-manifest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\db-manifest.js","./exchange-heads":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\exchange-heads.js","./orbit-db-address":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\orbit-db-address.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\index.js","logplease":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js","orbit-db-access-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\index.js","orbit-db-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\index-browser.js","orbit-db-counterstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterStore.js","orbit-db-docstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentStore.js","orbit-db-eventstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventStore.js","orbit-db-feedstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedStore.js","orbit-db-identity-provider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\index.js","orbit-db-keystore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\index-browser.js","orbit-db-kvstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueStore.js","orbit-db-pubsub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\index.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\OrbitDB.js
      return function (require, module, exports) {
'use strict'

const path = require('path')
const EventStore = require('orbit-db-eventstore')
const FeedStore = require('orbit-db-feedstore')
const KeyValueStore = require('orbit-db-kvstore')
const CounterStore = require('orbit-db-counterstore')
const DocumentStore = require('orbit-db-docstore')
const Pubsub = require('orbit-db-pubsub')
const Cache = require('orbit-db-cache')
const Keystore = require('orbit-db-keystore')
const Identities = require('orbit-db-identity-provider')
let AccessControllers = require('orbit-db-access-controllers')
const OrbitDBAddress = require('./orbit-db-address')
const createDBManifest = require('./db-manifest')
const exchangeHeads = require('./exchange-heads')
const { isDefined, io } = require('./utils')

const Logger = require('logplease')
const logger = Logger.create("orbit-db")
Logger.setLogLevel('ERROR')

// Mapping for 'database type' -> Class
let databaseTypes = {
  'counter': CounterStore,
  'eventlog': EventStore,
  'feed': FeedStore,
  'docstore': DocumentStore,
  'keyvalue': KeyValueStore,
}

  class OrbitDB {
  constructor(ipfs, identity, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    if (!isDefined(identity))
      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    this._ipfs = ipfs
    this.identity = identity
    this.id = options.peerId
    this._pubsub = options && options.broker
      ? new options.broker(this._ipfs)
      : new Pubsub(this._ipfs, this.id)
    this.directory = options.directory || './orbitdb'
    this.keystore = options.keystore
    this.cache = options.cache || Cache
    this.stores = {}
    this._directConnections = {}
    // AccessControllers module can be passed in to enable
    // testing with orbit-db-access-controller
    AccessControllers = options.AccessControllers || AccessControllers
  }

  static async createInstance (ipfs, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    const { id } = await ipfs.id()
    const directory = options.directory || './orbitdb'
    const keystore = options.keystore || Keystore.create(path.join(directory, id, '/keystore'))

    const identity = options.identity || await Identities.createIdentity({
      id: options.id || id,
      keystore: keystore,
    })
    options = Object.assign({}, options, {
      peerId: id ,
      directory: directory,
      keystore: keystore
    })
    const orbitdb = new OrbitDB(ipfs, identity, options)
    return orbitdb
  }

  /* Databases */
  async feed (address, options = {}) {
    options = Object.assign({ create: true, type: 'feed' }, options)
    return this.open(address, options)
  }

  async log (address, options = {}) {
    options = Object.assign({ create: true, type: 'eventlog' }, options)
    return this.open(address, options)
  }

  async eventlog (address, options = {}) {
    return this.log(address, options)
  }

  async keyvalue (address, options = {}) {
    options = Object.assign({ create: true, type: 'keyvalue' }, options)
    return this.open(address, options)
  }

  async kvstore (address, options = {}) {
    return this.keyvalue(address, options)
  }

  async counter (address, options = {}) {
    options = Object.assign({ create: true, type: 'counter' }, options)
    return this.open(address, options)
  }

  async docs (address, options = {}) {
    options = Object.assign({ create: true, type: 'docstore' }, options)
    return this.open(address, options)
  }

  async docstore (address, options = {}) {
    return this.docs(address, options)
  }

  async disconnect () {
    //close Keystore
    if (this.keystore.close)
      await this.keystore.close()

    // Close all open databases
    const databases = Object.values(this.stores)
    for (let db of databases) {
      await db.close()
      delete this.stores[db.address.toString()]
    }

    // Close a direct connection and remove it from internal state
    const removeDirectConnect = e => {
      this._directConnections[e].close()
      delete this._directConnections[e]
    }

    // Close all direct connections to peers
    Object.keys(this._directConnections).forEach(removeDirectConnect)

    // Disconnect from pubsub
    if (this._pubsub) {
      await this._pubsub.disconnect()
    }

    // Remove all databases from the state
    this.stores = {}
  }

  // Alias for disconnect()
  async stop () {
    await this.disconnect()
  }

  /* Private methods */
  async _createStore (type, address, options) {
    // Get the type -> class mapping
    const Store = databaseTypes[type]

    if (!Store)
      throw new Error(`Invalid database type '${type}'`)

    let accessController
    if (options.accessControllerAddress) {
      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)
    }

    const cache = await this._loadCache(this.directory, address)

    const opts = Object.assign({ replicate: true }, options, {
      accessController: accessController,
      keystore: this.keystore,
      cache: cache,
      onClose: this._onClose.bind(this),
    })
    const identity = options.identity || this.identity

    const store = new Store(this._ipfs, identity, address, opts)
    store.events.on('write', this._onWrite.bind(this))
    // ID of the store is the address as a string
    const addr = address.toString()
    this.stores[addr] = store

    // Subscribe to pubsub to get updates from peers,
    // this is what hooks us into the message propagation layer
    // and the p2p network
    if(opts.replicate && this._pubsub)
      this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this))

    return store
  }

  // Callback for local writes to the database. We the update to pubsub.
  _onWrite (address, entry, heads) {
    if(!heads) throw new Error("'heads' not defined")
    if(this._pubsub) this._pubsub.publish(address, heads)
  }

  // Callback for receiving a message from the network
  async _onMessage (address, heads) {
    const store = this.stores[address]
    try {
      logger.debug(`Received ${heads.length} heads for '${address}':\n`, JSON.stringify(heads.map(e => e.hash), null, 2))
      if (store && heads && heads.length > 0) {
        await store.sync(heads)
      }
    } catch (e) {
      logger.error(e)
    }
  }

  // Callback for when a peer connected to a database
  async _onPeerConnected (address, peer) {
    logger.debug(`New peer '${peer}' connected to '${address}'`)

    const getStore = address => this.stores[address]
    const getDirectConnection = peer => this._directConnections[peer]
    const onChannelCreated = channel => this._directConnections[channel._receiverID] = channel
    const onMessage = (address, heads) => this._onMessage(address, heads)

    const channel = await exchangeHeads(
      this._ipfs,
      address,
      peer,
      getStore,
      getDirectConnection,
      onMessage,
      onChannelCreated
    )

    if (getStore(address))
      getStore(address).events.emit('peer', peer)
  }

  // Callback when database was closed
  async _onClose (address) {
    logger.debug(`Close ${address}`)

    // Unsubscribe from pubsub
    if (this._pubsub) {
      await this._pubsub.unsubscribe(address)
    }

    delete this.stores[address]
  }

  async _determineAddress(name, type, options = {}) {
    if (!OrbitDB.isValidType(type))
      throw new Error(`Invalid database type '${type}'`)

    if (OrbitDBAddress.isValid(name))
      throw new Error(`Given database name is an address. Please give only the name of the database!`)

    // Create an AccessController, use IPFS AC as the default
    options.accessController = Object.assign({}, { name: name , type: 'ipfs' }, options.accessController)
    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController  || {})

    // Save the manifest to IPFS
    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)

    // Create the database address
    return OrbitDBAddress.parse(path.join('/orbitdb', manifestHash, name))
  }

  /* Create and Open databases */

  /*
    options = {
      accessController: { write: [] } // array of keys that can write to this database
      directory: './orbitdb', // directory in which to place the database files
      overwrite: false, // whether we should overwrite the existing database if it exists
    }
  */
  async create (name, type, options = {}) {
    logger.debug(`create()`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Creating database '${name}' as ${type} in '${directory}'`)

    // Create the database address
    const dbAddress = await this._determineAddress(name, type, options)

    // Load the locally saved database information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database locally
    const haveDB = await this._haveLocalData(cache, dbAddress)

    if (haveDB && !options.overwrite)
      throw new Error(`Database '${dbAddress}' already exists!`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    logger.debug(`Created database '${dbAddress}'`)

    // Open the database
    return this.open(dbAddress, options)
  }

  async determineAddress(name, type, options = {}) {
    const opts = Object.assign({}, { onlyHash: true }, options)
    return this._determineAddress(name, type, opts)
  }

  /*
      options = {
        localOnly: false // if set to true, throws an error if database can't be found locally
        create: false // whether to create the database
        type: TODO
        overwrite: TODO

      }
   */
  async open (address, options = {}) {
    logger.debug(`open()`)

    options = Object.assign({ localOnly: false, create: false }, options)
    logger.debug(`Open database '${address}'`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Look from '${directory}'`)

    // If address is just the name of database, check the options to crate the database
    if (!OrbitDBAddress.isValid(address)) {
      if (!options.create) {
        throw new Error(`'options.create' set to 'false'. If you want to create a database, set 'options.create' to 'true'.`)
      } else if (options.create && !options.type) {
        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)
      } else {
        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)
        options.overwrite = options.overwrite ? options.overwrite : true
        return this.create(address, options.type, options)
      }
    }

    // Parse the database address
    const dbAddress = OrbitDBAddress.parse(address)

    // Load the locally saved db information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database
    const haveDB = await this._haveLocalData(cache, dbAddress)

    logger.debug((haveDB ? 'Found' : 'Didn\'t find') + ` database '${dbAddress}'`)

    // If we want to try and open the database local-only, throw an error
    // if we don't have the database locally
    if (options.localOnly && !haveDB) {
      logger.warn(`Database '${dbAddress}' doesn't exist!`)
      throw new Error(`Database '${dbAddress}' doesn't exist!`)
    }

    logger.debug(`Loading Manifest for '${dbAddress}'`)

    // Get the database manifest from IPFS
    const manifest = await io.read(this._ipfs, dbAddress.root)
    logger.debug(`Manifest for '${dbAddress}':\n${JSON.stringify(manifest, null, 2)}`)

    // Make sure the type from the manifest matches the type that was given as an option
    if (options.type && manifest.type !== options.type)
      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    // Open the the database
    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController })
    return this._createStore(manifest.type, dbAddress, options)
  }

  // Save the database locally
  async _addManifestToCache (directory, dbAddress) {
    const cache = await this._loadCache(directory, dbAddress)
    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)
    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)
  }

  async _loadCache (directory, dbAddress) {
    let cache
    try {
      cache = await this.cache.load(directory, dbAddress)
    } catch (e) {
      console.log(e)
      logger.error("Couldn't load Cache:", e)
    }

    return cache
  }

  /**
   * Check if we have the database, or part of it, saved locally
   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]
   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]
   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]
   */
  async _haveLocalData (cache, dbAddress) {
    if (!cache) {
      return false
    }
    const data = await cache.get(path.join(dbAddress.toString(), '_manifest'))
    return data !== undefined && data !== null
  }

  /**
   * Returns supported database types as an Array of strings
   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']
   * @return {[Array]} [Supported database types]
   */
  static get databaseTypes () {
    return Object.keys(databaseTypes)
  }

  static isValidType (type) {
    return Object.keys(databaseTypes).includes(type)
  }

  static addDatabaseType (type, store) {
    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)
    databaseTypes[type] = store
  }

  static getDatabaseTypes () {
    return databaseTypes
  }

  static isValidAddress (address) {
    return OrbitDBAddress.isValid(address)
  }

  static parseAddress (address) {
    return OrbitDBAddress.parse(address)
  }
}

module.exports = OrbitDB

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\OrbitDB.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\index.js", {"./boot":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\boot.js","./components":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\index.js","./config":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\config.js","./mfs-preload":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\mfs-preload.js","./preload":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\preload.js","./runtime/ipld-nodejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\ipld-browser.js","./runtime/repo-nodejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\repo-browser.js","./state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\state.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","ipfs-block-service":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block-service\\src\\index.js","ipld":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\index.js","is-ipfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-ipfs\\src\\index.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js","merge-options":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\merge-options\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js","multihashing-async":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\node_modules\\multihashing-async\\src\\index.js","peer-book":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-book\\src\\index.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const BlockService = require('ipfs-block-service')
const Ipld = require('ipld')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const crypto = require('libp2p-crypto')
const isIPFS = require('is-ipfs')
const multiaddr = require('multiaddr')
const multihash = require('multihashes')
const PeerBook = require('peer-book')
const multibase = require('multibase')
const multicodec = require('multicodec')
const multihashing = require('multihashing-async')
const CID = require('cids')
const debug = require('debug')
const mergeOptions = require('merge-options')
const EventEmitter = require('events')

const config = require('./config')
const boot = require('./boot')
const components = require('./components')

// replaced by repo-browser when running in the browser
const defaultRepo = require('./runtime/repo-nodejs')
const preload = require('./preload')
const mfsPreload = require('./mfs-preload')
const ipldOptions = require('./runtime/ipld-nodejs')

class IPFS extends EventEmitter {
  constructor (options) {
    super()

    const defaults = {
      init: true,
      start: true,
      EXPERIMENTAL: {},
      preload: {
        enabled: true,
        addresses: [
          '/dnsaddr/node0.preload.ipfs.io/https',
          '/dnsaddr/node1.preload.ipfs.io/https'
        ]
      }
    }

    options = config.validate(options || {})

    this._options = mergeOptions(defaults, options)

    if (options.init === false) {
      this._options.init = false
    }

    if (!(options.start === false)) {
      this._options.start = true
    }

    if (typeof options.repo === 'string' ||
        options.repo === undefined) {
      this._repo = defaultRepo(options.repo)
    } else {
      this._repo = options.repo
    }

    // IPFS utils
    this.log = debug('ipfs')
    this.log.err = debug('ipfs:err')

    // IPFS Core Internals
    // this._repo - assigned above
    this._peerInfoBook = new PeerBook()
    this._peerInfo = undefined
    this._bitswap = undefined
    this._blockService = new BlockService(this._repo)
    this._ipld = new Ipld(ipldOptions(this._blockService, this._options.ipld, this.log))
    this._preload = preload(this)
    this._mfsPreload = mfsPreload(this)
    this._ipns = undefined
    // eslint-disable-next-line no-console
    this._print = this._options.silent ? this.log : console.log

    // IPFS Core exposed components
    //   - for booting up a node
    this.init = components.init(this)
    this.preStart = components.preStart(this)
    this.start = components.start(this)
    this.stop = components.stop(this)
    this.shutdown = this.stop
    this.isOnline = components.isOnline(this)
    //   - interface-ipfs-core defined API
    Object.assign(this, components.filesRegular(this))
    this.version = components.version(this)
    this.id = components.id(this)
    this.repo = components.repo(this)
    this.bootstrap = components.bootstrap(this)
    this.config = components.config(this)
    this.block = components.block(this)
    this.object = components.object(this)
    this.dag = components.dag(this)
    this.files = components.filesMFS(this)
    this.libp2p = null // assigned on start
    this.swarm = components.swarm(this)
    this.name = components.name(this)
    this.bitswap = components.bitswap(this)
    this.pin = components.pin(this)
    this.ping = components.ping(this)
    this.pingPullStream = components.pingPullStream(this)
    this.pingReadableStream = components.pingReadableStream(this)
    this.pubsub = components.pubsub(this)
    this.dht = components.dht(this)
    this.dns = components.dns(this)
    this.key = components.key(this)
    this.stats = components.stats(this)
    this.resolve = components.resolve(this)

    if (this._options.EXPERIMENTAL.pubsub) {
      this.log('EXPERIMENTAL pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.ipnsPubsub) {
      if (!this._options.EXPERIMENTAL.pubsub) {
        this.log('EXPERIMENTAL pubsub is enabled to use IPNS pubsub')
        this._options.EXPERIMENTAL.pubsub = true
      }

      this.log('EXPERIMENTAL IPNS pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.sharding) {
      this.log('EXPERIMENTAL sharding is enabled')
    }

    this.state = require('./state')(this)

    boot(this)
  }
}

module.exports = IPFS

// Note: We need to do this to force browserify to load the Buffer module
const BufferImpl = Buffer
Object.assign(module.exports, { crypto, isIPFS, Buffer: BufferImpl, CID, multiaddr, multibase, multihash, multihashing, multicodec, PeerId, PeerInfo })

module.exports.createNode = (options) => {
  return new IPFS(options)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\helpers.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fast-json-patch\lib\helpers.js
      return function (require, module, exports) {
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
Object.defineProperty(exports, "hasOwnProperty", { value: hasOwnProperty });
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\core.js", {"./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\helpers.js","fast-deep-equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\node_modules\\fast-deep-equal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fast-json-patch\lib\core.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var areEquals = require('fast-deep-equal');
var helpers_1 = require("./helpers");
exports.JsonPatchError = helpers_1.PatchError;
exports.deepClone = helpers_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (key && key.indexOf('~') != -1) {
                    key = helpers_1.unescapePathComponent(key);
                }
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
/**
 * Default export for backwards compat
 */
exports.default = {
    JsonPatchError: exports.JsonPatchError,
    deepClone: exports.deepClone,
    getValueByPointer: getValueByPointer,
    applyOperation: applyOperation,
    applyPatch: applyPatch,
    applyReducer: applyReducer,
    validator: validator,
    validate: validate
};

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\lib\\core.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\index.js", {"./cid-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\cid-util.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multihashes\\src\\index.js","uint8arrays/concat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\concat.js","uint8arrays/equals":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\equals.js","uint8arrays/to-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\to-string.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\src\index.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')
const multibase = require('multibase')
const multicodec = require('multicodec')
const CIDUtil = require('./cid-util')
const uint8ArrayConcat = require('uint8arrays/concat')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayEquals = require('uint8arrays/equals')

const codecs = multicodec.nameToCode
const codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {
  p[codecs[name]] = name
  return p
}, /** @type {Record<CodecCode, CodecName>} */({}))

const symbol = Symbol.for('@ipld/js-cid/CID')

/**
 * @typedef {Object} SerializedCID
 * @property {string} codec
 * @property {number} version
 * @property {Uint8Array} hash
 */
/**
 * @typedef {0|1} CIDVersion
 * @typedef {__import__('multibase').BaseNameOrCode} BaseNameOrCode
 * @typedef {__import__('multicodec').CodecName} CodecName
 * @typedef {__import__('multicodec').CodecCode} CodecCode
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 *
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Uint8Array)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {CIDVersion | string | Uint8Array | CID} version
   * @param {string|number} [codec]
   * @param {Uint8Array} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.bytes>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    // We have below three blank field accessors only because
    // otherwise TS will not pick them up if done after assignemnts

    /**
     * The version of the CID.
     *
     * @type {CIDVersion}
     */
    // eslint-disable-next-line no-unused-expressions
    this.version

    /**
     * The codec of the CID.
     *
     * @deprecated
     * @type {CodecName}
     */
    // eslint-disable-next-line no-unused-expressions
    this.codec

    /**
     * The multihash of the CID.
     *
     * @type {Uint8Array}
     */
    // eslint-disable-next-line no-unused-expressions
    this.multihash

    Object.defineProperty(this, symbol, { value: true })
    if (CID.isCID(version)) {
      // version is an exising CID instance
      const cid = /** @type {CID} */(version)
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = cid.multihash
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      // @ts-ignore
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (version instanceof Uint8Array) {
      const v = parseInt(version[0].toString(), 16)
      if (v === 1) {
        // version is a CID Uint8Array
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash Uint8Array, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    this.version = version

    if (typeof codec === 'number') {
      // @ts-ignore
      codec = codecInts[codec]
    }

    this.codec = /** @type {CodecName} */ (codec)

    this.multihash = /** @type {Uint8Array} */ (multihash)

    /**
     * Multibase name as string.
     *
     * @deprecated
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Uint8Array`
   *
   * @returns {Uint8Array}
   *
   */
  get bytes () {
    // @ts-ignore
    let bytes = this._bytes

    if (!bytes) {
      if (this.version === 0) {
        bytes = this.multihash
      } else if (this.version === 1) {
        const codec = multicodec.getCodeVarint(this.codec)
        bytes = uint8ArrayConcat([
          [1], codec, this.multihash
        ], 1 + codec.byteLength + this.multihash.byteLength)
      } else {
        throw new Error('unsupported version')
      }

      // Cache this Uint8Array so it doesn't have to be recreated
      Object.defineProperty(this, '_bytes', { value: bytes })
    }

    return bytes
  }

  /**
   * The prefix of the CID.
   *
   * @returns {Uint8Array}
   */
  get prefix () {
    const codec = multicodec.getCodeVarint(this.codec)
    const multihash = mh.prefix(this.multihash)
    const prefix = uint8ArrayConcat([
      [this.version], codec, multihash
    ], 1 + codec.byteLength + multihash.byteLength)

    return prefix
  }

  /**
   * The codec of the CID in its number form.
   *
   * @returns {CodecCode}
   */
  get code () {
    return codecs[this.codec]
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new CID(1, this.codec, this.multihash, this.multibaseName)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    // @ts-ignore non enumerable cache property
    if (this.string && this.string.length !== 0 && base === this.multibaseName) {
      // @ts-ignore non enumerable cache property
      return this.string
    }
    let str
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = uint8ArrayToString(multibase.encode(base, this.bytes))
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  /**
   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
   *
   * @returns {string}
   */
  [Symbol.for('nodejs.util.inspect.custom')] () {
    return 'CID(' + this.toString() + ')'
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {boolean}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      uint8ArrayEquals(this.multihash, other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other - The other CID.
   * @returns {void}
   */
  static validateCID (other) {
    const errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }

  /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is CID}
   */
  static isCID (value) {
    return value instanceof CID || Boolean(value && value[symbol])
  }
}

CID.codecs = codecs

module.exports = CID

      };
    };
  }
}, {package:"cids",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multihashes\src\constants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
}, {package:"multihashes",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js", {"./decode.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\decode.js","./encode.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\encode.js","./length.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\varint\index.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js", {"util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\web-encoding\src\lib.js
      return function (require, module, exports) {
"use strict"

exports.TextEncoder =
  typeof TextEncoder !== "undefined" ? TextEncoder : require("util").TextEncoder

exports.TextDecoder =
  typeof TextDecoder !== "undefined" ? TextDecoder : require("util").TextDecoder

      };
    };
  }
}, {package:"web-encoding",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multibase\src\index.js
      return function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {__import__("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-base64\\base64.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\js-base64\base64.js
      return function (require, module, exports) {
(function (Buffer){(function (){


//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
        ? define(factory) :
        // cf. https://github.com/dankogai/js-base64/issues/119
        (function() {
            // existing version for noConflict()
            const _Base64 = global.Base64;
            const gBase64 = factory();
            gBase64.noConflict = () => {
                global.Base64 = _Base64;
                return gBase64;
            };
            if (global.Meteor) { // Meteor.js
                Base64 = gBase64;
            }
            global.Base64 = gBase64;
        })();
}((typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
        : this
), function() {
    'use strict';

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.1';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};

    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(k => gBase64.Base64[k] = gBase64[k]);
    return gBase64;
}));



}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"js-base64",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-base64\\base64.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\print.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\varint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\constants.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\int-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\uint8arrays\concat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js", {"./decode.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js","./encode.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js","./length.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\node_modules\varint\index.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js", {"uint8arrays/from-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\util.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\analytics-node\node_modules\uuid\lib\bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\bytesToUuid.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\analytics-node\node_modules\uuid\lib\rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\analytics-node\\node_modules\\uuid\\lib\\rng-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\charenc\\charenc.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\charenc\charenc.js
      return function (require, module, exports) {
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

      };
    };
  }
}, {package:"charenc",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\charenc\\charenc.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypt\\crypt.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\crypt\crypt.js
      return function (require, module, exports) {
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

      };
    };
  }
}, {package:"crypt",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypt\\crypt.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-type\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\component-type\index.js
      return function (require, module, exports) {
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  if (isBuffer(val)) return 'buffer';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val);

  return typeof val;
};

// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js
function isBuffer(obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

      };
    };
  }
}, {package:"component-type",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-type\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\join-component\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\join-component\index.js
      return function (require, module, exports) {

/**
 * Join `arr` with the trailing `str` defaulting to "and",
 * and `sep` string defaulting to ", ".
 *
 * @param {Array} arr
 * @param {String} str
 * @param {String} sep
 * @return {String}
 * @api public
 */

module.exports = function(arr, str, sep){
  str = str || 'and';
  sep = sep || ', ';

  if (arr.length < 2) return arr[0] || '';

  var oxford = str.slice(0, 2) === sep;

  if (!oxford) {
    str = ' ' + str;
  } else if (arr.length == 2) {
    str = str.slice(1);
  }

  return arr.slice(0, -1).join(sep) + str + ' ' + arr[arr.length - 1];
};

      };
    };
  }
}, {package:"join-component",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\join-component\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\lib\\index.js", {"is-retry-allowed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-retry-allowed\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios-retry\lib\index.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkError = isNetworkError;
exports.isRetryableError = isRetryableError;
exports.isSafeRequestError = isSafeRequestError;
exports.isIdempotentRequestError = isIdempotentRequestError;
exports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
exports.exponentialDelay = exponentialDelay;
exports.default = axiosRetry;

var _isRetryAllowed = require('is-retry-allowed');

var _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var namespace = 'axios-retry';

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkError(error) {
  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests
  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors
}

var SAFE_HTTP_METHODS = ['get', 'head', 'options'];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isRetryableError(error) {
  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isSafeRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isIdempotentRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}

/**
 * @return {number} - delay in milliseconds, always 0
 */
function noDelay() {
  return 0;
}

/**
 * @param  {number} [retryNumber=0]
 * @return {number} - delay in milliseconds
 */
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var delay = Math.pow(2, retryNumber) * 100;
  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
  return delay + randomSum;
}

/**
 * Initializes and returns the retry state for the given request/config
 * @param  {AxiosRequestConfig} config
 * @return {Object}
 */
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}

/**
 * Returns the axios-retry options for the current request
 * @param  {AxiosRequestConfig} config
 * @param  {AxiosRetryConfig} defaultOptions
 * @return {AxiosRetryConfig}
 */
function getRequestOptions(config, defaultOptions) {
  return Object.assign({}, defaultOptions, config[namespace]);
}

/**
 * @param  {Axios} axios
 * @param  {AxiosRequestConfig} config
 */
function fixConfig(axios, config) {
  if (axios.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues
 *
 * @example
 *
 * import axios from 'axios';
 *
 * axiosRetry(axios, { retries: 3 });
 *
 * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Exponential back-off retry delay between requests
 * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});
 *
 * // Custom retry delay
 * axiosRetry(axios, { retryDelay : (retryCount) => {
 *   return retryCount * 1000;
 * }});
 *
 * // Also works with custom axios instances
 * const client = axios.create({ baseURL: 'http://example.com' });
 * axiosRetry(client, { retries: 3 });
 *
 * client.get('/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Allows request-specific configuration
 * client
 *   .get('/test', {
 *     'axios-retry': {
 *       retries: 0
 *     }
 *   })
 *   .catch(error => { // The first request fails
 *     error !== undefined
 *   });
 *
 * @param {Axios} axios An axios instance (the axios object or one created from axios.create)
 * @param {Object} [defaultOptions]
 * @param {number} [defaultOptions.retries=3] Number of retries
 * @param {boolean} [defaultOptions.shouldResetTimeout=false]
 *        Defines if the timeout should be reset between retries
 * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]
 *        A function to determine if the error can be retried
 * @param {Function} [defaultOptions.retryDelay=noDelay]
 *        A function to determine the delay between retry requests
 */
function axiosRetry(axios, defaultOptions) {
  axios.interceptors.request.use(function (config) {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });

  axios.interceptors.response.use(null, function (error) {
    var config = error.config;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(error);
    }

    var _getRequestOptions = getRequestOptions(config, defaultOptions),
        _getRequestOptions$re = _getRequestOptions.retries,
        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,
        _getRequestOptions$re2 = _getRequestOptions.retryCondition,
        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,
        _getRequestOptions$re3 = _getRequestOptions.retryDelay,
        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,
        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,
        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;

    var currentState = getCurrentState(config);

    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;

    if (shouldRetry) {
      currentState.retryCount += 1;
      var delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
        var lastRequestDuration = Date.now() - currentState.lastRequestTime;
        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)
        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
      }

      config.transformRequest = [function (data) {
        return data;
      }];

      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve(axios(config));
        }, delay);
      });
    }

    return Promise.reject(error);
  });
}

// Compatibility with CommonJS
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"axios-retry",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios-retry\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\axios.js", {"./cancel/Cancel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\Cancel.js","./cancel/CancelToken":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\CancelToken.js","./cancel/isCancel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\isCancel.js","./core/Axios":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\Axios.js","./core/mergeConfig":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\mergeConfig.js","./defaults":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\defaults.js","./helpers/bind":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\bind.js","./helpers/isAxiosError":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\isAxiosError.js","./helpers/spread":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\spread.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\axios.js
      return function (require, module, exports) {
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\axios.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\constants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var BN = require("bn.js");
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\object.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.stripZeros(v);
                assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\object.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./secp256k1v3-adapter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\account.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns a zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
};
/**
 * Checks if a given address is a zero address.
 */
exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details, consult EIP-1191.
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
};
/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium).
 */
exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    pubKey = bytes_1.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }
    assert(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\account.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js","./secp256k1v3-adapter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\signature.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns the ECDSA signature of a message hash.
 */
exports.ecsign = function (msgHash, privateKey, chainId) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var recovery = sig.recovery;
    var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,
    };
    return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    // NOTE: with potential introduction of chainId this might need to be updated
    if (buf.length !== 65) {
        throw new Error('Invalid signature length');
    }
    var v = buf[64];
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64),
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new BN(r);
    var sBN = new BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v, chainId) {
    return chainId ? v - (2 * chainId + 35) : v - 27;
}
function isValidSigRecovery(recovery) {
    return recovery === 0 || recovery === 1;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\signature.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\bytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */
exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) { right = false; }
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
exports.setLength = exports.setLengthLeft;
/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */
exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = exports.unpad;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjsUtil.isHexString(v)) {
                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjsUtil.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (BN.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\bytes.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\hash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
var _a = require('ethereum-cryptography/keccak'), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;
var createHash = require('create-hash');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Creates Keccak hash of the input
 * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
 * it's interpreted as hexadecimal, otherwise as utf8.
 * @param bits The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, 'utf8');
    }
    else {
        a = bytes_1.toBuffer(a);
    }
    if (!bits)
        bits = 256;
    switch (bits) {
        case 224: {
            return keccak224(a);
        }
        case 256: {
            return k256(a);
        }
        case 384: {
            return keccak384(a);
        }
        case 512: {
            return keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates SHA256 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256')
        .update(a)
        .digest();
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160')
        .update(a)
        .digest();
    if (padded === true) {
        return bytes_1.setLength(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\hash.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js", {"./secp256k1v3-lib/der":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js","./secp256k1v3-lib/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\secp256k1v3-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
var secp256k1 = require('ethereum-cryptography/secp256k1');
var secp256k1v3 = require('./secp256k1v3-lib/index');
var der = require('./secp256k1v3-lib/der');
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        return false;
    }
    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
    }
    throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyNegate = function (privateKey) {
    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
        throw new Error('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
    }
    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
        keys.push(Uint8Array.from(publicKey));
    });
    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureNormalize = function (signature) {
    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureExport = function (signature) {
    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImport = function (signature) {
    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
        throw new RangeError('signature length is invalid');
    }
    var sigObj = der.signatureImportLax(signature);
    if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
    }
    return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
exports.sign = function (message, privateKey, options) {
    if (options === null) {
        throw new TypeError('options should be an Object');
    }
    var signOptions = undefined;
    if (options) {
        signOptions = {};
        if (options.data === null) {
            // validate option.data length
            throw new TypeError('options.data should be a Buffer');
        }
        if (options.data) {
            if (options.data.length != 32) {
                throw new RangeError('options.data length is invalid');
            }
            signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
            throw new TypeError('options.noncefn should be a Function');
        }
        if (options.noncefn) {
            // convert option.noncefn function signature
            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                var bufferData = data != null ? Buffer.from(data) : null;
                var buffer = Buffer.from('');
                if (options.noncefn) {
                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                }
                return new Uint8Array(buffer);
            };
        }
    }
    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid,
    };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.recover = function (message, signature, recid, compressed) {
    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError('public key length is invalid');
    }
    // ensure valid privateKey length
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\uuid\lib\bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\bytesToUuid.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\uuid\lib\rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\uuid\\lib\\rng-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createSwappableProxy.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\swappable-obj-proxy\src\createSwappableProxy.js
      return function (require, module, exports) {

module.exports = function createSwappableProxy (initialTarget) {
  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    target = newTarget
  }
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createSwappableProxy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createEventEmitterProxy.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\swappable-obj-proxy\src\createEventEmitterProxy.js
      return function (require, module, exports) {
const filterNoop = () => true
const internalEvents = ['newListener', 'removeListener']
const externalEventFilter = (name) => !internalEvents.includes(name)

module.exports = function createEventEmitterProxy (initialTarget, opts) {
  // parse options
  opts = opts || {}
  let eventFilter = opts.eventFilter || filterNoop
  if (eventFilter === 'skipInternal') eventFilter = externalEventFilter
  if (typeof eventFilter !== 'function') throw new Error('createEventEmitterProxy - Invalid eventFilter')

  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    const oldTarget = target
    target = newTarget
    // migrate listeners
    oldTarget.eventNames().filter(eventFilter).forEach((name) => {
      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler))
    })
    // remove old
    oldTarget.removeAllListeners()
  }
}

function getRawListeners(eventEmitter, name) {
  // prefer native
  if (eventEmitter.rawListeners) return eventEmitter.rawListeners(name)
  // fallback to lookup against internal object
  let events = eventEmitter._events[name] || []
  // ensure array
  if (!Array.isArray(events)) events = [events]
  // return copy
  return events.slice()
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\swappable-obj-proxy\\src\\createEventEmitterProxy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\index.js", {"./BaseBlockTracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js","./PollingBlockTracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js","./SubscribeBlockTracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-block-tracker\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./BaseBlockTracker"), exports);
__exportStar(require("./PollingBlockTracker"), exports);
__exportStar(require("./SubscribeBlockTracker"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\node_modules\\bs58\\lib\\bs58.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\coinstring\node_modules\bs58\lib\bs58.js
      return function (require, module, exports) {
// Base58 encoding/decoding
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var ALPHABET_MAP = {}
for(var i = 0; i < ALPHABET.length; i++) {
  ALPHABET_MAP[ALPHABET.charAt(i)] = i
}
var BASE = 58

function encode(buffer) {
  if (buffer.length === 0) return ''

  var i, j, digits = [0]
  for (i = 0; i < buffer.length; i++) {
    for (j = 0; j < digits.length; j++) digits[j] <<= 8

    digits[0] += buffer[i]

    var carry = 0
    for (j = 0; j < digits.length; ++j) {
      digits[j] += carry

      carry = (digits[j] / BASE) | 0
      digits[j] %= BASE
    }

    while (carry) {
      digits.push(carry % BASE)

      carry = (carry / BASE) | 0
    }
  }

  // deal with leading zeros
  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0)

  // convert digits to a string
  var stringOutput = ""
  for (var i = digits.length - 1; i >= 0; i--) {
    stringOutput = stringOutput + ALPHABET[digits[i]]
  }
  return stringOutput
}

function decode(string) {
  if (string.length === 0) return []

  var i, j, bytes = [0]
  for (i = 0; i < string.length; i++) {
    var c = string[i]
    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character')

    for (j = 0; j < bytes.length; j++) bytes[j] *= BASE
    bytes[0] += ALPHABET_MAP[c]

    var carry = 0
    for (j = 0; j < bytes.length; ++j) {
      bytes[j] += carry

      carry = bytes[j] >> 8
      bytes[j] &= 0xff
    }

    while (carry) {
      bytes.push(carry & 0xff)

      carry >>= 8
    }
  }

  // deal with leading zeros
  for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0)

  return bytes.reverse()
}

module.exports = {
  encode: encode,
  decode: decode
}

      };
    };
  }
}, {package:"bs58",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\coinstring\\node_modules\\bs58\\lib\\bs58.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js", {"../messages.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\elliptic\index.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var BN = require('bn.js')
var EC = require('elliptic').ec

var messages = require('../messages.json')

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js", {"./assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js","./der":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js","./messages.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\index.js
      return function (require, module, exports) {
'use strict'
var assert = require('./assert')
var der = require('./der')
var messages = require('./messages.json')

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\js.js", {"./lib/api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\api\\index.js","./lib/keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\keccak.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\keccak\js.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib/api')(require('./lib/keccak'))

      };
    };
  }
}, {package:"keccak",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\js.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-util\\dist\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethjs-util\\lib\\index.js","keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\keccak\\js.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\index.js", {"./lib/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\ethereumjs-abi\index.js
      return function (require, module, exports) {
module.exports = require('./lib/index.js')

      };
    };
  }
}, {package:"ethereumjs-abi",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\index.js", {"./commonjs/core.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\core.js","./commonjs/duplex.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\duplex.js","./commonjs/helpers.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\node_modules\fast-json-patch\index.js
      return function (require, module, exports) {
var core = require("./commonjs/core.js");
Object.assign(exports, core);

var duplex = require("./commonjs/duplex.js");
Object.assign(exports, duplex);

var helpers = require("./commonjs/helpers.js");
exports.JsonPatchError = helpers.PatchError;
exports.deepClone = helpers._deepClone;
exports.escapePathComponent = helpers.escapePathComponent;
exports.unescapePathComponent = helpers.unescapePathComponent;

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseClone.js", {"./_Stack":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_Stack.js","./_arrayEach":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_arrayEach.js","./_assignValue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_assignValue.js","./_baseAssign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssign.js","./_baseAssignIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssignIn.js","./_cloneBuffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneBuffer.js","./_copyArray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyArray.js","./_copySymbols":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbols.js","./_copySymbolsIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbolsIn.js","./_getAllKeys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getAllKeys.js","./_getAllKeysIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getAllKeysIn.js","./_getTag":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getTag.js","./_initCloneArray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneArray.js","./_initCloneByTag":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneByTag.js","./_initCloneObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneObject.js","./isArray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isArray.js","./isBuffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isBuffer.js","./isMap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isMap.js","./isObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isObject.js","./isSet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isSet.js","./keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keys.js","./keysIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keysIn.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_baseClone.js
      return function (require, module, exports) {
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseClone.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\util.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","aes-js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\aes-js\\index.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","crc-32":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crc-32\\crc32.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\util.js
      return function (require, module, exports) {
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.promisifyCb = exports.existsIn = exports.isAsciiStr = exports.buildSignerPathBuf = exports.getP256KeyPairFromPub = exports.getP256KeyPair = exports.parseDER = exports.aes256_decrypt = exports.aes256_encrypt = exports.fixLen = exports.ensureHexBuffer = exports.splitFrames = exports.isValidAssetPath = exports.toPaddedDER = exports.checksum = exports.parseLattice1Response = void 0;
// Static utility functions
var aes_js_1 = __importDefault(require("aes-js"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var buffer_1 = require("buffer/");
var crc_32_1 = __importDefault(require("crc-32"));
var elliptic_1 = __importDefault(require("elliptic"));
var constants_1 = require("./constants");
var COINS = constants_1.BIP_CONSTANTS.COINS, PURPOSES = constants_1.BIP_CONSTANTS.PURPOSES;
var EC = elliptic_1.default.ec;
var ec = new EC('p256');
//--------------------------------------------------
// LATTICE UTILS
//--------------------------------------------------
// Parse a response from the Lattice1
var parseLattice1Response = function (r) {
    var parsed = {
        err: null,
        data: null,
    };
    var b = buffer_1.Buffer.from(r, 'hex');
    var off = 0;
    // Get protocol version
    var protoVer = b.readUInt8(off);
    off++;
    if (protoVer !== constants_1.VERSION_BYTE) {
        parsed.err = 'Incorrect protocol version. Please update your SDK';
        return parsed;
    }
    // Get the type of response
    // Should always be 0x00
    var msgType = b.readUInt8(off);
    off++;
    if (msgType !== 0x00) {
        parsed.err = 'Incorrect response from Lattice1';
        return parsed;
    }
    // Get the payload
    b.readUInt32BE(off);
    off += 4; // First 4 bytes is the id, but we don't need that anymore
    var len = b.readUInt16BE(off);
    off += 2;
    var payload = b.slice(off, off + len);
    off += len;
    // Get response code
    var responseCode = payload.readUInt8(0);
    if (responseCode !== constants_1.responseCodes.RESP_SUCCESS) {
        parsed.err = "".concat(constants_1.responseMsgs[responseCode] ? constants_1.responseMsgs[responseCode] : 'Unknown Error', " (Lattice)");
        parsed.responseCode = responseCode;
        return parsed;
    }
    else {
        parsed.data = payload.slice(1, payload.length);
    }
    // Verify checksum
    var cs = b.readUInt32BE(off);
    var expectedCs = (0, exports.checksum)(b.slice(0, b.length - 4));
    if (cs !== expectedCs) {
        parsed.err = 'Invalid checksum from device response';
        parsed.data = null;
        return parsed;
    }
    return parsed;
};
exports.parseLattice1Response = parseLattice1Response;
var checksum = function (x) {
    // crc32 returns a signed integer - need to cast it to unsigned
    // Note that this uses the default 0xedb88320 polynomial
    return crc_32_1.default.buf(x) >>> 0; // Need this to be a uint, hence the bit shift
};
exports.checksum = checksum;
// Get a 74-byte padded DER-encoded signature buffer
// `sig` must be the signature output from elliptic.js
var toPaddedDER = function (sig) {
    // We use 74 as the maximum length of a DER signature. All sigs must
    // be right-padded with zeros so that this can be a fixed size field
    var b = buffer_1.Buffer.alloc(74);
    var ds = buffer_1.Buffer.from(sig.toDER());
    ds.copy(b);
    return b;
};
exports.toPaddedDER = toPaddedDER;
//--------------------------------------------------
// TRANSACTION UTILS
//--------------------------------------------------
var isValidAssetPath = function (path, fwConstants) {
    var allowedPurposes = [
        PURPOSES.ETH,
        PURPOSES.BTC_LEGACY,
        PURPOSES.BTC_WRAPPED_SEGWIT,
        PURPOSES.BTC_SEGWIT,
    ];
    var allowedCoins = [COINS.ETH, COINS.BTC, COINS.BTC_TESTNET];
    // These coin types were given to us by MyCrypto. They should be allowed, but we expect
    // an Ethereum-type address with these coin types.
    // These all use SLIP44: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    var allowedMyCryptoCoins = [
        60, 61, 966, 700, 9006, 9000, 1007, 553, 178, 137, 37310, 108, 40, 889,
        1987, 820, 6060, 1620, 1313114, 76, 246529, 246785, 1001, 227, 916, 464,
        2221, 344, 73799, 246,
    ];
    // Make sure firmware supports this Bitcoin path
    var isBitcoin = path[1] === COINS.BTC || path[1] === COINS.BTC_TESTNET;
    var isBitcoinNonWrappedSegwit = isBitcoin && path[0] !== PURPOSES.BTC_WRAPPED_SEGWIT;
    if (isBitcoinNonWrappedSegwit && !fwConstants.allowBtcLegacyAndSegwitAddrs)
        return false;
    // Make sure this path is otherwise valid
    return (allowedPurposes.indexOf(path[0]) >= 0 &&
        (allowedCoins.indexOf(path[1]) >= 0 ||
            allowedMyCryptoCoins.indexOf(path[1] - constants_1.HARDENED_OFFSET) > 0));
};
exports.isValidAssetPath = isValidAssetPath;
var splitFrames = function (data, frameSz) {
    var frames = [];
    var n = Math.ceil(data.length / frameSz);
    var off = 0;
    for (var i = 0; i < n; i++) {
        frames.push(data.slice(off, off + frameSz));
        off += frameSz;
    }
    return frames;
};
exports.splitFrames = splitFrames;
function isBase10NumStr(x) {
    var bn = new bignumber_js_1.default(x).toString().split('.').join('');
    var s = new String(x);
    // Note that the JS native `String()` loses precision for large numbers, but we only
    // want to validate the base of the number so we don't care about far out precision.
    return bn.slice(0, 8) === s.slice(0, 8);
}
// Ensure a param is represented by a buffer
var ensureHexBuffer = function (x, zeroIsNull) {
    if (zeroIsNull === void 0) { zeroIsNull = true; }
    try {
        // For null values, return a 0-sized buffer. For most situations we assume
        // 0 should be represented with a zero-length buffer (e.g. for RLP-building
        // txs), but it can also be treated as a 1-byte buffer (`00`) if needed
        if (x === null || (x === 0 && zeroIsNull === true))
            return buffer_1.Buffer.alloc(0);
        var isNumber = typeof x === 'number' || isBase10NumStr(x);
        // Otherwise try to get this converted to a hex string
        if (isNumber) {
            // If this is a number or a base-10 number string, convert it to hex
            x = "".concat(new bignumber_js_1.default(x).toString(16));
        }
        else if (typeof x === 'string' && x.slice(0, 2) === '0x') {
            x = x.slice(2);
        }
        else {
            x = x.toString('hex');
        }
        if (x.length % 2 > 0)
            x = "0".concat(x);
        if (x === '00' && !isNumber)
            return buffer_1.Buffer.alloc(0);
        return buffer_1.Buffer.from(x, 'hex');
    }
    catch (err) {
        throw new Error("Cannot convert ".concat(x.toString(), " to hex buffer (").concat(err.toString(), ")"));
    }
};
exports.ensureHexBuffer = ensureHexBuffer;
var fixLen = function (msg, length) {
    var buf = buffer_1.Buffer.alloc(length);
    if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
    }
    return msg.slice(-length);
};
exports.fixLen = fixLen;
//--------------------------------------------------
// CRYPTO UTILS
//--------------------------------------------------
var aes256_encrypt = function (data, key) {
    var iv = buffer_1.Buffer.from(constants_1.AES_IV);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    var paddedData = data.length % 16 === 0 ? data : aes_js_1.default.padding.pkcs7.pad(data);
    return buffer_1.Buffer.from(aesCbc.encrypt(paddedData));
};
exports.aes256_encrypt = aes256_encrypt;
var aes256_decrypt = function (data, key) {
    var iv = buffer_1.Buffer.from(constants_1.AES_IV);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    return buffer_1.Buffer.from(aesCbc.decrypt(data));
};
exports.aes256_decrypt = aes256_decrypt;
// Decode a DER signature. Returns signature object {r, s } or null if there is an error
var parseDER = function (sigBuf) {
    if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02)
        return null;
    var off = 3;
    var sig = { r: null, s: null };
    var rLen = sigBuf[off];
    off++;
    sig.r = sigBuf.slice(off, off + rLen);
    off += rLen;
    if (sigBuf[off] !== 0x02)
        return null;
    off++;
    var sLen = sigBuf[off];
    off++;
    sig.s = sigBuf.slice(off, off + sLen);
    return sig;
};
exports.parseDER = parseDER;
var getP256KeyPair = function (priv) {
    return ec.keyFromPrivate(priv, 'hex');
};
exports.getP256KeyPair = getP256KeyPair;
var getP256KeyPairFromPub = function (pub) {
    return ec.keyFromPublic(pub, 'hex');
};
exports.getP256KeyPairFromPub = getP256KeyPairFromPub;
var buildSignerPathBuf = function (signerPath, varAddrPathSzAllowed) {
    var buf = buffer_1.Buffer.alloc(24);
    var off = 0;
    if (varAddrPathSzAllowed && signerPath.length > 5)
        throw new Error('Signer path must be <=5 indices.');
    if (!varAddrPathSzAllowed && signerPath.length !== 5)
        throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');
    buf.writeUInt32LE(signerPath.length, off);
    off += 4;
    for (var i = 0; i < 5; i++) {
        if (i < signerPath.length)
            buf.writeUInt32LE(signerPath[i], off);
        else
            buf.writeUInt32LE(0, off);
        off += 4;
    }
    return buf;
};
exports.buildSignerPathBuf = buildSignerPathBuf;
//--------------------------------------------------
// OTHER UTILS
//--------------------------------------------------
var isAsciiStr = function (str, allowFormatChars) {
    if (allowFormatChars === void 0) { allowFormatChars = false; }
    if (typeof str !== 'string') {
        return false;
    }
    var extraChars = allowFormatChars ?
        [
            0x0020,
            0x000a, // New line
        ] : [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (extraChars.indexOf(c) < 0 && (c < 0x0020 || c > 0x007f)) {
            return false;
        }
    }
    return true;
};
exports.isAsciiStr = isAsciiStr;
// Check if a value exists in an object. Only checks first level of keys.
var existsIn = function (val, obj) {
    return Object.keys(obj).some(function (key) { return obj[key] === val; });
};
exports.existsIn = existsIn;
/**
 * `promisifyCb` accepts `resolve` and `reject` from a `Promise` and an optional callback.
 * It returns that callback if it exists, otherwise it resolves or rejects as a `Promise`
 */
var promisifyCb = function (resolve, reject, cb) {
    return function (err) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        if (cb && typeof cb === 'function')
            return cb.apply(void 0, __spreadArray([err], params, false));
        if (err && typeof err === 'string')
            return reject(err);
        return resolve.apply(void 0, params);
    };
};
exports.promisifyCb = promisifyCb;
// Create a buffer of size `n` and fill it with random data
var randomBytes = function (n) {
    var buf = buffer_1.Buffer.alloc(n);
    for (var i = 0; i < n; i++) {
        buf[i] = Math.round(Math.random() * 255);
    }
    return buf;
};
exports.randomBytes = randomBytes;

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereumAbi.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\ethereumAbi.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abiParsers = exports.unpackAbiDef = exports.getFuncSig = exports.buildAddAbiPayload = exports.ABI_DEF_SZ = exports.MAX_ABI_DEFS = void 0;
var buffer_1 = require("buffer/");
var js_sha3_1 = require("js-sha3");
var constants_1 = require("./constants");
var NAME_MAX_SZ = 100;
var HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count
var CATEGORY_SZ = 32;
var PARAM_NAME_SZ = 20;
var PARAM_SZ = 26; // 20 byte name + 6 byte def
var MAX_PARAMS = 18;
exports.MAX_ABI_DEFS = 2;
exports.ABI_DEF_SZ = (HEADER_SZ + CATEGORY_SZ + (PARAM_SZ * MAX_PARAMS));
// Build a request to add ABI data
var buildAddAbiPayload = function (defs) {
    if (!defs || !Array.isArray(defs))
        throw new Error('Missing definitions.');
    if (defs.length > exports.MAX_ABI_DEFS)
        throw new Error("You may only add ".concat(exports.MAX_ABI_DEFS, " ABI definitions per request."));
    var b = buffer_1.Buffer.alloc(1 + (exports.MAX_ABI_DEFS * exports.ABI_DEF_SZ));
    var off = 0;
    b.writeUInt8(defs.length, off);
    off++;
    defs.forEach(function (def) {
        if (!def.sig || !def.name || !def.params)
            throw new Error('name, sig, and params must be present for every ABI definition.');
        // -- Header data --
        var sig = buffer_1.Buffer.from(def.sig, 'hex');
        if (sig.length !== 4)
            throw new Error('Function signatures must always be four bytes.');
        sig.copy(b, off);
        off += sig.length;
        var name = buffer_1.Buffer.from(def.name);
        if (name.length > NAME_MAX_SZ - 1)
            // The -1 accounts for the null terminator
            throw new Error("Only function names shorter than ".concat(NAME_MAX_SZ - 1, " characters are supported."));
        buffer_1.Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off);
        off += NAME_MAX_SZ;
        // Number of parameters
        var numParams = Array.isArray(def.params) ? def.params.length : 0;
        b.writeUInt8(numParams, off);
        off++;
        // -- (optional) Category name --
        if (def.category && typeof def.category === 'string') {
            var category = buffer_1.Buffer.from(def.category);
            if (category.length > CATEGORY_SZ - 1)
                // -1 accounts for null terminator
                throw new Error("Category name must be shorter than ".concat(CATEGORY_SZ - 1, ". Got ").concat(category.length));
            category.copy(b, off);
        }
        off += CATEGORY_SZ;
        // -- Param data --
        if (numParams > MAX_PARAMS)
            throw new Error('Currently only ABI defintions with <=10 parameters are supported.');
        if (numParams > 0) {
            // First copy param names
            def.params.forEach(function (param) {
                if (param.name === undefined ||
                    param.latticeTypeIdx === undefined ||
                    param.isArray === undefined ||
                    param.arraySz === undefined)
                    throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');
                buffer_1.Buffer.from(param.name).slice(0, PARAM_NAME_SZ).copy(b, off);
                off += PARAM_NAME_SZ;
            });
            // Bump offset to account for blank param slots
            off += PARAM_NAME_SZ * (MAX_PARAMS - numParams);
            // Next copy the definitions
            def.params.forEach(function (param) {
                b.writeUInt8(param.latticeTypeIdx, off);
                off++;
                b.writeUInt8(param.isArray ? 1 : 0, off);
                off++;
                b.writeUInt32LE(param.arraySz, off);
                off += 4;
            });
            // Bump offset again
            off += 6 * (MAX_PARAMS - numParams);
        }
        else {
            // If there are no params, just bump the offset
            off += PARAM_SZ * MAX_PARAMS;
        }
    });
    return b;
};
exports.buildAddAbiPayload = buildAddAbiPayload;
// Get the 4-byte function identifier based on the canonical name
var getFuncSig = function (f) {
    // Canonical name is:
    // funcName(paramType0, ..., paramTypeN)
    var canonicalName = "".concat(f.name, "(");
    f.inputs.forEach(function (input) {
        if (input.type.indexOf('tuple') > -1) {
            var arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);
            canonicalName += '(';
            input.components.forEach(function (c, i) {
                canonicalName += "".concat(c.type).concat(i === input.components.length - 1 ? '' : ',');
            });
            canonicalName += ")".concat(arrSuffix, ",");
        }
        else {
            canonicalName += "".concat(input.type, ",");
        }
    });
    if (f.inputs.length > 0)
        canonicalName = canonicalName.slice(0, canonicalName.length - 1);
    canonicalName += ')';
    return (0, js_sha3_1.keccak256)(canonicalName).slice(0, 8);
};
exports.getFuncSig = getFuncSig;
var unpackAbiDef = function (_def) {
    var off = 0;
    var def = {
        header: {
            sig: '',
            name: '',
            numParam: 0,
        },
        category: '',
        params: []
    };
    def.header.sig = '0x' + _def.slice(off, off + 4).toString('hex');
    off += 4;
    def.header.name = _def.slice(off, off + NAME_MAX_SZ).toString().split('\x00')[0];
    off += NAME_MAX_SZ;
    def.header.numParam = _def.readUInt8(off);
    off += 1;
    def.category = _def.slice(off, off + CATEGORY_SZ).toString().split('\x00')[0];
    off += CATEGORY_SZ;
    // Get param names
    for (var i = 0; i < MAX_PARAMS; i++) {
        if (i < def.header.numParam) {
            var param = {
                name: '',
                type: 0,
                typeName: '',
                isArray: false,
                arraySz: 0,
            };
            param.name = _def.slice(off, off + PARAM_NAME_SZ).toString().split('\x00')[0];
            def.params.push(param);
        }
        off += PARAM_NAME_SZ;
    }
    function reverseFwTypeMap(typeIdx) {
        var typeName = null;
        Object.keys(constants_1.ETH_ABI_LATTICE_FW_TYPE_MAP).forEach(function (key) {
            if (constants_1.ETH_ABI_LATTICE_FW_TYPE_MAP[key] === typeIdx) {
                typeName = key;
            }
        });
        return typeName;
    }
    // Get param info
    for (var i = 0; i < MAX_PARAMS; i++) {
        if (i < def.header.numParam) {
            def.params[i].type = _def.readUInt8(off);
            off += 1;
            def.params[i].typeName = reverseFwTypeMap(def.params[i].type);
            def.params[i].isArray = _def.readUInt8(off);
            off += 1;
            def.params[i].arraySz = _def.readUInt32LE(off);
            off += 4;
        }
    }
    return def;
};
exports.unpackAbiDef = unpackAbiDef;
//--------------------------------------
// PARSERS
//--------------------------------------
function parseEtherscanAbiDefs(_defs, skipErrors) {
    if (skipErrors === void 0) { skipErrors = false; }
    // `_defs` are `result` of the parsed response
    var defs = [];
    _defs.forEach(function (d) {
        if (d.name &&
            d.inputs &&
            d.type === 'function' &&
            d.stateMutability !== 'view' &&
            d.constant !== true) {
            try {
                var sig = (0, exports.getFuncSig)(d);
                var params = parseEtherscanAbiInputs(d.inputs);
                defs.push({
                    name: d.name,
                    sig: sig,
                    params: params,
                });
            }
            catch (err) {
                if (skipErrors === true)
                    console.error('Failed to load def:', d.name, err.toString());
                else
                    throw new Error(err);
            }
        }
    });
    return defs;
}
exports.abiParsers = {
    etherscan: parseEtherscanAbiDefs,
};
//--------------------------------------
// HELPERS
//--------------------------------------
// Parse the ABI param data into structs Lattice firmware will recognize.
function parseEtherscanAbiInputs(inputs, data, isNestedTuple) {
    if (data === void 0) { data = []; }
    if (isNestedTuple === void 0) { isNestedTuple = false; }
    var tupleParams = [];
    inputs.forEach(function (input) {
        var typeName = input.type;
        var d = { isArray: false, arraySz: 0, name: input.name };
        var openBracketIdx = typeName.indexOf('[');
        var closeBracketIdx = typeName.indexOf(']');
        var isMultiDim = typeName.split('[').length > 2;
        if (isMultiDim) {
            throw new Error('Skipping function with unsupported multidimensional array type');
        }
        else {
            if (openBracketIdx > -1 && closeBracketIdx > -1) {
                if (openBracketIdx >= closeBracketIdx) {
                    // not a valid param -- skip it
                }
                else if (openBracketIdx + 1 === closeBracketIdx) {
                    d.isArray = true;
                }
                else {
                    // Parse the array size if applicable
                    var number = parseInt(typeName.slice(openBracketIdx + 1, closeBracketIdx));
                    if (isNaN(number)) {
                        return d;
                    }
                    d.isArray = true;
                    d.arraySz = number;
                }
            }
            var singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;
            if (singularTypeName === 'tuple') {
                if (isNestedTuple === true)
                    throw new Error('Nested tuples are not supported');
                singularTypeName = "tuple".concat(input.components.length);
                tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);
            }
            d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName);
            if (!d.latticeTypeIdx)
                throw new Error("Unsupported type: ".concat(typeName));
            data.push(d);
        }
    });
    var params = data.concat(tupleParams);
    if (params.length > 18)
        throw new Error('Function has too many parameters for Lattice firmware (18 max)');
    return data.concat(tupleParams);
}
// Enum values from inside Lattice firmware
function getTypeIdxLatticeFw(type) {
    return constants_1.ETH_ABI_LATTICE_FW_TYPE_MAP[type];
}
exports.default = {
    MAX_ABI_DEFS: exports.MAX_ABI_DEFS,
    buildAddAbiPayload: exports.buildAddAbiPayload,
    getFuncSig: exports.getFuncSig,
    abiParsers: exports.abiParsers,
};

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereumAbi.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\client.js", {"./agent-base":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\agent-base.js","./is-object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\is-object.js","./request-base":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\request-base.js","./response-base":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\response-base.js","component-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superagent\lib\client.js
      return function (require, module, exports) {
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

      };
    };
  }
}, {package:"superagent",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\client.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\genericSigning.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","./index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\index.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\util.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","hash.js/lib/hash/sha":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hash.js\\lib\\hash\\sha.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\genericSigning.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncodedPayload = exports.parseGenericSigningResponse = exports.buildGenericSigningMsgRequest = void 0;
/**
Generic signing module. Any payload can be sent to the Lattice and
will be displayed in full (note that \n and \t characters will be
displayed as line breaks and tabs on the screen).

This payload should be coupled with:
* Signer's BIP44 path
* Curve on which to derive the signing key
* Hash function to use on the message
*/
var buffer_1 = require("buffer/");
var js_sha3_1 = require("js-sha3");
var sha_1 = require("hash.js/lib/hash/sha");
var constants_1 = require("./constants");
var index_1 = require("./index");
var util_1 = require("./util");
var buildGenericSigningMsgRequest = function (req) {
    var signerPath = req.signerPath, curveType = req.curveType, hashType = req.hashType, _a = req.encodingType, encodingType = _a === void 0 ? null : _a, _b = req.omitPubkey, omitPubkey = _b === void 0 ? false : _b, fwConstants = req.fwConstants;
    var extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed, genericSigning = fwConstants.genericSigning, varAddrPathSzAllowed = fwConstants.varAddrPathSzAllowed;
    var curveTypes = genericSigning.curveTypes, encodingTypes = genericSigning.encodingTypes, hashTypes = genericSigning.hashTypes, baseDataSz = genericSigning.baseDataSz, baseReqSz = genericSigning.baseReqSz;
    try {
        var _c = (0, exports.getEncodedPayload)(req.payload, encodingType, encodingTypes), encoding = _c.encoding, payloadBuf = _c.payloadBuf;
        // Sanity checks
        if (payloadBuf.length === 0) {
            throw new Error('Payload could not be handled.');
        }
        else if (!genericSigning || !extraDataFrameSz || !extraDataMaxFrames || !prehashAllowed) {
            throw new Error('Unsupported. Please update your Lattice firmware.');
        }
        else if (!(0, util_1.existsIn)(curveType, curveTypes)) {
            throw new Error('Unsupported curve type.');
        }
        else if (!(0, util_1.existsIn)(hashType, hashTypes)) {
            throw new Error('Unsupported hash type.');
        }
        // Ed25519 specific sanity checks
        if (curveType === curveTypes.ED25519) {
            if (hashType !== hashTypes.NONE) {
                throw new Error('Signing on ed25519 requires unhashed message');
            }
            signerPath.forEach(function (idx) {
                if (idx < constants_1.HARDENED_OFFSET) {
                    throw new Error('Signing on ed25519 requires all signer path indices be hardened.');
                }
            });
        }
        // Build the request buffer with metadata and then the payload to sign.
        var buf = buffer_1.Buffer.alloc(baseReqSz);
        var off = 0;
        buf.writeUInt32LE(encoding, off);
        off += 4;
        buf.writeUInt8(hashType, off);
        off += 1;
        buf.writeUInt8(curveType, off);
        off += 1;
        var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, varAddrPathSzAllowed);
        signerPathBuf.copy(buf, off);
        off += signerPathBuf.length;
        buf.writeUInt8(omitPubkey ? 1 : 0, off);
        off += 1;
        buf.writeUInt16LE(payloadBuf.length, off);
        off += 2;
        // Size of data payload that can be included in the first/base request
        var maxExpandedSz = baseDataSz + (extraDataMaxFrames * extraDataFrameSz);
        // Flow data into extraData requests if applicable
        var extraDataPayloads_1 = [];
        var prehash = null;
        if (payloadBuf.length > baseDataSz) {
            if (prehashAllowed && payloadBuf.length > maxExpandedSz) {
                // If this payload is too large to send, but the Lattice allows a prehashed message, do that
                if (hashType === hashTypes.NONE) {
                    // This cannot be done for ED25519 signing, which must sign the full message
                    throw new Error('Message too large to send and could not be prehashed (hashType=NONE).');
                }
                else if (hashType === hashTypes.KECCAK256) {
                    prehash = buffer_1.Buffer.from((0, js_sha3_1.keccak256)(payloadBuf), 'hex');
                }
                else if (hashType === hashTypes.SHA256) {
                    prehash = buffer_1.Buffer.from((0, sha_1.sha256)().update(payloadBuf).digest('hex'), 'hex');
                }
                else {
                    throw new Error('Unsupported hash type.');
                }
            }
            else {
                // Split overflow data into extraData frames
                var frames_1 = (0, util_1.splitFrames)(payloadBuf.slice(baseDataSz), extraDataFrameSz);
                frames_1.forEach(function (frame) {
                    var szLE = buffer_1.Buffer.alloc(4);
                    szLE.writeUInt32LE(frame.length, 0);
                    extraDataPayloads_1.push(buffer_1.Buffer.concat([szLE, frame]));
                });
            }
        }
        // If the message had to be prehashed, we will only copy the hash data into the request.
        // Otherwise copy as many payload bytes into the request as possible. Follow up data
        // from `frames` will come in follow up requests.
        var toCopy = prehash ? prehash : payloadBuf;
        toCopy.copy(buf, off);
        // Return all the necessary data
        return {
            payload: buf,
            extraDataPayloads: extraDataPayloads_1,
            schema: constants_1.signingSchema.GENERAL_SIGNING,
            curveType: curveType,
            omitPubkey: omitPubkey
        };
    }
    catch (err) {
        return { err: err.message };
    }
};
exports.buildGenericSigningMsgRequest = buildGenericSigningMsgRequest;
var parseGenericSigningResponse = function (res, off, curveType, omitPubkey) {
    var parsed = {
        pubkey: null,
        sig: null,
    };
    // Parse BIP44 path
    // Parse pubkey and then sig
    if (curveType === index_1.Constants.SIGNING.CURVES.SECP256K1) {
        // Handle `GpEccPubkey256_t`
        if (!omitPubkey) {
            var compression = res.readUint8(off);
            off += 1;
            if (compression === 0x02 || compression === 0x03) {
                // Compressed key - only copy x
                parsed.pubkey = buffer_1.Buffer.alloc(33);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off, off + 32).copy(parsed.pubkey, 1);
            }
            else if (compression === 0x04) {
                // Uncompressed key
                parsed.pubkey = buffer_1.Buffer.alloc(65);
                parsed.pubkey.writeUInt8(compression, 0);
                res.slice(off).copy(parsed.pubkey, 1);
            }
            else {
                throw new Error('Bad compression byte in signing response.');
            }
            off += 64;
        }
        else {
            // Skip pubkey section
            off += 65;
        }
        // Handle `GpECDSASig_t`
        parsed.sig = (0, util_1.parseDER)(res.slice(off, off + 2 + res[off + 1]));
        // Remove any leading zeros in signature components to ensure
        // the result is a 64 byte sig
        parsed.sig.r = (0, util_1.fixLen)(parsed.sig.r, 32);
        parsed.sig.s = (0, util_1.fixLen)(parsed.sig.s, 32);
    }
    else if (curveType === index_1.Constants.SIGNING.CURVES.ED25519) {
        if (!omitPubkey) {
            // Handle `GpEdDSAPubkey_t`
            parsed.pubkey = buffer_1.Buffer.alloc(32);
            res.slice(off, off + 32).copy(parsed.pubkey);
        }
        off += 32;
        // Handle `GpEdDSASig_t`
        parsed.sig = {
            r: res.slice(off, off + 32),
            s: res.slice(off + 32, off + 64),
        };
    }
    else {
        throw new Error('Unsupported curve.');
    }
    return parsed;
};
exports.parseGenericSigningResponse = parseGenericSigningResponse;
var getEncodedPayload = function (payload, encodingType, allowedEncodings) {
    var encoding = encodingType;
    if (encoding === null) {
        // If no encoding type was passed, we will display the payload as either
        // ASCII or a hex string. Determine which one of the default encodings to use.
        // If the buffer passed in is a string and is not prefixed with 0x, treat as utf8.
        // Otherwise treat it as a hex buffer.
        var isHex = buffer_1.Buffer.isBuffer(payload) ||
            (typeof payload === 'string' && payload.slice(0, 2) === '0x');
        if (!isHex && !(0, util_1.isAsciiStr)(payload, true)) {
            // If this is not '0x' prefixed but is not valid ASCII, convert to hex payload
            isHex = true;
            payload = "0x".concat(buffer_1.Buffer.from(payload).toString('hex'));
        }
        // Set encodingType to real value
        encoding = isHex ?
            index_1.Constants.SIGNING.ENCODINGS.HEX :
            index_1.Constants.SIGNING.ENCODINGS.ASCII;
    }
    // Make sure the encoding type specified is supported by firmware
    if (!(0, util_1.existsIn)(encoding, allowedEncodings)) {
        throw new Error('Encoding type not supported by Lattice firmware.');
    }
    // Build the request with the specified encoding type
    if (encoding === index_1.Constants.SIGNING.ENCODINGS.HEX ||
        encoding === index_1.Constants.SIGNING.ENCODINGS.SOLANA) {
        return {
            payloadBuf: (0, util_1.ensureHexBuffer)(payload),
            encoding: encoding,
        };
    }
    else if (encoding === index_1.Constants.SIGNING.ENCODINGS.ASCII) {
        return {
            payloadBuf: buffer_1.Buffer.from(payload),
            encoding: encoding,
        };
    }
    else {
        throw new Error('Unhandled encoding type.');
    }
};
exports.getEncodedPayload = getEncodedPayload;

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\genericSigning.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\index.js", {"./bits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\index.js","./buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\index.js","./byte":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\byte\\index.js","./integer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\index.js","./nibble":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\nibble\\index.js","./string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\string\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string = exports.nibble = exports.integer = exports.byte = exports.buffer = exports.bits = void 0;
var bits_1 = require("./bits");
exports.bits = bits_1.default;
var buffer_1 = require("./buffer");
exports.buffer = buffer_1.default;
var byte_1 = require("./byte");
exports.byte = byte_1.default;
var integer_1 = require("./integer");
exports.integer = integer_1.default;
var nibble_1 = require("./nibble");
exports.nibble = nibble_1.default;
var string_1 = require("./string");
exports.string = string_1.default;
var bitwise = { bits: bits_1.default, buffer: buffer_1.default, byte: byte_1.default, integer: integer_1.default, nibble: nibble_1.default, string: string_1.default };
exports.default = bitwise;

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereum.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\util.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js","borc":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\index.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","eth-eip712-util-browser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js","rlp-browser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp-browser\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\ethereum.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which
// does not have browser (or, by proxy, React-Native) support.
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var borc_1 = __importDefault(require("borc"));
var buffer_1 = require("buffer/");
//@ts-expect-error - This third-party package is not typed properly
var eth_eip712_util_browser_1 = require("eth-eip712-util-browser");
var js_sha3_1 = require("js-sha3");
var rlp_browser_1 = __importDefault(require("rlp-browser"));
var secp256k1_1 = __importDefault(require("secp256k1"));
var constants_1 = require("./constants");
var util_1 = require("./util");
var buildEthereumMsgRequest = function (input) {
    if (!input.payload || !input.protocol || !input.signerPath)
        throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');
    if (input.signerPath.length > 5 || input.signerPath.length < 2)
        throw new Error('Please provide a signer path with 2-5 indices');
    var req = {
        schema: constants_1.signingSchema.ETH_MSG,
        payload: null,
        input: input,
        msg: null, // Save the buffered message for later
    };
    try {
        switch (input.protocol) {
            case 'signPersonal':
                return buildPersonalSignRequest(req, input);
            case 'eip712':
                if (!input.fwConstants.eip712Supported)
                    throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.');
                return buildEIP712Request(req, input);
            default:
                throw new Error('Unsupported protocol');
        }
    }
    catch (err) {
        return { err: err.toString() };
    }
};
var validateEthereumMsgResponse = function (res, req) {
    var signer = res.signer, sig = res.sig;
    var input = req.input, msg = req.msg, _a = req.prehash, prehash = _a === void 0 ? null : _a;
    if (input.protocol === 'signPersonal') {
        // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these
        //       may be configurable in future versions
        var hash_1 = prehash
            ? prehash
            : buffer_1.Buffer.from((0, js_sha3_1.keccak256)(buffer_1.Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(hash_1, sig, signer, {
            chainId: 1,
            useEIP155: false,
        });
    }
    else if (input.protocol === 'eip712') {
        var encoded = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
        var digest = prehash ? prehash : encoded;
        // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
        return addRecoveryParam(digest, sig, signer, { useEIP155: false });
    }
    else {
        throw new Error('Unsupported protocol');
    }
};
var buildEthereumTxRequest = function (data) {
    try {
        var _a = data.chainId, chainId = _a === void 0 ? 1 : _a;
        var signerPath = data.signerPath, _b = data.eip155, eip155 = _b === void 0 ? null : _b, fwConstants = data.fwConstants, _c = data.type, type = _c === void 0 ? null : _c;
        var contractDeployKey = fwConstants.contractDeployKey, extraDataFrameSz = fwConstants.extraDataFrameSz, extraDataMaxFrames = fwConstants.extraDataMaxFrames, prehashAllowed = fwConstants.prehashAllowed;
        var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
        var MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;
        var VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed;
        // Sanity checks:
        // There are a handful of named chains we allow the user to reference (`chainIds`)
        // Custom chainIDs should be either numerical or hex strings
        if (typeof chainId !== 'number' &&
            isValidChainIdHexNumStr(chainId) === false)
            chainId = chainIds[chainId];
        // If this was not a custom chainID and we cannot find the name of it, exit
        if (!chainId)
            throw new Error('Unsupported chain ID or name');
        // Sanity check on signePath
        if (!signerPath)
            throw new Error('`signerPath` not provided');
        // Is this a contract deployment?
        if (data.to === null && !contractDeployKey) {
            throw new Error('Contract deployment not supported. Please update your Lattice firmware.');
        }
        var isDeployment = data.to === null && contractDeployKey;
        // We support eip1559 and eip2930 types (as well as legacy)
        var eip1559IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(2) > -1;
        var eip2930IsAllowed = fwConstants.allowedEthTxTypes &&
            fwConstants.allowedEthTxTypes.indexOf(1) > -1;
        var isEip1559 = eip1559IsAllowed && (type === 2 || type === 'eip1559');
        var isEip2930 = eip2930IsAllowed && (type === 1 || type === 'eip2930');
        if (type !== null && !isEip1559 && !isEip2930)
            throw new Error('Unsupported Ethereum transaction type');
        // Determine if we should use EIP155 given the chainID.
        // If we are explicitly told to use eip155, we will use it. Otherwise,
        // we will look up if the specified chainId is associated with a chain
        // that does not use EIP155 by default. Note that most do use EIP155.
        var useEIP155 = chainUsesEIP155(chainId);
        if (eip155 !== null && typeof eip155 === 'boolean') {
            useEIP155 = eip155;
        }
        else if (isEip1559 || isEip2930) {
            // Newer transaction types do not use EIP155 since the chainId is serialized
            useEIP155 = false;
        }
        // Hack for metamask, which sends value=null for 0 ETH transactions
        if (!data.value)
            data.value = 0;
        //--------------
        // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING
        //--------------
        // Ensure all fields are 0x-prefixed hex strings
        var rawTx = [];
        // Build the transaction buffer array
        var chainIdBytes = (0, util_1.ensureHexBuffer)(chainId);
        var nonceBytes = (0, util_1.ensureHexBuffer)(data.nonce);
        var gasPriceBytes = void 0;
        var gasLimitBytes = (0, util_1.ensureHexBuffer)(data.gasLimit);
        // Handle contract deployment (indicated by `to` being `null`)
        // For contract deployment we write a 20-byte key to the request
        // buffer, which gets swapped for an empty buffer in firmware.
        var toRlpElem = void 0, toBytes = void 0;
        if (isDeployment) {
            toRlpElem = buffer_1.Buffer.alloc(0);
            toBytes = (0, util_1.ensureHexBuffer)(contractDeployKey);
        }
        else {
            toRlpElem = (0, util_1.ensureHexBuffer)(data.to);
            toBytes = (0, util_1.ensureHexBuffer)(data.to);
        }
        var valueBytes = (0, util_1.ensureHexBuffer)(data.value);
        var dataBytes = (0, util_1.ensureHexBuffer)(data.data);
        if (isEip1559 || isEip2930) {
            // EIP1559 and EIP2930 transactions have a chainID field
            rawTx.push(chainIdBytes);
        }
        rawTx.push(nonceBytes);
        var maxPriorityFeePerGasBytes = void 0, maxFeePerGasBytes = void 0;
        if (isEip1559) {
            if (!data.maxPriorityFeePerGas)
                throw new Error('EIP1559 transactions must include `maxPriorityFeePerGas`');
            if (!data.maxPriorityFeePerGas)
                throw new Error('EIP1559 transactions must include `maxFeePerGas`');
            maxPriorityFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxPriorityFeePerGas);
            rawTx.push(maxPriorityFeePerGasBytes);
            maxFeePerGasBytes = (0, util_1.ensureHexBuffer)(data.maxFeePerGas);
            rawTx.push(maxFeePerGasBytes);
            // EIP1559 renamed "gasPrice" to "maxFeePerGas", but firmware still
            // uses `gasPrice` in the struct, so update that value here.
            gasPriceBytes = maxFeePerGasBytes;
        }
        else {
            // EIP1559 transactions do not have the gasPrice field
            gasPriceBytes = (0, util_1.ensureHexBuffer)(data.gasPrice);
            rawTx.push(gasPriceBytes);
        }
        rawTx.push(gasLimitBytes);
        rawTx.push(toRlpElem);
        rawTx.push(valueBytes);
        rawTx.push(dataBytes);
        // We do not currently support accessList in firmware so we need to prehash if
        // the list is non-null
        var PREHASH_FROM_ACCESS_LIST_1 = false;
        if (isEip1559 || isEip2930) {
            var accessList_1 = [];
            if (Array.isArray(data.accessList)) {
                data.accessList.forEach(function (listItem) {
                    var keys = [];
                    listItem.storageKeys.forEach(function (key) {
                        keys.push((0, util_1.ensureHexBuffer)(key));
                    });
                    accessList_1.push([(0, util_1.ensureHexBuffer)(listItem.address), keys]);
                    PREHASH_FROM_ACCESS_LIST_1 = true;
                });
            }
            rawTx.push(accessList_1);
        }
        else if (useEIP155 === true) {
            // Add empty v,r,s values for EIP155 legacy transactions
            rawTx.push(chainIdBytes); // v (which is the same as chainId in EIP155 txs)
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // r
            rawTx.push((0, util_1.ensureHexBuffer)(null)); // s
        }
        //--------------
        // 2. BUILD THE LATTICE REQUEST PAYLOAD
        //--------------
        var ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params
        var ETH_TX_EXTRA_FIELDS_SZ = 0; // Accounts for newer ETH tx types (e.g. eip1559)
        if (fwConstants.allowedEthTxTypesVersion === 1) {
            // eip1559 and eip2930
            // Add extra params and shrink the data region (extraData blocks are unaffected)
            ETH_TX_EXTRA_FIELDS_SZ = fwConstants.totalExtraEthTxDataSz;
            MAX_BASE_DATA_SZ -= ETH_TX_EXTRA_FIELDS_SZ;
        }
        var txReqPayload = buffer_1.Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);
        var off = 0;
        // 1. EIP155 switch and chainID
        //------------------
        txReqPayload.writeUInt8(Number(useEIP155), off);
        off++;
        // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger
        // chainID values. To account for these, we will put the chainID into the `data` buffer if it
        // is >=255. Values up to UINT64_MAX will be allowed.
        var chainIdBuf = void 0;
        var chainIdBufSz = 0;
        if (useChainIdBuffer(chainId) === true) {
            chainIdBuf = getChainIdBuf(chainId);
            chainIdBufSz = chainIdBuf.length;
            if (chainIdBufSz > constants_1.MAX_CHAIN_ID_BYTES)
                throw new Error('ChainID provided is too large.');
            // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer
            txReqPayload.writeUInt8(constants_1.HANDLE_LARGER_CHAIN_ID, off);
            off++;
        }
        else {
            // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer
            chainIdBuf = (0, util_1.ensureHexBuffer)(chainId);
            if (chainIdBuf.length !== 1)
                throw new Error('Error parsing chainID');
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBuf.length;
        }
        // 2. Signer Path
        //------------------
        var signerPathBuf = (0, util_1.buildSignerPathBuf)(signerPath, VAR_PATH_SZ);
        signerPathBuf.copy(txReqPayload, off);
        off += signerPathBuf.length;
        // 3. ETH TX request data
        //------------------
        if (nonceBytes.length > 4)
            throw new Error('Nonce too large');
        nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length));
        off += 4;
        if (gasPriceBytes.length > 8)
            throw new Error('Gas price too large');
        gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length));
        off += 8;
        if (gasLimitBytes.length > 4)
            throw new Error('Gas limit too large');
        gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length));
        off += 4;
        if (toBytes.length !== 20)
            throw new Error('Invalid `to` address');
        toBytes.copy(txReqPayload, off);
        off += 20;
        if (valueBytes.length > 32)
            throw new Error('Value too large');
        valueBytes.copy(txReqPayload, off + (32 - valueBytes.length));
        off += 32;
        // Extra Tx data comes before `data` in the struct
        var PREHASH_UNSUPPORTED = false;
        if (fwConstants.allowedEthTxTypesVersion === 1) {
            var extraEthTxDataSz = fwConstants.totalExtraEthTxDataSz || 0;
            // Some types may not be supported by firmware, so we will need to prehash
            if (PREHASH_FROM_ACCESS_LIST_1) {
                PREHASH_UNSUPPORTED = true;
            }
            txReqPayload.writeUInt8(PREHASH_UNSUPPORTED ? 1 : 0, off);
            off += 1;
            // EIP1559 & EIP2930 struct version
            if (isEip1559) {
                txReqPayload.writeUInt8(2, off);
                off += 1; // Eip1559 type enum value
                if (maxPriorityFeePerGasBytes.length > 8)
                    throw new Error('maxPriorityFeePerGasBytes too large');
                maxPriorityFeePerGasBytes.copy(txReqPayload, off + (8 - maxPriorityFeePerGasBytes.length));
                off += 8;
            }
            else if (isEip2930) {
                txReqPayload.writeUInt8(1, off);
                off += 1; // Eip2930 type enum value
                off += extraEthTxDataSz - 2; // Skip EIP1559 params
            }
            else {
                off += extraEthTxDataSz - 1; // Skip EIP1559 and EIP2930 params
            }
        }
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads_1 = [];
        var prehash = null;
        // Create the buffer, prefix with chainId (if needed) and add data slice
        var dataSz = dataBytes.length || 0;
        var chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;
        var dataToCopy = buffer_1.Buffer.alloc(dataSz + chainIdExtraSz);
        if (chainIdExtraSz > 0) {
            dataToCopy.writeUInt8(chainIdBufSz, 0);
            chainIdBuf.copy(dataToCopy, 1);
        }
        dataBytes.copy(dataToCopy, chainIdExtraSz);
        if (dataSz > MAX_BASE_DATA_SZ) {
            // Determine sizes and run through sanity checks
            var totalSz = dataSz + chainIdExtraSz;
            var maxSzAllowed = MAX_BASE_DATA_SZ + extraDataMaxFrames * extraDataFrameSz;
            if (prehashAllowed && totalSz > maxSzAllowed) {
                // If this payload is too large to send, but the Lattice allows a prehashed message, do that
                prehash = buffer_1.Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
            }
            else {
                if (!EXTRA_DATA_ALLOWED ||
                    (EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed))
                    throw new Error("Data field too large (got ".concat(dataBytes.length, "; must be <=").concat(maxSzAllowed - chainIdExtraSz, " bytes)"));
                // Split overflow data into extraData frames
                var frames_1 = (0, util_1.splitFrames)(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);
                frames_1.forEach(function (frame) {
                    var szLE = buffer_1.Buffer.alloc(4);
                    szLE.writeUInt32LE(frame.length, 0);
                    extraDataPayloads_1.push(buffer_1.Buffer.concat([szLE, frame]));
                });
            }
        }
        else if (PREHASH_UNSUPPORTED) {
            // If something is unsupported in firmware but we want to allow such transactions,
            // we prehash the message here.
            prehash = buffer_1.Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(rawTx, type)), 'hex');
        }
        // Write the data size (does *NOT* include the chainId buffer, if that exists)
        txReqPayload.writeUInt16BE(dataBytes.length, off);
        off += 2;
        // Copy in the chainId buffer if needed
        if (chainIdBufSz > 0) {
            txReqPayload.writeUInt8(chainIdBufSz, off);
            off++;
            chainIdBuf.copy(txReqPayload, off);
            off += chainIdBufSz;
        }
        // Copy the first slice of the data itself. If this payload has been pre-hashed, include it
        // in the `data` field. This will result in a different Lattice screen being drawn.
        if (prehash) {
            prehash.copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        else {
            dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off);
            off += MAX_BASE_DATA_SZ;
        }
        return {
            rawTx: rawTx,
            type: type,
            payload: txReqPayload.slice(0, off),
            extraDataPayloads: extraDataPayloads_1,
            schema: constants_1.signingSchema.ETH_TRANSFER,
            chainId: chainId,
            useEIP155: useEIP155,
            signerPath: signerPath,
        };
    }
    catch (err) {
        return { err: err.message };
    }
};
// From ethereumjs-util
function stripZeros(a) {
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
// Given a 64-byte signature [r,s] we need to figure out the v value
// and attah the full signature to the end of the transaction payload
var buildEthRawTx = function (tx, sig, address) {
    // RLP-encode the data we sent to the lattice
    var hash = buffer_1.Buffer.from((0, js_sha3_1.keccak256)(get_rlp_encoded_preimage(tx.rawTx, tx.type)), 'hex');
    var newSig = addRecoveryParam(hash, sig, address, tx);
    // Use the signature to generate a new raw transaction payload
    // Strip the last 3 items and replace them with signature components
    var newRawTx = tx.useEIP155 ? tx.rawTx.slice(0, -3) : tx.rawTx;
    newRawTx.push(newSig.v);
    // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros
    // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187
    newRawTx.push(stripZeros(newSig.r));
    newRawTx.push(stripZeros(newSig.s));
    var rlpEncodedWithSig = rlp_browser_1.default.encode(newRawTx);
    if (tx.type) {
        rlpEncodedWithSig = buffer_1.Buffer.concat([
            buffer_1.Buffer.from([tx.type]),
            rlpEncodedWithSig,
        ]);
    }
    return { rawTx: rlpEncodedWithSig.toString('hex'), sigWithV: newSig };
};
// Attach a recovery parameter to a signature by brute-forcing ECRecover
function addRecoveryParam(hashBuf, sig, address, txData) {
    if (txData === void 0) { txData = {}; }
    try {
        // Rebuild the keccak256 hash here so we can `ecrecover`
        var hash_2 = new Uint8Array(hashBuf);
        var v = 0;
        // Fix signature componenet lengths to 32 bytes each
        var r = (0, util_1.fixLen)(sig.r, 32);
        sig.r = r;
        var s = (0, util_1.fixLen)(sig.s, 32);
        sig.s = s;
        // Calculate the recovery param
        var rs = new Uint8Array(buffer_1.Buffer.concat([r, s]));
        var pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        // If the first `v` value is a match, return the sig!
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        // Otherwise, try the other `v` value
        v = 1;
        pubkey = secp256k1_1.default.ecdsaRecover(rs, v, hash_2, false).slice(1);
        if (pubToAddrStr(pubkey) === address.toString('hex')) {
            sig.v = getRecoveryParam(v, txData);
            return sig;
        }
        else {
            // If neither is a match, we should return an error
            throw new Error('Invalid Ethereum signature returned.');
        }
    }
    catch (err) {
        throw new Error(err);
    }
}
// Convert an RLP-serialized transaction (plus signature) into a transaction hash
var hashTransaction = function (serializedTx) {
    return (0, js_sha3_1.keccak256)(buffer_1.Buffer.from(serializedTx, 'hex'));
};
// Returns address string given public key buffer
function pubToAddrStr(pub) {
    return (0, js_sha3_1.keccak256)(pub).slice(-40);
}
// Convert a 0/1 `v` into a recovery param:
// * For non-EIP155 transactions, return `27 + v`
// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`
function getRecoveryParam(v, txData) {
    if (txData === void 0) { txData = {}; }
    var chainId = txData.chainId, useEIP155 = txData.useEIP155, type = txData.type;
    // For EIP1559 and EIP2930 transactions, we want the recoveryParam (0 or 1)
    // rather than the `v` value because the `chainId` is already included in the
    // transaction payload.
    if (type === 1 || type === 2) {
        return (0, util_1.ensureHexBuffer)(v, true); // 0 or 1, with 0 expected as an empty buffer
    }
    else if (false === useEIP155 || chainId === null) {
        // For ETH messages and non-EIP155 chains the set should be [27, 28] for `v`
        return buffer_1.Buffer.from(new bignumber_js_1.default(v).plus(27).toString(16), 'hex');
    }
    // We will use EIP155 in most cases. Convert v to a bignum and operate on it.
    // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36
    // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1
    // so we add 35 to that.
    var chainIdBuf = getChainIdBuf(chainId);
    var chainIdBN = new bignumber_js_1.default(chainIdBuf.toString('hex'), 16);
    return (0, util_1.ensureHexBuffer)("0x".concat(chainIdBN.times(2).plus(35).plus(v).toString(16)));
}
var chainIds = {
    mainnet: 1,
    roptsten: 3,
    rinkeby: 4,
    kovan: 42,
    goerli: 5,
};
// Get a buffer containing the chainId value.
// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian
function getChainIdBuf(chainId) {
    var b;
    // If our chainID is a hex string, we can convert it to a hex
    // buffer directly
    if (true === isValidChainIdHexNumStr(chainId))
        b = (0, util_1.ensureHexBuffer)(chainId);
    // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer
    else
        b = (0, util_1.ensureHexBuffer)("0x".concat(new bignumber_js_1.default(chainId).toString(16)));
    // Make sure the buffer is an allowed size
    if (b.length > 8)
        throw new Error('ChainID provided is too large.');
    // If this matches a u16, u32, or u64 size, return it now
    if (b.length <= 2 || b.length === 4 || b.length === 8)
        return b;
    // For other size buffers, we need to pack into u32 or u64 before returning;
    var buf;
    if (b.length === 3) {
        buf = buffer_1.Buffer.alloc(4);
        buf.writeUInt32BE(chainId);
    }
    else if (b.length <= 8) {
        buf = buffer_1.Buffer.alloc(8);
        b.copy(buf, 8 - b.length);
    }
    return buf;
}
// Determine if the chain uses EIP155 by default, based on the chainID
function chainUsesEIP155(chainID) {
    switch (chainID) {
        case 3: // ropsten
        case 4: // rinkeby
            return false;
        case 1: // mainnet
        case 42: // kovan
        case 5: // goerli
        default:
            // all others should use eip155
            return true;
    }
}
// Determine if a valid number was passed in as a hex string
function isValidChainIdHexNumStr(s) {
    if (typeof s !== 'string')
        return false;
    if (s.slice(0, 2) !== '0x')
        return false;
    try {
        var b = new bignumber_js_1.default(s, 16);
        return b.isNaN() === false;
    }
    catch (err) {
        return false;
    }
}
// If this is a nubmer that fits in one byte, we don't need to add it
// to the `data` buffer of the main transaction.
// Note the one edge case: we still need to use the `data` field for chainID=255.
function useChainIdBuffer(id) {
    var buf = getChainIdBuf(id);
    if (buf.length === 1)
        return buf.readUInt8(0) === 255;
    return true;
}
function buildPersonalSignRequest(req, input) {
    var MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;
    var VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;
    var L = 24 + MAX_BASE_MSG_SZ + 4;
    var off = 0;
    req.payload = buffer_1.Buffer.alloc(L);
    req.payload.writeUInt8(constants_1.ethMsgProtocol.SIGN_PERSONAL, 0);
    off += 1;
    // Write the signer path into the buffer
    var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, VAR_PATH_SZ);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Write the payload buffer. The payload can come in either as a buffer or as a string
    var payload = input.payload;
    // Determine if this is a hex string
    var displayHex = false;
    if (typeof input.payload === 'string') {
        if (input.payload.slice(0, 2) === '0x') {
            payload = (0, util_1.ensureHexBuffer)(input.payload);
            displayHex =
                false ===
                    constants_1.ASCII_REGEX.test(buffer_1.Buffer.from(input.payload.slice(2), 'hex').toString());
        }
        else {
            if (false === (0, util_1.isAsciiStr)(input.payload))
                throw new Error('Currently, the Lattice can only display ASCII strings.');
            payload = buffer_1.Buffer.from(input.payload);
        }
    }
    else if (typeof input.displayHex === 'boolean') {
        // If this is a buffer and the user has specified whether or not this
        // is a hex buffer with the optional argument, write that
        displayHex = input.displayHex;
    }
    else {
        // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.
        // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER
        //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING
        // TODO: Develop a more elegant solution for this
        if (!input.payload.toString)
            throw new Error('Unsupported input data type');
        displayHex = false === constants_1.ASCII_REGEX.test(input.payload.toString());
    }
    var fwConst = input.fwConstants;
    var maxSzAllowed = MAX_BASE_MSG_SZ + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
    if (fwConst.personalSignHeaderSz) {
        // Account for the personal_sign header string
        maxSzAllowed -= fwConst.personalSignHeaderSz;
    }
    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {
        // If this message will not fit and pre-hashing is allowed, do that
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        var prehash = buffer_1.Buffer.from((0, js_sha3_1.keccak256)(buffer_1.Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');
        prehash.copy(req.payload, off);
        req.prehash = prehash;
    }
    else {
        // Otherwise we can fit the payload.
        // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable
        var extraDataPayloads = getExtraData(payload, input);
        // Write the payload and metadata into our buffer
        req.extraDataPayloads = extraDataPayloads;
        req.msg = payload;
        req.payload.writeUInt8(displayHex, off);
        off += 1;
        req.payload.writeUInt16LE(payload.length, off);
        off += 2;
        payload.copy(req.payload, off);
    }
    return req;
}
function buildEIP712Request(req, input) {
    try {
        var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, varAddrPathSzAllowed = _a.varAddrPathSzAllowed, eip712MaxTypeParams_1 = _a.eip712MaxTypeParams;
        var TYPED_DATA = constants_1.ethMsgProtocol.TYPED_DATA;
        var L = 24 + ethMaxMsgSz + 4;
        var off = 0;
        req.payload = buffer_1.Buffer.alloc(L);
        req.payload.writeUInt8(TYPED_DATA.enumIdx, 0);
        off += 1;
        // Write the signer path
        var signerPathBuf = (0, util_1.buildSignerPathBuf)(input.signerPath, varAddrPathSzAllowed);
        signerPathBuf.copy(req.payload, off);
        off += signerPathBuf.length;
        // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload
        var data_1 = JSON.parse(JSON.stringify(input.payload));
        if (!data_1.primaryType || !data_1.types[data_1.primaryType])
            throw new Error('primaryType must be specified and the type must be included.');
        if (!data_1.message || !data_1.domain)
            throw new Error('message and domain must be specified.');
        if (0 > Object.keys(data_1.types).indexOf('EIP712Domain'))
            throw new Error('EIP712Domain type must be defined.');
        // Parse the payload to ensure we have valid EIP712 data types and that
        // they are encoded such that Lattice firmware can parse them.
        // We need two different encodings: one to send to the Lattice in a format that plays
        // nicely with our firmware CBOR decoder. The other is formatted to be consumable by
        // our EIP712 validation module.
        input.payload.message = parseEIP712Msg(JSON.parse(JSON.stringify(data_1.message)), JSON.parse(JSON.stringify(data_1.primaryType)), JSON.parse(JSON.stringify(data_1.types)), true);
        input.payload.domain = parseEIP712Msg(JSON.parse(JSON.stringify(data_1.domain)), 'EIP712Domain', JSON.parse(JSON.stringify(data_1.types)), true);
        data_1.domain = parseEIP712Msg(data_1.domain, 'EIP712Domain', data_1.types, false);
        data_1.message = parseEIP712Msg(data_1.message, data_1.primaryType, data_1.types, false);
        // Now build the message to be sent to the Lattice
        var payload = buffer_1.Buffer.from(borc_1.default.encode(data_1));
        var fwConst = input.fwConstants;
        var maxSzAllowed = ethMaxMsgSz + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;
        // Determine if we need to prehash
        var shouldPrehash_1 = payload.length > maxSzAllowed;
        Object.keys(data_1.types).forEach(function (k) {
            if (data_1.types[k].length > eip712MaxTypeParams_1) {
                shouldPrehash_1 = true;
            }
        });
        if (fwConst.ethMsgPreHashAllowed && shouldPrehash_1) {
            // If this payload is too large to send, but the Lattice allows a prehashed message, do that
            req.payload.writeUInt16LE(payload.length, off);
            off += 2;
            var prehash = eth_eip712_util_browser_1.TypedDataUtils.hash(req.input.payload);
            prehash.copy(req.payload, off);
            req.prehash = prehash;
        }
        else {
            var extraDataPayloads = getExtraData(payload, input);
            req.extraDataPayloads = extraDataPayloads;
            req.payload.writeUInt16LE(payload.length, off);
            off += 2;
            payload.copy(req.payload, off);
            off += payload.length;
            // Slice out the part of the buffer that we didn't use.
            req.payload = req.payload.slice(0, off);
        }
        return req;
    }
    catch (err) {
        return { err: "Failed to build EIP712 request: ".concat(err.message) };
    }
}
function getExtraData(payload, input) {
    var _a = input.fwConstants, ethMaxMsgSz = _a.ethMaxMsgSz, extraDataFrameSz = _a.extraDataFrameSz, extraDataMaxFrames = _a.extraDataMaxFrames;
    var MAX_BASE_MSG_SZ = ethMaxMsgSz;
    var EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
    var extraDataPayloads = [];
    if (payload.length > MAX_BASE_MSG_SZ) {
        // Determine sizes and run through sanity checks
        var maxSzAllowed = MAX_BASE_MSG_SZ + extraDataMaxFrames * extraDataFrameSz;
        if (!EXTRA_DATA_ALLOWED)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(MAX_BASE_MSG_SZ));
        else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed)
            throw new Error("Your message is ".concat(payload.length, " bytes, but can only be a maximum of ").concat(maxSzAllowed));
        // Split overflow data into extraData frames
        var frames_2 = (0, util_1.splitFrames)(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);
        frames_2.forEach(function (frame) {
            var szLE = buffer_1.Buffer.alloc(4);
            szLE.writeUInt32LE(frame.length, 0);
            extraDataPayloads.push(buffer_1.Buffer.concat([szLE, frame]));
        });
    }
    return extraDataPayloads;
}
function parseEIP712Msg(msg, typeName, types, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    try {
        var type = types[typeName];
        type.forEach(function (item) {
            var isArrayType = item.type.indexOf('[') > -1;
            var singularType = isArrayType
                ? item.type.slice(0, item.type.indexOf('['))
                : item.type;
            var isCustomType = Object.keys(types).indexOf(singularType) > -1;
            if (isCustomType && Array.isArray(msg)) {
                // For custom types we need to jump into the `msg` using the key (name of type) and
                // parse that entire sub-struct as if it were a message.
                // We will recurse into sub-structs until we reach a level where every item is an
                // elementary (i.e. non-custom) type.
                // For arrays, we need to loop through each message item.
                for (var i = 0; i < msg.length; i++) {
                    msg[i][item.name] = parseEIP712Msg(msg[i][item.name], singularType, types, forJSParser);
                }
            }
            else if (isCustomType) {
                // Not an array means we can jump directly into the sub-struct to convert
                msg[item.name] = parseEIP712Msg(msg[item.name], singularType, types, forJSParser);
            }
            else if (Array.isArray(msg)) {
                // If we have an array for this particular type and the type we are parsing
                // is *not* a custom type, loop through the array elements and convert the types.
                for (var i = 0; i < msg.length; i++) {
                    if (isArrayType) {
                        // If this type is itself an array, loop through those elements and parse individually.
                        // This code is not reachable for custom types so we assume these are arrays of
                        // elementary types.
                        for (var j = 0; j < msg[i][item.name].length; j++) {
                            msg[i][item.name][j] = parseEIP712Item(msg[i][item.name][j], singularType, forJSParser);
                        }
                    }
                    else {
                        // Non-arrays parse + replace one value for the elementary type
                        msg[i][item.name] = parseEIP712Item(msg[i][item.name], singularType, forJSParser);
                    }
                }
            }
            else if (isArrayType) {
                // If we have an elementary array type and a non-array message level,
                //loop through the array and parse + replace  each item individually.
                for (var i = 0; i < msg[item.name].length; i++) {
                    msg[item.name][i] = parseEIP712Item(msg[item.name][i], singularType, forJSParser);
                }
            }
            else {
                // If this is a singular elementary type, simply parse + replace.
                msg[item.name] = parseEIP712Item(msg[item.name], singularType, forJSParser);
            }
        });
    }
    catch (err) {
        throw new Error(err.message);
    }
    return msg;
}
function parseEIP712Item(data, type, forJSParser) {
    if (forJSParser === void 0) { forJSParser = false; }
    if (type === 'bytes') {
        // Variable sized bytes need to be buffer type
        data = (0, util_1.ensureHexBuffer)(data);
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type.slice(0, 5) === 'bytes') {
        // Fixed sizes bytes need to be buffer type. We also add some sanity checks.
        var nBytes = parseInt(type.slice(5));
        data = (0, util_1.ensureHexBuffer)(data);
        if (data.length !== nBytes)
            throw new Error("Expected ".concat(type, " type, but got ").concat(data.length, " bytes"));
        if (forJSParser) {
            // For EIP712 encoding module it's easier to encode hex strings
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (type === 'address') {
        // Address must be a 20 byte buffer
        data = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle the 0-address
        if (data.length === 0) {
            data = buffer_1.Buffer.alloc(20);
        }
        if (data.length !== 20)
            throw new Error("Address type must be 20 bytes, but got ".concat(data.length, " bytes"));
        // For EIP712 encoding module it's easier to encode hex strings
        if (forJSParser) {
            data = "0x".concat(data.toString('hex'));
        }
    }
    else if (constants_1.ethMsgProtocol.TYPED_DATA.typeCodes[type] &&
        (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {
        var b = (0, util_1.ensureHexBuffer)(data);
        // Edge case to handle 0-value bignums
        if (b.length === 0) {
            b = buffer_1.Buffer.from('00', 'hex');
        }
        // Uint256s should be encoded as bignums.
        if (forJSParser) {
            // For EIP712 encoding in this module we need strings to represent the numbers
            data = "0x".concat(b.toString('hex'));
        }
        else {
            // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays
            // nicely with its firmware cbor lib.
            // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates
            // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure
            // we are creating a compatible type.
            // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser
            // context. This is surprisingly difficult - I tried several libs and only cbor/borc have
            // worked (borc is a supposedly "browser compatible" version of cbor)
            data = new borc_1.default.Encoder().semanticTypes[1][0](b.toString('hex'), 16);
        }
    }
    else if (type === 'bool') {
        // Booleans need to be cast to a u8
        data = data === true ? 1 : 0;
    }
    // Other types don't need to be modified
    return data;
}
function get_personal_sign_prefix(L) {
    return buffer_1.Buffer.from("\u0019Ethereum Signed Message:\n".concat(L.toString()), 'utf-8');
}
function get_rlp_encoded_preimage(rawTx, txType) {
    if (txType) {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([txType]), rlp_browser_1.default.encode(rawTx)]);
    }
    else {
        return rlp_browser_1.default.encode(rawTx);
    }
}
exports.default = {
    buildEthereumMsgRequest: buildEthereumMsgRequest,
    validateEthereumMsgResponse: validateEthereumMsgResponse,
    buildEthereumTxRequest: buildEthereumTxRequest,
    buildEthRawTx: buildEthRawTx,
    hashTransaction: hashTransaction,
    chainIds: chainIds,
    ensureHexBuffer: util_1.ensureHexBuffer,
};

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\ethereum.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\bitcoin.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\constants.js","bech32":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js","bs58check":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58check\\index.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js","hash.js/lib/hash/ripemd":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hash.js\\lib\\hash\\ripemd.js","hash.js/lib/hash/sha":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hash.js\\lib\\hash\\sha.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\dist\bitcoin.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Util for Bitcoin-specific functionality
var bech32_1 = require("bech32");
var bs58check_1 = __importDefault(require("bs58check"));
var buffer_1 = require("buffer/");
var ripemd_1 = require("hash.js/lib/hash/ripemd");
var sha_1 = require("hash.js/lib/hash/sha");
var constants_1 = require("./constants");
var DEFAULT_SEQUENCE = 0xffffffff;
var DEFAULT_SIGHASH_BUFFER = buffer_1.Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01
var PURPOSES = constants_1.BIP_CONSTANTS.PURPOSES, COINS = constants_1.BIP_CONSTANTS.COINS;
var OP = {
    ZERO: 0x00,
    HASH160: 0xa9,
    DUP: 0x76,
    EQUAL: 0x87,
    EQUALVERIFY: 0x88,
    CHECKSIG: 0xac,
};
var SEGWIT_V0 = 0x00;
var SEGWIT_NATIVE_V0_PREFIX = 'bc';
var SEGWIT_NATIVE_V0_TESTNET_PREFIX = 'tb';
var FMT_SEGWIT_NATIVE_V0 = 0xd0;
var FMT_SEGWIT_NATIVE_V0_TESTNET = 0xf0;
var FMT_SEGWIT_WRAPPED = 0x05;
var FMT_SEGWIT_WRAPPED_TESTNET = 0xc4;
var FMT_LEGACY = 0x00;
var FMT_LEGACY_TESTNET = 0x6f;
var BTC_SCRIPT_TYPE_P2PKH = 0x01;
var BTC_SCRIPT_TYPE_P2SH_P2WPKH = 0x03;
var BTC_SCRIPT_TYPE_P2WPKH_V0 = 0x04;
// We need to build two different objects here:
// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction
//    with the returned signatures to build and serialize the transaction before
//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones
//    we get from the Lattice
// 2. The serialized Lattice request, which includes data (outlined in the specification)
//    that is needed to sign all of the inputs and build a change output.
// @inputs (contained in `data`)
// `prevOuts`: an array of objects with the following properties:
//           a. txHash
//           b. value
//           c. index          -- the index of the output in the transaction
//           d. signerPath -- the path of the address in our wallet that is signing this input
// `recipient`: Receiving address, which must be converted to a pubkeyhash
// `value`:     Number of satoshis to send the recipient
// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)
//              already based on the number of inputs plus two outputs
// `version`:   Transaction version of the inputs. All inputs must be of the same version!
// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb
var buildBitcoinTxRequest = function (data) {
    try {
        var prevOuts = data.prevOuts, recipient = data.recipient, value = data.value, changePath = data.changePath, fee = data.fee;
        if (!changePath)
            throw new Error('No changePath provided.');
        if (changePath.length !== 5)
            throw new Error('Please provide a full change path.');
        // Serialize the request
        var payload_1 = buffer_1.Buffer.alloc(59 + 69 * prevOuts.length);
        var off_1 = 0;
        // Change version byte (a.k.a. address format byte)
        var changeFmt = getAddressFormat(changePath);
        payload_1.writeUInt8(changeFmt, 0);
        off_1++;
        // Build the change data
        payload_1.writeUInt32LE(changePath.length, off_1);
        off_1 += 4;
        for (var i = 0; i < changePath.length; i++) {
            payload_1.writeUInt32LE(changePath[i], off_1);
            off_1 += 4;
        }
        // Fee is a param
        payload_1.writeUInt32LE(fee, off_1);
        off_1 += 4;
        var dec = decodeAddress(recipient);
        // Parameterize the recipient output
        payload_1.writeUInt8(dec.versionByte, off_1);
        off_1++;
        dec.pkh.copy(payload_1, off_1);
        off_1 += dec.pkh.length;
        writeUInt64LE(value, payload_1, off_1);
        off_1 += 8;
        // Build the inputs from the previous outputs
        payload_1.writeUInt8(prevOuts.length, off_1);
        off_1++;
        var inputSum_1 = 0;
        prevOuts.forEach(function (input) {
            if (!input.signerPath || input.signerPath.length !== 5) {
                throw new Error('Full recipient path not specified ');
            }
            payload_1.writeUInt32LE(input.signerPath.length, off_1);
            off_1 += 4;
            for (var i = 0; i < input.signerPath.length; i++) {
                payload_1.writeUInt32LE(input.signerPath[i], off_1);
                off_1 += 4;
            }
            payload_1.writeUInt32LE(input.index, off_1);
            off_1 += 4;
            writeUInt64LE(input.value, payload_1, off_1);
            off_1 += 8;
            inputSum_1 += input.value;
            var scriptType = getScriptType(input);
            payload_1.writeUInt8(scriptType, off_1);
            off_1++;
            if (!buffer_1.Buffer.isBuffer(input.txHash))
                input.txHash = buffer_1.Buffer.from(input.txHash, 'hex');
            input.txHash.copy(payload_1, off_1);
            off_1 += input.txHash.length;
        });
        // Send them back!
        return {
            payload: payload_1,
            schema: constants_1.signingSchema.BTC_TRANSFER,
            origData: data,
            changeData: {
                // This data helps fill in the change output
                value: inputSum_1 - (value + fee),
            },
        };
    }
    catch (err) {
        return { err: err };
    }
};
// Serialize a transaction consisting of inputs, outputs, and some
// metadata
// -- inputs  = { hash, index, sig, pubkey }
// -- outputs = { value, recipient }  // expects an address string for `recipient`
// -- isSegwitSpend = true if the inputs are being spent using segwit
//                    (NOTE: either ALL are being spent, or none are)
// -- lockTime = Will probably always be 0
var serializeTx = function (data) {
    var inputs = data.inputs, outputs = data.outputs, _a = data.lockTime, lockTime = _a === void 0 ? 0 : _a;
    var payload = buffer_1.Buffer.alloc(4);
    var off = 0;
    // Always use version 2
    var version = 2;
    var useWitness = needsWitness(inputs);
    payload.writeUInt32LE(version, off);
    off += 4;
    if (useWitness) {
        payload = concat(payload, buffer_1.Buffer.from('00', 'hex')); // marker = 0x00
        payload = concat(payload, buffer_1.Buffer.from('01', 'hex')); // flag = 0x01
    }
    // Serialize signed inputs
    var numInputs = getVarInt(inputs.length);
    payload = concat(payload, numInputs);
    off += numInputs.length;
    inputs.forEach(function (input) {
        payload = concat(payload, input.hash.reverse());
        off += input.hash.length;
        var index = getU32LE(input.index);
        payload = concat(payload, index);
        off += index.length;
        var scriptType = getScriptType(input);
        // Build the sigScript. Note that p2wpkh does not have a scriptSig.
        if (scriptType === BTC_SCRIPT_TYPE_P2SH_P2WPKH) {
            // Build a vector (varSlice of varSlice) containing the redeemScript
            var redeemScript = buildRedeemScript(input.pubkey);
            var redeemScriptLen = getVarInt(redeemScript.length);
            var slice = buffer_1.Buffer.concat([redeemScriptLen, redeemScript]);
            var sliceLen = getVarInt(slice.length);
            payload = concat(payload, sliceLen);
            off += sliceLen.length;
            payload = concat(payload, slice);
            off += slice.length;
        }
        else if (scriptType === BTC_SCRIPT_TYPE_P2PKH) {
            // Build the signature + pubkey script to spend this input
            var slice = buildSig(input.sig, input.pubkey);
            payload = concat(payload, slice);
            off += slice.length;
        }
        else if (scriptType === BTC_SCRIPT_TYPE_P2WPKH_V0) {
            var emptyScript = buffer_1.Buffer.from('00', 'hex');
            payload = concat(payload, emptyScript);
            off += 1;
        }
        // Use the default sequence for all transactions
        var sequence = getU32LE(DEFAULT_SEQUENCE);
        payload = concat(payload, sequence);
        off += sequence.length;
    });
    // Serialize outputs
    var numOutputs = getVarInt(outputs.length);
    payload = concat(payload, numOutputs);
    off += numOutputs.length;
    outputs.forEach(function (output) {
        var value = getU64LE(output.value);
        payload = concat(payload, value);
        off += value.length;
        // Build the output locking script and write it as a var slice
        var script = buildLockingScript(output.recipient);
        var scriptLen = getVarInt(script.length);
        payload = concat(payload, scriptLen);
        off += scriptLen.length;
        payload = concat(payload, script);
        off += script.length;
    });
    // Add witness data if needed
    if (useWitness) {
        var sigs = [];
        var pubkeys = [];
        for (var i = 0; i < inputs.length; i++) {
            sigs.push(inputs[i].sig);
            pubkeys.push(inputs[i].pubkey);
        }
        var witnessSlice = buildWitness(sigs, pubkeys);
        payload = concat(payload, witnessSlice);
        off += witnessSlice.length;
    }
    // Finish with locktime
    return buffer_1.Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');
};
// Convert a pubkeyhash to a bitcoin base58check address with a version byte
var getBitcoinAddress = function (pubkeyhash, version) {
    var bech32Prefix = null;
    var bech32Version = null;
    if (version === FMT_SEGWIT_NATIVE_V0) {
        bech32Prefix = SEGWIT_NATIVE_V0_PREFIX;
        bech32Version = SEGWIT_V0;
    }
    else if (version === FMT_SEGWIT_NATIVE_V0_TESTNET) {
        bech32Prefix = SEGWIT_NATIVE_V0_TESTNET_PREFIX;
        bech32Version = SEGWIT_V0;
    }
    if (bech32Prefix !== null && bech32Version !== null) {
        var words = bech32_1.bech32.toWords(pubkeyhash);
        words.unshift(bech32Version);
        return bech32_1.bech32.encode(bech32Prefix, words);
    }
    else {
        return bs58check_1.default.encode(buffer_1.Buffer.concat([buffer_1.Buffer.from([version]), pubkeyhash]));
    }
};
// Builder utils
//-----------------------
function buildRedeemScript(pubkey) {
    var redeemScript = buffer_1.Buffer.alloc(22);
    var shaHash = buffer_1.Buffer.from((0, sha_1.sha256)().update(pubkey).digest('hex'), 'hex');
    var pubkeyhash = buffer_1.Buffer.from((0, ripemd_1.ripemd160)().update(shaHash).digest('hex'), 'hex');
    redeemScript.writeUInt8(OP.ZERO, 0);
    redeemScript.writeUInt8(pubkeyhash.length, 1);
    pubkeyhash.copy(redeemScript, 2);
    return redeemScript;
}
// Var slice of signature + var slice of pubkey
function buildSig(sig, pubkey) {
    sig = buffer_1.Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER]);
    var sigLen = getVarInt(sig.length);
    var pubkeyLen = getVarInt(pubkey.length);
    var slice = buffer_1.Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);
    var len = getVarInt(slice.length);
    return buffer_1.Buffer.concat([len, slice]);
}
// Witness is written as a "vector", which is a list of varSlices
// prefixed by the number of items
function buildWitness(sigs, pubkeys) {
    var witness = buffer_1.Buffer.alloc(0);
    // Two items in each vector (sig, pubkey)
    var len = buffer_1.Buffer.alloc(1);
    len.writeUInt8(2, 0);
    for (var i = 0; i < sigs.length; i++) {
        var sig = buffer_1.Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);
        var sigLen = getVarInt(sig.length);
        var pubkey = pubkeys[i];
        var pubkeyLen = getVarInt(pubkey.length);
        witness = buffer_1.Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);
    }
    return witness;
}
// Locking script buiders
//-----------------------
function buildLockingScript(address) {
    var dec = decodeAddress(address);
    switch (dec.versionByte) {
        case FMT_SEGWIT_NATIVE_V0:
        case FMT_SEGWIT_NATIVE_V0_TESTNET:
            return buildP2wpkhLockingScript(dec.pkh);
        case FMT_SEGWIT_WRAPPED:
        case FMT_SEGWIT_WRAPPED_TESTNET:
            return buildP2shLockingScript(dec.pkh);
        case FMT_LEGACY:
        case FMT_LEGACY_TESTNET:
            return buildP2pkhLockingScript(dec.pkh);
        default:
            throw new Error("Unknown version byte: ".concat(dec.versionByte, ". Cannot build BTC transaction."));
    }
}
function buildP2pkhLockingScript(pubkeyhash) {
    var out = buffer_1.Buffer.alloc(5 + pubkeyhash.length);
    var off = 0;
    out.writeUInt8(OP.DUP, off);
    off++;
    out.writeUInt8(OP.HASH160, off);
    off++;
    out.writeUInt8(pubkeyhash.length, off);
    off++;
    pubkeyhash.copy(out, off);
    off += pubkeyhash.length;
    out.writeUInt8(OP.EQUALVERIFY, off);
    off++;
    out.writeUInt8(OP.CHECKSIG, off);
    off++;
    return out;
}
function buildP2shLockingScript(pubkeyhash) {
    var out = buffer_1.Buffer.alloc(3 + pubkeyhash.length);
    var off = 0;
    out.writeUInt8(OP.HASH160, off);
    off++;
    out.writeUInt8(pubkeyhash.length, off);
    off++;
    pubkeyhash.copy(out, off);
    off += pubkeyhash.length;
    out.writeUInt8(OP.EQUAL, off);
    off++;
    return out;
}
function buildP2wpkhLockingScript(pubkeyhash) {
    var out = buffer_1.Buffer.alloc(2 + pubkeyhash.length);
    out.writeUInt8(OP.ZERO, 0);
    out.writeUInt8(pubkeyhash.length, 1);
    pubkeyhash.copy(out, 2);
    return out;
}
// Static Utils
//----------------------
function concat(base, addition) {
    return buffer_1.Buffer.concat([base, addition]);
}
function getU64LE(x) {
    var buffer = buffer_1.Buffer.alloc(8);
    writeUInt64LE(x, buffer, 0);
    return buffer;
}
function getU32LE(x) {
    var buffer = buffer_1.Buffer.alloc(4);
    buffer.writeUInt32LE(x, 0);
    return buffer;
}
function getVarInt(x) {
    var buffer;
    if (x < 0xfd) {
        buffer = buffer_1.Buffer.alloc(1);
        buffer.writeUInt8(x, 0);
    }
    else if (x <= 0xffff) {
        buffer = buffer_1.Buffer.alloc(3);
        buffer.writeUInt8(0xfd, 0);
        buffer.writeUInt16LE(x, 1);
    }
    else if (x < 0xffffffff) {
        buffer = buffer_1.Buffer.alloc(5);
        buffer.writeUInt8(0xfe, 0);
        buffer.writeUInt32LE(x, 1);
    }
    else {
        buffer = buffer_1.Buffer.alloc(9);
        buffer.writeUInt8(0xff, 0);
        buffer.writeUInt32LE(x >>> 0, 1);
        buffer.writeUInt32LE((x / 0x100000000) | 0, 5);
    }
    return buffer;
}
function writeUInt64LE(n, buf, off) {
    if (typeof n === 'number')
        n = n.toString(16);
    var preBuf = buffer_1.Buffer.alloc(8);
    var nStr = n.length % 2 === 0 ? n.toString(16) : "0".concat(n.toString(16));
    var nBuf = buffer_1.Buffer.from(nStr, 'hex');
    nBuf.reverse().copy(preBuf, 0);
    preBuf.copy(buf, off);
    return preBuf;
}
function decodeAddress(address) {
    var versionByte, pkh;
    try {
        versionByte = bs58check_1.default.decode(address)[0];
        pkh = bs58check_1.default.decode(address).slice(1);
    }
    catch (err) {
        try {
            var bech32Dec = bech32_1.bech32.decode(address);
            if (bech32Dec.prefix === SEGWIT_NATIVE_V0_PREFIX)
                versionByte = FMT_SEGWIT_NATIVE_V0;
            else if (bech32Dec.prefix === SEGWIT_NATIVE_V0_TESTNET_PREFIX)
                versionByte = FMT_SEGWIT_NATIVE_V0_TESTNET;
            else
                throw new Error('Unsupported prefix: must be bc or tb.');
            if (bech32Dec.words[0] !== 0)
                throw new Error("Unsupported segwit version: must be 0, got ".concat(bech32Dec.words[0]));
            pkh = buffer_1.Buffer.from(bech32_1.bech32.fromWords(bech32Dec.words.slice(1)));
        }
        catch (err) {
            throw new Error("Unable to decode address: ".concat(address, ": ").concat(err.message));
        }
    }
    return { versionByte: versionByte, pkh: pkh };
}
// Determine the address format (a.k.a. "version") depending on the
// purpose of the dervation path.
function getAddressFormat(path) {
    if (path.length < 2)
        throw new Error('Path must be >1 index');
    var purpose = path[0];
    var coin = path[1];
    if (purpose === PURPOSES.BTC_SEGWIT && coin === COINS.BTC) {
        return FMT_SEGWIT_NATIVE_V0;
    }
    else if (purpose === PURPOSES.BTC_SEGWIT && coin === COINS.BTC_TESTNET) {
        return FMT_SEGWIT_NATIVE_V0_TESTNET;
    }
    else if (purpose === PURPOSES.BTC_WRAPPED_SEGWIT && coin === COINS.BTC) {
        return FMT_SEGWIT_WRAPPED;
    }
    else if (purpose === PURPOSES.BTC_WRAPPED_SEGWIT &&
        coin === COINS.BTC_TESTNET) {
        return FMT_SEGWIT_WRAPPED_TESTNET;
    }
    else if (purpose === PURPOSES.BTC_LEGACY && coin === COINS.BTC) {
        return FMT_LEGACY;
    }
    else if (purpose === PURPOSES.BTC_LEGACY && coin === COINS.BTC_TESTNET) {
        return FMT_LEGACY_TESTNET;
    }
    else {
        throw new Error('Invalid Bitcoin path provided. Cannot determine address format.');
    }
}
// Determine the script type for an input based on its owner's derivation
// path's `purpose` index.
// We do not support p2sh and only issue single-key addresses from the Lattice
// so we can determine this based on path alone.
function getScriptType(input) {
    switch (input.signerPath[0]) {
        case PURPOSES.BTC_LEGACY:
            return BTC_SCRIPT_TYPE_P2PKH;
        case PURPOSES.BTC_WRAPPED_SEGWIT:
            return BTC_SCRIPT_TYPE_P2SH_P2WPKH;
        case PURPOSES.BTC_SEGWIT:
            return BTC_SCRIPT_TYPE_P2WPKH_V0;
        default:
            throw new Error("Unsupported path purpose (".concat(input.signerPath[0], "): cannot determine BTC script type."));
    }
}
// Determine if a a transaction should have a witness portion.
// This will return true if any input is p2sh(p2wpkh) or p2wpkh.
// We determine the script type based on the derivation path.
function needsWitness(inputs) {
    var w = false;
    inputs.forEach(function (input) {
        if (input.signerPath[0] === PURPOSES.BTC_SEGWIT ||
            input.signerPath[0] === PURPOSES.BTC_WRAPPED_SEGWIT) {
            w = true;
        }
    });
    return w;
}
exports.default = {
    buildBitcoinTxRequest: buildBitcoinTxRequest,
    serializeTx: serializeTx,
    getBitcoinAddress: getBitcoinAddress,
    getAddressFormat: getAddressFormat,
};

      };
    };
  }
}, {package:"gridplus-sdk",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\dist\\bitcoin.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js", {"../messages.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\lib\elliptic\index.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var BN = require('bn.js')
var EC = require('elliptic').ec

var messages = require('../messages.json')

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js", {"./assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js","./der":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js","./messages.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\lib\index.js
      return function (require, module, exports) {
'use strict'
var assert = require('./assert')
var der = require('./der')
var messages = require('./messages.json')

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\misc.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\misc.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\misc.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\account.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\account.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\account.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\params.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\params.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\params.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\binance.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\trezor\management.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\bitcoin.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\eos.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\ripple.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\coinInfo.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\ethereum.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\transactions.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\backend\transactions.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\transactions.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\stellar.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\nem.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\tezos.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js", {"../trezor/protobuf":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\networks\cardano.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CardanoTxWitnessType = exports.CardanoTxSigningMode = exports.CardanoPoolRelayType = exports.CardanoNativeScriptHashDisplayFormat = exports.CardanoNativeScriptType = exports.CardanoCertificateType = exports.CardanoAddressType = void 0;

var _protobuf = require("../trezor/protobuf");

exports.CardanoAddressType = _protobuf.Enum_CardanoAddressType;
exports.CardanoCertificateType = _protobuf.Enum_CardanoCertificateType;
exports.CardanoNativeScriptType = _protobuf.Enum_CardanoNativeScriptType;
exports.CardanoNativeScriptHashDisplayFormat = _protobuf.Enum_CardanoNativeScriptHashDisplayFormat;
exports.CardanoPoolRelayType = _protobuf.Enum_CardanoPoolRelayType;
exports.CardanoTxSigningMode = _protobuf.Enum_CardanoTxSigningMode;
exports.CardanoTxWitnessType = _protobuf.Enum_CardanoTxWitnessType;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\events.js", {"../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\events.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\events.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\api.js", {"../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js","./account":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\account.js","./backend/blockchain":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js","./events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\events.js","./misc":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\misc.js","./networks/binance":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js","./networks/bitcoin":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js","./networks/cardano":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js","./networks/coinInfo":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js","./networks/eos":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js","./networks/ethereum":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js","./networks/nem":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js","./networks/ripple":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js","./networks/stellar":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js","./networks/tezos":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js","./params":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\params.js","./trezor/device":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js","./trezor/management":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js","./trezor/protobuf":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\api.js
      return function (require, module, exports) {
"use strict";

var CONSTANTS = _interopRequireWildcard(require("../constants"));

var P = _interopRequireWildcard(require("./params"));

var Device = _interopRequireWildcard(require("./trezor/device"));

var Mgmnt = _interopRequireWildcard(require("./trezor/management"));

var Protobuf = _interopRequireWildcard(require("./trezor/protobuf"));

var Account = _interopRequireWildcard(require("./account"));

var Bitcoin = _interopRequireWildcard(require("./networks/bitcoin"));

var Binance = _interopRequireWildcard(require("./networks/binance"));

var Cardano = _interopRequireWildcard(require("./networks/cardano"));

var CoinInfo = _interopRequireWildcard(require("./networks/coinInfo"));

var EOS = _interopRequireWildcard(require("./networks/eos"));

var Ethereum = _interopRequireWildcard(require("./networks/ethereum"));

var NEM = _interopRequireWildcard(require("./networks/nem"));

var Ripple = _interopRequireWildcard(require("./networks/ripple"));

var Stellar = _interopRequireWildcard(require("./networks/stellar"));

var Tezos = _interopRequireWildcard(require("./networks/tezos"));

var Misc = _interopRequireWildcard(require("./misc"));

var Events = _interopRequireWildcard(require("./events"));

var Blockchain = _interopRequireWildcard(require("./backend/blockchain"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\api.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js", {"../../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\trezor\device.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js", {"../../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\backend\blockchain.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\network.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\network.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.TYPES = void 0;
var TYPES = Object.freeze({
  bitcoin: 'Bitcoin',
  ethereum: 'Ethereum',
  eos: 'Eos',
  nem: 'NEM',
  stellar: 'Stellar',
  cardano: 'Cardano',
  ripple: 'Ripple',
  tezos: 'Tezors',
  binance: 'Binance'
});
exports.TYPES = TYPES;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\network.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\device.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\device.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.WAIT_FOR_SELECTION = exports.WORD = exports.PASSPHRASE_ON_DEVICE = exports.PASSPHRASE = exports.PIN = exports.BUTTON = exports.LOADING = exports.USED_ELSEWHERE = exports.RELEASED = exports.ACQUIRED = exports.RELEASE = exports.ACQUIRE = exports.CHANGED = exports.DISCONNECT = exports.CONNECT_UNACQUIRED = exports.CONNECT = void 0;
// device list events
var CONNECT = 'device-connect';
exports.CONNECT = CONNECT;
var CONNECT_UNACQUIRED = 'device-connect_unacquired';
exports.CONNECT_UNACQUIRED = CONNECT_UNACQUIRED;
var DISCONNECT = 'device-disconnect';
exports.DISCONNECT = DISCONNECT;
var CHANGED = 'device-changed';
exports.CHANGED = CHANGED;
var ACQUIRE = 'device-acquire';
exports.ACQUIRE = ACQUIRE;
var RELEASE = 'device-release';
exports.RELEASE = RELEASE;
var ACQUIRED = 'device-acquired';
exports.ACQUIRED = ACQUIRED;
var RELEASED = 'device-released';
exports.RELEASED = RELEASED;
var USED_ELSEWHERE = 'device-used_elsewhere';
exports.USED_ELSEWHERE = USED_ELSEWHERE;
var LOADING = 'device-loading'; // trezor-link events in protobuf format

exports.LOADING = LOADING;
var BUTTON = 'button';
exports.BUTTON = BUTTON;
var PIN = 'pin';
exports.PIN = PIN;
var PASSPHRASE = 'passphrase';
exports.PASSPHRASE = PASSPHRASE;
var PASSPHRASE_ON_DEVICE = 'passphrase_on_device';
exports.PASSPHRASE_ON_DEVICE = PASSPHRASE_ON_DEVICE;
var WORD = 'word'; // custom

exports.WORD = WORD;
var WAIT_FOR_SELECTION = 'device-wait_for_selection';
exports.WAIT_FOR_SELECTION = WAIT_FOR_SELECTION;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\device.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\iframe.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\iframe.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CALL = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from iframe.html inline script before "window.onload" event. This is first message from iframe to window.opener.
var BOOTSTRAP = 'iframe-bootstrap'; // Message from iframe.js to window.opener, called after "window.onload" event. This is second message from iframe to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'iframe-loaded'; // Message from window.opener to iframe.js

exports.LOADED = LOADED;
var INIT = 'iframe-init'; // Error message from iframe.js to window.opener. Could be thrown during iframe initialization process

exports.INIT = INIT;
var ERROR = 'iframe-error'; // Message from window.opener to iframe. Call method

exports.ERROR = ERROR;
var CALL = 'iframe-call';
exports.CALL = CALL;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\iframe.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\transport.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\transport.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.START_PENDING = exports.DISABLE_WEBUSB = exports.REQUEST = exports.STREAM = exports.UPDATE = exports.ERROR = exports.START = void 0;
var START = 'transport-start';
exports.START = START;
var ERROR = 'transport-error';
exports.ERROR = ERROR;
var UPDATE = 'transport-update';
exports.UPDATE = UPDATE;
var STREAM = 'transport-stream';
exports.STREAM = STREAM;
var REQUEST = 'transport-request_device';
exports.REQUEST = REQUEST;
var DISABLE_WEBUSB = 'transport-disable_webusb';
exports.DISABLE_WEBUSB = DISABLE_WEBUSB;
var START_PENDING = 'transport-start_pending';
exports.START_PENDING = START_PENDING;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\transport.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\ui.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\ui.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.IFRAME_FAILURE = exports.ADDRESS_VALIDATION = exports.BUNDLE_PROGRESS = exports.LOGIN_CHALLENGE_RESPONSE = exports.LOGIN_CHALLENGE_REQUEST = exports.CUSTOM_MESSAGE_RESPONSE = exports.CUSTOM_MESSAGE_REQUEST = exports.CHANGE_SETTINGS = exports.RECEIVE_WORD = exports.RECEIVE_FEE = exports.RECEIVE_ACCOUNT = exports.CHANGE_ACCOUNT = exports.RECEIVE_DEVICE = exports.RECEIVE_PASSPHRASE = exports.RECEIVE_PIN = exports.RECEIVE_CONFIRMATION = exports.RECEIVE_PERMISSION = exports.REQUEST_WORD = exports.REQUEST_BUTTON = exports.INSUFFICIENT_FUNDS = exports.UPDATE_CUSTOM_FEE = exports.SELECT_FEE = exports.SELECT_ACCOUNT = exports.SELECT_DEVICE = exports.SET_OPERATION = exports.LOADING = exports.CONNECT = exports.INVALID_PASSPHRASE_ACTION = exports.INVALID_PASSPHRASE = exports.REQUEST_PASSPHRASE_ON_DEVICE = exports.REQUEST_PASSPHRASE = exports.INVALID_PIN = exports.REQUEST_PIN = exports.REQUEST_CONFIRMATION = exports.REQUEST_PERMISSION = exports.CLOSE_UI_WINDOW = exports.REQUEST_UI_WINDOW = exports.DEVICE_NEEDS_BACKUP = exports.FIRMWARE_PROGRESS = exports.FIRMWARE_NOT_INSTALLED = exports.FIRMWARE_NOT_COMPATIBLE = exports.FIRMWARE_NOT_SUPPORTED = exports.FIRMWARE_OUTDATED = exports.FIRMWARE_OLD = exports.SEEDLESS = exports.INITIALIZE = exports.REQUIRE_MODE = exports.NOT_IN_BOOTLOADER = exports.BOOTLOADER = exports.TRANSPORT = void 0;
var TRANSPORT = 'ui-no_transport';
exports.TRANSPORT = TRANSPORT;
var BOOTLOADER = 'ui-device_bootloader_mode';
exports.BOOTLOADER = BOOTLOADER;
var NOT_IN_BOOTLOADER = 'ui-device_not_in_bootloader_mode';
exports.NOT_IN_BOOTLOADER = NOT_IN_BOOTLOADER;
var REQUIRE_MODE = 'ui-device_require_mode';
exports.REQUIRE_MODE = REQUIRE_MODE;
var INITIALIZE = 'ui-device_not_initialized';
exports.INITIALIZE = INITIALIZE;
var SEEDLESS = 'ui-device_seedless';
exports.SEEDLESS = SEEDLESS;
var FIRMWARE_OLD = 'ui-device_firmware_old';
exports.FIRMWARE_OLD = FIRMWARE_OLD;
var FIRMWARE_OUTDATED = 'ui-device_firmware_outdated';
exports.FIRMWARE_OUTDATED = FIRMWARE_OUTDATED;
var FIRMWARE_NOT_SUPPORTED = 'ui-device_firmware_unsupported';
exports.FIRMWARE_NOT_SUPPORTED = FIRMWARE_NOT_SUPPORTED;
var FIRMWARE_NOT_COMPATIBLE = 'ui-device_firmware_not_compatible';
exports.FIRMWARE_NOT_COMPATIBLE = FIRMWARE_NOT_COMPATIBLE;
var FIRMWARE_NOT_INSTALLED = 'ui-device_firmware_not_installed';
exports.FIRMWARE_NOT_INSTALLED = FIRMWARE_NOT_INSTALLED;
var FIRMWARE_PROGRESS = 'ui-firmware-progress';
exports.FIRMWARE_PROGRESS = FIRMWARE_PROGRESS;
var DEVICE_NEEDS_BACKUP = 'ui-device_needs_backup';
exports.DEVICE_NEEDS_BACKUP = DEVICE_NEEDS_BACKUP;
var REQUEST_UI_WINDOW = 'ui-request_window';
exports.REQUEST_UI_WINDOW = REQUEST_UI_WINDOW;
var CLOSE_UI_WINDOW = 'ui-close_window';
exports.CLOSE_UI_WINDOW = CLOSE_UI_WINDOW;
var REQUEST_PERMISSION = 'ui-request_permission';
exports.REQUEST_PERMISSION = REQUEST_PERMISSION;
var REQUEST_CONFIRMATION = 'ui-request_confirmation';
exports.REQUEST_CONFIRMATION = REQUEST_CONFIRMATION;
var REQUEST_PIN = 'ui-request_pin';
exports.REQUEST_PIN = REQUEST_PIN;
var INVALID_PIN = 'ui-invalid_pin';
exports.INVALID_PIN = INVALID_PIN;
var REQUEST_PASSPHRASE = 'ui-request_passphrase';
exports.REQUEST_PASSPHRASE = REQUEST_PASSPHRASE;
var REQUEST_PASSPHRASE_ON_DEVICE = 'ui-request_passphrase_on_device';
exports.REQUEST_PASSPHRASE_ON_DEVICE = REQUEST_PASSPHRASE_ON_DEVICE;
var INVALID_PASSPHRASE = 'ui-invalid_passphrase';
exports.INVALID_PASSPHRASE = INVALID_PASSPHRASE;
var INVALID_PASSPHRASE_ACTION = 'ui-invalid_passphrase_action';
exports.INVALID_PASSPHRASE_ACTION = INVALID_PASSPHRASE_ACTION;
var CONNECT = 'ui-connect';
exports.CONNECT = CONNECT;
var LOADING = 'ui-loading';
exports.LOADING = LOADING;
var SET_OPERATION = 'ui-set_operation';
exports.SET_OPERATION = SET_OPERATION;
var SELECT_DEVICE = 'ui-select_device';
exports.SELECT_DEVICE = SELECT_DEVICE;
var SELECT_ACCOUNT = 'ui-select_account';
exports.SELECT_ACCOUNT = SELECT_ACCOUNT;
var SELECT_FEE = 'ui-select_fee';
exports.SELECT_FEE = SELECT_FEE;
var UPDATE_CUSTOM_FEE = 'ui-update_custom_fee';
exports.UPDATE_CUSTOM_FEE = UPDATE_CUSTOM_FEE;
var INSUFFICIENT_FUNDS = 'ui-insufficient_funds';
exports.INSUFFICIENT_FUNDS = INSUFFICIENT_FUNDS;
var REQUEST_BUTTON = 'ui-button';
exports.REQUEST_BUTTON = REQUEST_BUTTON;
var REQUEST_WORD = 'ui-request_word';
exports.REQUEST_WORD = REQUEST_WORD;
var RECEIVE_PERMISSION = 'ui-receive_permission';
exports.RECEIVE_PERMISSION = RECEIVE_PERMISSION;
var RECEIVE_CONFIRMATION = 'ui-receive_confirmation';
exports.RECEIVE_CONFIRMATION = RECEIVE_CONFIRMATION;
var RECEIVE_PIN = 'ui-receive_pin';
exports.RECEIVE_PIN = RECEIVE_PIN;
var RECEIVE_PASSPHRASE = 'ui-receive_passphrase';
exports.RECEIVE_PASSPHRASE = RECEIVE_PASSPHRASE;
var RECEIVE_DEVICE = 'ui-receive_device';
exports.RECEIVE_DEVICE = RECEIVE_DEVICE;
var CHANGE_ACCOUNT = 'ui-change_account';
exports.CHANGE_ACCOUNT = CHANGE_ACCOUNT;
var RECEIVE_ACCOUNT = 'ui-receive_account';
exports.RECEIVE_ACCOUNT = RECEIVE_ACCOUNT;
var RECEIVE_FEE = 'ui-receive_fee';
exports.RECEIVE_FEE = RECEIVE_FEE;
var RECEIVE_WORD = 'ui-receive_word';
exports.RECEIVE_WORD = RECEIVE_WORD;
var CHANGE_SETTINGS = 'ui-change_settings';
exports.CHANGE_SETTINGS = CHANGE_SETTINGS;
var CUSTOM_MESSAGE_REQUEST = 'ui-custom_request';
exports.CUSTOM_MESSAGE_REQUEST = CUSTOM_MESSAGE_REQUEST;
var CUSTOM_MESSAGE_RESPONSE = 'ui-custom_response';
exports.CUSTOM_MESSAGE_RESPONSE = CUSTOM_MESSAGE_RESPONSE;
var LOGIN_CHALLENGE_REQUEST = 'ui-login_challenge_request';
exports.LOGIN_CHALLENGE_REQUEST = LOGIN_CHALLENGE_REQUEST;
var LOGIN_CHALLENGE_RESPONSE = 'ui-login_challenge_response';
exports.LOGIN_CHALLENGE_RESPONSE = LOGIN_CHALLENGE_RESPONSE;
var BUNDLE_PROGRESS = 'ui-bundle_progress';
exports.BUNDLE_PROGRESS = BUNDLE_PROGRESS;
var ADDRESS_VALIDATION = 'ui-address_validation';
exports.ADDRESS_VALIDATION = ADDRESS_VALIDATION;
var IFRAME_FAILURE = 'ui-iframe_failure';
exports.IFRAME_FAILURE = IFRAME_FAILURE;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\ui.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\blockchain.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\blockchain.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.FIAT_RATES_UPDATE = exports.NOTIFICATION = exports.BLOCK = exports.CONNECT = exports.ERROR = void 0;
// blockchain events
var ERROR = 'blockchain-error';
exports.ERROR = ERROR;
var CONNECT = 'blockchain-connect';
exports.CONNECT = CONNECT;
var BLOCK = 'blockchain-block';
exports.BLOCK = BLOCK;
var NOTIFICATION = 'blockchain-notification';
exports.NOTIFICATION = NOTIFICATION;
var FIAT_RATES_UPDATE = 'fiat-rates-update';
exports.FIAT_RATES_UPDATE = FIAT_RATES_UPDATE;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\blockchain.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\popup.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\popup.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CLOSE_WINDOW = exports.CANCEL_POPUP_REQUEST = exports.CLOSED = exports.HANDSHAKE = exports.EXTENSION_USB_PERMISSIONS = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from popup.html inline script before "window.onload" event. This is first message from popup to window.opener.
var BOOTSTRAP = 'popup-bootstrap'; // Message from popup.js to window.opener, called after "window.onload" event. This is second message from popup to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'popup-loaded'; // Message from window.opener to popup.js. Send settings to popup. This is first message from window.opener to popup.

exports.LOADED = LOADED;
var INIT = 'popup-init'; // Error message from popup to window.opener. Could be thrown during popup initialization process (POPUP.INIT)

exports.INIT = INIT;
var ERROR = 'popup-error'; // Message to webextensions, opens "trezor-usb-permission.html" within webextension

exports.ERROR = ERROR;
var EXTENSION_USB_PERMISSIONS = 'open-usb-permissions'; // Message called from both [popup > iframe] then [iframe > popup] in this exact order.
// Firstly popup call iframe to resolve popup promise in Core
// Then iframe reacts to POPUP.HANDSHAKE message and sends ConnectSettings, transport information and requested method details back to popup

exports.EXTENSION_USB_PERMISSIONS = EXTENSION_USB_PERMISSIONS;
var HANDSHAKE = 'popup-handshake'; // Event emitted from PopupManager at the end of popup closing process.
// Sent from popup thru window.opener to an iframe because message channel between popup and iframe is no longer available

exports.HANDSHAKE = HANDSHAKE;
var CLOSED = 'popup-closed'; // Message called from iframe to popup, it means that popup will not be needed (example: Blockchain methods are not using popup at all)
// This will close active popup window and/or clear opening process in PopupManager (maybe popup wasn't opened yet)

exports.CLOSED = CLOSED;
var CANCEL_POPUP_REQUEST = 'ui-cancel-popup-request'; // Message called from inline element in popup.html (window.closeWindow), this is used only with webextensions to properly handle popup close event

exports.CANCEL_POPUP_REQUEST = CANCEL_POPUP_REQUEST;
var CLOSE_WINDOW = 'window.close';
exports.CLOSE_WINDOW = CLOSE_WINDOW;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\popup.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\cardano.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\cardano.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.POOL_RELAY_TYPE = exports.CERTIFICATE_TYPE = exports.ADDRESS_TYPE = exports.NETWORK_IDS = exports.PROTOCOL_MAGICS = void 0;
var PROTOCOL_MAGICS = Object.freeze({
  mainnet: 764824073,
  testnet: 42
});
exports.PROTOCOL_MAGICS = PROTOCOL_MAGICS;
var NETWORK_IDS = Object.freeze({
  mainnet: 1,
  testnet: 0
}); // constants below are deprecated
// use `CardanoAddressType`, `CardanoCertificateType` and `CardanoPoolRelayType` from protobuf instead

exports.NETWORK_IDS = NETWORK_IDS;
var ADDRESS_TYPE = Object.freeze({
  Base: 0,
  Pointer: 4,
  Enterprise: 6,
  Byron: 8,
  Reward: 14
});
exports.ADDRESS_TYPE = ADDRESS_TYPE;
var CERTIFICATE_TYPE = Object.freeze({
  StakeRegistration: 0,
  StakeDeregistration: 1,
  StakeDelegation: 2,
  StakePoolRegistration: 3
});
exports.CERTIFICATE_TYPE = CERTIFICATE_TYPE;
var POOL_RELAY_TYPE = Object.freeze({
  SingleHostIp: 0,
  SingleHostName: 1,
  MultipleHostName: 2
});
exports.POOL_RELAY_TYPE = POOL_RELAY_TYPE;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\cardano.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\errors.js", {"@babel/runtime/helpers/inheritsLoose":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/wrapNativeSuper":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\wrapNativeSuper.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\constants\errors.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.LIBUSB_ERROR_MESSAGE = exports.WEBUSB_ERROR_MESSAGE = exports.INVALID_PIN_ERROR_MESSAGE = exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = exports.TypedError = exports.TrezorError = exports.ERROR_CODES = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var ERROR_CODES = {
  Init_NotInitialized: 'TrezorConnect not yet initialized',
  // race condition: call on not initialized Core (usually hot-reloading)
  Init_AlreadyInitialized: 'TrezorConnect has been already initialized',
  // thrown by .init called multiple times
  Init_IframeBlocked: 'Iframe blocked',
  // iframe injection blocked (ad-blocker)
  Init_IframeTimeout: 'Iframe timeout',
  // iframe didn't load in specified time
  Init_ManifestMissing: 'Manifest not set. Read more at https://github.com/trezor/connect/blob/develop/docs/index.md',
  // manifest is not set
  Popup_ConnectionMissing: 'Unable to establish connection with iframe',
  // thrown by popup
  Transport_Missing: 'Transport is missing',
  // no transport available
  Transport_InvalidProtobuf: '',
  // generic error from transport layer (trezor-link)
  Method_InvalidPackage: 'This version of trezor-connect is not suitable to work without browser. Use trezor-connect@extended package instead',
  // thrown by node and react-native env while using regular 'web' package
  Method_InvalidParameter: '',
  // replaced by generic text
  Method_NotAllowed: 'Method not allowed for this configuration',
  // example: device management in popup mode
  Method_PermissionsNotGranted: 'Permissions not granted',
  // permission/confirmation not granted in popup
  Method_Cancel: 'Cancelled',
  // permission/confirmation not granted in popup OR .cancel() custom error
  Method_Interrupted: 'Popup closed',
  // interruption: popup closed
  Method_UnknownCoin: 'Coin not found',
  // coin definition not found
  Method_AddressNotMatch: 'Addresses do not match',
  // thrown by all getAddress methods with custom UI validation
  Method_FirmwareUpdate_DownloadFailed: 'Failed to download firmware binary',
  // thrown by FirmwareUpdate method
  Method_CustomMessage_Callback: 'Parameter "callback" is not a function',
  // thrown by CustomMessage method
  Method_Discovery_BundleException: '',
  // thrown by getAccountInfo method
  Method_Override: 'override',
  // inner "error", it's more like a interruption
  Method_NoResponse: 'Call resolved without response',
  // thrown by npm index(es), call to Core resolved without response, should not happen
  Backend_NotSupported: 'BlockchainLink settings not found in coins.json',
  // thrown by methods which using backends, blockchainLink not defined for this coin
  Backend_WorkerMissing: '',
  // thrown by BlockchainLink class, worker not specified
  Backend_Disconnected: 'Backend disconnected',
  // thrown by BlockchainLink class
  Backend_Invalid: 'Invalid backend',
  // thrown by BlockchainLink class, invalid backend (ie: backend for wrong coin set)
  Backend_Error: '',
  // thrown by BlockchainLink class, generic message from 'blockchain-link'
  Runtime: '',
  // thrown from several places, this shouldn't ever happen tho
  Device_NotFound: 'Device not found',
  Device_InitializeFailed: '',
  // generic error from firmware while calling "Initialize" message
  Device_FwException: '',
  // generic FirmwareException type
  Device_ModeException: '',
  // generic Device.UnexpectedMode type
  Device_Disconnected: 'Device disconnected',
  // device disconnected during call
  Device_UsedElsewhere: 'Device is used in another window',
  // interruption: current session toked by other application
  Device_InvalidState: 'Passphrase is incorrect',
  // authorization error (device state comparison)
  Device_CallInProgress: 'Device call in progress' // thrown when trying to make another call while current is still running

};
exports.ERROR_CODES = ERROR_CODES;

var TrezorError = /*#__PURE__*/function (_Error) {
  (0, _inheritsLoose2["default"])(TrezorError, _Error);

  function TrezorError(code, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.code = code;
    _this.message = message;
    return _this;
  }

  return TrezorError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.TrezorError = TrezorError;

var TypedError = function TypedError(id, message) {
  return new TrezorError(id, message || ERROR_CODES[id]);
}; // a slight hack
// this error string is hard-coded
// in both bridge and extension


exports.TypedError = TypedError;
var WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = 'wrong previous session';
exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = WRONG_PREVIOUS_SESSION_ERROR_MESSAGE;
var INVALID_PIN_ERROR_MESSAGE = 'PIN invalid';
exports.INVALID_PIN_ERROR_MESSAGE = INVALID_PIN_ERROR_MESSAGE;
var WEBUSB_ERROR_MESSAGE = 'NetworkError: Unable to claim interface.'; // trezord error prefix.
// user has insufficient permissions. may occur in Linux (missing udev rules), Windows and MacOS.

exports.WEBUSB_ERROR_MESSAGE = WEBUSB_ERROR_MESSAGE;
var LIBUSB_ERROR_MESSAGE = 'LIBUSB_ERROR';
exports.LIBUSB_ERROR_MESSAGE = LIBUSB_ERROR_MESSAGE;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\errors.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\webusb\\button.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\webusb\button.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var render = function render(className, url, origin) {
  var query = className || '.trezor-webusb-button';
  var buttons = document.querySelectorAll(query);
  var src = url + "?" + Date.now();
  buttons.forEach(function (b) {
    if (b.getElementsByTagName('iframe').length < 1) {
      var bounds = b.getBoundingClientRect();
      var btnIframe = document.createElement('iframe');
      btnIframe.frameBorder = '0';
      btnIframe.width = Math.round(bounds.width) + "px";
      btnIframe.height = Math.round(bounds.height) + "px";
      btnIframe.style.position = 'absolute';
      btnIframe.style.top = '0px';
      btnIframe.style.left = '0px';
      btnIframe.style.zIndex = '1'; // btnIframe.style.opacity = '0'; // this makes click impossible on cross-origin

      btnIframe.setAttribute('allow', 'usb');
      btnIframe.setAttribute('scrolling', 'no');

      btnIframe.onload = function () {
        btnIframe.contentWindow.postMessage({// style: JSON.stringify( window.getComputedStyle(b) ),
          // outer: b.outerHTML,
          // inner: b.innerHTML
        }, origin);
      };

      btnIframe.src = src; // inject iframe into button

      b.append(btnIframe);
    }
  });
};

var _default = render;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\webusb\\button.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\debug.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\utils\debug.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.getLog = exports.enableLogByPrefix = exports.enableLog = exports.initLog = void 0;

/* eslint-disable no-console */
var colors = {
  // green
  DescriptorStream: 'color: #77ab59',
  DeviceList: 'color: #36802d',
  Device: 'color: #bada55',
  Core: 'color: #c9df8a',
  IFrame: 'color: #FFFFFF; background: #f4a742;',
  Popup: 'color: #f48a00'
};
var MAX_ENTRIES = 100;

var Log = /*#__PURE__*/function () {
  function Log(prefix, enabled) {
    this.prefix = prefix;
    this.enabled = enabled;
    this.messages = [];
    this.css = colors[prefix] || 'color: #000000; background: #FFFFFF;';
  }

  var _proto = Log.prototype;

  _proto.addMessage = function addMessage(level, prefix) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.messages.push({
      level: level,
      prefix: prefix,
      message: args,
      timestamp: new Date().getTime()
    });

    if (this.messages.length > MAX_ENTRIES) {
      this.messages.shift();
    }
  };

  _proto.log = function log() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    this.addMessage.apply(this, ['log', this.prefix].concat(args));

    if (this.enabled) {
      var _console;

      (_console = console).log.apply(_console, [this.prefix].concat(args));
    }
  };

  _proto.error = function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    this.addMessage.apply(this, ['error', this.prefix].concat(args));

    if (this.enabled) {
      var _console2;

      (_console2 = console).error.apply(_console2, [this.prefix].concat(args));
    }
  };

  _proto.warn = function warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    this.addMessage.apply(this, ['warn', this.prefix].concat(args));

    if (this.enabled) {
      var _console3;

      (_console3 = console).warn.apply(_console3, [this.prefix].concat(args));
    }
  };

  _proto.debug = function debug() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    this.addMessage.apply(this, ['debug', this.prefix].concat(args));

    if (this.enabled) {
      var _console4;

      (_console4 = console).log.apply(_console4, ["%c" + this.prefix, this.css].concat(args));
    }
  };

  return Log;
}();

var _logs = {};

var initLog = function initLog(prefix, enabled) {
  var instance = new Log(prefix, !!enabled);
  _logs[prefix] = instance;
  return instance;
};

exports.initLog = initLog;

var enableLog = function enableLog(enabled) {
  Object.keys(_logs).forEach(function (key) {
    _logs[key].enabled = enabled;
  });
};

exports.enableLog = enableLog;

var enableLogByPrefix = function enableLogByPrefix(prefix, enabled) {
  if (_logs[prefix]) {
    _logs[prefix].enabled = enabled;
  }
};

exports.enableLogByPrefix = enableLogByPrefix;

var getLog = function getLog() {
  var logs = [];
  Object.keys(_logs).forEach(function (key) {
    logs = logs.concat(_logs[key].messages);
  });
  logs.sort(function (a, b) {
    return a.timestamp - b.timestamp;
  });
  return logs;
};

exports.getLog = getLog;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\debug.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\message\index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.errorMessage = exports.parseMessage = void 0;

// parse MessageEvent .data into CoreMessage
var parseMessage = function parseMessage(messageData) {
  var message = {
    event: messageData.event,
    type: messageData.type,
    payload: messageData.payload
  };

  if (typeof messageData.id === 'number') {
    message.id = messageData.id;
  }

  if (typeof messageData.success === 'boolean') {
    message.success = messageData.success;
  }

  return message;
}; // common response used straight from npm index (not from Core)


exports.parseMessage = parseMessage;

var errorMessage = function errorMessage(error) {
  return {
    success: false,
    payload: {
      error: error.message,
      code: error.code
    }
  };
};

exports.errorMessage = errorMessage;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\PopupManager.js", {"../constants/iframe":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\iframe.js","../constants/popup":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\popup.js","../constants/ui":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\ui.js","../env/browser/networkUtils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js","../utils/deferred":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\deferred.js","./showPopupRequest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\showPopupRequest.js","@babel/runtime/helpers/assertThisInitialized":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/inheritsLoose":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\popup\PopupManager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var POPUP = _interopRequireWildcard(require("../constants/popup"));

var IFRAME = _interopRequireWildcard(require("../constants/iframe"));

var UI = _interopRequireWildcard(require("../constants/ui"));

var _showPopupRequest = require("./showPopupRequest");

var _networkUtils = require("../env/browser/networkUtils");

var _deferred = require("../utils/deferred");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// const POPUP_REQUEST_TIMEOUT = 602;
var POPUP_REQUEST_TIMEOUT = 850;
var POPUP_CLOSE_INTERVAL = 500;
var POPUP_OPEN_TIMEOUT = 3000;

var PopupManager = /*#__PURE__*/function (_EventEmitter) {
  (0, _inheritsLoose2["default"])(PopupManager, _EventEmitter);

  // Window
  function PopupManager(settings) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestTimeout", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closeInterval", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extensionTabId", 0);
    _this.settings = settings;
    _this.origin = (0, _networkUtils.getOrigin)(settings.popupSrc);
    _this.handleMessage = _this.handleMessage.bind((0, _assertThisInitialized2["default"])(_this));
    _this.iframeHandshake = (0, _deferred.create)(IFRAME.LOADED);

    if (_this.settings.env === 'webextension') {
      _this.handleExtensionConnect = _this.handleExtensionConnect.bind((0, _assertThisInitialized2["default"])(_this));
      _this.handleExtensionMessage = _this.handleExtensionMessage.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

      chrome.runtime.onConnect.addListener(_this.handleExtensionConnect);
    }

    window.addEventListener('message', _this.handleMessage, false);
    return _this;
  }

  var _proto = PopupManager.prototype;

  _proto.request = function request(lazyLoad) {
    var _this2 = this;

    if (lazyLoad === void 0) {
      lazyLoad = false;
    }

    // popup request
    // TODO: ie - open immediately and hide it but post handshake after timeout
    // bring popup window to front
    if (this.locked) {
      if (this._window) {
        if (this.settings.env === 'webextension') {
          // $FlowIssue chrome not declared outside
          chrome.tabs.update(this._window.id, {
            active: true
          });
        } else {
          this._window.focus();
        }
      }

      return;
    }

    var openFn = this.open.bind(this);
    this.locked = true;

    if (!this.settings.supportedBrowser) {
      openFn();
    } else {
      var timeout = lazyLoad || this.settings.env === 'webextension' ? 1 : POPUP_REQUEST_TIMEOUT;
      this.requestTimeout = window.setTimeout(function () {
        _this2.requestTimeout = 0;
        openFn(lazyLoad);
      }, timeout);
    }
  };

  _proto.cancel = function cancel() {
    this.close();
  };

  _proto.unlock = function unlock() {
    this.locked = false;
  };

  _proto.open = function open(lazyLoad) {
    var _this3 = this;

    var src = this.settings.popupSrc;

    if (!this.settings.supportedBrowser) {
      this.openWrapper(src + "#unsupported");
      return;
    }

    this.popupPromise = (0, _deferred.create)(POPUP.LOADED);
    this.openWrapper(lazyLoad ? src + "#loading" : src);
    this.closeInterval = window.setInterval(function () {
      if (!_this3._window) return;

      if (_this3.settings.env === 'webextension') {
        // $FlowIssue chrome not declared outside
        chrome.tabs.get(_this3._window.id, function (tab) {
          if (!tab) {
            _this3.close();

            _this3.emit(POPUP.CLOSED);
          }
        });
      } else if (_this3._window.closed) {
        _this3.close();

        _this3.emit(POPUP.CLOSED);
      }
    }, POPUP_CLOSE_INTERVAL); // open timeout will be cancelled by POPUP.BOOTSTRAP message

    this.openTimeout = window.setTimeout(function () {
      _this3.close();

      (0, _showPopupRequest.showPopupRequest)(_this3.open.bind(_this3), function () {
        _this3.emit(POPUP.CLOSED);
      });
    }, POPUP_OPEN_TIMEOUT);
  };

  _proto.openWrapper = function openWrapper(url) {
    var _this4 = this;

    if (this.settings.env === 'webextension') {
      // $FlowIssue chrome not declared outside
      chrome.windows.getCurrent(null, function (currentWindow) {
        // Request coming from extension popup,
        // create new window above instead of opening new tab
        if (currentWindow.type !== 'normal') {
          // $FlowIssue chrome not declared outside
          chrome.windows.create({
            url: url
          }, function (newWindow) {
            // $FlowIssue chrome not declared outside
            chrome.tabs.query({
              windowId: newWindow.id,
              active: true
            }, function (tabs) {
              // eslint-disable-next-line prefer-destructuring
              _this4._window = tabs[0];
            });
          });
        } else {
          // $FlowIssue chrome not declared outside
          chrome.tabs.query({
            currentWindow: true,
            active: true
          }, function (tabs) {
            _this4.extensionTabId = tabs[0].id; // $FlowIssue chrome not declared outside

            chrome.tabs.create({
              url: url,
              index: tabs[0].index + 1
            }, function (tab) {
              _this4._window = tab;
            });
          });
        }
      });
    } else if (this.settings.env === 'electron') {
      this._window = window.open(url, 'modal');
    } else {
      this._window = window.open('', '_blank');

      if (this._window) {
        this._window.location.href = url; // otherwise android/chrome loose window.opener reference
      }
    }
  };

  _proto.handleExtensionConnect = function handleExtensionConnect(port) {
    if (port.name !== 'trezor-connect') return;

    if (!this._window || this._window && this._window.id !== port.sender.tab.id) {
      port.disconnect();
      return;
    } // since POPUP.BOOTSTRAP will not be handled by "handleMessage" we need to threat "content-script" connection as the same event
    // popup is opened properly, now wait for POPUP.LOADED message (in this case handled by "handleExtensionMessage")


    window.clearTimeout(this.openTimeout);
    this.extensionPort = port; // $FlowIssue need to update ChromePort definition

    this.extensionPort.onMessage.addListener(this.handleExtensionMessage);
  };

  _proto.handleExtensionMessage = function handleExtensionMessage(message) {
    var _this5 = this;

    if (!this.extensionPort) return;
    var port = this.extensionPort;
    var data = message.data;
    if (!data || typeof data !== 'object') return;

    if (data.type === POPUP.ERROR) {
      // handle popup error
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      }

      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        port.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this5.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        });
      });
    } else if (data.type === POPUP.EXTENSION_USB_PERMISSIONS) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.query({
        currentWindow: true,
        active: true
      }, function (tabs) {
        // $FlowIssue chrome not declared outside
        chrome.tabs.create({
          url: 'trezor-usb-permissions.html',
          index: tabs[0].index + 1
        }, function (_tab) {// do nothing
        });
      });
    } else if (data.type === POPUP.CLOSE_WINDOW) {
      this.emit(POPUP.CLOSED);
      this.close();
    }
  };

  _proto.handleMessage = function handleMessage(message) {
    var _this6 = this;

    // ignore messages from domain other then popup origin and without data
    // const data: CoreMessage = message.data;
    var data = message.data;
    if ((0, _networkUtils.getOrigin)(message.origin) !== this.origin || !data || typeof data !== 'object') return;

    if (data.type === IFRAME.LOADED) {
      var useBroadcastChannel = data.payload && typeof data.payload.useBroadcastChannel === 'boolean' ? data.payload.useBroadcastChannel : false;
      this.iframeHandshake.resolve(useBroadcastChannel);
    } else if (data.type === POPUP.BOOTSTRAP) {
      // popup is opened properly, now wait for POPUP.LOADED message
      window.clearTimeout(this.openTimeout);
    } else if (data.type === POPUP.ERROR && this._window) {
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      } // popup is successfully loaded


      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        _this6._window.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this6.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        }, _this6.origin);
      }); // send ConnectSettings to popup
      // note this settings and iframe.ConnectSettings could be different (especially: origin, popup, webusb, debug)
      // now popup is able to load assets
    } else if (data.type === POPUP.CANCEL_POPUP_REQUEST || data.type === UI.CLOSE_UI_WINDOW) {
      this.close();
    }
  };

  _proto.close = function close() {
    this.locked = false;
    this.popupPromise = undefined;

    if (this.requestTimeout) {
      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = 0;
    }

    if (this.openTimeout) {
      window.clearTimeout(this.openTimeout);
      this.openTimeout = 0;
    }

    if (this.closeInterval) {
      window.clearInterval(this.closeInterval);
      this.closeInterval = 0;
    }

    if (this.extensionPort) {
      this.extensionPort.disconnect();
      this.extensionPort = null;
    } // switch to previously focused tab


    if (this.extensionTabId) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.update(this.extensionTabId, {
        active: true
      });
      this.extensionTabId = 0;
    }

    if (this._window) {
      if (this.settings.env === 'webextension') {
        // eslint-disable-next-line no-unused-vars
        var _e = chrome.runtime.lastError; // $FlowIssue chrome not declared outside

        chrome.tabs.remove(this._window.id, function () {
          // eslint-disable-next-line no-unused-vars
          _e = chrome.runtime.lastError;
        });
      } else {
        this._window.close();
      }

      this._window = null;
    }
  };

  _proto.postMessage = /*#__PURE__*/function () {
    var _postMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(message) {
      var _this7 = this;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this._window && message.type !== UI.REQUEST_UI_WINDOW && this.openTimeout)) {
                _context.next = 4;
                break;
              }

              this.close();
              (0, _showPopupRequest.showPopupRequest)(this.open.bind(this), function () {
                _this7.emit(POPUP.CLOSED);
              });
              return _context.abrupt("return");

            case 4:
              if (!this.popupPromise) {
                _context.next = 7;
                break;
              }

              _context.next = 7;
              return this.popupPromise.promise;

            case 7:
              // post message to popup window
              if (this._window) {
                this._window.postMessage(message, this.origin);
              }

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function postMessage(_x) {
      return _postMessage.apply(this, arguments);
    }

    return postMessage;
  }();

  return PopupManager;
}(_events["default"]);

exports["default"] = PopupManager;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\PopupManager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\data\\ConnectSettings.js", {"@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\data\ConnectSettings.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.parse = exports.corsValidator = exports.getEnv = exports.DEFAULT_PRIORITY = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*
 * Initial settings for connect.
 * It could be changed by passing values into TrezorConnect.init(...) method
 */
var VERSION = '8.2.6';
var versionN = VERSION.split('.').map(function (s) {
  return parseInt(s, 10);
}); // const DIRECTORY = `${ versionN[0] }${ (versionN[1] > 0 ? `.${versionN[1]}` : '') }/`;

var DIRECTORY = versionN[0] + "/";
var DEFAULT_DOMAIN = "https://connect.trezor.io/" + DIRECTORY;
var DEFAULT_PRIORITY = 2;
exports.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
var initialSettings = {
  configSrc: './data/config.json',
  // constant
  version: VERSION,
  // constant
  debug: false,
  priority: DEFAULT_PRIORITY,
  trustedHost: false,
  connectSrc: DEFAULT_DOMAIN,
  iframeSrc: DEFAULT_DOMAIN + "iframe.html",
  popup: true,
  popupSrc: DEFAULT_DOMAIN + "popup.html",
  webusbSrc: DEFAULT_DOMAIN + "webusb.html",
  transportReconnect: false,
  webusb: true,
  pendingTransportEvent: true,
  supportedBrowser: typeof navigator !== 'undefined' ? !/Trident|MSIE|Edge/.test(navigator.userAgent) : true,
  manifest: null,
  env: 'web',
  lazyLoad: false,
  timestamp: new Date().getTime(),
  interactionTimeout: 600 // 5 minutes

};
var currentSettings = initialSettings;

var parseManifest = function parseManifest(manifest) {
  if (!manifest) return;
  if (typeof manifest.email !== 'string') return;
  if (typeof manifest.appUrl !== 'string') return;
  return {
    email: manifest.email,
    appUrl: manifest.appUrl
  };
};

var getEnv = function getEnv() {
  // $FlowIssue: chrome is not declared outside the project
  if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
    return 'webextension';
  }

  if (typeof navigator !== 'undefined') {
    if (typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
      return 'react-native';
    }

    var userAgent = navigator.userAgent.toLowerCase();

    if (userAgent.indexOf(' electron/') > -1) {
      return 'electron';
    }
  } // if (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
  //     return 'react-native';
  // }
  // if (typeof process !== 'undefined' && process.versions.hasOwnProperty('electron')) {
  //     return 'electron';
  // }


  return 'web';
}; // Cors validation copied from Trezor Bridge
// see: https://github.com/trezor/trezord-go/blob/05991cea5900d18bcc6ece5ae5e319d138fc5551/server/api/api.go#L229
// Its pointless to allow `trezor-connect` endpoints { connectSrc } for domains other than listed below
// `trezord` will block communication anyway


exports.getEnv = getEnv;

var corsValidator = function corsValidator(url) {
  if (typeof url !== 'string') return;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//)) return url;
  if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//)) return url;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//)) return url;
  if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//)) return url;
};

exports.corsValidator = corsValidator;

var parse = function parse(input) {
  if (input === void 0) {
    input = {};
  }

  var settings = _objectSpread({}, currentSettings);

  if (Object.prototype.hasOwnProperty.call(input, 'debug')) {
    if (Array.isArray(input)) {// enable log with prefix
    }

    if (typeof input.debug === 'boolean') {
      settings.debug = input.debug;
    } else if (typeof input.debug === 'string') {
      settings.debug = input.debug === 'true';
    }
  }

  if (typeof input.connectSrc === 'string') {
    settings.connectSrc = input.connectSrc;
  } // For debugging purposes `connectSrc` could be defined in `global.__TREZOR_CONNECT_SRC` variable


  if (typeof global !== 'undefined' && typeof global.__TREZOR_CONNECT_SRC === 'string') {
    settings.connectSrc = corsValidator(global.__TREZOR_CONNECT_SRC);
    settings.debug = true;
  } // For debugging purposes `connectSrc` could be defined in url query of hosting page. Usage:
  // https://3rdparty-page.com/?trezor-connect-src=https://localhost:8088/


  if (typeof window !== 'undefined' && window.location && typeof window.location.search === 'string') {
    var vars = window.location.search.split('&');
    var customUrl = vars.find(function (v) {
      return v.indexOf('trezor-connect-src') >= 0;
    });

    if (customUrl) {
      var _customUrl$split = customUrl.split('='),
          connectSrc = _customUrl$split[1];

      settings.connectSrc = corsValidator(decodeURIComponent(connectSrc));
      settings.debug = true;
    }
  }

  var src = settings.connectSrc || DEFAULT_DOMAIN;
  settings.iframeSrc = src + "iframe.html";
  settings.popupSrc = src + "popup.html";
  settings.webusbSrc = src + "webusb.html";

  if (typeof input.transportReconnect === 'boolean') {
    settings.transportReconnect = input.transportReconnect;
  }

  if (typeof input.webusb === 'boolean') {
    settings.webusb = input.webusb;
  }

  if (typeof input.popup === 'boolean') {
    settings.popup = input.popup;
  }

  if (typeof input.lazyLoad === 'boolean') {
    settings.lazyLoad = input.lazyLoad;
  }

  if (typeof input.pendingTransportEvent === 'boolean') {
    settings.pendingTransportEvent = input.pendingTransportEvent;
  } // local files


  if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
    settings.origin = "file://" + window.location.pathname;
    settings.webusb = false;
  }

  if (typeof input.extension === 'string') {
    settings.extension = input.extension;
  }

  if (typeof input.env === 'string') {
    settings.env = input.env;
  } else {
    settings.env = getEnv();
  }

  if (typeof input.timestamp === 'number') {
    settings.timestamp = input.timestamp;
  }

  if (typeof input.interactionTimeout === 'number') {
    settings.interactionTimeout = input.interactionTimeout;
  }

  if (typeof input.manifest === 'object') {
    settings.manifest = parseManifest(input.manifest);
  }

  currentSettings = settings;
  return currentSettings;
};

exports.parse = parse;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\data\\ConnectSettings.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\builder.js", {"../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\message\builder.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.BlockchainMessage = exports.ResponseMessage = exports.TransportMessage = exports.DeviceMessage = exports.UiMessage = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var UiMessage = function UiMessage(type, payload) {
  return {
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  };
};

exports.UiMessage = UiMessage;

var DeviceMessage = function DeviceMessage(type, payload) {
  return {
    event: _constants.DEVICE_EVENT,
    type: type,
    payload: payload
  };
};

exports.DeviceMessage = DeviceMessage;

var TransportMessage = function TransportMessage(type, payload) {
  return {
    event: _constants.TRANSPORT_EVENT,
    type: type,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: payload.error ? _objectSpread(_objectSpread({}, payload), {}, {
      error: payload.error.message,
      code: payload.error.code
    }) : payload
  };
};

exports.TransportMessage = TransportMessage;

var ResponseMessage = function ResponseMessage(id, success, payload) {
  if (payload === void 0) {
    payload = null;
  }

  return {
    event: _constants.RESPONSE_EVENT,
    type: _constants.RESPONSE_EVENT,
    id: id,
    success: success,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: success ? payload : {
      error: payload.error.message,
      code: payload.error.code
    }
  };
};

exports.ResponseMessage = ResponseMessage;

var BlockchainMessage = function BlockchainMessage(type, payload) {
  return {
    event: _constants.BLOCKCHAIN_EVENT,
    type: type,
    payload: payload
  };
};

exports.BlockchainMessage = BlockchainMessage;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\message\\builder.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\builder.js", {"../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\constants\\index.js","../env/browser/networkUtils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js","../utils/deferred":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\deferred.js","./inline-styles":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\inline-styles.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\iframe\builder.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _deferred = require("../utils/deferred");

var _constants = require("../constants");

var _networkUtils = require("../env/browser/networkUtils");

var _inlineStyles = _interopRequireDefault(require("./inline-styles"));

/* eslint-disable import/no-mutable-exports */
var instance;
exports.instance = instance;
var origin;
exports.origin = origin;
var initPromise = (0, _deferred.create)();
exports.initPromise = initPromise;
var timeout = 0;
exports.timeout = timeout;
var error;
/* eslint-enable import/no-mutable-exports */

exports.error = error;
var _messageID = 0; // every postMessage to iframe has its own promise to resolve

var messagePromises = {};
exports.messagePromises = messagePromises;

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    var existedFrame, src, manifestString, manifest, onLoad;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            exports.initPromise = initPromise = (0, _deferred.create)();
            existedFrame = document.getElementById('trezorconnect');

            if (existedFrame) {
              exports.instance = instance = existedFrame;
            } else {
              exports.instance = instance = document.createElement('iframe');
              instance.frameBorder = '0';
              instance.width = '0px';
              instance.height = '0px';
              instance.style.position = 'absolute';
              instance.style.display = 'none';
              instance.style.border = '0px';
              instance.style.width = '0px';
              instance.style.height = '0px';
              instance.id = 'trezorconnect';
            }

            if (settings.env === 'web') {
              manifestString = settings.manifest ? JSON.stringify(settings.manifest) : 'undefined'; // note: btoa(undefined) === btoa('undefined') === "dW5kZWZpbmVk"

              manifest = "version=" + settings.version + "&manifest=" + encodeURIComponent(btoa(JSON.stringify(manifestString)));
              src = settings.iframeSrc + "?" + manifest;
            } else {
              src = settings.iframeSrc;
            }

            instance.setAttribute('src', src);

            if (settings.webusb) {
              instance.setAttribute('allow', 'usb');
            }

            exports.origin = origin = (0, _networkUtils.getOrigin)(instance.src);
            exports.timeout = timeout = window.setTimeout(function () {
              initPromise.reject(_constants.ERRORS.TypedError('Init_IframeTimeout'));
            }, 10000);

            onLoad = function onLoad() {
              if (!instance) {
                initPromise.reject(_constants.ERRORS.TypedError('Init_IframeBlocked'));
                return;
              }

              try {
                // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                var iframeOrigin = instance.contentWindow.location.origin;

                if (!iframeOrigin || iframeOrigin === 'null') {
                  // eslint-disable-next-line no-use-before-define
                  handleIframeBlocked();
                  return;
                }
              } catch (e) {// empty
              }

              var extension; // $FlowIssue chrome is not declared outside

              if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                chrome.runtime.onConnect.addListener(function () {});
                extension = chrome.runtime.id;
              }

              instance.contentWindow.postMessage({
                type: _constants.IFRAME.INIT,
                payload: {
                  settings: settings,
                  extension: extension
                }
              }, origin);
              instance.onload = undefined;
            }; // IE hack


            if (instance.attachEvent) {
              instance.attachEvent('onload', onLoad);
            } else {
              instance.onload = onLoad;
            } // inject iframe into host document body


            if (document.body) {
              document.body.appendChild(instance); // eslint-disable-next-line no-use-before-define

              injectStyleSheet();
            }

            _context.prev = 11;
            _context.next = 14;
            return initPromise.promise;

          case 14:
            _context.next = 20;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](11);

            // reset state to allow initialization again
            if (instance) {
              if (instance.parentNode) {
                instance.parentNode.removeChild(instance);
              }

              exports.instance = instance = null;
            }

            throw _context.t0;

          case 20:
            _context.prev = 20;
            window.clearTimeout(timeout);
            exports.timeout = timeout = 0;
            return _context.finish(20);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 16, 20, 24]]);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var injectStyleSheet = function injectStyleSheet() {
  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  var doc = instance.ownerDocument;
  var head = doc.head || doc.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.setAttribute('id', 'TrezorConnectStylesheet'); // $FlowIssue

  if (style.styleSheet) {
    // IE
    // $FlowIssue
    style.styleSheet.cssText = _inlineStyles["default"];
    head.appendChild(style);
  } else {
    style.appendChild(document.createTextNode(_inlineStyles["default"]));
    head.append(style);
  }
};

var handleIframeBlocked = function handleIframeBlocked() {
  window.clearTimeout(timeout);
  exports.error = error = _constants.ERRORS.TypedError('Init_IframeBlocked'); // eslint-disable-next-line no-use-before-define

  dispose();
  initPromise.reject(error);
}; // post messages to iframe


var postMessage = function postMessage(message, usePromise) {
  if (usePromise === void 0) {
    usePromise = true;
  }

  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  if (usePromise) {
    _messageID++;
    message.id = _messageID;
    messagePromises[_messageID] = (0, _deferred.create)();
    var promise = messagePromises[_messageID].promise;
    instance.contentWindow.postMessage(message, origin);
    return promise;
  }

  instance.contentWindow.postMessage(message, origin);
  return null;
};

exports.postMessage = postMessage;

var dispose = function dispose() {
  if (instance && instance.parentNode) {
    try {
      instance.parentNode.removeChild(instance);
    } catch (e) {// do nothing
    }
  }

  exports.instance = instance = null;
  exports.timeout = timeout = 0;
};

exports.dispose = dispose;

var clearTimeout = function clearTimeout() {
  window.clearTimeout(timeout);
};

exports.clearTimeout = clearTimeout;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\builder.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\dist\personal-sign.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const utils_1 = require("./utils");
/**
 * Create an Ethereum-specific signature for a message.
 *
 * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,
 * as well as the MetaMask's `personal_sign` method.
 *
 * @param options - The personal sign options.
 * @param options.privateKey - The key to sign with.
 * @param options.data - The hex data to sign.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function personalSign({ privateKey, data, }) {
    if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const message = utils_1.legacyToBuffer(data);
    const msgHash = ethereumjs_util_1.hashPersonalMessage(message);
    const sig = ethereumjs_util_1.ecsign(msgHash, privateKey);
    const serialized = utils_1.concatSig(ethereumjs_util_1.toBuffer(sig.v), sig.r, sig.s);
    return serialized;
}
exports.personalSign = personalSign;
/**
 * Recover the address of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The signature recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded address of the message signer.
 */
function recoverPersonalSignature({ data, signature, }) {
    if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    const sender = ethereumjs_util_1.publicToAddress(publicKey);
    const senderHex = ethereumjs_util_1.bufferToHex(sender);
    return senderHex;
}
exports.recoverPersonalSignature = recoverPersonalSignature;
/**
 * Recover the public key of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The public key recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded public key of the message signer.
 */
function extractPublicKey({ data, signature, }) {
    if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    return `0x${publicKey.toString('hex')}`;
}
exports.extractPublicKey = extractPublicKey;
/**
 * Get the public key for the given signature and message.
 *
 * @param message - The message that was signed.
 * @param signature - The '0x'-prefixed hex encoded message signature.
 * @returns The public key of the signer.
 */
function getPublicKeyFor(message, signature) {
    const messageHash = ethereumjs_util_1.hashPersonalMessage(utils_1.legacyToBuffer(message));
    return utils_1.recoverPublicKey(messageHash, signature);
}
//# sourceMappingURL=personal-sign.js.map
      };
    };
  }
}, {package:"@metamask\\eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","tweetnacl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\dist\encryption.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
const nacl = __importStar(require("tweetnacl"));
const naclUtil = __importStar(require("tweetnacl-util"));
const utils_1 = require("./utils");
/**
 * Encrypt a message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encrypt({ publicKey, data, version, }) {
    if (utils_1.isNullish(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(version)) {
        throw new Error('Missing version parameter');
    }
    switch (version) {
        case 'x25519-xsalsa20-poly1305': {
            if (typeof data !== 'string') {
                throw new Error('Message data must be given as a string');
            }
            // generate ephemeral keypair
            const ephemeralKeyPair = nacl.box.keyPair();
            // assemble encryption parameters - from string to UInt8
            let pubKeyUInt8Array;
            try {
                pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
            }
            catch (err) {
                throw new Error('Bad public key');
            }
            const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            // encrypt
            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
            // handle encrypted data
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: naclUtil.encodeBase64(nonce),
                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
                ciphertext: naclUtil.encodeBase64(encryptedMessage),
            };
            // return encrypted msg data
            return output;
        }
        default:
            throw new Error('Encryption type/version not supported');
    }
}
exports.encrypt = encrypt;
/**
 * Encrypt a message in a way that obscures the message length.
 *
 * The message is padded to a multiple of 2048 before being encrypted so that the length of the
 * resulting encrypted message can't be used to guess the exact length of the original message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encryptSafely({ publicKey, data, version, }) {
    if (utils_1.isNullish(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(version)) {
        throw new Error('Missing version parameter');
    }
    const DEFAULT_PADDING_LENGTH = 2 ** 11;
    const NACL_EXTRA_BYTES = 16;
    if (typeof data === 'object' && 'toJSON' in data) {
        // remove toJSON attack vector
        // TODO, check all possible children
        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    }
    // add padding
    const dataWithPadding = {
        data,
        padding: '',
    };
    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    const modVal = dataLength % DEFAULT_PADDING_LENGTH;
    let padLength = 0;
    // Only pad if necessary
    if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength);
    const paddedMessage = JSON.stringify(dataWithPadding);
    return encrypt({ publicKey, data: paddedMessage, version });
}
exports.encryptSafely = encryptSafely;
/**
 * Decrypt a message.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decrypt({ encryptedData, privateKey, }) {
    if (utils_1.isNullish(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if (utils_1.isNullish(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    switch (encryptedData.version) {
        case 'x25519-xsalsa20-poly1305': {
            // string to buffer to UInt8Array
            const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);
            const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(encryptedData.nonce);
            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
            // decrypt
            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
            // return decrypted msg data
            let output;
            try {
                output = naclUtil.encodeUTF8(decryptedMessage);
            }
            catch (err) {
                throw new Error('Decryption failed.');
            }
            if (output) {
                return output;
            }
            throw new Error('Decryption failed.');
        }
        default:
            throw new Error('Encryption type/version not supported.');
    }
}
exports.decrypt = decrypt;
/**
 * Decrypt a message that has been encrypted using `encryptSafely`.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decryptSafely({ encryptedData, privateKey, }) {
    if (utils_1.isNullish(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if (utils_1.isNullish(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));
    return dataWithPadding.data;
}
exports.decryptSafely = decryptSafely;
/**
 * Get the encryption public key for the given key.
 *
 * @param privateKey - The private key to generate the encryption public key with.
 * @returns The encryption public key.
 */
function getEncryptionPublicKey(privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey);
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return naclUtil.encodeBase64(encryptionPublicKey);
}
exports.getEncryptionPublicKey = getEncryptionPublicKey;
/**
 * Convert a hex string to the UInt8Array format used by nacl.
 *
 * @param msgHex - The string to convert.
 * @returns The converted string.
 */
function nacl_decodeHex(msgHex) {
    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');
    return naclUtil.decodeBase64(msgBase64);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\dist\sign-typed-data.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethereumjs_abi_1 = require("ethereumjs-abi");
const utils_1 = require("./utils");
/**
 * Represents the version of `signTypedData` being used.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.
 *
 * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
exports.TYPED_MESSAGE_SCHEMA = {
    type: 'object',
    properties: {
        types: {
            type: 'object',
            additionalProperties: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        type: { type: 'string', enum: getSolidityTypes() },
                    },
                    required: ['name', 'type'],
                },
            },
        },
        primaryType: { type: 'string' },
        domain: { type: 'object' },
        message: { type: 'object' },
    },
    required: ['types', 'primaryType', 'domain', 'message'],
};
/**
 * Get a list of all Solidity types.
 *
 * @returns A list of all Solidity types.
 */
function getSolidityTypes() {
    const types = ['bool', 'address', 'string', 'bytes'];
    const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
    const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
    const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);
    return [...types, ...ints, ...uints, ...bytes];
}
/**
 * Validate that the given value is a valid version string.
 *
 * @param version - The version value to validate.
 * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be
 * allowed.
 */
function validateVersion(version, allowedVersions) {
    if (!Object.keys(SignTypedDataVersion).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
    }
    else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);
    }
}
/**
 * Encode a single field.
 *
 * @param types - All type definitions.
 * @param name - The name of the field to encode.
 * @param type - The type of the field being encoded.
 * @param value - The value to encode.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns Encoded representation of the field.
 */
function encodeField(types, name, type, value, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    if (types[type] !== undefined) {
        return [
            'bytes32',
            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null
                ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                : ethereumjs_util_1.keccak(encodeData(type, value, types, version)),
        ];
    }
    if (value === undefined) {
        throw new Error(`missing value for field ${name} of type ${type}`);
    }
    if (type === 'bytes') {
        return ['bytes32', ethereumjs_util_1.keccak(value)];
    }
    if (type === 'string') {
        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
        if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8');
        }
        return ['bytes32', ethereumjs_util_1.keccak(value)];
    }
    if (type.lastIndexOf(']') === type.length - 1) {
        if (version === SignTypedDataVersion.V3) {
            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
        }
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
            'bytes32',
            ethereumjs_util_1.keccak(ethereumjs_abi_1.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
        ];
    }
    return [type, value];
}
/**
 * Encodes an object by encoding and concatenating each of its members.
 *
 * @param primaryType - The root type.
 * @param data - The object to encode.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns An encoded representation of an object.
 */
function encodeData(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const encodedTypes = ['bytes32'];
    const encodedValues = [hashType(primaryType, types)];
    for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {
            continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return ethereumjs_abi_1.rawEncode(encodedTypes, encodedValues);
}
/**
 * Encodes the type of an object by encoding a comma delimited list of its members.
 *
 * @param primaryType - The root type to encode.
 * @param types - Type definitions for all types included in the message.
 * @returns An encoded representation of the primary type.
 */
function encodeType(primaryType, types) {
    let result = '';
    const unsortedDeps = findTypeDependencies(primaryType, types);
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        const children = types[type];
        if (!children) {
            throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
    }
    return result;
}
/**
 * Finds all types within a type definition object.
 *
 * @param primaryType - The root type.
 * @param types - Type definitions for all types included in the message.
 * @param results - The current set of accumulated types.
 * @returns The set of all types found in the type definition.
 */
function findTypeDependencies(primaryType, types, results = new Set()) {
    [primaryType] = primaryType.match(/^\w*/u);
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
    }
    return results;
}
/**
 * Hashes an object.
 *
 * @param primaryType - The root type.
 * @param data - The object to hash.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the object.
 */
function hashStruct(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    return ethereumjs_util_1.keccak(encodeData(primaryType, data, types, version));
}
/**
 * Hashes the type of an object.
 *
 * @param primaryType - The root type to hash.
 * @param types - Type definitions for all types included in the message.
 * @returns The hash of the object type.
 */
function hashType(primaryType, types) {
    return ethereumjs_util_1.keccak(encodeType(primaryType, types));
}
/**
 * Removes properties from a message object that are not defined per EIP-712.
 *
 * @param data - The typed message object.
 * @returns The typed message object with only allowed fields.
 */
function sanitizeData(data) {
    const sanitizedData = {};
    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
            sanitizedData[key] = data[key];
        }
    }
    if ('types' in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
    }
    return sanitizedData;
}
/**
 * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,
 * which is "1901", followed by the hash of the domain separator, then the data (if any).
 * The result is hashed again and returned.
 *
 * This function does not sign the message. The resulting hash must still be signed to create an
 * EIP-712 signature.
 *
 * @param typedData - The typed message to hash.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the typed message.
 */
function eip712Hash(typedData, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const sanitizedData = sanitizeData(typedData);
    const parts = [Buffer.from('1901', 'hex')];
    parts.push(hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, version));
    if (sanitizedData.primaryType !== 'EIP712Domain') {
        parts.push(hashStruct(
        // TODO: Validate that this is a string, so this type cast can be removed.
        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));
    }
    return ethereumjs_util_1.keccak(Buffer.concat(parts));
}
/**
 * A collection of utility functions used for signing typed data.
 */
exports.TypedDataUtils = {
    encodeData,
    encodeType,
    findTypeDependencies,
    hashStruct,
    hashType,
    sanitizeData,
    eip712Hash,
};
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.
 */
function typedSignatureHash(typedData) {
    const hashBuffer = _typedSignatureHash(typedData);
    return ethereumjs_util_1.bufferToHex(hashBuffer);
}
exports.typedSignatureHash = typedSignatureHash;
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The hash representing the type of the provided message.
 */
function _typedSignatureHash(typedData) {
    const error = new Error('Expect argument to be non-empty array');
    if (typeof typedData !== 'object' ||
        !('length' in typedData) ||
        !typedData.length) {
        throw error;
    }
    const data = typedData.map(function (e) {
        if (e.type !== 'bytes') {
            return e.value;
        }
        return utils_1.legacyToBuffer(e.value);
    });
    const types = typedData.map(function (e) {
        return e.type;
    });
    const schema = typedData.map(function (e) {
        if (!e.name) {
            throw error;
        }
        return `${e.type} ${e.name}`;
    });
    return ethereumjs_abi_1.soliditySHA3(['bytes32', 'bytes32'], [
        ethereumjs_abi_1.soliditySHA3(new Array(typedData.length).fill('string'), schema),
        ethereumjs_abi_1.soliditySHA3(types, data),
    ]);
}
/**
 * Sign typed data according to EIP-712. The signing differs based upon the `version`.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and
 * recursive data structures are not supported.
 *
 * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of
 * arrays and recursive data structures.
 *
 * @param options - The signing options.
 * @param options.privateKey - The private key to sign with.
 * @param options.data - The typed data to sign.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function signTypedData({ privateKey, data, version, }) {
    validateVersion(version);
    if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(privateKey)) {
        throw new Error('Missing private key parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const sig = ethereumjs_util_1.ecsign(messageHash, privateKey);
    return utils_1.concatSig(ethereumjs_util_1.toBuffer(sig.v), sig.r, sig.s);
}
exports.signTypedData = signTypedData;
/**
 * Recover the address of the account that created the given EIP-712
 * signature. The version provided must match the version used to
 * create the signature.
 *
 * @param options - The signature recovery options.
 * @param options.data - The typed data that was signed.
 * @param options.signature - The '0x-prefixed hex encoded message signature.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex address of the signer.
 */
function recoverTypedSignature({ data, signature, version, }) {
    validateVersion(version);
    if (utils_1.isNullish(data)) {
        throw new Error('Missing data parameter');
    }
    else if (utils_1.isNullish(signature)) {
        throw new Error('Missing signature parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const publicKey = utils_1.recoverPublicKey(messageHash, signature);
    const sender = ethereumjs_util_1.publicToAddress(publicKey);
    return ethereumjs_util_1.bufferToHex(sender);
}
exports.recoverTypedSignature = recoverTypedSignature;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\dist\utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_util_1 = require("ethjs-util");
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */
function padWithZeroes(hexString, targetLength) {
    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, '0');
}
exports.padWithZeroes = padWithZeroes;
/**
 * Returns `true` if the given value is nullish.
 *
 * @param value - The value being checked.
 * @returns Whether the value is nullish.
 */
function isNullish(value) {
    return value === null || value === undefined;
}
exports.isNullish = isNullish;
/**
 * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in
 * `ethereumjs-util@5.2.1`.
 *
 * @param value - The value to convert to a Buffer.
 * @returns The given value as a Buffer.
 */
function legacyToBuffer(value) {
    return typeof value === 'string' && !ethjs_util_1.isHexString(value)
        ? Buffer.from(value)
        : ethereumjs_util_1.toBuffer(value);
}
exports.legacyToBuffer = legacyToBuffer;
/**
 * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature as a '0x'-prefixed string.
 */
function concatSig(v, r, s) {
    const rSig = ethereumjs_util_1.fromSigned(r);
    const sSig = ethereumjs_util_1.fromSigned(s);
    const vSig = ethereumjs_util_1.bufferToInt(v);
    const rStr = padWithZeroes(ethereumjs_util_1.toUnsigned(rSig).toString('hex'), 64);
    const sStr = padWithZeroes(ethereumjs_util_1.toUnsigned(sSig).toString('hex'), 64);
    const vStr = ethjs_util_1.stripHexPrefix(ethjs_util_1.intToHex(vSig));
    return ethereumjs_util_1.addHexPrefix(rStr.concat(sStr, vStr));
}
exports.concatSig = concatSig;
/**
 * Recover the public key from the given signature and message hash.
 *
 * @param messageHash - The hash of the signed message.
 * @param signature - The signature.
 * @returns The public key of the signer.
 */
function recoverPublicKey(messageHash, signature) {
    const sigParams = ethereumjs_util_1.fromRpcSig(signature);
    return ethereumjs_util_1.ecrecover(messageHash, sigParams.v, sigParams.r, sigParams.s);
}
exports.recoverPublicKey = recoverPublicKey;
/**
 * Normalize the input to a lower-cased '0x'-prefixed hex string.
 *
 * @param input - The value to normalize.
 * @returns The normalized value.
 */
function normalize(input) {
    if (!input) {
        return undefined;
    }
    if (typeof input === 'number') {
        const buffer = ethereumjs_util_1.toBuffer(input);
        input = ethereumjs_util_1.bufferToHex(buffer);
    }
    if (typeof input !== 'string') {
        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
    }
    return ethereumjs_util_1.addHexPrefix(input.toLowerCase());
}
exports.normalize = normalize;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs", {"./url-alphabet/index.cjs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\url-alphabet\\index.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\nanoid\index.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
if ("development" !== 'production') {
  if (
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative' &&
    typeof crypto === 'undefined'
  ) {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +
        'For secure IDs, import `react-native-get-random-values` ' +
        'before Nano ID.'
    )
  }
  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error(
      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
        ' before importing Nano ID to fix IE 11 support'
    )
  }
  if (typeof crypto === 'undefined') {
    throw new Error(
      'Your browser does not have secure random generator. ' +
        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * size) / alphabet.length)
  return () => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array(size))
  while (size--) {
    let byte = bytes[size] & 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
}, {package:"nanoid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\index.browser.cjs",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\network-access.js", {"../Permission":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\Permission.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\endowments\network-access.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.networkAccessEndowmentBuilder = void 0;
const Permission_1 = require("../Permission");
const permissionName = 'endowment:network-access';
/**
 * `endowment:network-access` returns the name of global browser API(s) that
 * enable network access. This is intended to populate the endowments of the
 * SES Compartment in which a Snap executes.
 */
const specificationBuilder = (_builderOptions) => {
    return {
        permissionType: Permission_1.PermissionType.Endowment,
        targetKey: permissionName,
        allowedCaveats: null,
        endowmentGetter: (_getterOptions) => {
            return ['fetch'];
        },
    };
};
exports.networkAccessEndowmentBuilder = Object.freeze({
    targetKey: permissionName,
    specificationBuilder,
});
//# sourceMappingURL=network-access.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\endowments\\network-access.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js", {"fast-deep-equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-deep-equal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\utils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidJson = exports.isNonEmptyArray = exports.hasProperty = exports.isPlainObject = exports.timeSince = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
/**
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
const hasProperty = (object, key) => Reflect.hasOwnProperty.call(object, key);
exports.hasProperty = hasProperty;
/**
 * {@link NonEmptyArray} type guard.
 *
 * @template T - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * {@link Json} type guard.
 *
 * @param value - The value to check.
 * @returns Whether the value is valid JSON.
 */
function isValidJson(value) {
    try {
        return fast_deep_equal_1.default(value, JSON.parse(JSON.stringify(value)));
    }
    catch (_) {
        return false;
    }
}
exports.isValidJson = isValidJson;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js", {"eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\errors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsRequestNotFoundError = exports.DuplicateCaveatError = exports.ForbiddenCaveatError = exports.InvalidCaveatFieldsError = exports.CaveatInvalidJsonError = exports.CaveatMissingValueError = exports.InvalidCaveatTypeError = exports.InvalidCaveatError = exports.CaveatAlreadyExistsError = exports.CaveatDoesNotExistError = exports.InvalidCaveatsPropertyError = exports.UnrecognizedCaveatTypeError = exports.EndowmentPermissionDoesNotExistError = exports.PermissionDoesNotExistError = exports.InvalidApprovedPermissionError = exports.UnrecognizedSubjectError = exports.InvalidSubjectIdentifierError = exports.internalError = exports.userRejectedRequest = exports.invalidParams = exports.methodNotFound = exports.unauthorized = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
function unauthorized(opts) {
    return eth_rpc_errors_1.ethErrors.provider.unauthorized({
        message: 'Unauthorized to perform action. Try requesting the required permission(s) first. For more information, see: https://docs.metamask.io/guide/rpc-api.html#permissions',
        data: opts.data,
    });
}
exports.unauthorized = unauthorized;
function methodNotFound(method, data) {
    const message = `The method "${method}" does not exist / is not available.`;
    const opts = { message };
    if (data !== undefined) {
        opts.data = data;
    }
    return eth_rpc_errors_1.ethErrors.rpc.methodNotFound(opts);
}
exports.methodNotFound = methodNotFound;
function invalidParams(opts) {
    return eth_rpc_errors_1.ethErrors.rpc.invalidParams({
        data: opts.data,
        message: opts.message,
    });
}
exports.invalidParams = invalidParams;
function userRejectedRequest(data) {
    return eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data });
}
exports.userRejectedRequest = userRejectedRequest;
function internalError(message, data) {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message, data });
}
exports.internalError = internalError;
class InvalidSubjectIdentifierError extends Error {
    constructor(origin) {
        super(`Invalid subject identifier: "${typeof origin === 'string' ? origin : typeof origin}"`);
    }
}
exports.InvalidSubjectIdentifierError = InvalidSubjectIdentifierError;
class UnrecognizedSubjectError extends Error {
    constructor(origin) {
        super(`Unrecognized subject: "${origin}" has no permissions.`);
    }
}
exports.UnrecognizedSubjectError = UnrecognizedSubjectError;
class InvalidApprovedPermissionError extends Error {
    constructor(origin, target, approvedPermission) {
        super(`Invalid approved permission for origin "${origin}" and target "${target}".`);
        this.data = { origin, target, approvedPermission };
    }
}
exports.InvalidApprovedPermissionError = InvalidApprovedPermissionError;
class PermissionDoesNotExistError extends Error {
    constructor(origin, target) {
        super(`Subject "${origin}" has no permission for "${target}".`);
    }
}
exports.PermissionDoesNotExistError = PermissionDoesNotExistError;
class EndowmentPermissionDoesNotExistError extends Error {
    constructor(target, origin) {
        super(`Subject "${origin}" has no permission for "${target}".`);
        if (origin) {
            this.data = { origin };
        }
    }
}
exports.EndowmentPermissionDoesNotExistError = EndowmentPermissionDoesNotExistError;
class UnrecognizedCaveatTypeError extends Error {
    constructor(caveatType, origin, target) {
        super(`Unrecognized caveat type: "${caveatType}"`);
        this.data = { caveatType };
        if (origin !== undefined) {
            this.data.origin = origin;
        }
        if (target !== undefined) {
            this.data.target = target;
        }
    }
}
exports.UnrecognizedCaveatTypeError = UnrecognizedCaveatTypeError;
class InvalidCaveatsPropertyError extends Error {
    constructor(origin, target, caveatsProperty) {
        super(`The "caveats" property of permission for "${target}" of subject "${origin}" is invalid. It must be a non-empty array if specified.`);
        this.data = { origin, target, caveatsProperty };
    }
}
exports.InvalidCaveatsPropertyError = InvalidCaveatsPropertyError;
class CaveatDoesNotExistError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" has no caveat of type "${caveatType}".`);
    }
}
exports.CaveatDoesNotExistError = CaveatDoesNotExistError;
class CaveatAlreadyExistsError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" already has a caveat of type "${caveatType}".`);
    }
}
exports.CaveatAlreadyExistsError = CaveatAlreadyExistsError;
class InvalidCaveatError extends eth_rpc_errors_1.EthereumRpcError {
    constructor(receivedCaveat, origin, target) {
        super(eth_rpc_errors_1.errorCodes.rpc.invalidParams, `Invalid caveat. Caveats must be plain objects.`, { receivedCaveat });
        this.data = { origin, target };
    }
}
exports.InvalidCaveatError = InvalidCaveatError;
class InvalidCaveatTypeError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat types must be strings. Received: "${typeof caveat.type}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatTypeError = InvalidCaveatTypeError;
class CaveatMissingValueError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat is missing "value" field.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatMissingValueError = CaveatMissingValueError;
class CaveatInvalidJsonError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat "value" is invalid JSON.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatInvalidJsonError = CaveatInvalidJsonError;
class InvalidCaveatFieldsError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat has unexpected number of fields: "${Object.keys(caveat).length}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatFieldsError = InvalidCaveatFieldsError;
class ForbiddenCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" may not have caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.ForbiddenCaveatError = ForbiddenCaveatError;
class DuplicateCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" contains multiple caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.DuplicateCaveatError = DuplicateCaveatError;
class PermissionsRequestNotFoundError extends Error {
    constructor(id) {
        super(`Permissions request with id "${id}" not found.`);
    }
}
exports.PermissionsRequestNotFoundError = PermissionsRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-freeze-strict\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\deep-freeze-strict\index.js
      return function (require, module, exports) {
module.exports = function deepFreeze (o) {
  Object.freeze(o);

  var oIsFunction = typeof o === "function";
  var hasOwnProp = Object.prototype.hasOwnProperty;

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (hasOwnProp.call(o, prop)
    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

      };
    };
  }
}, {package:"deep-freeze-strict",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-freeze-strict\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\permission-middleware.js", {"./errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js","json-rpc-engine":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\permission-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionMiddlewareFactory = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const errors_1 = require("./errors");
/**
 * Creates a permission middleware function factory. Intended for internal use
 * in the {@link PermissionController}. Like any {@link JsonRpcEngine}
 * middleware, each middleware will only receive requests from a particular
 * subject / origin. However, each middleware also requires access to some
 * `PermissionController` internals, which is why this "factory factory" exists.
 *
 * The middlewares returned by the factory will pass through requests for
 * unrestricted methods, and attempt to execute restricted methods. If a method
 * is neither restricted nor unrestricted, a "method not found" error will be
 * returned.
 * If a method is restricted, the middleware will first attempt to retrieve the
 * subject's permission for that method. If the permission is found, the method
 * will be executed. Otherwise, an "unauthorized" error will be returned.
 *
 * @param options - Options bag.
 * @param options.executeRestrictedMethod - {@link PermissionController._executeRestrictedMethod}.
 * @param options.getRestrictedMethod - {@link PermissionController.getRestrictedMethod}.
 * @param options.isUnrestrictedMethod - A function that checks whether a
 * particular method is unrestricted.
 * @returns A permission middleware factory function.
 */
function getPermissionMiddlewareFactory({ executeRestrictedMethod, getRestrictedMethod, isUnrestrictedMethod, }) {
    return function createPermissionMiddleware(subject) {
        const { origin } = subject;
        if (typeof origin !== 'string' || !origin) {
            throw new Error('The subject "origin" must be a non-empty string.');
        }
        const permissionsMiddleware = async (req, res, next) => {
            const { method, params } = req;
            // Skip registered unrestricted methods.
            if (isUnrestrictedMethod(method)) {
                return next();
            }
            // This will throw if no restricted method implementation is found.
            const methodImplementation = getRestrictedMethod(method, origin);
            // This will throw if the permission does not exist.
            const result = await executeRestrictedMethod(methodImplementation, subject, method, params);
            if (result === undefined) {
                res.error = errors_1.internalError(`Request for method "${req.method}" returned undefined result.`, { request: req });
                return undefined;
            }
            res.result = result;
            return undefined;
        };
        return json_rpc_engine_1.createAsyncMiddleware(permissionsMiddleware);
    };
}
exports.getPermissionMiddlewareFactory = getPermissionMiddlewareFactory;
//# sourceMappingURL=permission-middleware.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\permission-middleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\getPermissions.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\rpc-methods\getPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionsHandler = void 0;
const utils_1 = require("../utils");
exports.getPermissionsHandler = {
    methodNames: [utils_1.MethodNames.getPermissions],
    implementation: getPermissionsImplementation,
    hookNames: {
        getPermissionsForOrigin: true,
    },
};
async function getPermissionsImplementation(_req, res, _next, end, { getPermissionsForOrigin }) {
    res.result = Object.values(getPermissionsForOrigin() || {});
    return end();
}
//# sourceMappingURL=getPermissions.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\getPermissions.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\requestPermissions.js", {"../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\utils.js","../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\errors.js","../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\utils.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\permissions\rpc-methods\requestPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestPermissionsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const utils_2 = require("../../utils");
exports.requestPermissionsHandler = {
    methodNames: [utils_1.MethodNames.requestPermissions],
    implementation: requestPermissionsImplementation,
    hookNames: {
        requestPermissionsForOrigin: true,
    },
};
async function requestPermissionsImplementation(req, res, _next, end, { requestPermissionsForOrigin }) {
    const { id, params } = req;
    if ((typeof id !== 'number' && typeof id !== 'string') ||
        (typeof id === 'string' && !id)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: 'Invalid request: Must specify a valid id.',
            data: { request: req },
        }));
    }
    if (!Array.isArray(params) || !utils_2.isPlainObject(params[0])) {
        return end(errors_1.invalidParams({ data: { request: req } }));
    }
    const [requestedPermissions] = params;
    const [grantedPermissions] = await requestPermissionsForOrigin(requestedPermissions, String(id));
    // `wallet_requestPermission` is specified to return an array.
    res.result = Object.values(grantedPermissions);
    return end();
}
//# sourceMappingURL=requestPermissions.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\permissions\\rpc-methods\\requestPermissions.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateSnapManifest.js", {"ajv/dist/runtime/equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\equal.js","ajv/dist/runtime/ucs2length":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\ucs2length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\json-schemas\validateSnapManifest.js
      return function (require, module, exports) {
"use strict";
module.exports = validate20;
module.exports.default = validate20;
const schema22 = { "title": "Snap Manifest", "description": "The Snap manifest file MUST be named `snap.manifest.json` and located in the package root directory.", "type": "object", "additionalProperties": false, "required": ["version", "description", "proposedName", "source", "initialPermissions", "manifestVersion"], "properties": { "version": { "type": "string", "title": "Version", "description": "MUST be a valid SemVer version string and equal to the corresponding `package.json` field.", "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" }, "description": { "type": "string", "title": "Description", "description": "MUST be a non-empty string less than or equal to 280 characters. A short description of the Snap.", "minLength": 1, "maxLength": 280 }, "proposedName": { "type": "string", "title": "Proposed Name", "description": "MUST be a string less than or equal to 214 characters. The Snap author's proposed name for the Snap. The Snap host application may display this name unmodified in its user interface. The proposed name SHOULD be human-readable.", "minLength": 1, "maxLength": 214, "pattern": "^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$" }, "repository": { "title": "Repository", "description": "MAY be omitted. If present, MUST be equal to the corresponding package.json field.", "oneOf": [{ "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["type", "url"], "properties": { "type": { "type": "string", "minLength": 1 }, "url": { "type": "string", "minLength": 1 } } }] }, "source": { "type": "object", "title": "Source", "description": "Specifies some Snap metadata and where to fetch the Snap during installation.", "additionalProperties": false, "required": ["shasum", "location"], "properties": { "shasum": { "type": "string", "description": "MUST be the Base64-encoded string representation of the SHA-256 hash of the Snap source file.", "minLength": 44, "maxLength": 44, "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$" }, "location": { "title": "Source Location", "type": "object", "additionalProperties": false, "required": ["npm"], "properties": { "npm": { "title": "npm", "type": "object", "additionalProperties": false, "required": ["filePath", "packageName", "registry"], "properties": { "filePath": { "type": "string", "title": "File Path", "description": "The path to the Snap bundle file from the project root directory.", "minLength": 1 }, "iconPath": { "type": "string", "title": "Icon Path", "description": "The path to an .svg file from the project root directory.", "pattern": "\\w+\\.svg$" }, "packageName": { "type": "string", "title": "Package Name", "description": "The Snap's npm package name.", "minLength": 1 }, "registry": { "type": "string", "title": "npm Registry", "description": "The npm registry URL.", "enum": ["https://registry.npmjs.org", "https://registry.npmjs.org/"] } } } } } } }, "initialPermissions": { "type": "object", "title": "Initial Permissions", "description": "MUST be a valid EIP-2255 wallet_requestPermissions parameter object, specifying the initial permissions that will be requested when the Snap is added to the host application." }, "manifestVersion": { "type": "string", "title": "Manifest Version", "description": "The Snap manifest specification version targeted by the manifest.", "enum": ["0.1"] } } };
const pattern0 = new RegExp("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$", "u");
const pattern1 = new RegExp("^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$", "u");
const pattern2 = new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$", "u");
const pattern3 = new RegExp("\\w+\\.svg$", "u");
const func8 = require("ajv/dist/runtime/ucs2length").default;
const func0 = require("ajv/dist/runtime/equal").default;
function validate20(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) { let vErrors = null; let errors = 0; if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.version === undefined) {
        const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "version" }, message: "must have required property '" + "version" + "'" };
        if (vErrors === null) {
            vErrors = [err0];
        }
        else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (data.description === undefined) {
        const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "description" }, message: "must have required property '" + "description" + "'" };
        if (vErrors === null) {
            vErrors = [err1];
        }
        else {
            vErrors.push(err1);
        }
        errors++;
    }
    if (data.proposedName === undefined) {
        const err2 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "proposedName" }, message: "must have required property '" + "proposedName" + "'" };
        if (vErrors === null) {
            vErrors = [err2];
        }
        else {
            vErrors.push(err2);
        }
        errors++;
    }
    if (data.source === undefined) {
        const err3 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property '" + "source" + "'" };
        if (vErrors === null) {
            vErrors = [err3];
        }
        else {
            vErrors.push(err3);
        }
        errors++;
    }
    if (data.initialPermissions === undefined) {
        const err4 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "initialPermissions" }, message: "must have required property '" + "initialPermissions" + "'" };
        if (vErrors === null) {
            vErrors = [err4];
        }
        else {
            vErrors.push(err4);
        }
        errors++;
    }
    if (data.manifestVersion === undefined) {
        const err5 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "manifestVersion" }, message: "must have required property '" + "manifestVersion" + "'" };
        if (vErrors === null) {
            vErrors = [err5];
        }
        else {
            vErrors.push(err5);
        }
        errors++;
    }
    for (const key0 in data) {
        if (!(((((((key0 === "version") || (key0 === "description")) || (key0 === "proposedName")) || (key0 === "repository")) || (key0 === "source")) || (key0 === "initialPermissions")) || (key0 === "manifestVersion"))) {
            const err6 = { instancePath, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
            if (vErrors === null) {
                vErrors = [err6];
            }
            else {
                vErrors.push(err6);
            }
            errors++;
        }
    }
    if (data.version !== undefined) {
        let data0 = data.version;
        if (typeof data0 === "string") {
            if (!pattern0.test(data0)) {
                const err7 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/pattern", keyword: "pattern", params: { pattern: "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" }, message: "must match pattern \"" + "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" + "\"" };
                if (vErrors === null) {
                    vErrors = [err7];
                }
                else {
                    vErrors.push(err7);
                }
                errors++;
            }
        }
        else {
            const err8 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err8];
            }
            else {
                vErrors.push(err8);
            }
            errors++;
        }
    }
    if (data.description !== undefined) {
        let data1 = data.description;
        if (typeof data1 === "string") {
            if (func8(data1) > 280) {
                const err9 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/maxLength", keyword: "maxLength", params: { limit: 280 }, message: "must NOT have more than 280 characters" };
                if (vErrors === null) {
                    vErrors = [err9];
                }
                else {
                    vErrors.push(err9);
                }
                errors++;
            }
            if (func8(data1) < 1) {
                const err10 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                if (vErrors === null) {
                    vErrors = [err10];
                }
                else {
                    vErrors.push(err10);
                }
                errors++;
            }
        }
        else {
            const err11 = { instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err11];
            }
            else {
                vErrors.push(err11);
            }
            errors++;
        }
    }
    if (data.proposedName !== undefined) {
        let data2 = data.proposedName;
        if (typeof data2 === "string") {
            if (func8(data2) > 214) {
                const err12 = { instancePath: instancePath + "/proposedName", schemaPath: "#/properties/proposedName/maxLength", keyword: "maxLength", params: { limit: 214 }, message: "must NOT have more than 214 characters" };
                if (vErrors === null) {
                    vErrors = [err12];
                }
                else {
                    vErrors.push(err12);
                }
                errors++;
            }
            if (func8(data2) < 1) {
                const err13 = { instancePath: instancePath + "/proposedName", schemaPath: "#/properties/proposedName/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                if (vErrors === null) {
                    vErrors = [err13];
                }
                else {
                    vErrors.push(err13);
                }
                errors++;
            }
            if (!pattern1.test(data2)) {
                const err14 = { instancePath: instancePath + "/proposedName", schemaPath: "#/properties/proposedName/pattern", keyword: "pattern", params: { pattern: "^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$" }, message: "must match pattern \"" + "^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$" + "\"" };
                if (vErrors === null) {
                    vErrors = [err14];
                }
                else {
                    vErrors.push(err14);
                }
                errors++;
            }
        }
        else {
            const err15 = { instancePath: instancePath + "/proposedName", schemaPath: "#/properties/proposedName/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err15];
            }
            else {
                vErrors.push(err15);
            }
            errors++;
        }
    }
    if (data.repository !== undefined) {
        let data3 = data.repository;
        const _errs9 = errors;
        let valid1 = false;
        let passing0 = null;
        const _errs10 = errors;
        if (data3 !== null) {
            const err16 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf/0/type", keyword: "type", params: { type: "null" }, message: "must be null" };
            if (vErrors === null) {
                vErrors = [err16];
            }
            else {
                vErrors.push(err16);
            }
            errors++;
        }
        var _valid0 = _errs10 === errors;
        if (_valid0) {
            valid1 = true;
            passing0 = 0;
        }
        const _errs12 = errors;
        if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
            if (data3.type === undefined) {
                const err17 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf/1/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property '" + "type" + "'" };
                if (vErrors === null) {
                    vErrors = [err17];
                }
                else {
                    vErrors.push(err17);
                }
                errors++;
            }
            if (data3.url === undefined) {
                const err18 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf/1/required", keyword: "required", params: { missingProperty: "url" }, message: "must have required property '" + "url" + "'" };
                if (vErrors === null) {
                    vErrors = [err18];
                }
                else {
                    vErrors.push(err18);
                }
                errors++;
            }
            for (const key1 in data3) {
                if (!((key1 === "type") || (key1 === "url"))) {
                    const err19 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf/1/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key1 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                        vErrors = [err19];
                    }
                    else {
                        vErrors.push(err19);
                    }
                    errors++;
                }
            }
            if (data3.type !== undefined) {
                let data4 = data3.type;
                if (typeof data4 === "string") {
                    if (func8(data4) < 1) {
                        const err20 = { instancePath: instancePath + "/repository/type", schemaPath: "#/properties/repository/oneOf/1/properties/type/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                        if (vErrors === null) {
                            vErrors = [err20];
                        }
                        else {
                            vErrors.push(err20);
                        }
                        errors++;
                    }
                }
                else {
                    const err21 = { instancePath: instancePath + "/repository/type", schemaPath: "#/properties/repository/oneOf/1/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err21];
                    }
                    else {
                        vErrors.push(err21);
                    }
                    errors++;
                }
            }
            if (data3.url !== undefined) {
                let data5 = data3.url;
                if (typeof data5 === "string") {
                    if (func8(data5) < 1) {
                        const err22 = { instancePath: instancePath + "/repository/url", schemaPath: "#/properties/repository/oneOf/1/properties/url/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                        if (vErrors === null) {
                            vErrors = [err22];
                        }
                        else {
                            vErrors.push(err22);
                        }
                        errors++;
                    }
                }
                else {
                    const err23 = { instancePath: instancePath + "/repository/url", schemaPath: "#/properties/repository/oneOf/1/properties/url/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err23];
                    }
                    else {
                        vErrors.push(err23);
                    }
                    errors++;
                }
            }
        }
        else {
            const err24 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
                vErrors = [err24];
            }
            else {
                vErrors.push(err24);
            }
            errors++;
        }
        var _valid0 = _errs12 === errors;
        if (_valid0 && valid1) {
            valid1 = false;
            passing0 = [passing0, 1];
        }
        else {
            if (_valid0) {
                valid1 = true;
                passing0 = 1;
            }
        }
        if (!valid1) {
            const err25 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
                vErrors = [err25];
            }
            else {
                vErrors.push(err25);
            }
            errors++;
        }
        else {
            errors = _errs9;
            if (vErrors !== null) {
                if (_errs9) {
                    vErrors.length = _errs9;
                }
                else {
                    vErrors = null;
                }
            }
        }
    }
    if (data.source !== undefined) {
        let data6 = data.source;
        if (data6 && typeof data6 == "object" && !Array.isArray(data6)) {
            if (data6.shasum === undefined) {
                const err26 = { instancePath: instancePath + "/source", schemaPath: "#/properties/source/required", keyword: "required", params: { missingProperty: "shasum" }, message: "must have required property '" + "shasum" + "'" };
                if (vErrors === null) {
                    vErrors = [err26];
                }
                else {
                    vErrors.push(err26);
                }
                errors++;
            }
            if (data6.location === undefined) {
                const err27 = { instancePath: instancePath + "/source", schemaPath: "#/properties/source/required", keyword: "required", params: { missingProperty: "location" }, message: "must have required property '" + "location" + "'" };
                if (vErrors === null) {
                    vErrors = [err27];
                }
                else {
                    vErrors.push(err27);
                }
                errors++;
            }
            for (const key2 in data6) {
                if (!((key2 === "shasum") || (key2 === "location"))) {
                    const err28 = { instancePath: instancePath + "/source", schemaPath: "#/properties/source/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key2 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                        vErrors = [err28];
                    }
                    else {
                        vErrors.push(err28);
                    }
                    errors++;
                }
            }
            if (data6.shasum !== undefined) {
                let data7 = data6.shasum;
                if (typeof data7 === "string") {
                    if (func8(data7) > 44) {
                        const err29 = { instancePath: instancePath + "/source/shasum", schemaPath: "#/properties/source/properties/shasum/maxLength", keyword: "maxLength", params: { limit: 44 }, message: "must NOT have more than 44 characters" };
                        if (vErrors === null) {
                            vErrors = [err29];
                        }
                        else {
                            vErrors.push(err29);
                        }
                        errors++;
                    }
                    if (func8(data7) < 44) {
                        const err30 = { instancePath: instancePath + "/source/shasum", schemaPath: "#/properties/source/properties/shasum/minLength", keyword: "minLength", params: { limit: 44 }, message: "must NOT have fewer than 44 characters" };
                        if (vErrors === null) {
                            vErrors = [err30];
                        }
                        else {
                            vErrors.push(err30);
                        }
                        errors++;
                    }
                    if (!pattern2.test(data7)) {
                        const err31 = { instancePath: instancePath + "/source/shasum", schemaPath: "#/properties/source/properties/shasum/pattern", keyword: "pattern", params: { pattern: "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$" }, message: "must match pattern \"" + "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$" + "\"" };
                        if (vErrors === null) {
                            vErrors = [err31];
                        }
                        else {
                            vErrors.push(err31);
                        }
                        errors++;
                    }
                }
                else {
                    const err32 = { instancePath: instancePath + "/source/shasum", schemaPath: "#/properties/source/properties/shasum/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err32];
                    }
                    else {
                        vErrors.push(err32);
                    }
                    errors++;
                }
            }
            if (data6.location !== undefined) {
                let data8 = data6.location;
                if (data8 && typeof data8 == "object" && !Array.isArray(data8)) {
                    if (data8.npm === undefined) {
                        const err33 = { instancePath: instancePath + "/source/location", schemaPath: "#/properties/source/properties/location/required", keyword: "required", params: { missingProperty: "npm" }, message: "must have required property '" + "npm" + "'" };
                        if (vErrors === null) {
                            vErrors = [err33];
                        }
                        else {
                            vErrors.push(err33);
                        }
                        errors++;
                    }
                    for (const key3 in data8) {
                        if (!(key3 === "npm")) {
                            const err34 = { instancePath: instancePath + "/source/location", schemaPath: "#/properties/source/properties/location/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key3 }, message: "must NOT have additional properties" };
                            if (vErrors === null) {
                                vErrors = [err34];
                            }
                            else {
                                vErrors.push(err34);
                            }
                            errors++;
                        }
                    }
                    if (data8.npm !== undefined) {
                        let data9 = data8.npm;
                        if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                            if (data9.filePath === undefined) {
                                const err35 = { instancePath: instancePath + "/source/location/npm", schemaPath: "#/properties/source/properties/location/properties/npm/required", keyword: "required", params: { missingProperty: "filePath" }, message: "must have required property '" + "filePath" + "'" };
                                if (vErrors === null) {
                                    vErrors = [err35];
                                }
                                else {
                                    vErrors.push(err35);
                                }
                                errors++;
                            }
                            if (data9.packageName === undefined) {
                                const err36 = { instancePath: instancePath + "/source/location/npm", schemaPath: "#/properties/source/properties/location/properties/npm/required", keyword: "required", params: { missingProperty: "packageName" }, message: "must have required property '" + "packageName" + "'" };
                                if (vErrors === null) {
                                    vErrors = [err36];
                                }
                                else {
                                    vErrors.push(err36);
                                }
                                errors++;
                            }
                            if (data9.registry === undefined) {
                                const err37 = { instancePath: instancePath + "/source/location/npm", schemaPath: "#/properties/source/properties/location/properties/npm/required", keyword: "required", params: { missingProperty: "registry" }, message: "must have required property '" + "registry" + "'" };
                                if (vErrors === null) {
                                    vErrors = [err37];
                                }
                                else {
                                    vErrors.push(err37);
                                }
                                errors++;
                            }
                            for (const key4 in data9) {
                                if (!((((key4 === "filePath") || (key4 === "iconPath")) || (key4 === "packageName")) || (key4 === "registry"))) {
                                    const err38 = { instancePath: instancePath + "/source/location/npm", schemaPath: "#/properties/source/properties/location/properties/npm/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key4 }, message: "must NOT have additional properties" };
                                    if (vErrors === null) {
                                        vErrors = [err38];
                                    }
                                    else {
                                        vErrors.push(err38);
                                    }
                                    errors++;
                                }
                            }
                            if (data9.filePath !== undefined) {
                                let data10 = data9.filePath;
                                if (typeof data10 === "string") {
                                    if (func8(data10) < 1) {
                                        const err39 = { instancePath: instancePath + "/source/location/npm/filePath", schemaPath: "#/properties/source/properties/location/properties/npm/properties/filePath/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                                        if (vErrors === null) {
                                            vErrors = [err39];
                                        }
                                        else {
                                            vErrors.push(err39);
                                        }
                                        errors++;
                                    }
                                }
                                else {
                                    const err40 = { instancePath: instancePath + "/source/location/npm/filePath", schemaPath: "#/properties/source/properties/location/properties/npm/properties/filePath/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    if (vErrors === null) {
                                        vErrors = [err40];
                                    }
                                    else {
                                        vErrors.push(err40);
                                    }
                                    errors++;
                                }
                            }
                            if (data9.iconPath !== undefined) {
                                let data11 = data9.iconPath;
                                if (typeof data11 === "string") {
                                    if (!pattern3.test(data11)) {
                                        const err41 = { instancePath: instancePath + "/source/location/npm/iconPath", schemaPath: "#/properties/source/properties/location/properties/npm/properties/iconPath/pattern", keyword: "pattern", params: { pattern: "\\w+\\.svg$" }, message: "must match pattern \"" + "\\w+\\.svg$" + "\"" };
                                        if (vErrors === null) {
                                            vErrors = [err41];
                                        }
                                        else {
                                            vErrors.push(err41);
                                        }
                                        errors++;
                                    }
                                }
                                else {
                                    const err42 = { instancePath: instancePath + "/source/location/npm/iconPath", schemaPath: "#/properties/source/properties/location/properties/npm/properties/iconPath/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    if (vErrors === null) {
                                        vErrors = [err42];
                                    }
                                    else {
                                        vErrors.push(err42);
                                    }
                                    errors++;
                                }
                            }
                            if (data9.packageName !== undefined) {
                                let data12 = data9.packageName;
                                if (typeof data12 === "string") {
                                    if (func8(data12) < 1) {
                                        const err43 = { instancePath: instancePath + "/source/location/npm/packageName", schemaPath: "#/properties/source/properties/location/properties/npm/properties/packageName/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                                        if (vErrors === null) {
                                            vErrors = [err43];
                                        }
                                        else {
                                            vErrors.push(err43);
                                        }
                                        errors++;
                                    }
                                }
                                else {
                                    const err44 = { instancePath: instancePath + "/source/location/npm/packageName", schemaPath: "#/properties/source/properties/location/properties/npm/properties/packageName/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    if (vErrors === null) {
                                        vErrors = [err44];
                                    }
                                    else {
                                        vErrors.push(err44);
                                    }
                                    errors++;
                                }
                            }
                            if (data9.registry !== undefined) {
                                let data13 = data9.registry;
                                if (typeof data13 !== "string") {
                                    const err45 = { instancePath: instancePath + "/source/location/npm/registry", schemaPath: "#/properties/source/properties/location/properties/npm/properties/registry/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                    if (vErrors === null) {
                                        vErrors = [err45];
                                    }
                                    else {
                                        vErrors.push(err45);
                                    }
                                    errors++;
                                }
                                if (!((data13 === "https://registry.npmjs.org") || (data13 === "https://registry.npmjs.org/"))) {
                                    const err46 = { instancePath: instancePath + "/source/location/npm/registry", schemaPath: "#/properties/source/properties/location/properties/npm/properties/registry/enum", keyword: "enum", params: { allowedValues: schema22.properties.source.properties.location.properties.npm.properties.registry.enum }, message: "must be equal to one of the allowed values" };
                                    if (vErrors === null) {
                                        vErrors = [err46];
                                    }
                                    else {
                                        vErrors.push(err46);
                                    }
                                    errors++;
                                }
                            }
                        }
                        else {
                            const err47 = { instancePath: instancePath + "/source/location/npm", schemaPath: "#/properties/source/properties/location/properties/npm/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                            if (vErrors === null) {
                                vErrors = [err47];
                            }
                            else {
                                vErrors.push(err47);
                            }
                            errors++;
                        }
                    }
                }
                else {
                    const err48 = { instancePath: instancePath + "/source/location", schemaPath: "#/properties/source/properties/location/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                    if (vErrors === null) {
                        vErrors = [err48];
                    }
                    else {
                        vErrors.push(err48);
                    }
                    errors++;
                }
            }
        }
        else {
            const err49 = { instancePath: instancePath + "/source", schemaPath: "#/properties/source/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
                vErrors = [err49];
            }
            else {
                vErrors.push(err49);
            }
            errors++;
        }
    }
    if (data.initialPermissions !== undefined) {
        let data14 = data.initialPermissions;
        if (!(data14 && typeof data14 == "object" && !Array.isArray(data14))) {
            const err50 = { instancePath: instancePath + "/initialPermissions", schemaPath: "#/properties/initialPermissions/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
                vErrors = [err50];
            }
            else {
                vErrors.push(err50);
            }
            errors++;
        }
    }
    if (data.manifestVersion !== undefined) {
        let data15 = data.manifestVersion;
        if (typeof data15 !== "string") {
            const err51 = { instancePath: instancePath + "/manifestVersion", schemaPath: "#/properties/manifestVersion/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err51];
            }
            else {
                vErrors.push(err51);
            }
            errors++;
        }
        if (!(data15 === "0.1")) {
            const err52 = { instancePath: instancePath + "/manifestVersion", schemaPath: "#/properties/manifestVersion/enum", keyword: "enum", params: { allowedValues: schema22.properties.manifestVersion.enum }, message: "must be equal to one of the allowed values" };
            if (vErrors === null) {
                vErrors = [err52];
            }
            else {
                vErrors.push(err52);
            }
            errors++;
        }
    }
}
else {
    const err53 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
    if (vErrors === null) {
        vErrors = [err53];
    }
    else {
        vErrors.push(err53);
    }
    errors++;
} validate20.errors = vErrors; return vErrors; }
//# sourceMappingURL=validateSnapManifest.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateSnapManifest.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL2xpYi9lbnMtaXBmcy9jb250cmFjdHMvcmVzb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnN0YW50cy9jb250cmFjdHMuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL2Rpc3QvY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL2pzb24tcnBjLWVuZ2luZS9kaXN0L2NyZWF0ZUFzeW5jTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9nZXRVbmlxdWVJZC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9pZFJlbWFwTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1lbmdpbmUvZGlzdC9tZXJnZU1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL2Rpc3QvSnNvblJwY0VuZ2luZS5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL2Vucy9lbnMuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9lbnVtcy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL3NlbGVjdG9ycy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL2NhdmVhdC1tdXRhdG9ycy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL3Blcm1pc3Npb24tbG9nLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvcGVybWlzc2lvbnMvYmFja2dyb3VuZC1hcGkuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9zcGVjaWZpY2F0aW9ucy5qcyIsImFwcC9zY3JpcHRzL2xpYi9jbGVhbkVycm9yU3RhY2suanMiLCJub2RlX21vZHVsZXMvbm9uY2UtdHJhY2tlci9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9saWIvdXRpbC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy90eC1zdGF0ZS1tYW5hZ2VyLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL3R4LWdhcy11dGlscy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy9wZW5kaW5nLXR4LXRyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvdGhpcmRwYXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9pbmRleC5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL25ldHdvcmsvbmV0d29yay5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvaGRrZXkvbGliL2hka2V5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckFzTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi1yZXdyaXRlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmZsaWdodC1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcHJvdmlkZXJGcm9tTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3JldHJ5T25FbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyRnJvbUVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3Qvd2FsbGV0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9kaXN0L1NtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtbGF0dGljZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC10cmV6b3Ita2V5cmluZy9ub2RlX21vZHVsZXMvaGRrZXkvbGliL2hka2V5LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvcGx1Z2lucy9ldGhlcmV1bS90eXBlZERhdGEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9yZXNvdXJjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3N1YmplY3QtbWV0YWRhdGEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NuYXBzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc2VydmljZXMvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2NyZWF0ZU1ldGhvZE1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJkZXZlbG9wbWVudC9tb2NrLTNib3guanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9uZXR3b3JrL2NyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi8zYm94LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvc3JjL3Byb2ZpbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3JlbW92ZS10cmFpbGluZy1zbGFzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNzdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJub2RlX21vZHVsZXMvbWQ1L21kNS5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VnbWVudC9sb29zZWx5LXZhbGlkYXRlLWV2ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zLXJldHJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zY3J5cHRzeS9saWIvc2NyeXB0LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9jcmVhdGVKc29uUnBjQ2xpZW50LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9jcmVhdGVJbmZ1cmFDbGllbnQuanMiLCJub2RlX21vZHVsZXMvY29pbnN0cmluZy9saWIvY29pbnN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvdXRpbHMvY2FjaGUuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvZGlzdC9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9kaXN0L2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZW52L2Jyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcmVzb3VyY2UvRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9zdWJqZWN0LW1ldGFkYXRhL1N1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL1Blcm1pc3Npb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9lbmRvd21lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvUGVybWlzc2lvbkNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9DYXZlYXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9ycGMtbWV0aG9kcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NuYXBzL1NuYXBDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvanNvbi1zY2hlbWFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9zZXJ2aWNlcy9FeGVjdXRpb25TZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc2VydmljZXMvQWJzdHJhY3RFeGVjdXRpb25TZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc2VydmljZXMvV2ViV29ya2VyRXhlY3V0aW9uU2VydmljZS5qcyIsImFwcC9zY3JpcHRzL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUvaGFuZGxlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9taWRkbGV3YXJlL3BlbmRpbmcuanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvcHJpdmF0ZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL2Rpc3Qvc3RvcmUubGVnYWN5LmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi9zcGFjZS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1wdWJzdWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliLzNpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi92ZXJpZmllZC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi91dGlscy9pZC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvcHVibGljU3RvcmUuanMiLCJub2RlX21vZHVsZXMvM2JveC1vcmJpdGRiLXBsdWdpbnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiL3NyYy9PcmJpdERCLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViLWVuY29kaW5nL3NyYy9saWIuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLWJhc2U2NC9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3ZhcmludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2ludC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL2FuYWx5dGljcy1ub2RlL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanMiLCJub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LXR5cGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvam9pbi1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MtcmV0cnkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2FjY291bnQuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2hhc2guanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azF2My1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3dhcHBhYmxlLW9iai1wcm94eS9zcmMvY3JlYXRlU3dhcHBhYmxlUHJveHkuanMiLCJub2RlX21vZHVsZXMvc3dhcHBhYmxlLW9iai1wcm94eS9zcmMvY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2luc3RyaW5nL25vZGVfbW9kdWxlcy9iczU4L2xpYi9iczU4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMva2VjY2FrL2pzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9ldGhlcmV1bUFiaS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL2Rpc3QvZ2VuZXJpY1NpZ25pbmcuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9ldGhlcmV1bS5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvZGlzdC9iaXRjb2luLmpzIiwibm9kZV9tb2R1bGVzL2V0aC10cmV6b3Ita2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9lbGxpcHRpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL21pc2MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2FjY291bnQuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL3BhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvYmluYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvdHJlem9yL21hbmFnZW1lbnQuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2JpdGNvaW4uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2Vvcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvcmlwcGxlLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9jb2luSW5mby5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvZXRoZXJldW0uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2JhY2tlbmQvdHJhbnNhY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9zdGVsbGFyLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9uZW0uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL3Rlem9zLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9jYXJkYW5vLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvdHJlem9yL2RldmljZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvYmFja2VuZC9ibG9ja2NoYWluLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvbmV0d29yay5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL2RldmljZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL2lmcmFtZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3VpLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvYmxvY2tjaGFpbi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvY2FyZGFuby5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvd2VidXNiL2J1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdXRpbHMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL21lc3NhZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3BvcHVwL1BvcHVwTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZGF0YS9Db25uZWN0U2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL21lc3NhZ2UvYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvaWZyYW1lL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3NpZ24tdHlwZWQtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmJyb3dzZXIuY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvZW5kb3dtZW50cy9uZXR3b3JrLWFjY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZnJlZXplLXN0cmljdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3Blcm1pc3Npb24tbWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3JwYy1tZXRob2RzL2dldFBlcm1pc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvcnBjLW1ldGhvZHMvcmVxdWVzdFBlcm1pc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvanNvbi1zY2hlbWFzL3ZhbGlkYXRlU25hcE1hbmlmZXN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNLEdBQUcsR0FBRyxDQUNWO0FBQ0UsRUFBQSxRQUFRLEVBQUUsS0FEWjtBQUVFLEVBQUEsTUFBTSxFQUFFLENBQ047QUFBRSxJQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLElBQUEsSUFBSSxFQUFFO0FBQXRCLEdBRE0sRUFFTjtBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FGTSxDQUZWO0FBTUUsRUFBQSxJQUFJLEVBQUUsWUFOUjtBQU9FLEVBQUEsT0FBTyxFQUFFLEVBUFg7QUFRRSxFQUFBLE9BQU8sRUFBRSxLQVJYO0FBU0UsRUFBQSxlQUFlLEVBQUUsWUFUbkI7QUFVRSxFQUFBLElBQUksRUFBRTtBQVZSLENBRFUsRUFhVjtBQUNFLEVBQUEsUUFBUSxFQUFFLElBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUFDO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQUFELENBRlY7QUFHRSxFQUFBLElBQUksRUFBRSxTQUhSO0FBSUUsRUFBQSxPQUFPLEVBQUUsQ0FBQztBQUFFLElBQUEsSUFBSSxFQUFFLEVBQVI7QUFBWSxJQUFBLElBQUksRUFBRTtBQUFsQixHQUFELENBSlg7QUFLRSxFQUFBLE9BQU8sRUFBRSxLQUxYO0FBTUUsRUFBQSxlQUFlLEVBQUUsTUFObkI7QUFPRSxFQUFBLElBQUksRUFBRTtBQVBSLENBYlUsRUFzQlY7QUFDRSxFQUFBLFFBQVEsRUFBRSxJQURaO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FBQztBQUFFLElBQUEsSUFBSSxFQUFFLGFBQVI7QUFBdUIsSUFBQSxJQUFJLEVBQUU7QUFBN0IsR0FBRCxDQUZWO0FBR0UsRUFBQSxJQUFJLEVBQUUsbUJBSFI7QUFJRSxFQUFBLE9BQU8sRUFBRSxDQUFDO0FBQUUsSUFBQSxJQUFJLEVBQUUsRUFBUjtBQUFZLElBQUEsSUFBSSxFQUFFO0FBQWxCLEdBQUQsQ0FKWDtBQUtFLEVBQUEsT0FBTyxFQUFFLEtBTFg7QUFNRSxFQUFBLGVBQWUsRUFBRSxNQU5uQjtBQU9FLEVBQUEsSUFBSSxFQUFFO0FBUFIsQ0F0QlUsRUErQlY7QUFDRSxFQUFBLFFBQVEsRUFBRSxLQURaO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FDTjtBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FETSxFQUVOO0FBQUUsSUFBQSxJQUFJLEVBQUUsS0FBUjtBQUFlLElBQUEsSUFBSSxFQUFFO0FBQXJCLEdBRk0sRUFHTjtBQUFFLElBQUEsSUFBSSxFQUFFLE9BQVI7QUFBaUIsSUFBQSxJQUFJLEVBQUU7QUFBdkIsR0FITSxDQUZWO0FBT0UsRUFBQSxJQUFJLEVBQUUsU0FQUjtBQVFFLEVBQUEsT0FBTyxFQUFFLEVBUlg7QUFTRSxFQUFBLE9BQU8sRUFBRSxLQVRYO0FBVUUsRUFBQSxlQUFlLEVBQUUsWUFWbkI7QUFXRSxFQUFBLElBQUksRUFBRTtBQVhSLENBL0JVLEVBNENWO0FBQ0UsRUFBQSxRQUFRLEVBQUUsSUFEWjtBQUVFLEVBQUEsTUFBTSxFQUFFLENBQ047QUFBRSxJQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLElBQUEsSUFBSSxFQUFFO0FBQXRCLEdBRE0sRUFFTjtBQUFFLElBQUEsSUFBSSxFQUFFLGNBQVI7QUFBd0IsSUFBQSxJQUFJLEVBQUU7QUFBOUIsR0FGTSxDQUZWO0FBTUUsRUFBQSxJQUFJLEVBQUUsS0FOUjtBQU9FLEVBQUEsT0FBTyxFQUFFLENBQ1A7QUFBRSxJQUFBLElBQUksRUFBRSxhQUFSO0FBQXVCLElBQUEsSUFBSSxFQUFFO0FBQTdCLEdBRE8sRUFFUDtBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FGTyxDQVBYO0FBV0UsRUFBQSxPQUFPLEVBQUUsS0FYWDtBQVlFLEVBQUEsZUFBZSxFQUFFLE1BWm5CO0FBYUUsRUFBQSxJQUFJLEVBQUU7QUFiUixDQTVDVSxFQTJEVjtBQUNFLEVBQUEsUUFBUSxFQUFFLEtBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQURNLEVBRU47QUFBRSxJQUFBLElBQUksRUFBRSxHQUFSO0FBQWEsSUFBQSxJQUFJLEVBQUU7QUFBbkIsR0FGTSxFQUdOO0FBQUUsSUFBQSxJQUFJLEVBQUUsR0FBUjtBQUFhLElBQUEsSUFBSSxFQUFFO0FBQW5CLEdBSE0sQ0FGVjtBQU9FLEVBQUEsSUFBSSxFQUFFLFdBUFI7QUFRRSxFQUFBLE9BQU8sRUFBRSxFQVJYO0FBU0UsRUFBQSxPQUFPLEVBQUUsS0FUWDtBQVVFLEVBQUEsZUFBZSxFQUFFLFlBVm5CO0FBV0UsRUFBQSxJQUFJLEVBQUU7QUFYUixDQTNEVSxFQXdFVjtBQUNFLEVBQUEsUUFBUSxFQUFFLEtBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQURNLEVBRU47QUFBRSxJQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLElBQUEsSUFBSSxFQUFFO0FBQXRCLEdBRk0sQ0FGVjtBQU1FLEVBQUEsSUFBSSxFQUFFLGdCQU5SO0FBT0UsRUFBQSxPQUFPLEVBQUUsRUFQWDtBQVFFLEVBQUEsT0FBTyxFQUFFLEtBUlg7QUFTRSxFQUFBLGVBQWUsRUFBRSxZQVRuQjtBQVVFLEVBQUEsSUFBSSxFQUFFO0FBVlIsQ0F4RVUsRUFvRlY7QUFDRSxFQUFBLFFBQVEsRUFBRSxJQURaO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FBQztBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FBRCxDQUZWO0FBR0UsRUFBQSxJQUFJLEVBQUUsTUFIUjtBQUlFLEVBQUEsT0FBTyxFQUFFLENBQUM7QUFBRSxJQUFBLElBQUksRUFBRSxFQUFSO0FBQVksSUFBQSxJQUFJLEVBQUU7QUFBbEIsR0FBRCxDQUpYO0FBS0UsRUFBQSxPQUFPLEVBQUUsS0FMWDtBQU1FLEVBQUEsZUFBZSxFQUFFLE1BTm5CO0FBT0UsRUFBQSxJQUFJLEVBQUU7QUFQUixDQXBGVSxFQTZGVjtBQUNFLEVBQUEsUUFBUSxFQUFFLElBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQURNLEVBRU47QUFBRSxJQUFBLElBQUksRUFBRSxLQUFSO0FBQWUsSUFBQSxJQUFJLEVBQUU7QUFBckIsR0FGTSxDQUZWO0FBTUUsRUFBQSxJQUFJLEVBQUUsTUFOUjtBQU9FLEVBQUEsT0FBTyxFQUFFLENBQUM7QUFBRSxJQUFBLElBQUksRUFBRSxFQUFSO0FBQVksSUFBQSxJQUFJLEVBQUU7QUFBbEIsR0FBRCxDQVBYO0FBUUUsRUFBQSxPQUFPLEVBQUUsS0FSWDtBQVNFLEVBQUEsZUFBZSxFQUFFLE1BVG5CO0FBVUUsRUFBQSxJQUFJLEVBQUU7QUFWUixDQTdGVSxFQXlHVjtBQUNFLEVBQUEsUUFBUSxFQUFFLEtBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQURNLEVBRU47QUFBRSxJQUFBLElBQUksRUFBRSxhQUFSO0FBQXVCLElBQUEsSUFBSSxFQUFFO0FBQTdCLEdBRk0sRUFHTjtBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FITSxDQUZWO0FBT0UsRUFBQSxJQUFJLEVBQUUsUUFQUjtBQVFFLEVBQUEsT0FBTyxFQUFFLEVBUlg7QUFTRSxFQUFBLE9BQU8sRUFBRSxLQVRYO0FBVUUsRUFBQSxlQUFlLEVBQUUsWUFWbkI7QUFXRSxFQUFBLElBQUksRUFBRTtBQVhSLENBekdVLEVBc0hWO0FBQ0UsRUFBQSxRQUFRLEVBQUUsSUFEWjtBQUVFLEVBQUEsTUFBTSxFQUFFLENBQUM7QUFBRSxJQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLElBQUEsSUFBSSxFQUFFO0FBQXRCLEdBQUQsQ0FGVjtBQUdFLEVBQUEsSUFBSSxFQUFFLE1BSFI7QUFJRSxFQUFBLE9BQU8sRUFBRSxDQUFDO0FBQUUsSUFBQSxJQUFJLEVBQUUsRUFBUjtBQUFZLElBQUEsSUFBSSxFQUFFO0FBQWxCLEdBQUQsQ0FKWDtBQUtFLEVBQUEsT0FBTyxFQUFFLEtBTFg7QUFNRSxFQUFBLGVBQWUsRUFBRSxNQU5uQjtBQU9FLEVBQUEsSUFBSSxFQUFFO0FBUFIsQ0F0SFUsRUErSFY7QUFDRSxFQUFBLFFBQVEsRUFBRSxLQURaO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FDTjtBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FETSxFQUVOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQUZNLENBRlY7QUFNRSxFQUFBLElBQUksRUFBRSxTQU5SO0FBT0UsRUFBQSxPQUFPLEVBQUUsRUFQWDtBQVFFLEVBQUEsT0FBTyxFQUFFLEtBUlg7QUFTRSxFQUFBLGVBQWUsRUFBRSxZQVRuQjtBQVVFLEVBQUEsSUFBSSxFQUFFO0FBVlIsQ0EvSFUsRUEySVY7QUFDRSxFQUFBLFFBQVEsRUFBRSxJQURaO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FBQztBQUFFLElBQUEsSUFBSSxFQUFFLE1BQVI7QUFBZ0IsSUFBQSxJQUFJLEVBQUU7QUFBdEIsR0FBRCxDQUZWO0FBR0UsRUFBQSxJQUFJLEVBQUUsYUFIUjtBQUlFLEVBQUEsT0FBTyxFQUFFLENBQUM7QUFBRSxJQUFBLElBQUksRUFBRSxFQUFSO0FBQVksSUFBQSxJQUFJLEVBQUU7QUFBbEIsR0FBRCxDQUpYO0FBS0UsRUFBQSxPQUFPLEVBQUUsS0FMWDtBQU1FLEVBQUEsZUFBZSxFQUFFLE1BTm5CO0FBT0UsRUFBQSxJQUFJLEVBQUU7QUFQUixDQTNJVSxFQW9KVjtBQUNFLEVBQUEsUUFBUSxFQUFFLElBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUFDO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQUFELENBRlY7QUFHRSxFQUFBLElBQUksRUFBRSxRQUhSO0FBSUUsRUFBQSxPQUFPLEVBQUUsQ0FDUDtBQUFFLElBQUEsSUFBSSxFQUFFLEdBQVI7QUFBYSxJQUFBLElBQUksRUFBRTtBQUFuQixHQURPLEVBRVA7QUFBRSxJQUFBLElBQUksRUFBRSxHQUFSO0FBQWEsSUFBQSxJQUFJLEVBQUU7QUFBbkIsR0FGTyxDQUpYO0FBUUUsRUFBQSxPQUFPLEVBQUUsS0FSWDtBQVNFLEVBQUEsZUFBZSxFQUFFLE1BVG5CO0FBVUUsRUFBQSxJQUFJLEVBQUU7QUFWUixDQXBKVSxFQWdLVjtBQUNFLEVBQUEsUUFBUSxFQUFFLEtBRFo7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixJQUFBLElBQUksRUFBRTtBQUF0QixHQURNLEVBRU47QUFBRSxJQUFBLElBQUksRUFBRSxNQUFSO0FBQWdCLElBQUEsSUFBSSxFQUFFO0FBQXRCLEdBRk0sQ0FGVjtBQU1FLEVBQUEsSUFBSSxFQUFFLFNBTlI7QUFPRSxFQUFBLE9BQU8sRUFBRSxFQVBYO0FBUUUsRUFBQSxPQUFPLEVBQUUsS0FSWDtBQVNFLEVBQUEsZUFBZSxFQUFFLFlBVG5CO0FBVUUsRUFBQSxJQUFJLEVBQUU7QUFWUixDQWhLVSxFQTRLVjtBQUNFLEVBQUEsTUFBTSxFQUFFLENBQUM7QUFBRSxJQUFBLElBQUksRUFBRSxTQUFSO0FBQW1CLElBQUEsSUFBSSxFQUFFO0FBQXpCLEdBQUQsQ0FEVjtBQUVFLEVBQUEsT0FBTyxFQUFFLEtBRlg7QUFHRSxFQUFBLGVBQWUsRUFBRSxZQUhuQjtBQUlFLEVBQUEsSUFBSSxFQUFFO0FBSlIsQ0E1S1UsRUFrTFY7QUFDRSxFQUFBLFNBQVMsRUFBRSxLQURiO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FDTjtBQUFFLElBQUEsT0FBTyxFQUFFLElBQVg7QUFBaUIsSUFBQSxJQUFJLEVBQUUsTUFBdkI7QUFBK0IsSUFBQSxJQUFJLEVBQUU7QUFBckMsR0FETSxFQUVOO0FBQUUsSUFBQSxPQUFPLEVBQUUsS0FBWDtBQUFrQixJQUFBLElBQUksRUFBRSxHQUF4QjtBQUE2QixJQUFBLElBQUksRUFBRTtBQUFuQyxHQUZNLENBRlY7QUFNRSxFQUFBLElBQUksRUFBRSxhQU5SO0FBT0UsRUFBQSxJQUFJLEVBQUU7QUFQUixDQWxMVSxFQTJMVjtBQUNFLEVBQUEsU0FBUyxFQUFFLEtBRGI7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxPQUFPLEVBQUUsSUFBWDtBQUFpQixJQUFBLElBQUksRUFBRSxNQUF2QjtBQUErQixJQUFBLElBQUksRUFBRTtBQUFyQyxHQURNLEVBRU47QUFBRSxJQUFBLE9BQU8sRUFBRSxLQUFYO0FBQWtCLElBQUEsSUFBSSxFQUFFLE1BQXhCO0FBQWdDLElBQUEsSUFBSSxFQUFFO0FBQXRDLEdBRk0sQ0FGVjtBQU1FLEVBQUEsSUFBSSxFQUFFLGFBTlI7QUFPRSxFQUFBLElBQUksRUFBRTtBQVBSLENBM0xVLEVBb01WO0FBQ0UsRUFBQSxTQUFTLEVBQUUsS0FEYjtBQUVFLEVBQUEsTUFBTSxFQUFFLENBQ047QUFBRSxJQUFBLE9BQU8sRUFBRSxJQUFYO0FBQWlCLElBQUEsSUFBSSxFQUFFLE1BQXZCO0FBQStCLElBQUEsSUFBSSxFQUFFO0FBQXJDLEdBRE0sRUFFTjtBQUFFLElBQUEsT0FBTyxFQUFFLElBQVg7QUFBaUIsSUFBQSxJQUFJLEVBQUUsYUFBdkI7QUFBc0MsSUFBQSxJQUFJLEVBQUU7QUFBNUMsR0FGTSxDQUZWO0FBTUUsRUFBQSxJQUFJLEVBQUUsWUFOUjtBQU9FLEVBQUEsSUFBSSxFQUFFO0FBUFIsQ0FwTVUsRUE2TVY7QUFDRSxFQUFBLFNBQVMsRUFBRSxLQURiO0FBRUUsRUFBQSxNQUFNLEVBQUUsQ0FDTjtBQUFFLElBQUEsT0FBTyxFQUFFLElBQVg7QUFBaUIsSUFBQSxJQUFJLEVBQUUsTUFBdkI7QUFBK0IsSUFBQSxJQUFJLEVBQUU7QUFBckMsR0FETSxFQUVOO0FBQUUsSUFBQSxPQUFPLEVBQUUsS0FBWDtBQUFrQixJQUFBLElBQUksRUFBRSxHQUF4QjtBQUE2QixJQUFBLElBQUksRUFBRTtBQUFuQyxHQUZNLEVBR047QUFBRSxJQUFBLE9BQU8sRUFBRSxLQUFYO0FBQWtCLElBQUEsSUFBSSxFQUFFLEdBQXhCO0FBQTZCLElBQUEsSUFBSSxFQUFFO0FBQW5DLEdBSE0sQ0FGVjtBQU9FLEVBQUEsSUFBSSxFQUFFLGVBUFI7QUFRRSxFQUFBLElBQUksRUFBRTtBQVJSLENBN01VLEVBdU5WO0FBQ0UsRUFBQSxTQUFTLEVBQUUsS0FEYjtBQUVFLEVBQUEsTUFBTSxFQUFFLENBQ047QUFBRSxJQUFBLE9BQU8sRUFBRSxJQUFYO0FBQWlCLElBQUEsSUFBSSxFQUFFLE1BQXZCO0FBQStCLElBQUEsSUFBSSxFQUFFO0FBQXJDLEdBRE0sRUFFTjtBQUFFLElBQUEsT0FBTyxFQUFFLEtBQVg7QUFBa0IsSUFBQSxJQUFJLEVBQUUsWUFBeEI7QUFBc0MsSUFBQSxJQUFJLEVBQUU7QUFBNUMsR0FGTSxFQUdOO0FBQUUsSUFBQSxPQUFPLEVBQUUsS0FBWDtBQUFrQixJQUFBLElBQUksRUFBRSxLQUF4QjtBQUErQixJQUFBLElBQUksRUFBRTtBQUFyQyxHQUhNLENBRlY7QUFPRSxFQUFBLElBQUksRUFBRSxhQVBSO0FBUUUsRUFBQSxJQUFJLEVBQUU7QUFSUixDQXZOVSxFQWlPVjtBQUNFLEVBQUEsU0FBUyxFQUFFLEtBRGI7QUFFRSxFQUFBLE1BQU0sRUFBRSxDQUNOO0FBQUUsSUFBQSxPQUFPLEVBQUUsSUFBWDtBQUFpQixJQUFBLElBQUksRUFBRSxNQUF2QjtBQUErQixJQUFBLElBQUksRUFBRTtBQUFyQyxHQURNLEVBRU47QUFBRSxJQUFBLE9BQU8sRUFBRSxLQUFYO0FBQWtCLElBQUEsSUFBSSxFQUFFLE1BQXhCO0FBQWdDLElBQUEsSUFBSSxFQUFFO0FBQXRDLEdBRk0sQ0FGVjtBQU1FLEVBQUEsSUFBSSxFQUFFLG9CQU5SO0FBT0UsRUFBQSxJQUFJLEVBQUU7QUFQUixDQWpPVSxDQUFaO2VBMk9lLEc7Ozs7Ozs7Ozs7Ozs7QUMzT2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9GTyxNQUFNLDRCQUE0QixHQUN2Qyw0Q0FESzs7QUFFQSxNQUFNLG9DQUFvQyxHQUMvQyw0Q0FESzs7QUFFQSxNQUFNLG9DQUFvQyxHQUMvQyw0Q0FESzs7QUFFQSxNQUFNLGtDQUFrQyxHQUM3Qyw0Q0FESzs7Ozs7Ozs7Ozs7OztBQ05QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6UEE7O0FBQ0E7O0FBRWUsTUFBTSxHQUFOLENBQVU7QUFDSSxTQUFwQixvQkFBb0IsQ0FBQyxPQUFELEVBQVU7QUFDbkMsV0FBTyxPQUFPLENBQUMsK0JBQWMsT0FBZCxDQUFELENBQWQ7QUFDRDs7QUFFRCxFQUFBLFdBQVcsQ0FBQztBQUFFLElBQUEsT0FBRjtBQUFXLElBQUE7QUFBWCxNQUF3QixFQUF6QixFQUE2QjtBQUN0QyxTQUFLLFNBQUwsR0FBaUIsSUFBSSxpQkFBSixDQUFhO0FBQzVCLE1BQUEsT0FENEI7QUFFNUIsTUFBQTtBQUY0QixLQUFiLENBQWpCO0FBSUQ7O0FBRUQsRUFBQSxNQUFNLENBQUMsT0FBRCxFQUFVO0FBQ2QsV0FBTyxLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLE9BQXRCLENBQVA7QUFDRDs7QUFFRCxFQUFBLE9BQU8sQ0FBQyxPQUFELEVBQVU7QUFDZixXQUFPLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsT0FBdkIsQ0FBUDtBQUNEOztBQWxCc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSGxCLE1BQU0sYUFBYSxHQUFHLFNBQXRCOztBQUVBLE1BQU0sa0JBQWtCLEdBQUc7QUFDaEMsRUFBQSxlQUFlLEVBQUUsMEJBRGU7QUFFaEMsRUFBQSxrQkFBa0IsRUFBRSw2QkFGWTtBQUdoQyxFQUFBLFlBQVksRUFBRTtBQUhrQixDQUEzQjs7QUFNQSxNQUFNLGtCQUFrQixHQUFHLENBQ2hDLDJCQURnQyxFQUVoQyxtQkFGZ0MsQ0FBM0I7O0FBS0EsTUFBTSxnQkFBZ0IsR0FBRztBQUM5QixFQUFBLFVBQVUsRUFBRSxZQURrQjtBQUU5QixFQUFBLFFBQVEsRUFBRTtBQUZvQixDQUF6QjtBQUtQO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxTQUFTLEdBQUcsR0FBbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJQOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxHQUFJLEtBQUQsSUFBVyxLQUFLLENBQUMsUUFBckM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSw0QkFBNEIsR0FBRyw4QkFDMUMsV0FEMEMsRUFFekMsUUFBRCxJQUFjO0FBQ1osU0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjLFFBQWQsRUFBd0IsTUFBeEIsQ0FBK0IsQ0FBQyxtQkFBRCxFQUFzQixPQUF0QixLQUFrQztBQUFBOztBQUN0RSxVQUFNLE1BQU0sMkJBQUcsT0FBTyxDQUFDLFdBQVgsa0ZBQUcscUJBQXFCLFlBQXhCLDBEQUFHLHNCQUFtQyxPQUFuQyxDQUEyQyxJQUEzQyxDQUNiLENBQUM7QUFBRSxNQUFBO0FBQUYsS0FBRCxLQUFjLElBQUksS0FBSyx5QkFBWSx3QkFEdEIsQ0FBZjs7QUFJQSxRQUFJLE1BQUosRUFBWTtBQUNWLE1BQUEsbUJBQW1CLENBQUMsR0FBcEIsQ0FBd0IsT0FBTyxDQUFDLE1BQWhDLEVBQXdDLE1BQU0sQ0FBQyxLQUEvQztBQUNEOztBQUNELFdBQU8sbUJBQVA7QUFDRCxHQVRNLEVBU0osSUFBSSxHQUFKLEVBVEksQ0FBUDtBQVVELENBYnlDLENBQXJDO0FBZ0JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDTyxNQUFNLGtCQUFrQixHQUFHLENBQUMsY0FBRCxFQUFpQixtQkFBakIsS0FBeUM7QUFDekUsTUFBSSxtQkFBbUIsS0FBSyxTQUE1QixFQUF1QztBQUNyQyxXQUFPLGNBQVA7QUFDRDs7QUFFRCxRQUFNLGVBQWUsR0FBRyxJQUFJLEdBQUosRUFBeEI7O0FBQ0EsTUFBSSxjQUFjLEtBQUssbUJBQXZCLEVBQTRDO0FBQzFDLFdBQU8sZUFBUDtBQUNEOztBQUVELFFBQU0sVUFBVSxHQUFHLElBQUksR0FBSixDQUFRLENBQUMsR0FBRyxjQUFjLENBQUMsSUFBZixFQUFKLENBQVIsQ0FBbkI7O0FBRUEsT0FBSyxNQUFNLE1BQVgsSUFBcUIsbUJBQW1CLENBQUMsSUFBcEIsRUFBckIsRUFBaUQ7QUFBQTs7QUFDL0MsVUFBTSxXQUFXLDBCQUFHLGNBQWMsQ0FBQyxHQUFmLENBQW1CLE1BQW5CLENBQUgscUVBQWlDLEVBQWxELENBRCtDLENBRy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSSxtQkFBbUIsQ0FBQyxHQUFwQixDQUF3QixNQUF4QixNQUFvQyxXQUF4QyxFQUFxRDtBQUNuRCxNQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixNQUFwQixFQUE0QixXQUE1QjtBQUNEOztBQUVELElBQUEsVUFBVSxDQUFDLE1BQVgsQ0FBa0IsTUFBbEI7QUFDRCxHQXpCd0UsQ0EyQnpFO0FBQ0E7OztBQUNBLE9BQUssTUFBTSxNQUFYLElBQXFCLFVBQVUsQ0FBQyxJQUFYLEVBQXJCLEVBQXdDO0FBQ3RDLElBQUEsZUFBZSxDQUFDLEdBQWhCLENBQW9CLE1BQXBCLEVBQTRCLGNBQWMsQ0FBQyxHQUFmLENBQW1CLE1BQW5CLENBQTVCO0FBQ0Q7O0FBQ0QsU0FBTyxlQUFQO0FBQ0QsQ0FqQ007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEUDs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sc0JBQXNCLEdBQUc7QUFDcEMsR0FBQyx5QkFBWSx3QkFBYixHQUF3QztBQUN0QyxJQUFBO0FBRHNDO0FBREosQ0FBL0I7QUFNUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsU0FBUyxhQUFULENBQXVCLGFBQXZCLEVBQXNDLGdCQUF0QyxFQUF3RDtBQUN0RCxRQUFNLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxNQUFqQixDQUNqQixPQUFELElBQWEsT0FBTyxLQUFLLGFBRFAsQ0FBcEI7O0FBSUEsTUFBSSxXQUFXLENBQUMsTUFBWixLQUF1QixnQkFBZ0IsQ0FBQyxNQUE1QyxFQUFvRDtBQUNsRCxXQUFPO0FBQUUsTUFBQSxTQUFTLEVBQUUsd0NBQXVCO0FBQXBDLEtBQVA7QUFDRCxHQUZELE1BRU8sSUFBSSxXQUFXLENBQUMsTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUNqQyxXQUFPO0FBQ0wsTUFBQSxTQUFTLEVBQUUsd0NBQXVCLFdBRDdCO0FBRUwsTUFBQSxLQUFLLEVBQUU7QUFGRixLQUFQO0FBSUQ7O0FBQ0QsU0FBTztBQUFFLElBQUEsU0FBUyxFQUFFLHdDQUF1QjtBQUFwQyxHQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENEOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sdUJBQU4sQ0FBOEI7QUFDbkM7QUFDRjtBQUNBO0FBQ0UsRUFBQSxXQUFXLENBQUM7QUFBRSxJQUFBLGlCQUFGO0FBQXFCLElBQUE7QUFBckIsR0FBRCxFQUFtQztBQUM1QyxTQUFLLGlCQUFMLEdBQXlCLGlCQUF6QjtBQUNBLFNBQUssS0FBTCxHQUFhLElBQUkseUJBQUo7QUFDWCxNQUFBLGlCQUFpQixFQUFFLEVBRFI7QUFFWCxNQUFBLHFCQUFxQixFQUFFO0FBRlosT0FHUixTQUhRLEVBQWI7QUFLRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsY0FBYyxHQUFHO0FBQ2YsV0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLHFCQUE3QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU87QUFDdEIsU0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QjtBQUFFLE1BQUEscUJBQXFCLEVBQUU7QUFBekIsS0FBdkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsVUFBVSxHQUFHO0FBQ1gsV0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLGlCQUE3QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxhQUFhLENBQUMsT0FBRCxFQUFVO0FBQ3JCLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFBRSxNQUFBLGlCQUFpQixFQUFFO0FBQXJCLEtBQXZCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEscUJBQXFCLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUI7QUFDdEMsUUFBSSxRQUFRLENBQUMsTUFBVCxLQUFvQixDQUF4QixFQUEyQjtBQUN6QjtBQUNEOztBQUVELFVBQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUMsUUFBRCxFQUFXLElBQUksQ0FBQyxHQUFMLEVBQVgsQ0FBNUM7QUFFQSxTQUFLLGdCQUFMLENBQXNCLE1BQXRCLEVBQThCO0FBQzVCLE1BQUEsWUFBWSxFQUFFO0FBQ1osUUFBQSxRQUFRLEVBQUU7QUFERTtBQURjLEtBQTlCO0FBS0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxnQkFBZ0IsR0FBRztBQUNqQixXQUFPLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxJQUFYLEVBQWlCLElBQWpCLEtBQTBCO0FBQy9CLFVBQUksYUFBSixFQUFtQixnQkFBbkI7QUFDQSxZQUFNO0FBQUUsUUFBQSxNQUFGO0FBQVUsUUFBQTtBQUFWLFVBQXFCLEdBQTNCO0FBQ0EsWUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVAsQ0FBa0Isb0JBQWxCLENBQW5CLENBSCtCLENBSy9COztBQUNBLFVBQ0UsQ0FBQywwQkFBbUIsUUFBbkIsQ0FBNEIsTUFBNUIsQ0FBRCxLQUNDLFVBQVUsSUFBSSxLQUFLLGlCQUFMLENBQXVCLEdBQXZCLENBQTJCLE1BQTNCLENBRGYsQ0FERixFQUdFO0FBQ0EsUUFBQSxhQUFhLEdBQUcsS0FBSyxVQUFMLENBQWdCLEdBQWhCLEVBQXFCLFVBQXJCLENBQWhCOztBQUVBLFlBQUksTUFBTSxLQUFNLEdBQUUsb0JBQWMsb0JBQWhDLEVBQXFEO0FBQ25EO0FBQ0E7QUFDQSxVQUFBLGdCQUFnQixHQUFHLEtBQUssbUJBQUwsQ0FBeUIsR0FBekIsQ0FBbkI7QUFDRDtBQUNGLE9BWEQsTUFXTyxJQUFJLE1BQU0sS0FBSyxxQkFBZixFQUFzQztBQUMzQztBQUNBO0FBQ0EsUUFBQSxhQUFhLEdBQUcsS0FBSyxVQUFMLENBQWdCLEdBQWhCLEVBQXFCLFVBQXJCLENBQWhCO0FBQ0EsUUFBQSxnQkFBZ0IsR0FBRyxDQUFDLGNBQUQsQ0FBbkI7QUFDRCxPQUxNLE1BS0E7QUFDTDtBQUNBLFFBQUEsSUFBSTtBQUNKO0FBQ0QsT0ExQjhCLENBNEIvQjs7O0FBQ0EsTUFBQSxJQUFJLENBQUUsRUFBRCxJQUFRO0FBQ1gsY0FBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUwsRUFBYjtBQUNBLGFBQUssV0FBTCxDQUFpQixhQUFqQixFQUFnQyxHQUFoQyxFQUFxQyxJQUFyQzs7QUFFQSxZQUFJLGdCQUFnQixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQXpCLElBQWtDLEdBQUcsQ0FBQyxNQUExQyxFQUFrRDtBQUNoRDtBQUNBO0FBQ0EsZUFBSyxxQkFBTCxDQUNFLGdCQURGLEVBRUUsTUFGRixFQUdFLEdBQUcsQ0FBQyxNQUhOLEVBSUUsSUFKRixFQUtFLE1BQU0sS0FBSyxxQkFMYjtBQU9EOztBQUNELFFBQUEsRUFBRTtBQUNILE9BaEJHLENBQUo7QUFpQkQsS0E5Q0Q7QUErQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsVUFBVSxDQUFDLE9BQUQsRUFBVSxVQUFWLEVBQXNCO0FBQzlCLFVBQU0sYUFBYSxHQUFHO0FBQ3BCLE1BQUEsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQURRO0FBRXBCLE1BQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUZJO0FBR3BCLE1BQUEsVUFBVSxFQUFFLFVBQVUsR0FDbEIsd0JBQWlCLFFBREMsR0FFbEIsd0JBQWlCLFVBTEQ7QUFNcEIsTUFBQSxNQUFNLEVBQUUsT0FBTyxDQUFDLE1BTkk7QUFPcEIsTUFBQSxPQUFPLEVBQUUsZ0NBQVUsT0FBVixFQUFtQixJQUFuQixFQUF5QixDQUF6QixDQVBXO0FBUXBCLE1BQUEsV0FBVyxFQUFFLElBQUksQ0FBQyxHQUFMLEVBUk87QUFTcEIsTUFBQSxRQUFRLEVBQUUsSUFUVTtBQVVwQixNQUFBLFlBQVksRUFBRSxJQVZNO0FBV3BCLE1BQUEsT0FBTyxFQUFFO0FBWFcsS0FBdEI7QUFhQSxTQUFLLGlCQUFMLENBQXVCLGFBQXZCO0FBQ0EsV0FBTyxhQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLFdBQVcsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQixJQUFsQixFQUF3QjtBQUNqQyxRQUFJLENBQUMsS0FBRCxJQUFVLENBQUMsUUFBZixFQUF5QjtBQUN2QjtBQUNEOztBQUVELElBQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUIsZ0NBQVUsUUFBVixFQUFvQixJQUFwQixFQUEwQixDQUExQixDQUFqQjtBQUNBLElBQUEsS0FBSyxDQUFDLFlBQU4sR0FBcUIsSUFBckI7QUFDQSxJQUFBLEtBQUssQ0FBQyxPQUFOLEdBQWdCLENBQUMsUUFBUSxDQUFDLEtBQTFCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsaUJBQWlCLENBQUMsS0FBRCxFQUFRO0FBQ3ZCLFVBQU0sSUFBSSxHQUFHLEtBQUssY0FBTCxFQUFiLENBRHVCLENBR3ZCOztBQUNBLElBQUEsSUFBSSxDQUFDLElBQUwsQ0FBVSxLQUFWLEVBSnVCLENBTXZCOztBQUNBLFFBQUksSUFBSSxDQUFDLE1BQUwsR0FBYyxnQkFBbEIsRUFBNkI7QUFDM0IsTUFBQSxJQUFJLENBQUMsS0FBTDtBQUNEOztBQUVELFNBQUssaUJBQUwsQ0FBdUIsSUFBdkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxxQkFBcUIsQ0FDbkIsZ0JBRG1CLEVBRW5CLE1BRm1CLEVBR25CLE1BSG1CLEVBSW5CLElBSm1CLEVBS25CLG9CQUxtQixFQU1uQjtBQUNBLFFBQUksUUFBSixFQUFjLFVBQWQ7O0FBRUEsUUFBSSxvQkFBSixFQUEwQjtBQUN4QixNQUFBLFFBQVEsR0FBRyxNQUFYO0FBQ0EsWUFBTSxnQkFBZ0IsR0FBRyxtQkFBbUIsQ0FBQyxRQUFELEVBQVcsSUFBWCxDQUE1QztBQUVBLE1BQUEsVUFBVSxHQUFHO0FBQ1gsUUFBQSxZQUFZLEVBQUU7QUFDWixVQUFBLFFBQVEsRUFBRSxnQkFERTtBQUVaLFVBQUEsWUFBWSxFQUFFO0FBRkY7QUFESCxPQUFiO0FBTUQsS0FWRCxNQVVPO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBQSxVQUFVLEdBQUcsTUFBTSxDQUNoQixHQURVLENBQ0wsSUFBRCxJQUFVO0FBQ2IsWUFBSSxJQUFJLENBQUMsZ0JBQUwsS0FBMEIsY0FBOUIsRUFBOEM7QUFDNUMsVUFBQSxRQUFRLEdBQUcsS0FBSyx5QkFBTCxDQUErQixJQUEvQixDQUFYO0FBQ0Q7O0FBRUQsZUFBTyxJQUFJLENBQUMsZ0JBQVo7QUFDRCxPQVBVLEVBUVYsTUFSVSxDQVFILENBQUMsR0FBRCxFQUFNLE1BQU4sS0FBaUI7QUFDdkI7QUFDQTtBQUNBLFlBQUksZ0JBQWdCLENBQUMsUUFBakIsQ0FBMEIsTUFBMUIsQ0FBSixFQUF1QztBQUNyQyxjQUFJLE1BQU0sS0FBSyxjQUFmLEVBQStCO0FBQzdCLGtCQUFNLGdCQUFnQixHQUFHLG1CQUFtQixDQUFDLFFBQUQsRUFBVyxJQUFYLENBQTVDO0FBRUEsWUFBQSxHQUFHLENBQUMsTUFBRCxDQUFILEdBQWM7QUFDWixjQUFBLFlBQVksRUFBRSxJQURGO0FBRVosY0FBQSxRQUFRLEVBQUU7QUFGRSxhQUFkO0FBSUQsV0FQRCxNQU9PO0FBQ0wsWUFBQSxHQUFHLENBQUMsTUFBRCxDQUFILEdBQWM7QUFBRSxjQUFBLFlBQVksRUFBRTtBQUFoQixhQUFkO0FBQ0Q7QUFDRjs7QUFFRCxlQUFPLEdBQVA7QUFDRCxPQXpCVSxFQXlCUixFQXpCUSxDQUFiO0FBMEJEOztBQUVELFFBQUksTUFBTSxDQUFDLElBQVAsQ0FBWSxVQUFaLEVBQXdCLE1BQXhCLEdBQWlDLENBQXJDLEVBQXdDO0FBQ3RDLFdBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsVUFBOUI7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxnQkFBZ0IsQ0FBQyxNQUFELEVBQVMsVUFBVCxFQUFxQjtBQUNuQztBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssVUFBTCxFQUFoQjs7QUFDQSxVQUFNLGdCQUFnQixtQ0FDakIsT0FBTyxDQUFDLE1BQUQsQ0FEVSxHQUVqQixVQUZpQixDQUF0QixDQUhtQyxDQVFuQztBQUNBOzs7QUFDQSxVQUFNLHdCQUF3QixHQUM1QixPQUFPLENBQUMsTUFBRCxDQUFQLElBQW1CLE9BQU8sQ0FBQyxNQUFELENBQVAsQ0FBZ0IsWUFEckM7QUFFQSxVQUFNLG1CQUFtQixHQUFHLFVBQVUsQ0FBQyxZQUF2Qzs7QUFFQSxRQUFJLHdCQUF3QixJQUFJLG1CQUFoQyxFQUFxRDtBQUNuRDtBQUNBO0FBQ0EsWUFBTSxZQUFZLEdBQ2hCLG1CQUFtQixDQUFDLFlBQXBCLElBQ0Esd0JBQXdCLENBQUMsWUFGM0IsQ0FIbUQsQ0FPbkQ7O0FBQ0EsTUFBQSxnQkFBZ0IsQ0FBQyxZQUFqQixHQUFnQztBQUM5QixRQUFBLFlBRDhCO0FBRTlCLFFBQUEsUUFBUSxrQ0FDSCx3QkFBd0IsQ0FBQyxRQUR0QixHQUVILG1CQUFtQixDQUFDLFFBRmpCO0FBRnNCLE9BQWhDO0FBT0Q7O0FBRUQsSUFBQSxPQUFPLENBQUMsTUFBRCxDQUFQLEdBQWtCLGdCQUFsQjtBQUVBLFNBQUssYUFBTCxDQUFtQixPQUFuQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLG1CQUFtQixDQUFDLE9BQUQsRUFBVTtBQUMzQixRQUNFLENBQUMsT0FBTyxDQUFDLE1BQVQsSUFDQSxDQUFDLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixDQURELElBRUEsT0FBTyxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsQ0FBUCxLQUE2QixRQUY3QixJQUdBLEtBQUssQ0FBQyxPQUFOLENBQWMsT0FBTyxDQUFDLE1BQVIsQ0FBZSxDQUFmLENBQWQsQ0FKRixFQUtFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixDQUFaLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHlCQUF5QixDQUFDLElBQUQsRUFBTztBQUM5QixRQUFJLElBQUksQ0FBQyxnQkFBTCxLQUEwQixjQUExQixJQUE0QyxDQUFDLElBQUksQ0FBQyxPQUF0RCxFQUErRDtBQUM3RCxhQUFPLEVBQVA7QUFDRDs7QUFFRCxVQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUosRUFBakI7O0FBQ0EsU0FBSyxNQUFNLE1BQVgsSUFBcUIsSUFBSSxDQUFDLE9BQTFCLEVBQW1DO0FBQ2pDLFVBQ0UsTUFBTSxDQUFDLElBQVAsS0FBZ0IseUJBQVksd0JBQTVCLElBQ0EsS0FBSyxDQUFDLE9BQU4sQ0FBYyxNQUFNLENBQUMsS0FBckIsQ0FGRixFQUdFO0FBQ0EsYUFBSyxNQUFNLEtBQVgsSUFBb0IsTUFBTSxDQUFDLEtBQTNCLEVBQWtDO0FBQ2hDLFVBQUEsUUFBUSxDQUFDLEdBQVQsQ0FBYSxLQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFdBQU8sQ0FBQyxHQUFHLFFBQUosQ0FBUDtBQUNEOztBQXpWa0MsQyxDQTRWckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0EsU0FBUyxtQkFBVCxDQUE2QixRQUE3QixFQUF1QyxJQUF2QyxFQUE2QztBQUMzQyxTQUFPLFFBQVEsQ0FBQyxNQUFULENBQWdCLENBQUMsR0FBRCxFQUFNLE9BQU4scUNBQXdCLEdBQXhCO0FBQTZCLEtBQUMsT0FBRCxHQUFXO0FBQXhDLElBQWhCLEVBQWlFLEVBQWpFLENBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDclhEOztBQUNBOztBQUtPLFNBQVMsaUNBQVQsQ0FBMkMsb0JBQTNDLEVBQWlFO0FBQ3RFLFNBQU87QUFDTCxJQUFBLG1CQUFtQixFQUFFLENBQUMsTUFBRCxFQUFTLE9BQVQsS0FBcUI7QUFDeEMsWUFBTSxRQUFRLEdBQUcsb0JBQW9CLENBQUMsU0FBckIsQ0FDZixNQURlLEVBRWYsK0JBQWtCLFlBRkgsRUFHZix5QkFBWSx3QkFIRyxDQUFqQjs7QUFNQSxVQUFJLFFBQVEsQ0FBQyxLQUFULENBQWUsUUFBZixDQUF3QixPQUF4QixDQUFKLEVBQXNDO0FBQ3BDLGNBQU0sSUFBSSxLQUFKLENBQ0gsdUNBQXNDLE1BQU8sOEJBQTZCLE9BQVEsSUFEL0UsQ0FBTjtBQUdEOztBQUVELE1BQUEsb0JBQW9CLENBQUMsWUFBckIsQ0FDRSxNQURGLEVBRUUsK0JBQWtCLFlBRnBCLEVBR0UseUJBQVksd0JBSGQsRUFJRSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQWIsRUFBb0IsT0FBcEIsQ0FKRjtBQU1ELEtBcEJJO0FBc0JMLElBQUEsc0JBQXNCLEVBQUUsQ0FBQyxNQUFELEVBQVMsT0FBVCxLQUFxQjtBQUMzQyxZQUFNLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxTQUFyQixDQUNmLE1BRGUsRUFFZiwrQkFBa0IsWUFGSCxFQUdmLHlCQUFZLHdCQUhHLENBQWpCOztBQU1BLFVBQUksQ0FBQyxRQUFRLENBQUMsS0FBVCxDQUFlLFFBQWYsQ0FBd0IsT0FBeEIsQ0FBTCxFQUF1QztBQUNyQyxjQUFNLElBQUksS0FBSixDQUNILHVDQUFzQyxNQUFPLHNDQUFxQyxPQUFRLElBRHZGLENBQU47QUFHRDs7QUFFRCxZQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxLQUFULENBQWUsTUFBZixDQUN2QixlQUFELElBQXFCLGVBQWUsS0FBSyxPQURqQixDQUExQjs7QUFJQSxVQUFJLGlCQUFpQixDQUFDLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2xDLFFBQUEsb0JBQW9CLENBQUMsZ0JBQXJCLENBQ0UsTUFERixFQUVFLCtCQUFrQixZQUZwQjtBQUlELE9BTEQsTUFLTztBQUNMLFFBQUEsb0JBQW9CLENBQUMsWUFBckIsQ0FDRSxNQURGLEVBRUUsK0JBQWtCLFlBRnBCLEVBR0UseUJBQVksd0JBSGQsRUFJRSxpQkFKRjtBQU1EO0FBQ0YsS0FwREk7QUFzREwsSUFBQSwrQkFBK0IsRUFBRSxNQUFPLE1BQVAsSUFBa0I7QUFDakQsWUFBTSxFQUFFLEdBQUcsc0JBQVg7QUFDQSxNQUFBLG9CQUFvQixDQUFDLGtCQUFyQixDQUNFO0FBQUUsUUFBQTtBQUFGLE9BREYsRUFFRTtBQUNFLFFBQUEsWUFBWSxFQUFFO0FBRGhCLE9BRkYsRUFLRTtBQUFFLFFBQUE7QUFBRixPQUxGO0FBT0EsYUFBTyxFQUFQO0FBQ0Q7QUFoRUksR0FBUDtBQWtFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RUQ7O0FBSUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsTUFBUCxtQkFDbEIsOEJBRGtCLEVBQXZCO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYztBQUNwQyxHQUFDLHlCQUFZLHdCQUFiLEdBQXlDLFFBQUQsSUFBYztBQUNwRCxXQUFPO0FBQUUsTUFBQSxJQUFJLEVBQUUseUJBQVksd0JBQXBCO0FBQThDLE1BQUEsS0FBSyxFQUFFO0FBQXJELEtBQVA7QUFDRDtBQUhtQyxDQUFkLENBQXhCO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sTUFBTSx1QkFBdUIsR0FBRyxDQUFDO0FBQUUsRUFBQTtBQUFGLENBQUQsS0FBdUI7QUFDNUQsU0FBTztBQUNMLEtBQUMseUJBQVksd0JBQWIsR0FBd0M7QUFDdEMsTUFBQSxJQUFJLEVBQUUseUJBQVksd0JBRG9CO0FBR3RDLE1BQUEsU0FBUyxFQUFFLENBQUMsTUFBRCxFQUFTLE1BQVQsS0FBb0I7QUFDN0IsZUFBTyxNQUFPLElBQVAsSUFBZ0I7QUFDckIsZ0JBQU0sTUFBTSxHQUFHLE1BQU0sTUFBTSxDQUFDLElBQUQsQ0FBM0I7QUFDQSxpQkFBTyxNQUFNLENBQ1YsTUFESSxDQUNJLE9BQUQsSUFBYSxNQUFNLENBQUMsS0FBUCxDQUFhLFFBQWIsQ0FBc0IsT0FBdEIsQ0FEaEIsRUFFSixLQUZJLENBRUUsQ0FGRixFQUVLLENBRkwsQ0FBUDtBQUdELFNBTEQ7QUFNRCxPQVZxQztBQVl0QyxNQUFBLFNBQVMsRUFBRSxDQUFDLE1BQUQsRUFBUyxPQUFULEVBQWtCLE9BQWxCLEtBQ1Qsc0JBQXNCLENBQUMsTUFBTSxDQUFDLEtBQVIsRUFBZSxhQUFmO0FBYmM7QUFEbkMsR0FBUDtBQWlCRCxDQWxCTTtBQW9CUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNPLE1BQU0sMkJBQTJCLEdBQUcsQ0FBQztBQUMxQyxFQUFBLGNBRDBDO0FBRTFDLEVBQUEsYUFGMEM7QUFHMUMsRUFBQTtBQUgwQyxDQUFELEtBSXJDO0FBQ0osU0FBTztBQUNMLEtBQUMsY0FBYyxDQUFDLFlBQWhCLEdBQStCO0FBQzdCLE1BQUEsY0FBYyxFQUFFLGdDQUFlLGdCQURGO0FBRTdCLE1BQUEsU0FBUyxFQUFFLGNBQWMsQ0FBQyxZQUZHO0FBRzdCLE1BQUEsY0FBYyxFQUFFLENBQUMseUJBQVksd0JBQWIsQ0FIYTtBQUs3QixNQUFBLE9BQU8sRUFBRSxDQUFDLGlCQUFELEVBQW9CLFdBQXBCLEtBQW9DO0FBQzNDLFlBQUksS0FBSyxDQUFDLE9BQU4sQ0FBYyxpQkFBaUIsQ0FBQyxPQUFoQyxDQUFKLEVBQThDO0FBQzVDLGdCQUFNLElBQUksS0FBSixDQUNILEdBQUUsY0FBYyxDQUFDLFlBQWEseUZBRDNCLENBQU47QUFHRCxTQUwwQyxDQU8zQzs7O0FBQ0EsWUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBakIsRUFBbUM7QUFDakMsZ0JBQU0sSUFBSSxLQUFKLENBQ0gsR0FBRSxjQUFjLENBQUMsWUFBYSx5Q0FEM0IsQ0FBTjtBQUdEOztBQUVELGVBQU8sMEVBQ0YsaUJBREU7QUFFTCxVQUFBLE9BQU8sRUFBRSxDQUNQLGVBQWUsQ0FBQyx5QkFBWSx3QkFBYixDQUFmLENBQ0UsV0FBVyxDQUFDLGdCQURkLENBRE87QUFGSixXQUFQO0FBUUQsT0EzQjRCO0FBNkI3QixNQUFBLG9CQUFvQixFQUFFLE1BQU8sS0FBUCxJQUFpQjtBQUNyQyxjQUFNLFFBQVEsR0FBRyxNQUFNLGNBQWMsRUFBckM7QUFDQSxjQUFNLFVBQVUsR0FBRyxhQUFhLEVBQWhDO0FBRUEsZUFBTyxRQUFRLENBQUMsSUFBVCxDQUFjLENBQUMsWUFBRCxFQUFlLGFBQWYsS0FBaUM7QUFDcEQsY0FBSSxDQUFDLFVBQVUsQ0FBQyxZQUFELENBQWYsRUFBK0I7QUFDN0IsWUFBQSx3Q0FBd0MsQ0FBQyxVQUFELEVBQWEsUUFBYixDQUF4QztBQUNBLGtCQUFNLElBQUksS0FBSixDQUFXLGtDQUFpQyxZQUFhLElBQXpELENBQU47QUFDRCxXQUhELE1BR08sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFELENBQWYsRUFBZ0M7QUFDckMsWUFBQSx3Q0FBd0MsQ0FBQyxVQUFELEVBQWEsUUFBYixDQUF4QztBQUNBLGtCQUFNLElBQUksS0FBSixDQUNILGtDQUFpQyxhQUFjLElBRDVDLENBQU47QUFHRCxXQUxNLE1BS0EsSUFDTCxVQUFVLENBQUMsWUFBRCxDQUFWLENBQXlCLFlBQXpCLEtBQ0EsVUFBVSxDQUFDLGFBQUQsQ0FBVixDQUEwQixZQUZyQixFQUdMO0FBQ0EsbUJBQU8sQ0FBUDtBQUNELFdBTE0sTUFLQSxJQUFJLFVBQVUsQ0FBQyxZQUFELENBQVYsQ0FBeUIsWUFBekIsS0FBMEMsU0FBOUMsRUFBeUQ7QUFDOUQsbUJBQU8sQ0FBUDtBQUNELFdBRk0sTUFFQSxJQUFJLFVBQVUsQ0FBQyxhQUFELENBQVYsQ0FBMEIsWUFBMUIsS0FBMkMsU0FBL0MsRUFBMEQ7QUFDL0QsbUJBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQsaUJBQ0UsVUFBVSxDQUFDLGFBQUQsQ0FBVixDQUEwQixZQUExQixHQUNBLFVBQVUsQ0FBQyxZQUFELENBQVYsQ0FBeUIsWUFGM0I7QUFJRCxTQXhCTSxDQUFQO0FBeUJELE9BMUQ0QjtBQTREN0IsTUFBQSxTQUFTLEVBQUUsQ0FBQyxVQUFELEVBQWEsT0FBYixFQUFzQixPQUF0QixLQUFrQztBQUMzQyxjQUFNO0FBQUUsVUFBQTtBQUFGLFlBQWMsVUFBcEI7O0FBQ0EsWUFDRSxDQUFDLE9BQUQsSUFDQSxPQUFPLENBQUMsTUFBUixLQUFtQixDQURuQixJQUVBLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBVyxJQUFYLEtBQW9CLHlCQUFZLHdCQUhsQyxFQUlFO0FBQ0EsZ0JBQU0sSUFBSSxLQUFKLENBQ0gsR0FBRSxjQUFjLENBQUMsWUFBYSxtRUFBa0UseUJBQVksd0JBQXlCLElBRGxJLENBQU47QUFHRDtBQUNGO0FBdkU0QjtBQUQxQixHQUFQO0FBMkVELENBaEZNO0FBa0ZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQSxTQUFTLHNCQUFULENBQWdDLFFBQWhDLEVBQTBDLGFBQTFDLEVBQXlEO0FBQ3ZELE1BQUksQ0FBQyxLQUFLLENBQUMsT0FBTixDQUFjLFFBQWQsQ0FBRCxJQUE0QixRQUFRLENBQUMsTUFBVCxLQUFvQixDQUFwRCxFQUF1RDtBQUNyRCxVQUFNLElBQUksS0FBSixDQUNILEdBQUUsY0FBYyxDQUFDLFlBQWEseURBRDNCLENBQU47QUFHRDs7QUFFRCxRQUFNLFVBQVUsR0FBRyxhQUFhLEVBQWhDO0FBQ0EsRUFBQSxRQUFRLENBQUMsT0FBVCxDQUFrQixPQUFELElBQWE7QUFDNUIsUUFBSSxDQUFDLE9BQUQsSUFBWSxPQUFPLE9BQVAsS0FBbUIsUUFBbkMsRUFBNkM7QUFDM0MsWUFBTSxJQUFJLEtBQUosQ0FDSCxHQUFFLGNBQWMsQ0FBQyxZQUFhLCtEQUE4RCxPQUFRLElBRGpHLENBQU47QUFHRDs7QUFFRCxRQUFJLENBQUMsVUFBVSxDQUFDLE9BQUQsQ0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUksS0FBSixDQUNILEdBQUUsY0FBYyxDQUFDLFlBQWEsMkNBQTBDLE9BQVEsSUFEN0UsQ0FBTjtBQUdEO0FBQ0YsR0FaRDtBQWFEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUMvQyxpQkFEK0MsRUFFL0MsVUFGK0MsRUFHL0MsYUFIK0MsRUFJL0MsY0FKK0MsRUFLL0MsYUFMK0MsRUFNL0MsaUJBTitDLEVBTy9DLGdCQVArQyxFQVEvQyxjQVIrQyxFQVMvQyxnQkFUK0MsRUFVL0Msb0JBVitDLEVBVy9DLHNCQVgrQyxFQVkvQyxvQ0FaK0MsRUFhL0Msc0NBYitDLEVBYy9DLGFBZCtDLEVBZS9DLDRCQWYrQyxFQWdCL0Msc0JBaEIrQyxFQWlCL0MsbUJBakIrQyxFQWtCL0MsYUFsQitDLEVBbUIvQyxjQW5CK0MsRUFvQi9DLGtCQXBCK0MsRUFxQi9DLHVDQXJCK0MsRUFzQi9DLHlDQXRCK0MsRUF1Qi9DLDBCQXZCK0MsRUF3Qi9DLHlCQXhCK0MsRUF5Qi9DLDJCQXpCK0MsRUEwQi9DLGlDQTFCK0MsRUEyQi9DLG1DQTNCK0MsRUE0Qi9DLDhCQTVCK0MsRUE2Qi9DLGdDQTdCK0MsRUE4Qi9DLGFBOUIrQyxFQStCL0MsY0EvQitDLEVBZ0MvQyxZQWhDK0MsRUFpQy9DLG9CQWpDK0MsRUFrQy9DLGVBbEMrQyxFQW1DL0MsaUNBbkMrQyxFQW9DL0MscUJBcEMrQyxFQXFDL0Msd0JBckMrQyxFQXNDL0MscUJBdEMrQyxFQXVDL0MsVUF2QytDLEVBd0MvQyxtQkF4QytDLEVBeUMvQyxzQkF6QytDLEVBMEMvQyxzQkExQytDLEVBMkMvQyxzQkEzQytDLEVBNEMvQyxvQkE1QytDLEVBNkMvQyxnQkE3QytDLEVBOEMvQyxhQTlDK0MsRUErQy9DLHFCQS9DK0MsRUFnRC9DLDJCQWhEK0MsRUFpRC9DLHFCQWpEK0MsRUFrRC9DLGVBbEQrQyxFQW1EL0MsZUFuRCtDLEVBb0QvQyxhQXBEK0MsRUFxRC9DLG9CQXJEK0MsRUFzRC9DLGVBdEQrQyxFQXVEL0MsbUJBdkQrQyxFQXdEL0Msb0JBeEQrQyxFQXlEL0MsV0F6RCtDLENBQWQsQ0FBNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDak5QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLFNBQVMsZUFBVCxDQUF5QixHQUF6QixFQUE4QjtBQUMzQyxNQUFJO0FBQUUsSUFBQTtBQUFGLE1BQVcsR0FBZjtBQUNBLEVBQUEsSUFBSSxHQUFHLElBQUksS0FBSyxTQUFULEdBQXFCLE9BQXJCLEdBQStCLE1BQU0sQ0FBQyxJQUFELENBQTVDO0FBRUEsTUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQWQ7QUFDQSxFQUFBLEdBQUcsR0FBRyxHQUFHLEtBQUssU0FBUixHQUFvQixFQUFwQixHQUF5QixNQUFNLENBQUMsR0FBRCxDQUFyQzs7QUFFQSxNQUFJLElBQUksS0FBSyxFQUFiLEVBQWlCO0FBQ2YsSUFBQSxHQUFHLENBQUMsS0FBSixHQUFZLEdBQUcsQ0FBQyxPQUFoQjtBQUNELEdBRkQsTUFFTyxJQUFJLEdBQUcsS0FBSyxFQUFaLEVBQWdCO0FBQ3JCLElBQUEsR0FBRyxDQUFDLEtBQUosR0FBWSxHQUFHLENBQUMsSUFBaEI7QUFDRCxHQUZNLE1BRUEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFULEVBQWdCO0FBQ3JCLElBQUEsR0FBRyxDQUFDLEtBQUosR0FBYSxHQUFFLEdBQUcsQ0FBQyxJQUFLLEtBQUksR0FBRyxDQUFDLE9BQVEsRUFBeEM7QUFDRDs7QUFFRCxTQUFPLEdBQVA7QUFDRDs7Ozs7Ozs7Ozs7O0FDdEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pLQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFFQSxNQUFNLFdBQVcsR0FBRztBQUNsQixFQUFBLElBQUksRUFBRSxrQkFEWTtBQUVsQixFQUFBLEVBQUUsRUFBRSxDQUFDLEVBQUQsRUFBSyxTQUFMLEtBQ0YsU0FBUyxHQUFHLHdCQUFhLEVBQWIsRUFBaUIsV0FBakIsRUFBSCxHQUFvQyx3QkFBYSxFQUFiLENBSDdCO0FBSWxCLEVBQUEsS0FBSyxFQUFFLGtCQUpXO0FBS2xCLEVBQUEsS0FBSyxFQUFFLGtCQUxXO0FBTWxCLEVBQUEsSUFBSSxFQUFFLGtCQU5ZO0FBT2xCLEVBQUEsR0FBRyxFQUFFLGtCQVBhO0FBUWxCLEVBQUEsUUFBUSxFQUFFLGtCQVJRO0FBU2xCLEVBQUEsWUFBWSxFQUFFLGtCQVRJO0FBVWxCLEVBQUEsb0JBQW9CLEVBQUUsa0JBVko7QUFXbEIsRUFBQSxJQUFJLEVBQUUsa0JBWFk7QUFZbEIsRUFBQSxpQkFBaUIsRUFBRyxRQUFELElBQWMsUUFaZjtBQWFsQixFQUFBLFlBQVksRUFBRyxRQUFELElBQWM7QUFiVixDQUFwQjs7QUFnQk8sU0FBUyw0QkFBVCxDQUFzQyxRQUF0QyxFQUFnRCxTQUFTLEdBQUcsSUFBNUQsRUFBa0U7QUFDdkUsUUFBTSxrQkFBa0IsR0FBRyxpQkFBaUIsQ0FBQyxRQUFELEVBQVcsU0FBWCxDQUE1QztBQUNBLEVBQUEsZ0JBQWdCLENBQUMsa0JBQUQsQ0FBaEI7QUFDQSxTQUFPLGtCQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTLGlCQUFULENBQTJCLFFBQTNCLEVBQXFDLFNBQVMsR0FBRyxJQUFqRCxFQUF1RDtBQUM1RDtBQUNBLFFBQU0sa0JBQWtCLEdBQUcsRUFBM0I7O0FBQ0EsT0FBSyxNQUFNLEdBQVgsSUFBa0IsV0FBbEIsRUFBK0I7QUFDN0IsUUFBSSxRQUFRLENBQUMsR0FBRCxDQUFaLEVBQW1CO0FBQ2pCLE1BQUEsa0JBQWtCLENBQUMsR0FBRCxDQUFsQixHQUEwQixXQUFXLENBQUMsR0FBRCxDQUFYLENBQWlCLFFBQVEsQ0FBQyxHQUFELENBQXpCLEVBQWdDLFNBQWhDLENBQTFCO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPLGtCQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyx3Q0FBVCxDQUNFLFFBREYsRUFFRSxtQkFGRixFQUdFLHNCQUhGLEVBSUU7QUFDQSxNQUFJLE9BQU8sUUFBUSxDQUFDLHNCQUFELENBQWYsS0FBNEMsV0FBaEQsRUFBNkQ7QUFDM0QsVUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNILHlDQUF3QyxtQkFBb0Isc0JBQXFCLHNCQUF1Qix5QkFEckcsQ0FBTjtBQUdEO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLG1CQUFULENBQTZCLFFBQTdCLEVBQXVDLEtBQXZDLEVBQThDO0FBQzVDLE1BQUksT0FBTyxRQUFRLENBQUMsS0FBRCxDQUFmLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDLFVBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSCwrQkFBOEIsS0FBTSwyQkFBMEIsUUFBUSxDQUFDLEtBQUQsQ0FBUSxHQUQzRSxDQUFOO0FBR0Q7QUFDRjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsMkNBQVQsQ0FBcUQsUUFBckQsRUFBK0QsS0FBL0QsRUFBc0U7QUFDcEUsVUFBUSxLQUFSO0FBQ0UsU0FBSyxjQUFMO0FBQ0EsU0FBSyxzQkFBTDtBQUNFLFVBQ0UsUUFBUSxDQUFDLElBQVQsSUFDQSxRQUFRLENBQUMsSUFBVCxLQUFrQix3Q0FBMkIsVUFGL0MsRUFHRTtBQUNBLGNBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSCxzREFBcUQsUUFBUSxDQUFDLElBQUsseUVBQXdFLHdDQUEyQixVQUFXLEdBRDlLLENBQU47QUFHRDs7QUFDRDs7QUFDRixTQUFLLFVBQUw7QUFDQTtBQUNFLFVBQ0UsUUFBUSxDQUFDLElBQVQsSUFDQSxRQUFRLENBQUMsSUFBVCxLQUFrQix3Q0FBMkIsVUFGL0MsRUFHRTtBQUNBLGNBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSCxzREFBcUQsUUFBUSxDQUFDLElBQUssNEVBRGhFLENBQU47QUFHRDs7QUFyQkw7QUF1QkQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBUyxnQkFBVCxDQUEwQixRQUExQixFQUFvQyxvQkFBb0IsR0FBRyxJQUEzRCxFQUFpRTtBQUN0RSxNQUFJLENBQUMsUUFBRCxJQUFhLE9BQU8sUUFBUCxLQUFvQixRQUFqQyxJQUE2QyxLQUFLLENBQUMsT0FBTixDQUFjLFFBQWQsQ0FBakQsRUFBMEU7QUFDeEUsVUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNKLGdEQURJLENBQU47QUFHRDs7QUFDRCxNQUFJLENBQUMsUUFBUSxDQUFDLEVBQVYsSUFBZ0IsQ0FBQyxRQUFRLENBQUMsSUFBOUIsRUFBb0M7QUFDbEMsVUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNKLGdKQURJLENBQU47QUFHRDs7QUFDRCxNQUFJLHdDQUFxQjtBQUFFLElBQUE7QUFBRixHQUFyQixLQUFzQyxDQUFDLG9CQUEzQyxFQUFpRTtBQUMvRCxVQUFNLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQ0osc0hBREksQ0FBTjtBQUdEOztBQUVELEVBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxRQUFmLEVBQXlCLE9BQXpCLENBQWlDLENBQUMsQ0FBQyxHQUFELEVBQU0sS0FBTixDQUFELEtBQWtCO0FBQ2pEO0FBQ0EsWUFBUSxHQUFSO0FBQ0UsV0FBSyxNQUFMO0FBQ0UsUUFBQSxZQUFZLENBQUMsUUFBRCxDQUFaO0FBQ0E7O0FBQ0YsV0FBSyxJQUFMO0FBQ0UsUUFBQSxpQkFBaUIsQ0FBQyxRQUFELENBQWpCO0FBQ0E7O0FBQ0YsV0FBSyxVQUFMO0FBQ0UsUUFBQSwyQ0FBMkMsQ0FBQyxRQUFELEVBQVcsVUFBWCxDQUEzQztBQUNBLFFBQUEsd0NBQXdDLENBQ3RDLFFBRHNDLEVBRXRDLFVBRnNDLEVBR3RDLGNBSHNDLENBQXhDO0FBS0EsUUFBQSx3Q0FBd0MsQ0FDdEMsUUFEc0MsRUFFdEMsVUFGc0MsRUFHdEMsc0JBSHNDLENBQXhDO0FBS0EsUUFBQSxtQkFBbUIsQ0FBQyxRQUFELEVBQVcsVUFBWCxDQUFuQjtBQUNBOztBQUNGLFdBQUssY0FBTDtBQUNFLFFBQUEsMkNBQTJDLENBQUMsUUFBRCxFQUFXLGNBQVgsQ0FBM0M7QUFDQSxRQUFBLHdDQUF3QyxDQUN0QyxRQURzQyxFQUV0QyxjQUZzQyxFQUd0QyxVQUhzQyxDQUF4QztBQUtBLFFBQUEsbUJBQW1CLENBQUMsUUFBRCxFQUFXLGNBQVgsQ0FBbkI7QUFDQTs7QUFDRixXQUFLLHNCQUFMO0FBQ0UsUUFBQSwyQ0FBMkMsQ0FDekMsUUFEeUMsRUFFekMsc0JBRnlDLENBQTNDO0FBSUEsUUFBQSx3Q0FBd0MsQ0FDdEMsUUFEc0MsRUFFdEMsc0JBRnNDLEVBR3RDLFVBSHNDLENBQXhDO0FBS0EsUUFBQSxtQkFBbUIsQ0FBQyxRQUFELEVBQVcsc0JBQVgsQ0FBbkI7QUFDQTs7QUFDRixXQUFLLE9BQUw7QUFDRSxRQUFBLG1CQUFtQixDQUFDLFFBQUQsRUFBVyxPQUFYLENBQW5COztBQUNBLFlBQUksS0FBSyxDQUFDLFFBQU4sR0FBaUIsUUFBakIsQ0FBMEIsR0FBMUIsQ0FBSixFQUFvQztBQUNsQyxnQkFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNILDhCQUE2QixLQUFNLDJCQURoQyxDQUFOO0FBR0Q7O0FBRUQsWUFBSSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFqQixDQUEwQixHQUExQixDQUFKLEVBQW9DO0FBQ2xDLGdCQUFNLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQ0gsaUNBQWdDLEtBQU0sMkJBRG5DLENBQU47QUFHRDs7QUFFRCxZQUFJLENBQUMsS0FBSyxDQUFDLEtBQU4sQ0FBWSxtQkFBWixDQUFMLEVBQXVDO0FBQ3JDLGdCQUFNLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQ0gsaUNBQWdDLEtBQU0sNEJBRG5DLENBQU47QUFHRDs7QUFDRDs7QUFDRixXQUFLLFNBQUw7QUFDRSxZQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPLEtBQVAsS0FBaUIsUUFBbEQsRUFBNEQ7QUFDMUQsZ0JBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSCwrQkFBOEIsR0FBSSx5Q0FBd0MsS0FBTSxHQUQ3RSxDQUFOO0FBR0Q7O0FBQ0Q7O0FBQ0Y7QUFDRSxRQUFBLG1CQUFtQixDQUFDLFFBQUQsRUFBVyxHQUFYLENBQW5CO0FBdEVKO0FBd0VELEdBMUVEO0FBMkVEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTLFlBQVQsQ0FBc0IsUUFBdEIsRUFBZ0M7QUFDckMsTUFBSSxFQUFFLE9BQU8sUUFBUSxDQUFDLElBQWhCLEtBQXlCLFFBQTNCLENBQUosRUFBMEM7QUFDeEMsVUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNILDJCQUEwQixRQUFRLENBQUMsSUFBSyxrQkFEckMsQ0FBTjtBQUdEOztBQUNELE1BQUksQ0FBQyx1Q0FBa0IsUUFBUSxDQUFDLElBQTNCLEVBQWlDO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUFqQyxDQUFMLEVBQW9FO0FBQ2xFLFVBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEIseUJBQTVCLENBQU47QUFDRDtBQUNGO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVMsaUJBQVQsQ0FBMkIsUUFBM0IsRUFBcUM7QUFDMUMsTUFBSSxRQUFRLENBQUMsRUFBVCxLQUFnQixJQUFoQixJQUF3QixRQUFRLENBQUMsRUFBVCxLQUFnQixJQUE1QyxFQUFrRDtBQUNoRCxRQUFJLFFBQVEsQ0FBQyxJQUFiLEVBQW1CO0FBQ2pCLGFBQU8sUUFBUSxDQUFDLEVBQWhCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0Qix1QkFBNUIsQ0FBTjtBQUNEO0FBQ0YsR0FORCxNQU1PLElBQ0wsUUFBUSxDQUFDLEVBQVQsS0FBZ0IsU0FBaEIsSUFDQSxDQUFDLHVDQUFrQixRQUFRLENBQUMsRUFBM0IsRUFBK0I7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBQS9CLENBRkksRUFHTDtBQUNBLFVBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEIsdUJBQTVCLENBQU47QUFDRDs7QUFDRCxTQUFPLFFBQVA7QUFDRDs7QUFFTSxNQUFNLG9DQUFvQyxHQUFHLENBQUM7QUFDbkQsRUFBQSxNQURtRDtBQUVuRCxFQUFBLG1CQUZtRDtBQUduRCxFQUFBO0FBSG1ELElBSWpELEVBSmdELEtBSXpDO0FBQ1QsTUFBSSxDQUFDLE1BQUQsSUFBVyxDQUFDLE1BQU0sQ0FBQyxRQUF2QixFQUFpQztBQUMvQixVQUFNLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQ0osMENBREksQ0FBTjtBQUdEOztBQUNELE1BQUksTUFBTSxDQUFDLE1BQVAsS0FBa0Isa0NBQXFCLFNBQTNDLEVBQXNEO0FBQ3BELFVBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSixtREFESSxDQUFOO0FBR0Q7O0FBQ0QsUUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBeEM7O0FBQ0EsTUFBSSxtQkFBbUIsSUFBSSxtQkFBbUIsQ0FBQyxNQUFwQixHQUE2QixDQUF4RCxFQUEyRDtBQUN6RCxVQUFNLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDLElBQXBCLENBQzNCLEVBQUQ7QUFBQTs7QUFBQSxhQUFRLGlCQUFBLEVBQUUsQ0FBQyxRQUFILDhEQUFhLEtBQWIsTUFBdUIsZUFBL0I7QUFBQSxLQUQ0QixDQUE5Qjs7QUFHQSxRQUFJLHFCQUFKLEVBQTJCO0FBQ3pCLFlBQU0sd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FDSix5REFESSxDQUFOO0FBR0Q7QUFDRjs7QUFDRCxNQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLE1BQXRCLEdBQStCLENBQTVELEVBQStEO0FBQzdELFVBQU0sdUJBQXVCLEdBQUcscUJBQXFCLENBQUMsSUFBdEIsQ0FDN0IsRUFBRDtBQUFBOztBQUFBLGFBQVEsa0JBQUEsRUFBRSxDQUFDLFFBQUgsZ0VBQWEsS0FBYixNQUF1QixlQUEvQjtBQUFBLEtBRDhCLENBQWhDOztBQUdBLFFBQUksdUJBQUosRUFBNkI7QUFDM0IsWUFBTSx3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUNKLDJEQURJLENBQU47QUFHRDtBQUNGO0FBQ0YsQ0FwQ007QUFzQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDTyxTQUFTLGNBQVQsR0FBMEI7QUFDL0IsU0FBTyxDQUNMLGtDQUFxQixRQURoQixFQUMwQjtBQUMvQixvQ0FBcUIsU0FGaEIsRUFFMkI7QUFDaEMsb0NBQXFCLE1BSGhCLEVBR3dCO0FBQzdCLG9DQUFxQixPQUpoQixDQUl5QjtBQUp6QixHQUFQO0FBTUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTLHlCQUFULENBQW1DLE9BQW5DLEVBQTRDO0FBQ2pELFNBQU8sT0FBTyxPQUFQLEtBQW1CLFFBQW5CLEdBQThCLE9BQTlCLEdBQXdDLE9BQU8sQ0FBQyxRQUFSLENBQWlCLEVBQWpCLENBQS9DO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeFVEOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUtBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU0sdUJBQU4sU0FBc0MseUJBQXRDLENBQW1EO0FBQ2hFLEVBQUEsV0FBVyxDQUFDO0FBQUUsSUFBQSxTQUFGO0FBQWEsSUFBQSxjQUFiO0FBQTZCLElBQUEsVUFBN0I7QUFBeUMsSUFBQTtBQUF6QyxHQUFELEVBQStEO0FBQ3hFO0FBRUEsU0FBSyxLQUFMLEdBQWEsSUFBSSx5QkFBSjtBQUNYLE1BQUEsWUFBWSxFQUFFO0FBREgsT0FFUixTQUZRLEVBQWI7QUFJQSxTQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDQSxTQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxTQUFLLGlCQUFMLEdBQXlCLGlCQUF6QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxjQUFjLENBQUMsSUFBSSxHQUFHLEVBQVIsRUFBWTtBQUFBOztBQUN4QixVQUFNLEtBQUssR0FBRyxLQUFLLFVBQUwsRUFBZDtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssaUJBQUwsRUFBaEI7O0FBQ0EsUUFBSSxLQUFLLEtBQUssU0FBZCxFQUF5QjtBQUN2QixZQUFNLElBQUksS0FBSixDQUFVLHNEQUFWLENBQU47QUFDRDs7QUFFRCxRQUFJLG9CQUFvQixHQUFHLElBQTNCLENBUHdCLENBU3hCO0FBQ0E7QUFDQTs7QUFDQSxRQUNFLElBQUksQ0FBQyxRQUFMLElBQ0EsT0FBTyxJQUFJLENBQUMsTUFBWixLQUF1QixRQUR2QixJQUVBLElBQUksQ0FBQyxNQUFMLEtBQWdCLFVBSGxCLEVBSUU7QUFDQSxVQUFJLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxRQUFyQixLQUFrQyxXQUF0QyxFQUFtRDtBQUNqRCxRQUFBLG9CQUFvQixHQUFHO0FBQ3JCLFVBQUEsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFESCxTQUF2QjtBQUdELE9BSkQsTUFJTyxJQUNMLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxZQUFyQixLQUFzQyxXQUF0QyxJQUNBLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxvQkFBckIsS0FBOEMsV0FGekMsRUFHTDtBQUNBLFFBQUEsb0JBQW9CLEdBQUc7QUFDckIsVUFBQSxvQkFBb0IsRUFBRSxJQUFJLENBQUMsUUFBTCxDQUFjLG9CQURmO0FBRXJCLFVBQUEsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFGUCxTQUF2QjtBQUlEOztBQUVELFVBQUksT0FBTyxJQUFJLENBQUMsUUFBTCxDQUFjLEdBQXJCLEtBQTZCLFdBQWpDLEVBQThDO0FBQzVDLFFBQUEsb0JBQW9CLG1DQUNmLG9CQURlO0FBRWxCLFVBQUEsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFGRCxVQUFwQjtBQUlEO0FBQ0Y7O0FBRUQ7QUFDRSxNQUFBLEVBQUUsRUFBRSx3QkFETjtBQUVFLE1BQUEsSUFBSSxFQUFFLElBQUksSUFBSixHQUFXLE9BQVgsRUFGUjtBQUdFLE1BQUEsTUFBTSxFQUFFLGtDQUFxQixVQUgvQjtBQUlFLE1BQUEsaUJBQWlCLEVBQUUsS0FKckI7QUFLRSxNQUFBLG1CQUFtQixvQkFBRSxJQUFJLENBQUMsUUFBUCxtREFBRSxlQUFlLEdBTHRDO0FBTUUsTUFBQSxrQkFBa0IsRUFBRSxLQU50QjtBQU9FLE1BQUEsT0FQRjtBQVFFLE1BQUEsZUFBZSxFQUFFLElBUm5CO0FBU0UsTUFBQTtBQVRGLE9BVUssSUFWTDtBQVlEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxtQkFBbUIsR0FBRztBQUNwQixVQUFNLE9BQU8sR0FBRyxLQUFLLGlCQUFMLEVBQWhCO0FBQ0EsVUFBTSxPQUFPLEdBQUcsS0FBSyxVQUFMLEVBQWhCO0FBQ0EsV0FBTyxvQkFDTCxLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLFlBRGpCLEVBRUosV0FBRCxJQUNFLFdBQVcsQ0FBQyxNQUFaLEtBQXVCLGtDQUFxQixVQUE1QyxJQUNBLDZDQUEwQixXQUExQixFQUF1QyxPQUF2QyxFQUFnRCxPQUFoRCxDQUpHLENBQVA7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsdUJBQXVCLENBQUMsT0FBRCxFQUFVO0FBQy9CLFVBQU0sY0FBYyxHQUFHO0FBQUUsTUFBQSxNQUFNLEVBQUUsa0NBQXFCO0FBQS9CLEtBQXZCOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1gsTUFBQSxjQUFjLENBQUMsSUFBZixHQUFzQixPQUF0QjtBQUNEOztBQUNELFdBQU8sS0FBSyxlQUFMLENBQXFCO0FBQUUsTUFBQTtBQUFGLEtBQXJCLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsc0JBQXNCLENBQUMsT0FBRCxFQUFVO0FBQzlCLFVBQU0sY0FBYyxHQUFHO0FBQUUsTUFBQSxNQUFNLEVBQUUsa0NBQXFCO0FBQS9CLEtBQXZCOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1gsTUFBQSxjQUFjLENBQUMsSUFBZixHQUFzQixPQUF0QjtBQUNEOztBQUNELFdBQU8sS0FBSyxlQUFMLENBQXFCO0FBQUUsTUFBQTtBQUFGLEtBQXJCLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsd0JBQXdCLENBQUMsT0FBRCxFQUFVO0FBQ2hDLFVBQU0sY0FBYyxHQUFHO0FBQUUsTUFBQSxNQUFNLEVBQUUsa0NBQXFCO0FBQS9CLEtBQXZCOztBQUNBLFFBQUksT0FBSixFQUFhO0FBQ1gsTUFBQSxjQUFjLENBQUMsSUFBZixHQUFzQixPQUF0QjtBQUNEOztBQUNELFdBQU8sS0FBSyxlQUFMLENBQXFCO0FBQUUsTUFBQTtBQUFGLEtBQXJCLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsY0FBYyxDQUFDLE1BQUQsRUFBUztBQUNyQjtBQUNBLFFBQUksTUFBTSxDQUFDLFFBQVgsRUFBcUI7QUFDbkIsTUFBQSxNQUFNLENBQUMsUUFBUCxHQUFrQix3Q0FBNkIsTUFBTSxDQUFDLFFBQXBDLEVBQThDLEtBQTlDLENBQWxCO0FBQ0Q7O0FBRUQsU0FBSyxJQUFMLENBQVcsR0FBRSxNQUFNLENBQUMsRUFBRyxTQUF2QixFQUFpQyxNQUFNO0FBQ3JDLFdBQUssa0JBQUwsQ0FBeUIsR0FBRSxNQUFNLENBQUMsRUFBRyxXQUFyQztBQUNELEtBRkQ7QUFHQSxTQUFLLElBQUwsQ0FBVyxHQUFFLE1BQU0sQ0FBQyxFQUFHLFdBQXZCLEVBQW1DLE1BQU07QUFDdkMsV0FBSyxrQkFBTCxDQUF5QixHQUFFLE1BQU0sQ0FBQyxFQUFHLFNBQXJDO0FBQ0QsS0FGRCxFQVRxQixDQVlyQjs7QUFDQSxJQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEVBQWpCLENBYnFCLENBY3JCOztBQUNBLFVBQU0sUUFBUSxHQUFHLCtDQUFtQixNQUFuQixDQUFqQjtBQUNBLElBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxJQUFmLENBQW9CLFFBQXBCO0FBRUEsVUFBTSxZQUFZLEdBQUcsS0FBSyxlQUFMLENBQXFCO0FBQ3hDLE1BQUEsc0JBQXNCLEVBQUU7QUFEZ0IsS0FBckIsQ0FBckI7QUFHQSxVQUFNO0FBQUUsTUFBQTtBQUFGLFFBQXFCLElBQTNCLENBckJxQixDQXVCckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFNLGVBQWUsR0FBRyxJQUFJLEdBQUosRUFBeEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxZQUFZLENBQzdCLE9BRGlCLEdBRWpCLE1BRmlCLENBRVQsRUFBRCxJQUFRO0FBQ2QsWUFBTTtBQUFFLFFBQUEsS0FBRjtBQUFTLFFBQUE7QUFBVCxVQUFrQixFQUFFLENBQUMsUUFBM0I7QUFDQSxZQUFNO0FBQUUsUUFBQSxPQUFGO0FBQVcsUUFBQSxpQkFBWDtBQUE4QixRQUFBO0FBQTlCLFVBQXlDLEVBQS9DO0FBQ0EsWUFBTSxHQUFHLEdBQUksR0FBRSxLQUFNLElBQUcsT0FBWixhQUFZLE9BQVosY0FBWSxPQUFaLEdBQXVCLGlCQUFrQixJQUFHLElBQUssRUFBN0Q7O0FBQ0EsVUFBSSxlQUFlLENBQUMsR0FBaEIsQ0FBb0IsR0FBcEIsQ0FBSixFQUE4QjtBQUM1QixlQUFPLEtBQVA7QUFDRCxPQUZELE1BRU8sSUFDTCxlQUFlLENBQUMsSUFBaEIsR0FBdUIsY0FBYyxHQUFHLENBQXhDLElBQ0EsNEJBQWlCLFFBQWpCLENBQTBCLE1BQTFCLE1BQXNDLEtBRmpDLEVBR0w7QUFDQSxRQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixHQUFwQjtBQUNBLGVBQU8sS0FBUDtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNELEtBaEJpQixFQWlCakIsR0FqQmlCLENBaUJaLEVBQUQsSUFBUSxFQUFFLENBQUMsRUFqQkUsQ0FBcEI7O0FBbUJBLFNBQUssbUJBQUwsQ0FBeUIsV0FBekI7O0FBQ0EsU0FBSyx1QkFBTCxDQUE2QixDQUFDLE1BQUQsQ0FBN0I7O0FBQ0EsV0FBTyxNQUFQO0FBQ0Q7O0FBRUQsRUFBQSxzQkFBc0IsQ0FBQyxNQUFELEVBQVM7QUFBQTs7QUFDN0IsVUFBTSxXQUFXLEdBQUcsTUFBSCxhQUFHLE1BQUgsMkNBQUcsTUFBTSxDQUFFLFFBQVgscURBQUcsaUJBQWtCLElBQXRDO0FBQ0EsVUFBTSxxQkFBcUIsR0FBRyxLQUFLLHdCQUFMLENBQThCLFdBQTlCLENBQTlCO0FBQ0EsVUFBTSxtQkFBbUIsR0FBRyxLQUFLLHNCQUFMLENBQTRCLFdBQTVCLENBQTVCO0FBQ0Esb0RBQXFDO0FBQ25DLE1BQUEsTUFEbUM7QUFFbkMsTUFBQSxtQkFGbUM7QUFHbkMsTUFBQTtBQUhtQyxLQUFyQzs7QUFLQSxTQUFLLHVCQUFMLENBQTZCLENBQUMsTUFBRCxDQUE3Qjs7QUFDQSxXQUFPLE1BQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsY0FBYyxDQUFDLElBQUQsRUFBTztBQUNuQixVQUFNO0FBQUUsTUFBQTtBQUFGLFFBQW1CLEtBQUssS0FBTCxDQUFXLFFBQVgsRUFBekI7QUFDQSxXQUFPLFlBQVksQ0FBQyxJQUFELENBQW5CO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsaUJBQWlCLENBQUMsTUFBRCxFQUFTLElBQVQsRUFBZTtBQUM5QjtBQUNBLFFBQUksTUFBTSxDQUFDLFFBQVgsRUFBcUI7QUFDbkIsTUFBQSxNQUFNLENBQUMsUUFBUCxHQUFrQix3Q0FBNkIsTUFBTSxDQUFDLFFBQXBDLEVBQThDLEtBQTlDLENBQWxCO0FBQ0QsS0FKNkIsQ0FNOUI7OztBQUNBLFVBQU0sWUFBWSxHQUFHLCtDQUFtQixNQUFuQixDQUFyQixDQVA4QixDQVE5Qjs7QUFDQSxVQUFNLGFBQWEsR0FBRywwQ0FBYyxNQUFNLENBQUMsT0FBckIsQ0FBdEIsQ0FUOEIsQ0FVOUI7O0FBQ0EsVUFBTSxLQUFLLEdBQUcsaURBQXFCLGFBQXJCLEVBQW9DLFlBQXBDLEVBQWtELElBQWxELENBQWQ7O0FBQ0EsUUFBSSxLQUFLLENBQUMsTUFBVixFQUFrQjtBQUNoQixNQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsSUFBZixDQUFvQixLQUFwQjtBQUNELEtBZDZCLENBZ0I5Qjs7O0FBQ0EsVUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQXBCO0FBQ0EsU0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QjtBQUNyQixNQUFBLFlBQVksa0NBQ1AsS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixZQURmO0FBRVYsU0FBQyxJQUFELEdBQVE7QUFGRTtBQURTLEtBQXZCO0FBTUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsZUFBZSxDQUFDO0FBQ2QsSUFBQSxjQUFjLEdBQUcsRUFESDtBQUVkLElBQUEsV0FGYztBQUdkLElBQUEsc0JBQXNCLEdBQUcsSUFIWDtBQUlkLElBQUE7QUFKYyxNQUtaLEVBTFcsRUFLUDtBQUNOLFVBQU0sT0FBTyxHQUFHLEtBQUssaUJBQUwsRUFBaEI7QUFDQSxVQUFNLE9BQU8sR0FBRyxLQUFLLFVBQUwsRUFBaEIsQ0FGTSxDQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFNLGdCQUFnQixHQUFHLHVCQUFVLGNBQVYsRUFBMkIsU0FBRCxJQUFlO0FBQ2hFLGFBQU8sT0FBTyxTQUFQLEtBQXFCLFVBQXJCLEdBQ0gsU0FERyxHQUVGLENBQUQsSUFBTyxDQUFDLEtBQUssU0FGakI7QUFHRCxLQUp3QixDQUF6QixDQVRNLENBZU47QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTSxvQkFBb0IsR0FBRyxXQUFXLEdBQ3BDLG1CQUFNLFdBQU4sRUFBbUIsSUFBbkIsQ0FEb0MsR0FFcEMsS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixZQUYxQixDQW5CTSxDQXVCTjtBQUNBOztBQUNBLFVBQU0sb0JBQW9CLEdBQUcsb0JBQzNCLG9CQUFPLG9CQUFQLEVBQThCLFdBQUQsSUFBaUI7QUFDNUM7QUFDQTtBQUNBLFVBQ0Usc0JBQXNCLElBQ3RCLDZDQUEwQixXQUExQixFQUF1QyxPQUF2QyxFQUFnRCxPQUFoRCxNQUE2RCxLQUYvRCxFQUdFO0FBQ0EsZUFBTyxLQUFQO0FBQ0QsT0FSMkMsQ0FTNUM7QUFDQTs7O0FBQ0EsV0FBSyxNQUFNLENBQUMsR0FBRCxFQUFNLFNBQU4sQ0FBWCxJQUErQixNQUFNLENBQUMsT0FBUCxDQUFlLGdCQUFmLENBQS9CLEVBQWlFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJLEdBQUcsSUFBSSxXQUFXLENBQUMsUUFBdkIsRUFBaUM7QUFDL0IsY0FBSSxTQUFTLENBQUMsV0FBVyxDQUFDLFFBQVosQ0FBcUIsR0FBckIsQ0FBRCxDQUFULEtBQXlDLEtBQTdDLEVBQW9EO0FBQ2xELG1CQUFPLEtBQVA7QUFDRDtBQUNGLFNBSkQsTUFJTyxJQUFJLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRCxDQUFaLENBQVQsS0FBZ0MsS0FBcEMsRUFBMkM7QUFDaEQsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0EzQkQsQ0FEMkIsRUE2QjNCLE1BN0IyQixDQUE3Qjs7QUErQkEsUUFBSSxLQUFLLEtBQUssU0FBZCxFQUF5QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQU0sTUFBTSxHQUFHLElBQUksR0FBSixFQUFmO0FBQ0EsWUFBTSxHQUFHLEdBQUcsRUFBWixDQU51QixDQU92QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFdBQUssSUFBSSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsTUFBckIsR0FBOEIsQ0FBM0MsRUFBOEMsQ0FBQyxHQUFHLENBQUMsQ0FBbkQsRUFBc0QsQ0FBQyxFQUF2RCxFQUEyRDtBQUN6RCxjQUFNLE1BQU0sR0FBRyxvQkFBb0IsQ0FBQyxDQUFELENBQW5DO0FBQ0EsY0FBTTtBQUFFLFVBQUE7QUFBRixZQUFZLE1BQU0sQ0FBQyxRQUF6Qjs7QUFDQSxZQUFJLENBQUMsTUFBTSxDQUFDLEdBQVAsQ0FBVyxLQUFYLENBQUwsRUFBd0I7QUFDdEIsY0FBSSxNQUFNLENBQUMsSUFBUCxHQUFjLEtBQWxCLEVBQXlCO0FBQ3ZCLFlBQUEsTUFBTSxDQUFDLEdBQVAsQ0FBVyxLQUFYO0FBQ0QsV0FGRCxNQUVPO0FBQ0w7QUFDRDtBQUNGLFNBVHdELENBVXpEO0FBQ0E7OztBQUNBLFFBQUEsR0FBRyxDQUFDLE9BQUosQ0FBWSxNQUFaO0FBQ0Q7O0FBQ0QsYUFBTyxHQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxvQkFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsbUJBQW1CLENBQUMsSUFBRCxFQUFPO0FBQ3hCLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLFFBQXREOztBQUNBLFNBQUssa0JBQUwsQ0FBd0IsSUFBeEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEscUJBQXFCLENBQUMsSUFBRCxFQUFPO0FBQzFCLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLFVBQXREO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLG1CQUFtQixDQUFDLElBQUQsRUFBTztBQUN4QixTQUFLLHFCQUFMLENBQTJCLElBQTNCLEVBQWlDLGtDQUFxQixRQUF0RDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU87QUFDdEIsU0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxrQ0FBcUIsTUFBdEQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxvQkFBb0IsQ0FBQyxJQUFELEVBQU87QUFDekIsVUFBTSxNQUFNLEdBQUcsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQWY7QUFDQSxJQUFBLE1BQU0sQ0FBQyxhQUFQLEdBQXVCLElBQUksSUFBSixHQUFXLE9BQVgsRUFBdkI7QUFDQSxTQUFLLGlCQUFMLENBQXVCLE1BQXZCLEVBQStCLDJDQUEvQjs7QUFDQSxTQUFLLHFCQUFMLENBQTJCLElBQTNCLEVBQWlDLGtDQUFxQixTQUF0RDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxvQkFBb0IsQ0FBQyxJQUFELEVBQU87QUFDekIsU0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxrQ0FBcUIsU0FBdEQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsa0JBQWtCLENBQUMsSUFBRCxFQUFPO0FBQ3ZCLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLE9BQXREO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxpQkFBaUIsQ0FBQyxJQUFELEVBQU8sR0FBUCxFQUFZO0FBQUE7O0FBQzNCLFVBQU0sS0FBSyxHQUFHLEdBQUcsSUFBSSxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFyQjtBQUVBLFVBQU0sTUFBTSxHQUFHLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUFmO0FBQ0EsSUFBQSxNQUFNLENBQUMsR0FBUCxHQUFhO0FBQ1gsTUFBQSxPQUFPLEVBQUUsbUJBQUEsS0FBSyxDQUFDLE9BQU4sa0VBQWUsUUFBZixPQUE2QixLQUFLLENBQUMsUUFBTixFQUQzQjtBQUVYLE1BQUEsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUZBO0FBR1gsTUFBQSxLQUFLLEVBQUUsS0FBSyxDQUFDO0FBSEYsS0FBYjtBQUtBLFNBQUssaUJBQUwsQ0FDRSxNQURGLEVBRUUsZ0RBRkY7O0FBSUEsU0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxrQ0FBcUIsTUFBdEQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGdCQUFnQixDQUFDLE9BQUQsRUFBVTtBQUN4QjtBQUNBLFVBQU07QUFBRSxNQUFBO0FBQUYsUUFBbUIsS0FBSyxLQUFMLENBQVcsUUFBWCxFQUF6QjtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssVUFBTCxFQUFoQjtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssaUJBQUwsRUFBaEIsQ0FKd0IsQ0FNeEI7O0FBQ0EsU0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QjtBQUNyQixNQUFBLFlBQVksRUFBRSxvQkFDWixZQURZLEVBRVgsV0FBRCxJQUNFLFdBQVcsQ0FBQyxRQUFaLENBQXFCLElBQXJCLEtBQThCLE9BQTlCLElBQ0EsNkNBQTBCLFdBQTFCLEVBQXVDLE9BQXZDLEVBQWdELE9BQWhELENBSlU7QUFETyxLQUF2QjtBQVFEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRSxFQUFBLGtCQUFrQixHQUFHO0FBQ25CLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFDckIsTUFBQSxZQUFZLEVBQUUsb0JBQ1osS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixZQURWLEVBRVgsV0FBRCxJQUFpQixXQUFXLENBQUMsTUFBWixLQUF1QixrQ0FBcUIsVUFGakQ7QUFETyxLQUF2QjtBQU1ELEdBemhCK0QsQ0EyaEJoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEscUJBQXFCLENBQUMsSUFBRCxFQUFPLE1BQVAsRUFBZTtBQUNsQyxVQUFNLE1BQU0sR0FBRyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBZjs7QUFFQSxRQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1g7QUFDRDs7QUFFRCxJQUFBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQWhCOztBQUNBLFFBQUk7QUFDRixXQUFLLGlCQUFMLENBQ0UsTUFERixFQUVHLHFDQUFvQyxNQUFPLEVBRjlDO0FBSUEsV0FBSyxJQUFMLENBQVcsR0FBRSxNQUFNLENBQUMsRUFBRyxJQUFHLE1BQU8sRUFBakMsRUFBb0MsSUFBcEM7QUFDQSxXQUFLLElBQUwsQ0FBVyxrQkFBWCxFQUE4QixJQUE5QixFQUFvQyxNQUFwQzs7QUFDQSxVQUNFLENBQ0Usa0NBQXFCLFNBRHZCLEVBRUUsa0NBQXFCLFFBRnZCLEVBR0Usa0NBQXFCLE1BSHZCLEVBSUUsUUFKRixDQUlXLE1BSlgsQ0FERixFQU1FO0FBQ0EsYUFBSyxJQUFMLENBQVcsR0FBRSxNQUFNLENBQUMsRUFBRyxXQUF2QixFQUFtQyxNQUFuQztBQUNEOztBQUNELFdBQUssSUFBTCxDQUFVLCtDQUEyQixZQUFyQztBQUNELEtBakJELENBaUJFLE9BQU8sS0FBUCxFQUFjO0FBQ2Qsd0JBQUksS0FBSixDQUFVLEtBQVY7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsdUJBQXVCLENBQUMsWUFBRCxFQUFlO0FBQ3BDLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFDckIsTUFBQSxZQUFZLEVBQUUsWUFBWSxDQUFDLE1BQWIsQ0FBb0IsQ0FBQyxNQUFELEVBQVMsS0FBVCxLQUFtQjtBQUNuRCxRQUFBLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBUCxDQUFOLEdBQW1CLEtBQW5CO0FBQ0EsZUFBTyxNQUFQO0FBQ0QsT0FIYSxFQUdYLEtBQUssS0FBTCxDQUFXLFFBQVgsR0FBc0IsWUFIWDtBQURPLEtBQXZCO0FBTUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsa0JBQWtCLENBQUMsbUJBQUQsRUFBc0I7QUFDdEMsVUFBTTtBQUFFLE1BQUE7QUFBRixRQUFtQixLQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXpCO0FBQ0EsV0FBTyxZQUFZLENBQUMsbUJBQUQsQ0FBbkI7QUFDQSxTQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLE1BQUE7QUFEcUIsS0FBdkI7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxtQkFBbUIsQ0FBQyxvQkFBRCxFQUF1QjtBQUN4QyxVQUFNO0FBQUUsTUFBQTtBQUFGLFFBQW1CLEtBQUssS0FBTCxDQUFXLFFBQVgsRUFBekI7QUFDQSxJQUFBLG9CQUFvQixDQUFDLE9BQXJCLENBQThCLGFBQUQsSUFBbUI7QUFDOUMsYUFBTyxZQUFZLENBQUMsYUFBRCxDQUFuQjtBQUNELEtBRkQ7QUFHQSxTQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLE1BQUE7QUFEcUIsS0FBdkI7QUFHRDs7QUF4b0IrRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RGxFOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVlLE1BQU0sU0FBTixDQUFnQjtBQUM3QixFQUFBLFdBQVcsQ0FBQyxRQUFELEVBQVc7QUFDcEIsU0FBSyxLQUFMLEdBQWEsSUFBSSxtQkFBSixDQUFhLFFBQWIsQ0FBYjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUN1QixRQUFmLGVBQWUsQ0FBQyxNQUFELEVBQVM7QUFDNUIsVUFBTSxLQUFLLEdBQUcsTUFBTSxLQUFLLEtBQUwsQ0FBVyxnQkFBWCxDQUE0QixRQUE1QixFQUFzQyxLQUF0QyxDQUFwQixDQUQ0QixDQUc1Qjs7QUFDQSxVQUFNLGVBQWUsR0FBRyxtQkFBUSxLQUFLLENBQUMsUUFBZCxDQUF4QjtBQUNBLFVBQU0sZUFBZSxHQUFHLGdDQUFxQixlQUFyQixFQUFzQyxFQUF0QyxFQUEwQyxFQUExQyxDQUF4QjtBQUNBLFFBQUksZUFBZSxHQUFHLG1CQUFRLGVBQVIsQ0FBdEI7QUFDQSxRQUFJLGVBQUo7O0FBQ0EsUUFBSTtBQUNGLE1BQUEsZUFBZSxHQUFHLE1BQU0sS0FBSyxhQUFMLENBQW1CLE1BQW5CLENBQXhCO0FBQ0QsS0FGRCxDQUVFLE9BQU8sS0FBUCxFQUFjO0FBQ2Qsd0JBQUksSUFBSixDQUFTLEtBQVQ7O0FBQ0EsTUFBQSxlQUFlLEdBQUc7QUFDaEIsUUFBQSxNQUFNLEVBQUUsS0FBSyxDQUFDLE9BREU7QUFFaEIsUUFBQSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBRkE7QUFHaEIsUUFBQSxLQUFLLEVBQUU7QUFBRSxVQUFBLFdBQVcsRUFBRSxLQUFLLENBQUMsTUFBckI7QUFBNkIsVUFBQSxhQUFhLEVBQUUsS0FBSyxDQUFDO0FBQWxEO0FBSFMsT0FBbEI7QUFLRDs7QUFFRCxXQUFPO0FBQUUsTUFBQSxhQUFhLEVBQUUsS0FBSyxDQUFDLFFBQXZCO0FBQWlDLE1BQUEsZUFBakM7QUFBa0QsTUFBQTtBQUFsRCxLQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNxQixRQUFiLGFBQWEsQ0FBQyxNQUFELEVBQVM7QUFDMUIsVUFBTSxRQUFRLEdBQUcsdUJBQVUsTUFBTSxDQUFDLFFBQWpCLENBQWpCLENBRDBCLENBRzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsV0FBTyxRQUFRLENBQUMsUUFBaEI7QUFDQSxXQUFPLFFBQVEsQ0FBQyxZQUFoQjtBQUNBLFdBQU8sUUFBUSxDQUFDLG9CQUFoQixDQVYwQixDQVkxQjs7QUFDQSxXQUFPLE1BQU0sS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixRQUF2QixDQUFiO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLFlBQVksQ0FBQyxrQkFBRCxFQUFxQixnQkFBckIsRUFBdUMsVUFBVSxHQUFHLEdBQXBELEVBQXlEO0FBQ25FLFVBQU0saUJBQWlCLEdBQUcsbUJBQVEsa0JBQVIsQ0FBMUI7QUFDQSxVQUFNLGVBQWUsR0FBRyxtQkFBUSxnQkFBUixDQUF4QjtBQUNBLFVBQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxJQUFoQixDQUFxQixHQUFyQixDQUF4QjtBQUNBLFVBQU0sa0JBQWtCLEdBQUcsaUJBQWlCLENBQUMsSUFBbEIsQ0FBdUIsVUFBdkIsQ0FBM0IsQ0FKbUUsQ0FNbkU7O0FBQ0EsUUFBSSxpQkFBaUIsQ0FBQyxFQUFsQixDQUFxQixlQUFyQixDQUFKLEVBQTJDO0FBQ3pDLGFBQU8sbUJBQVEsaUJBQVIsQ0FBUDtBQUNELEtBVGtFLENBVW5FOzs7QUFDQSxRQUFJLGtCQUFrQixDQUFDLEVBQW5CLENBQXNCLGVBQXRCLENBQUosRUFBNEM7QUFDMUMsYUFBTyxtQkFBUSxrQkFBUixDQUFQO0FBQ0QsS0Fia0UsQ0FjbkU7OztBQUNBLFdBQU8sbUJBQVEsZUFBUixDQUFQO0FBQ0Q7O0FBRXdCLFFBQW5CLG1CQUFtQixDQUFDLE1BQUQsRUFBUyxVQUFULEVBQXFCO0FBQzVDLFVBQU07QUFDSixNQUFBLGFBREk7QUFFSixNQUFBLGVBRkk7QUFHSixNQUFBO0FBSEksUUFJRixNQUFNLEtBQUssZUFBTCxDQUFxQixNQUFyQixDQUpWLENBRDRDLENBTzVDOztBQUNBLFVBQU0sUUFBUSxHQUFHLEtBQUssWUFBTCxDQUNmLGtDQUFhLGVBQWIsQ0FEZSxFQUVmLGFBRmUsRUFHZixVQUhlLENBQWpCO0FBS0EsV0FBTztBQUFFLE1BQUEsUUFBRjtBQUFZLE1BQUE7QUFBWixLQUFQO0FBQ0Q7O0FBN0Y0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCL0I7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsTUFBTSx5QkFBTixTQUF3Qyx5QkFBeEMsQ0FBcUQ7QUFDbEU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxFQUFBLFdBQVcsQ0FBQyxNQUFELEVBQVM7QUFDbEI7QUFEa0IsZ0VBckJHLENBcUJIO0FBQUEscUVBYlEsSUFBSSxHQUFKLEVBYVI7QUFFbEIsU0FBSyxLQUFMLEdBQWEsTUFBTSxDQUFDLEtBQVAsSUFBZ0IsSUFBSSxtQkFBSixDQUFhLE1BQU0sQ0FBQyxRQUFwQixDQUE3QjtBQUNBLFNBQUssWUFBTCxHQUFvQixNQUFNLENBQUMsWUFBM0I7QUFDQSxTQUFLLHNCQUFMLEdBQThCLE1BQU0sQ0FBQyxzQkFBckM7QUFDQSxTQUFLLHdCQUFMLEdBQWdDLE1BQU0sQ0FBQyx3QkFBdkM7QUFDQSxTQUFLLGtCQUFMLEdBQTBCLE1BQU0sQ0FBQyxrQkFBakM7QUFDQSxTQUFLLGtCQUFMLEdBQTBCLE1BQU0sQ0FBQyxrQkFBakM7QUFDQSxTQUFLLGtCQUFMLEdBQTBCLE1BQU0sQ0FBQyxrQkFBakM7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ3dCLFFBQWhCLGdCQUFnQixHQUFHO0FBQ3ZCO0FBQ0EsVUFBTSxlQUFlLEdBQUcsTUFBTSxLQUFLLFlBQUwsQ0FBa0IsYUFBbEIsRUFBOUI7O0FBQ0EsUUFBSTtBQUNGLFlBQU0sVUFBVSxHQUFHLEtBQUssc0JBQUwsRUFBbkI7QUFDQSxZQUFNLE9BQU8sQ0FBQyxHQUFSLENBQ0osVUFBVSxDQUFDLEdBQVgsQ0FBZ0IsTUFBRCxJQUFZLEtBQUssZUFBTCxDQUFxQixNQUFyQixDQUEzQixDQURJLENBQU47QUFHRCxLQUxELENBS0UsT0FBTyxHQUFQLEVBQVk7QUFDWix3QkFBSSxLQUFKLENBQ0UsaUVBREY7O0FBR0Esd0JBQUksS0FBSixDQUFVLEdBQVY7QUFDRDs7QUFDRCxJQUFBLGVBQWUsQ0FBQyxXQUFoQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUMwQixRQUFsQixrQkFBa0IsQ0FBQyxXQUFELEVBQWM7QUFDcEMsVUFBTSxPQUFPLEdBQUcsS0FBSyxzQkFBTCxFQUFoQjs7QUFDQSxRQUFJLENBQUMsT0FBTyxDQUFDLE1BQWIsRUFBcUI7QUFDbkI7QUFDRDs7QUFDRCxTQUFLLE1BQU0sTUFBWCxJQUFxQixPQUFyQixFQUE4QjtBQUM1QixVQUFJO0FBQ0YsY0FBTSxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsV0FBekIsQ0FBTjtBQUNELE9BRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUFBOztBQUNaLGNBQU0sWUFBWSxHQUNoQixlQUFBLEdBQUcsQ0FBQyxLQUFKLGdGQUFXLE9BQVgsMEVBQW9CLFdBQXBCLE9BQXFDLEdBQUcsQ0FBQyxPQUFKLENBQVksV0FBWixFQUR2QztBQUVBLGNBQU0sU0FBUyxHQUNiO0FBQ0EsUUFBQSxZQUFZLENBQUMsUUFBYixDQUFzQixxQ0FBdEIsS0FDQSxZQUFZLENBQUMsUUFBYixDQUFzQixtQkFBdEIsQ0FEQSxJQUVBO0FBQ0EsUUFBQSxZQUFZLENBQUMsUUFBYixDQUFzQiw4QkFBdEIsQ0FIQSxJQUlBLFlBQVksQ0FBQyxRQUFiLENBQ0UscURBREYsQ0FKQSxJQU9BO0FBQ0EsUUFBQSxZQUFZLENBQUMsUUFBYixDQUFzQixpQkFBdEIsQ0FSQSxJQVNBLFlBQVksQ0FBQyxRQUFiLENBQXNCLGVBQXRCLENBWEYsQ0FIWSxDQWVaOztBQUNBLFlBQUksU0FBSixFQUFlO0FBQ2I7QUFDRCxTQWxCVyxDQW1CWjs7O0FBQ0EsUUFBQSxNQUFNLENBQUMsT0FBUCxHQUFpQjtBQUNmLFVBQUEsS0FBSyxFQUFFLFlBRFE7QUFFZixVQUFBLE9BQU8sRUFBRTtBQUZNLFNBQWpCO0FBSUEsYUFBSyxJQUFMLENBQVUsWUFBVixFQUF3QixNQUF4QixFQUFnQyxHQUFoQztBQUNEO0FBQ0Y7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ21CLFFBQVgsV0FBVyxDQUFDLE1BQUQsRUFBUyxpQkFBVCxFQUE0QjtBQUMzQyxRQUFJLENBQUMsTUFBTSxDQUFDLHFCQUFaLEVBQW1DO0FBQ2pDLFdBQUssSUFBTCxDQUFVLGlCQUFWLEVBQTZCLE1BQTdCLEVBQXFDLGlCQUFyQztBQUNEOztBQUVELFVBQU0scUJBQXFCLEdBQ3pCLE1BQU0sQ0FBQyxxQkFBUCxJQUFnQyxpQkFEbEM7QUFFQSxVQUFNLGVBQWUsR0FDbkIsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsaUJBQWhCLEVBQW1DLEVBQW5DLElBQ0EsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IscUJBQWhCLEVBQXVDLEVBQXZDLENBRkY7QUFJQSxVQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBUCxJQUFxQixDQUF4QyxDQVgyQyxDQWEzQzs7QUFDQSxRQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLEVBQVQsRUFBYSxJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxVQUFaLENBQWIsQ0FBdEIsRUFBNkQ7QUFDM0QsYUFBTyxTQUFQO0FBQ0QsS0FoQjBDLENBa0IzQzs7O0FBQ0EsUUFBSSxFQUFFLFdBQVcsTUFBYixDQUFKLEVBQTBCO0FBQ3hCLGFBQU8sS0FBSyxrQkFBTCxDQUF3QixNQUFNLENBQUMsRUFBL0IsQ0FBUDtBQUNEOztBQUVELFVBQU07QUFBRSxNQUFBO0FBQUYsUUFBWSxNQUFsQjtBQUNBLFVBQU0sTUFBTSxHQUFHLE1BQU0sS0FBSyxrQkFBTCxDQUF3QixLQUF4QixDQUFyQixDQXhCMkMsQ0EwQjNDOztBQUNBLFNBQUssSUFBTCxDQUFVLFVBQVYsRUFBc0IsTUFBdEI7QUFDQSxXQUFPLE1BQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUV1QixRQUFmLGVBQWUsQ0FBQyxNQUFELEVBQVM7QUFDNUIsVUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQXRCO0FBQ0EsVUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQXBCLENBRjRCLENBSTVCOztBQUNBLFFBQUksTUFBTSxDQUFDLE1BQVAsS0FBa0Isa0NBQXFCLFNBQTNDLEVBQXNEO0FBQ3BEO0FBQ0QsS0FQMkIsQ0FTNUI7QUFDQTs7O0FBQ0EsUUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLFlBQU0sV0FBVyxHQUFHLElBQUksS0FBSixDQUNsQixzRUFEa0IsQ0FBcEI7QUFHQSxNQUFBLFdBQVcsQ0FBQyxJQUFaLEdBQW1CLGVBQW5CO0FBQ0EsV0FBSyxJQUFMLENBQVUsV0FBVixFQUF1QixJQUF2QixFQUE2QixXQUE3QjtBQUVBO0FBQ0Q7O0FBRUQsUUFBSSxNQUFNLEtBQUssb0JBQUwsQ0FBMEIsTUFBMUIsQ0FBVixFQUE2QztBQUMzQyxXQUFLLElBQUwsQ0FBVSxZQUFWLEVBQXdCLElBQXhCO0FBQ0E7QUFDRDs7QUFFRCxRQUFJO0FBQ0YsWUFBTSxrQkFBa0IsR0FBRyxNQUFNLEtBQUssS0FBTCxDQUFXLHFCQUFYLENBQWlDLE1BQWpDLENBQWpDOztBQUNBLFVBQUksa0JBQUosYUFBSSxrQkFBSixlQUFJLGtCQUFrQixDQUFFLFdBQXhCLEVBQXFDO0FBQ25DLGNBQU07QUFDSixVQUFBLGFBREk7QUFFSixVQUFBLFNBQVMsRUFBRTtBQUZQLFlBR0YsTUFBTSxLQUFLLEtBQUwsQ0FBVyxjQUFYLENBQ1Isa0JBRFEsYUFDUixrQkFEUSx1QkFDUixrQkFBa0IsQ0FBRSxTQURaLEVBRVIsS0FGUSxDQUhWO0FBUUEsYUFBSyxJQUFMLENBQ0UsY0FERixFQUVFLElBRkYsRUFHRSxrQkFIRixFQUlFLGFBSkYsRUFLRSxjQUxGO0FBT0E7QUFDRDtBQUNGLEtBcEJELENBb0JFLE9BQU8sR0FBUCxFQUFZO0FBQ1osTUFBQSxNQUFNLENBQUMsT0FBUCxHQUFpQjtBQUNmLFFBQUEsS0FBSyxFQUFFLEdBQUcsQ0FBQyxPQURJO0FBRWYsUUFBQSxPQUFPLEVBQUU7QUFGTSxPQUFqQjtBQUlBLFdBQUssSUFBTCxDQUFVLFlBQVYsRUFBd0IsTUFBeEIsRUFBZ0MsR0FBaEM7QUFDQTtBQUNEOztBQUVELFFBQUksTUFBTSxLQUFLLG9CQUFMLENBQTBCLE1BQTFCLENBQVYsRUFBNkM7QUFDM0MsV0FBSyxJQUFMLENBQVUsWUFBVixFQUF3QixJQUF4QjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQzRCLFFBQXBCLG9CQUFvQixDQUFDLE1BQUQsRUFBUztBQUNqQyxVQUFNO0FBQ0osTUFBQSxJQUFJLEVBQUUsTUFERjtBQUVKLE1BQUEsUUFBUSxFQUFFO0FBQUUsUUFBQSxLQUFGO0FBQVMsUUFBQTtBQUFUO0FBRk4sUUFHRixNQUhKO0FBSUEsVUFBTSxnQkFBZ0IsR0FBRyxNQUFNLEtBQUssS0FBTCxDQUFXLG1CQUFYLENBQStCLElBQS9CLENBQS9COztBQUVBLFFBQUksUUFBUSxDQUFDLEtBQUQsRUFBUSxFQUFSLENBQVIsSUFBdUIsZ0JBQWdCLENBQUMsUUFBakIsRUFBM0IsRUFBd0Q7QUFDdEQsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDLEtBQUsseUJBQUwsQ0FBK0IsR0FBL0IsQ0FBbUMsTUFBbkMsQ0FBTCxFQUFpRDtBQUMvQyxXQUFLLHlCQUFMLENBQStCLEdBQS9CLENBQW1DLE1BQW5DLEVBQTJDLENBQTNDO0FBQ0Q7O0FBRUQsVUFBTSxrQkFBa0IsR0FBRyxLQUFLLHlCQUFMLENBQStCLEdBQS9CLENBQW1DLE1BQW5DLENBQTNCOztBQUVBLFFBQUksa0JBQWtCLEdBQUcsS0FBSyxvQkFBOUIsRUFBb0Q7QUFDbEQsV0FBSyx5QkFBTCxDQUErQixHQUEvQixDQUFtQyxNQUFuQyxFQUEyQyxrQkFBa0IsR0FBRyxDQUFoRTtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUVELFNBQUsseUJBQUwsQ0FBK0IsTUFBL0IsQ0FBc0MsTUFBdEM7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDNEIsUUFBcEIsb0JBQW9CLENBQUMsTUFBRCxFQUFTO0FBQ2pDLFVBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBQWhDO0FBQ0EsVUFBTSxTQUFTLEdBQUcsS0FBSyx3QkFBTCxDQUE4QixPQUE5QixDQUFsQjtBQUNBLFdBQU8sU0FBUyxDQUFDLElBQVYsRUFDTDtBQUNBO0FBQ0E7QUFDQyxJQUFBLEtBQUQsSUFDRSxFQUFFLEtBQUssQ0FBQyxFQUFOLEtBQWEsTUFBTSxDQUFDLEVBQXRCLEtBQ0EsS0FBSyxDQUFDLFFBQU4sQ0FBZSxLQUFmLEtBQXlCLE1BQU0sQ0FBQyxRQUFQLENBQWdCLEtBTnRDLENBQVA7QUFRRDs7QUE5UWlFOzs7Ozs7Ozs7Ozs7Ozs7QUNYcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JUQSxJQUFBLFVBQUEsT0FBQSxDQUFBLFFBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsVUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsaUJBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHdCQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLFVBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxxQkFBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBOztBQUlBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsV0FBQSxPQUFBLENBQUEsc0NBQUEsQ0FBQSxDQUFBOztBQVVBLElBQUEsUUFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxPQUFBLENBQUEsMENBQUEsQ0FBQSxDQUFBOztBQUlBLElBQUEsb0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsK0NBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSw0QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw0QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHNCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7Ozs7OztBQUVBLE1BQU0sTUFBTSxPQUFPLElBQVAsYUFBWixDQUFBO0FBQ0EsTUFBTSxtQkFBbUIsQ0FBQSxDQUFBLEVBQUEsaUJBQUEsUUFBQSxFQUFvQixLQUFBLE9BQUEsR0FBUyxFQUE3QixDQUF6QixDQUFBO0FBRUEsSUFBSSx5QkFBSixDQUFBOztBQUNBLElBQUksT0FBTyxJQUFQLFFBQUosRUFBeUI7RUFDdkIsNEJBQTRCO0lBQzFCLE1BQU0sUUFBQSxpQkFEb0I7SUFFMUIsUUFBUSx1QkFGa0I7SUFHMUIsU0FBUyxPQUhpQjtJQUkxQixVQUFVLGdCQUFBO0dBSlosQ0FBQTtDQURGLE1BT08sSUFBSSxPQUFPLElBQVAsZUFBQSxJQUE4QixHQUFHLEtBQUssTUFBMUMsRUFBa0Q7RUFDdkQsNEJBQTRCO0lBQUUsTUFBTSxRQUFBLFFBQVI7SUFBaUIsU0FBUyxRQUFBLGlCQUFBO0dBQXRELENBQUE7Q0FESyxNQUVBO0VBQ0wsNEJBQTRCO0lBQUUsTUFBTSxRQUFBLFFBQVI7SUFBaUIsU0FBUyxRQUFBLGlCQUFBO0dBQXRELENBQUE7Q0FDRDs7QUFFRCxNQUFNLHdCQUFxQixhQUFBLENBQUE7RUFDekIsUUFBUSxLQUFBO0NBRGlCLEVBRXRCLHlCQUZzQixDQUEzQixDQUFBOztBQUtBLE1BQU0sNkJBQTZCO0VBQ2pDLE1BQU07SUFBRSxNQUFNLFNBQUE7R0FBUjtDQURSLENBQUE7QUFJTyxNQUFNLGlCQUFpQjs7RUFFNUIsb0JBQW9CLGtCQUZROztFQUk1QixxQkFBcUIsbUJBSk87O0VBTTVCLG1CQUFtQixpQkFOUzs7RUFRNUIscUJBQXFCLG1CQUFBO0NBUmhCLENBQUE7OztBQVdRLGdDQUFnQyxPQUFBLFFBQWhDLENBQTZDO0VBQzFELFdBQVcsQ0FBQyxPQUFPLEVBQVIsRUFBWTtJQUNyQixLQUFBLEVBQUEsQ0FEcUI7O0lBSXJCLElBQUEsY0FBQSxHQUFxQixJQUFJLFNBQUEsZ0JBQUosQ0FDbkIsSUFBSSxTQUFKLElBQUEsYUFBQSxDQUFBLEVBQUEsRUFBc0IscUJBQXRCLENBRG1CLENBQXJCLENBQUE7SUFHQSxJQUFBLHNCQUFBLEdBQTZCLElBQUksU0FBQSxnQkFBSixDQUMzQixJQUFBLGNBQUEsU0FBQSxFQUQyQixDQUE3QixDQUFBO0lBR0EsSUFBQSxhQUFBLEdBQW9CLElBQUksU0FBQSxnQkFBSixDQUFvQixTQUFwQixDQUFwQixDQVZxQjs7Ozs7O0lBZ0JyQixJQUFBLGVBQUEsR0FBc0IsSUFBSSxTQUFBLGdCQUFKLENBQ3BCLElBQUksZUFBSixJQUFBLGFBQUEsQ0FBQSxFQUFBLEVBQ0ssMEJBREwsQ0FEb0IsQ0FBdEIsQ0FBQTtJQUtBLElBQUEsTUFBQSxHQUFhLElBQUksU0FBQSxjQUFKLENBQWtCO01BQzdCLFVBQVUsSUFBQSxjQURtQjtNQUU3Qix1QkFBdUIsSUFBQSxzQkFGTTtNQUc3QixTQUFTLElBQUEsYUFIb0I7TUFJN0IsZ0JBQWdCLElBQUEsZUFBSztLQUpWLENBQWIsQ0FyQnFCOztJQTZCckIsSUFBQSxVQUFBLEdBQWlCLElBQWpCLENBQUE7SUFDQSxJQUFBLGNBQUEsR0FBcUIsSUFBckIsQ0E5QnFCOztJQWlDckIsSUFBQSxlQUFBLEdBQXNCLElBQXRCLENBQUE7SUFDQSxJQUFBLG1CQUFBLEdBQTBCLElBQTFCLENBQUE7SUFFQSxJQUFBLEdBQUEsQ0FBUSxjQUFjLG1CQUF0QixFQUEyQyxJQUFBLGNBQTNDLENBQUEsQ0FBQTtHQUNEOzs7Ozs7Ozs7RUFRRCxrQkFBa0IsWUFBWTtJQUM1QixJQUFJLENBQUMsU0FBRCxJQUFjLE9BQU8sU0FBUCxLQUFxQixRQUF2QyxFQUFpRDtNQUMvQyxNQUFNLElBQUksS0FBSixDQUFVLDJCQUFWLENBQU4sQ0FBQTtLQUNEOztJQUVELElBQUEsaUJBQUEsR0FBd0IsU0FBeEIsQ0FBQTtHQUNEOztFQUVELGtCQUFrQixpQkFBaUI7SUFDakMsSUFBQSxvQkFBQSxHQUEyQixjQUEzQixDQUFBO0lBQ0EsTUFBTTs7OztLQUFBLEdBQTRCLElBQUEsa0JBQUEsRUFBbEMsQ0FBQTs7SUFDQSxJQUFBLG1CQUFBLENBQXdCO01BQUUsSUFBRjtNQUFRLE1BQVI7TUFBZ0IsT0FBQTtLQUF4QyxDQUFBLENBQUE7O0lBQ0EsSUFBQSxjQUFBLEVBQUEsQ0FBQTtHQTFEd0Q7OztFQThEMUQsMEJBQTBCLEdBQUc7SUFDM0IsTUFBTSxXQUFXLElBQUEsZUFBakIsQ0FBQTtJQUNBLE1BQU0sZUFBZSxJQUFBLG1CQUFyQixDQUFBO0lBQ0EsT0FBTztNQUFFLFFBQUY7TUFBWSxZQUFBO0tBQW5CLENBQUE7R0FDRDs7Ozs7Ozs7RUFPRCxjQUFjLEdBQUc7SUFDZixPQUFPLElBQUksT0FBSixDQUFZLHFCQUFxQjtNQUN0QyxNQUFNOztPQUFBLEdBQWUsSUFBQSwyQkFBQSxFQUFyQixDQUFBO01BQ0EsTUFBTSxXQUFXLElBQUksU0FBQSxRQUFKLENBQWEsUUFBYixDQUFqQixDQUFBO01BQ0EsUUFBUSxVQUFSLENBQ0U7UUFBRSxRQUFRLHNCQUFWO1FBQWtDLFFBQVEsQ0FBQyxRQUFELEVBQVcsS0FBWCxDQUFBO09BRDVDLEVBRUUsZ0JBQWdCO1FBQ2QsSUFBSSxHQUFKLEVBQVM7VUFDUCxPQUFPLE1BQU0sQ0FBQyxHQUFELENBQWIsQ0FBQTtTQUNEOztRQUNELE9BQU8sT0FBTyxDQUFDLEtBQUQsQ0FBZCxDQUFBO09BTkosQ0FBQSxDQUFBO0tBSEssQ0FBUCxDQUFBO0dBYUQ7Ozs7Ozs7OztFQVE0Qiw2QkFBQSxHQUFHO0lBQzlCLE1BQU07O0tBQUEsR0FBVyxJQUFBLGVBQUEsU0FBQSxFQUFqQixDQUFBOztJQUNBLElBQUksSUFBSSxDQUFDLElBQUQsQ0FBSixLQUFlLFNBQW5CLEVBQThCO01BQzVCLE9BQU8sSUFBSSxDQUFDLElBQUQsQ0FBWCxDQUFBO0tBQ0Q7O0lBQ0QsTUFBTSxjQUFjLE1BQU0sSUFBQSxlQUFBLEVBQTFCLENBQUE7SUFDQSxNQUFNLGtCQUNKLFdBQVcsSUFBSSxXQUFXLGNBQVgsS0FBOEIsU0FEL0MsQ0FBQTtJQUVBLElBQUEscUJBQUEsQ0FBMEIsSUFBMUIsRUFBZ0MsZUFBaEMsQ0FBQSxDQUFBO0lBQ0EsT0FBTyxlQUFQLENBQUE7R0FDRDs7RUFFRCxhQUFhLEdBQUc7O0lBRWQsSUFBSSxJQUFBLGlCQUFBLEVBQUosRUFBNkI7TUFDM0IsSUFBQSxjQUFBLEVBQUEsQ0FBQTtLQUNEO0dBQ0Y7O0VBRUQsZUFBZSxHQUFHO0lBQ2hCLE9BQU8sSUFBQSxhQUFBLFNBQUEsRUFBUCxDQUFBO0dBQ0Q7O0VBRUQsZUFBZSxVQUFVO0lBQ3ZCLElBQUEsYUFBQSxTQUFBLENBQTJCLE9BQTNCLENBQUEsQ0FBQTtHQUNEOzs7Ozs7Ozs7RUFRRCxvQkFBb0IseUJBQXlCO0lBQzNDLElBQUEsZUFBQSxZQUFBLENBQWdDO01BQzlCLE1BQU07UUFDSixDQUFDLFNBQUQsR0FBYSxXQUFBO09BRFQ7S0FEUixDQUFBLENBQUE7R0FLRDs7Ozs7O0VBS0QsbUJBQW1CLEdBQUc7SUFDcEIsSUFBQSxlQUFBLFNBQUEsQ0FBQSxhQUFBLENBQUEsRUFBQSxFQUFrQywwQkFBbEMsQ0FBQSxDQUFBLENBQUE7R0FDRDs7RUFFRCxnQkFBZ0IsR0FBRztJQUNqQixPQUFPLElBQUEsZ0JBQUEsRUFBQSxLQUEyQixTQUFsQyxDQUFBO0dBQ0Q7O0VBRUQsYUFBYSxHQUFHOztJQUVkLElBQUksQ0FBQyxJQUFBLFVBQUwsRUFBcUI7TUFDbkIsU0FBQSxRQUFBLEtBQUEsQ0FDRSxtRUFERixDQUFBLENBQUE7O01BR0EsT0FBQTtLQUNEOztJQUVELE1BQU0sVUFBVSxJQUFBLGtCQUFBLEVBQWhCLENBQUE7O0lBQ0EsSUFBSSxDQUFDLE9BQUwsRUFBYztNQUNaLFNBQUEsUUFBQSxLQUFBLENBQ0Usa0VBREYsQ0FBQSxDQUFBOztNQUdBLElBQUEsZ0JBQUEsQ0FBcUIsU0FBckIsQ0FBQSxDQUpZOztNQU1aLElBQUEsb0JBQUEsRUFBQSxDQUFBO01BQ0EsT0FBQTtLQWpCWTs7O0lBcUJkLE1BQU0sV0FBVyxJQUFJLFNBQUEsUUFBSixDQUFhLElBQUEsVUFBYixDQUFqQixDQUFBO0lBQ0EsTUFBTSxpQkFBaUIsSUFBQSxnQkFBQSxFQUF2QixDQUFBO0lBQ0EsTUFBTTs7S0FBQSxHQUFXLElBQUEsa0JBQUEsRUFBakIsQ0FBQTs7SUFDQSxNQUFNLFdBQVcsUUFBQSxzQkFBQSxTQUFBLENBQStCLElBQS9CLENBQWpCLENBQUE7O0lBRUEsSUFBSSxRQUFKLEVBQWM7TUFDWixJQUFBLHlCQUFBLENBQThCLElBQTlCLENBQUEsQ0FBQTtLQURGLE1BRU87TUFDTCxJQUFBLEtBQUEsQ0FBVSxjQUFjLG9CQUF4QixDQUFBLENBQUE7S0FDRDs7SUFFRCxRQUFRLFVBQVIsQ0FBbUI7TUFBRSxRQUFRLGFBQUE7S0FBN0IsRUFBOEMseUJBQXlCO01BQ3JFLE1BQU0saUJBQWlCLElBQUEsZ0JBQUEsRUFBdkIsQ0FBQTs7TUFDQSxJQUFJLGNBQWMsS0FBSyxjQUF2QixFQUF1QztRQUNyQyxJQUFJLEdBQUosRUFBUztVQUNQLElBQUEsZ0JBQUEsQ0FBcUIsU0FBckIsQ0FBQSxDQURPOztVQUdQLElBQUEsb0JBQUEsRUFBQSxDQUFBO1VBQ0EsT0FBQTtTQUNEOztRQUVELElBQUEsZ0JBQUEsQ0FBcUIsY0FBckIsQ0FBQSxDQVJxQzs7UUFVckMsSUFBQSx3QkFBQSxFQUFBLENBQUE7T0FDRDtLQWJILENBQUEsQ0FBQTtHQWVEOztFQUVELGlCQUFpQixHQUFHO0lBQUEsSUFBQSxxQkFBQSxDQUFBOztJQUNsQixNQUFNOzs7S0FBQSxHQUFtQyxJQUFBLGtCQUFBLEVBQXpDLENBQUE7SUFDQSxPQUFPLENBQUEsQ0FBQSx3QkFBQSxRQUFBLHVCQUFBLENBQXVCLElBQXZCLENBQUEsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxxQkFBQSxRQUFBLEtBQXlDLGFBQWhELENBQUE7R0FDRDs7RUFFRCxZQUFZLGtCQUFrQixTQUFTLEtBQTNCLEVBQWtDLFdBQVcsRUFBN0MsWUFBMkQ7SUFDckUsT0FBQSxPQUFBLEdBQUEsQ0FDRSxDQUFBLENBQUEsRUFBQSxTQUFBLDZCQUFBLEVBQTZCLE9BQTdCLENBREYsRUFFRyxDQUFBLGtCQUFBLEVBQW9CLE9BQVEsQ0FBQSxzQkFBQSxDQUYvQixDQUFBLENBQUE7O0lBSUEsT0FBQSxPQUFBLEdBQUEsQ0FDRSxDQUFBLENBQUEsRUFBQSxTQUFBLGNBQUEsRUFBYyxRQUFRLENBQUMsT0FBRCxFQUFVLEVBQVYsQ0FBdEIsQ0FERixFQUVHLENBQUEsa0JBQUEsRUFBb0IsT0FBUSxDQUFBLCtDQUFBLENBRi9CLENBQUEsQ0FBQTs7SUFJQSxJQUFBLGtCQUFBLENBQXVCO01BQ3JCLE1BQU0sUUFBQSxpQkFEZTtNQUVyQixNQUZxQjtNQUdyQixPQUhxQjtNQUlyQixNQUpxQjtNQUtyQixRQUxxQjtNQU1yQixRQUFBO0tBTkYsQ0FBQSxDQUFBO0dBUUQ7O0VBRW9CLHFCQUFBLE9BQU87SUFDMUIsT0FBQSxPQUFBLGVBQUEsQ0FDRSxJQURGLEVBRUUsUUFBQSxpQkFGRixFQUdHLENBQUEsNkRBQUEsRUFBK0QsUUFBQSxpQkFBaUIsQ0FBQSxxQkFBQSxDQUhuRixDQUFBLENBQUE7O0lBS0EsT0FBQSxPQUFBLEdBQUEsQ0FDRSxRQUFBLHNCQUFBLFNBQUEsQ0FBK0IsSUFBL0IsQ0FERixFQUVHLENBQUEsOEJBQUEsRUFBZ0MsSUFBSyxDQUFBLEVBQUEsQ0FGeEMsQ0FBQSxDQUFBOztJQUlBLE1BQU07O0tBQUEsR0FBYyxRQUFBLHVCQUFBLENBQXVCLElBQXZCLENBQXBCLENBQUE7SUFDQSxJQUFBLGtCQUFBLENBQXVCO01BQ3JCLElBRHFCO01BRXJCLFFBQVEsRUFGYTtNQUdyQixPQUhxQjtNQUlyQixRQUFRLEtBSmE7TUFLckIsVUFBVSxFQUFBO0tBTFosQ0FBQSxDQUFBO0dBT0Q7O0VBRUQsZUFBZSxHQUFHO0lBQ2hCLElBQUEsa0JBQUEsQ0FBdUIsSUFBQSxrQkFBQSxFQUF2QixDQUFBLENBQUE7R0FDRDs7Ozs7Ozs7RUFPRCxpQkFBaUIsU0FBUztJQUN4QixJQUFBLHNCQUFBLFlBQUEsQ0FBdUMsSUFBQSxrQkFBQSxFQUF2QyxDQUFBLENBQUE7SUFDQSxJQUFBLGNBQUEsWUFBQSxDQUErQixNQUEvQixDQUFBLENBQUE7O0lBQ0EsSUFBQSxlQUFBLENBQW9CLE1BQXBCLENBQUEsQ0FBQTtHQUNEOztFQUVELDBCQUEwQixHQUFHO0lBQzNCLE1BQU0sU0FBUyxJQUFBLHNCQUFBLFNBQUEsRUFBZixDQUFBO0lBQ0EsSUFBQSxjQUFBLFlBQUEsQ0FBK0IsTUFBL0IsQ0FBQSxDQUFBOztJQUNBLElBQUEsZUFBQSxDQUFvQixNQUFwQixDQUFBLENBQUE7R0FDRDs7RUFFRCxpQkFBaUIsR0FBRztJQUNsQixPQUFPLElBQUEsY0FBQSxTQUFBLEVBQVAsQ0FBQTtHQUNEOztFQUVELG9CQUFvQixHQUFHO0lBQ3JCLE1BQU0sV0FBVyxJQUFBLGNBQUEsU0FBQSxFQUFqQixDQUFBO0lBQ0EsT0FBTyxRQUFRLEtBQVIsS0FBa0IsUUFBQSxpQkFBbEIsR0FBcUMsUUFBUSxPQUE3QyxHQUF1RCxRQUFRLEtBQXRFLENBQUE7R0EzUXdEOzs7OztFQWtSNUIsOEJBQUEsVUFBVTtJQUN0QyxNQUFNLFNBQVUsQ0FBQSxRQUFBLEVBQVUsT0FBUSxDQUFBLGNBQUEsRUFBZ0IsSUFBQSxpQkFBc0IsQ0FBQSxDQUF4RSxDQUFBO0lBRUEsSUFBSSxpQkFBaUIsS0FBckIsQ0FBQTtJQUNBLElBQUEsS0FBQSxDQUFVLGNBQWMsbUJBQXhCLEVBQTZDLE1BQU07TUFDakQsaUJBQWlCLElBQWpCLENBQUE7S0FERixDQUFBLENBQUE7O0lBSUEsSUFBSTtNQUNGLE1BQU0sV0FBVyxNQUFNLGdCQUFnQixDQUFDLE1BQUQsRUFBUztRQUM5QyxRQUFRLE1BRHNDO1FBRTlDLE1BQU0sSUFBSSxVQUFKLENBQWU7VUFDbkIsU0FBUyxLQURVO1VBRW5CLFFBQVEsaUJBRlc7VUFHbkIsUUFBUSxFQUhXO1VBSW5CLElBQUksQ0FBQTtTQUpBLENBQUE7T0FGK0IsQ0FBdkMsQ0FBQTs7TUFVQSxJQUFJLGNBQUosRUFBb0I7UUFDbEIsT0FBQTtPQUNEOztNQUVELElBQUksUUFBUSxHQUFaLEVBQWlCO1FBQ2YsSUFBQSxLQUFBLENBQVUsY0FBYyxvQkFBeEIsQ0FBQSxDQUFBO09BREYsTUFFTztRQUNMLE1BQU0sa0JBQWtCLE1BQU0sUUFBUSxLQUFSLEVBQTlCLENBQUE7O1FBQ0EsSUFBSSxjQUFKLEVBQW9CO1VBQ2xCLE9BQUE7U0FDRDs7UUFDRCxJQUFJLGVBQWUsTUFBZixLQUEwQixRQUFBLG1CQUE5QixFQUFrRDtVQUNoRCxJQUFBLEtBQUEsQ0FBVSxjQUFjLGtCQUF4QixDQUFBLENBQUE7U0FDRDtPQUNGO0tBekJILENBMEJFLFlBQVk7TUFDWixTQUFBLFFBQUEsS0FBQSxDQUFVLENBQUEsMkNBQUEsQ0FBVixFQUF3RCxHQUF4RCxDQUFBLENBQUE7S0FDRDtHQUNGOztFQUVELGNBQWMsT0FBTzs7SUFFbkIsSUFBQSxLQUFBLENBQVUsY0FBYyxvQkFBeEIsQ0FBQSxDQUZtQjs7SUFJbkIsSUFBQSxnQkFBQSxDQUFxQixTQUFyQixDQUFBLENBSm1COztJQU1uQixJQUFBLG9CQUFBLEVBQUEsQ0FObUI7O0lBUW5CLElBQUEsbUJBQUEsQ0FBd0IsSUFBeEIsQ0FBQSxDQVJtQjs7O0lBVW5CLElBQUEsS0FBQSxDQUFVLGNBQWMsbUJBQXhCLEVBQTZDLElBQUksS0FBakQsQ0FBQSxDQUFBO0dBQ0Q7O0VBRUQsa0JBQWtCLENBQUM7Ozs7R0FBRCxFQUE0Qjs7SUFFNUMsTUFBTSxXQUFXLFFBQUEsc0JBQUEsU0FBQSxDQUErQixJQUEvQixDQUFqQixDQUFBOztJQUNBLElBQUksUUFBSixFQUFjO01BQ1osSUFBQSx5QkFBQSxDQUE4QixJQUE5QixFQUFvQyxJQUFBLGlCQUFwQyxDQUFBLENBRFk7O0tBQWQsTUFHTyxJQUFJLElBQUksS0FBSyxRQUFBLGlCQUFiLEVBQStCO01BQ3BDLElBQUEsMkJBQUEsQ0FBZ0MsTUFBaEMsRUFBd0MsT0FBeEMsQ0FBQSxDQUFBO0tBREssTUFFQTtNQUNMLE1BQU0sSUFBSSxLQUFKLENBQ0gsQ0FBQSx1REFBQSxFQUF5RCxJQUFLLENBQUEsQ0FBQSxDQUQzRCxDQUFOLENBQUE7S0FHRDtHQUNGOztFQUVELHdCQUF3QixrQkFBa0I7SUFDeEMsU0FBQSxRQUFBLEtBQUEsQ0FBUyw2Q0FBVCxFQUF3RCxJQUF4RCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsbUJBQUEsUUFBQSxFQUFtQjtNQUN2QyxTQUFTLElBRDhCO01BRXZDLFNBQUE7S0FGb0IsQ0FBdEIsQ0FBQTs7SUFJQSxJQUFBLGtCQUFBLENBQXVCLGFBQXZCLENBQUEsQ0FBQTtHQUNEOztFQUVELDBCQUEwQixrQkFBa0I7SUFDMUMsU0FBQSxRQUFBLEtBQUEsQ0FBUywrQ0FBVCxFQUEwRCxNQUExRCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsb0JBQUEsUUFBQSxFQUFvQjtNQUFFLE1BQUY7TUFBVSxPQUFBO0tBQTlCLENBQXRCLENBQUE7O0lBQ0EsSUFBQSxrQkFBQSxDQUF1QixhQUF2QixDQUFBLENBQUE7R0FDRDs7RUFFRCxpQkFBaUIsQ0FBQzs7O0dBQUQsRUFBc0M7SUFDckQsTUFBTSxxQkFBcUIsQ0FBQSxDQUFBLEVBQUEseUJBQUEsUUFBQSxFQUN6QixJQUFBLG9CQUR5QixDQUEzQixDQUFBO0lBR0EsTUFBTSxTQUFTLElBQUksY0FBQSxjQUFKLEVBQWYsQ0FBQTtJQUNBLE1BQU0sS0FBTixDQUFZLGtCQUFaLENBQUEsQ0FBQTtJQUNBLE1BQU0sS0FBTixDQUFZLGlCQUFaLENBQUEsQ0FBQTtJQUNBLE1BQU0sV0FBVyxDQUFBLENBQUEsRUFBQSxxQkFBQSxtQkFBQSxFQUFtQixNQUFuQixDQUFqQixDQUFBOztJQUNBLElBQUEsNEJBQUEsQ0FBaUM7TUFBRSxRQUFGO01BQVksWUFBQTtLQUE3QyxDQUFBLENBQUE7R0FDRDs7RUFFRCwyQkFBMkIsQ0FBQzs7O0dBQUQsRUFBNkI7O0lBRXRELElBQUksSUFBQSxlQUFKLEVBQXlCO01BQ3ZCLElBQUEsZUFBQSxVQUFBLENBQThCLFFBQTlCLENBQUEsQ0FBQTtLQURGLE1BRU87TUFDTCxJQUFBLGVBQUEsR0FBc0IsQ0FBQSxDQUFBLEVBQUEsa0JBQUEscUJBQUEsRUFBcUIsUUFBckIsQ0FBdEIsQ0FBQTtLQUNEOztJQUNELElBQUksSUFBQSxtQkFBSixFQUE2QjtNQUMzQixJQUFBLG1CQUFBLFVBQUEsQ0FBa0MsWUFBbEMsQ0FBQSxDQUFBO0tBREYsTUFFTztNQUNMLElBQUEsbUJBQUEsR0FBMEIsQ0FBQSxDQUFBLEVBQUEsa0JBQUEsd0JBQUEsRUFBd0IsWUFBeEIsRUFBc0M7UUFDOUQsYUFBYSxjQUFBO09BRFcsQ0FBMUIsQ0FBQTtLQVZvRDs7O0lBZXRELElBQUEsVUFBQSxHQUFpQixRQUFqQixDQUFBO0lBQ0EsSUFBQSxjQUFBLEdBQXFCLFlBQXJCLENBQUE7R0FDRDs7Q0FoWXlEOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0MUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQUcsaUJBQUosRUFBbUIsR0FBRyxzQ0FBcUIsUUFBM0MsQ0FBcEI7QUFFQSxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBWixDQUFtQixDQUFDLEdBQUQsRUFBTSxPQUFOLEtBQWtCO0FBQ3RELE9BQUssTUFBTSxVQUFYLElBQXlCLE9BQU8sQ0FBQyxXQUFqQyxFQUE4QztBQUM1QyxJQUFBLEdBQUcsQ0FBQyxHQUFKLENBQVEsVUFBUixFQUFvQixPQUFwQjtBQUNEOztBQUNELFNBQU8sR0FBUDtBQUNELENBTGtCLEVBS2hCLElBQUksR0FBSixFQUxnQixDQUFuQjtBQU9BLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxDQUFDLElBQU4sQ0FDeEIsSUFBSSxHQUFKLENBQ0UscUJBQVEsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsQ0FBQztBQUFFLEVBQUE7QUFBRixDQUFELEtBQW1CLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixDQUFuQyxDQUFSLENBREYsRUFFRSxNQUZGLEVBRHdCLENBQTFCO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBUyxzQkFBVCxDQUFnQyxLQUFoQyxFQUF1QztBQUM1QztBQUNBLFFBQU0sZ0JBQWdCLEdBQUcsaUJBQWlCLENBQUMsTUFBbEIsQ0FDdEIsUUFBRCxJQUFjLENBQUMsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsQ0FBMkIsS0FBM0IsRUFBa0MsUUFBbEMsQ0FEUSxDQUF6Qjs7QUFHQSxNQUFJLGdCQUFnQixDQUFDLE1BQWpCLEdBQTBCLENBQTlCLEVBQWlDO0FBQy9CLFVBQU0sSUFBSSxLQUFKLENBQ0gsOEJBQTZCLGdCQUFnQixDQUFDLElBQWpCLENBQXNCLElBQXRCLENBQTRCLElBRHRELENBQU47QUFHRDs7QUFFRCxTQUFPLGVBQWUsZ0JBQWYsQ0FBZ0MsR0FBaEMsRUFBcUMsR0FBckMsRUFBMEMsSUFBMUMsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDMUQ7QUFDQSxRQUFJLGlDQUF3QixHQUF4QixDQUE0QixHQUFHLENBQUMsTUFBaEMsQ0FBSixFQUE2QztBQUMzQyxhQUFPLEdBQUcsQ0FBQyx3QkFBVSxHQUFWLENBQWMsa0JBQWQsRUFBRCxDQUFWO0FBQ0Q7O0FBRUQsVUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQVgsQ0FBZSxHQUFHLENBQUMsTUFBbkIsQ0FBaEI7O0FBQ0EsUUFBSSxPQUFKLEVBQWE7QUFDWCxZQUFNO0FBQUUsUUFBQSxjQUFGO0FBQWtCLFFBQUE7QUFBbEIsVUFBZ0MsT0FBdEM7O0FBQ0EsVUFBSTtBQUNGO0FBQ0EsZUFBTyxNQUFNLGNBQWMsQ0FDekIsR0FEeUIsRUFFekIsR0FGeUIsRUFHekIsSUFIeUIsRUFJekIsR0FKeUIsRUFLekIsNkJBQVksS0FBWixFQUFtQixTQUFuQixDQUx5QixDQUEzQjtBQU9ELE9BVEQsQ0FTRSxPQUFPLEtBQVAsRUFBYztBQUNkLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxLQUFkO0FBQ0EsZUFBTyxHQUFHLENBQUMsS0FBRCxDQUFWO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQUksRUFBWDtBQUNELEdBekJEO0FBMEJEOzs7Ozs7Ozs7Ozs7O0FDckVEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZOQSxTQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQXFCO0FBQ25CLFNBQU8sSUFBSSxPQUFKLENBQWEsT0FBRCxJQUFhLFVBQVUsQ0FBQyxPQUFELEVBQVUsSUFBVixDQUFuQyxDQUFQO0FBQ0Q7O0FBRUQsZUFBZSxnQkFBZixDQUFnQyxHQUFoQyxFQUFxQztBQUNuQyxRQUFNLEdBQUcsR0FBRyxNQUFNLE1BQU0sQ0FBQyxLQUFQLENBQWMsNkJBQTRCLEdBQUksRUFBOUMsQ0FBbEI7QUFDQSxRQUFNLElBQUksR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFKLEVBQW5CO0FBQ0EsU0FBTyxJQUFJLENBQUMsTUFBTCxHQUFjLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBWCxDQUFkLEdBQWlDLElBQXhDO0FBQ0Q7O0FBRUQsZUFBZSxjQUFmLENBQThCLEdBQTlCLEVBQW1DLFlBQW5DLEVBQWlEO0FBQy9DLFFBQU0sR0FBRyxHQUFHLE1BQU0sTUFBTSxDQUFDLEtBQVAsQ0FBYSx1QkFBYixFQUFzQztBQUN0RCxJQUFBLE1BQU0sRUFBRSxNQUQ4QztBQUV0RCxJQUFBLElBQUksRUFBRSxJQUFJLENBQUMsU0FBTCxDQUFlO0FBQ25CLE1BQUEsR0FEbUI7QUFFbkIsTUFBQSxJQUFJLEVBQUU7QUFGYSxLQUFmO0FBRmdELEdBQXRDLENBQWxCO0FBUUEsU0FBTyxHQUFHLENBQUMsSUFBSixFQUFQO0FBQ0Q7O0FBRUQsTUFBTSxRQUFOLENBQWU7QUFDQyxTQUFQLE9BQU8sQ0FBQyxPQUFELEVBQVU7QUFDdEIsU0FBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLFdBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0I7QUFDckIsTUFBQSxVQUFVLEVBQUcsRUFBRCxJQUFRO0FBQ2xCLFFBQUEsVUFBVSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVY7QUFDRCxPQUhvQjtBQUlyQixNQUFBLFNBQVMsRUFBRSxPQUFPLFNBQVAsRUFBa0IsTUFBbEIsS0FBNkI7QUFDdEMsY0FBTTtBQUFFLFVBQUE7QUFBRixZQUFpQixNQUF2QjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUVBLFFBQUEsVUFBVSxDQUFDLFVBQUQsRUFBYSxHQUFiLENBQVY7QUFFQSxjQUFNLEtBQUssQ0FBQyxFQUFELENBQVg7QUFFQSxlQUFPO0FBQ0wsVUFBQSxPQUFPLEVBQUU7QUFDUCxZQUFBLEdBQUcsRUFBRSxNQUFPLEdBQVAsSUFBZTtBQUNsQixvQkFBTSxLQUFLLENBQUMsRUFBRCxDQUFYO0FBQ0Esb0JBQU0sR0FBRyxHQUFHLE1BQU0sZ0JBQWdCLENBQy9CLEdBQUUsS0FBSyxPQUFRLElBQUcsS0FBSyxTQUFVLElBQUcsR0FBSSxFQURULENBQWxDO0FBR0EscUJBQU8sR0FBUDtBQUNELGFBUE07QUFRUCxZQUFBLEdBQUcsRUFBRSxPQUFPLEdBQVAsRUFBWSxJQUFaLEtBQXFCO0FBQ3hCLG9CQUFNLGNBQWMsQ0FDakIsR0FBRSxLQUFLLE9BQVEsSUFBRyxLQUFLLFNBQVUsSUFBRyxHQUFJLEVBRHZCLEVBRWxCLElBRmtCLENBQXBCO0FBSUEsb0JBQU0sS0FBSyxDQUFDLEVBQUQsQ0FBWDtBQUNBLHFCQUFPLElBQVA7QUFDRDtBQWZNO0FBREosU0FBUDtBQW1CRCxPQS9Cb0I7QUFnQ3JCLE1BQUEsTUFBTSxFQUFFLE1BQU07QUFoQ08sS0FBaEIsQ0FBUDtBQWtDRDs7QUFFcUIsZUFBVCxTQUFTLENBQUMsT0FBRCxFQUFVO0FBQzlCLFVBQU0sTUFBTSxHQUFHLE1BQU0sZ0JBQWdCLENBQUUsR0FBRSxPQUFRLDBCQUFaLENBQXJDO0FBQ0EsV0FBTyxNQUFNLEdBQUc7QUFBRSxNQUFBLE1BQU0sRUFBRTtBQUFFLFFBQUEsUUFBUSxFQUFFO0FBQVo7QUFBVixLQUFILEdBQWtDLEVBQS9DO0FBQ0Q7O0FBMUNZOztBQTZDZixNQUFNLENBQUMsT0FBUCxHQUFpQixRQUFqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQTs7QUFDQTs7QUFDQTs7QUFLZSxTQUFTLHdCQUFULENBQWtDO0FBQy9DLEVBQUEsT0FEK0M7QUFFL0MsRUFBQSxXQUYrQztBQUcvQyxFQUFBLGtCQUgrQztBQUkvQyxFQUFBLHFCQUorQztBQUsvQyxFQUFBLG1CQUwrQztBQU0vQyxFQUFBLHFCQU4rQztBQU8vQyxFQUFBLHFCQVArQztBQVEvQyxFQUFBLHNCQVIrQztBQVMvQyxFQUFBLHFCQVQrQztBQVUvQyxFQUFBLDBCQVYrQztBQVcvQyxFQUFBLGVBWCtDO0FBWS9DLEVBQUE7QUFaK0MsQ0FBbEMsRUFhWjtBQUNELFFBQU0sa0JBQWtCLEdBQUcsb0NBQWdCLENBQ3pDLDZDQUF5QjtBQUN2QixJQUFBLFdBQVcsRUFBRSxLQURVO0FBRXZCLElBQUEsa0JBQWtCLEVBQUcsYUFBWSxPQUFRO0FBRmxCLEdBQXpCLENBRHlDLEVBS3pDLGtEQUF1QjtBQUNyQixJQUFBLFdBRHFCO0FBRXJCLElBQUEsa0JBRnFCO0FBR3JCLElBQUEscUJBSHFCO0FBSXJCLElBQUEsbUJBSnFCO0FBS3JCLElBQUEscUJBTHFCO0FBTXJCLElBQUEscUJBTnFCO0FBT3JCLElBQUEsc0JBUHFCO0FBUXJCLElBQUEscUJBUnFCO0FBU3JCLElBQUE7QUFUcUIsR0FBdkIsQ0FMeUMsRUFnQnpDLDJDQUE2QjtBQUFFLElBQUE7QUFBRixHQUE3QixDQWhCeUMsRUFpQnpDLHdDQUEwQjtBQUFFLElBQUE7QUFBRixHQUExQixDQWpCeUMsQ0FBaEIsQ0FBM0I7QUFtQkEsU0FBTyxrQkFBUDtBQUNEOzs7Ozs7Ozs7Ozs7QUN6Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0aUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaElBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQQTs7QUFDQTs7QUFRQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBWSxPQUEzQjtBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxHQUFHO0FBQUUsRUFBQSxlQUFlLEVBQUU7QUFBbkIsQ0FBSCxHQUFpQyxFQUFoRTs7QUFDQSxNQUFNLGtCQUFrQixHQUFHLE1BQU07QUFDL0IsU0FBTyxNQUFNLEdBQUcsQ0FBQyxvQ0FBb0MsRUFBckMsQ0FBSCxHQUE4QyxFQUEzRDtBQUNELENBRkQ7O0FBSWUsU0FBUyxtQkFBVCxDQUE2QjtBQUFFLEVBQUEsTUFBRjtBQUFVLEVBQUE7QUFBVixDQUE3QixFQUFrRDtBQUMvRCxRQUFNLGVBQWUsR0FBRyxpREFBc0I7QUFBRSxJQUFBO0FBQUYsR0FBdEIsQ0FBeEI7QUFDQSxRQUFNLGFBQWEsR0FBRyxrREFBdUIsZUFBdkIsQ0FBdEI7QUFDQSxRQUFNLFlBQVksR0FBRyxJQUFJLG9DQUFKLGlDQUNoQixnQkFEZ0I7QUFFbkIsSUFBQSxRQUFRLEVBQUU7QUFGUyxLQUFyQjtBQUtBLFFBQU0saUJBQWlCLEdBQUcsb0NBQWdCLENBQ3hDLEdBQUcsa0JBQWtCLEVBRG1CLEVBRXhDLHVCQUF1QixDQUFDLE9BQUQsQ0FGaUIsRUFHeEMsMkRBQWdDO0FBQUUsSUFBQTtBQUFGLEdBQWhDLENBSHdDLEVBSXhDLHNEQUEyQjtBQUFFLElBQUE7QUFBRixHQUEzQixDQUp3QyxFQUt4QywwREFMd0MsRUFNeEMsaUVBQXNDO0FBQUUsSUFBQTtBQUFGLEdBQXRDLENBTndDLEVBT3hDLGVBUHdDLENBQWhCLENBQTFCO0FBVUEsU0FBTztBQUFFLElBQUEsaUJBQUY7QUFBcUIsSUFBQTtBQUFyQixHQUFQO0FBQ0Q7O0FBRUQsU0FBUyx1QkFBVCxDQUFpQyxPQUFqQyxFQUEwQztBQUN4QyxTQUFPLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxJQUFYLEVBQWlCLEdBQWpCLEtBQXlCO0FBQzlCLFFBQUksR0FBRyxDQUFDLE1BQUosS0FBZSxhQUFuQixFQUFrQztBQUNoQyxNQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsT0FBYjtBQUNBLGFBQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFJLEVBQVg7QUFDRCxHQU5EO0FBT0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxvQ0FBVCxHQUFnRDtBQUM5QyxTQUFPLDBDQUFzQixPQUFPLEdBQVAsRUFBWSxDQUFaLEVBQWUsSUFBZixLQUF3QjtBQUNuRCxRQUFJLEdBQUcsQ0FBQyxNQUFKLEtBQWUsaUJBQW5CLEVBQXNDO0FBQ3BDLFlBQU0sSUFBSSxPQUFKLENBQWEsT0FBRCxJQUFhLFVBQVUsQ0FBQyxPQUFELEVBQVUsZUFBUyxDQUFuQixDQUFuQyxDQUFOO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFJLEVBQVg7QUFDRCxHQUxNLENBQVA7QUFNRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1REQ7O0FBQ0E7O0FBU0E7O0FBQ0E7O0FBRUE7O0FBRWUsU0FBUyxrQkFBVCxDQUE0QjtBQUFFLEVBQUEsT0FBRjtBQUFXLEVBQUE7QUFBWCxDQUE1QixFQUFvRDtBQUNqRSxRQUFNLGdCQUFnQixHQUFHLCtCQUF1QjtBQUM5QyxJQUFBLE9BRDhDO0FBRTlDLElBQUEsU0FGOEM7QUFHOUMsSUFBQSxXQUFXLEVBQUUsQ0FIaUM7QUFJOUMsSUFBQSxNQUFNLEVBQUU7QUFKc0MsR0FBdkIsQ0FBekI7QUFNQSxRQUFNLGNBQWMsR0FBRyxrREFBdUIsZ0JBQXZCLENBQXZCO0FBQ0EsUUFBTSxZQUFZLEdBQUcsSUFBSSxvQ0FBSixDQUF3QjtBQUFFLElBQUEsUUFBUSxFQUFFO0FBQVosR0FBeEIsQ0FBckI7QUFFQSxRQUFNLGlCQUFpQixHQUFHLG9DQUFnQixDQUN4QyxpQ0FBaUMsQ0FBQztBQUFFLElBQUE7QUFBRixHQUFELENBRE8sRUFFeEMsc0RBQTJCO0FBQUUsSUFBQTtBQUFGLEdBQTNCLENBRndDLEVBR3hDLDBEQUh3QyxFQUl4QyxvREFBeUI7QUFBRSxJQUFBLFlBQUY7QUFBZ0IsSUFBQSxRQUFRLEVBQUU7QUFBMUIsR0FBekIsQ0FKd0MsRUFLeEMsd0RBQTZCO0FBQUUsSUFBQSxZQUFGO0FBQWdCLElBQUEsUUFBUSxFQUFFO0FBQTFCLEdBQTdCLENBTHdDLEVBTXhDLGlFQUFzQztBQUFFLElBQUE7QUFBRixHQUF0QyxDQU53QyxFQU94QyxnQkFQd0MsQ0FBaEIsQ0FBMUI7QUFTQSxTQUFPO0FBQUUsSUFBQSxpQkFBRjtBQUFxQixJQUFBO0FBQXJCLEdBQVA7QUFDRDs7QUFFRCxTQUFTLGlDQUFULENBQTJDO0FBQUUsRUFBQTtBQUFGLENBQTNDLEVBQXdEO0FBQ3RELE1BQUksQ0FBQyxnQ0FBdUIsT0FBdkIsQ0FBTCxFQUFzQztBQUNwQyxVQUFNLElBQUksS0FBSixDQUFXLHlDQUF3QyxPQUFRLEdBQTNELENBQU47QUFDRDs7QUFFRCxRQUFNO0FBQUUsSUFBQSxPQUFGO0FBQVcsSUFBQTtBQUFYLE1BQXlCLGdDQUF1QixPQUF2QixDQUEvQjtBQUVBLFNBQU8sNkNBQXlCO0FBQzlCLElBQUEsV0FBVyxFQUFFLE9BRGlCO0FBRTlCLElBQUEsV0FBVyxFQUFFO0FBRmlCLEdBQXpCLENBQVA7QUFJRDs7Ozs7Ozs7Ozs7OztBQ2hERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3QxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1K0NBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3R4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM1dBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEhBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU0sUUFBUSxHQUFHLENBQ2YseUJBRGUsRUFFZixvQkFGZSxFQUdmLHlCQUhlLEVBSWYseUJBSmUsRUFLZix3QkFMZSxFQU1mLHFCQU5lLEVBT2YsNEJBUGUsRUFRZixtQkFSZSxDQUFqQjtlQVVlLFE7Ozs7Ozs7Ozs7Ozs7QUNuQmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUkE7O0FBQ0E7O0FBRU8sU0FBUyw0QkFBVCxDQUFzQztBQUFFLEVBQUE7QUFBRixDQUF0QyxFQUEyRDtBQUNoRSxTQUFPLDBDQUFzQixPQUFPLEdBQVAsRUFBWSxHQUFaLEVBQWlCLElBQWpCLEtBQTBCO0FBQ3JELFVBQU07QUFBRSxNQUFBLE1BQUY7QUFBVSxNQUFBO0FBQVYsUUFBcUIsR0FBM0I7O0FBQ0EsUUFBSSxNQUFNLEtBQUsseUJBQWYsRUFBMEM7QUFDeEMsTUFBQSxJQUFJO0FBQ0o7QUFDRDs7QUFDRCxVQUFNLENBQUMsS0FBRCxFQUFRLFFBQVIsSUFBb0IsTUFBMUI7O0FBQ0EsUUFBSSxRQUFRLEtBQUssU0FBakIsRUFBNEI7QUFDMUIsTUFBQSxJQUFJO0FBQ0o7QUFDRDs7QUFDRCxJQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsTUFBTSxlQUFlLENBQUMsS0FBRCxDQUFsQztBQUNELEdBWk0sQ0FBUDtBQWFEOztBQUVNLFNBQVMseUJBQVQsQ0FBbUM7QUFBRSxFQUFBO0FBQUYsQ0FBbkMsRUFBb0U7QUFDekUsU0FBTywwQ0FBc0IsT0FBTyxHQUFQLEVBQVksR0FBWixFQUFpQixJQUFqQixLQUEwQjtBQUNyRCxVQUFNO0FBQUUsTUFBQSxNQUFGO0FBQVUsTUFBQTtBQUFWLFFBQXFCLEdBQTNCOztBQUNBLFFBQUksTUFBTSxLQUFLLDBCQUFmLEVBQTJDO0FBQ3pDLE1BQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsVUFBTSxDQUFDLElBQUQsSUFBUyxNQUFmO0FBQ0EsVUFBTSxNQUFNLEdBQUcsMkJBQTJCLENBQUMsSUFBRCxDQUExQzs7QUFDQSxRQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsTUFBQSxJQUFJO0FBQ0o7QUFDRDs7QUFDRCxJQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsb0NBQXlCLE1BQXpCLENBQWI7QUFDRCxHQWJNLENBQVA7QUFjRDs7Ozs7Ozs7Ozs7O0FDbENEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxc0JBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeDBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyUEE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImJhY2tncm91bmQtMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFiaSA9IFtcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hhc2gnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRDb250ZW50JyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBuYW1lOiAnY29udGVudCcsXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnaW50ZXJmYWNlSUQnLCB0eXBlOiAnYnl0ZXM0JyB9XSxcbiAgICBuYW1lOiAnc3VwcG9ydHNJbnRlcmZhY2UnLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYm9vbCcgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAncHVyZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2tleScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0VGV4dCcsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAnY29udGVudFR5cGVzJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnQUJJJyxcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7IG5hbWU6ICdjb250ZW50VHlwZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgeyBuYW1lOiAnZGF0YScsIHR5cGU6ICdieXRlcycgfSxcbiAgICBdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICd4JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICd5JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0UHVia2V5JyxcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGFzaCcsIHR5cGU6ICdieXRlcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdzZXRDb250ZW50aGFzaCcsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ2FkZHInLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAna2V5JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRlbnRUeXBlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldEFCSScsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ25hbWUnLFxuICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnc3RyaW5nJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAnbmFtZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnc2V0TmFtZScsXG4gICAgb3V0cHV0czogW10sXG4gICAgcGF5YWJsZTogZmFsc2UsXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgfSxcbiAge1xuICAgIGNvbnN0YW50OiB0cnVlLFxuICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgbmFtZTogJ2NvbnRlbnRoYXNoJyxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2J5dGVzJyB9XSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBuYW1lOiAncHVia2V5JyxcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7IG5hbWU6ICd4JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IG5hbWU6ICd5JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgXSxcbiAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICB9LFxuICB7XG4gICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBuYW1lOiAnYWRkcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ3NldEFkZHInLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IG5hbWU6ICdlbnNBZGRyJywgdHlwZTogJ2FkZHJlc3MnIH1dLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdjb25zdHJ1Y3RvcicsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ2EnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdBZGRyQ2hhbmdlZCcsXG4gICAgdHlwZTogJ2V2ZW50JyxcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGluZGV4ZWQ6IHRydWUsIG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAnbmFtZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnTmFtZUNoYW5nZWQnLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnY29udGVudFR5cGUnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICBdLFxuICAgIG5hbWU6ICdBQklDaGFuZ2VkJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgIHsgaW5kZXhlZDogZmFsc2UsIG5hbWU6ICd4JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBuYW1lOiAneScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgIF0sXG4gICAgbmFtZTogJ1B1YmtleUNoYW5nZWQnLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ2luZGV4ZWRLZXknLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ2tleScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnVGV4dENoYW5nZWQnLFxuICAgIHR5cGU6ICdldmVudCcsXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgeyBpbmRleGVkOiB0cnVlLCBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgeyBpbmRleGVkOiBmYWxzZSwgbmFtZTogJ2hhc2gnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgXSxcbiAgICBuYW1lOiAnQ29udGVudGhhc2hDaGFuZ2VkJyxcbiAgICB0eXBlOiAnZXZlbnQnLFxuICB9LFxuXTtcbmV4cG9ydCBkZWZhdWx0IGFiaTtcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBtdWx0aUMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuXG5jb25zdCB7IGhleFN0cmluZ1RvQnVmZmVyLCBwcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9wcm9maWxlcycpO1xuY29uc3QgeyBjaWRGb3JXZWIsIGNpZFYwVG9WMUJhc2UzMiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8vZXhwb3J0IHNvbWUgaGVscGVycyBmdW5jdGlvbnNcblx0aGVscGVyczoge1xuXHRcdGNpZEZvcldlYixcblx0XHRjaWRWMFRvVjFCYXNlMzIsXG5cdH0sXG5cblx0LyoqXG5cdCogRGVjb2RlIGEgQ29udGVudCBIYXNoLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIGFuIGhleCBzdHJpbmcgY29udGFpbmluZyBhIGNvbnRlbnQgaGFzaFxuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY29kZWQgY29udGVudFxuXHQqL1xuXHRkZWNvZGU6IGZ1bmN0aW9uIChjb250ZW50SGFzaCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGNvbnRlbnRIYXNoKTtcblx0XHRjb25zdCBjb2RlYyA9IG11bHRpQy5nZXRDb2RlYyhidWZmZXIpO1xuXHRcdGNvbnN0IHZhbHVlID0gbXVsdGlDLnJtUHJlZml4KGJ1ZmZlcik7XG5cdFx0bGV0IHByb2ZpbGUgPSBwcm9maWxlc1tjb2RlY107XG5cdFx0aWYgKCFwcm9maWxlKSBwcm9maWxlID0gcHJvZmlsZXNbJ2RlZmF1bHQnXTtcblx0XHRyZXR1cm4gcHJvZmlsZS5kZWNvZGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhbiBJUEZTIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBzdHJpbmcgY29udGFpbmluZyBhbiBJUEZTIGFkZHJlc3Ncblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21JcGZzOiBmdW5jdGlvbiAoaXBmc0hhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ2lwZnMtbnMnLCBpcGZzSGFzaCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGEgU2t5bGluayBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IHNreWxpbmsgc3RyaW5nIGNvbnRhaW5pbmcgYSBTa3lsaW5rXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU2t5bGluazogZnVuY3Rpb24gKHNreWxpbmspIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3NreW5ldC1ucycsIHNreWxpbmspO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhIFN3YXJtIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBzd2FybUhhc2ggc3RyaW5nIGNvbnRhaW5pbmcgYSBTd2FybSBhZGRyZXNzXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU3dhcm06IGZ1bmN0aW9uIChzd2FybUhhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3N3YXJtLW5zJywgc3dhcm1IYXNoKTtcblx0fSxcblxuXHQvKipcblx0KiBHZW5lcmFsIHB1cnBvc2UgZW5jb2RpbmcgZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gY29kZWMgXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuICAqL1xuXHRlbmNvZGU6IGZ1bmN0aW9uIChjb2RlYywgdmFsdWUpIHtcblx0XHRsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2NvZGVjXTtcblx0XHRpZiAoIXByb2ZpbGUpIHByb2ZpbGUgPSBwcm9maWxlc1snZGVmYXVsdCddO1xuXHRcdGNvbnN0IGVuY29kZWRWYWx1ZSA9IHByb2ZpbGUuZW5jb2RlKHZhbHVlKTtcblx0XHRyZXR1cm4gbXVsdGlILnRvSGV4U3RyaW5nKG11bHRpQy5hZGRQcmVmaXgoY29kZWMsIGVuY29kZWRWYWx1ZSkpXG5cdH0sXG5cblx0LyoqXG5cdCogRXh0cmFjdCB0aGUgY29kZWMgb2YgYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gaGFzaCBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYSBjb250ZW50IGhhc2hcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHRyYWN0ZWQgY29kZWNcblx0Ki9cblx0Z2V0Q29kZWM6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0bGV0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGhhc2gpO1xuXHRcdHJldHVybiBtdWx0aUMuZ2V0Q29kZWMoYnVmZmVyKTtcblx0fSxcbn1cbiIsImV4cG9ydCBjb25zdCBTSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTID1cbiAgJzB4YjFmOGU1NWM3ZjY0ZDIwM2MxNDAwYjlkODU1NWQwNTBmOTRhZGYzOSc7XG5leHBvcnQgY29uc3QgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19SSU5LRUJZID1cbiAgJzB4OWY1MTBiMTlmMWFkNjZmMGRjZjZlNDU1NTlmYWIwZDY3NTJjMWRiNyc7XG5leHBvcnQgY29uc3QgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19ST1BTVEVOID1cbiAgJzB4YjhlNjcxNzM0Y2U1YzhkN2RmYmJlYTU1NzRmYTRjZjM5ZjdhNTRhNCc7XG5leHBvcnQgY29uc3QgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19LT1ZBTiA9XG4gICcweGIxZDNmYmIyZjgzYWVjZDE5NmY0NzRjMTZjYTVkOWNmZmEwZDBmZmMnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZShoYW5kbGVycykge1xuICAgIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbcmVxLm1ldGhvZF07XG4gICAgICAgIC8vIGlmIG5vIGhhbmRsZXIsIHJldHVyblxuICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGhhbmRsZXIgaXMgZm4sIGNhbGwgYXMgbWlkZGxld2FyZVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyKHJlcSwgcmVzLCBuZXh0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgICAgICByZXMucmVzdWx0ID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSA9IGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSmxZWFJsVTJOaFptWnZiR1JOYVdSa2JHVjNZWEpsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2YzNKakwyTnlaV0YwWlZOallXWm1iMnhrVFdsa1pHeGxkMkZ5WlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZKUVN4VFFVRm5RaXgzUWtGQmQwSXNRMEZCUXl4UlFVVjRRenRKUVVORExFOUJRVThzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1JVRkJSU3hIUVVGSExFVkJRVVVzUlVGQlJUdFJRVU0zUWl4TlFVRk5MRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNKRExIZENRVUYzUWp0UlFVTjRRaXhKUVVGSkxFOUJRVThzUzBGQlN5eFRRVUZUTEVWQlFVVTdXVUZEZWtJc1QwRkJUeXhKUVVGSkxFVkJRVVVzUTBGQlF6dFRRVU5tTzFGQlEwUXNkVU5CUVhWRE8xRkJRM1pETEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1ZVRkJWU3hGUVVGRk8xbEJRMnBETEU5QlFVOHNUMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNKRE8xRkJRMFFzWjBSQlFXZEVPMUZCUXk5RExFZEJRU3RDTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTlCUVU4c1EwRkJRenRSUVVOc1JDeFBRVUZQTEVkQlFVY3NSVUZCUlN4RFFVRkRPMGxCUTJZc1EwRkJReXhEUVVGRE8wRkJRMG9zUTBGQlF6dEJRV3BDUkN3MFJFRnBRa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVBc3luY01pZGRsZXdhcmUgPSB2b2lkIDA7XG4vKipcbiAqIEpzb25ScGNFbmdpbmUgb25seSBhY2NlcHRzIGNhbGxiYWNrLWJhc2VkIG1pZGRsZXdhcmUgZGlyZWN0bHkuXG4gKiBjcmVhdGVBc3luY01pZGRsZXdhcmUgZXhpc3RzIHRvIGVuYWJsZSBjb25zdW1lcnMgdG8gcGFzcyBpbiBhc3luYyBtaWRkbGV3YXJlXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQXN5bmMgbWlkZGxld2FyZSBoYXZlIG5vIFwiZW5kXCIgZnVuY3Rpb24uIEluc3RlYWQsIHRoZXkgXCJlbmRcIiBpZiB0aGV5IHJldHVyblxuICogd2l0aG91dCBjYWxsaW5nIFwibmV4dFwiLiBSYXRoZXIgdGhhbiBwYXNzaW5nIGluIGV4cGxpY2l0IHJldHVybiBoYW5kbGVycyxcbiAqIGFzeW5jIG1pZGRsZXdhcmUgY2FuIHNpbXBseSBhd2FpdCBcIm5leHRcIiwgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVcbiAqIHJlc3BvbnNlIG9iamVjdCB3aGVuIGV4ZWN1dGlvbiByZXN1bWVzLlxuICpcbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgY3JlYXRlQXN5bmNNaWRkbGV3YXJlIHBhc3NlcyB0aGUgYXN5bmMgbWlkZGxld2FyZSBhXG4gKiB3cmFwcGVkIFwibmV4dFwiIGZ1bmN0aW9uLiBUaGF0IGZ1bmN0aW9uIGNhbGxzIHRoZSBpbnRlcm5hbCBKc29uUnBjRW5naW5lXG4gKiBcIm5leHRcIiBmdW5jdGlvbiB3aXRoIGEgcmV0dXJuIGhhbmRsZXIgdGhhdCByZXNvbHZlcyBhIHByb21pc2Ugd2hlbiBjYWxsZWQuXG4gKlxuICogVGhlIHJldHVybiBoYW5kbGVyIHdpbGwgYWx3YXlzIGJlIGNhbGxlZC4gSXRzIHJlc29sdXRpb24gb2YgdGhlIHByb21pc2VcbiAqIGVuYWJsZXMgdGhlIGNvbnRyb2wgZmxvdyBkZXNjcmliZWQgYWJvdmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luY01pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gbmV4dFByb21pc2UgaXMgdGhlIGtleSB0byB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcbiAgICAgICAgLy8gXCJuZXh0XCIgZnVuY3Rpb25cbiAgICAgICAgbGV0IHJlc29sdmVOZXh0UHJvbWlzZTtcbiAgICAgICAgY29uc3QgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgbmV4dFdhc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUuXG4gICAgICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG5leHRXYXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gV2UgcGFzcyBhIHJldHVybiBoYW5kbGVyIHRvIG5leHQoKS4gV2hlbiBpdCBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSxcbiAgICAgICAgICAgIC8vIHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUgd2lsbCByZXN1bWUgZXhlY3V0aW5nLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBuZXh0KChydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBjb21lcyBmcm9tIEpzb25ScGNFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gcnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjaztcbiAgICAgICAgICAgICAgICByZXNvbHZlTmV4dFByb21pc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbmV4dFByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhc3luY01pZGRsZXdhcmUocmVxLCByZXMsIGFzeW5jTmV4dCk7XG4gICAgICAgICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlOyAvLyB3ZSBtdXN0IHdhaXQgdW50aWwgdGhlIHJldHVybiBoYW5kbGVyIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IGNyZWF0ZUFzeW5jTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSmxZWFJsUVhONWJtTk5hV1JrYkdWM1lYSmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZjM0pqTDJOeVpXRjBaVUZ6ZVc1alRXbGtaR3hsZDJGeVpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGblFrRTdPenM3T3pzN096czdPenM3T3pzN1IwRm5Ra2M3UVVGRFNDeFRRVUZuUWl4eFFrRkJjVUlzUTBGRGJrTXNaVUZCTmtNN1NVRkZOME1zVDBGQlR5eExRVUZMTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hKUVVGSkxFVkJRVVVzUjBGQlJ5eEZRVUZGTEVWQlFVVTdVVUZEYmtNc0swTkJRU3RETzFGQlF5OURMSEZFUVVGeFJEdFJRVU55UkN4clFrRkJhMEk3VVVGRGJFSXNTVUZCU1N4clFrRkJPRUlzUTBGQlF6dFJRVU51UXl4TlFVRk5MRmRCUVZjc1IwRkJSeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RlFVRkZPMWxCUXpGRExHdENRVUZyUWl4SFFVRkhMRTlCUVU4c1EwRkJRenRSUVVNdlFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRWxCUVVrc2NVSkJRWEZDTEVkQlFWa3NTVUZCU1N4RFFVRkRPMUZCUXpGRExFbEJRVWtzWVVGQllTeEhRVUZITEV0QlFVc3NRMEZCUXp0UlFVVXhRaXd3UkVGQk1FUTdVVUZETVVRc1RVRkJUU3hUUVVGVExFZEJRVWNzUzBGQlN5eEpRVUZKTEVWQlFVVTdXVUZETTBJc1lVRkJZU3hIUVVGSExFbEJRVWtzUTBGQlF6dFpRVVZ5UWl4MVJVRkJkVVU3V1VGRGRrVXNlVVJCUVhsRU8xbEJRM3BFTEdkRVFVRm5SRHRaUVVOb1JDeEpRVUZKTEVOQlFVTXNRMEZCUXl4NVFrRkJlVUlzUlVGQlJTeEZRVUZGTzJkQ1FVTnFReXcwUkVGQk5FUTdaMEpCUXpWRUxIRkNRVUZ4UWl4SFFVRkhMSGxDUVVGNVFpeERRVUZETzJkQ1FVTnNSQ3hyUWtGQmEwSXNSVUZCUlN4RFFVRkRPMWxCUTNaQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEwZ3NUVUZCVFN4WFFVRlhMRU5CUVVNN1VVRkRjRUlzUTBGQlF5eERRVUZETzFGQlJVWXNTVUZCU1R0WlFVTkdMRTFCUVUwc1pVRkJaU3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkZNME1zU1VGQlNTeGhRVUZoTEVWQlFVVTdaMEpCUTJwQ0xFMUJRVTBzVjBGQlZ5eERRVUZETEVOQlFVTXNhMFJCUVd0RU8yZENRVU53UlN4eFFrRkJLME1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0aFFVTjRSRHRwUWtGQlRUdG5Ra0ZEVEN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WVVGRFdEdFRRVU5HTzFGQlFVTXNUMEZCVHl4TFFVRkxMRVZCUVVVN1dVRkRaQ3hKUVVGSkxIRkNRVUZ4UWl4RlFVRkZPMmRDUVVONFFpeHhRa0ZCSzBNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dGhRVU42UkR0cFFrRkJUVHRuUWtGRFRDeEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1lVRkRXanRUUVVOR08wbEJRMGdzUTBGQlF5eERRVUZETzBGQlEwb3NRMEZCUXp0QlFTOURSQ3h6UkVFclEwTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVuaXF1ZUlkID0gdm9pZCAwO1xuLy8gdWludDMyICh0d28ncyBjb21wbGVtZW50KSBtYXhcbi8vIG1vcmUgY29uc2VydmF0aXZlIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbmNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5sZXQgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDtcbiAgICByZXR1cm4gaWRDb3VudGVyO1xufVxuZXhwb3J0cy5nZXRVbmlxdWVJZCA9IGdldFVuaXF1ZUlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWjJWMFZXNXBjWFZsU1dRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZaMlYwVlc1cGNYVmxTV1F1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzWjBOQlFXZERPMEZCUTJoRExHbEVRVUZwUkR0QlFVTnFSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eFZRVUZWTEVOQlFVTTdRVUZEZGtJc1NVRkJTU3hUUVVGVExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdRVUZGYUVRc1UwRkJaMElzVjBGQlZ6dEpRVU42UWl4VFFVRlRMRWRCUVVjc1EwRkJReXhUUVVGVExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUTJ4RExFOUJRVThzVTBGQlV5eERRVUZETzBGQlEyNUNMRU5CUVVNN1FVRklSQ3hyUTBGSFF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBnZXRVbmlxdWVJZF8xID0gcmVxdWlyZShcIi4vZ2V0VW5pcXVlSWRcIik7XG5mdW5jdGlvbiBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSWQgPSByZXEuaWQ7XG4gICAgICAgIGNvbnN0IG5ld0lkID0gZ2V0VW5pcXVlSWRfMS5nZXRVbmlxdWVJZCgpO1xuICAgICAgICByZXEuaWQgPSBuZXdJZDtcbiAgICAgICAgcmVzLmlkID0gbmV3SWQ7XG4gICAgICAgIG5leHQoKGRvbmUpID0+IHtcbiAgICAgICAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7XG4gICAgICAgICAgICByZXMuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVJZFJlbWFwTWlkZGxld2FyZSA9IGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVdSU1pXMWhjRTFwWkdSc1pYZGhjbVV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmFXUlNaVzFoY0UxcFpHUnNaWGRoY21VdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc0swTkJRVFJETzBGQlJ6VkRMRk5CUVdkQ0xIVkNRVUYxUWp0SlFVTnlReXhQUVVGUExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFVkJRVVU3VVVGRE9VSXNUVUZCVFN4VlFVRlZMRWRCUVVjc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF6dFJRVU14UWl4TlFVRk5MRXRCUVVzc1IwRkJSeXg1UWtGQlZ5eEZRVUZGTEVOQlFVTTdVVUZETlVJc1IwRkJSeXhEUVVGRExFVkJRVVVzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEWml4SFFVRkhMRU5CUVVNc1JVRkJSU3hIUVVGSExFdEJRVXNzUTBGQlF6dFJRVU5tTEVsQlFVa3NRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hGUVVGRk8xbEJRMW9zUjBGQlJ5eERRVUZETEVWQlFVVXNSMEZCUnl4VlFVRlZMRU5CUVVNN1dVRkRjRUlzUjBGQlJ5eERRVUZETEVWQlFVVXNSMEZCUnl4VlFVRlZMRU5CUVVNN1dVRkRjRUlzU1VGQlNTeEZRVUZGTEVOQlFVTTdVVUZEVkN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU1zUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZhUkN3d1JFRlpReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1lcmdlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IEpzb25ScGNFbmdpbmVfMSA9IHJlcXVpcmUoXCIuL0pzb25ScGNFbmdpbmVcIik7XG5mdW5jdGlvbiBtZXJnZU1pZGRsZXdhcmUobWlkZGxld2FyZVN0YWNrKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IEpzb25ScGNFbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgbWlkZGxld2FyZVN0YWNrLmZvckVhY2goKG1pZGRsZXdhcmUpID0+IGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpKTtcbiAgICByZXR1cm4gZW5naW5lLmFzTWlkZGxld2FyZSgpO1xufVxuZXhwb3J0cy5tZXJnZU1pZGRsZXdhcmUgPSBtZXJnZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV1Z5WjJWTmFXUmtiR1YzWVhKbExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dmMzSmpMMjFsY21kbFRXbGtaR3hsZDJGeVpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeHRSRUZCYlVVN1FVRkZia1VzVTBGQlowSXNaVUZCWlN4RFFVRkRMR1ZCUVhORU8wbEJRM0JHTEUxQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc05rSkJRV0VzUlVGQlJTeERRVUZETzBsQlEyNURMR1ZCUVdVc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTnFSU3hQUVVGUExFMUJRVTBzUTBGQlF5eFpRVUZaTEVWQlFVVXNRMEZCUXp0QlFVTXZRaXhEUVVGRE8wRkJTa1FzTUVOQlNVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNFbmdpbmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuLyoqXG4gKiBBIEpTT04tUlBDIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHByb2Nlc3Nvci5cbiAqIEdpdmUgaXQgYSBzdGFjayBvZiBtaWRkbGV3YXJlLCBwYXNzIGl0IHJlcXVlc3RzLCBhbmQgZ2V0IGJhY2sgcmVzcG9uc2VzLlxuICovXG5jbGFzcyBKc29uUnBjRW5naW5lIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0byB0aGUgZW5naW5lJ3MgbWlkZGxld2FyZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaWRkbGV3YXJlIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gYWRkLlxuICAgICAqL1xuICAgIHB1c2gobWlkZGxld2FyZSkge1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlLnB1c2gobWlkZGxld2FyZSk7XG4gICAgfVxuICAgIGhhbmRsZShyZXEsIGNiKSB7XG4gICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjYWxsYmFja1wiIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmF0Y2gocmVxLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQmF0Y2gocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGUocmVxLCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2VIYW5kbGUocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcHVzaGVkIHRvIG90aGVyXG4gICAgICogZW5naW5lcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhc01pZGRsZXdhcmUoKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbbWlkZGxld2FyZUVycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycyxdID0gYXdhaXQgSnNvblJwY0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgSnNvblJwY0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kKG1pZGRsZXdhcmVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGFzeW5jIChoYW5kbGVyQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IEpzb25ScGNFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlQmF0Y2gocmVxcywgY2IpIHtcbiAgICAgICAgLy8gVGhlIG9yZGVyIGhlcmUgaXMgaW1wb3J0YW50XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAyLiBXYWl0IGZvciBhbGwgcmVxdWVzdHMgdG8gZmluaXNoLCBvciB0aHJvdyBvbiBzb21lIGtpbmQgb2YgZmF0YWxcbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIC8vIDEuIEJlZ2luIGV4ZWN1dGluZyBlYWNoIHJlcXVlc3QgaW4gdGhlIG9yZGVyIHJlY2VpdmVkXG4gICAgICAgICAgICByZXFzLm1hcCh0aGlzLl9wcm9taXNlSGFuZGxlLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIC8vIDMuIFJldHVybiBiYXRjaCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3BvbnNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcHJvbWlzZS13cmFwcGVkIF9oYW5kbGUuXG4gICAgICovXG4gICAgX3Byb21pc2VIYW5kbGUocmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlKHJlcSwgKF9lcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGEgcmVzcG9uc2UsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXZlIGFueSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgY2F1Z2h0IGFuZCBwcm9wYWdhdGVkLlxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0IG9iamVjdCBpcyB2YWxpZCwgcHJvY2Vzc2VzIGl0LCBhbmQgcGFzc2VzIGFueVxuICAgICAqIGVycm9yIGFuZCB0aGUgcmVzcG9uc2Ugb2JqZWN0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHJlamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlKGNhbGxlclJlcSwgY2IpIHtcbiAgICAgICAgaWYgKCFjYWxsZXJSZXEgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2FsbGVyUmVxKSB8fFxuICAgICAgICAgICAgdHlwZW9mIGNhbGxlclJlcSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvcihldGhfcnBjX2Vycm9yc18xLmVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBgUmVxdWVzdHMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBSZWNlaXZlZDogJHt0eXBlb2YgY2FsbGVyUmVxfWAsIHsgcmVxdWVzdDogY2FsbGVyUmVxIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycm9yLCB7IGlkOiB1bmRlZmluZWQsIGpzb25ycGM6ICcyLjAnLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxlclJlcS5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBldGhfcnBjX2Vycm9yc18xLkV0aGVyZXVtUnBjRXJyb3IoZXRoX3JwY19lcnJvcnNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYE11c3Qgc3BlY2lmeSBhIHN0cmluZyBtZXRob2QuIFJlY2VpdmVkOiAke3R5cGVvZiBjYWxsZXJSZXEubWV0aG9kfWAsIHsgcmVxdWVzdDogY2FsbGVyUmVxIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycm9yLCB7IGlkOiBjYWxsZXJSZXEuaWQsIGpzb25ycGM6ICcyLjAnLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXEgPSBPYmplY3QuYXNzaWduKHt9LCBjYWxsZXJSZXEpO1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBpZDogcmVxLmlkLFxuICAgICAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgLy8gQSByZXF1ZXN0IGhhbmRsZXIgZXJyb3IsIGEgcmUtdGhyb3duIG1pZGRsZXdhcmUgZXJyb3IsIG9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gdW5leHBlY3RlZC5cbiAgICAgICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG5vIHJlc3VsdCBpcyBwcmVzZW50IG9uIGFuIGVycm9yZWQgcmVzcG9uc2VcbiAgICAgICAgICAgIGRlbGV0ZSByZXMucmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuZXJyb3IgPSBldGhfcnBjX2Vycm9yc18xLnNlcmlhbGl6ZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IoZXJyb3IsIHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgZ2l2ZW4gcmVxdWVzdCBhbmQgcmVzcG9uc2UsIHJ1bnMgYWxsIG1pZGRsZXdhcmUgYW5kIHRoZWlyIHJldHVyblxuICAgICAqIGhhbmRsZXJzLCBpZiBhbnksIGFuZCBlbnN1cmVzIHRoYXQgaW50ZXJuYWwgcmVxdWVzdCBwcm9jZXNzaW5nIHNlbWFudGljc1xuICAgICAqIGFyZSBzYXRpc2ZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3Byb2Nlc3NSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnMsXSA9IGF3YWl0IEpzb25ScGNFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuICAgICAgICAvLyBUaHJvdyBpZiBcImVuZFwiIHdhcyBub3QgY2FsbGVkLCBvciBpZiB0aGUgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHRcbiAgICAgICAgLy8gbm9yIGFuIGVycm9yLlxuICAgICAgICBKc29uUnBjRW5naW5lLl9jaGVja0ZvckNvbXBsZXRpb24ocmVxLCByZXMsIGlzQ29tcGxldGUpO1xuICAgICAgICAvLyBUaGUgcmV0dXJuIGhhbmRsZXJzIHNob3VsZCBydW4gZXZlbiBpZiBhbiBlcnJvciB3YXMgZW5jb3VudGVyZWQgZHVyaW5nXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgcHJvY2Vzc2luZy5cbiAgICAgICAgYXdhaXQgSnNvblJwY0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAvLyBOb3cgd2UgcmUtdGhyb3cgdGhlIG1pZGRsZXdhcmUgcHJvY2Vzc2luZyBlcnJvciwgaWYgYW55LCB0byBjYXRjaCBpdFxuICAgICAgICAvLyBmdXJ0aGVyIHVwIHRoZSBjYWxsIGNoYWluLlxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGx5IGV4ZWN1dGVzIHRoZSBnaXZlbiBzdGFjayBvZiBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN1dGlvbixcbiAgICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQsIGFuZCBhbiBhcnJheSBvZlxuICAgICAqIG1pZGRsZXdhcmUtZGVmaW5lZCByZXR1cm4gaGFuZGxlcnMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIF9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlU3RhY2spIHtcbiAgICAgICAgY29uc3QgcmV0dXJuSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgLy8gR28gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIHJldHVybkhhbmRsZXJzXG4gICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlU3RhY2spIHtcbiAgICAgICAgICAgIFtlcnJvciwgaXNDb21wbGV0ZV0gPSBhd2FpdCBKc29uUnBjRW5naW5lLl9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzLnJldmVyc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgYW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN0aW9uLFxuICAgICAqIGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXF1ZXN0IHNob3VsZCBlbmQuXG4gICAgICovXG4gICAgc3RhdGljIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVyciB8fCByZXMuZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9IGV0aF9ycGNfZXJyb3JzXzEuc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBlbmRcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtlcnJvciwgdHJ1ZV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAocmV0dXJuSGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kKHJlcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5IYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKG5ldyBldGhfcnBjX2Vycm9yc18xLkV0aGVyZXVtUnBjRXJyb3IoZXRoX3JwY19lcnJvcnNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbCwgYEpzb25ScGNFbmdpbmU6IFwibmV4dFwiIHJldHVybiBoYW5kbGVycyBtdXN0IGJlIGZ1bmN0aW9ucy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBSZWNlaXZlZCBcIiR7dHlwZW9mIHJldHVybkhhbmRsZXJ9XCIgZm9yIHJlcXVlc3Q6XFxuJHtqc29uaWZ5KHJlcSl9YCwgeyByZXF1ZXN0OiByZXEgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGVuZFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtudWxsLCBmYWxzZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsbHkgZXhlY3V0ZXMgYXJyYXkgb2YgcmV0dXJuIGhhbmRsZXJzLiBUaGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgYXJlXG4gICAgICogYXNzdW1lZCB0byBiZSBpbiB0aGVpciBzY29wZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgX3J1blJldHVybkhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKGVycikgPT4gKGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciwgb3IgaWZcbiAgICAgKiB0aGUgXCJpc0NvbXBsZXRlXCIgZmxhZyBpcyBmYWxzeS5cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NoZWNrRm9yQ29tcGxldGlvbihyZXEsIHJlcywgaXNDb21wbGV0ZSkge1xuICAgICAgICBpZiAoISgncmVzdWx0JyBpbiByZXMpICYmICEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXRoX3JwY19lcnJvcnNfMS5FdGhlcmV1bVJwY0Vycm9yKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGBKc29uUnBjRW5naW5lOiBSZXNwb25zZSBoYXMgbm8gZXJyb3Igb3IgcmVzdWx0IGZvciByZXF1ZXN0OlxcbiR7anNvbmlmeShyZXEpfWAsIHsgcmVxdWVzdDogcmVxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvcihldGhfcnBjX2Vycm9yc18xLmVycm9yQ29kZXMucnBjLmludGVybmFsLCBgSnNvblJwY0VuZ2luZTogTm90aGluZyBlbmRlZCByZXF1ZXN0OlxcbiR7anNvbmlmeShyZXEpfWAsIHsgcmVxdWVzdDogcmVxIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uUnBjRW5naW5lID0gSnNvblJwY0VuZ2luZTtcbmZ1bmN0aW9uIGpzb25pZnkocmVxdWVzdCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LCBudWxsLCAyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVNuTnZibEp3WTBWdVoybHVaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5S2MyOXVVbkJqUlc1bmFXNWxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096dEJRVUZCTEhOR1FVRTBSRHRCUVVNMVJDeHRSRUZCT0VVN1FVRjFSamxGT3pzN1IwRkhSenRCUVVOSUxFMUJRV0VzWVVGQll5eFRRVUZSTERSQ1FVRm5RanRKUVVkcVJEdFJRVU5GTEV0QlFVc3NSVUZCUlN4RFFVRkRPMUZCUTFJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZEZUVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTQ3hKUVVGSkxFTkJRVThzVlVGQmJVTTdVVUZETlVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTXNWVUZCYVVRc1EwRkJReXhEUVVGRE8wbEJRek5GTEVOQlFVTTdTVUV5UTBRc1RVRkJUU3hEUVVGRExFZEJRVmtzUlVGQlJTeEZRVUZSTzFGQlF6TkNMRWxCUVVrc1JVRkJSU3hKUVVGSkxFOUJRVThzUlVGQlJTeExRVUZMTEZWQlFWVXNSVUZCUlR0WlFVTnNReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERSRFFVRTBReXhEUVVGRExFTkJRVU03VTBGREwwUTdVVUZGUkN4SlFVRkpMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZEZEVJc1NVRkJTU3hGUVVGRkxFVkJRVVU3WjBKQlEwNHNUMEZCVHl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFZEJRVWNzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTnVRenRaUVVORUxFOUJRVThzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRUUVVNdlFqdFJRVVZFTEVsQlFVa3NSVUZCUlN4RlFVRkZPMWxCUTA0c1QwRkJUeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFUaENMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGVrUTdVVUZEUkN4UFFVRlBMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQk9FSXNRMEZCUXl4RFFVRkRPMGxCUXpkRUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWazdVVUZEVml4UFFVRlBMRXRCUVVzc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVsQlFVa3NSVUZCUlN4SFFVRkhMRVZCUVVVc1JVRkJSVHRaUVVOdVF5eEpRVUZKTzJkQ1FVTkdMRTFCUVUwc1EwRkRTaXhsUVVGbExFVkJRMllzVlVGQlZTeEZRVU5XTEdOQlFXTXNSVUZEWml4SFFVRkhMRTFCUVUwc1lVRkJZU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMmRDUVVWMFJTeEpRVUZKTEZWQlFWVXNSVUZCUlR0dlFrRkRaQ3hOUVVGTkxHRkJRV0VzUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhqUVVGakxFTkJRVU1zUTBGQlF6dHZRa0ZEZGtRc1QwRkJUeXhIUVVGSExFTkJRVU1zWlVGQk5rTXNRMEZCUXl4RFFVRkRPMmxDUVVNelJEdG5Ra0ZGUkN4UFFVRlBMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzWlVGQlpTeEZRVUZGTEVWQlFVVTdiMEpCUTNCRExFbEJRVWs3ZDBKQlEwWXNUVUZCVFN4aFFVRmhMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN2NVSkJRM2hFTzI5Q1FVRkRMRTlCUVU4c1MwRkJTeXhGUVVGRk8zZENRVU5rTEU5QlFVOHNaVUZCWlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8zRkNRVU12UWp0dlFrRkRSQ3hQUVVGUExHVkJRV1VzUlVGQlJTeERRVUZETzJkQ1FVTXpRaXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU5LTzFsQlFVTXNUMEZCVHl4TFFVRkxMRVZCUVVVN1owSkJRMlFzVDBGQlR5eEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1lVRkRia0k3VVVGRFNDeERRVUZETEVOQlFVTTdTVUZEU2l4RFFVRkRPMGxCYVVKUExFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlEzaENMRWxCUVN0Q0xFVkJReTlDTEVWQlFYRkZPMUZCUlhKRkxEaENRVUU0UWp0UlFVTTVRaXhKUVVGSk8xbEJRMFlzY1VWQlFYRkZPMWxCUTNKRkxGRkJRVkU3V1VGRFVpeE5RVUZOTEZOQlFWTXNSMEZCUnl4TlFVRk5MRTlCUVU4c1EwRkJReXhIUVVGSE8xbEJRMnBETEhkRVFVRjNSRHRaUVVONFJDeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUTNwRExFTkJRVU03V1VGRlJpd3lRa0ZCTWtJN1dVRkRNMElzU1VGQlNTeEZRVUZGTEVWQlFVVTdaMEpCUTA0c1QwRkJUeXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMkZCUXpWQ08xbEJRMFFzVDBGQlR5eFRRVUZUTEVOQlFVTTdVMEZEYkVJN1VVRkJReXhQUVVGUExFdEJRVXNzUlVGQlJUdFpRVU5rTEVsQlFVa3NSVUZCUlN4RlFVRkZPMmRDUVVOT0xFOUJRVThzUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMkZCUTJ4Q08xbEJSVVFzVFVGQlRTeExRVUZMTEVOQlFVTTdVMEZEWWp0SlFVTklMRU5CUVVNN1NVRkZSRHM3VDBGRlJ6dEpRVU5MTEdOQlFXTXNRMEZEY0VJc1IwRkJORUk3VVVGRk5VSXNUMEZCVHl4SlFVRkpMRTlCUVU4c1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZGTzFsQlF6ZENMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRWRCUVVjc1JVRkJSU3hGUVVGRk8yZENRVU01UWl4eFJVRkJjVVU3WjBKQlEzSkZMR2xEUVVGcFF6dG5Ra0ZEYWtNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEyWXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkxMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRMjVDTEZOQlFXdERMRVZCUTJ4RExFVkJRV2RGTzFGQlJXaEZMRWxCUTBVc1EwRkJReXhUUVVGVE8xbEJRMVlzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRlRUlzVDBGQlR5eFRRVUZUTEV0QlFVc3NVVUZCVVN4RlFVTTNRanRaUVVOQkxFMUJRVTBzUzBGQlN5eEhRVUZITEVsQlFVa3NhVU5CUVdkQ0xFTkJRMmhETERKQ1FVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExHTkJRV01zUlVGRE4wSXNOa05CUVRaRExFOUJRVThzVTBGQlV5eEZRVUZGTEVWQlF5OUVMRVZCUVVVc1QwRkJUeXhGUVVGRkxGTkJRVk1zUlVGQlJTeERRVU4yUWl4RFFVRkRPMWxCUTBZc1QwRkJUeXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkROVVE3VVVGRlJDeEpRVUZKTEU5QlFVOHNVMEZCVXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhSUVVGUkxFVkJRVVU3V1VGRGVFTXNUVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hwUTBGQlowSXNRMEZEYUVNc01rSkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNZMEZCWXl4RlFVTTNRaXd5UTBGQk1rTXNUMEZCVHl4VFFVRlRMRU5CUVVNc1RVRkJUU3hGUVVGRkxFVkJRM0JGTEVWQlFVVXNUMEZCVHl4RlFVRkZMRk5CUVZNc1JVRkJSU3hEUVVOMlFpeERRVUZETzFsQlEwWXNUMEZCVHl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEZOQlFWTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1QwRkJUeXhGUVVGRkxFdEJRVXNzUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUXk5RU8xRkJSVVFzVFVGQlRTeEhRVUZITEhGQ1FVRnBReXhUUVVGVExFTkJRVVVzUTBGQlF6dFJRVU4wUkN4TlFVRk5MRWRCUVVjc1IwRkJiME03V1VGRE0wTXNSVUZCUlN4RlFVRkZMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRMVlzVDBGQlR5eEZRVUZGTEVkQlFVY3NRMEZCUXl4UFFVRlBPMU5CUTNKQ0xFTkJRVU03VVVGRFJpeEpRVUZKTEV0QlFVc3NSMEZCSzBJc1NVRkJTU3hEUVVGRE8xRkJSVGRETEVsQlFVazdXVUZEUml4TlFVRk5MRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNSRE8xRkJRVU1zVDBGQlR5eE5RVUZOTEVWQlFVVTdXVUZEWml4elJVRkJjMFU3V1VGRGRFVXNZMEZCWXp0WlFVTmtMRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU03VTBGRGFFSTdVVUZGUkN4SlFVRkpMRXRCUVVzc1JVRkJSVHRaUVVOVUxIRkVRVUZ4UkR0WlFVTnlSQ3hQUVVGUExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTTdXVUZEYkVJc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEVWQlFVVTdaMEpCUTJRc1IwRkJSeXhEUVVGRExFdEJRVXNzUjBGQlJ5d3JRa0ZCWXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8yRkJRMjVETzFOQlEwWTdVVUZGUkN4UFFVRlBMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUjBGQkswSXNRMEZCUXl4RFFVRkRPMGxCUTNCRUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMHNzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZETTBJc1IwRkJORUlzUlVGRE5VSXNSMEZCYjBNN1VVRkZjRU1zVFVGQlRTeERRVU5LTEV0QlFVc3NSVUZEVEN4VlFVRlZMRVZCUTFZc1kwRkJZeXhGUVVObUxFZEJRVWNzVFVGQlRTeGhRVUZoTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRmRFVXNlVVZCUVhsRk8xRkJRM3BGTEdkQ1FVRm5RanRSUVVOb1FpeGhRVUZoTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRSUVVWNFJDeDVSVUZCZVVVN1VVRkRla1VzZVVKQlFYbENPMUZCUTNwQ0xFMUJRVTBzWVVGQllTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETzFGQlJYWkVMSFZGUVVGMVJUdFJRVU4yUlN3MlFrRkJOa0k3VVVGRE4wSXNTVUZCU1N4TFFVRkxMRVZCUVVVN1dVRkRWQ3hOUVVGTkxFdEJRVXNzUTBGQlF6dFRRVU5pTzBsQlEwZ3NRMEZCUXp0SlFVVkVPenM3T3pzN1QwRk5SenRKUVVOTExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNhVUpCUVdsQ0xFTkJRM0JETEVkQlFUUkNMRVZCUXpWQ0xFZEJRVzlETEVWQlEzQkRMR1ZCUVhORU8xRkJVWFJFTEUxQlFVMHNZMEZCWXl4SFFVRnBReXhGUVVGRkxFTkJRVU03VVVGRGVFUXNTVUZCU1N4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRMnBDTEVsQlFVa3NWVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVWMlFpeDNSVUZCZDBVN1VVRkRlRVVzUzBGQlN5eE5RVUZOTEZWQlFWVXNTVUZCU1N4bFFVRmxMRVZCUVVVN1dVRkRlRU1zUTBGQlF5eExRVUZMTEVWQlFVVXNWVUZCVlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hoUVVGaExFTkJRVU1zWTBGQll5eERRVU4wUkN4SFFVRkhMRVZCUTBnc1IwRkJSeXhGUVVOSUxGVkJRVlVzUlVGRFZpeGpRVUZqTEVOQlEyWXNRMEZCUXp0WlFVTkdMRWxCUVVrc1ZVRkJWU3hGUVVGRk8yZENRVU5rTEUxQlFVMDdZVUZEVUR0VFFVTkdPMUZCUTBRc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeFZRVUZWTEVWQlFVVXNZMEZCWXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRGRrUXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBzc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGRE0wSXNSMEZCTkVJc1JVRkROVUlzUjBGQmIwTXNSVUZEY0VNc1ZVRkJLME1zUlVGREwwTXNZMEZCTkVNN1VVRkZOVU1zVDBGQlR5eEpRVUZKTEU5QlFVOHNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRk8xbEJRemRDTEUxQlFVMHNSMEZCUnl4SFFVRTJRaXhEUVVGRExFZEJRV0VzUlVGQlJTeEZRVUZGTzJkQ1FVTjBSQ3hOUVVGTkxFdEJRVXNzUjBGQlJ5eEhRVUZITEVsQlFVa3NSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJRenRuUWtGREwwSXNTVUZCU1N4TFFVRkxMRVZCUVVVN2IwSkJRMVFzUjBGQlJ5eERRVUZETEV0QlFVc3NSMEZCUnl3clFrRkJZeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzJsQ1FVTnVRenRuUWtGRFJDdzJRMEZCTmtNN1owSkJRemRETEU5QlFVOHNRMEZCUXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcENMRU5CUVVNc1EwRkJRenRaUVVWR0xFMUJRVTBzU1VGQlNTeEhRVUU0UWl4RFFVTjBReXhoUVVFd1F5eEZRVU14UXl4RlFVRkZPMmRDUVVOR0xFbEJRVWtzUjBGQlJ5eERRVUZETEV0QlFVc3NSVUZCUlR0dlFrRkRZaXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMmxDUVVOb1FqdHhRa0ZCVFR0dlFrRkRUQ3hKUVVGSkxHRkJRV0VzUlVGQlJUdDNRa0ZEYWtJc1NVRkJTU3hQUVVGUExHRkJRV0VzUzBGQlN5eFZRVUZWTEVWQlFVVTdORUpCUTNaRExFZEJRVWNzUTBGRFJDeEpRVUZKTEdsRFFVRm5RaXhEUVVOc1Fpd3lRa0ZCVlN4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRM1pDTERKRVFVRXlSRHRuUTBGRGVrUXNZVUZCWVN4UFFVRlBMR0ZCUVdFc2JVSkJRVzFDTEU5QlFVOHNRMEZEZWtRc1IwRkJSeXhEUVVOS0xFVkJRVVVzUlVGRFRDeEZRVUZGTEU5QlFVOHNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkRha0lzUTBGRFJpeERRVUZETzNsQ1FVTklPM2RDUVVORUxHTkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN2NVSkJRM0JETzI5Q1FVVkVMR3RFUVVGclJEdHZRa0ZEYkVRc1QwRkJUeXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRM2hDTzFsQlEwZ3NRMEZCUXl4RFFVRkRPMWxCUlVZc1NVRkJTVHRuUWtGRFJpeFZRVUZWTEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hKUVVGSkxFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTTdZVUZEYWtNN1dVRkJReXhQUVVGUExFdEJRVXNzUlVGQlJUdG5Ra0ZEWkN4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03WVVGRFdqdFJRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkxMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zYTBKQlFXdENMRU5CUTNKRExGRkJRWE5ETzFGQlJYUkRMRXRCUVVzc1RVRkJUU3hQUVVGUExFbEJRVWtzVVVGQlVTeEZRVUZGTzFsQlF6bENMRTFCUVUwc1NVRkJTU3hQUVVGUExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVN1owSkJRM0JETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JFTEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTBvN1NVRkRTQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBzc1RVRkJUU3hEUVVGRExHMUNRVUZ0UWl4RFFVTm9ReXhIUVVFMFFpeEZRVU0xUWl4SFFVRnZReXhGUVVOd1F5eFZRVUZ0UWp0UlFVVnVRaXhKUVVGSkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVsQlFVa3NSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFOUJRVThzU1VGQlNTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTXpReXhOUVVGTkxFbEJRVWtzYVVOQlFXZENMRU5CUTNoQ0xESkNRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkRka0lzWjBWQlFXZEZMRTlCUVU4c1EwRkRja1VzUjBGQlJ5eERRVU5LTEVWQlFVVXNSVUZEU0N4RlFVRkZMRTlCUVU4c1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGRGFrSXNRMEZCUXp0VFFVTklPMUZCUTBRc1NVRkJTU3hEUVVGRExGVkJRVlVzUlVGQlJUdFpRVU5tTEUxQlFVMHNTVUZCU1N4cFEwRkJaMElzUTBGRGVFSXNNa0pCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVU4yUWl3d1EwRkJNRU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRVZCUTNoRUxFVkJRVVVzVDBGQlR5eEZRVUZGTEVkQlFVY3NSVUZCUlN4RFFVTnFRaXhEUVVGRE8xTkJRMGc3U1VGRFNDeERRVUZETzBOQlEwWTdRVUZ5V1VRc2MwTkJjVmxETzBGQlJVUXNVMEZCVXl4UFFVRlBMRU5CUVVNc1QwRkJaME03U1VGREwwTXNUMEZCVHl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUlVGQlJTeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRNVU1zUTBGQlF5SjkiLCJpbXBvcnQgRXRoSnNFbnMgZnJvbSAnZXRoanMtZW5zJztcbmltcG9ydCBlbnNOZXR3b3JrTWFwIGZyb20gJ2V0aGVyZXVtLWVucy1uZXR3b3JrLW1hcCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVucyB7XG4gIHN0YXRpYyBnZXROZXR3b3JrRW5zU3VwcG9ydChuZXR3b3JrKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZW5zTmV0d29ya01hcFtuZXR3b3JrXSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7IG5ldHdvcmssIHByb3ZpZGVyIH0gPSB7fSkge1xuICAgIHRoaXMuX2V0aEpzRW5zID0gbmV3IEV0aEpzRW5zKHtcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcm92aWRlcixcbiAgICB9KTtcbiAgfVxuXG4gIGxvb2t1cChlbnNOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V0aEpzRW5zLmxvb2t1cChlbnNOYW1lKTtcbiAgfVxuXG4gIHJldmVyc2UoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLl9ldGhKc0Vucy5yZXZlcnNlKGFkZHJlc3MpO1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgV0FMTEVUX1BSRUZJWCA9ICd3YWxsZXRfJztcblxuZXhwb3J0IGNvbnN0IE5PVElGSUNBVElPTl9OQU1FUyA9IHtcbiAgYWNjb3VudHNDaGFuZ2VkOiAnbWV0YW1hc2tfYWNjb3VudHNDaGFuZ2VkJyxcbiAgdW5sb2NrU3RhdGVDaGFuZ2VkOiAnbWV0YW1hc2tfdW5sb2NrU3RhdGVDaGFuZ2VkJyxcbiAgY2hhaW5DaGFuZ2VkOiAnbWV0YW1hc2tfY2hhaW5DaGFuZ2VkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBMT0dfSUdOT1JFX01FVEhPRFMgPSBbXG4gICd3YWxsZXRfcmVnaXN0ZXJPbmJvYXJkaW5nJyxcbiAgJ3dhbGxldF93YXRjaEFzc2V0Jyxcbl07XG5cbmV4cG9ydCBjb25zdCBMT0dfTUVUSE9EX1RZUEVTID0ge1xuICByZXN0cmljdGVkOiAncmVzdHJpY3RlZCcsXG4gIGludGVybmFsOiAnaW50ZXJuYWwnLFxufTtcblxuLyoqXG4gKiBUaGUgcGVybWlzc2lvbiBhY3Rpdml0eSBsb2cgc2l6ZSBsaW1pdC5cbiAqL1xuZXhwb3J0IGNvbnN0IExPR19MSU1JVCA9IDEwMDtcbiIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgQ2F2ZWF0VHlwZXMgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zJztcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgc2VsZWN0b3JzIGZvciBQZXJtaXNzaW9uQ29udHJvbGxlciBzZWxlY3RvciBldmVudFxuICogc3Vic2NyaXB0aW9ucywgdXNlZCB0byBkZXRlY3Qgd2hlbmV2ZXIgYSBzdWJqZWN0J3MgYWNjb3VudHMgY2hhbmdlIHNvIHRoYXRcbiAqIHdlIGNhbiBub3RpZnkgdGhlIHN1YmplY3QgdmlhIHRoZSBgYWNjb3VudHNDaGFuZ2VkYCBwcm92aWRlciBldmVudC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+fSBzdGF0ZSAtIFRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIgc3RhdGUuXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFRoZSBQZXJtaXNzaW9uQ29udHJvbGxlciBzdWJqZWN0cy5cbiAqL1xuY29uc3QgZ2V0U3ViamVjdHMgPSAoc3RhdGUpID0+IHN0YXRlLnN1YmplY3RzO1xuXG4vKipcbiAqIEdldCB0aGUgcGVybWl0dGVkIGFjY291bnRzIGZvciBlYWNoIHN1YmplY3QsIGtleWVkIGJ5IG9yaWdpbi5cbiAqIFRoZSB2YWx1ZXMgb2YgdGhlIHJldHVybmVkIG1hcCBhcmUgaW1tdXRhYmxlIHZhbHVlcyBmcm9tIHRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIgc3RhdGUuXG4gKlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZ1tdPn0gVGhlIGN1cnJlbnQgb3JpZ2luOmFjY291bnRzW10gbWFwLlxuICovXG5leHBvcnQgY29uc3QgZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbiA9IGNyZWF0ZVNlbGVjdG9yKFxuICBnZXRTdWJqZWN0cyxcbiAgKHN1YmplY3RzKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3ViamVjdHMpLnJlZHVjZSgob3JpZ2luVG9BY2NvdW50c01hcCwgc3ViamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2F2ZWF0ID0gc3ViamVjdC5wZXJtaXNzaW9ucz8uZXRoX2FjY291bnRzPy5jYXZlYXRzLmZpbmQoXG4gICAgICAgICh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgKTtcblxuICAgICAgaWYgKGNhdmVhdCkge1xuICAgICAgICBvcmlnaW5Ub0FjY291bnRzTWFwLnNldChzdWJqZWN0Lm9yaWdpbiwgY2F2ZWF0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5Ub0FjY291bnRzTWFwO1xuICAgIH0sIG5ldyBNYXAoKSk7XG4gIH0sXG4pO1xuXG4vKipcbiAqIEdpdmVuIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cyBleHBvc2VkIGFjY291bnRzIGZvciBlYWNoIFBlcm1pc3Npb25Db250cm9sbGVyXG4gKiBzdWJqZWN0LCByZXR1cm5zIGEgbmV3IG1hcCBjb250YWluaW5nIGFsbCBhY2NvdW50cyB0aGF0IGhhdmUgY2hhbmdlZC5cbiAqIFRoZSB2YWx1ZXMgb2YgZWFjaCBtYXAgbXVzdCBiZSBpbW11dGFibGUgdmFsdWVzIGRpcmVjdGx5IGZyb20gdGhlXG4gKiBQZXJtaXNzaW9uQ29udHJvbGxlciBzdGF0ZSwgb3IgYW4gZW1wdHkgYXJyYXkgaW5zdGFudGlhdGVkIGluIHRoaXNcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nW10+fSBuZXdBY2NvdW50c01hcCAtIFRoZSBuZXcgb3JpZ2luOmFjY291bnRzW10gbWFwLlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59IFtwcmV2aW91c0FjY291bnRzTWFwXSAtIFRoZSBwcmV2aW91cyBvcmlnaW46YWNjb3VudHNbXSBtYXAuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nW10+fSBUaGUgb3JpZ2luOmFjY291bnRzW10gbWFwIG9mIGNoYW5nZWQgYWNjb3VudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDaGFuZ2VkQWNjb3VudHMgPSAobmV3QWNjb3VudHNNYXAsIHByZXZpb3VzQWNjb3VudHNNYXApID0+IHtcbiAgaWYgKHByZXZpb3VzQWNjb3VudHNNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXdBY2NvdW50c01hcDtcbiAgfVxuXG4gIGNvbnN0IGNoYW5nZWRBY2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgaWYgKG5ld0FjY291bnRzTWFwID09PSBwcmV2aW91c0FjY291bnRzTWFwKSB7XG4gICAgcmV0dXJuIGNoYW5nZWRBY2NvdW50cztcbiAgfVxuXG4gIGNvbnN0IG5ld09yaWdpbnMgPSBuZXcgU2V0KFsuLi5uZXdBY2NvdW50c01hcC5rZXlzKCldKTtcblxuICBmb3IgKGNvbnN0IG9yaWdpbiBvZiBwcmV2aW91c0FjY291bnRzTWFwLmtleXMoKSkge1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gbmV3QWNjb3VudHNNYXAuZ2V0KG9yaWdpbikgPz8gW107XG5cbiAgICAvLyBUaGUgdmFsdWVzIG9mIHRoZXNlIG1hcHMgYXJlIHJlZmVyZW5jZXMgdG8gaW1tdXRhYmxlIHZhbHVlcywgd2hpY2ggaXMgd2h5XG4gICAgLy8gYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgaXMgZW5vdWdoIGZvciBkaWZmaW5nLiBUaGUgdmFsdWVzIGFyZSBlaXRoZXIgZnJvbVxuICAgIC8vIFBlcm1pc3Npb25Db250cm9sbGVyIHN0YXRlLCBvciBhbiBlbXB0eSBhcnJheSBpbml0aWFsaXplZCBpbiB0aGUgcHJldmlvdXNcbiAgICAvLyBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uIGBuZXdBY2NvdW50c01hcGAgd2lsbCBuZXZlciBjb250YWluIGFueSBlbXB0eVxuICAgIC8vIGFycmF5cy5cbiAgICBpZiAocHJldmlvdXNBY2NvdW50c01hcC5nZXQob3JpZ2luKSAhPT0gbmV3QWNjb3VudHMpIHtcbiAgICAgIGNoYW5nZWRBY2NvdW50cy5zZXQob3JpZ2luLCBuZXdBY2NvdW50cyk7XG4gICAgfVxuXG4gICAgbmV3T3JpZ2lucy5kZWxldGUob3JpZ2luKTtcbiAgfVxuXG4gIC8vIEJ5IG5vdywgbmV3T3JpZ2lucyBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGFpbnMgc29tZSBudW1iZXIgb2YgcHJldmlvdXNseVxuICAvLyB1bmVuY291bnRlcmVkIG9yaWdpbnMsIGFuZCBhbGwgb2YgdGhlaXIgYWNjb3VudHMgaGF2ZSBcImNoYW5nZWRcIi5cbiAgZm9yIChjb25zdCBvcmlnaW4gb2YgbmV3T3JpZ2lucy5rZXlzKCkpIHtcbiAgICBjaGFuZ2VkQWNjb3VudHMuc2V0KG9yaWdpbiwgbmV3QWNjb3VudHNNYXAuZ2V0KG9yaWdpbikpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VkQWNjb3VudHM7XG59O1xuIiwiaW1wb3J0IHsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiB9IGZyb20gJ0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzJztcbmltcG9ydCB7IENhdmVhdFR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogRmFjdG9yaWVzIHRoYXQgY29uc3RydWN0IGNhdmVhdCBtdXRhdG9yIGZ1bmN0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG9cbiAqIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDYXZlYXRNdXRhdG9yRmFjdG9yaWVzID0ge1xuICBbQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXToge1xuICAgIHJlbW92ZUFjY291bnQsXG4gIH0sXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRhcmdldCBhY2NvdW50IGZyb20gdGhlIHZhbHVlIGFycmF5cyBvZiBhbGxcbiAqIGByZXN0cmljdFJldHVybmVkQWNjb3VudHNgIGNhdmVhdHMuIE5vLW9wcyBpZiB0aGUgdGFyZ2V0IGFjY291bnQgaXMgbm90IGluXG4gKiB0aGUgYXJyYXksIGFuZCByZXZva2VzIHRoZSBwYXJlbnQgcGVybWlzc2lvbiBpZiBpdCdzIHRoZSBvbmx5IGFjY291bnQgaW5cbiAqIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0QWNjb3VudCAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHJlbW92ZSBmcm9tXG4gKiBhbGwgYWNjb3VudHMgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGlzdGluZ0FjY291bnRzIC0gVGhlIGFjY291bnQgYWRkcmVzcyBhcnJheSBmcm9tIHRoZVxuICogYWNjb3VudCBwZXJtaXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQWNjb3VudCh0YXJnZXRBY2NvdW50LCBleGlzdGluZ0FjY291bnRzKSB7XG4gIGNvbnN0IG5ld0FjY291bnRzID0gZXhpc3RpbmdBY2NvdW50cy5maWx0ZXIoXG4gICAgKGFkZHJlc3MpID0+IGFkZHJlc3MgIT09IHRhcmdldEFjY291bnQsXG4gICk7XG5cbiAgaWYgKG5ld0FjY291bnRzLmxlbmd0aCA9PT0gZXhpc3RpbmdBY2NvdW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4geyBvcGVyYXRpb246IENhdmVhdE11dGF0b3JPcGVyYXRpb24ubm9vcCB9O1xuICB9IGVsc2UgaWYgKG5ld0FjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0aW9uOiBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnVwZGF0ZVZhbHVlLFxuICAgICAgdmFsdWU6IG5ld0FjY291bnRzLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgb3BlcmF0aW9uOiBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnJldm9rZVBlcm1pc3Npb24gfTtcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcbmltcG9ydCB7IENhdmVhdFR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5pbXBvcnQge1xuICBMT0dfSUdOT1JFX01FVEhPRFMsXG4gIExPR19MSU1JVCxcbiAgTE9HX01FVEhPRF9UWVBFUyxcbiAgV0FMTEVUX1BSRUZJWCxcbn0gZnJvbSAnLi9lbnVtcyc7XG5cbi8qKlxuICogQ29udHJvbGxlciB3aXRoIG1pZGRsZXdhcmUgZm9yIGxvZ2dpbmcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byByZXN0cmljdGVkXG4gKiBhbmQgcGVybWlzc2lvbnMtcmVsYXRlZCBtZXRob2RzLlxuICovXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHt7IHJlc3RyaWN0ZWRNZXRob2RzOiBTZXQ8c3RyaW5nPiwgaW5pdFN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB9fSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IHJlc3RyaWN0ZWRNZXRob2RzLCBpbml0U3RhdGUgfSkge1xuICAgIHRoaXMucmVzdHJpY3RlZE1ldGhvZHMgPSByZXN0cmljdGVkTWV0aG9kcztcbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICBwZXJtaXNzaW9uSGlzdG9yeToge30sXG4gICAgICBwZXJtaXNzaW9uQWN0aXZpdHlMb2c6IFtdLFxuICAgICAgLi4uaW5pdFN0YXRlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzdHJpY3RlZCBtZXRob2QgYWN0aXZpdHkgbG9nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gVGhlIGFjdGl2aXR5IGxvZy5cbiAgICovXG4gIGdldEFjdGl2aXR5TG9nKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkucGVybWlzc2lvbkFjdGl2aXR5TG9nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcmVzdHJpY3RlZCBtZXRob2QgYWN0aXZpdHkgbG9nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGxvZ3MgLSBUaGUgbmV3IGFjdGl2aXR5IGxvZyBhcnJheS5cbiAgICovXG4gIHVwZGF0ZUFjdGl2aXR5TG9nKGxvZ3MpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgcGVybWlzc2lvbkFjdGl2aXR5TG9nOiBsb2dzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVybWlzc2lvbiBoaXN0b3J5IGxvZy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nLlxuICAgKi9cbiAgZ2V0SGlzdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnBlcm1pc3Npb25IaXN0b3J5O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGVybWlzc2lvbiBoaXN0b3J5IGxvZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpc3RvcnkgLSBUaGUgbmV3IHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nIG9iamVjdC5cbiAgICovXG4gIHVwZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBwZXJtaXNzaW9uSGlzdG9yeTogaGlzdG9yeSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBleHBvc2VkIGFjY291bnQgaGlzdG9yeSBmb3IgdGhlIGdpdmVuIG9yaWdpbi5cbiAgICogU2V0cyB0aGUgJ2xhc3Qgc2VlbicgdGltZSB0byBEYXRlLm5vdygpIGZvciB0aGUgZ2l2ZW4gYWNjb3VudHMuXG4gICAqIERvZXMgKipub3QqKiB1cGRhdGUgdGhlICdsYXN0QXBwcm92ZWQnIHRpbWUgZm9yIHRoZSBwZXJtaXNzaW9uIGl0c2VsZi5cbiAgICogUmV0dXJucyBpZiB0aGUgYWNjb3VudHMgYXJyYXkgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoYXQgdGhlIGFjY291bnRzIGFyZSBleHBvc2VkIHRvLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFjY291bnRzIC0gVGhlIGFjY291bnRzLlxuICAgKi9cbiAgdXBkYXRlQWNjb3VudHNIaXN0b3J5KG9yaWdpbiwgYWNjb3VudHMpIHtcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudFRvVGltZU1hcCA9IGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIERhdGUubm93KCkpO1xuXG4gICAgdGhpcy5jb21taXROZXdIaXN0b3J5KG9yaWdpbiwge1xuICAgICAgZXRoX2FjY291bnRzOiB7XG4gICAgICAgIGFjY291bnRzOiBhY2NvdW50VG9UaW1lTWFwLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwZXJtaXNzaW9ucyBsb2cgbWlkZGxld2FyZS4gUmVjb3JkcyBwZXJtaXNzaW9ucyBhY3Rpdml0eSBhbmQgaGlzdG9yeTpcbiAgICpcbiAgICogQWN0aXZpdHk6IHJlcXVlc3RzIGFuZCByZXNwb25zZXMgZm9yIHJlc3RyaWN0ZWQgYW5kIG1vc3Qgd2FsbGV0XyBtZXRob2RzLlxuICAgKlxuICAgKiBIaXN0b3J5OiBmb3IgZWFjaCBvcmlnaW4sIHRoZSBsYXN0IHRpbWUgYSBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBpbmNsdWRpbmdcbiAgICogd2hpY2ggYWNjb3VudHMgd2VyZSBleHBvc2VkLCBpZiBhbnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtKc29uUnBjRW5naW5lTWlkZGxld2FyZX0gVGhlIHBlcm1pc3Npb25zIGxvZyBtaWRkbGV3YXJlLlxuICAgKi9cbiAgY3JlYXRlTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgICBsZXQgYWN0aXZpdHlFbnRyeSwgcmVxdWVzdGVkTWV0aG9kcztcbiAgICAgIGNvbnN0IHsgb3JpZ2luLCBtZXRob2QgfSA9IHJlcTtcbiAgICAgIGNvbnN0IGlzSW50ZXJuYWwgPSBtZXRob2Quc3RhcnRzV2l0aChXQUxMRVRfUFJFRklYKTtcblxuICAgICAgLy8gd2Ugb25seSBsb2cgY2VydGFpbiBtZXRob2RzXG4gICAgICBpZiAoXG4gICAgICAgICFMT0dfSUdOT1JFX01FVEhPRFMuaW5jbHVkZXMobWV0aG9kKSAmJlxuICAgICAgICAoaXNJbnRlcm5hbCB8fCB0aGlzLnJlc3RyaWN0ZWRNZXRob2RzLmhhcyhtZXRob2QpKVxuICAgICAgKSB7XG4gICAgICAgIGFjdGl2aXR5RW50cnkgPSB0aGlzLmxvZ1JlcXVlc3QocmVxLCBpc0ludGVybmFsKTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSBgJHtXQUxMRVRfUFJFRklYfXJlcXVlc3RQZXJtaXNzaW9uc2ApIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcyBmcm9tIHRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgc29cbiAgICAgICAgICAvLyB0aGF0IHdlIGNhbiByZWNvcmQgcGVybWlzc2lvbnMgaGlzdG9yeVxuICAgICAgICAgIHJlcXVlc3RlZE1ldGhvZHMgPSB0aGlzLmdldFJlcXVlc3RlZE1ldGhvZHMocmVxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJykge1xuICAgICAgICAvLyBldGhfcmVxdWVzdEFjY291bnRzIGlzIGEgc3BlY2lhbCBjYXNlOyB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGFjY291bnRzXG4gICAgICAgIC8vIGZyb20gaXRcbiAgICAgICAgYWN0aXZpdHlFbnRyeSA9IHRoaXMubG9nUmVxdWVzdChyZXEsIGlzSW50ZXJuYWwpO1xuICAgICAgICByZXF1ZXN0ZWRNZXRob2RzID0gWydldGhfYWNjb3VudHMnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vLW9wXG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIG5leHQgd2l0aCBhIHJldHVybiBoYW5kbGVyIGZvciBjYXB0dXJpbmcgdGhlIHJlc3BvbnNlXG4gICAgICBuZXh0KChjYikgPT4ge1xuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5sb2dSZXNwb25zZShhY3Rpdml0eUVudHJ5LCByZXMsIHRpbWUpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRNZXRob2RzICYmICFyZXMuZXJyb3IgJiYgcmVzLnJlc3VsdCkge1xuICAgICAgICAgIC8vIGFueSBwZXJtaXNzaW9ucyBvciBhY2NvdW50cyBjaGFuZ2VzIHdpbGwgYmUgcmVjb3JkZWQgb24gdGhlIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIHNvIHdlIG9ubHkgbG9nIHBlcm1pc3Npb25zIGhpc3RvcnkgaGVyZVxuICAgICAgICAgIHRoaXMubG9nUGVybWlzc2lvbnNIaXN0b3J5KFxuICAgICAgICAgICAgcmVxdWVzdGVkTWV0aG9kcyxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHJlcy5yZXN1bHQsXG4gICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgbWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBjb21taXRzIGFuIGFjdGl2aXR5IGxvZyBlbnRyeSwgd2l0aG91dCByZXNwb25zZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ludGVybmFsIC0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBpbnRlcm5hbC5cbiAgICovXG4gIGxvZ1JlcXVlc3QocmVxdWVzdCwgaXNJbnRlcm5hbCkge1xuICAgIGNvbnN0IGFjdGl2aXR5RW50cnkgPSB7XG4gICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICBtZXRob2RUeXBlOiBpc0ludGVybmFsXG4gICAgICAgID8gTE9HX01FVEhPRF9UWVBFUy5pbnRlcm5hbFxuICAgICAgICA6IExPR19NRVRIT0RfVFlQRVMucmVzdHJpY3RlZCxcbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0OiBzdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMiksXG4gICAgICByZXF1ZXN0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgICAgcmVzcG9uc2VUaW1lOiBudWxsLFxuICAgICAgc3VjY2VzczogbnVsbCxcbiAgICB9O1xuICAgIHRoaXMuY29tbWl0TmV3QWN0aXZpdHkoYWN0aXZpdHlFbnRyeSk7XG4gICAgcmV0dXJuIGFjdGl2aXR5RW50cnk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZXNwb25zZSBkYXRhIHRvIGFuIGV4aXN0aW5nIGFjdGl2aXR5IGxvZyBlbnRyeS5cbiAgICogRW50cnkgYXNzdW1lZCBhbHJlYWR5IGNvbW1pdHRlZCAoaS5lLiwgaW4gdGhlIGxvZykuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIFRoZSBlbnRyeSB0byBhZGQgYSByZXNwb25zZSB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBPdXRwdXQgZnJvbSBEYXRlLm5vdygpXG4gICAqL1xuICBsb2dSZXNwb25zZShlbnRyeSwgcmVzcG9uc2UsIHRpbWUpIHtcbiAgICBpZiAoIWVudHJ5IHx8ICFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVudHJ5LnJlc3BvbnNlID0gc3RyaW5naWZ5KHJlc3BvbnNlLCBudWxsLCAyKTtcbiAgICBlbnRyeS5yZXNwb25zZVRpbWUgPSB0aW1lO1xuICAgIGVudHJ5LnN1Y2Nlc3MgPSAhcmVzcG9uc2UuZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ29tbWl0IGEgbmV3IGVudHJ5IHRvIHRoZSBhY3Rpdml0eSBsb2cuXG4gICAqIFJlbW92ZXMgdGhlIG9sZGVzdCBlbnRyeSBmcm9tIHRoZSBsb2cgaWYgaXQgZXhjZWVkcyB0aGUgbG9nIGxpbWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBUaGUgYWN0aXZpdHkgbG9nIGVudHJ5LlxuICAgKi9cbiAgY29tbWl0TmV3QWN0aXZpdHkoZW50cnkpIHtcbiAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRBY3Rpdml0eUxvZygpO1xuXG4gICAgLy8gYWRkIG5ldyBlbnRyeSB0byBlbmQgb2YgbG9nXG4gICAgbG9ncy5wdXNoKGVudHJ5KTtcblxuICAgIC8vIHJlbW92ZSBvbGRlc3QgbG9nIGlmIGV4Y2VlZGluZyBzaXplIGxpbWl0XG4gICAgaWYgKGxvZ3MubGVuZ3RoID4gTE9HX0xJTUlUKSB7XG4gICAgICBsb2dzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBY3Rpdml0eUxvZyhsb2dzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nIGVudHJpZXMsIGlmIGFueSwgYW5kIGNvbW1pdCB0aGVtLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHJlcXVlc3RlZE1ldGhvZHMgLSBUaGUgbWV0aG9kIG5hbWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7QXJyYXk8SU9jYXBMZENhcGFiaWxpdHl9IHJlc3VsdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0IHJlc3BvbnNlLnJlc3VsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWUgLSBUaGUgdGltZSBvZiB0aGUgcmVxdWVzdCwgaS5lLiBEYXRlLm5vdygpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXRoUmVxdWVzdEFjY291bnRzIC0gV2hldGhlciB0aGUgcGVybWlzc2lvbnMgcmVxdWVzdCB3YXMgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLlxuICAgKi9cbiAgbG9nUGVybWlzc2lvbnNIaXN0b3J5KFxuICAgIHJlcXVlc3RlZE1ldGhvZHMsXG4gICAgb3JpZ2luLFxuICAgIHJlc3VsdCxcbiAgICB0aW1lLFxuICAgIGlzRXRoUmVxdWVzdEFjY291bnRzLFxuICApIHtcbiAgICBsZXQgYWNjb3VudHMsIG5ld0VudHJpZXM7XG5cbiAgICBpZiAoaXNFdGhSZXF1ZXN0QWNjb3VudHMpIHtcbiAgICAgIGFjY291bnRzID0gcmVzdWx0O1xuICAgICAgY29uc3QgYWNjb3VudFRvVGltZU1hcCA9IGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIHRpbWUpO1xuXG4gICAgICBuZXdFbnRyaWVzID0ge1xuICAgICAgICBldGhfYWNjb3VudHM6IHtcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFRvVGltZU1hcCxcbiAgICAgICAgICBsYXN0QXBwcm92ZWQ6IHRpbWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmRzIG5ldyBcImxhc3RBcHByb3ZlZFwiIHRpbWVzIGZvciB0aGUgZ3JhbnRlZCBwZXJtaXNzaW9ucywgaWYgYW55LlxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgZXRoX2FjY291bnRzLCBpbiBvcmRlciB0byByZWNvcmQgdGhlIHRpbWUgdGhlXG4gICAgICAvLyBhY2NvdW50cyB3ZXJlIGxhc3Qgc2VlbiBvciBhcHByb3ZlZCBieSB0aGUgb3JpZ2luLlxuICAgICAgbmV3RW50cmllcyA9IHJlc3VsdFxuICAgICAgICAubWFwKChwZXJtKSA9PiB7XG4gICAgICAgICAgaWYgKHBlcm0ucGFyZW50Q2FwYWJpbGl0eSA9PT0gJ2V0aF9hY2NvdW50cycpIHtcbiAgICAgICAgICAgIGFjY291bnRzID0gdGhpcy5nZXRBY2NvdW50c0Zyb21QZXJtaXNzaW9uKHBlcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwZXJtLnBhcmVudENhcGFiaWxpdHk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgbWV0aG9kKSA9PiB7XG4gICAgICAgICAgLy8gYWxsIGFwcHJvdmVkIHBlcm1pc3Npb25zIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIG5vdCBqdXN0IHRoZSBuZXdseSByZXF1ZXN0ZWQgb25lc1xuICAgICAgICAgIGlmIChyZXF1ZXN0ZWRNZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdldGhfYWNjb3VudHMnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjY291bnRUb1RpbWVNYXAgPSBnZXRBY2NvdW50VG9UaW1lTWFwKGFjY291bnRzLCB0aW1lKTtcblxuICAgICAgICAgICAgICBhY2NbbWV0aG9kXSA9IHtcbiAgICAgICAgICAgICAgICBsYXN0QXBwcm92ZWQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRUb1RpbWVNYXAsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY2NbbWV0aG9kXSA9IHsgbGFzdEFwcHJvdmVkOiB0aW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhuZXdFbnRyaWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbW1pdE5ld0hpc3Rvcnkob3JpZ2luLCBuZXdFbnRyaWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tbWl0IG5ldyBlbnRyaWVzIHRvIHRoZSBwZXJtaXNzaW9ucyBoaXN0b3J5IGxvZy5cbiAgICogTWVyZ2VzIHRoZSBoaXN0b3J5IGZvciB0aGUgZ2l2ZW4gb3JpZ2luLCBvdmVyd3JpdGluZyBleGlzdGluZyBlbnRyaWVzXG4gICAqIHdpdGggdGhlIHNhbWUga2V5IChwZXJtaXNzaW9uIG5hbWUpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIHJlcXVlc3Rpbmcgb3JpZ2luLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RW50cmllcyAtIFRoZSBuZXcgZW50cmllcyB0byBjb21taXQuXG4gICAqL1xuICBjb21taXROZXdIaXN0b3J5KG9yaWdpbiwgbmV3RW50cmllcykge1xuICAgIC8vIGEgc2ltcGxlIG1lcmdlIHVwZGF0ZXMgbW9zdCBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IGhpc3RvcnkgPSB0aGlzLmdldEhpc3RvcnkoKTtcbiAgICBjb25zdCBuZXdPcmlnaW5IaXN0b3J5ID0ge1xuICAgICAgLi4uaGlzdG9yeVtvcmlnaW5dLFxuICAgICAgLi4ubmV3RW50cmllcyxcbiAgICB9O1xuXG4gICAgLy8gZXRoX2FjY291bnRzIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmcsIGJlY2F1c2Ugb2YgaW5mb3JtYXRpb25cbiAgICAvLyB3ZSBzdG9yZSBhYm91dCB0aGUgYWNjb3VudHNcbiAgICBjb25zdCBleGlzdGluZ0V0aEFjY291bnRzRW50cnkgPVxuICAgICAgaGlzdG9yeVtvcmlnaW5dICYmIGhpc3Rvcnlbb3JpZ2luXS5ldGhfYWNjb3VudHM7XG4gICAgY29uc3QgbmV3RXRoQWNjb3VudHNFbnRyeSA9IG5ld0VudHJpZXMuZXRoX2FjY291bnRzO1xuXG4gICAgaWYgKGV4aXN0aW5nRXRoQWNjb3VudHNFbnRyeSAmJiBuZXdFdGhBY2NvdW50c0VudHJ5KSB7XG4gICAgICAvLyB3ZSBtYXkgaW50ZW5kIHRvIHVwZGF0ZSBqdXN0IHRoZSBhY2NvdW50cywgbm90IHRoZSBwZXJtaXNzaW9uXG4gICAgICAvLyBpdHNlbGZcbiAgICAgIGNvbnN0IGxhc3RBcHByb3ZlZCA9XG4gICAgICAgIG5ld0V0aEFjY291bnRzRW50cnkubGFzdEFwcHJvdmVkIHx8XG4gICAgICAgIGV4aXN0aW5nRXRoQWNjb3VudHNFbnRyeS5sYXN0QXBwcm92ZWQ7XG5cbiAgICAgIC8vIG1lcmdlIG9sZCBhbmQgbmV3IGV0aF9hY2NvdW50cyBoaXN0b3J5IGVudHJpZXNcbiAgICAgIG5ld09yaWdpbkhpc3RvcnkuZXRoX2FjY291bnRzID0ge1xuICAgICAgICBsYXN0QXBwcm92ZWQsXG4gICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgLi4uZXhpc3RpbmdFdGhBY2NvdW50c0VudHJ5LmFjY291bnRzLFxuICAgICAgICAgIC4uLm5ld0V0aEFjY291bnRzRW50cnkuYWNjb3VudHMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGhpc3Rvcnlbb3JpZ2luXSA9IG5ld09yaWdpbkhpc3Rvcnk7XG5cbiAgICB0aGlzLnVwZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCByZXF1ZXN0ZWQgbWV0aG9kcyBmcm9tIGEgcGVybWlzc2lvbnMgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBUaGUgbmFtZXMgb2YgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIGdldFJlcXVlc3RlZE1ldGhvZHMocmVxdWVzdCkge1xuICAgIGlmIChcbiAgICAgICFyZXF1ZXN0LnBhcmFtcyB8fFxuICAgICAgIXJlcXVlc3QucGFyYW1zWzBdIHx8XG4gICAgICB0eXBlb2YgcmVxdWVzdC5wYXJhbXNbMF0gIT09ICdvYmplY3QnIHx8XG4gICAgICBBcnJheS5pc0FycmF5KHJlcXVlc3QucGFyYW1zWzBdKVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXF1ZXN0LnBhcmFtc1swXSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJtaXR0ZWQgYWNjb3VudHMgZnJvbSBhbiBldGhfYWNjb3VudHMgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZSBwZXJtaXNzaW9uIGlzIG5vdCBldGhfYWNjb3VudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwZXJtIC0gVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59IFRoZSBwZXJtaXR0ZWQgYWNjb3VudHMuXG4gICAqL1xuICBnZXRBY2NvdW50c0Zyb21QZXJtaXNzaW9uKHBlcm0pIHtcbiAgICBpZiAocGVybS5wYXJlbnRDYXBhYmlsaXR5ICE9PSAnZXRoX2FjY291bnRzJyB8fCAhcGVybS5jYXZlYXRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBjYXZlYXQgb2YgcGVybS5jYXZlYXRzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhdmVhdC50eXBlID09PSBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShjYXZlYXQudmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjYXZlYXQudmFsdWUpIHtcbiAgICAgICAgICBhY2NvdW50cy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWNjb3VudHNdO1xuICB9XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbnNcblxuLyoqXG4gKiBHZXQgYSBtYXAgZnJvbSBhY2NvdW50IGFkZHJlc3NlcyB0byB0aGUgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFjY291bnRzIC0gQW4gYXJyYXkgb2YgYWRkcmVzc2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBBIHRpbWUsIGUuZy4gRGF0ZS5ub3coKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgc3RyaW5nOm51bWJlciBtYXAgb2YgYWRkcmVzc2VzIHRvIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIHRpbWUpIHtcbiAgcmV0dXJuIGFjY291bnRzLnJlZHVjZSgoYWNjLCBhY2NvdW50KSA9PiAoeyAuLi5hY2MsIFthY2NvdW50XTogdGltZSB9KSwge30pO1xufVxuIiwiaW1wb3J0IG5hbm9pZCBmcm9tICduYW5vaWQnO1xuaW1wb3J0IHtcbiAgQ2F2ZWF0VHlwZXMsXG4gIFJlc3RyaWN0ZWRNZXRob2RzLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25CYWNrZ3JvdW5kQXBpTWV0aG9kcyhwZXJtaXNzaW9uQ29udHJvbGxlcikge1xuICByZXR1cm4ge1xuICAgIGFkZFBlcm1pdHRlZEFjY291bnQ6IChvcmlnaW4sIGFjY291bnQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0Q2F2ZWF0KFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICAgQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgKTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnZhbHVlLmluY2x1ZGVzKGFjY291bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgZXRoX2FjY291bnRzIHBlcm1pc3Npb24gZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGFscmVhZHkgcGVybWl0cyBhY2NvdW50IFwiJHthY2NvdW50fVwiLmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdChcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXG4gICAgICAgIENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyxcbiAgICAgICAgWy4uLmV4aXN0aW5nLnZhbHVlLCBhY2NvdW50XSxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJlbW92ZVBlcm1pdHRlZEFjY291bnQ6IChvcmlnaW4sIGFjY291bnQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0Q2F2ZWF0KFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICAgQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgKTtcblxuICAgICAgaWYgKCFleGlzdGluZy52YWx1ZS5pbmNsdWRlcyhhY2NvdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uIGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBhbHJlYWR5IGRvZXMgbm90IHBlcm1pdCBhY2NvdW50IFwiJHthY2NvdW50fVwiLmAsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbWFpbmluZ0FjY291bnRzID0gZXhpc3RpbmcudmFsdWUuZmlsdGVyKFxuICAgICAgICAoZXhpc3RpbmdBY2NvdW50KSA9PiBleGlzdGluZ0FjY291bnQgIT09IGFjY291bnQsXG4gICAgICApO1xuXG4gICAgICBpZiAocmVtYWluaW5nQWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLnJldm9rZVBlcm1pc3Npb24oXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdChcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICAgICAgICAgIENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyxcbiAgICAgICAgICByZW1haW5pbmdBY2NvdW50cyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVxdWVzdEFjY291bnRzUGVybWlzc2lvbldpdGhJZDogYXN5bmMgKG9yaWdpbikgPT4ge1xuICAgICAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9ucyhcbiAgICAgICAgeyBvcmlnaW4gfSxcbiAgICAgICAge1xuICAgICAgICAgIGV0aF9hY2NvdW50czoge30sXG4gICAgICAgIH0sXG4gICAgICAgIHsgaWQgfSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGNvbnN0cnVjdFBlcm1pc3Npb24sXG4gIFBlcm1pc3Npb25UeXBlLFxufSBmcm9tICdAbWV0YW1hc2svc25hcC1jb250cm9sbGVycyc7XG5pbXBvcnQge1xuICBDYXZlYXRUeXBlcyxcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMnO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgc3BlY2lmaWNhdGlvbnMgb2YgdGhlIHBlcm1pc3Npb25zIGFuZCBjYXZlYXRzXG4gKiB0aGF0IGFyZSByZWNvZ25pemVkIGJ5IG91ciBwZXJtaXNzaW9uIHN5c3RlbS4gU2VlIHRoZSBQZXJtaXNzaW9uQ29udHJvbGxlclxuICogUkVBRE1FIGluIEBtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzIGZvciBkZXRhaWxzLlxuICovXG5cbi8qKlxuICogVGhlIFwia2V5c1wiIG9mIGFsbCBvZiBwZXJtaXNzaW9ucyByZWNvZ25pemVkIGJ5IHRoZSBQZXJtaXNzaW9uQ29udHJvbGxlci5cbiAqIFBlcm1pc3Npb24ga2V5cyBhbmQgbmFtZXMgaGF2ZSBkaXN0aW5jdCBtZWFuaW5ncyBpbiB0aGUgcGVybWlzc2lvbiBzeXN0ZW0uXG4gKi9cbmNvbnN0IFBlcm1pc3Npb25LZXlzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLlJlc3RyaWN0ZWRNZXRob2RzLFxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbnMgZm9yIGFsbCBjYXZlYXQgdHlwZXMgcmVjb2duaXplZCBieSB0aGVcbiAqIFBlcm1pc3Npb25Db250cm9sbGVyLlxuICovXG5jb25zdCBDYXZlYXRGYWN0b3JpZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgW0NhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50c106IChhY2NvdW50cykgPT4ge1xuICAgIHJldHVybiB7IHR5cGU6IENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50cywgdmFsdWU6IGFjY291bnRzIH07XG4gIH0sXG59KTtcblxuLyoqXG4gKiBBIFByZWZlcmVuY2VzQ29udHJvbGxlciBpZGVudGl0eSBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gSWRlbnRpdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGlkZW50aXR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaWRlbnRpdHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RTZWxlY3RlZF0gLSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBpZGVudGl0eSB3YXNcbiAqIGxhc3Qgc2VsZWN0ZWQgaW4gdGhlIFVJLlxuICovXG5cbi8qKlxuICogR2V0cyB0aGUgc3BlY2lmaWNhdGlvbnMgZm9yIGFsbCBjYXZlYXRzIHRoYXQgd2lsbCBiZSByZWNvZ25pemVkIGJ5IHRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIuXG4gKlxuICogQHBhcmFtIHt7XG4gKiAgIGdldElkZW50aXRpZXM6ICgpID0+IFJlY29yZDxzdHJpbmcsIElkZW50aXR5PixcbiAqIH19IG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENhdmVhdFNwZWNpZmljYXRpb25zID0gKHsgZ2V0SWRlbnRpdGllcyB9KSA9PiB7XG4gIHJldHVybiB7XG4gICAgW0NhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50c106IHtcbiAgICAgIHR5cGU6IENhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyxcblxuICAgICAgZGVjb3JhdG9yOiAobWV0aG9kLCBjYXZlYXQpID0+IHtcbiAgICAgICAgcmV0dXJuIGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWV0aG9kKGFyZ3MpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIC5maWx0ZXIoKGFjY291bnQpID0+IGNhdmVhdC52YWx1ZS5pbmNsdWRlcyhhY2NvdW50KSlcbiAgICAgICAgICAgIC5zbGljZSgwLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHZhbGlkYXRvcjogKGNhdmVhdCwgX29yaWdpbiwgX3RhcmdldCkgPT5cbiAgICAgICAgdmFsaWRhdGVDYXZlYXRBY2NvdW50cyhjYXZlYXQudmFsdWUsIGdldElkZW50aXRpZXMpLFxuICAgIH0sXG4gIH07XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNwZWNpZmljYXRpb25zIGZvciBhbGwgcGVybWlzc2lvbnMgdGhhdCB3aWxsIGJlIHJlY29nbml6ZWQgYnkgdGhlXG4gKiBQZXJtaXNzaW9uQ29udHJvbGxlci5cbiAqXG4gKiBAcGFyYW0ge3tcbiAqICAgZ2V0QWxsQWNjb3VudHM6ICgpID0+IFByb21pc2U8c3RyaW5nW10+LFxuICogICBnZXRJZGVudGl0aWVzOiAoKSA9PiBSZWNvcmQ8c3RyaW5nLCBJZGVudGl0eT4sXG4gKiB9fSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gKiBAcGFyYW0gb3B0aW9ucy5nZXRBbGxBY2NvdW50cyAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFsbCBFdGhlcmV1bSBhY2NvdW50c1xuICogaW4gdGhlIGN1cnJlbnQgTWV0YU1hc2sgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb3B0aW9ucy5nZXRJZGVudGl0aWVzIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gKiBgUHJlZmVyZW5jZXNDb250cm9sbGVyYCBpZGVudGl0eSBvYmplY3RzIGZvciBhbGwgRXRoZXJldW0gYWNjb3VudHMgaW4gdGhlXG4gKiBAcGFyYW0gb3B0aW9ucy5jYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzIC0gQSBmdW5jdGlvbiB0aGF0XG4gKiBjYXB0dXJlcyBleHRyYSBlcnJvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgXCJNaXNzaW5nIGlkZW50aXR5IGZvciBhZGRyZXNzXCJcbiAqIGVycm9yLlxuICogY3VycmVudCBNZXRhTWFzayBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyA9ICh7XG4gIGdldEFsbEFjY291bnRzLFxuICBnZXRJZGVudGl0aWVzLFxuICBjYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzLFxufSkgPT4ge1xuICByZXR1cm4ge1xuICAgIFtQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHNdOiB7XG4gICAgICBwZXJtaXNzaW9uVHlwZTogUGVybWlzc2lvblR5cGUuUmVzdHJpY3RlZE1ldGhvZCxcbiAgICAgIHRhcmdldEtleTogUGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzLFxuICAgICAgYWxsb3dlZENhdmVhdHM6IFtDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNdLFxuXG4gICAgICBmYWN0b3J5OiAocGVybWlzc2lvbk9wdGlvbnMsIHJlcXVlc3REYXRhKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBlcm1pc3Npb25PcHRpb25zLmNhdmVhdHMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7UGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzfSBlcnJvcjogUmVjZWl2ZWQgdW5leHBlY3RlZCBjYXZlYXRzLiBBbnkgcGVybWl0dGVkIGNhdmVhdHMgd2lsbCBiZSBhZGRlZCBhdXRvbWF0aWNhbGx5LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgdmFsdWUgd2lsbCBiZSBmdXJ0aGVyIHZhbGlkYXRlZCBhcyBwYXJ0IG9mIHRoZSBjYXZlYXQuXG4gICAgICAgIGlmICghcmVxdWVzdERhdGEuYXBwcm92ZWRBY2NvdW50cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke1Blcm1pc3Npb25LZXlzLmV0aF9hY2NvdW50c30gZXJyb3I6IE5vIGFwcHJvdmVkIGFjY291bnRzIHNwZWNpZmllZC5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uc3RydWN0UGVybWlzc2lvbih7XG4gICAgICAgICAgLi4ucGVybWlzc2lvbk9wdGlvbnMsXG4gICAgICAgICAgY2F2ZWF0czogW1xuICAgICAgICAgICAgQ2F2ZWF0RmFjdG9yaWVzW0NhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50c10oXG4gICAgICAgICAgICAgIHJlcXVlc3REYXRhLmFwcHJvdmVkQWNjb3VudHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kSW1wbGVtZW50YXRpb246IGFzeW5jIChfYXJncykgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFsbEFjY291bnRzKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aXRpZXMgPSBnZXRJZGVudGl0aWVzKCk7XG5cbiAgICAgICAgcmV0dXJuIGFjY291bnRzLnNvcnQoKGZpcnN0QWRkcmVzcywgc2Vjb25kQWRkcmVzcykgPT4ge1xuICAgICAgICAgIGlmICghaWRlbnRpdGllc1tmaXJzdEFkZHJlc3NdKSB7XG4gICAgICAgICAgICBjYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzKGlkZW50aXRpZXMsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBpZGVudGl0eSBmb3IgYWRkcmVzczogXCIke2ZpcnN0QWRkcmVzc31cIi5gKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpZGVudGl0aWVzW3NlY29uZEFkZHJlc3NdKSB7XG4gICAgICAgICAgICBjYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzKGlkZW50aXRpZXMsIGFjY291bnRzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYE1pc3NpbmcgaWRlbnRpdHkgZm9yIGFkZHJlc3M6IFwiJHtzZWNvbmRBZGRyZXNzfVwiLmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBpZGVudGl0aWVzW2ZpcnN0QWRkcmVzc10ubGFzdFNlbGVjdGVkID09PVxuICAgICAgICAgICAgaWRlbnRpdGllc1tzZWNvbmRBZGRyZXNzXS5sYXN0U2VsZWN0ZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaWRlbnRpdGllc1tmaXJzdEFkZHJlc3NdLmxhc3RTZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlkZW50aXRpZXNbc2Vjb25kQWRkcmVzc10ubGFzdFNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaWRlbnRpdGllc1tzZWNvbmRBZGRyZXNzXS5sYXN0U2VsZWN0ZWQgLVxuICAgICAgICAgICAgaWRlbnRpdGllc1tmaXJzdEFkZHJlc3NdLmxhc3RTZWxlY3RlZFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgdmFsaWRhdG9yOiAocGVybWlzc2lvbiwgX29yaWdpbiwgX3RhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhY2F2ZWF0cyB8fFxuICAgICAgICAgIGNhdmVhdHMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgY2F2ZWF0c1swXS50eXBlICE9PSBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7UGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzfSBlcnJvcjogSW52YWxpZCBjYXZlYXRzLiBUaGVyZSBtdXN0IGJlIGEgc2luZ2xlIGNhdmVhdCBvZiB0eXBlIFwiJHtDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHN9XCIuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gIH07XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgYWNjb3VudHMgYXNzb2NpYXRlZCB3aXRoIGEgY2F2ZWF0LiBJbiBlc3NlbmNlLCBlbnN1cmVzIHRoYXRcbiAqIHRoZSBhY2NvdW50cyB2YWx1ZSBpcyBhbiBhcnJheSBvZiBub24tZW1wdHkgc3RyaW5ncywgYW5kIHRoYXQgZWFjaCBzdHJpbmdcbiAqIGNvcnJlc3BvbmRzIHRvIGEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGlkZW50aXR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjY291bnRzIC0gVGhlIGFjY291bnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2F2ZWF0LlxuICogQHBhcmFtIHsoKSA9PiBSZWNvcmQ8c3RyaW5nLCBJZGVudGl0eT59IGdldElkZW50aXRpZXMgLSBHZXRzIGFsbFxuICogUHJlZmVyZW5jZXNDb250cm9sbGVyIGlkZW50aXRpZXMuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2F2ZWF0QWNjb3VudHMoYWNjb3VudHMsIGdldElkZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFjY291bnRzKSB8fCBhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHN9IGVycm9yOiBFeHBlY3RlZCBub24tZW1wdHkgYXJyYXkgb2YgRXRoZXJldW0gYWRkcmVzc2VzLmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGlkZW50aXRpZXMgPSBnZXRJZGVudGl0aWVzKCk7XG4gIGFjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICBpZiAoIWFkZHJlc3MgfHwgdHlwZW9mIGFkZHJlc3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke1Blcm1pc3Npb25LZXlzLmV0aF9hY2NvdW50c30gZXJyb3I6IEV4cGVjdGVkIGFuIGFycmF5IG9mIEV0aGVyZXVtIGFkZHJlc3Nlcy4gUmVjZWl2ZWQ6IFwiJHthZGRyZXNzfVwiLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaWRlbnRpdGllc1thZGRyZXNzXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHN9IGVycm9yOiBSZWNlaXZlZCB1bnJlY29nbml6ZWQgYWRkcmVzczogXCIke2FkZHJlc3N9XCIuYCxcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBBbGwgdW5yZXN0cmljdGVkIG1ldGhvZHMgcmVjb2duaXplZCBieSB0aGUgUGVybWlzc2lvbkNvbnRyb2xsZXIuXG4gKiBVbnJlc3RyaWN0ZWQgbWV0aG9kcyBhcmUgaWdub3JlZCBieSB0aGUgcGVybWlzc2lvbiBzeXN0ZW0sIGJ1dCBldmVyeVxuICogSlNPTi1SUEMgcmVxdWVzdCBzZWVuIGJ5IHRoZSBwZXJtaXNzaW9uIHN5c3RlbSBtdXN0IGNvcnJlc3BvbmQgdG8gYVxuICogcmVzdHJpY3RlZCBvciB1bnJlc3RyaWN0ZWQgbWV0aG9kLCBvciB0aGUgcmVxdWVzdCB3aWxsIGJlIHJlamVjdGVkIHdpdGggYVxuICogXCJtZXRob2Qgbm90IGZvdW5kXCIgZXJyb3IuXG4gKi9cbmV4cG9ydCBjb25zdCB1bnJlc3RyaWN0ZWRNZXRob2RzID0gT2JqZWN0LmZyZWV6ZShbXG4gICdldGhfYmxvY2tOdW1iZXInLFxuICAnZXRoX2NhbGwnLFxuICAnZXRoX2NoYWluSWQnLFxuICAnZXRoX2NvaW5iYXNlJyxcbiAgJ2V0aF9kZWNyeXB0JyxcbiAgJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICdldGhfZmVlSGlzdG9yeScsXG4gICdldGhfZ2FzUHJpY2UnLFxuICAnZXRoX2dldEJhbGFuY2UnLFxuICAnZXRoX2dldEJsb2NrQnlIYXNoJyxcbiAgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnLFxuICAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJyxcbiAgJ2V0aF9nZXRDb2RlJyxcbiAgJ2V0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5JyxcbiAgJ2V0aF9nZXRGaWx0ZXJDaGFuZ2VzJyxcbiAgJ2V0aF9nZXRGaWx0ZXJMb2dzJyxcbiAgJ2V0aF9nZXRMb2dzJyxcbiAgJ2V0aF9nZXRQcm9vZicsXG4gICdldGhfZ2V0U3RvcmFnZUF0JyxcbiAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnLFxuICAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JyxcbiAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsXG4gICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnLFxuICAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JyxcbiAgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnLFxuICAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJyxcbiAgJ2V0aF9nZXRXb3JrJyxcbiAgJ2V0aF9oYXNocmF0ZScsXG4gICdldGhfbWluaW5nJyxcbiAgJ2V0aF9uZXdCbG9ja0ZpbHRlcicsXG4gICdldGhfbmV3RmlsdGVyJyxcbiAgJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInLFxuICAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAnZXRoX3NpZ24nLFxuICAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAnZXRoX3NpZ25UeXBlZERhdGFfdjEnLFxuICAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICAnZXRoX3N1Ym1pdEhhc2hyYXRlJyxcbiAgJ2V0aF9zdWJtaXRXb3JrJyxcbiAgJ2V0aF9zeW5jaW5nJyxcbiAgJ2V0aF91bmluc3RhbGxGaWx0ZXInLFxuICAnbWV0YW1hc2tfZ2V0UHJvdmlkZXJTdGF0ZScsXG4gICdtZXRhbWFza193YXRjaEFzc2V0JyxcbiAgJ25ldF9saXN0ZW5pbmcnLFxuICAnbmV0X3BlZXJDb3VudCcsXG4gICduZXRfdmVyc2lvbicsXG4gICdwZXJzb25hbF9lY1JlY292ZXInLFxuICAncGVyc29uYWxfc2lnbicsXG4gICd3YWxsZXRfd2F0Y2hBc3NldCcsXG4gICd3ZWIzX2NsaWVudFZlcnNpb24nLFxuICAnd2ViM19zaGEzJyxcbl0pO1xuIiwiLyoqXG4gKiBSZXR1cm5zIGVycm9yIHdpdGhvdXQgc3RhY2sgdHJhY2UgZm9yIGJldHRlciBVSSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gZXJyb3JcbiAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3Igd2l0aCBjbGVhbiBzdGFjayB0cmFjZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xlYW5FcnJvclN0YWNrKGVycikge1xuICBsZXQgeyBuYW1lIH0gPSBlcnI7XG4gIG5hbWUgPSBuYW1lID09PSB1bmRlZmluZWQgPyAnRXJyb3InIDogU3RyaW5nKG5hbWUpO1xuXG4gIGxldCBtc2cgPSBlcnIubWVzc2FnZTtcbiAgbXNnID0gbXNnID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhtc2cpO1xuXG4gIGlmIChuYW1lID09PSAnJykge1xuICAgIGVyci5zdGFjayA9IGVyci5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKG1zZyA9PT0gJycpIHtcbiAgICBlcnIuc3RhY2sgPSBlcnIubmFtZTtcbiAgfSBlbHNlIGlmICghZXJyLnN0YWNrKSB7XG4gICAgZXJyLnN0YWNrID0gYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWA7XG4gIH1cblxuICByZXR1cm4gZXJyO1xufVxuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGhqcy1xdWVyeScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgTXV0ZXggPSByZXF1aXJlKCdhd2FpdC1zZW1hcGhvcmUnKS5NdXRleFxuLyoqXG4gIEBwYXJhbSBvcHRzIHtPYmplY3R9XG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvdmlkZXIgYSBldGhlcmV1bSBwcm92aWRlclxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB0eE1ldGFcbiAgICB3aG9zZWUgc3RhdHVzIGlzIGBzdWJtaXR0ZWRgXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdHhNZXRhXG4gICAgd2hvc2Ugc3RhdHVzIGlzIGBjb25maXJtZWRgXG4gIEBjbGFzc1xuKi9cbmNsYXNzIE5vbmNlVHJhY2tlciB7XG5cbiAgY29uc3RydWN0b3IgKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucywgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICB0aGlzLmJsb2NrVHJhY2tlciA9IGJsb2NrVHJhY2tlclxuICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgRXRoUXVlcnkocHJvdmlkZXIpXG4gICAgdGhpcy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zID0gZ2V0UGVuZGluZ1RyYW5zYWN0aW9uc1xuICAgIHRoaXMuZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zID0gZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zXG4gICAgdGhpcy5sb2NrTWFwID0ge31cbiAgfVxuXG4gIC8qKlxuICAgIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IHdpdGggdGhlIGtleSByZWxlYXNlTG9jayAodGhlIGdsb2FibCBtdXRleClcbiAgKi9cbiAgYXN5bmMgZ2V0R2xvYmFsTG9jayAoKSB7XG4gICAgY29uc3QgZ2xvYmFsTXV0ZXggPSB0aGlzLl9sb29rdXBNdXRleCgnZ2xvYmFsJylcbiAgICAvLyBhd2FpdCBnbG9iYWwgbXV0ZXggZnJlZVxuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgZ2xvYmFsTXV0ZXguYWNxdWlyZSgpXG4gICAgcmV0dXJuIHsgcmVsZWFzZUxvY2sgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIE5vbmNlRGV0YWlsc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGlnaGVzdExvY2FsbHlDb25maXJtZWQgLSBBIGhleCBzdHJpbmcgb2YgdGhlIGhpZ2hlc3Qgbm9uY2Ugb24gYSBjb25maXJtZWQgdHJhbnNhY3Rpb24uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0TmV0d29ya05vbmNlIC0gVGhlIG5leHQgbm9uY2Ugc3VnZ2VzdGVkIGJ5IHRoZSBldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCBtZXRob2QuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoZXN0U3VnZ2VzdGVkIC0gVGhlIG1heGltdW0gYmV0d2VlbiB0aGUgb3RoZXIgdHdvLCB0aGUgbnVtYmVyIHJldHVybmVkLlxuICAgKi9cblxuICAvKipcbiAgdGhpcyB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgYG5leHROb25jZWAgYG5vbmNlRGV0YWlsc2AsIGFuZCB0aGUgcmVsZWFzZUxvY2tcbiAgTm90ZTogcmVsZWFzZUxvY2sgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGEgc2lnbmVkIHR4IHRvIHBlbmRpbmcgdHJhbnNhY3Rpb25zIChvciBkaXNjYXJkaW5nKS5cblxuICBAcGFyYW0gYWRkcmVzcyB7c3RyaW5nfSB0aGUgaGV4IHN0cmluZyBmb3IgdGhlIGFkZHJlc3Mgd2hvc2Ugbm9uY2Ugd2UgYXJlIGNhbGN1bGF0aW5nXG4gIEByZXR1cm5zIHtQcm9taXNlPE5vbmNlRGV0YWlscz59XG4gICovXG4gIGFzeW5jIGdldE5vbmNlTG9jayAoYWRkcmVzcykge1xuICAgIC8vIGF3YWl0IGdsb2JhbCBtdXRleCBmcmVlXG4gICAgYXdhaXQgdGhpcy5fZ2xvYmFsTXV0ZXhGcmVlKClcbiAgICAvLyBhd2FpdCBsb2NrIGZyZWUsIHRoZW4gdGFrZSBsb2NrXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLl90YWtlTXV0ZXgoYWRkcmVzcylcbiAgICB0cnkge1xuICAgICAgLy8gZXZhbHVhdGUgbXVsdGlwbGUgbmV4dE5vbmNlIHN0cmF0ZWdpZXNcbiAgICAgIGNvbnN0IG5vbmNlRGV0YWlscyA9IHt9XG4gICAgICBjb25zdCBuZXR3b3JrTm9uY2VSZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXROZXR3b3JrTmV4dE5vbmNlKGFkZHJlc3MpXG4gICAgICBjb25zdCBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCA9IHRoaXMuX2dldEhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkKGFkZHJlc3MpXG4gICAgICBjb25zdCBuZXh0TmV0d29ya05vbmNlID0gbmV0d29ya05vbmNlUmVzdWx0Lm5vbmNlXG4gICAgICBjb25zdCBoaWdoZXN0U3VnZ2VzdGVkID0gTWF0aC5tYXgobmV4dE5ldHdvcmtOb25jZSwgaGlnaGVzdExvY2FsbHlDb25maXJtZWQpXG5cbiAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoYWRkcmVzcylcbiAgICAgIGNvbnN0IGxvY2FsTm9uY2VSZXN1bHQgPSB0aGlzLl9nZXRIaWdoZXN0Q29udGludW91c0Zyb20ocGVuZGluZ1R4cywgaGlnaGVzdFN1Z2dlc3RlZCkgfHwgMFxuXG4gICAgICBub25jZURldGFpbHMucGFyYW1zID0ge1xuICAgICAgICBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCxcbiAgICAgICAgaGlnaGVzdFN1Z2dlc3RlZCxcbiAgICAgICAgbmV4dE5ldHdvcmtOb25jZSxcbiAgICAgIH1cbiAgICAgIG5vbmNlRGV0YWlscy5sb2NhbCA9IGxvY2FsTm9uY2VSZXN1bHRcbiAgICAgIG5vbmNlRGV0YWlscy5uZXR3b3JrID0gbmV0d29ya05vbmNlUmVzdWx0XG5cbiAgICAgIGNvbnN0IG5leHROb25jZSA9IE1hdGgubWF4KG5ldHdvcmtOb25jZVJlc3VsdC5ub25jZSwgbG9jYWxOb25jZVJlc3VsdC5ub25jZSlcbiAgICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKG5leHROb25jZSksIGBub25jZS10cmFja2VyIC0gbmV4dE5vbmNlIGlzIG5vdCBhbiBpbnRlZ2VyIC0gZ290OiAoJHt0eXBlb2YgbmV4dE5vbmNlfSkgXCIke25leHROb25jZX1cImApXG5cbiAgICAgIC8vIHJldHVybiBub25jZSBhbmQgcmVsZWFzZSBjYlxuICAgICAgcmV0dXJuIHsgbmV4dE5vbmNlLCBub25jZURldGFpbHMsIHJlbGVhc2VMb2NrIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHJlbGVhc2UgbG9jayBpZiB3ZSBlbmNvdW50ZXIgYW4gZXJyb3JcbiAgICAgIHJlbGVhc2VMb2NrKClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9nbG9iYWxNdXRleEZyZWUgKCkge1xuICAgIGNvbnN0IGdsb2JhbE11dGV4ID0gdGhpcy5fbG9va3VwTXV0ZXgoJ2dsb2JhbCcpXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCBnbG9iYWxNdXRleC5hY3F1aXJlKClcbiAgICByZWxlYXNlTG9jaygpXG4gIH1cblxuICBhc3luYyBfdGFrZU11dGV4IChsb2NrSWQpIHtcbiAgICBjb25zdCBtdXRleCA9IHRoaXMuX2xvb2t1cE11dGV4KGxvY2tJZClcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IG11dGV4LmFjcXVpcmUoKVxuICAgIHJldHVybiByZWxlYXNlTG9ja1xuICB9XG5cbiAgX2xvb2t1cE11dGV4IChsb2NrSWQpIHtcbiAgICBsZXQgbXV0ZXggPSB0aGlzLmxvY2tNYXBbbG9ja0lkXVxuICAgIGlmICghbXV0ZXgpIHtcbiAgICAgIG11dGV4ID0gbmV3IE11dGV4KClcbiAgICAgIHRoaXMubG9ja01hcFtsb2NrSWRdID0gbXV0ZXhcbiAgICB9XG4gICAgcmV0dXJuIG11dGV4XG4gIH1cblxuICBhc3luYyBfZ2V0TmV0d29ya05leHROb25jZSAoYWRkcmVzcykge1xuICAgIC8vIGNhbGN1bGF0ZSBuZXh0IG5vbmNlXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgb3VyIGJhc2UgY291bnRcbiAgICAvLyBhbmQgcGVuZGluZyBjb3VudCBhcmUgZnJvbSB0aGUgc2FtZSBibG9ja1xuICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKVxuICAgIGNvbnN0IGJhc2VDb3VudEJOID0gYXdhaXQgdGhpcy5ldGhRdWVyeS5nZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrTnVtYmVyKVxuICAgIGNvbnN0IGJhc2VDb3VudCA9IGJhc2VDb3VudEJOLnRvTnVtYmVyKClcbiAgICBhc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihiYXNlQ291bnQpLCBgbm9uY2UtdHJhY2tlciAtIGJhc2VDb3VudCBpcyBub3QgYW4gaW50ZWdlciAtIGdvdDogKCR7dHlwZW9mIGJhc2VDb3VudH0pIFwiJHtiYXNlQ291bnR9XCJgKVxuICAgIGNvbnN0IG5vbmNlRGV0YWlscyA9IHsgYmxvY2tOdW1iZXIsIGJhc2VDb3VudCB9XG4gICAgcmV0dXJuIHsgbmFtZTogJ25ldHdvcmsnLCBub25jZTogYmFzZUNvdW50LCBkZXRhaWxzOiBub25jZURldGFpbHMgfVxuICB9XG5cbiAgX2dldEhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkIChhZGRyZXNzKSB7XG4gICAgY29uc3QgY29uZmlybWVkVHJhbnNhY3Rpb25zID0gdGhpcy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMoYWRkcmVzcylcbiAgICBjb25zdCBoaWdoZXN0ID0gdGhpcy5fZ2V0SGlnaGVzdE5vbmNlKGNvbmZpcm1lZFRyYW5zYWN0aW9ucylcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihoaWdoZXN0KSA/IGhpZ2hlc3QgKyAxIDogMFxuICB9XG5cbiAgX2dldEhpZ2hlc3ROb25jZSAodHhMaXN0KSB7XG4gICAgY29uc3Qgbm9uY2VzID0gdHhMaXN0Lm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBjb25zdCBub25jZSA9IHR4TWV0YS50eFBhcmFtcy5ub25jZVxuICAgICAgYXNzZXJ0KHR5cGVvZiBub25jZSwgJ3N0cmluZycsICdub25jZXMgc2hvdWxkIGJlIGhleCBzdHJpbmdzJylcbiAgICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpXG4gICAgfSlcbiAgICBjb25zdCBoaWdoZXN0Tm9uY2UgPSBNYXRoLm1heC5hcHBseShudWxsLCBub25jZXMpXG4gICAgcmV0dXJuIGhpZ2hlc3ROb25jZVxuICB9XG5cbiAgLyoqXG4gICAgQHR5cGVkZWYge29iamVjdH0gaGlnaGVzdENvbnRpbnVvdXNGcm9tXG4gICAgQHByb3BlcnR5IHtzdHJpbmd9IC0gbmFtZSB0aGUgbmFtZSBmb3IgaG93IHRoZSBub25jZSB3YXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGF0YSB1c2VkXG4gICAgQHByb3BlcnR5IHtudW1iZXJ9IC0gbm9uY2UgdGhlIG5leHQgc3VnZ2VzdGVkIG5vbmNlXG4gICAgQHByb3BlcnR5IHtvYmplY3R9IC0gZGV0YWlscyB0aGUgcHJvdmlkZWQgc3RhcnRpbmcgbm9uY2UgdGhhdCB3YXMgdXNlZCAoZm9yIGRlYnVnZ2luZylcbiAgKi9cbiAgLyoqXG4gICAgQHBhcmFtIHR4TGlzdCB7YXJyYXl9IC0gbGlzdCBvZiB0eE1ldGEnc1xuICAgIEBwYXJhbSBzdGFydFBvaW50IHtudW1iZXJ9IC0gdGhlIGhpZ2hlc3Qga25vd24gbG9jYWxseSBjb25maXJtZWQgbm9uY2VcbiAgICBAcmV0dXJucyB7aGlnaGVzdENvbnRpbnVvdXNGcm9tfVxuICAqL1xuICBfZ2V0SGlnaGVzdENvbnRpbnVvdXNGcm9tICh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcbiAgICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGNvbnN0IG5vbmNlID0gdHhNZXRhLnR4UGFyYW1zLm5vbmNlXG4gICAgICBhc3NlcnQodHlwZW9mIG5vbmNlLCAnc3RyaW5nJywgJ25vbmNlcyBzaG91bGQgYmUgaGV4IHN0cmluZ3MnKVxuICAgICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlLCAxNilcbiAgICB9KVxuXG4gICAgbGV0IGhpZ2hlc3QgPSBzdGFydFBvaW50XG4gICAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xuICAgICAgaGlnaGVzdCsrXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmFtZTogJ2xvY2FsJywgbm9uY2U6IGhpZ2hlc3QsIGRldGFpbHM6IHsgc3RhcnRQb2ludCwgaGlnaGVzdCB9IH1cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9uY2VUcmFja2VyXG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbCc7XG5pbXBvcnQge1xuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fU1RBVFVTRVMsXG59IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgaXNFSVAxNTU5VHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyBpc1ZhbGlkSGV4QWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5cbmNvbnN0IG5vcm1hbGl6ZXJzID0ge1xuICBmcm9tOiBhZGRIZXhQcmVmaXgsXG4gIHRvOiAodG8sIGxvd2VyQ2FzZSkgPT5cbiAgICBsb3dlckNhc2UgPyBhZGRIZXhQcmVmaXgodG8pLnRvTG93ZXJDYXNlKCkgOiBhZGRIZXhQcmVmaXgodG8pLFxuICBub25jZTogYWRkSGV4UHJlZml4LFxuICB2YWx1ZTogYWRkSGV4UHJlZml4LFxuICBkYXRhOiBhZGRIZXhQcmVmaXgsXG4gIGdhczogYWRkSGV4UHJlZml4LFxuICBnYXNQcmljZTogYWRkSGV4UHJlZml4LFxuICBtYXhGZWVQZXJHYXM6IGFkZEhleFByZWZpeCxcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFkZEhleFByZWZpeCxcbiAgdHlwZTogYWRkSGV4UHJlZml4LFxuICBlc3RpbWF0ZVN1Z2dlc3RlZDogKGVzdGltYXRlKSA9PiBlc3RpbWF0ZSxcbiAgZXN0aW1hdGVVc2VkOiAoZXN0aW1hdGUpID0+IGVzdGltYXRlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFuZFZhbGlkYXRlVHhQYXJhbXModHhQYXJhbXMsIGxvd2VyQ2FzZSA9IHRydWUpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0gbm9ybWFsaXplVHhQYXJhbXModHhQYXJhbXMsIGxvd2VyQ2FzZSk7XG4gIHZhbGlkYXRlVHhQYXJhbXMobm9ybWFsaXplZFR4UGFyYW1zKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRUeFBhcmFtcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiB0eFBhcmFtc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIFRoZSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvd2VyQ2FzZV0gLSBXaGV0aGVyIHRvIGxvd2VyY2FzZSB0aGUgJ3RvJyBhZGRyZXNzLlxuICogRGVmYXVsdDogdHJ1ZVxuICogQHJldHVybnMge09iamVjdH0gdGhlIG5vcm1hbGl6ZWQgdHggcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUeFBhcmFtcyh0eFBhcmFtcywgbG93ZXJDYXNlID0gdHJ1ZSkge1xuICAvLyBhcHBseSBvbmx5IGtleXMgaW4gdGhlIG5vcm1hbGl6ZXJzXG4gIGNvbnN0IG5vcm1hbGl6ZWRUeFBhcmFtcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVycykge1xuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XG4gICAgICBub3JtYWxpemVkVHhQYXJhbXNba2V5XSA9IG5vcm1hbGl6ZXJzW2tleV0odHhQYXJhbXNba2V5XSwgbG93ZXJDYXNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRUeFBhcmFtcztcbn1cblxuLyoqXG4gKiBHaXZlbiB0d28gZmllbGRzLCBlbnN1cmUgdGhhdCB0aGUgc2Vjb25kIGZpZWxkIGlzIG5vdCBpbmNsdWRlZCBpbiB0eFBhcmFtcyxcbiAqIGFuZCBpZiBpdCBpcyB0aHJvdyBhbiBpbnZhbGlkUGFyYW1zIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkQmVpbmdWYWxpZGF0ZWQgLSB0aGUgY3VycmVudCBmaWVsZCBiZWluZyB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtdXR1YWxseUV4Y2x1c2l2ZUZpZWxkIC0gdGhlIGZpZWxkIHRvIGVuc3VyZSBpcyBub3QgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge2V0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtc30gVGhyb3dzIGlmIG11dHVhbGx5RXhjbHVzaXZlRmllbGQgaXNcbiAqICBwcmVzZW50IGluIHR4UGFyYW1zLlxuICovXG5mdW5jdGlvbiBlbnN1cmVNdXR1YWxseUV4Y2x1c2l2ZUZpZWxkc05vdFByb3ZpZGVkKFxuICB0eFBhcmFtcyxcbiAgZmllbGRCZWluZ1ZhbGlkYXRlZCxcbiAgbXV0dWFsbHlFeGNsdXNpdmVGaWVsZCxcbikge1xuICBpZiAodHlwZW9mIHR4UGFyYW1zW211dHVhbGx5RXhjbHVzaXZlRmllbGRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uIHBhcmFtczogc3BlY2lmaWVkICR7ZmllbGRCZWluZ1ZhbGlkYXRlZH0gYnV0IGFsc28gaW5jbHVkZWQgJHttdXR1YWxseUV4Y2x1c2l2ZUZpZWxkfSwgdGhlc2UgY2Fubm90IGJlIG1peGVkYCxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBwcm92aWRlZCB2YWx1ZSBmb3IgZmllbGQgaXMgYSBzdHJpbmcsIHRocm93cyBhblxuICogaW52YWxpZFBhcmFtcyBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR4UGFyYW1zIC0gdGhlIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgY3VycmVudCBmaWVsZCBiZWluZyB2YWxpZGF0ZWRcbiAqIEB0aHJvd3Mge2V0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtc30gVGhyb3dzIGlmIGZpZWxkIGlzIG5vdCBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCBmaWVsZCkge1xuICBpZiAodHlwZW9mIHR4UGFyYW1zW2ZpZWxkXSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6ICR7ZmllbGR9IGlzIG5vdCBhIHN0cmluZy4gZ290OiAoJHt0eFBhcmFtc1tmaWVsZF19KWAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgcHJvdmlkZWQgdHhQYXJhbXMgaGFzIHRoZSBwcm9wZXIgJ3R5cGUnIHNwZWNpZmllZCBmb3IgdGhlXG4gKiBnaXZlbiBmaWVsZCwgaWYgaXQgaXMgcHJvdmlkZWQuIElmIHR5cGVzIGRvIG5vdCBtYXRjaCB0aHJvd3MgYW5cbiAqIGludmFsaWRQYXJhbXMgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR4UGFyYW1zIC0gdGhlIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnMgb2JqZWN0XG4gKiBAcGFyYW0geydnYXNQcmljZScgfCAnbWF4RmVlUGVyR2FzJyB8ICdtYXhQcmlvcml0eUZlZVBlckdhcyd9IGZpZWxkIC0gdGhlXG4gKiAgY3VycmVudCBmaWVsZCBiZWluZyB2YWxpZGF0ZWRcbiAqIEB0aHJvd3Mge2V0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtc30gVGhyb3dzIGlmIHR5cGUgZG9lcyBub3QgbWF0Y2ggdGhlXG4gKiAgZXhwZWN0YXRpb25zIGZvciBwcm92aWRlZCBmaWVsZC5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlUHJvcGVyVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGVQcm92aWRlZCh0eFBhcmFtcywgZmllbGQpIHtcbiAgc3dpdGNoIChmaWVsZCkge1xuICAgIGNhc2UgJ21heEZlZVBlckdhcyc6XG4gICAgY2FzZSAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnOlxuICAgICAgaWYgKFxuICAgICAgICB0eFBhcmFtcy50eXBlICYmXG4gICAgICAgIHR4UGFyYW1zLnR5cGUgIT09IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZTogc3BlY2lmaWVkIHR5cGUgXCIke3R4UGFyYW1zLnR5cGV9XCIgYnV0IGluY2x1ZGluZyBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIHJlcXVpcmVzIHR5cGU6IFwiJHtUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUfVwiYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2dhc1ByaWNlJzpcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKFxuICAgICAgICB0eFBhcmFtcy50eXBlICYmXG4gICAgICAgIHR4UGFyYW1zLnR5cGUgPT09IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdHlwZTogc3BlY2lmaWVkIHR5cGUgXCIke3R4UGFyYW1zLnR5cGV9XCIgYnV0IGluY2x1ZGVkIGEgZ2FzUHJpY2UgaW5zdGVhZCBvZiBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZ2l2ZW4gdHggcGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0eCBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZWlwMTU1OUNvbXBhdGliaWxpdHkgLSB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IHRyYW5zYWN0aW9uc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSB0eCBwYXJhbXMgY29udGFpbnMgaW52YWxpZCBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVHhQYXJhbXModHhQYXJhbXMsIGVpcDE1NTlDb21wYXRpYmlsaXR5ID0gdHJ1ZSkge1xuICBpZiAoIXR4UGFyYW1zIHx8IHR5cGVvZiB0eFBhcmFtcyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh0eFBhcmFtcykpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAnSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6IG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgfVxuICBpZiAoIXR4UGFyYW1zLnRvICYmICF0eFBhcmFtcy5kYXRhKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24gcGFyYW1zOiBtdXN0IHNwZWNpZnkgXCJkYXRhXCIgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRzLCBvciBcInRvXCIgKGFuZCBvcHRpb25hbGx5IFwiZGF0YVwiKSBmb3IgYWxsIG90aGVyIHR5cGVzIG9mIHRyYW5zYWN0aW9ucy4nLFxuICAgICk7XG4gIH1cbiAgaWYgKGlzRUlQMTU1OVRyYW5zYWN0aW9uKHsgdHhQYXJhbXMgfSkgJiYgIWVpcDE1NTlDb21wYXRpYmlsaXR5KSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24gcGFyYW1zOiBwYXJhbXMgc3BlY2lmeSBhbiBFSVAtMTU1OSB0cmFuc2FjdGlvbiBidXQgdGhlIGN1cnJlbnQgbmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5JyxcbiAgICApO1xuICB9XG5cbiAgT2JqZWN0LmVudHJpZXModHhQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIC8vIHZhbGlkYXRlIHR5cGVzXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2Zyb20nOlxuICAgICAgICB2YWxpZGF0ZUZyb20odHhQYXJhbXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvJzpcbiAgICAgICAgdmFsaWRhdGVSZWNpcGllbnQodHhQYXJhbXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2dhc1ByaWNlJzpcbiAgICAgICAgZW5zdXJlUHJvcGVyVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGVQcm92aWRlZCh0eFBhcmFtcywgJ2dhc1ByaWNlJyk7XG4gICAgICAgIGVuc3VyZU11dHVhbGx5RXhjbHVzaXZlRmllbGRzTm90UHJvdmlkZWQoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgJ2dhc1ByaWNlJyxcbiAgICAgICAgICAnbWF4RmVlUGVyR2FzJyxcbiAgICAgICAgKTtcbiAgICAgICAgZW5zdXJlTXV0dWFsbHlFeGNsdXNpdmVGaWVsZHNOb3RQcm92aWRlZChcbiAgICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICAgICdtYXhQcmlvcml0eUZlZVBlckdhcycsXG4gICAgICAgICk7XG4gICAgICAgIGVuc3VyZUZpZWxkSXNTdHJpbmcodHhQYXJhbXMsICdnYXNQcmljZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21heEZlZVBlckdhcyc6XG4gICAgICAgIGVuc3VyZVByb3BlclRyYW5zYWN0aW9uRW52ZWxvcGVUeXBlUHJvdmlkZWQodHhQYXJhbXMsICdtYXhGZWVQZXJHYXMnKTtcbiAgICAgICAgZW5zdXJlTXV0dWFsbHlFeGNsdXNpdmVGaWVsZHNOb3RQcm92aWRlZChcbiAgICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgICAnbWF4RmVlUGVyR2FzJyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICApO1xuICAgICAgICBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCAnbWF4RmVlUGVyR2FzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnOlxuICAgICAgICBlbnN1cmVQcm9wZXJUcmFuc2FjdGlvbkVudmVsb3BlVHlwZVByb3ZpZGVkKFxuICAgICAgICAgIHR4UGFyYW1zLFxuICAgICAgICAgICdtYXhQcmlvcml0eUZlZVBlckdhcycsXG4gICAgICAgICk7XG4gICAgICAgIGVuc3VyZU11dHVhbGx5RXhjbHVzaXZlRmllbGRzTm90UHJvdmlkZWQoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgJ21heFByaW9yaXR5RmVlUGVyR2FzJyxcbiAgICAgICAgICAnZ2FzUHJpY2UnLFxuICAgICAgICApO1xuICAgICAgICBlbnN1cmVGaWVsZElzU3RyaW5nKHR4UGFyYW1zLCAnbWF4UHJpb3JpdHlGZWVQZXJHYXMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIGVuc3VyZUZpZWxkSXNTdHJpbmcodHhQYXJhbXMsICd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb24gdmFsdWUgXCIke3ZhbHVlfVwiOiBub3QgYSBwb3NpdGl2ZSBudW1iZXIuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uIHZhbHVlIG9mIFwiJHt2YWx1ZX1cIjogbnVtYmVyIG11c3QgYmUgaW4gd2VpLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsdWUubWF0Y2goL14weFthLWZBLUYwLTldKyQvdSkpIHtcbiAgICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiB2YWx1ZSBvZiBcIiR7dmFsdWV9XCI6IG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hhaW5JZCc6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICAgICBgSW52YWxpZCB0cmFuc2FjdGlvbiBwYXJhbXM6ICR7a2V5fSBpcyBub3QgYSBOdW1iZXIgb3IgaGV4IHN0cmluZy4gZ290OiAoJHt2YWx1ZX0pYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZW5zdXJlRmllbGRJc1N0cmluZyh0eFBhcmFtcywga2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUge0Bjb2RlIGZyb219IGZpZWxkIGluIHRoZSBnaXZlbiB0eCBwYXJhbXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHhQYXJhbXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZnJvbSBhZGRyZXNzIGlzbid0IHZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZyb20odHhQYXJhbXMpIHtcbiAgaWYgKCEodHlwZW9mIHR4UGFyYW1zLmZyb20gPT09ICdzdHJpbmcnKSkge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgIGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3MgXCIke3R4UGFyYW1zLmZyb219XCI6IG5vdCBhIHN0cmluZy5gLFxuICAgICk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkSGV4QWRkcmVzcyh0eFBhcmFtcy5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3MuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHtAY29kZSB0b30gZmllbGQgaW4gdGhlIGdpdmVuIHR4IHBhcmFtc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eFBhcmFtcyAtIHRoZSB0eCBwYXJhbXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSB0eCBwYXJhbXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgcmVjaXBpZW50IGlzIGludmFsaWQgT1IgdGhlcmUgaXNuJ3QgdHggZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSZWNpcGllbnQodHhQYXJhbXMpIHtcbiAgaWYgKHR4UGFyYW1zLnRvID09PSAnMHgnIHx8IHR4UGFyYW1zLnRvID09PSBudWxsKSB7XG4gICAgaWYgKHR4UGFyYW1zLmRhdGEpIHtcbiAgICAgIGRlbGV0ZSB0eFBhcmFtcy50bztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdJbnZhbGlkIFwidG9cIiBhZGRyZXNzLicpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB0eFBhcmFtcy50byAhPT0gdW5kZWZpbmVkICYmXG4gICAgIWlzVmFsaWRIZXhBZGRyZXNzKHR4UGFyYW1zLnRvLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pXG4gICkge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygnSW52YWxpZCBcInRvXCIgYWRkcmVzcy4nKTtcbiAgfVxuICByZXR1cm4gdHhQYXJhbXM7XG59XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUNvbmZpcm1lZEV4dGVybmFsVHJhbnNhY3Rpb24gPSAoe1xuICB0eE1ldGEsXG4gIHBlbmRpbmdUcmFuc2FjdGlvbnMsXG4gIGNvbmZpcm1lZFRyYW5zYWN0aW9ucyxcbn0gPSB7fSkgPT4ge1xuICBpZiAoIXR4TWV0YSB8fCAhdHhNZXRhLnR4UGFyYW1zKSB7XG4gICAgdGhyb3cgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKFxuICAgICAgJ1widHhNZXRhXCIgb3IgXCJ0eE1ldGEudHhQYXJhbXNcIiBpcyBtaXNzaW5nJyxcbiAgICApO1xuICB9XG4gIGlmICh0eE1ldGEuc3RhdHVzICE9PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQpIHtcbiAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAnRXh0ZXJuYWwgdHJhbnNhY3Rpb24gc3RhdHVzIHNob3VsZCBiZSBcImNvbmZpcm1lZFwiJyxcbiAgICApO1xuICB9XG4gIGNvbnN0IGV4dGVybmFsVHhOb25jZSA9IHR4TWV0YS50eFBhcmFtcy5ub25jZTtcbiAgaWYgKHBlbmRpbmdUcmFuc2FjdGlvbnMgJiYgcGVuZGluZ1RyYW5zYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZm91bmRQZW5kaW5nVHhCeU5vbmNlID0gcGVuZGluZ1RyYW5zYWN0aW9ucy5maW5kKFxuICAgICAgKGVsKSA9PiBlbC50eFBhcmFtcz8ubm9uY2UgPT09IGV4dGVybmFsVHhOb25jZSxcbiAgICApO1xuICAgIGlmIChmb3VuZFBlbmRpbmdUeEJ5Tm9uY2UpIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgICAgJ0V4dGVybmFsIHRyYW5zYWN0aW9uIG5vbmNlIHNob3VsZCBub3QgYmUgaW4gcGVuZGluZyB0eHMnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbmZpcm1lZFRyYW5zYWN0aW9ucyAmJiBjb25maXJtZWRUcmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZvdW5kQ29uZmlybWVkVHhCeU5vbmNlID0gY29uZmlybWVkVHJhbnNhY3Rpb25zLmZpbmQoXG4gICAgICAoZWwpID0+IGVsLnR4UGFyYW1zPy5ub25jZSA9PT0gZXh0ZXJuYWxUeE5vbmNlLFxuICAgICk7XG4gICAgaWYgKGZvdW5kQ29uZmlybWVkVHhCeU5vbmNlKSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoXG4gICAgICAgICdFeHRlcm5hbCB0cmFuc2FjdGlvbiBub25jZSBzaG91bGQgbm90IGJlIGluIGNvbmZpcm1lZCB0eHMnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgZmluYWwgc3RhdGVzXG4gKlxuICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgc3RhdGVzIHRoYXQgY2FuIGJlIGNvbnNpZGVyZWQgZmluYWwgc3RhdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaW5hbFN0YXRlcygpIHtcbiAgcmV0dXJuIFtcbiAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCwgLy8gdGhlIHVzZXIgaGFzIHJlc3BvbmRlZCBubyFcbiAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQsIC8vIHRoZSB0eCBoYXMgYmVlbiBpbmNsdWRlZCBpbiBhIGJsb2NrLlxuICAgIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRCwgLy8gdGhlIHR4IGZhaWxlZCBmb3Igc29tZSByZWFzb24sIGluY2x1ZGVkIG9uIHR4IGRhdGEuXG4gICAgVFJBTlNBQ1RJT05fU1RBVFVTRVMuRFJPUFBFRCwgLy8gdGhlIHR4IG5vbmNlIHdhcyBhbHJlYWR5IHVzZWRcbiAgXTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHR4IHJlY2VpcHQgZ2FzIHVzZWQgdG8gYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBJdCBzZWVtcyB0aGF0IHNvbWV0aW1lcyB0aGUgbnVtZXJpY2FsIHZhbHVlcyBiZWluZyByZXR1cm5lZCBmcm9tXG4gKiB0aGlzLnF1ZXJ5LmdldFRyYW5zYWN0aW9uUmVjZWlwdCBhcmUgQk4gaW5zdGFuY2VzIGFuZCBub3Qgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyBvciBCTiBpbnN0YW5jZX0gZ2FzVXNlZFxuICogQHJldHVybnMgbm9ybWFsaXplZCBnYXMgdXNlZCBhcyBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVR4UmVjZWlwdEdhc1VzZWQoZ2FzVXNlZCkge1xuICByZXR1cm4gdHlwZW9mIGdhc1VzZWQgPT09ICdzdHJpbmcnID8gZ2FzVXNlZCA6IGdhc1VzZWQudG9TdHJpbmcoMTYpO1xufVxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdzYWZlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVN0b3JlIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IGtleUJ5LCBtYXBWYWx1ZXMsIG9taXRCeSwgcGlja0J5LCBzb3J0QnkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMgfSBmcm9tICcuLi8uLi9tZXRhbWFzay1jb250cm9sbGVyJztcbmltcG9ydCB7IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZUhpc3RvcnlFbnRyeSxcbiAgcmVwbGF5SGlzdG9yeSxcbiAgc25hcHNob3RGcm9tVHhNZXRhLFxufSBmcm9tICcuL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMnO1xuaW1wb3J0IHtcbiAgZ2V0RmluYWxTdGF0ZXMsXG4gIG5vcm1hbGl6ZUFuZFZhbGlkYXRlVHhQYXJhbXMsXG4gIHZhbGlkYXRlQ29uZmlybWVkRXh0ZXJuYWxUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi9saWIvdXRpbCc7XG5cbi8qKlxuICogVHJhbnNhY3Rpb25TdGF0dXNlcyByZWltcG9ydGVkIGZyb20gdGhlIHNoYXJlZCB0cmFuc2FjdGlvbiBjb25zdGFudHMgZmlsZVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXG4gKiAgJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nXG4gKiApLlRyYW5zYWN0aW9uU3RhdHVzU3RyaW5nfSBUcmFuc2FjdGlvblN0YXR1c1N0cmluZ1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlR4UGFyYW1zfSBUeFBhcmFtc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcbiAqICAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbidcbiAqICkuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9uU3RhdGVcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgVHJhbnNhY3Rpb25NZXRhPn0gdHJhbnNhY3Rpb25zIC0gVHJhbnNhY3Rpb25NZXRhXG4gKiAga2V5ZWQgYnkgdGhlIHRyYW5zYWN0aW9uJ3MgaWQuXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvblN0YXRlTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHN0YXRlIG9mIGEgdHJhbnNhY3Rpb24gYW5kXG4gKiBzdG9yaW5nIHRoZSB0cmFuc2FjdGlvbi4gSXQgYWxzbyBoYXMgc29tZSBjb252ZW5pZW5jZSBtZXRob2RzIGZvciBmaW5kaW5nXG4gKiBzdWJzZXRzIG9mIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtUcmFuc2FjdGlvblN0YXRlfSBbb3B0cy5pbml0U3RhdGU9eyB0cmFuc2FjdGlvbnM6IHt9IH1dIC0gaW5pdGlhbFxuICogIHRyYW5zYWN0aW9ucyBsaXN0IGtleWVkIGJ5IGlkXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHhIaXN0b3J5TGltaXRdIC0gbGltaXQgZm9yIGhvdyBtYW55IGZpbmlzaGVkXG4gKiAgdHJhbnNhY3Rpb25zIGNhbiBoYW5nIGFyb3VuZCBpbiBzdGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5nZXROZXR3b3JrIC0gcmV0dXJuIG5ldHdvcmsgbnVtYmVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoeyBpbml0U3RhdGUsIHR4SGlzdG9yeUxpbWl0LCBnZXROZXR3b3JrLCBnZXRDdXJyZW50Q2hhaW5JZCB9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHRyYW5zYWN0aW9uczoge30sXG4gICAgICAuLi5pbml0U3RhdGUsXG4gICAgfSk7XG4gICAgdGhpcy50eEhpc3RvcnlMaW1pdCA9IHR4SGlzdG9yeUxpbWl0O1xuICAgIHRoaXMuZ2V0TmV0d29yayA9IGdldE5ldHdvcms7XG4gICAgdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFRyYW5zYWN0aW9uTWV0YSBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgZmllbGRzIHJlcXVpcmVkIGZvclxuICAgKiB1c2UgdGhyb3VnaG91dCB0aGUgZXh0ZW5zaW9uLiBUaGUgYXJndW1lbnQgaGVyZSB3aWxsIG92ZXJyaWRlIGV2ZXJ5dGhpbmdcbiAgICogaW4gdGhlIHJlc3VsdGluZyB0cmFuc2FjdGlvbiBtZXRhLlxuICAgKlxuICAgKiBUT0RPOiBEb24ndCBvdmVyd3JpdGUgZXZlcnl0aGluZz9cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPFRyYW5zYWN0aW9uTWV0YT59IG9wdHMgLSB0aGUgb2JqZWN0IHRvIHVzZSB3aGVuXG4gICAqICBvdmVyd3JpdGluZyBkZWZhdWx0IGtleXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YVxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhfSB0aGUgZGVmYXVsdCB0eE1ldGEgb2JqZWN0XG4gICAqL1xuICBnZW5lcmF0ZVR4TWV0YShvcHRzID0ge30pIHtcbiAgICBjb25zdCBuZXRJZCA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgaWYgKG5ldElkID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgaXMgaGF2aW5nIHRyb3VibGUgY29ubmVjdGluZyB0byB0aGUgbmV0d29yaycpO1xuICAgIH1cblxuICAgIGxldCBkYXBwU3VnZ2VzdGVkR2FzRmVlcyA9IG51bGw7XG5cbiAgICAvLyBJZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgdHJhbnNhY3Rpb24gc3VnZ2VzdGVkIGJ5IGEgZGFwcCBhbmQgbm90XG4gICAgLy8gYW4gaW50ZXJuYWxseSBjcmVhdGVkIG1ldGFtYXNrIHRyYW5zYWN0aW9uLCB3ZSBuZWVkIHRvIGtlZXAgcmVjb3JkIG9mXG4gICAgLy8gdGhlIG9yaWdpbmFsbHkgc3VibWl0dGVkIGdhc1BhcmFtcy5cbiAgICBpZiAoXG4gICAgICBvcHRzLnR4UGFyYW1zICYmXG4gICAgICB0eXBlb2Ygb3B0cy5vcmlnaW4gPT09ICdzdHJpbmcnICYmXG4gICAgICBvcHRzLm9yaWdpbiAhPT0gJ21ldGFtYXNrJ1xuICAgICkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnR4UGFyYW1zLmdhc1ByaWNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkYXBwU3VnZ2VzdGVkR2FzRmVlcyA9IHtcbiAgICAgICAgICBnYXNQcmljZTogb3B0cy50eFBhcmFtcy5nYXNQcmljZSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBvcHRzLnR4UGFyYW1zLm1heEZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIG9wdHMudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgPSB7XG4gICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG9wdHMudHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgbWF4RmVlUGVyR2FzOiBvcHRzLnR4UGFyYW1zLm1heEZlZVBlckdhcyxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRzLnR4UGFyYW1zLmdhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgPSB7XG4gICAgICAgICAgLi4uZGFwcFN1Z2dlc3RlZEdhc0ZlZXMsXG4gICAgICAgICAgZ2FzOiBvcHRzLnR4UGFyYW1zLmdhcyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNyZWF0ZUlkKCksXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgIHN0YXR1czogVFJBTlNBQ1RJT05fU1RBVFVTRVMuVU5BUFBST1ZFRCxcbiAgICAgIG1ldGFtYXNrTmV0d29ya0lkOiBuZXRJZCxcbiAgICAgIG9yaWdpbmFsR2FzRXN0aW1hdGU6IG9wdHMudHhQYXJhbXM/LmdhcyxcbiAgICAgIHVzZXJFZGl0ZWRHYXNMaW1pdDogZmFsc2UsXG4gICAgICBjaGFpbklkLFxuICAgICAgbG9hZGluZ0RlZmF1bHRzOiB0cnVlLFxuICAgICAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMsXG4gICAgICAuLi5vcHRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogbmV0d29yay4gVGhpcyBpcyB0aGUgb25seSB0cmFuc2FjdGlvbiBmZXRjaGluZyBtZXRob2QgdGhhdCByZXR1cm5zIGFuXG4gICAqIG9iamVjdCwgc28gaXQgZG9lc24ndCB1c2UgZ2V0VHJhbnNhY3Rpb25zIGxpa2UgZXZlcnl0aGluZyBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgVHJhbnNhY3Rpb25NZXRhPn0gVW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMga2V5ZWRcbiAgICogIGJ5IGlkXG4gICAqL1xuICBnZXRVbmFwcHJvdmVkVHhMaXN0KCkge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgY29uc3QgbmV0d29yayA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIHJldHVybiBwaWNrQnkoXG4gICAgICB0aGlzLnN0b3JlLmdldFN0YXRlKCkudHJhbnNhY3Rpb25zLFxuICAgICAgKHRyYW5zYWN0aW9uKSA9PlxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQgJiZcbiAgICAgICAgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCwgbmV0d29yayksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay4gSWYgYW4gYWRkcmVzcyBpc1xuICAgKiBwcm92aWRlZCwgdGhlIGxpc3Qgd2lsbCBiZSBmdXJ0aGVyIHJlZmluZWQgdG8gb25seSB0aG9zZSB0cmFuc2FjdGlvbnNcbiAgICogb3JpZ2luYXRpbmcgZnJvbSB0aGUgc3VwcGxpZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSAtIGhleCBwcmVmaXhlZCBhZGRyZXNzIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGZvci5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfSB0aGUgZmlsdGVyZWQgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGdldEFwcHJvdmVkVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWFyY2hDcml0ZXJpYSA9IHsgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRCB9O1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICBzZWFyY2hDcml0ZXJpYS5mcm9tID0gYWRkcmVzcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHsgc2VhcmNoQ3JpdGVyaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay4gSWYgYW4gYWRkcmVzcyBpc1xuICAgKiBwcm92aWRlZCwgdGhlIGxpc3Qgd2lsbCBiZSBmdXJ0aGVyIHJlZmluZWQgdG8gb25seSB0aG9zZSB0cmFuc2FjdGlvbnNcbiAgICogb3JpZ2luYXRpbmcgZnJvbSB0aGUgc3VwcGxpZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSAtIGhleCBwcmVmaXhlZCBhZGRyZXNzIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGZvci5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfSB0aGUgZmlsdGVyZWQgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgIGNvbnN0IHNlYXJjaENyaXRlcmlhID0geyBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCB9O1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICBzZWFyY2hDcml0ZXJpYS5mcm9tID0gYWRkcmVzcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHsgc2VhcmNoQ3JpdGVyaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb25maXJtZWQgdHJhbnNhY3Rpb25zIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLiBJZiBhbiBhZGRyZXNzIGlzXG4gICAqIHByb3ZpZGVkLCB0aGUgbGlzdCB3aWxsIGJlIGZ1cnRoZXIgcmVmaW5lZCB0byBvbmx5IHRob3NlIHRyYW5zYWN0aW9uc1xuICAgKiBvcmlnaW5hdGluZyBmcm9tIHRoZSBzdXBwbGllZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FkZHJlc3NdIC0gaGV4IHByZWZpeGVkIGFkZHJlc3MgdG8gZmluZCB0cmFuc2FjdGlvbnMgZm9yLlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhW119IHRoZSBmaWx0ZXJlZCBsaXN0IG9mIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWFyY2hDcml0ZXJpYSA9IHsgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQgfTtcbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgc2VhcmNoQ3JpdGVyaWEuZnJvbSA9IGFkZHJlc3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9ucyh7IHNlYXJjaENyaXRlcmlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHR4TWV0YSB0byB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgaW4gdGhlIHN0b3JlLlxuICAgKiBpZiB0aGUgbGlzdCBpcyBvdmVyIHR4SGlzdG9yeUxpbWl0IGl0IHdpbGwgcmVtb3ZlIGEgdHJhbnNhY3Rpb24gdGhhdFxuICAgKiBpcyBpbiBpdHMgZmluYWwgc3RhdGUuXG4gICAqIGl0IHdpbGwgYWxzbyBhZGQgdGhlIGtleSBgaGlzdG9yeWAgdG8gdGhlIHR4TWV0YSB3aXRoIHRoZSBzbmFwIHNob3Qgb2ZcbiAgICogdGhlIG9yaWdpbmFsIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YX0gdHhNZXRhIC0gVGhlIFRyYW5zYWN0aW9uTWV0YSBvYmplY3QgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhfSBUaGUgc2FtZSBUcmFuc2FjdGlvbk1ldGEsIGJ1dCB3aXRoIHZhbGlkYXRlZFxuICAgKiAgdHhQYXJhbXMgYW5kIHRyYW5zYWN0aW9uIGhpc3RvcnkuXG4gICAqL1xuICBhZGRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgICAvLyBub3JtYWxpemUgYW5kIHZhbGlkYXRlIHR4UGFyYW1zIGlmIHByZXNlbnRcbiAgICBpZiAodHhNZXRhLnR4UGFyYW1zKSB7XG4gICAgICB0eE1ldGEudHhQYXJhbXMgPSBub3JtYWxpemVBbmRWYWxpZGF0ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcywgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMub25jZShgJHt0eE1ldGEuaWR9OnNpZ25lZGAsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3R4TWV0YS5pZH06cmVqZWN0ZWRgKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uY2UoYCR7dHhNZXRhLmlkfTpyZWplY3RlZGAsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3R4TWV0YS5pZH06c2lnbmVkYCk7XG4gICAgfSk7XG4gICAgLy8gaW5pdGlhbGl6ZSBoaXN0b3J5XG4gICAgdHhNZXRhLmhpc3RvcnkgPSBbXTtcbiAgICAvLyBjYXB0dXJlIGluaXRpYWwgc25hcHNob3Qgb2YgdHhNZXRhIGZvciBoaXN0b3J5XG4gICAgY29uc3Qgc25hcHNob3QgPSBzbmFwc2hvdEZyb21UeE1ldGEodHhNZXRhKTtcbiAgICB0eE1ldGEuaGlzdG9yeS5wdXNoKHNuYXBzaG90KTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIGZpbHRlclRvQ3VycmVudE5ldHdvcms6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHhIaXN0b3J5TGltaXQgfSA9IHRoaXM7XG5cbiAgICAvLyBjaGVja3MgaWYgdGhlIGxlbmd0aCBvZiB0aGUgdHggaGlzdG9yeSBpcyBsb25nZXIgdGhlbiBkZXNpcmVkIHBlcnNpc3RlbmNlXG4gICAgLy8gbGltaXQgYW5kIHRoZW4gaWYgaXQgaXMgcmVtb3ZlcyB0aGUgb2xkZXN0IGNvbmZpcm1lZCBvciByZWplY3RlZCB0eC5cbiAgICAvLyBQZW5kaW5nIG9yIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIHdpbGwgbm90IGJlIHJlbW92ZWQgYnkgdGhpc1xuICAgIC8vIG9wZXJhdGlvbi4gRm9yIHNhZmV0eSBvZiBwcmVzZW50aW5nIGEgZnVsbHkgZnVuY3Rpb25hbCB0cmFuc2FjdGlvbiBVSVxuICAgIC8vIHJlcHJlc2VudGF0aW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJyZWFrIGFwYXJ0IHRyYW5zYWN0aW9ucyB3aXRoIHRoZVxuICAgIC8vIHNhbWUgbm9uY2UsIHBlciBuZXR3b3JrLiBOb3QgYWNjb3VudGluZyBmb3IgdHJhbnNhY3Rpb25zIG9mIHRoZSBzYW1lXG4gICAgLy8gbm9uY2UgYW5kIG5ldHdvcmsgY29tYm8gY2FuIHJlc3VsdCBpbiBjb25mdXNpbmcgb3IgYnJva2VuIGV4cGVyaWVuY2VzXG4gICAgLy8gaW4gdGhlIFVJLlxuICAgIC8vXG4gICAgLy8gVE9ETzogd2UgYXJlIGFscmVhZHkgbGltaXRpbmcgd2hhdCB3ZSBzZW5kIHRvIHRoZSBVSSwgYW5kIGluIHRoZSBmdXR1cmVcbiAgICAvLyB3ZSB3aWxsIHNlbmQgVUkgb25seSBjb2xsZWN0ZWQgZ3JvdXBzIG9mIHRyYW5zYWN0aW9ucyAqcGVyIHBhZ2UqIHNvIGF0XG4gICAgLy8gc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB0aGlzIHBlcnNpc3RlbmNlIGxpbWl0IGNhbiBiZSBhZGp1c3RlZC4gV2hlblxuICAgIC8vIHdlIGRvIHRoYXQgSSB0aGluayB3ZSBzaG91bGQgZmlndXJlIG91dCBhIGJldHRlciBzdG9yYWdlIHNvbHV0aW9uIGZvclxuICAgIC8vIHRyYW5zYWN0aW9uIGhpc3RvcnkgZW50cmllcy5cbiAgICBjb25zdCBub25jZU5ldHdvcmtTZXQgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdHhzVG9EZWxldGUgPSB0cmFuc2FjdGlvbnNcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIoKHR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9uY2UsIGZyb20gfSA9IHR4LnR4UGFyYW1zO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIG1ldGFtYXNrTmV0d29ya0lkLCBzdGF0dXMgfSA9IHR4O1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtub25jZX0tJHtjaGFpbklkID8/IG1ldGFtYXNrTmV0d29ya0lkfS0ke2Zyb219YDtcbiAgICAgICAgaWYgKG5vbmNlTmV0d29ya1NldC5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBub25jZU5ldHdvcmtTZXQuc2l6ZSA8IHR4SGlzdG9yeUxpbWl0IC0gMSB8fFxuICAgICAgICAgIGdldEZpbmFsU3RhdGVzKCkuaW5jbHVkZXMoc3RhdHVzKSA9PT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgbm9uY2VOZXR3b3JrU2V0LmFkZChrZXkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAubWFwKCh0eCkgPT4gdHguaWQpO1xuXG4gICAgdGhpcy5fZGVsZXRlVHJhbnNhY3Rpb25zKHR4c1RvRGVsZXRlKTtcbiAgICB0aGlzLl9hZGRUcmFuc2FjdGlvbnNUb1N0YXRlKFt0eE1ldGFdKTtcbiAgICByZXR1cm4gdHhNZXRhO1xuICB9XG5cbiAgYWRkRXh0ZXJuYWxUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHR4TWV0YT8udHhQYXJhbXM/LmZyb207XG4gICAgY29uc3QgY29uZmlybWVkVHJhbnNhY3Rpb25zID0gdGhpcy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMoZnJvbUFkZHJlc3MpO1xuICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbnMgPSB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoZnJvbUFkZHJlc3MpO1xuICAgIHZhbGlkYXRlQ29uZmlybWVkRXh0ZXJuYWxUcmFuc2FjdGlvbih7XG4gICAgICB0eE1ldGEsXG4gICAgICBwZW5kaW5nVHJhbnNhY3Rpb25zLFxuICAgICAgY29uZmlybWVkVHJhbnNhY3Rpb25zLFxuICAgIH0pO1xuICAgIHRoaXMuX2FkZFRyYW5zYWN0aW9uc1RvU3RhdGUoW3R4TWV0YV0pO1xuICAgIHJldHVybiB0eE1ldGE7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWRcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YX0gdGhlIHR4TWV0YSB3aG8gbWF0Y2hlcyB0aGUgZ2l2ZW4gaWQgaWYgbm9uZSBmb3VuZFxuICAgKiBmb3IgdGhlIG5ldHdvcmsgcmV0dXJucyB1bmRlZmluZWRcbiAgICovXG4gIGdldFRyYW5zYWN0aW9uKHR4SWQpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbnNbdHhJZF07XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlcyB0aGUgdHhNZXRhIGluIHRoZSBsaXN0IGFuZCBhZGRzIGEgaGlzdG9yeSBlbnRyeVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHR4TWV0YSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub3RlXSAtIGEgbm90ZSBhYm91dCB0aGUgdXBkYXRlIGZvciBoaXN0b3J5XG4gICAqL1xuICB1cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEsIG5vdGUpIHtcbiAgICAvLyBub3JtYWxpemUgYW5kIHZhbGlkYXRlIHR4UGFyYW1zIGlmIHByZXNlbnRcbiAgICBpZiAodHhNZXRhLnR4UGFyYW1zKSB7XG4gICAgICB0eE1ldGEudHhQYXJhbXMgPSBub3JtYWxpemVBbmRWYWxpZGF0ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0eE1ldGEgc25hcHNob3QgZm9yIGhpc3RvcnlcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzbmFwc2hvdEZyb21UeE1ldGEodHhNZXRhKTtcbiAgICAvLyByZWNvdmVyIHByZXZpb3VzIHR4IHN0YXRlIG9ialxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSByZXBsYXlIaXN0b3J5KHR4TWV0YS5oaXN0b3J5KTtcbiAgICAvLyBnZW5lcmF0ZSBoaXN0b3J5IGVudHJ5IGFuZCBhZGQgdG8gaGlzdG9yeVxuICAgIGNvbnN0IGVudHJ5ID0gZ2VuZXJhdGVIaXN0b3J5RW50cnkocHJldmlvdXNTdGF0ZSwgY3VycmVudFN0YXRlLCBub3RlKTtcbiAgICBpZiAoZW50cnkubGVuZ3RoKSB7XG4gICAgICB0eE1ldGEuaGlzdG9yeS5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICAvLyBjb21taXQgdHhNZXRhIHRvIHN0YXRlXG4gICAgY29uc3QgdHhJZCA9IHR4TWV0YS5pZDtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczoge1xuICAgICAgICAuLi50aGlzLnN0b3JlLmdldFN0YXRlKCkudHJhbnNhY3Rpb25zLFxuICAgICAgICBbdHhJZF06IHR4TWV0YSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoQ3JpdGVyaWEgY2FuIHNlYXJjaCBpbiBhbnkga2V5IGluIFR4UGFyYW1zIG9yIHRoZSBiYXNlXG4gICAqIFRyYW5zYWN0aW9uTWV0YS4gVGhpcyB0eXBlIHJlcHJlc2VudHMgYW55IGtleSBvbiBlaXRoZXIgb2YgdGhvc2UgdHdvXG4gICAqIHR5cGVzLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7VHhQYXJhbXNba2V5b2YgVHhQYXJhbXNdIHwgVHJhbnNhY3Rpb25NZXRhW2tleW9mIFRyYW5zYWN0aW9uTWV0YV19IFNlYXJjaGFibGVLZXlzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBQcmVkaWNhdGVzIGNhbiBlaXRoZXIgYmUgc3RyaWN0IHZhbHVlcywgd2hpY2ggaXMgc2hvcnRoYW5kIGZvciB1c2luZ1xuICAgKiBzdHJpY3QgZXF1YWxpdHksIG9yIGEgbWV0aG9kIHRoYXQgcmVjZWl2ZXMgaGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXlcbiAgICogYW5kIHJldHVybnMgYSBib29sZWFuLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7KHY6IHVua25vd24pID0+IGJvb2xlYW4gfCB1bmtub3dufSBGaWx0ZXJQcmVkaWNhdGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgZnJvbSBzdGF0ZS4gQnkgZGVmYXVsdCB0aGlzIHdpbGwgcmV0dXJuXG4gICAqIHRoZSBmdWxsIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNoYWluL25ldHdvcmsuXG4gICAqIEFkZGl0aW9uYWwgb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgdG8gY2hhbmdlIHdoYXQgaXMgaW5jbHVkZWQgaW4gdGhlIGZpbmFsXG4gICAqIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyB0byBjaGFuZ2UgZmlsdGVyIGJlaGF2aW9yXG4gICAqIEBwYXJhbSB7UmVjb3JkPFNlYXJjaGFibGVLZXlzLCBGaWx0ZXJQcmVkaWNhdGU+fSBbb3B0cy5zZWFyY2hDcml0ZXJpYV0gLVxuICAgKiAgYW4gb2JqZWN0IHdpdGgga2V5cyB0aGF0IG1hdGNoIGtleXMgaW4gVHJhbnNhY3Rpb25NZXRhIG9yIFR4UGFyYW1zLCBhbmRcbiAgICogIHZhbHVlcyB0aGF0IGFyZSBwcmVkaWNhdGVzLiBQcmVkaWNhdGVzIGNhbiBlaXRoZXIgYmUgc3RyaWN0IHZhbHVlcyxcbiAgICogIHdoaWNoIGlzIHNob3J0aGFuZCBmb3IgdXNpbmcgc3RyaWN0IGVxdWFsaXR5LCBvciBhIG1ldGhvZCB0aGF0IHJlY2VpdmVzXG4gICAqICB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkgYW5kIHJldHVybnMgYSBib29sZWFuLiBUaGUgdHJhbnNhY3Rpb25cbiAgICogIGxpc3Qgd2lsbCBiZSBmaWx0ZXJlZCB0byBvbmx5IHRob3NlIGl0ZW1zIHRoYXQgdGhlIHByZWRpY2F0ZSByZXR1cm5zXG4gICAqICB0cnV0aHkgZm9yLiAqKkhJTlQqKjogYGVycjogdW5kZWZpbmVkYCBpcyBsaWtlIGxvb2tpbmcgZm9yIGEgdHggd2l0aCBub1xuICAgKiAgZXJyLiBzbyB5b3UgY2FuIGFsc28gc2VhcmNoIHR4cyB0aGF0IGRvbid0IGhhdmUgc29tZXRoaW5nIGFzIHdlbGwgYnlcbiAgICogIHNldHRpbmcgdGhlIHZhbHVlIGFzIHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbk1ldGFbXX0gW29wdHMuaW5pdGlhbExpc3RdIC0gSWYgcHJvdmlkZWQgdGhlIGZpbHRlcmluZ1xuICAgKiAgd2lsbCBvY2N1ciBvbiB0aGUgcHJvdmlkZWQgbGlzdC4gQnkgZGVmYXVsdCB0aGlzIHdpbGwgYmUgdGhlIGZ1bGwgbGlzdFxuICAgKiAgZnJvbSBzdGF0ZSBzb3J0ZWQgYnkgdGltZSBBU0MuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmlsdGVyVG9DdXJyZW50TmV0d29ya10gLSBGaWx0ZXIgdHJhbnNhY3Rpb25cbiAgICogIGxpc3QgdG8gb25seSB0aG9zZSB0aGF0IG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGNoYWluIG9yIG5ldHdvcmsuXG4gICAqICBEZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubGltaXRdIC0gbGltaXQgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgcmV0dXJuZWRcbiAgICogIHRvIE4gdW5pcXVlIG5vbmNlcy5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfSBUaGUgVHJhbnNhY3Rpb25NZXRhIG9iamVjdHMgdGhhdCBhbGwgcHJvdmlkZWRcbiAgICogIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSBmb3IuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbnMoe1xuICAgIHNlYXJjaENyaXRlcmlhID0ge30sXG4gICAgaW5pdGlhbExpc3QsXG4gICAgZmlsdGVyVG9DdXJyZW50TmV0d29yayA9IHRydWUsXG4gICAgbGltaXQsXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgY29uc3QgbmV0d29yayA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIC8vIHNlYXJjaENyaXRlcmlhIGlzIGFuIG9iamVjdCB0aGF0IG1pZ2h0IGhhdmUgdmFsdWVzIHRoYXQgYXJlbid0IHByZWRpY2F0ZVxuICAgIC8vIG1ldGhvZHMuIFdoZW4gcHJvdmlkaW5nIGFueSBvdGhlciB2YWx1ZSB0eXBlIChzdHJpbmcsIG51bWJlciwgZXRjKSwgd2VcbiAgICAvLyBjb25zaWRlciB0aGlzIHNob3J0aGFuZCBmb3IgXCJjaGVjayB0aGUgdmFsdWUgYXQga2V5IGZvciBzdHJpY3QgZXF1YWxpdHlcbiAgICAvLyB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZVwiLiBUbyBjb25mb3JtIHRoaXMgb2JqZWN0IHRvIGJlIG9ubHkgbWV0aG9kcywgd2VcbiAgICAvLyBtYXBWYWx1ZXMgKGxvZGFzaCkgc3VjaCB0aGF0IGV2ZXJ5IHZhbHVlIG9uIHRoZSBvYmplY3QgaXMgYSBtZXRob2QgdGhhdFxuICAgIC8vIHJldHVybnMgYSBib29sZWFuLlxuICAgIGNvbnN0IHByZWRpY2F0ZU1ldGhvZHMgPSBtYXBWYWx1ZXMoc2VhcmNoQ3JpdGVyaWEsIChwcmVkaWNhdGUpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgcHJlZGljYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcHJlZGljYXRlXG4gICAgICAgIDogKHYpID0+IHYgPT09IHByZWRpY2F0ZTtcbiAgICB9KTtcblxuICAgIC8vIElmIGFuIGluaXRpYWwgbGlzdCBpcyBwcm92aWRlZCB3ZSBuZWVkIHRvIGNoYW5nZSBpdCBiYWNrIGludG8gYW4gb2JqZWN0XG4gICAgLy8gZmlyc3QsIHNvIHRoYXQgaXQgbWF0Y2hlcyB0aGUgc2hhcGUgb2Ygb3VyIHN0YXRlLiBUaGlzIGlzIGRvbmUgYnkgdGhlXG4gICAgLy8gbG9kYXNoIGtleUJ5IG1ldGhvZC4gVGhpcyBpcyB0aGUgZWRnZSBjYXNlIGZvciB0aGlzIG1ldGhvZCwgdHlwaWNhbGx5XG4gICAgLy8gaW5pdGlhbExpc3Qgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zVG9GaWx0ZXIgPSBpbml0aWFsTGlzdFxuICAgICAgPyBrZXlCeShpbml0aWFsTGlzdCwgJ2lkJylcbiAgICAgIDogdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnRyYW5zYWN0aW9ucztcblxuICAgIC8vIENvbWJpbmUgc29ydEJ5IGFuZCBwaWNrQnkgdG8gdHJhbnNmb3JtIG91ciBzdGF0ZSBvYmplY3QgaW50byBhbiBhcnJheSBvZlxuICAgIC8vIG1hdGNoaW5nIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBzb3J0ZWQgYnkgdGltZS5cbiAgICBjb25zdCBmaWx0ZXJlZFRyYW5zYWN0aW9ucyA9IHNvcnRCeShcbiAgICAgIHBpY2tCeSh0cmFuc2FjdGlvbnNUb0ZpbHRlciwgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIGRlZmF1bHQgbWF0Y2hlc0NyaXRlcmlhIHRvIHRoZSB2YWx1ZSBvZiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrXG4gICAgICAgIC8vIHdoZW4gZmlsdGVyVG9DdXJyZW50TmV0d29yayBpcyB0cnVlLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsdGVyVG9DdXJyZW50TmV0d29yayAmJlxuICAgICAgICAgIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHJhbnNhY3Rpb24sIGNoYWluSWQsIG5ldHdvcmspID09PSBmYWxzZVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBwcmVkaWNhdGVNZXRob2RzIGtleXMgdG8gY2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIG1hdGNoZXMgdGhlIHNlYXJjaENyaXRlcmlhXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJlZGljYXRlXSBvZiBPYmplY3QuZW50cmllcyhwcmVkaWNhdGVNZXRob2RzKSkge1xuICAgICAgICAgIC8vIFdlIHJldHVybiBmYWxzZSBlYXJseSBhcyBzb29uIGFzIHdlIGtub3cgdGhhdCBvbmUgb2YgdGhlIHNwZWNpZmllZFxuICAgICAgICAgIC8vIHNlYXJjaCBjcml0ZXJpYSBkbyBub3QgbWF0Y2ggdGhlIHRyYW5zYWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgICAgICAgLy8gbmVlZGxlc3NseSBjaGVja2luZyBhbGwgY3JpdGVyaWEgd2hlbiB3ZSBhbHJlYWR5IGtub3cgdGhlIGNyaXRlcmlhXG4gICAgICAgICAgLy8gYXJlIG5vdCBmdWxseSBzYXRpc2ZpZWQuIFdlIGNoZWNrIGJvdGggdHhQYXJhbXMgYW5kIHRoZSBiYXNlXG4gICAgICAgICAgLy8gb2JqZWN0IGFzIHByZWRpY2F0ZSBrZXlzIGNhbiBiZSBlaXRoZXIuXG4gICAgICAgICAgaWYgKGtleSBpbiB0cmFuc2FjdGlvbi50eFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh0cmFuc2FjdGlvbi50eFBhcmFtc1trZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlKHRyYW5zYWN0aW9uW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSksXG4gICAgICAndGltZScsXG4gICAgKTtcbiAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBoYXZlIGFsbCB0cmFuc2FjdGlvbnMgb2YgYSBnaXZlbiBub25jZSBpbiBvcmRlciB0byBkaXNwbGF5XG4gICAgICAvLyBuZWNlc3NhcnkgZGV0YWlscyBpbiB0aGUgVUkuIFdlIHVzZSB0aGUgc2l6ZSBvZiB0aGlzIHNldCB0byBkZXRlcm1pbmVcbiAgICAgIC8vIHdoZXRoZXIgd2UgaGF2ZSByZWFjaGVkIHRoZSBsaW1pdCBwcm92aWRlZCwgdGh1cyBlbnN1cmluZyB0aGF0IGFsbFxuICAgICAgLy8gdHJhbnNhY3Rpb25zIG9mIG5vbmNlcyB3ZSBpbmNsdWRlIHdpbGwgYmUgc2VudCB0byB0aGUgVUkuXG4gICAgICBjb25zdCBub25jZXMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCB0eHMgPSBbXTtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0cmFuc2FjdGlvbiBsaXN0IHdlIGZpbHRlciBmcm9tIGlzIHNvcnRlZCBieSB0aW1lIEFTQy5cbiAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IGZpbHRlcmVkIHJlc3VsdHMgcHJlZmVycyB0aGUgbmV3ZXN0IHRyYW5zYWN0aW9ucyB3ZVxuICAgICAgLy8gaXRlcmF0ZSBmcm9tIHJpZ2h0IHRvIGxlZnQsIGluc2VydGluZyB0cmFuc2FjdGlvbnMgaW50byBmcm9udCBvZiBhIG5ld1xuICAgICAgLy8gYXJyYXkuIFRoZSBvcmlnaW5hbCBvcmRlciBpcyBwcmVzZXJ2ZWQsIGJ1dCB3ZSBlbnN1cmUgdGhhdCBuZXdlc3QgdHhzXG4gICAgICAvLyBhcmUgcHJlZmVycmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGZpbHRlcmVkVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHR4TWV0YSA9IGZpbHRlcmVkVHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICBjb25zdCB7IG5vbmNlIH0gPSB0eE1ldGEudHhQYXJhbXM7XG4gICAgICAgIGlmICghbm9uY2VzLmhhcyhub25jZSkpIHtcbiAgICAgICAgICBpZiAobm9uY2VzLnNpemUgPCBsaW1pdCkge1xuICAgICAgICAgICAgbm9uY2VzLmFkZChub25jZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIHRyYW5zYWN0aW9uIGludG8gdGhlIGJlZ2lubmluZyBvZiBvdXIgYXJyYXkgdG8gZW5zdXJlIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCBvcmRlciBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHR4cy51bnNoaWZ0KHR4TWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHhzO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRUcmFuc2FjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ3JlamVjdGVkJy5cbiAgICogQWZ0ZXIgc2V0dGluZyB0aGUgc3RhdHVzLCB0aGUgVHJhbnNhY3Rpb25NZXRhIGlzIGRlbGV0ZWQgZnJvbSBzdGF0ZS5cbiAgICpcbiAgICogVE9ETzogU2hvdWxkIHdlIHNob3cgaGlzdG9yaWNhbGx5IHJlamVjdGVkIHRyYW5zYWN0aW9ucyBzb21ld2hlcmUgaW4gdGhlXG4gICAqIFVJPyBTZWVtcyBsaWtlIGl0IGNvdWxkIGJlIHZhbHVhYmxlIGZvciBpbmZvcm1hdGlvbiBwdXJwb3Nlcy4gT2YgY291cnNlXG4gICAqIG9ubHkgYWZ0ZXIgbGltaXQgaXNzdWVzIGFyZSByZWR1Y2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0YXJnZXQgVHJhbnNhY3Rpb25NZXRhJ3MgSWRcbiAgICovXG4gIHNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlJFSkVDVEVEKTtcbiAgICB0aGlzLl9kZWxldGVUcmFuc2FjdGlvbih0eElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGEgd2l0aCBwcm92aWRlZCBpZCB0byAndW5hcHByb3ZlZCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c1VuYXBwcm92ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0dXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHByb3ZpZGVkIGlkIHRvICdhcHByb3ZlZCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c0FwcHJvdmVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ3NpZ25lZCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c1NpZ25lZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVFJBTlNBQ1RJT05fU1RBVFVTRVMuU0lHTkVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGEgd2l0aCBwcm92aWRlZCBpZCB0byAnc3VibWl0dGVkJ1xuICAgKiBhbmQgc2V0cyB0aGUgJ3N1Ym1pdHRlZFRpbWUnIHByb3BlcnR5IHdpdGggdGhlIGN1cnJlbnQgVW5peCBlcG9jaCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0YXJnZXQgVHJhbnNhY3Rpb25NZXRhJ3MgSWRcbiAgICovXG4gIHNldFR4U3RhdHVzU3VibWl0dGVkKHR4SWQpIHtcbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHR4TWV0YS5zdWJtaXR0ZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEsICd0eFN0YXRlTWFuYWdlciAtIGFkZCBzdWJtaXR0ZWQgdGltZSBzdGFtcCcpO1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ2NvbmZpcm1lZCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c0NvbmZpcm1lZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVFJBTlNBQ1RJT05fU1RBVFVTRVMuQ09ORklSTUVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGEgd2l0aCBwcm92aWRlZCBpZCB0byAnZHJvcHBlZCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c0Ryb3BwZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkRST1BQRUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0dXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHByb3ZpZGVkIGlkIHRvICdmYWlsZWQnIGFuZCBwdXRcbiAgICogdGhlIGVycm9yIG9uIHRoZSBUcmFuc2FjdGlvbk1ldGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSB0YXJnZXQgVHJhbnNhY3Rpb25NZXRhJ3MgSWRcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gZXJyb3Igb2JqZWN0XG4gICAqL1xuICBzZXRUeFN0YXR1c0ZhaWxlZCh0eElkLCBlcnIpIHtcbiAgICBjb25zdCBlcnJvciA9IGVyciB8fCBuZXcgRXJyb3IoJ0ludGVybmFsIG1ldGFtYXNrIGZhaWx1cmUnKTtcblxuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgdHhNZXRhLmVyciA9IHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2U/LnRvU3RyaW5nKCkgfHwgZXJyb3IudG9TdHJpbmcoKSxcbiAgICAgIHJwYzogZXJyb3IudmFsdWUsXG4gICAgICBzdGFjazogZXJyb3Iuc3RhY2ssXG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKFxuICAgICAgdHhNZXRhLFxuICAgICAgJ3RyYW5zYWN0aW9uczp0eC1zdGF0ZS1tYW5hZ2VyI2ZhaWwgLSBhZGQgZXJyb3InLFxuICAgICk7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0cmFuc2FjdGlvbnMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzIG9uIHRoZSBjdXJyZW50IG5ldHdvcmssXG4gICAqIHByZWZlcnJpbmcgY2hhaW5JZCBmb3IgY29tcGFyaXNvbiBvdmVyIG5ldHdvcmtJZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBoZXggc3RyaW5nIG9mIHRoZSBmcm9tIGFkZHJlc3Mgb24gdGhlIHR4UGFyYW1zXG4gICAqICB0byByZW1vdmVcbiAgICovXG4gIHdpcGVUcmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgIC8vIG5ldHdvcmsgb25seSB0eFxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgbmV0d29yayA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG5cbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogb21pdEJ5KFxuICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgICh0cmFuc2FjdGlvbikgPT5cbiAgICAgICAgICB0cmFuc2FjdGlvbi50eFBhcmFtcy5mcm9tID09PSBhZGRyZXNzICYmXG4gICAgICAgICAgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCwgbmV0d29yayksXG4gICAgICApLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgb3V0IHRoZSB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlXG4gICAqL1xuICBjbGVhclVuYXBwcm92ZWRUeHMoKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IG9taXRCeShcbiAgICAgICAgdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnRyYW5zYWN0aW9ucyxcbiAgICAgICAgKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQsXG4gICAgICApLFxuICAgIH0pO1xuICB9XG5cbiAgLy9cbiAgLy8gICAgICAgICAgIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgdHJhbnNhY3Rpb24ncyBzdGF0dXMgaW4gc3RhdGUsIGFuZCB0aGVuIGVtaXRzIGV2ZW50cyB0aGF0IGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvIGVsc2V3aGVyZS4gU2VlIGJlbG93IGZvciBiZXN0IGd1ZXNzZXMgb24gd2hlcmUgYW5kIGhvdyB0aGVzZVxuICAgKiBldmVudHMgYXJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZCAtIHRoZSBUcmFuc2FjdGlvbk1ldGEgSWRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblN0YXR1c1N0cmluZ30gc3RhdHVzIC0gdGhlIHN0YXR1cyB0byBzZXQgb24gdGhlXG4gICAqICBUcmFuc2FjdGlvbk1ldGFcbiAgICogQGZpcmVzIHR4TWV0YS5pZDp0eE1ldGEuc3RhdHVzIC0gZXZlcnkgdGltZSBhIHRyYW5zYWN0aW9uJ3Mgc3RhdHVzIGNoYW5nZXNcbiAgICogIHdlIGVtaXQgdGhlIGNoYW5nZSBwYXNzaW5nIGFsb25nIHRoZSBpZC4gVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgdXNlZFxuICAgKiAgb3V0c2lkZSBvZiB0aGlzIGZpbGUsIHdoaWNoIG9ubHkgbGlzdGVucyB0byB0aGlzIHRvIHVuc3Vic2NyaWJlIGxpc3RlbmVyc1xuICAgKiAgb2YgOnJlamVjdGVkIGFuZCA6c2lnbmVkIHN0YXR1c2VzIHdoZW4gdGhlIGludmVyc2Ugc3RhdHVzIGNoYW5nZXMuIExpa2VseVxuICAgKiAgc2FmZSB0byBkcm9wLlxuICAgKiBAZmlyZXMgdHg6c3RhdHVzLXVwZGF0ZSAtIGV2ZXJ5IHRpbWUgYSB0cmFuc2FjdGlvbidzIHN0YXR1cyBjaGFuZ2VzIHdlXG4gICAqICBlbWl0IHRoaXMgZXZlbnQgYW5kIHBhc3MgdHhJZCBhbmQgc3RhdHVzLiBUaGlzIGV2ZW50IGlzIHN1YnNjcmliZWQgdG8gaW5cbiAgICogIHRoZSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgYW5kIHJlLWJyb2FkY2FzdCBieSB0aGUgVHJhbnNhY3Rpb25Db250cm9sbGVyLlxuICAgKiAgSXQgaXMgdXNlZCBpbnRlcm5hbGx5IHdpdGhpbiB0aGUgVHJhbnNhY3Rpb25Db250cm9sbGVyIHRvIHRyeSBhbmQgdXBkYXRlXG4gICAqICBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBlYWNoIG5ldyBibG9jayAoZnJvbSBibG9ja1RyYWNrZXIpLiBJdCdzIGFsc29cbiAgICogIHN1YnNjcmliZWQgdG8gaW4gbWV0YW1hc2stY29udHJvbGxlciB0byBkaXNwbGF5IGEgYnJvd3NlciBub3RpZmljYXRpb24gb25cbiAgICogIGNvbmZpcm1lZCBvciBmYWlsZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBAZmlyZXMgdHhNZXRhLmlkOmZpbmlzaGVkIC0gV2hlbiBhIHRyYW5zYWN0aW9uIG1vdmVzIHRvIGEgZmluaXNoZWQgc3RhdGVcbiAgICogIHRoaXMgZXZlbnQgaXMgZW1pdHRlZCwgd2hpY2ggaXMgdXNlZCBpbiB0aGUgVHJhbnNhY3Rpb25Db250cm9sbGVyIHRvIHBhc3NcbiAgICogIGFsb25nIGRldGFpbHMgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBkYXBwIHRoYXQgc3VnZ2VzdGVkIHRoZW0uIFRoaXNcbiAgICogIHBhdHRlcm4gaXMgcmVwbGljYXRlZCBhY3Jvc3MgYWxsIG9mIHRoZSBtZXNzYWdlIG1hbmFnZXJzIGFuZCBjYW4gbGlrZWx5XG4gICAqICBiZSBzdXBwbGVtZW50ZWQgb3IgcmVwbGFjZWQgYnkgdGhlIEFwcHJvdmFsQ29udHJvbGxlci5cbiAgICogQGZpcmVzIHVwZGF0ZUJhZGdlIC0gV2hlbiB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBjaGFuZ2VzIGluIHN0YXRlLFxuICAgKiAgdGhlIGJhZGdlIGluIHRoZSBicm93c2VyIGV4dGVuc2lvbiBiYXIgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGVcbiAgICogIG51bWJlciBvZiBwZW5kaW5nIHRyYW5zYWN0aW9ucy4gVGhpcyBwYXJ0aWN1bGFyIGVtaXQgZG9lc24ndCBhcHBlYXIgdG9cbiAgICogIGJ1YmJsZSB1cCBhbnl3aGVyZSB0aGF0IGlzIGFjdHVhbGx5IHVzZWQuIFRyYW5zYWN0aW9uQ29udHJvbGxlciBlbWl0c1xuICAgKiAgdGhpcyAqYW55dGltZSB0aGUgc3RhdGUgY2hhbmdlcyosIHNvIHRoaXMgaXMgcHJvYmFibHkgc3VwZXJmbHVvdXMuXG4gICAqL1xuICBfc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgc3RhdHVzKSB7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbih0eElkKTtcblxuICAgIGlmICghdHhNZXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHhNZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgICAgdHhNZXRhLFxuICAgICAgICBgdHhTdGF0ZU1hbmFnZXI6IHNldHRpbmcgc3RhdHVzIHRvICR7c3RhdHVzfWAsXG4gICAgICApO1xuICAgICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06JHtzdGF0dXN9YCwgdHhJZCk7XG4gICAgICB0aGlzLmVtaXQoYHR4OnN0YXR1cy11cGRhdGVgLCB0eElkLCBzdGF0dXMpO1xuICAgICAgaWYgKFxuICAgICAgICBbXG4gICAgICAgICAgVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVELFxuICAgICAgICAgIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlJFSkVDVEVELFxuICAgICAgICAgIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRCxcbiAgICAgICAgXS5pbmNsdWRlcyhzdGF0dXMpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06ZmluaXNoZWRgLCB0eE1ldGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgdHJhbnNhY3Rpb25zIGludG8gc3RhdGUuIFRoaXMgaXMgbm90IGludGVuZGVkIGZvclxuICAgKiBleHRlcm5hbCB1c2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25NZXRhW119IHRyYW5zYWN0aW9ucyAtIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyB0byBzYXZlXG4gICAqL1xuICBfYWRkVHJhbnNhY3Rpb25zVG9TdGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnJlZHVjZSgocmVzdWx0LCBuZXdUeCkgPT4ge1xuICAgICAgICByZXN1bHRbbmV3VHguaWRdID0gbmV3VHg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB0aGlzLnN0b3JlLmdldFN0YXRlKCkudHJhbnNhY3Rpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmVzIG9uZSB0cmFuc2FjdGlvbiBmcm9tIHN0YXRlLiBUaGlzIGlzIG5vdCBpbnRlbmRlZCBmb3IgZXh0ZXJuYWwgdXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0VHJhbnNhY3Rpb25JZCAtIHRoZSB0cmFuc2FjdGlvbiB0byBkZWxldGVcbiAgICovXG4gIF9kZWxldGVUcmFuc2FjdGlvbih0YXJnZXRUcmFuc2FjdGlvbklkKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBkZWxldGUgdHJhbnNhY3Rpb25zW3RhcmdldFRyYW5zYWN0aW9uSWRdO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZXMgbXVsdGlwbGUgdHJhbnNhY3Rpb24gZnJvbSBzdGF0ZS4gVGhpcyBpcyBub3QgaW50ZW5kZWQgZm9yIGV4dGVybmFsIHVzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gdGFyZ2V0VHJhbnNhY3Rpb25JZHMgLSB0aGUgdHJhbnNhY3Rpb25zIHRvIGRlbGV0ZVxuICAgKi9cbiAgX2RlbGV0ZVRyYW5zYWN0aW9ucyh0YXJnZXRUcmFuc2FjdGlvbklkcykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGFyZ2V0VHJhbnNhY3Rpb25JZHMuZm9yRWFjaCgodHJhbnNhY3Rpb25JZCkgPT4ge1xuICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkXTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aGpzLXF1ZXJ5JztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBoZXhUb0JuLCBCbk11bHRpcGx5QnlGcmFjdGlvbiwgYm5Ub0hleCB9IGZyb20gJy4uLy4uL2xpYi91dGlsJztcblxuLyoqXG4gKiBSZXN1bHQgb2YgZ2FzIGFuYWx5c2lzLCBpbmNsdWRpbmcgZWl0aGVyIGEgZ2FzIGVzdGltYXRlIGZvciBhIHN1Y2Nlc3NmdWwgYW5hbHlzaXMsIG9yXG4gKiBkZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgYSBmYWlsZWQgYW5hbHlzaXMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gR2FzQW5hbHlzaXNSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBibG9ja0dhc0xpbWl0IC0gVGhlIGdhcyBsaW1pdCBvZiB0aGUgYmxvY2sgdXNlZCBmb3IgdGhlIGFuYWx5c2lzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXN0aW1hdGVkR2FzSGV4IC0gVGhlIGVzdGltYXRlZCBnYXMsIGluIGhleGFkZWNpbWFsXG4gKiBAcHJvcGVydHkge09iamVjdH0gc2ltdWxhdGlvbkZhaWxzIC0gRGVidWcgaW5mb3JtYXRpb24gYWJvdXQgd2h5IGFuIGFuYWx5c2lzIGZhaWxlZFxuICovXG5cbi8qKlxuICogdHgtZ2FzLXV0aWxzIGFyZSBnYXMgdXRpbGl0eSBtZXRob2RzIGZvciBUcmFuc2FjdGlvbiBtYW5hZ2VyXG4gKiBpdHMgcGFzc2VkIGV0aHF1ZXJ5XG4gKiBhbmQgdXNlZCB0byBkbyB0aGluZ3MgbGlrZSBjYWxjdWxhdGUgZ2FzIG9mIGEgdHguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3ZpZGVyIC0gQSBuZXR3b3JrIHByb3ZpZGVyLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR4R2FzVXRpbCB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5xdWVyeSA9IG5ldyBFdGhRdWVyeShwcm92aWRlcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtHYXNBbmFseXNpc1Jlc3VsdH0gVGhlIHJlc3VsdCBvZiB0aGUgZ2FzIGFuYWx5c2lzXG4gICAqL1xuICBhc3luYyBhbmFseXplR2FzVXNhZ2UodHhNZXRhKSB7XG4gICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldEJsb2NrQnlOdW1iZXIoJ2xhdGVzdCcsIGZhbHNlKTtcblxuICAgIC8vIGZhbGxiYWNrIHRvIGJsb2NrIGdhc0xpbWl0XG4gICAgY29uc3QgYmxvY2tHYXNMaW1pdEJOID0gaGV4VG9CbihibG9jay5nYXNMaW1pdCk7XG4gICAgY29uc3Qgc2FmZXJHYXNMaW1pdEJOID0gQm5NdWx0aXBseUJ5RnJhY3Rpb24oYmxvY2tHYXNMaW1pdEJOLCAxOSwgMjApO1xuICAgIGxldCBlc3RpbWF0ZWRHYXNIZXggPSBiblRvSGV4KHNhZmVyR2FzTGltaXRCTik7XG4gICAgbGV0IHNpbXVsYXRpb25GYWlscztcbiAgICB0cnkge1xuICAgICAgZXN0aW1hdGVkR2FzSGV4ID0gYXdhaXQgdGhpcy5lc3RpbWF0ZVR4R2FzKHR4TWV0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy53YXJuKGVycm9yKTtcbiAgICAgIHNpbXVsYXRpb25GYWlscyA9IHtcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBlcnJvcktleTogZXJyb3IuZXJyb3JLZXksXG4gICAgICAgIGRlYnVnOiB7IGJsb2NrTnVtYmVyOiBibG9jay5udW1iZXIsIGJsb2NrR2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0IH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGJsb2NrR2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LCBlc3RpbWF0ZWRHYXNIZXgsIHNpbXVsYXRpb25GYWlscyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyB0aGUgdHgncyBnYXMgdXNhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eE1ldGEgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlc3RpbWF0ZWQgZ2FzIGxpbWl0IGFzIGEgaGV4IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVUeEdhcyh0eE1ldGEpIHtcbiAgICBjb25zdCB0eFBhcmFtcyA9IGNsb25lRGVlcCh0eE1ldGEudHhQYXJhbXMpO1xuXG4gICAgLy8gYGV0aF9lc3RpbWF0ZUdhc2AgY2FuIGZhaWwgaWYgdGhlIHVzZXIgaGFzIGluc3VmZmljaWVudCBiYWxhbmNlIGZvciB0aGVcbiAgICAvLyB2YWx1ZSBiZWluZyBzZW50LCBvciBmb3IgdGhlIGdhcyBjb3N0LiBXZSBkb24ndCB3YW50IHRvIGNoZWNrIHRoZWlyXG4gICAgLy8gYmFsYW5jZSBoZXJlLCB3ZSBqdXN0IHdhbnQgdGhlIGdhcyBlc3RpbWF0ZS4gVGhlIGdhcyBwcmljZSBpcyByZW1vdmVkXG4gICAgLy8gdG8gc2tpcCB0aG9zZSBiYWxhbmNlIGNoZWNrcy4gV2UgY2hlY2sgYmFsYW5jZSBlbHNld2hlcmUuIFdlIGFsc28gZGVsZXRlXG4gICAgLy8gbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyB0byBzdXBwb3J0IEVJUC0xNTU5IHR4cy5cbiAgICBkZWxldGUgdHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgZGVsZXRlIHR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICBkZWxldGUgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG5cbiAgICAvLyBlc3RpbWF0ZSB0eCBnYXMgcmVxdWlyZW1lbnRzXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnkuZXN0aW1hdGVHYXModHhQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnYXMgYnVmZmVyIHdpdGggb3V0IGV4Y2VlZGluZyB0aGUgYmxvY2sgZ2FzIGxpbWl0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsR2FzTGltaXRIZXggLSB0aGUgaW5pdGlhbCBnYXMgbGltaXQgdG8gYWRkIHRoZSBidWZmZXIgdG9vXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja0dhc0xpbWl0SGV4IC0gdGhlIGJsb2NrIGdhcyBsaW1pdFxuICAgKiBAcGFyYW0gbXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYnVmZmVyZWQgZ2FzIGxpbWl0IGFzIGEgaGV4IHN0cmluZ1xuICAgKi9cbiAgYWRkR2FzQnVmZmVyKGluaXRpYWxHYXNMaW1pdEhleCwgYmxvY2tHYXNMaW1pdEhleCwgbXVsdGlwbGllciA9IDEuNSkge1xuICAgIGNvbnN0IGluaXRpYWxHYXNMaW1pdEJuID0gaGV4VG9Cbihpbml0aWFsR2FzTGltaXRIZXgpO1xuICAgIGNvbnN0IGJsb2NrR2FzTGltaXRCbiA9IGhleFRvQm4oYmxvY2tHYXNMaW1pdEhleCk7XG4gICAgY29uc3QgdXBwZXJHYXNMaW1pdEJuID0gYmxvY2tHYXNMaW1pdEJuLm11bG4oMC45KTtcbiAgICBjb25zdCBidWZmZXJlZEdhc0xpbWl0Qm4gPSBpbml0aWFsR2FzTGltaXRCbi5tdWxuKG11bHRpcGxpZXIpO1xuXG4gICAgLy8gaWYgaW5pdGlhbEdhc0xpbWl0IGlzIGFib3ZlIGJsb2NrR2FzTGltaXQsIGRvbnQgbW9kaWZ5IGl0XG4gICAgaWYgKGluaXRpYWxHYXNMaW1pdEJuLmd0KHVwcGVyR2FzTGltaXRCbikpIHtcbiAgICAgIHJldHVybiBiblRvSGV4KGluaXRpYWxHYXNMaW1pdEJuKTtcbiAgICB9XG4gICAgLy8gaWYgYnVmZmVyZWRHYXNMaW1pdCBpcyBiZWxvdyBibG9ja0dhc0xpbWl0LCB1c2UgYnVmZmVyZWRHYXNMaW1pdFxuICAgIGlmIChidWZmZXJlZEdhc0xpbWl0Qm4ubHQodXBwZXJHYXNMaW1pdEJuKSkge1xuICAgICAgcmV0dXJuIGJuVG9IZXgoYnVmZmVyZWRHYXNMaW1pdEJuKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHVzZSBibG9ja0dhc0xpbWl0XG4gICAgcmV0dXJuIGJuVG9IZXgodXBwZXJHYXNMaW1pdEJuKTtcbiAgfVxuXG4gIGFzeW5jIGdldEJ1ZmZlcmVkR2FzTGltaXQodHhNZXRhLCBtdWx0aXBsaWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tHYXNMaW1pdCxcbiAgICAgIGVzdGltYXRlZEdhc0hleCxcbiAgICAgIHNpbXVsYXRpb25GYWlscyxcbiAgICB9ID0gYXdhaXQgdGhpcy5hbmFseXplR2FzVXNhZ2UodHhNZXRhKTtcblxuICAgIC8vIGFkZCBhZGRpdGlvbmFsIGdhcyBidWZmZXIgdG8gb3VyIGVzdGltYXRpb24gZm9yIHNhZmV0eVxuICAgIGNvbnN0IGdhc0xpbWl0ID0gdGhpcy5hZGRHYXNCdWZmZXIoXG4gICAgICBhZGRIZXhQcmVmaXgoZXN0aW1hdGVkR2FzSGV4KSxcbiAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICBtdWx0aXBsaWVyLFxuICAgICk7XG4gICAgcmV0dXJuIHsgZ2FzTGltaXQsIHNpbXVsYXRpb25GYWlscyB9O1xuICB9XG59XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ3NhZmUtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBFdGhRdWVyeSBmcm9tICdldGhqcy1xdWVyeSc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuXG4vKipcbiAqIEV2ZW50IGVtaXR0ZXIgdXRpbGl0eSBjbGFzcyBmb3IgdHJhY2tpbmcgdGhlIHRyYW5zYWN0aW9ucyBhcyB0aGV5XG4gKiBnbyBmcm9tIGEgcGVuZGluZyBzdGF0ZSB0byBhIGNvbmZpcm1lZCAobWluZWQgaW4gYSBibG9jaykgc3RhdGUuXG4gKlxuICogQXMgd2VsbCBhcyBjb250aW51ZXMgYnJvYWRjYXN0IHdoaWxlIGluIHRoZSBwZW5kaW5nIHN0YXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZW5kaW5nVHJhbnNhY3Rpb25UcmFja2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFdlIHdhaXQgdGhpcyBtYW55IGJsb2NrcyBiZWZvcmUgZW1pdHRpbmcgYSAndHg6ZHJvcHBlZCcgZXZlbnRcbiAgICpcbiAgICogVGhpcyBpcyBiZWNhdXNlIHdlIGNvdWxkIGJlIHRhbGtpbmcgdG8gYSBub2RlIHRoYXQgaXMgb3V0IG9mIHN5bmMuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBEUk9QUEVEX0JVRkZFUl9DT1VOVCA9IDM7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIHRyYW5zYWN0aW9uIGhhc2hlcyB0byB0aGUgbnVtYmVyIG9mIGJsb2NrcyB3ZSd2ZSBzZWVuXG4gICAqIHNpbmNlIGZpcnN0IGNvbnNpZGVyaW5nIGl0IGRyb3BwZWRcbiAgICpcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICBkcm9wcGVkQmxvY2tzQnVmZmVyQnlIYXNoID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gQ29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmFwcHJvdmVUcmFuc2FjdGlvbiAtIEFwcHJvdmVzIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb24gLSBTZXQgYSB0cmFuc2FjdGlvbiBhcyBjb25maXJtZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5nZXRDb21wbGV0ZWRUcmFuc2FjdGlvbnMgLSBSZXR1cm5zIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zIC0gUmV0dXJucyBhbiBhcnJheSBvZiBwZW5kaW5nIHRyYW5zYWN0aW9ucyxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5ub25jZVRyYWNrZXIgLSBzZWUgbm9uY2UgdHJhY2tlclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnByb3ZpZGVyIC0gQSBuZXR3b3JrIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5wdWJsaXNoVHJhbnNhY3Rpb24gLSBQdWJsaXNoZXMgYSByYXcgdHJhbnNhY3Rpb24sXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucXVlcnkgPSBjb25maWcucXVlcnkgfHwgbmV3IEV0aFF1ZXJ5KGNvbmZpZy5wcm92aWRlcik7XG4gICAgdGhpcy5ub25jZVRyYWNrZXIgPSBjb25maWcubm9uY2VUcmFja2VyO1xuICAgIHRoaXMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyA9IGNvbmZpZy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zO1xuICAgIHRoaXMuZ2V0Q29tcGxldGVkVHJhbnNhY3Rpb25zID0gY29uZmlnLmdldENvbXBsZXRlZFRyYW5zYWN0aW9ucztcbiAgICB0aGlzLnB1Ymxpc2hUcmFuc2FjdGlvbiA9IGNvbmZpZy5wdWJsaXNoVHJhbnNhY3Rpb247XG4gICAgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gPSBjb25maWcuYXBwcm92ZVRyYW5zYWN0aW9uO1xuICAgIHRoaXMuY29uZmlybVRyYW5zYWN0aW9uID0gY29uZmlnLmNvbmZpcm1UcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgdGhlIG5ldHdvcmsgZm9yIHNpZ25lZCB0eHMgYW5kIHJlbGVhc2VzIHRoZSBub25jZSBnbG9iYWwgbG9jayBpZiBpdCBpc1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlUGVuZGluZ1R4cygpIHtcbiAgICAvLyBpbiBvcmRlciB0byBrZWVwIHRoZSBub25jZVRyYWNrZXIgYWNjdXJhdGUgd2UgYmxvY2sgaXQgd2hpbGUgdXBkYXRpbmcgcGVuZGluZyB0cmFuc2FjdGlvbnNcbiAgICBjb25zdCBub25jZUdsb2JhbExvY2sgPSBhd2FpdCB0aGlzLm5vbmNlVHJhY2tlci5nZXRHbG9iYWxMb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBwZW5kaW5nVHhzLm1hcCgodHhNZXRhKSA9PiB0aGlzLl9jaGVja1BlbmRpbmdUeCh0eE1ldGEpKSxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyb3IoXG4gICAgICAgICdQZW5kaW5nVHJhbnNhY3Rpb25UcmFja2VyIC0gRXJyb3IgdXBkYXRpbmcgcGVuZGluZyB0cmFuc2FjdGlvbnMnLFxuICAgICAgKTtcbiAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgIH1cbiAgICBub25jZUdsb2JhbExvY2sucmVsZWFzZUxvY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1Ym1pdHMgZWFjaCBwZW5kaW5nIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja051bWJlciAtIHRoZSBsYXRlc3QgYmxvY2sgbnVtYmVyIGluIGhleFxuICAgKiBAZmlyZXMgdHg6d2FybmluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHJlc3VibWl0UGVuZGluZ1R4cyhibG9ja051bWJlcikge1xuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcbiAgICBpZiAoIXBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHhNZXRhIG9mIHBlbmRpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Jlc3VibWl0VHgodHhNZXRhLCBibG9ja051bWJlcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIudmFsdWU/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCkgfHwgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaXNLbm93blR4ID1cbiAgICAgICAgICAvLyBnZXRoXG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZCcpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdrbm93biB0cmFuc2FjdGlvbicpIHx8XG4gICAgICAgICAgLy8gcGFyaXR5XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdnYXMgcHJpY2UgdG9vIGxvdyB0byByZXBsYWNlJykgfHxcbiAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXG4gICAgICAgICAgICAndHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkJyxcbiAgICAgICAgICApIHx8XG4gICAgICAgICAgLy8gb3RoZXJcbiAgICAgICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2dhdGV3YXkgdGltZW91dCcpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdub25jZSB0b28gbG93Jyk7XG4gICAgICAgIC8vIGlnbm9yZSByZXN1Ym1pdCB3YXJuaW5ncywgcmV0dXJuIGVhcmx5XG4gICAgICAgIGlmIChpc0tub3duVHgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jb3VudGVyZWQgcmVhbCBlcnJvciAtIHRyYW5zaXRpb24gdG8gZXJyb3Igc3RhdGVcbiAgICAgICAgdHhNZXRhLndhcm5pbmcgPSB7XG4gICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlcmUgd2FzIGFuIGVycm9yIHdoZW4gcmVzdWJtaXR0aW5nIHRoaXMgdHJhbnNhY3Rpb24uJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KCd0eDp3YXJuaW5nJywgdHhNZXRhLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZXN1Ym1pdCB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAqXG4gICAqIFdpbGwgb25seSBhdHRlbXB0IHRvIHJldHJ5IHRoZSBnaXZlbiB0eCBldmVyeSB7QGNvZGUgMioqKHR4TWV0YS5yZXRyeUNvdW50KX0gYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHRyYW5zYWN0aW9uIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRlc3RCbG9ja051bWJlciAtIHRoZSBsYXRlc3QgYmxvY2sgbnVtYmVyIGluIGhleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8dW5kZWZpbmVkPn0gdGhlIHR4IGhhc2ggaWYgcmV0cmllZFxuICAgKiBAZmlyZXMgdHg6YmxvY2stdXBkYXRlXG4gICAqIEBmaXJlcyB0eDpyZXRyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX3Jlc3VibWl0VHgodHhNZXRhLCBsYXRlc3RCbG9ja051bWJlcikge1xuICAgIGlmICghdHhNZXRhLmZpcnN0UmV0cnlCbG9ja051bWJlcikge1xuICAgICAgdGhpcy5lbWl0KCd0eDpibG9jay11cGRhdGUnLCB0eE1ldGEsIGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFJldHJ5QmxvY2tOdW1iZXIgPVxuICAgICAgdHhNZXRhLmZpcnN0UmV0cnlCbG9ja051bWJlciB8fCBsYXRlc3RCbG9ja051bWJlcjtcbiAgICBjb25zdCB0eEJsb2NrRGlzdGFuY2UgPVxuICAgICAgTnVtYmVyLnBhcnNlSW50KGxhdGVzdEJsb2NrTnVtYmVyLCAxNikgLVxuICAgICAgTnVtYmVyLnBhcnNlSW50KGZpcnN0UmV0cnlCbG9ja051bWJlciwgMTYpO1xuXG4gICAgY29uc3QgcmV0cnlDb3VudCA9IHR4TWV0YS5yZXRyeUNvdW50IHx8IDA7XG5cbiAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmIHRvIGxpbWl0IHJldHJpZXMgYXQgcHVibGlzaGluZyAoY2FwcGVkIGF0IH4xNSBtaW51dGVzIGJldHdlZW4gcmV0cmllcylcbiAgICBpZiAodHhCbG9ja0Rpc3RhbmNlIDwgTWF0aC5taW4oNTAsIE1hdGgucG93KDIsIHJldHJ5Q291bnQpKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGF1dG8tc3VibWl0IGFscmVhZHktc2lnbmVkIHR4czpcbiAgICBpZiAoISgncmF3VHgnIGluIHR4TWV0YSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbih0eE1ldGEuaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmF3VHggfSA9IHR4TWV0YTtcbiAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB0aGlzLnB1Ymxpc2hUcmFuc2FjdGlvbihyYXdUeCk7XG5cbiAgICAvLyBJbmNyZW1lbnQgc3VjY2Vzc2Z1bCB0cmllczpcbiAgICB0aGlzLmVtaXQoJ3R4OnJldHJ5JywgdHhNZXRhKTtcbiAgICByZXR1cm4gdHhIYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IHRoZSBuZXR3b3JrIHRvIHNlZSBpZiB0aGUgZ2l2ZW4ge0Bjb2RlIHR4TWV0YX0gaGFzIGJlZW4gaW5jbHVkZWQgaW4gYSBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHRyYW5zYWN0aW9uIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAZmlyZXMgdHg6Y29uZmlybWVkXG4gICAqIEBmaXJlcyB0eDpkcm9wcGVkXG4gICAqIEBmaXJlcyB0eDpmYWlsZWRcbiAgICogQGZpcmVzIHR4Ondhcm5pbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgYXN5bmMgX2NoZWNrUGVuZGluZ1R4KHR4TWV0YSkge1xuICAgIGNvbnN0IHR4SGFzaCA9IHR4TWV0YS5oYXNoO1xuICAgIGNvbnN0IHR4SWQgPSB0eE1ldGEuaWQ7XG5cbiAgICAvLyBPbmx5IGNoZWNrIHN1Ym1pdHRlZCB0eHNcbiAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0cmEgY2hlY2sgaW4gY2FzZSB0aGVyZSB3YXMgYW4gdW5jYXVnaHQgZXJyb3IgZHVyaW5nIHRoZVxuICAgIC8vIHNpZ25hdHVyZSBhbmQgc3VibWlzc2lvbiBwcm9jZXNzXG4gICAgaWYgKCF0eEhhc2gpIHtcbiAgICAgIGNvbnN0IG5vVHhIYXNoRXJyID0gbmV3IEVycm9yKFxuICAgICAgICAnV2UgaGFkIGFuIGVycm9yIHdoaWxlIHN1Ym1pdHRpbmcgdGhpcyB0cmFuc2FjdGlvbiwgcGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgKTtcbiAgICAgIG5vVHhIYXNoRXJyLm5hbWUgPSAnTm9UeEhhc2hFcnJvcic7XG4gICAgICB0aGlzLmVtaXQoJ3R4OmZhaWxlZCcsIHR4SWQsIG5vVHhIYXNoRXJyKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCB0aGlzLl9jaGVja0lmTm9uY2VJc1Rha2VuKHR4TWV0YSkpIHtcbiAgICAgIHRoaXMuZW1pdCgndHg6ZHJvcHBlZCcsIHR4SWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvblJlY2VpcHQgPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgaWYgKHRyYW5zYWN0aW9uUmVjZWlwdD8uYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJhc2VGZWVQZXJHYXMsXG4gICAgICAgICAgdGltZXN0YW1wOiBibG9ja1RpbWVzdGFtcCxcbiAgICAgICAgfSA9IGF3YWl0IHRoaXMucXVlcnkuZ2V0QmxvY2tCeUhhc2goXG4gICAgICAgICAgdHJhbnNhY3Rpb25SZWNlaXB0Py5ibG9ja0hhc2gsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5lbWl0KFxuICAgICAgICAgICd0eDpjb25maXJtZWQnLFxuICAgICAgICAgIHR4SWQsXG4gICAgICAgICAgdHJhbnNhY3Rpb25SZWNlaXB0LFxuICAgICAgICAgIGJhc2VGZWVQZXJHYXMsXG4gICAgICAgICAgYmxvY2tUaW1lc3RhbXAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHR4TWV0YS53YXJuaW5nID0ge1xuICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGVyZSB3YXMgYSBwcm9ibGVtIGxvYWRpbmcgdGhpcyB0cmFuc2FjdGlvbi4nLFxuICAgICAgfTtcbiAgICAgIHRoaXMuZW1pdCgndHg6d2FybmluZycsIHR4TWV0YSwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgdGhpcy5fY2hlY2tJZlR4V2FzRHJvcHBlZCh0eE1ldGEpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3R4OmRyb3BwZWQnLCB0eElkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIG5vbmNlIGluIHRoZSBnaXZlbiB7QGNvZGUgdHhNZXRhfSBpcyBiZWhpbmQgdGhlIG5ldHdvcmsgbm9uY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0cmFuc2FjdGlvbiBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9jaGVja0lmVHhXYXNEcm9wcGVkKHR4TWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhc2g6IHR4SGFzaCxcbiAgICAgIHR4UGFyYW1zOiB7IG5vbmNlLCBmcm9tIH0sXG4gICAgfSA9IHR4TWV0YTtcbiAgICBjb25zdCBuZXR3b3JrTmV4dE5vbmNlID0gYXdhaXQgdGhpcy5xdWVyeS5nZXRUcmFuc2FjdGlvbkNvdW50KGZyb20pO1xuXG4gICAgaWYgKHBhcnNlSW50KG5vbmNlLCAxNikgPj0gbmV0d29ya05leHROb25jZS50b051bWJlcigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRyb3BwZWRCbG9ja3NCdWZmZXJCeUhhc2guaGFzKHR4SGFzaCkpIHtcbiAgICAgIHRoaXMuZHJvcHBlZEJsb2Nrc0J1ZmZlckJ5SGFzaC5zZXQodHhIYXNoLCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50QmxvY2tCdWZmZXIgPSB0aGlzLmRyb3BwZWRCbG9ja3NCdWZmZXJCeUhhc2guZ2V0KHR4SGFzaCk7XG5cbiAgICBpZiAoY3VycmVudEJsb2NrQnVmZmVyIDwgdGhpcy5EUk9QUEVEX0JVRkZFUl9DT1VOVCkge1xuICAgICAgdGhpcy5kcm9wcGVkQmxvY2tzQnVmZmVyQnlIYXNoLnNldCh0eEhhc2gsIGN1cnJlbnRCbG9ja0J1ZmZlciArIDEpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZHJvcHBlZEJsb2Nrc0J1ZmZlckJ5SGFzaC5kZWxldGUodHhIYXNoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgbm9uY2UgaW4gdGhlIGdpdmVuIHtAY29kZSB0eE1ldGF9IGlzIGNvcnJlY3QgYWdhaW5zdCB0aGUgbG9jYWwgc2V0IG9mIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhNZXRhIC0gdGhlIHRyYW5zYWN0aW9uIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2NoZWNrSWZOb25jZUlzVGFrZW4odHhNZXRhKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHR4TWV0YS50eFBhcmFtcy5mcm9tO1xuICAgIGNvbnN0IGNvbXBsZXRlZCA9IHRoaXMuZ2V0Q29tcGxldGVkVHJhbnNhY3Rpb25zKGFkZHJlc3MpO1xuICAgIHJldHVybiBjb21wbGV0ZWQuc29tZShcbiAgICAgIC8vIFRoaXMgaXMgY2FsbGVkIHdoaWxlIHRoZSB0cmFuc2FjdGlvbiBpcyBpbi1mbGlnaHQsIHNvIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlXG4gICAgICAvLyBsaXN0IG9mIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgbm93IGluY2x1ZGVzIHRoZSB0cmFuc2FjdGlvbiB3ZSB3ZXJlIGxvb2tpbmcgYXRcbiAgICAgIC8vIGFuZCBpZiB0aGF0IGlzIHRoZSBjYXNlLCBkb24ndCBjb25zaWRlciB0aGUgdHJhbnNhY3Rpb24gdG8gaGF2ZSB0YWtlbiBpdHMgb3duIG5vbmNlXG4gICAgICAob3RoZXIpID0+XG4gICAgICAgICEob3RoZXIuaWQgPT09IHR4TWV0YS5pZCkgJiZcbiAgICAgICAgb3RoZXIudHhQYXJhbXMubm9uY2UgPT09IHR4TWV0YS50eFBhcmFtcy5ub25jZSxcbiAgICApO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHJlbW92ZVNsYXNoID0gcmVxdWlyZSgncmVtb3ZlLXRyYWlsaW5nLXNsYXNoJylcbmNvbnN0IGxvb3NlbHlWYWxpZGF0ZSA9IHJlcXVpcmUoJ0BzZWdtZW50L2xvb3NlbHktdmFsaWRhdGUtZXZlbnQnKVxuY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpXG5jb25zdCBheGlvc1JldHJ5ID0gcmVxdWlyZSgnYXhpb3MtcmV0cnknKVxuY29uc3QgbXMgPSByZXF1aXJlKCdtcycpXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZC92NCcpXG5jb25zdCBtZDUgPSByZXF1aXJlKCdtZDUnKVxuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvblxuY29uc3QgaXNTdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2guaXNzdHJpbmcnKVxuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IHByb2Nlc3MubmV4dFRpY2suYmluZChwcm9jZXNzKVxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNsYXNzIEFuYWx5dGljcyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IGBBbmFseXRpY3NgIHdpdGggeW91ciBTZWdtZW50IHByb2plY3QncyBgd3JpdGVLZXlgIGFuZCBhblxuICAgKiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mIGBvcHRpb25zYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHdyaXRlS2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKVxuICAgKiAgIEBwcm9wZXJ0eSB7TnVtYmVyfSBmbHVzaEF0IChkZWZhdWx0OiAyMClcbiAgICogICBAcHJvcGVydHkge051bWJlcn0gZmx1c2hJbnRlcnZhbCAoZGVmYXVsdDogMTAwMDApXG4gICAqICAgQHByb3BlcnR5IHtTdHJpbmd9IGhvc3QgKGRlZmF1bHQ6ICdodHRwczovL2FwaS5zZWdtZW50LmlvJylcbiAgICogICBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZSAoZGVmYXVsdDogdHJ1ZSlcbiAgICovXG5cbiAgY29uc3RydWN0b3IgKHdyaXRlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIGFzc2VydCh3cml0ZUtleSwgJ1lvdSBtdXN0IHBhc3MgeW91ciBTZWdtZW50IHByb2plY3RcXCdzIHdyaXRlIGtleS4nKVxuXG4gICAgdGhpcy5xdWV1ZSA9IFtdXG4gICAgdGhpcy53cml0ZUtleSA9IHdyaXRlS2V5XG4gICAgdGhpcy5ob3N0ID0gcmVtb3ZlU2xhc2gob3B0aW9ucy5ob3N0IHx8ICdodHRwczovL2FwaS5zZWdtZW50LmlvJylcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgZmFsc2VcbiAgICB0aGlzLmZsdXNoQXQgPSBNYXRoLm1heChvcHRpb25zLmZsdXNoQXQsIDEpIHx8IDIwXG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gb3B0aW9ucy5mbHVzaEludGVydmFsIHx8IDEwMDAwXG4gICAgdGhpcy5mbHVzaGVkID0gZmFsc2VcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VuYWJsZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHR5cGVvZiBvcHRpb25zLmVuYWJsZSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5lbmFibGUgOiB0cnVlXG4gICAgfSlcbiAgICB0aGlzLmF4aW9zQ2xpZW50ID0gYXhpb3MuY3JlYXRlKClcbiAgICBheGlvc1JldHJ5KHRoaXMuYXhpb3NDbGllbnQsIHtcbiAgICAgIHJldHJpZXM6IG9wdGlvbnMucmV0cnlDb3VudCB8fCAzLFxuICAgICAgcmV0cnlDb25kaXRpb246IHRoaXMuX2lzRXJyb3JSZXRyeWFibGUsXG4gICAgICByZXRyeURlbGF5OiBheGlvc1JldHJ5LmV4cG9uZW50aWFsRGVsYXlcbiAgICB9KVxuICB9XG5cbiAgX3ZhbGlkYXRlIChtZXNzYWdlLCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvb3NlbHlWYWxpZGF0ZShtZXNzYWdlLCB0eXBlKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2UgPT09ICdZb3VyIG1lc3NhZ2UgbXVzdCBiZSA8IDMya2IuJykge1xuICAgICAgICBjb25zb2xlLmxvZygnWW91ciBtZXNzYWdlIG11c3QgYmUgPCAzMmtiLiBUaGlzIGlzIGN1cnJlbnRseSBzdXJmYWNlZCBhcyBhIHdhcm5pbmcgdG8gYWxsb3cgY2xpZW50cyB0byB1cGRhdGUuIFZlcnNpb25zIHJlbGVhc2VkIGFmdGVyIEF1Z3VzdCAxLCAyMDE4IHdpbGwgdGhyb3cgYW4gZXJyb3IgaW5zdGVhZC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUgYmVmb3JlIHRoZW4uJywgbWVzc2FnZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gaWRlbnRpZnkgYG1lc3NhZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QW5hbHl0aWNzfVxuICAgKi9cblxuICBpZGVudGlmeSAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXNzYWdlLCAnaWRlbnRpZnknKVxuICAgIHRoaXMuZW5xdWV1ZSgnaWRlbnRpZnknLCBtZXNzYWdlLCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBncm91cCBgbWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBbmFseXRpY3N9XG4gICAqL1xuXG4gIGdyb3VwIChtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3ZhbGlkYXRlKG1lc3NhZ2UsICdncm91cCcpXG4gICAgdGhpcy5lbnF1ZXVlKCdncm91cCcsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYWNrIGBtZXNzYWdlYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm4ge0FuYWx5dGljc31cbiAgICovXG5cbiAgdHJhY2sgKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWVzc2FnZSwgJ3RyYWNrJylcbiAgICB0aGlzLmVucXVldWUoJ3RyYWNrJywgbWVzc2FnZSwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGFnZSBgbWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBbmFseXRpY3N9XG4gICAqL1xuXG4gIHBhZ2UgKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWVzc2FnZSwgJ3BhZ2UnKVxuICAgIHRoaXMuZW5xdWV1ZSgncGFnZScsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHNjcmVlbiBgbWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QW5hbHl0aWNzfVxuICAgKi9cblxuICBzY3JlZW4gKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWVzc2FnZSwgJ3NjcmVlbicpXG4gICAgdGhpcy5lbnF1ZXVlKCdzY3JlZW4nLCBtZXNzYWdlLCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gYWxpYXMgYG1lc3NhZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QW5hbHl0aWNzfVxuICAgKi9cblxuICBhbGlhcyAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXNzYWdlLCAnYWxpYXMnKVxuICAgIHRoaXMuZW5xdWV1ZSgnYWxpYXMnLCBtZXNzYWdlLCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGBtZXNzYWdlYCBvZiB0eXBlIGB0eXBlYCB0byB0aGUgcXVldWUgYW5kXG4gICAqIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIGZsdXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKG9wdGlvbmFsKVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZW5xdWV1ZSAodHlwZSwgbWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3BcblxuICAgIGlmICghdGhpcy5lbmFibGUpIHtcbiAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2UpXG4gICAgbWVzc2FnZS50eXBlID0gdHlwZVxuICAgIG1lc3NhZ2UuY29udGV4dCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGlicmFyeToge1xuICAgICAgICBuYW1lOiAnYW5hbHl0aWNzLW5vZGUnLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgfSwgbWVzc2FnZS5jb250ZXh0KVxuXG4gICAgbWVzc2FnZS5fbWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG5vZGVWZXJzaW9uOiBwcm9jZXNzLnZlcnNpb25zLm5vZGVcbiAgICB9LCBtZXNzYWdlLl9tZXRhZGF0YSlcblxuICAgIGlmICghbWVzc2FnZS50aW1lc3RhbXApIHtcbiAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gbmV3IERhdGUoKVxuICAgIH1cblxuICAgIGlmICghbWVzc2FnZS5tZXNzYWdlSWQpIHtcbiAgICAgIC8vIFdlIG1kNSB0aGUgbWVzc2FhZ2UgdG8gYWRkIG1vcmUgcmFuZG9tbmVzcy4gVGhpcyBpcyBwcmltYXJpbHkgbWVhbnRcbiAgICAgIC8vIGZvciB1c2UgaW4gdGhlIGJyb3dzZXIgd2hlcmUgdGhlIHV1aWQgcGFja2FnZSBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tKClcbiAgICAgIC8vIHdoaWNoIGlzIG5vdCBhIGdyZWF0IHNvdXJjZSBvZiByYW5kb21uZXNzLlxuICAgICAgLy8gQm9ycm93ZWQgZnJvbSBhbmFseXRpY3MuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50LWludGVncmF0aW9ucy9hbmFseXRpY3MuanMtaW50ZWdyYXRpb24tc2VnbWVudGlvL2Jsb2IvYTIwZDJhMmQyMjJhZWIzYWIyYThjN2U3MjI4MGYxZGYyNjE4NDQwZS9saWIvaW5kZXguanMjTDI1NS1MMjU2KS5cbiAgICAgIG1lc3NhZ2UubWVzc2FnZUlkID0gYG5vZGUtJHttZDUoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpfS0ke3V1aWQoKX1gXG4gICAgfVxuXG4gICAgLy8gSGlzdG9yaWNhbGx5IHRoaXMgbGlicmFyeSBoYXMgYWNjZXB0ZWQgc3RyaW5ncyBhbmQgbnVtYmVycyBhcyBJRHMuXG4gICAgLy8gSG93ZXZlciwgb3VyIHNwZWMgb25seSBhbGxvd3Mgc3RyaW5ncy4gVG8gYXZvaWQgYnJlYWtpbmcgY29tcGF0aWJpbGl0eSxcbiAgICAvLyB3ZSdsbCBjb2VyY2UgdGhlc2UgdG8gc3RyaW5ncyBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5LlxuICAgIGlmIChtZXNzYWdlLmFub255bW91c0lkICYmICFpc1N0cmluZyhtZXNzYWdlLmFub255bW91c0lkKSkge1xuICAgICAgbWVzc2FnZS5hbm9ueW1vdXNJZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UuYW5vbnltb3VzSWQpXG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnVzZXJJZCAmJiAhaXNTdHJpbmcobWVzc2FnZS51c2VySWQpKSB7XG4gICAgICBtZXNzYWdlLnVzZXJJZCA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UudXNlcklkKVxuICAgIH1cblxuICAgIHRoaXMucXVldWUucHVzaCh7IG1lc3NhZ2UsIGNhbGxiYWNrIH0pXG5cbiAgICBpZiAoIXRoaXMuZmx1c2hlZCkge1xuICAgICAgdGhpcy5mbHVzaGVkID0gdHJ1ZVxuICAgICAgdGhpcy5mbHVzaCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPj0gdGhpcy5mbHVzaEF0KSB7XG4gICAgICB0aGlzLmZsdXNoKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mbHVzaEludGVydmFsICYmICF0aGlzLnRpbWVyKSB7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLmZsdXNoLmJpbmQodGhpcyksIHRoaXMuZmx1c2hJbnRlcnZhbClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggdGhlIGN1cnJlbnQgcXVldWVcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm4ge0FuYWx5dGljc31cbiAgICovXG5cbiAgZmx1c2ggKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlKSB7XG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgICAgIHRoaXMudGltZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMucXVldWUuc3BsaWNlKDAsIHRoaXMuZmx1c2hBdClcbiAgICBjb25zdCBjYWxsYmFja3MgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmNhbGxiYWNrKVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5tZXNzYWdlKVxuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGJhdGNoOiBtZXNzYWdlcyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIHNlbnRBdDogbmV3IERhdGUoKVxuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSBlcnIgPT4ge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZXJyKSlcbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSlcbiAgICB9XG5cbiAgICAvLyBEb24ndCBzZXQgdGhlIHVzZXIgYWdlbnQgaWYgd2UncmUgbm90IG9uIGEgYnJvd3Nlci4gVGhlIGxhdGVzdCBzcGVjIGFsbG93c1xuICAgIC8vIHRoZSBVc2VyLUFnZW50IGhlYWRlciAoc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyN0ZXJtaW5vbG9neS1oZWFkZXJzXG4gICAgLy8gYW5kIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9zZXRSZXF1ZXN0SGVhZGVyKSxcbiAgICAvLyBidXQgYnJvd3NlcnMgc3VjaCBhcyBDaHJvbWUgYW5kIFNhZmFyaSBoYXZlIG5vdCBjYXVnaHQgdXAuXG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBoZWFkZXJzWyd1c2VyLWFnZW50J10gPSBgYW5hbHl0aWNzLW5vZGUvJHt2ZXJzaW9ufWBcbiAgICB9XG5cbiAgICBjb25zdCByZXEgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogYCR7dGhpcy5ob3N0fS92MS9iYXRjaGAsXG4gICAgICBhdXRoOiB7XG4gICAgICAgIHVzZXJuYW1lOiB0aGlzLndyaXRlS2V5XG4gICAgICB9LFxuICAgICAgZGF0YSxcbiAgICAgIGhlYWRlcnNcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICByZXEudGltZW91dCA9IHR5cGVvZiB0aGlzLnRpbWVvdXQgPT09ICdzdHJpbmcnID8gbXModGhpcy50aW1lb3V0KSA6IHRoaXMudGltZW91dFxuICAgIH1cblxuICAgIHRoaXMuYXhpb3NDbGllbnQocmVxKVxuICAgICAgLnRoZW4oKCkgPT4gZG9uZSgpKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnIucmVzcG9uc2Uuc3RhdHVzVGV4dClcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnJvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoZXJyKVxuICAgICAgfSlcbiAgfVxuXG4gIF9pc0Vycm9yUmV0cnlhYmxlIChlcnJvcikge1xuICAgIC8vIFJldHJ5IE5ldHdvcmsgRXJyb3JzLlxuICAgIGlmIChheGlvc1JldHJ5LmlzTmV0d29ya0Vycm9yKGVycm9yKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoIWVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAvLyBDYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSByZXF1ZXN0IGNhbiBiZSByZXRyaWVkXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBSZXRyeSBTZXJ2ZXIgRXJyb3JzICg1eHgpLlxuICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPj0gNTAwICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA8PSA1OTkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gUmV0cnkgaWYgcmF0ZSBsaW1pdGVkLlxuICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuYWx5dGljc1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBXYWxsZXQgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHNjcnlwdHN5ID0gcmVxdWlyZSgnc2NyeXB0c3knKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xudmFyIGFlc2pzID0gcmVxdWlyZSgnYWVzLWpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DaXBoZXJCdWZmZXIoY2lwaGVyLCBkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKGRhdGEpLCBjaXBoZXIuZmluYWwoKV0pO1xufVxuXG52YXIgVGhpcmRwYXJ0eSA9IHt9O1xuXG4vKlxuICogb3B0czpcbiAqIC0gZGlnZXN0IC0gZGlnZXN0IGFsZ29yaXRobSwgZGVmYXVsdHMgdG8gbWQ1XG4gKiAtIGNvdW50IC0gaGFzaCBpdGVyYXRpb25zXG4gKiAtIGtleXNpemUgLSBkZXNpcmVkIGtleSBzaXplXG4gKiAtIGl2c2l6ZSAtIGRlc2lyZWQgSVYgc2l6ZVxuICpcbiAqIEFsZ29yaXRobSBmb3JtIGh0dHBzOi8vd3d3Lm9wZW5zc2wub3JnL2RvY3MvbWFubWFzdGVyL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG4gKlxuICogRklYTUU6IG5vdCBvcHRpbWlzZWQgYXQgYWxsXG4gKi9cbmZ1bmN0aW9uIGV2cF9rZGYoZGF0YSwgc2FsdCwgb3B0cykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIC8vIEEgc2luZ2xlIEVWUCBpdGVyYXRpb24sIHJldHVybnMgYERfaWAsIHdoZXJlIGJsb2NrIGVxdWxhcyB0byBgRF8oaS0xKWBcbiAgZnVuY3Rpb24gaXRlcihibG9jaykge1xuICAgIHZhciBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2gob3B0cy5kaWdlc3QgfHwgJ21kNScpO1xuICAgIGhhc2gudXBkYXRlKGJsb2NrKTtcbiAgICBoYXNoLnVwZGF0ZShkYXRhKTtcbiAgICBoYXNoLnVwZGF0ZShzYWx0KTtcbiAgICBibG9jayA9IGhhc2guZGlnZXN0KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IChvcHRzLmNvdW50IHx8IDEpOyBpKyspIHtcbiAgICAgIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRzLmRpZ2VzdCB8fCAnbWQ1Jyk7XG4gICAgICBoYXNoLnVwZGF0ZShibG9jayk7XG4gICAgICBibG9jayA9IGhhc2guZGlnZXN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgdmFyIGtleXNpemUgPSBvcHRzLmtleXNpemUgfHwgMTY7XG4gIHZhciBpdnNpemUgPSBvcHRzLml2c2l6ZSB8fCAxNjtcblxuICB2YXIgcmV0ID0gW107XG5cbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoQnVmZmVyLmNvbmNhdChyZXQpLmxlbmd0aCA8IGtleXNpemUgKyBpdnNpemUpIHtcbiAgICByZXRbaV0gPSBpdGVyKGkgPT09IDAgPyBCdWZmZXIuYWxsb2MoMCkgOiByZXRbaSAtIDFdKTtcbiAgICBpKys7XG4gIH1cblxuICB2YXIgdG1wID0gQnVmZmVyLmNvbmNhdChyZXQpO1xuXG4gIHJldHVybiB7XG4gICAga2V5OiB0bXAuc2xpY2UoMCwga2V5c2l6ZSksXG4gICAgaXY6IHRtcC5zbGljZShrZXlzaXplLCBrZXlzaXplICsgaXZzaXplKVxuICB9O1xufVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1Mjg4MzExL2NyeXB0b2pzLWFlcy1wYXR0ZXJuLWFsd2F5cy1lbmRzLXdpdGhcbmZ1bmN0aW9uIGRlY29kZUNyeXB0b2pzU2FsdChpbnB1dCkge1xuICB2YXIgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0Jyk7XG4gIGlmIChjaXBoZXJ0ZXh0LnNsaWNlKDAsIDgpLnRvU3RyaW5nKCkgPT09ICdTYWx0ZWRfXycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2FsdDogY2lwaGVydGV4dC5zbGljZSg4LCAxNiksXG4gICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LnNsaWNlKDE2KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRcbiAgICB9O1xuICB9XG59XG5cbi8qXG4gKiBUaGlzIHdhbGxldCBmb3JtYXQgaXMgY3JlYXRlZCBieSBodHRwczovL2dpdGh1Yi5jb20vU2lsZW50Q2ljZXJvL2V0aGVyZXVtanMtYWNjb3VudHNcbiAqIGFuZCB1c2VkIG9uIGh0dHBzOi8vd3d3Lm15ZXRoZXJ3YWxsZXQuY29tL1xuICovXG5UaGlyZHBhcnR5LmZyb21FdGhlcldhbGxldCA9IGZ1bmN0aW9uIChpbnB1dCwgcGFzc3dvcmQpIHtcbiAgdmFyIGpzb24gPSAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG5cbiAgdmFyIHByaXZLZXk7XG4gIGlmICghanNvbi5sb2NrZWQpIHtcbiAgICBpZiAoanNvbi5wcml2YXRlLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBwcml2S2V5ID0gQnVmZmVyLmZyb20oanNvbi5wcml2YXRlLCAnaGV4Jyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA3IGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgXCJlbmNyeXB0ZWRcIiB2ZXJzaW9uIGhhcyB0aGUgbG93IDQgYnl0ZXNcbiAgICAvLyBvZiB0aGUgaGFzaCBvZiB0aGUgYWRkcmVzcyBhcHBlbmRlZFxuICAgIHZhciBjaXBoZXIgPSBqc29uLmVuY3J5cHRlZCA/IGpzb24ucHJpdmF0ZS5zbGljZSgwLCAxMjgpIDoganNvbi5wcml2YXRlO1xuXG4gICAgLy8gZGVjb2RlIG9wZW5zc2wgY2lwaGVydGV4dCArIHNhbHQgZW5jb2RpbmdcbiAgICBjaXBoZXIgPSBkZWNvZGVDcnlwdG9qc1NhbHQoY2lwaGVyKTtcblxuICAgIGlmICghY2lwaGVyLnNhbHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRXRoZXJXYWxsZXQga2V5IGZvcm1hdCcpO1xuICAgIH1cblxuICAgIC8vIGRlcml2ZSBrZXkvaXYgdXNpbmcgT3BlblNTTCBFVlAgYXMgaW1wbGVtZW50ZWQgaW4gQ3J5cHRvSlNcbiAgICB2YXIgZXZwID0gZXZwX2tkZihCdWZmZXIuZnJvbShwYXNzd29yZCksIGNpcGhlci5zYWx0LCB7IGtleXNpemU6IDMyLCBpdnNpemU6IDE2IH0pO1xuXG4gICAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0yNTYtY2JjJywgZXZwLmtleSwgZXZwLml2KTtcbiAgICBwcml2S2V5ID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBCdWZmZXIuZnJvbShjaXBoZXIuY2lwaGVydGV4dCkpO1xuXG4gICAgLy8gTk9URTogeWVzLCB0aGV5J3ZlIHJ1biBpdCB0aHJvdWdoIFVURjhcbiAgICBwcml2S2V5ID0gQnVmZmVyLmZyb20odXRmOC5kZWNvZGUocHJpdktleS50b1N0cmluZygpKSwgJ2hleCcpO1xuICB9XG5cbiAgdmFyIHdhbGxldCA9IG5ldyBXYWxsZXQocHJpdktleSk7XG5cbiAgaWYgKHdhbGxldC5nZXRBZGRyZXNzU3RyaW5nKCkgIT09IGpzb24uYWRkcmVzcykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleSBvciBhZGRyZXNzJyk7XG4gIH1cblxuICByZXR1cm4gd2FsbGV0O1xufTtcblxuVGhpcmRwYXJ0eS5mcm9tRXRoZXJDYW1wID0gZnVuY3Rpb24gKHBhc3NwaHJhc2UpIHtcbiAgcmV0dXJuIG5ldyBXYWxsZXQoZXRoVXRpbC5rZWNjYWsyNTYoQnVmZmVyLmZyb20ocGFzc3BocmFzZSkpKTtcbn07XG5cblRoaXJkcGFydHkuZnJvbUtyeXB0b0tpdCA9IGZ1bmN0aW9uIChlbnRyb3B5LCBwYXNzd29yZCkge1xuICBmdW5jdGlvbiBrcnlwdG9LaXRCcm9rZW5TY3J5cHRTZWVkKGJ1Zikge1xuICAgIC8vIGpzLXNjcnlwdCBjYWxscyBgQnVmZmVyLmZyb20oU3RyaW5nKHNhbHQpLCAndXRmOCcpYCBvbiB0aGUgc2VlZCBldmVuIHRob3VnaCBpdCBpcyBhIGJ1ZmZlclxuICAgIC8vXG4gICAgLy8gVGhlIGBidWZmZXJgYCBpbXBsZW1lbnRhdGlvbiB1c2VkIGRvZXMgdGhlIGJlbG93IHRyYW5zZm9ybWF0aW9uIChkb2Vzbid0IG1hdGNoZXMgdGhlIGN1cnJlbnQgdmVyc2lvbik6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82N2M2MTE4MWI5MzhiMTdkMTBkYmZjMGE1NDVmNzEzYjhiZDU5ZGU4L2luZGV4LmpzXG5cbiAgICBmdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpOyAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdmFyIHRtcCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgdG1wID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzICsgZGVjb2RlVXRmOENoYXIodG1wKSk7XG4gIH1cblxuICBpZiAoZW50cm9weVswXSA9PT0gJyMnKSB7XG4gICAgZW50cm9weSA9IGVudHJvcHkuc2xpY2UoMSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IGVudHJvcHlbMF07XG4gIGVudHJvcHkgPSBlbnRyb3B5LnNsaWNlKDEpO1xuXG4gIHZhciBwcml2S2V5O1xuICBpZiAodHlwZSA9PT0gJ2QnKSB7XG4gICAgcHJpdktleSA9IGV0aFV0aWwuc2hhMjU2KEJ1ZmZlci5mcm9tKGVudHJvcHkpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncScpIHtcbiAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHZhciBlbmNyeXB0ZWRTZWVkID0gZXRoVXRpbC5zaGEyNTYoQnVmZmVyLmZyb20oZW50cm9weS5zbGljZSgwLCAzMCkpKTtcbiAgICB2YXIgY2hlY2tzdW0gPSBlbnRyb3B5LnNsaWNlKDMwLCA0Nik7XG5cbiAgICB2YXIgc2FsdCA9IGtyeXB0b0tpdEJyb2tlblNjcnlwdFNlZWQoZW5jcnlwdGVkU2VlZCk7XG4gICAgdmFyIGFlc0tleSA9IHNjcnlwdHN5KEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCAndXRmOCcpLCBzYWx0LCAxNjM4NCwgOCwgMSwgMzIpO1xuXG4gICAgLyogRklYTUU6IHRyeSB0byB1c2UgYGNyeXB0b2AgaW5zdGVhZCBvZiBgYWVzanNgXG4gICAgIC8vIE5PVEU6IEVDQiBkb2Vzbid0IHVzZSB0aGUgSVYsIHNvIGl0IGNhbiBiZSBhbnl0aGluZ1xuICAgIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFwiYWVzLTI1Ni1lY2JcIiwgYWVzS2V5LCBCdWZmZXIuZnJvbSgwKSlcbiAgICAgLy8gRklYTUU6IHRoaXMgaXMgYSBjbGVhciBhYnVzZSwgYnV0IHNlZW1zIHRvIG1hdGNoIGhvdyBFQ0IgaW4gYWVzanMgd29ya3NcbiAgICBwcml2S2V5ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkU2VlZCkuc2xpY2UoMCwgMTYpLFxuICAgICAgZGVjaXBoZXIudXBkYXRlKGVuY3J5cHRlZFNlZWQpLnNsaWNlKDAsIDE2KSxcbiAgICBdKVxuICAgICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4gICAgdmFyIGRlY2lwaGVyID0gbmV3IGFlc2pzLk1vZGVPZk9wZXJhdGlvbi5lY2IoYWVzS2V5KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5ldy1jYXAgKi9cbiAgICAvKiBkZWNyeXB0IHJldHVybnMgYW4gVWludDhBcnJheSwgcGVyaGFwcyB0aGVyZSBpcyBhIGJldHRlciB3YXkgdG8gY29uY2F0ZW5hdGUgKi9cbiAgICBwcml2S2V5ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oZGVjaXBoZXIuZGVjcnlwdChlbmNyeXB0ZWRTZWVkLnNsaWNlKDAsIDE2KSkpLCBCdWZmZXIuZnJvbShkZWNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZFNlZWQuc2xpY2UoMTYsIDMyKSkpXSk7XG5cbiAgICBpZiAoY2hlY2tzdW0ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGNoZWNrc3VtICE9PSBldGhVdGlsLnNoYTI1NihldGhVdGlsLnNoYTI1Nihwcml2S2V5KSkuc2xpY2UoMCwgOCkudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgaW5wdXQgLSBwb3NzaWJseSBpbnZhbGlkIHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIGVudHJvcHkgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBXYWxsZXQocHJpdktleSk7XG59O1xuXG5UaGlyZHBhcnR5LmZyb21RdW9ydW1XYWxsZXQgPSBmdW5jdGlvbiAocGFzc3BocmFzZSwgdXNlcmlkKSB7XG4gIGFzc2VydChwYXNzcGhyYXNlLmxlbmd0aCA+PSAxMCk7XG4gIGFzc2VydCh1c2VyaWQubGVuZ3RoID49IDEwKTtcblxuICB2YXIgc2VlZCA9IHBhc3NwaHJhc2UgKyB1c2VyaWQ7XG4gIHNlZWQgPSBjcnlwdG8ucGJrZGYyU3luYyhzZWVkLCBzZWVkLCAyMDAwLCAzMiwgJ3NoYTI1NicpO1xuXG4gIHJldHVybiBuZXcgV2FsbGV0KHNlZWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaGlyZHBhcnR5OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbnZhciBzY3J5cHRzeSA9IHJlcXVpcmUoJ3NjcnlwdHN5Jyk7XG52YXIgdXVpZHY0ID0gcmVxdWlyZSgndXVpZC92NCcpO1xudmFyIGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpO1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuQ2lwaGVyQnVmZmVyKGNpcGhlciwgZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhKSwgY2lwaGVyLmZpbmFsKCldKTtcbn1cblxudmFyIFdhbGxldCA9IGZ1bmN0aW9uIFdhbGxldChwcml2LCBwdWIpIHtcbiAgaWYgKHByaXYgJiYgcHViKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3VwcGx5IGJvdGggYSBwcml2YXRlIGFuZCBhIHB1YmxpYyBrZXkgdG8gdGhlIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICBpZiAocHJpdiAmJiAhZXRoVXRpbC5pc1ZhbGlkUHJpdmF0ZShwcml2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgZG9lcyBub3Qgc2F0aXNmeSB0aGUgY3VydmUgcmVxdWlyZW1lbnRzIChpZS4gaXQgaXMgaW52YWxpZCknKTtcbiAgfVxuXG4gIGlmIChwdWIgJiYgIWV0aFV0aWwuaXNWYWxpZFB1YmxpYyhwdWIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHB1YmxpYyBrZXknKTtcbiAgfVxuXG4gIHRoaXMuX3ByaXZLZXkgPSBwcml2O1xuICB0aGlzLl9wdWJLZXkgPSBwdWI7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ3ByaXZLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGFzc2VydCh0aGlzLl9wcml2S2V5LCAnVGhpcyBpcyBhIHB1YmxpYyBrZXkgb25seSB3YWxsZXQnKTtcbiAgICByZXR1cm4gdGhpcy5fcHJpdktleTtcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYWxsZXQucHJvdG90eXBlLCAncHViS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YktleSkge1xuICAgICAgdGhpcy5fcHViS2V5ID0gZXRoVXRpbC5wcml2YXRlVG9QdWJsaWModGhpcy5wcml2S2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1YktleTtcbiAgfVxufSk7XG5cbldhbGxldC5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChpY2FwRGlyZWN0KSB7XG4gIGlmIChpY2FwRGlyZWN0KSB7XG4gICAgdmFyIG1heCA9IG5ldyBldGhVdGlsLkJOKCcwODhmOTI0ZWVjZWVkYTdmZTkyZTFmNWIwZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcHJpdktleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgIGlmIChuZXcgZXRoVXRpbC5CTihldGhVdGlsLnByaXZhdGVUb0FkZHJlc3MocHJpdktleSkpLmx0ZShtYXgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHByaXZLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFdhbGxldChyYW5kb21CeXRlcygzMikpO1xuICB9XG59O1xuXG5XYWxsZXQuZ2VuZXJhdGVWYW5pdHlBZGRyZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgaWYgKCh0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0dGVybikpICE9PSAnb2JqZWN0Jykge1xuICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICB9XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcHJpdktleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgICB2YXIgYWRkcmVzcyA9IGV0aFV0aWwucHJpdmF0ZVRvQWRkcmVzcyhwcml2S2V5KTtcblxuICAgIGlmIChwYXR0ZXJuLnRlc3QoYWRkcmVzcy50b1N0cmluZygnaGV4JykpKSB7XG4gICAgICByZXR1cm4gbmV3IFdhbGxldChwcml2S2V5KTtcbiAgICB9XG4gIH1cbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJpdktleTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5nZXRQcml2YXRlS2V5KCkpO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnB1YktleTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0UHVibGljS2V5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmdldFB1YmxpY0tleSgpKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHRoaXMucHViS2V5KTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZ2V0QWRkcmVzc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5nZXRBZGRyZXNzKCkpO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRDaGVja3N1bUFkZHJlc3NTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKHRoaXMuZ2V0QWRkcmVzc1N0cmluZygpKTtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG5XYWxsZXQucHJvdG90eXBlLnRvVjMgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdHMpIHtcbiAgYXNzZXJ0KHRoaXMuX3ByaXZLZXksICdUaGlzIGlzIGEgcHVibGljIGtleSBvbmx5IHdhbGxldCcpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgc2FsdCA9IG9wdHMuc2FsdCB8fCByYW5kb21CeXRlcygzMik7XG4gIHZhciBpdiA9IG9wdHMuaXYgfHwgcmFuZG9tQnl0ZXMoMTYpO1xuXG4gIHZhciBkZXJpdmVkS2V5O1xuICB2YXIga2RmID0gb3B0cy5rZGYgfHwgJ3NjcnlwdCc7XG4gIHZhciBrZGZwYXJhbXMgPSB7XG4gICAgZGtsZW46IG9wdHMuZGtsZW4gfHwgMzIsXG4gICAgc2FsdDogc2FsdC50b1N0cmluZygnaGV4JylcbiAgfTtcblxuICBpZiAoa2RmID09PSAncGJrZGYyJykge1xuICAgIGtkZnBhcmFtcy5jID0gb3B0cy5jIHx8IDI2MjE0NDtcbiAgICBrZGZwYXJhbXMucHJmID0gJ2htYWMtc2hhMjU2JztcbiAgICBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBzYWx0LCBrZGZwYXJhbXMuYywga2RmcGFyYW1zLmRrbGVuLCAnc2hhMjU2Jyk7XG4gIH0gZWxzZSBpZiAoa2RmID09PSAnc2NyeXB0Jykge1xuICAgIC8vIEZJWE1FOiBzdXBwb3J0IHByb2dyZXNzIHJlcG9ydGluZyBjYWxsYmFja1xuICAgIGtkZnBhcmFtcy5uID0gb3B0cy5uIHx8IDI2MjE0NDtcbiAgICBrZGZwYXJhbXMuciA9IG9wdHMuciB8fCA4O1xuICAgIGtkZnBhcmFtcy5wID0gb3B0cy5wIHx8IDE7XG4gICAgZGVyaXZlZEtleSA9IHNjcnlwdHN5KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgc2FsdCwga2RmcGFyYW1zLm4sIGtkZnBhcmFtcy5yLCBrZGZwYXJhbXMucCwga2RmcGFyYW1zLmRrbGVuKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtkZicpO1xuICB9XG5cbiAgdmFyIGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihvcHRzLmNpcGhlciB8fCAnYWVzLTEyOC1jdHInLCBkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSwgaXYpO1xuICBpZiAoIWNpcGhlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2lwaGVyJyk7XG4gIH1cblxuICB2YXIgY2lwaGVydGV4dCA9IHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIHRoaXMucHJpdktleSk7XG5cbiAgdmFyIG1hYyA9IGV0aFV0aWwua2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW2Rlcml2ZWRLZXkuc2xpY2UoMTYsIDMyKSwgQnVmZmVyLmZyb20oY2lwaGVydGV4dCwgJ2hleCcpXSkpO1xuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMyxcbiAgICBpZDogdXVpZHY0KHsgcmFuZG9tOiBvcHRzLnV1aWQgfHwgcmFuZG9tQnl0ZXMoMTYpIH0pLFxuICAgIGFkZHJlc3M6IHRoaXMuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBjcnlwdG86IHtcbiAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgY2lwaGVycGFyYW1zOiB7XG4gICAgICAgIGl2OiBpdi50b1N0cmluZygnaGV4JylcbiAgICAgIH0sXG4gICAgICBjaXBoZXI6IG9wdHMuY2lwaGVyIHx8ICdhZXMtMTI4LWN0cicsXG4gICAgICBrZGY6IGtkZixcbiAgICAgIGtkZnBhcmFtczoga2RmcGFyYW1zLFxuICAgICAgbWFjOiBtYWMudG9TdHJpbmcoJ2hleCcpXG4gICAgfVxuICB9O1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRWM0ZpbGVuYW1lID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAvKlxuICAgKiBXZSB3YW50IGEgdGltZXN0YW1wIGxpa2UgMjAxNi0wMy0xNVQxNy0xMS0zMy4wMDc1OTgyODhaLiBEYXRlIGZvcm1hdHRpbmdcbiAgICogaXMgYSBwYWluIGluIEphdmFzY3JpcHQsIGV2ZXJib2R5IGtub3dzIHRoYXQuIFdlIGNvdWxkIHVzZSBtb21lbnQuanMsXG4gICAqIGJ1dCBkZWNpZGUgdG8gZG8gaXQgbWFudWFsbHkgaW4gb3JkZXIgdG8gc2F2ZSBzcGFjZS5cbiAgICpcbiAgICogdG9KU09OKCkgcmV0dXJucyBhIHByZXR0eSBjbG9zZSB2ZXJzaW9uLCBzbyBsZXQncyB1c2UgaXQuIEl0IGlzIG5vdCBVVEMgdGhvdWdoLFxuICAgKiBidXQgZG9lcyBpdCByZWFsbHkgbWF0dGVyP1xuICAgKlxuICAgKiBBbHRlcm5hdGl2ZSBtYW51YWwgd2F5IHdpdGggcGFkZGluZyBhbmQgRGF0ZSBmaWVsZHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcyNDQyODgvNDk2NDgxOVxuICAgKlxuICAgKi9cbiAgdmFyIHRzID0gdGltZXN0YW1wID8gbmV3IERhdGUodGltZXN0YW1wKSA6IG5ldyBEYXRlKCk7XG5cbiAgcmV0dXJuIFsnVVRDLS0nLCB0cy50b0pTT04oKS5yZXBsYWNlKC86L2csICctJyksICctLScsIHRoaXMuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignJyk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnRvVjNTdHJpbmcgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdHMpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9WMyhwYXNzd29yZCwgb3B0cykpO1xufTtcblxuV2FsbGV0LmZyb21QdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBub25TdHJpY3QpIHtcbiAgaWYgKG5vblN0cmljdCkge1xuICAgIHB1YiA9IGV0aFV0aWwuaW1wb3J0UHVibGljKHB1Yik7XG4gIH1cbiAgcmV0dXJuIG5ldyBXYWxsZXQobnVsbCwgcHViKTtcbn07XG5cbldhbGxldC5mcm9tRXh0ZW5kZWRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViKSB7XG4gIGFzc2VydChwdWIuc2xpY2UoMCwgNCkgPT09ICd4cHViJywgJ05vdCBhbiBleHRlbmRlZCBwdWJsaWMga2V5Jyk7XG4gIHB1YiA9IGJzNThjaGVjay5kZWNvZGUocHViKS5zbGljZSg0NSk7XG4gIC8vIENvbnZlcnQgdG8gYW4gRXRoZXJldW0gcHVibGljIGtleVxuICByZXR1cm4gV2FsbGV0LmZyb21QdWJsaWNLZXkocHViLCB0cnVlKTtcbn07XG5cbldhbGxldC5mcm9tUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2KSB7XG4gIHJldHVybiBuZXcgV2FsbGV0KHByaXYpO1xufTtcblxuV2FsbGV0LmZyb21FeHRlbmRlZFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdikge1xuICBhc3NlcnQocHJpdi5zbGljZSgwLCA0KSA9PT0gJ3hwcnYnLCAnTm90IGFuIGV4dGVuZGVkIHByaXZhdGUga2V5Jyk7XG4gIHZhciB0bXAgPSBiczU4Y2hlY2suZGVjb2RlKHByaXYpO1xuICBhc3NlcnQodG1wWzQ1XSA9PT0gMCwgJ0ludmFsaWQgZXh0ZW5kZWQgcHJpdmF0ZSBrZXknKTtcbiAgcmV0dXJuIFdhbGxldC5mcm9tUHJpdmF0ZUtleSh0bXAuc2xpY2UoNDYpKTtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS93aWtpL1Bhc3NwaHJhc2UtcHJvdGVjdGVkLWtleS1zdG9yZS1zcGVjXG5XYWxsZXQuZnJvbVYxID0gZnVuY3Rpb24gKGlucHV0LCBwYXNzd29yZCkge1xuICBhc3NlcnQodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJyk7XG4gIHZhciBqc29uID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKSA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuXG4gIGlmIChqc29uLlZlcnNpb24gIT09ICcxJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgVjEgd2FsbGV0Jyk7XG4gIH1cblxuICBpZiAoanNvbi5DcnlwdG8uS2V5SGVhZGVyLktkZiAhPT0gJ3NjcnlwdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIHNjaGVtZScpO1xuICB9XG5cbiAgdmFyIGtkZnBhcmFtcyA9IGpzb24uQ3J5cHRvLktleUhlYWRlci5LZGZQYXJhbXM7XG4gIHZhciBkZXJpdmVkS2V5ID0gc2NyeXB0c3koQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShqc29uLkNyeXB0by5TYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5OLCBrZGZwYXJhbXMuUiwga2RmcGFyYW1zLlAsIGtkZnBhcmFtcy5Ea0xlbik7XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShqc29uLkNyeXB0by5DaXBoZXJUZXh0LCAnaGV4Jyk7XG5cbiAgdmFyIG1hYyA9IGV0aFV0aWwua2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW2Rlcml2ZWRLZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKTtcblxuICBpZiAobWFjLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5DcnlwdG8uTUFDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZGVyaXZhdGlvbiBmYWlsZWQgLSBwb3NzaWJseSB3cm9uZyBwYXNzcGhyYXNlJyk7XG4gIH1cblxuICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTEyOC1jYmMnLCBldGhVdGlsLmtlY2NhazI1NihkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSkuc2xpY2UoMCwgMTYpLCBCdWZmZXIuZnJvbShqc29uLkNyeXB0by5JViwgJ2hleCcpKTtcbiAgdmFyIHNlZWQgPSBydW5DaXBoZXJCdWZmZXIoZGVjaXBoZXIsIGNpcGhlcnRleHQpO1xuXG4gIHJldHVybiBuZXcgV2FsbGV0KHNlZWQpO1xufTtcblxuV2FsbGV0LmZyb21WMyA9IGZ1bmN0aW9uIChpbnB1dCwgcGFzc3dvcmQsIG5vblN0cmljdCkge1xuICBhc3NlcnQodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJyk7XG4gIHZhciBqc29uID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKSA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2Uobm9uU3RyaWN0ID8gaW5wdXQudG9Mb3dlckNhc2UoKSA6IGlucHV0KTtcblxuICBpZiAoanNvbi52ZXJzaW9uICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBWMyB3YWxsZXQnKTtcbiAgfVxuXG4gIHZhciBkZXJpdmVkS2V5O1xuICB2YXIga2RmcGFyYW1zO1xuICBpZiAoanNvbi5jcnlwdG8ua2RmID09PSAnc2NyeXB0Jykge1xuICAgIGtkZnBhcmFtcyA9IGpzb24uY3J5cHRvLmtkZnBhcmFtcztcblxuICAgIC8vIEZJWE1FOiBzdXBwb3J0IHByb2dyZXNzIHJlcG9ydGluZyBjYWxsYmFja1xuICAgIGRlcml2ZWRLZXkgPSBzY3J5cHRzeShCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5uLCBrZGZwYXJhbXMuciwga2RmcGFyYW1zLnAsIGtkZnBhcmFtcy5ka2xlbik7XG4gIH0gZWxzZSBpZiAoanNvbi5jcnlwdG8ua2RmID09PSAncGJrZGYyJykge1xuICAgIGtkZnBhcmFtcyA9IGpzb24uY3J5cHRvLmtkZnBhcmFtcztcblxuICAgIGlmIChrZGZwYXJhbXMucHJmICE9PSAnaG1hYy1zaGEyNTYnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlcnMgdG8gUEJLREYyJyk7XG4gICAgfVxuXG4gICAgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLmMsIGtkZnBhcmFtcy5ka2xlbiwgJ3NoYTI1NicpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gc2NoZW1lJyk7XG4gIH1cblxuICB2YXIgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGpzb24uY3J5cHRvLmNpcGhlcnRleHQsICdoZXgnKTtcblxuICB2YXIgbWFjID0gZXRoVXRpbC5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpO1xuICBpZiAobWFjLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5jcnlwdG8ubWFjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgZGVyaXZhdGlvbiBmYWlsZWQgLSBwb3NzaWJseSB3cm9uZyBwYXNzcGhyYXNlJyk7XG4gIH1cblxuICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihqc29uLmNyeXB0by5jaXBoZXIsIGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpLCBCdWZmZXIuZnJvbShqc29uLmNyeXB0by5jaXBoZXJwYXJhbXMuaXYsICdoZXgnKSk7XG4gIHZhciBzZWVkID0gcnVuQ2lwaGVyQnVmZmVyKGRlY2lwaGVyLCBjaXBoZXJ0ZXh0KTtcblxuICByZXR1cm4gbmV3IFdhbGxldChzZWVkKTtcbn07XG5cbi8qXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbC9ibG9iL21hc3Rlci9weWV0aHNhbGV0b29sLnB5XG4gKiBKU09OIGZpZWxkczogZW5jc2VlZCwgZXRoYWRkciwgYnRjYWRkciwgZW1haWxcbiAqL1xuV2FsbGV0LmZyb21FdGhTYWxlID0gZnVuY3Rpb24gKGlucHV0LCBwYXNzd29yZCkge1xuICBhc3NlcnQodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJyk7XG4gIHZhciBqc29uID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKSA9PT0gJ29iamVjdCcgPyBpbnB1dCA6IEpTT04ucGFyc2UoaW5wdXQpO1xuXG4gIHZhciBlbmNzZWVkID0gQnVmZmVyLmZyb20oanNvbi5lbmNzZWVkLCAnaGV4Jyk7XG5cbiAgLy8ga2V5IGRlcml2YXRpb25cbiAgdmFyIGRlcml2ZWRLZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCAnc2hhMjU2Jykuc2xpY2UoMCwgMTYpO1xuXG4gIC8vIHNlZWQgZGVjb2RpbmcgKElWIGlzIGZpcnN0IDE2IGJ5dGVzKVxuICAvLyBOT1RFOiBjcnlwdG8gKGRlcml2ZWQgZnJvbSBvcGVuc3NsKSB3aGVuIHVzZWQgd2l0aCBhZXMtKi1jYmMgd2lsbCBoYW5kbGUgUEtDUyM3IHBhZGRpbmcgaW50ZXJuYWxseVxuICAvLyAgICAgICBzZWUgYWxzbyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTYxNDc3MC80OTY0ODE5XG4gIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMTI4LWNiYycsIGRlcml2ZWRLZXksIGVuY3NlZWQuc2xpY2UoMCwgMTYpKTtcbiAgdmFyIHNlZWQgPSBydW5DaXBoZXJCdWZmZXIoZGVjaXBoZXIsIGVuY3NlZWQuc2xpY2UoMTYpKTtcblxuICB2YXIgd2FsbGV0ID0gbmV3IFdhbGxldChldGhVdGlsLmtlY2NhazI1NihzZWVkKSk7XG4gIGlmICh3YWxsZXQuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKSAhPT0ganNvbi5ldGhhZGRyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIGtleSBtaXNtYXRjaCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgfVxuICByZXR1cm4gd2FsbGV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXYWxsZXQ7IiwiaW1wb3J0IHsgc3RyaWN0IGFzIGFzc2VydCB9IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBDb21wb3NlZFN0b3JlLCBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCB7IEpzb25ScGNFbmdpbmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHsgcHJvdmlkZXJGcm9tRW5naW5lIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQge1xuICBjcmVhdGVTd2FwcGFibGVQcm94eSxcbiAgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksXG59IGZyb20gJ3N3YXBwYWJsZS1vYmotcHJveHknO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aC1xdWVyeSc7XG5pbXBvcnQge1xuICBSSU5LRUJZLFxuICBNQUlOTkVULFxuICBJTkZVUkFfUFJPVklERVJfVFlQRVMsXG4gIE5FVFdPUktfVFlQRV9SUEMsXG4gIE5FVFdPUktfVFlQRV9UT19JRF9NQVAsXG4gIE1BSU5ORVRfQ0hBSU5fSUQsXG4gIFJJTktFQllfQ0hBSU5fSUQsXG4gIElORlVSQV9CTE9DS0VEX0tFWSxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5pbXBvcnQge1xuICBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nLFxuICBpc1NhZmVDaGFpbklkLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5pbXBvcnQgY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlIGZyb20gJy4vY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVJbmZ1cmFDbGllbnQgZnJvbSAnLi9jcmVhdGVJbmZ1cmFDbGllbnQnO1xuaW1wb3J0IGNyZWF0ZUpzb25ScGNDbGllbnQgZnJvbSAnLi9jcmVhdGVKc29uUnBjQ2xpZW50JztcblxuY29uc3QgZW52ID0gcHJvY2Vzcy5lbnYuTUVUQU1BU0tfRU5WO1xuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoU0VDT05EICogMzApO1xuXG5sZXQgZGVmYXVsdFByb3ZpZGVyQ29uZmlnT3B0cztcbmlmIChwcm9jZXNzLmVudi5JTl9URVNUKSB7XG4gIGRlZmF1bHRQcm92aWRlckNvbmZpZ09wdHMgPSB7XG4gICAgdHlwZTogTkVUV09SS19UWVBFX1JQQyxcbiAgICBycGNVcmw6ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnLFxuICAgIGNoYWluSWQ6ICcweDUzOScsXG4gICAgbmlja25hbWU6ICdMb2NhbGhvc3QgODU0NScsXG4gIH07XG59IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk1FVEFNQVNLX0RFQlVHIHx8IGVudiA9PT0gJ3Rlc3QnKSB7XG4gIGRlZmF1bHRQcm92aWRlckNvbmZpZ09wdHMgPSB7IHR5cGU6IFJJTktFQlksIGNoYWluSWQ6IFJJTktFQllfQ0hBSU5fSUQgfTtcbn0gZWxzZSB7XG4gIGRlZmF1bHRQcm92aWRlckNvbmZpZ09wdHMgPSB7IHR5cGU6IE1BSU5ORVQsIGNoYWluSWQ6IE1BSU5ORVRfQ0hBSU5fSUQgfTtcbn1cblxuY29uc3QgZGVmYXVsdFByb3ZpZGVyQ29uZmlnID0ge1xuICB0aWNrZXI6ICdFVEgnLFxuICAuLi5kZWZhdWx0UHJvdmlkZXJDb25maWdPcHRzLFxufTtcblxuY29uc3QgZGVmYXVsdE5ldHdvcmtEZXRhaWxzU3RhdGUgPSB7XG4gIEVJUFM6IHsgMTU1OTogdW5kZWZpbmVkIH0sXG59O1xuXG5leHBvcnQgY29uc3QgTkVUV09SS19FVkVOVFMgPSB7XG4gIC8vIEZpcmVkIGFmdGVyIHRoZSBhY3RpdmVseSBzZWxlY3RlZCBuZXR3b3JrIGlzIGNoYW5nZWRcbiAgTkVUV09SS19ESURfQ0hBTkdFOiAnbmV0d29ya0RpZENoYW5nZScsXG4gIC8vIEZpcmVkIHdoZW4gdGhlIGFjdGl2ZWx5IHNlbGVjdGVkIG5ldHdvcmsgKndpbGwqIGNoYW5nZVxuICBORVRXT1JLX1dJTExfQ0hBTkdFOiAnbmV0d29ya1dpbGxDaGFuZ2UnLFxuICAvLyBGaXJlZCB3aGVuIEluZnVyYSByZXR1cm5zIGFuIGVycm9yIGluZGljYXRpbmcgbm8gc3VwcG9ydFxuICBJTkZVUkFfSVNfQkxPQ0tFRDogJ2luZnVyYUlzQmxvY2tlZCcsXG4gIC8vIEZpcmVkIHdoZW4gbm90IHVzaW5nIGFuIEluZnVyYSBuZXR3b3JrIG9yIHdoZW4gSW5mdXJhIHJldHVybnMgbm8gZXJyb3IsIGluZGljYXRpbmcgc3VwcG9ydFxuICBJTkZVUkFfSVNfVU5CTE9DS0VEOiAnaW5mdXJhSXNVbmJsb2NrZWQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV0d29ya0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gY3JlYXRlIHN0b3Jlc1xuICAgIHRoaXMucHJvdmlkZXJTdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoXG4gICAgICBvcHRzLnByb3ZpZGVyIHx8IHsgLi4uZGVmYXVsdFByb3ZpZGVyQ29uZmlnIH0sXG4gICAgKTtcbiAgICB0aGlzLnByZXZpb3VzUHJvdmlkZXJTdG9yZSA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoXG4gICAgICB0aGlzLnByb3ZpZGVyU3RvcmUuZ2V0U3RhdGUoKSxcbiAgICApO1xuICAgIHRoaXMubmV0d29ya1N0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSgnbG9hZGluZycpO1xuICAgIC8vIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBhIGZldyBkZXRhaWxzIGFib3V0IHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICAvLyBJZGVhbGx5IHdlJ2QgbWVyZ2UgdGhpcy5uZXR3b3JrU3RvcmUgd2l0aCB0aGlzIG5ldyBzdG9yZSwgYnV0IGRvaW5nIHNvXG4gICAgLy8gd2lsbCByZXF1aXJlIGEgZGVjZW50IHNpemVkIHJlZmFjdG9yIG9mIGhvdyB3ZSdyZSBhY2Nlc3NpbmcgbmV0d29ya1xuICAgIC8vIHN0YXRlLiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgZm9yIGRldGVjdGluZyBFSVAgMTU1OSBzdXBwb3J0IGJ1dFxuICAgIC8vIGNhbiBiZSBleHRlbmRlZCB0byB0cmFjayBvdGhlciBuZXR3b3JrIGRldGFpbHMuXG4gICAgdGhpcy5uZXR3b3JrRGV0YWlscyA9IG5ldyBPYnNlcnZhYmxlU3RvcmUoXG4gICAgICBvcHRzLm5ldHdvcmtEZXRhaWxzIHx8IHtcbiAgICAgICAgLi4uZGVmYXVsdE5ldHdvcmtEZXRhaWxzU3RhdGUsXG4gICAgICB9LFxuICAgICk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBDb21wb3NlZFN0b3JlKHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyU3RvcmUsXG4gICAgICBwcmV2aW91c1Byb3ZpZGVyU3RvcmU6IHRoaXMucHJldmlvdXNQcm92aWRlclN0b3JlLFxuICAgICAgbmV0d29yazogdGhpcy5uZXR3b3JrU3RvcmUsXG4gICAgICBuZXR3b3JrRGV0YWlsczogdGhpcy5uZXR3b3JrRGV0YWlscyxcbiAgICB9KTtcblxuICAgIC8vIHByb3ZpZGVyIGFuZCBibG9jayB0cmFja2VyXG4gICAgdGhpcy5fcHJvdmlkZXIgPSBudWxsO1xuICAgIHRoaXMuX2Jsb2NrVHJhY2tlciA9IG51bGw7XG5cbiAgICAvLyBwcm92aWRlciBhbmQgYmxvY2sgdHJhY2tlciBwcm94aWVzIC0gYmVjYXVzZSB0aGUgbmV0d29yayBjaGFuZ2VzXG4gICAgdGhpcy5fcHJvdmlkZXJQcm94eSA9IG51bGw7XG4gICAgdGhpcy5fYmxvY2tUcmFja2VyUHJveHkgPSBudWxsO1xuXG4gICAgdGhpcy5vbihORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsIHRoaXMubG9va3VwTmV0d29yayk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgSW5mdXJhIHByb2plY3QgSURcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZCAtIFRoZSBJbmZ1cmEgcHJvamVjdCBJRFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByb2plY3QgSUQgaXMgbm90IGEgdmFsaWQgc3RyaW5nLlxuICAgKi9cbiAgc2V0SW5mdXJhUHJvamVjdElkKHByb2plY3RJZCkge1xuICAgIGlmICghcHJvamVjdElkIHx8IHR5cGVvZiBwcm9qZWN0SWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5mdXJhIHByb2plY3QgSUQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZ1cmFQcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gIH1cblxuICBpbml0aWFsaXplUHJvdmlkZXIocHJvdmlkZXJQYXJhbXMpIHtcbiAgICB0aGlzLl9iYXNlUHJvdmlkZXJQYXJhbXMgPSBwcm92aWRlclBhcmFtcztcbiAgICBjb25zdCB7IHR5cGUsIHJwY1VybCwgY2hhaW5JZCB9ID0gdGhpcy5nZXRQcm92aWRlckNvbmZpZygpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZVByb3ZpZGVyKHsgdHlwZSwgcnBjVXJsLCBjaGFpbklkIH0pO1xuICAgIHRoaXMubG9va3VwTmV0d29yaygpO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBwcm94aWVzIHNvIHRoZSByZWZlcmVuY2VzIHdpbGwgYWx3YXlzIGJlIGdvb2RcbiAgZ2V0UHJvdmlkZXJBbmRCbG9ja1RyYWNrZXIoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlclByb3h5O1xuICAgIGNvbnN0IGJsb2NrVHJhY2tlciA9IHRoaXMuX2Jsb2NrVHJhY2tlclByb3h5O1xuICAgIHJldHVybiB7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gcmV0dXJuIHRoZSBsYXRlc3QgYmxvY2sgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmtcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQmxvY2sgaGVhZGVyXG4gICAqL1xuICBnZXRMYXRlc3RCbG9jaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeyBwcm92aWRlciB9ID0gdGhpcy5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpO1xuICAgICAgY29uc3QgZXRoUXVlcnkgPSBuZXcgRXRoUXVlcnkocHJvdmlkZXIpO1xuICAgICAgZXRoUXVlcnkuc2VuZEFzeW5jKFxuICAgICAgICB7IG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbJ2xhdGVzdCcsIGZhbHNlXSB9LFxuICAgICAgICAoZXJyLCBibG9jaykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoYmxvY2spO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIGJsb2NrIGhlYWRlciBjb250YWlucyBmaWVsZHMgdGhhdCBpbmRpY2F0ZSBFSVAgMTU1OVxuICAgKiBzdXBwb3J0IChiYXNlRmVlUGVyR2FzKS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIEVJUCAxNTU5XG4gICAqL1xuICBhc3luYyBnZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpIHtcbiAgICBjb25zdCB7IEVJUFMgfSA9IHRoaXMubmV0d29ya0RldGFpbHMuZ2V0U3RhdGUoKTtcbiAgICBpZiAoRUlQU1sxNTU5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gRUlQU1sxNTU5XTtcbiAgICB9XG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKCk7XG4gICAgY29uc3Qgc3VwcG9ydHNFSVAxNTU5ID1cbiAgICAgIGxhdGVzdEJsb2NrICYmIGxhdGVzdEJsb2NrLmJhc2VGZWVQZXJHYXMgIT09IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNldE5ldHdvcmtFSVBTdXBwb3J0KDE1NTksIHN1cHBvcnRzRUlQMTU1OSk7XG4gICAgcmV0dXJuIHN1cHBvcnRzRUlQMTU1OTtcbiAgfVxuXG4gIHZlcmlmeU5ldHdvcmsoKSB7XG4gICAgLy8gQ2hlY2sgbmV0d29yayB3aGVuIHJlc3RvcmluZyBjb25uZWN0aXZpdHk6XG4gICAgaWYgKHRoaXMuaXNOZXR3b3JrTG9hZGluZygpKSB7XG4gICAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gIH1cblxuICBnZXROZXR3b3JrU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya1N0b3JlLmdldFN0YXRlKCk7XG4gIH1cblxuICBzZXROZXR3b3JrU3RhdGUobmV0d29yaykge1xuICAgIHRoaXMubmV0d29ya1N0b3JlLnB1dFN0YXRlKG5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBFSVAgc3VwcG9ydCBpbmRpY2F0aW9uIGluIHRoZSBuZXR3b3JrRGV0YWlscyBzdG9yZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gRUlQTnVtYmVyIC0gVGhlIG51bWJlciBvZiB0aGUgRUlQIHRvIG1hcmsgc3VwcG9ydCBmb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N1cHBvcnRlZCAtIFRydWUgaWYgdGhlIEVJUCBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIHNldE5ldHdvcmtFSVBTdXBwb3J0KEVJUE51bWJlciwgaXNTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm5ldHdvcmtEZXRhaWxzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIEVJUFM6IHtcbiAgICAgICAgW0VJUE51bWJlcl06IGlzU3VwcG9ydGVkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBFSVAgc3VwcG9ydCB0byBkZWZhdWx0IChubyBzdXBwb3J0KVxuICAgKi9cbiAgY2xlYXJOZXR3b3JrRGV0YWlscygpIHtcbiAgICB0aGlzLm5ldHdvcmtEZXRhaWxzLnB1dFN0YXRlKHsgLi4uZGVmYXVsdE5ldHdvcmtEZXRhaWxzU3RhdGUgfSk7XG4gIH1cblxuICBpc05ldHdvcmtMb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpID09PSAnbG9hZGluZyc7XG4gIH1cblxuICBsb29rdXBOZXR3b3JrKCkge1xuICAgIC8vIFByZXZlbnQgZmlyaW5nIHdoZW4gcHJvdmlkZXIgaXMgbm90IGRlZmluZWQuXG4gICAgaWYgKCF0aGlzLl9wcm92aWRlcikge1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgICdOZXR3b3JrQ29udHJvbGxlciAtIGxvb2t1cE5ldHdvcmsgYWJvcnRlZCBkdWUgdG8gbWlzc2luZyBwcm92aWRlcicsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgJ05ldHdvcmtDb250cm9sbGVyIC0gbG9va3VwTmV0d29yayBhYm9ydGVkIGR1ZSB0byBtaXNzaW5nIGNoYWluSWQnLFxuICAgICAgKTtcbiAgICAgIHRoaXMuc2V0TmV0d29ya1N0YXRlKCdsb2FkaW5nJyk7XG4gICAgICAvLyBrZWVwIG5ldHdvcmsgZGV0YWlscyBpbiBzeW5jIHdpdGggbmV0d29yayBzdGF0ZVxuICAgICAgdGhpcy5jbGVhck5ldHdvcmtEZXRhaWxzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUGluZyB0aGUgUlBDIGVuZHBvaW50IHNvIHdlIGNhbiBjb25maXJtIHRoYXQgaXQgd29ya3NcbiAgICBjb25zdCBldGhRdWVyeSA9IG5ldyBFdGhRdWVyeSh0aGlzLl9wcm92aWRlcik7XG4gICAgY29uc3QgaW5pdGlhbE5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcy5nZXRQcm92aWRlckNvbmZpZygpO1xuICAgIGNvbnN0IGlzSW5mdXJhID0gSU5GVVJBX1BST1ZJREVSX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xuXG4gICAgaWYgKGlzSW5mdXJhKSB7XG4gICAgICB0aGlzLl9jaGVja0luZnVyYUF2YWlsYWJpbGl0eSh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KE5FVFdPUktfRVZFTlRTLklORlVSQV9JU19VTkJMT0NLRUQpO1xuICAgIH1cblxuICAgIGV0aFF1ZXJ5LnNlbmRBc3luYyh7IG1ldGhvZDogJ25ldF92ZXJzaW9uJyB9LCAoZXJyLCBuZXR3b3JrVmVyc2lvbikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudE5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgaWYgKGluaXRpYWxOZXR3b3JrID09PSBjdXJyZW50TmV0d29yaykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5zZXROZXR3b3JrU3RhdGUoJ2xvYWRpbmcnKTtcbiAgICAgICAgICAvLyBrZWVwIG5ldHdvcmsgZGV0YWlscyBpbiBzeW5jIHdpdGggbmV0d29yayBzdGF0ZVxuICAgICAgICAgIHRoaXMuY2xlYXJOZXR3b3JrRGV0YWlscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TmV0d29ya1N0YXRlKG5ldHdvcmtWZXJzaW9uKTtcbiAgICAgICAgLy8gbG9vayB1cCBFSVAtMTU1OSBzdXBwb3J0XG4gICAgICAgIHRoaXMuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldEN1cnJlbnRDaGFpbklkKCkge1xuICAgIGNvbnN0IHsgdHlwZSwgY2hhaW5JZDogY29uZmlnQ2hhaW5JZCB9ID0gdGhpcy5nZXRQcm92aWRlckNvbmZpZygpO1xuICAgIHJldHVybiBORVRXT1JLX1RZUEVfVE9fSURfTUFQW3R5cGVdPy5jaGFpbklkIHx8IGNvbmZpZ0NoYWluSWQ7XG4gIH1cblxuICBzZXRScGNUYXJnZXQocnBjVXJsLCBjaGFpbklkLCB0aWNrZXIgPSAnRVRIJywgbmlja25hbWUgPSAnJywgcnBjUHJlZnMpIHtcbiAgICBhc3NlcnQub2soXG4gICAgICBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKGNoYWluSWQpLFxuICAgICAgYEludmFsaWQgY2hhaW4gSUQgXCIke2NoYWluSWR9XCI6IGludmFsaWQgaGV4IHN0cmluZy5gLFxuICAgICk7XG4gICAgYXNzZXJ0Lm9rKFxuICAgICAgaXNTYWZlQ2hhaW5JZChwYXJzZUludChjaGFpbklkLCAxNikpLFxuICAgICAgYEludmFsaWQgY2hhaW4gSUQgXCIke2NoYWluSWR9XCI6IG51bWVyaWNhbCB2YWx1ZSBncmVhdGVyIHRoYW4gbWF4IHNhZmUgdmFsdWUuYCxcbiAgICApO1xuICAgIHRoaXMuc2V0UHJvdmlkZXJDb25maWcoe1xuICAgICAgdHlwZTogTkVUV09SS19UWVBFX1JQQyxcbiAgICAgIHJwY1VybCxcbiAgICAgIGNoYWluSWQsXG4gICAgICB0aWNrZXIsXG4gICAgICBuaWNrbmFtZSxcbiAgICAgIHJwY1ByZWZzLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2V0UHJvdmlkZXJUeXBlKHR5cGUpIHtcbiAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoXG4gICAgICB0eXBlLFxuICAgICAgTkVUV09SS19UWVBFX1JQQyxcbiAgICAgIGBOZXR3b3JrQ29udHJvbGxlciAtIGNhbm5vdCBjYWxsIFwic2V0UHJvdmlkZXJUeXBlXCIgd2l0aCB0eXBlIFwiJHtORVRXT1JLX1RZUEVfUlBDfVwiLiBVc2UgXCJzZXRScGNUYXJnZXRcImAsXG4gICAgKTtcbiAgICBhc3NlcnQub2soXG4gICAgICBJTkZVUkFfUFJPVklERVJfVFlQRVMuaW5jbHVkZXModHlwZSksXG4gICAgICBgVW5rbm93biBJbmZ1cmEgcHJvdmlkZXIgdHlwZSBcIiR7dHlwZX1cIi5gLFxuICAgICk7XG4gICAgY29uc3QgeyBjaGFpbklkIH0gPSBORVRXT1JLX1RZUEVfVE9fSURfTUFQW3R5cGVdO1xuICAgIHRoaXMuc2V0UHJvdmlkZXJDb25maWcoe1xuICAgICAgdHlwZSxcbiAgICAgIHJwY1VybDogJycsXG4gICAgICBjaGFpbklkLFxuICAgICAgdGlja2VyOiAnRVRIJyxcbiAgICAgIG5pY2tuYW1lOiAnJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0Q29ubmVjdGlvbigpIHtcbiAgICB0aGlzLnNldFByb3ZpZGVyQ29uZmlnKHRoaXMuZ2V0UHJvdmlkZXJDb25maWcoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvdmlkZXIgY29uZmlnIGFuZCBzd2l0Y2hlcyB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKi9cbiAgc2V0UHJvdmlkZXJDb25maWcoY29uZmlnKSB7XG4gICAgdGhpcy5wcmV2aW91c1Byb3ZpZGVyU3RvcmUudXBkYXRlU3RhdGUodGhpcy5nZXRQcm92aWRlckNvbmZpZygpKTtcbiAgICB0aGlzLnByb3ZpZGVyU3RvcmUudXBkYXRlU3RhdGUoY29uZmlnKTtcbiAgICB0aGlzLl9zd2l0Y2hOZXR3b3JrKGNvbmZpZyk7XG4gIH1cblxuICByb2xsYmFja1RvUHJldmlvdXNQcm92aWRlcigpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLnByZXZpb3VzUHJvdmlkZXJTdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRoaXMucHJvdmlkZXJTdG9yZS51cGRhdGVTdGF0ZShjb25maWcpO1xuICAgIHRoaXMuX3N3aXRjaE5ldHdvcmsoY29uZmlnKTtcbiAgfVxuXG4gIGdldFByb3ZpZGVyQ29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyU3RvcmUuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIGdldE5ldHdvcmtJZGVudGlmaWVyKCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlclN0b3JlLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHByb3ZpZGVyLnR5cGUgPT09IE5FVFdPUktfVFlQRV9SUEMgPyBwcm92aWRlci5ycGNVcmwgOiBwcm92aWRlci50eXBlO1xuICB9XG5cbiAgLy9cbiAgLy8gUHJpdmF0ZVxuICAvL1xuXG4gIGFzeW5jIF9jaGVja0luZnVyYUF2YWlsYWJpbGl0eShuZXR3b3JrKSB7XG4gICAgY29uc3QgcnBjVXJsID0gYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW8vdjMvJHt0aGlzLl9pbmZ1cmFQcm9qZWN0SWR9YDtcblxuICAgIGxldCBuZXR3b3JrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMub25jZShORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsICgpID0+IHtcbiAgICAgIG5ldHdvcmtDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQocnBjVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgIGlkOiAxLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV0d29ya0NoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhpcy5lbWl0KE5FVFdPUktfRVZFTlRTLklORlVSQV9JU19VTkJMT0NLRUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAobmV0d29ya0NoYW5nZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvciA9PT0gSU5GVVJBX0JMT0NLRURfS0VZKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KE5FVFdPUktfRVZFTlRTLklORlVSQV9JU19CTE9DS0VEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYE1ldGFNYXNrIC0gSW5mdXJhIGF2YWlsYWJpbGl0eSBjaGVjayBmYWlsZWRgLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIF9zd2l0Y2hOZXR3b3JrKG9wdHMpIHtcbiAgICAvLyBJbmRpY2F0ZSB0byBzdWJzY3JpYmVycyB0aGF0IG5ldHdvcmsgaXMgYWJvdXQgdG8gY2hhbmdlXG4gICAgdGhpcy5lbWl0KE5FVFdPUktfRVZFTlRTLk5FVFdPUktfV0lMTF9DSEFOR0UpO1xuICAgIC8vIFNldCBsb2FkaW5nIHN0YXRlXG4gICAgdGhpcy5zZXROZXR3b3JrU3RhdGUoJ2xvYWRpbmcnKTtcbiAgICAvLyBSZXNldCBuZXR3b3JrIGRldGFpbHNcbiAgICB0aGlzLmNsZWFyTmV0d29ya0RldGFpbHMoKTtcbiAgICAvLyBDb25maWd1cmUgdGhlIHByb3ZpZGVyIGFwcHJvcHJpYXRlbHlcbiAgICB0aGlzLl9jb25maWd1cmVQcm92aWRlcihvcHRzKTtcbiAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBuZXR3b3JrIGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5lbWl0KE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSwgb3B0cy50eXBlKTtcbiAgfVxuXG4gIF9jb25maWd1cmVQcm92aWRlcih7IHR5cGUsIHJwY1VybCwgY2hhaW5JZCB9KSB7XG4gICAgLy8gaW5mdXJhIHR5cGUtYmFzZWQgZW5kcG9pbnRzXG4gICAgY29uc3QgaXNJbmZ1cmEgPSBJTkZVUkFfUFJPVklERVJfVFlQRVMuaW5jbHVkZXModHlwZSk7XG4gICAgaWYgKGlzSW5mdXJhKSB7XG4gICAgICB0aGlzLl9jb25maWd1cmVJbmZ1cmFQcm92aWRlcih0eXBlLCB0aGlzLl9pbmZ1cmFQcm9qZWN0SWQpO1xuICAgICAgLy8gdXJsLWJhc2VkIHJwYyBlbmRwb2ludHNcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE5FVFdPUktfVFlQRV9SUEMpIHtcbiAgICAgIHRoaXMuX2NvbmZpZ3VyZVN0YW5kYXJkUHJvdmlkZXIocnBjVXJsLCBjaGFpbklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTmV0d29ya0NvbnRyb2xsZXIgLSBfY29uZmlndXJlUHJvdmlkZXIgLSB1bmtub3duIHR5cGUgXCIke3R5cGV9XCJgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBfY29uZmlndXJlSW5mdXJhUHJvdmlkZXIodHlwZSwgcHJvamVjdElkKSB7XG4gICAgbG9nLmluZm8oJ05ldHdvcmtDb250cm9sbGVyIC0gY29uZmlndXJlSW5mdXJhUHJvdmlkZXInLCB0eXBlKTtcbiAgICBjb25zdCBuZXR3b3JrQ2xpZW50ID0gY3JlYXRlSW5mdXJhQ2xpZW50KHtcbiAgICAgIG5ldHdvcms6IHR5cGUsXG4gICAgICBwcm9qZWN0SWQsXG4gICAgfSk7XG4gICAgdGhpcy5fc2V0TmV0d29ya0NsaWVudChuZXR3b3JrQ2xpZW50KTtcbiAgfVxuXG4gIF9jb25maWd1cmVTdGFuZGFyZFByb3ZpZGVyKHJwY1VybCwgY2hhaW5JZCkge1xuICAgIGxvZy5pbmZvKCdOZXR3b3JrQ29udHJvbGxlciAtIGNvbmZpZ3VyZVN0YW5kYXJkUHJvdmlkZXInLCBycGNVcmwpO1xuICAgIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBjcmVhdGVKc29uUnBjQ2xpZW50KHsgcnBjVXJsLCBjaGFpbklkIH0pO1xuICAgIHRoaXMuX3NldE5ldHdvcmtDbGllbnQobmV0d29ya0NsaWVudCk7XG4gIH1cblxuICBfc2V0TmV0d29ya0NsaWVudCh7IG5ldHdvcmtNaWRkbGV3YXJlLCBibG9ja1RyYWNrZXIgfSkge1xuICAgIGNvbnN0IG1ldGFtYXNrTWlkZGxld2FyZSA9IGNyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZShcbiAgICAgIHRoaXMuX2Jhc2VQcm92aWRlclBhcmFtcyxcbiAgICApO1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBKc29uUnBjRW5naW5lKCk7XG4gICAgZW5naW5lLnB1c2gobWV0YW1hc2tNaWRkbGV3YXJlKTtcbiAgICBlbmdpbmUucHVzaChuZXR3b3JrTWlkZGxld2FyZSk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLl9zZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcih7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIgfSk7XG4gIH1cblxuICBfc2V0UHJvdmlkZXJBbmRCbG9ja1RyYWNrZXIoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyIH0pIHtcbiAgICAvLyB1cGRhdGUgb3IgaW5pdGlhbGl6ZSBwcm94aWVzXG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVyUHJveHkpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyUHJveHkuc2V0VGFyZ2V0KHByb3ZpZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJvdmlkZXJQcm94eSA9IGNyZWF0ZVN3YXBwYWJsZVByb3h5KHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Jsb2NrVHJhY2tlclByb3h5KSB7XG4gICAgICB0aGlzLl9ibG9ja1RyYWNrZXJQcm94eS5zZXRUYXJnZXQoYmxvY2tUcmFja2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYmxvY2tUcmFja2VyUHJveHkgPSBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eShibG9ja1RyYWNrZXIsIHtcbiAgICAgICAgZXZlbnRGaWx0ZXI6ICdza2lwSW50ZXJuYWwnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNldCBuZXcgcHJvdmlkZXIgYW5kIGJsb2NrVHJhY2tlclxuICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5fYmxvY2tUcmFja2VyID0gYmxvY2tUcmFja2VyO1xuICB9XG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG52YXIgY3MgPSByZXF1aXJlKCdjb2luc3RyaW5nJylcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuXG52YXIgTUFTVEVSX1NFQ1JFVCA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIHNlZWQnLCAndXRmOCcpXG52YXIgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMFxudmFyIExFTiA9IDc4XG5cbi8vIEJpdGNvaW4gaGFyZGNvZGVkIGJ5IGRlZmF1bHQsIGNhbiB1c2UgcGFja2FnZSBgY29pbmluZm9gIGZvciBvdGhlcnNcbnZhciBCSVRDT0lOX1ZFUlNJT05TID0ge3ByaXZhdGU6IDB4MDQ4OEFERTQsIHB1YmxpYzogMHgwNDg4QjIxRX1cblxuZnVuY3Rpb24gSERLZXkgKHZlcnNpb25zKSB7XG4gIHRoaXMudmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHRoaXMuZGVwdGggPSAwXG4gIHRoaXMuaW5kZXggPSAwXG4gIHRoaXMuX3ByaXZhdGVLZXkgPSBudWxsXG4gIHRoaXMuX3B1YmxpY0tleSA9IG51bGxcbiAgdGhpcy5jaGFpbkNvZGUgPSBudWxsXG4gIHRoaXMuX2ZpbmdlcnByaW50ID0gMFxuICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnZmluZ2VycHJpbnQnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmluZ2VycHJpbnQgfSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ2lkZW50aWZpZXInLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWRlbnRpZmllciB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHViS2V5SGFzaCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlkZW50aWZpZXIgfSB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVLZXlcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc3NlcnQuZXF1YWwodmFsdWUubGVuZ3RoLCAzMiwgJ1ByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkodmFsdWUpID09PSB0cnVlLCAnSW52YWxpZCBwcml2YXRlIGtleScpXG5cbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gdmFsdWVcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHZhbHVlLCB0cnVlKVxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0tleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IDMzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNjUsICdQdWJsaWMga2V5IG11c3QgYmUgMzMgb3IgNjUgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHB1YmxpYyBrZXknKVxuXG4gICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQodmFsdWUsIHRydWUpIC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnRcbiAgICB0aGlzLl9pZGVudGlmaWVyID0gaGFzaDE2MCh0aGlzLnB1YmxpY0tleSlcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHRoaXMuX2lkZW50aWZpZXIuc2xpY2UoMCwgNCkucmVhZFVJbnQzMkJFKDApXG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3ByaXZhdGVFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEsIDApLCB0aGlzLnByaXZhdGVLZXldKSkpXG4gICAgZWxzZSByZXR1cm4gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljRXh0ZW5kZWRLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHVibGljLCB0aGlzLnB1YmxpY0tleSkpXG4gIH1cbn0pXG5cbkhES2V5LnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAocGF0aCA9PT0gJ20nIHx8IHBhdGggPT09ICdNJyB8fCBwYXRoID09PSBcIm0nXCIgfHwgcGF0aCA9PT0gXCJNJ1wiKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gcGF0aC5zcGxpdCgnLycpXG4gIHZhciBoZGtleSA9IHRoaXNcbiAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGFzc2VydChjLCAnbScsICdJbnZhbGlkIHBhdGgnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGhhcmRlbmVkID0gKGMubGVuZ3RoID4gMSkgJiYgKGNbYy5sZW5ndGggLSAxXSA9PT0gXCInXCIpXG4gICAgdmFyIGNoaWxkSW5kZXggPSBwYXJzZUludChjLCAxMCkgLy8gJiAoSEFSREVORURfT0ZGU0VUIC0gMSlcbiAgICBhc3NlcnQoY2hpbGRJbmRleCA8IEhBUkRFTkVEX09GRlNFVCwgJ0ludmFsaWQgaW5kZXgnKVxuICAgIGlmIChoYXJkZW5lZCkgY2hpbGRJbmRleCArPSBIQVJERU5FRF9PRkZTRVRcblxuICAgIGhka2V5ID0gaGRrZXkuZGVyaXZlQ2hpbGQoY2hpbGRJbmRleClcbiAgfSlcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkucHJvdG90eXBlLmRlcml2ZUNoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBpc0hhcmRlbmVkID0gaW5kZXggPj0gSEFSREVORURfT0ZGU0VUXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKVxuXG4gIHZhciBkYXRhXG5cbiAgaWYgKGlzSGFyZGVuZWQpIHsgLy8gSGFyZGVuZWQgY2hpbGRcbiAgICBhc3NlcnQodGhpcy5wcml2YXRlS2V5LCAnQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKVxuXG4gICAgdmFyIHBrID0gdGhpcy5wcml2YXRlS2V5XG4gICAgdmFyIHpiID0gQnVmZmVyLmFsbG9jKDEsIDApXG4gICAgcGsgPSBCdWZmZXIuY29uY2F0KFt6YiwgcGtdKVxuXG4gICAgLy8gZGF0YSA9IDB4MDAgfHwgc2VyMjU2KGtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtwaywgaW5kZXhCdWZmZXJdKVxuICB9IGVsc2UgeyAvLyBOb3JtYWwgY2hpbGRcbiAgICAvLyBkYXRhID0gc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgLy8gICAgICA9IHNlclAoS3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucHVibGljS2V5LCBpbmRleEJ1ZmZlcl0pXG4gIH1cblxuICB2YXIgSSA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCB0aGlzLmNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhkID0gbmV3IEhES2V5KHRoaXMudmVyc2lvbnMpXG5cbiAgLy8gUHJpdmF0ZSBwYXJlbnQga2V5IC0+IHByaXZhdGUgY2hpbGQga2V5XG4gIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAvLyBraSA9IHBhcnNlMjU2KElMKSArIGtwYXIgKG1vZCBuKVxuICAgIHRyeSB7XG4gICAgICBoZC5wcml2YXRlS2V5ID0gc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZCh0aGlzLnByaXZhdGVLZXksIElMKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAocHJpdmF0ZUtleSArIElMKSA9PT0gMFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBraSA9PSAwLCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSlcbiAgICB9XG4gIC8vIFB1YmxpYyBwYXJlbnQga2V5IC0+IHB1YmxpYyBjaGlsZCBrZXlcbiAgfSBlbHNlIHtcbiAgICAvLyBLaSA9IHBvaW50KHBhcnNlMjU2KElMKSkgKyBLcGFyXG4gICAgLy8gICAgPSBHKklMICsgS3BhclxuICAgIHRyeSB7XG4gICAgICBoZC5wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQodGhpcy5wdWJsaWNLZXksIElMLCB0cnVlKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAoZyoqSUwgKyBwdWJsaWNLZXkpIGlzIGluZmluaXR5XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIEtpIGlzIHRoZSBwb2ludCBhdCBpbmZpbml0eSwgb25lIHNob3VsZCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEsIGlzSGFyZGVuZWQpXG4gICAgfVxuICB9XG5cbiAgaGQuY2hhaW5Db2RlID0gSVJcbiAgaGQuZGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICBoZC5wYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZmluZ2VycHJpbnQvLyAucmVhZFVJbnQzMkJFKDApXG4gIGhkLmluZGV4ID0gaW5kZXhcblxuICByZXR1cm4gaGRcbn1cblxuSERLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoaGFzaCkge1xuICByZXR1cm4gc2VjcDI1NmsxLnNpZ24oaGFzaCwgdGhpcy5wcml2YXRlS2V5KS5zaWduYXR1cmVcbn1cblxuSERLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoaGFzaCwgc2lnbmF0dXJlLCB0aGlzLnB1YmxpY0tleSlcbn1cblxuSERLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB4cHJpdjogdGhpcy5wcml2YXRlRXh0ZW5kZWRLZXksXG4gICAgeHB1YjogdGhpcy5wdWJsaWNFeHRlbmRlZEtleVxuICB9XG59XG5cbkhES2V5LmZyb21NYXN0ZXJTZWVkID0gZnVuY3Rpb24gKHNlZWRCdWZmZXIsIHZlcnNpb25zKSB7XG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIE1BU1RFUl9TRUNSRVQpLnVwZGF0ZShzZWVkQnVmZmVyKS5kaWdlc3QoKVxuICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKVxuICB2YXIgSVIgPSBJLnNsaWNlKDMyKVxuXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcbiAgaGRrZXkuY2hhaW5Db2RlID0gSVJcbiAgaGRrZXkucHJpdmF0ZUtleSA9IElMXG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21FeHRlbmRlZEtleSA9IGZ1bmN0aW9uIChiYXNlNThrZXksIHZlcnNpb25zKSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcblxuICB2YXIga2V5QnVmZmVyID0gY3MuZGVjb2RlKGJhc2U1OGtleSlcblxuICB2YXIgdmVyc2lvbiA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoMClcbiAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUgfHwgdmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogZG9lcyBub3QgbWF0Y2ggcHJpdmF0ZSBvciBwdWJsaWMnKVxuXG4gIGhka2V5LmRlcHRoID0ga2V5QnVmZmVyLnJlYWRVSW50OCg0KVxuICBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoNSlcbiAgaGRrZXkuaW5kZXggPSBrZXlCdWZmZXIucmVhZFVJbnQzMkJFKDkpXG4gIGhka2V5LmNoYWluQ29kZSA9IGtleUJ1ZmZlci5zbGljZSgxMywgNDUpXG5cbiAgdmFyIGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSlcbiAgaWYgKGtleS5yZWFkVUludDgoMCkgPT09IDApIHsgLy8gcHJpdmF0ZVxuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wcml2YXRlLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlJylcbiAgICBoZGtleS5wcml2YXRlS2V5ID0ga2V5LnNsaWNlKDEpIC8vIGN1dCBvZmYgZmlyc3QgMHgwIGJ5dGVcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwdWJsaWMnKVxuICAgIGhka2V5LnB1YmxpY0tleSA9IGtleVxuICB9XG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21KU09OID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gSERLZXkuZnJvbUV4dGVuZGVkS2V5KG9iai54cHJpdilcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplIChoZGtleSwgdmVyc2lvbiwga2V5KSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShMRU4pXG5cbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmVyc2lvbiwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaGRrZXkuZGVwdGgsIDQpXG5cbiAgdmFyIGZpbmdlcnByaW50ID0gaGRrZXkuZGVwdGggPyBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA6IDB4MDAwMDAwMDBcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoZmluZ2VycHJpbnQsIDUpXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGhka2V5LmluZGV4LCA5KVxuXG4gIGhka2V5LmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpXG4gIGtleS5jb3B5KGJ1ZmZlciwgNDUpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBoYXNoMTYwIChidWYpIHtcbiAgdmFyIHNoYSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShzaGEpLmRpZ2VzdCgpXG59XG5cbkhES2V5LkhBUkRFTkVEX09GRlNFVCA9IEhBUkRFTkVEX09GRlNFVFxubW9kdWxlLmV4cG9ydHMgPSBIREtleVxuIiwiY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IGV0aEFiaSA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtYWJpJylcbmNvbnN0IG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKVxubmFjbC51dGlsID0gcmVxdWlyZSgndHdlZXRuYWNsLXV0aWwnKVxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgZG9tYWluOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgbWVzc2FnZTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICB9LFxuICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGFcbiAqL1xuY29uc3QgVHlwZWREYXRhVXRpbHMgPSB7XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmICh1c2VWNCkge1xuICAgICAgY29uc3QgZW5jb2RlRmllbGQgPSAobmFtZSwgdHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyA6XG4gICAgICAgICAgICBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKG5hbWUsIHBhcnNlZFR5cGUsIGl0ZW0pKVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2NhayhldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbX3R5cGVdKSA9PiBfdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIF92YWx1ZV0pID0+IF92YWx1ZSksXG4gICAgICAgICAgKSldXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3R5cGUsIHZhbHVlXVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoZmllbGQubmFtZSwgZmllbGQudHlwZSwgZGF0YVtmaWVsZC5uYW1lXSlcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSlcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgLy8gY29udmVydCBzdHJpbmcgdG8gYnVmZmVyIC0gcHJldmVudHMgZXRoVXRpbCBmcm9tIGludGVycHJldGluZyBzdHJpbmdzIGxpa2UgJzB4YWJjZCcgYXMgaGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZXNbZmllbGQudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgY3VycmVudGx5IHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKGZpZWxkLnR5cGUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aEFiaS5yYXdFbmNvZGUoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBsZXQgZGVwcyA9IHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKS5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSBwcmltYXJ5VHlwZSlcbiAgICBkZXBzID0gW3ByaW1hcnlUeXBlXS5jb25jYXQoZGVwcy5zb3J0KCkpXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV1cbiAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YClcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgke3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlOiBfdHlwZSB9KSA9PiBgJHtfdHlwZX0gJHtuYW1lfWApLmpvaW4oJywnKX0pYFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmludGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyAtIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICovXG4gIGZpbmRUeXBlRGVwZW5kZW5jaWVzIChwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgIGNvbnN0IFtmaXJzdFdvcmRdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpXG4gICAgcHJpbWFyeVR5cGUgPSBmaXJzdFdvcmRcbiAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSlcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cykpIHtcbiAgICAgICAgIXJlc3VsdHMuaW5jbHVkZXMoZGVwKSAmJiByZXN1bHRzLnB1c2goZGVwKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFN0cnVjdCAocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFR5cGUgKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSlcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAqL1xuICBzYW5pdGl6ZURhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSkge1xuICAgICAgZGF0YVtrZXldICYmIChzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV0pXG4gICAgfVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnR5cGVzKSB7XG4gICAgICBzYW5pdGl6ZWREYXRhLnR5cGVzID0geyBFSVA3MTJEb21haW46IFtdLCAuLi5zYW5pdGl6ZWREYXRhLnR5cGVzIH1cbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGFcbiAgfSxcblxuICAvKipcbiAgICogU2lnbnMgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGFuZCByZXR1cm5zIGl0cyBrZWNjYWsgaGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWREYXRhIC0gVHlwZXMgbWVzc2FnZSBkYXRhIHRvIHNpZ25cbiAgICogQHJldHVybnMge3N0cmluZ30gLSBrZWNjYWsgaGFzaCBvZiB0aGUgcmVzdWx0aW5nIHNpZ25lZCBtZXNzYWdlXG4gICAqL1xuICBzaWduICh0eXBlZERhdGEsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB0aGlzLnNhbml0aXplRGF0YSh0eXBlZERhdGEpXG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldXG4gICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICBwYXJ0cy5wdXNoKHRoaXMuaGFzaFN0cnVjdChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHVzZVY0KSlcbiAgICB9XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKEJ1ZmZlci5jb25jYXQocGFydHMpKVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVFlQRURfTUVTU0FHRV9TQ0hFTUEsXG4gIFR5cGVkRGF0YVV0aWxzLFxuXG4gIGNvbmNhdFNpZyAodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocilcbiAgICBjb25zdCBzU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHMpXG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodilcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoclNpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSkudG9TdHJpbmcoJ2hleCcpXG4gIH0sXG5cbiAgbm9ybWFsaXplIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG5cbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoaW5wdXQudG9Mb3dlckNhc2UoKSlcbiAgfSxcblxuICBwZXJzb25hbFNpZ24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICBjb25zdCBzZW5kZXJIZXggPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgICByZXR1cm4gc2VuZGVySGV4XG4gIH0sXG5cbiAgZXh0cmFjdFB1YmxpY0tleSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWBcbiAgfSxcblxuICB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YUxlZ2FjeSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICBlbmNyeXB0IChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG5cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2dQYXJhbXMuZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlY3Qgc2VjcmV0IG1lc3NhZ2UsIG1lc3NhZ2UgcGFyYW1zIHNob3VsZCBiZSBvZiB0aGUgZm9ybSB7ZGF0YTogXCJzZWNyZXQgbWVzc2FnZVwifSAnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIGVwaGVtZXJhbCBrZXlwYWlyXG4gICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKClcblxuICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KHJlY2VpdmVyUHVibGljS2V5KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2dQYXJhbXMuZGF0YSlcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKVxuXG4gICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSlcblxuICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICAgICAgICBlcGhlbVB1YmxpY0tleTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgY2lwaGVydGV4dDogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpXG5cbiAgICB9XG4gIH0sXG5cbiAgZW5jcnlwdFNhZmVseSAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9ICgyICoqIDExKVxuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNlxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXNcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS50b0pTT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHdpdGggdG9KU09OIHByb3BlcnR5LiAgUGxlYXNlIHJlbW92ZSB0b0pTT04gcHJvcGVydHknKVxuICAgIH1cblxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHBhZGRpbmc6ICcnLFxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpXG4gICAgY29uc3QgbW9kVmFsID0gKGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIKVxuICAgIGxldCBwYWRMZW5ndGggPSAwXG4gICAgLy8gT25seSBwYWQgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZFZhbCA+IDApIHtcbiAgICAgIHBhZExlbmd0aCA9IChERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsKSAtIE5BQ0xfRVhUUkFfQllURVMgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKVxuXG4gICAgY29uc3QgcGFkZGVkTXNnUGFyYW1zID0geyBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpIH1cbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pXG4gIH0sXG5cbiAgZGVjcnlwdCAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG5cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZERhdGEudmVyc2lvbikge1xuICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAvLyBzdHJpbmcgdG8gYnVmZmVyIHRvIFVJbnQ4QXJyYXlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHJlY2VpdmVyUHJpdmF0ZUtleSlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXlcblxuICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpXG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dClcbiAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpXG5cbiAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkpXG5cbiAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICBsZXQgb3V0cHV0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmFjbC51dGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZC4nKVxuICAgIH1cbiAgfSxcblxuICBkZWNyeXB0U2FmZWx5IChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKHRoaXMuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKVxuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YVxuICB9LFxuXG5cbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSAocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocHJpdmF0ZUtleSlcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXlcbiAgICByZXR1cm4gbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBzaWduVHlwZWRNZXNzYWdlIChwcml2YXRlS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFMZWdhY3kocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhKHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjQocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICByZWNvdmVyVHlwZWRNZXNzYWdlIChtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWMyc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICBzaWduVHlwZWREYXRhIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICBzaWduVHlwZWREYXRhX3Y0IChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCAodHlwZWREYXRhKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5JylcbiAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8ICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ2J5dGVzJyA/IGV0aFV0aWwudG9CdWZmZXIoZS52YWx1ZSkgOiBlLnZhbHVlXG4gIH0pXG4gIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGVcbiAgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gXG4gIH0pXG5cbiAgcmV0dXJuIGV0aEFiaS5zb2xpZGl0eVNIQTMoXG4gICAgWydieXRlczMyJywgJ2J5dGVzMzInXSxcbiAgICBbXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSxcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0sXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleSAoaGFzaCwgc2lnKSB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFV0aWwudG9CdWZmZXIoc2lnKVxuICBjb25zdCBzaWdQYXJhbXMgPSBldGhVdGlsLmZyb21ScGNTaWcoc2lnbmF0dXJlKVxuICByZXR1cm4gZXRoVXRpbC5lY3JlY292ZXIoaGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucylcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yIChtc2dQYXJhbXMpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwudG9CdWZmZXIobXNnUGFyYW1zLmRhdGEpXG4gIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgcmV0dXJuIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbn1cblxuXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzIChudW1iZXIsIGxlbmd0aCkge1xuICBsZXQgbXlTdHJpbmcgPSBgJHtudW1iZXJ9YFxuICB3aGlsZSAobXlTdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YFxuICB9XG4gIHJldHVybiBteVN0cmluZ1xufVxuXG4vLyBjb252ZXJ0cyBoZXggc3RyaW5ncyB0byB0aGUgVWludDhBcnJheSBmb3JtYXQgdXNlZCBieSBuYWNsXG5mdW5jdGlvbiBuYWNsX2RlY29kZUhleCAobXNnSGV4KSB7XG4gIGNvbnN0IG1zZ0Jhc2U2NCA9IChCdWZmZXIuZnJvbShtc2dIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIHJldHVybiBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NClcbn1cblxuXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUgPSBleHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kQXN5bmMocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gcHJvdmlkZXJBc01pZGRsZXdhcmU7XG5mdW5jdGlvbiBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmQocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFzTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCBfcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9ICgwLCBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleCkocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJld3JpdGUgYmxvY2tSZWYgdG8gYmxvY2stdHJhY2tlcidzIGJsb2NrIG51bWJlclxuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBpZiAocmVxLnBhcmFtcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgICAgIHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi1yZXdyaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBleHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL2dsb2JhbC1yZXF1aXJlLEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmNvbnN0IGZldGNoID0gZ2xvYmFsLmZldGNoIHx8IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IGJ0b2EgPSBnbG9iYWwuYnRvYSB8fCByZXF1aXJlKCdidG9hJyk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvZ2xvYmFsLXJlcXVpcmUsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ2ZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5JyxcbiAgICAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcbiAgICAnRmFpbGVkIHRvIGZldGNoJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoeyBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Qm9keSA9IGF3YWl0IGZldGNoUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBkYXRhOiBib2R5LmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHsgcmVxLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCk7XG4gICAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gICAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG4gICAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gICAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcbiAgICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkLFxuICAgIH07XG4gICAgLy8gZW5jb2RlZCBhdXRoIGRldGFpbHMgYXMgaGVhZGVyIChub3QgYWxsb3dlZCBpbiBmZXRjaCB1cmwpXG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSAmJiBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXV0aFN0cmluZyA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBidG9hKGF1dGhTdHJpbmcpO1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gO1xuICAgIH1cbiAgICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICAgIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4geyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxO1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgcmVzdWx0ICs9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgICByZXN1bHQgKz0gYC8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9YDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGA6JHtwYXJzZWRVcmwucG9ydH1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5zZWFyY2h9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBtc2cgfSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSgpIHtcbiAgICBjb25zdCBpbmZsaWdodFJlcXVlc3RzID0ge307XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjYWNoZUlkLCBpZiBjYWNoZWFibGVcbiAgICAgICAgY29uc3QgY2FjaGVJZCA9ICgwLCBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQpKHJlcSk7XG4gICAgICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICAgICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gaWYgZm91bmQsIHdhaXQgZm9yIHRoZSBhY3RpdmUgcmVxdWVzdCB0byBiZSBoYW5kbGVkXG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXIgYXJyYXkgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgICAgIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgICAgIC8vIGFsbG93IHJlcXVlc3QgdG8gYmUgaGFuZGxlZCBub3JtYWxseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBjbGVhciBpbmZsaWdodCByZXF1ZXN0c1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYWN0aXZlUmVxdWVzdEhhbmRsZXJzIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goKGhhbmRsZWRSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhIGNvcHkgb2YgdGhlIHJlc3VsdCBhbmQgZXJyb3IgdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXMucmVzdWx0ID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoaGFuZGxlZFJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzLmVycm9yID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoaGFuZGxlZFJlcy5lcnJvcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIHNvIGFsbCByZXF1ZXN0cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmU7XG5mdW5jdGlvbiBkZWZlcnJlZFByb21pc2UoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGlnaHQtY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBmdXR1cmVCbG9ja1JlZlJlcXVlc3RzID0gW1xuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Jyxcbl07XG4vLyBpbnNwZWN0IGlmIHJlc3BvbnNlIGNvbnRhaW5zIGEgYmxvY2sgcmVmIGhpZ2hlciB0aGFuIG91ciBsYXRlc3QgYmxvY2tcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0pIHtcbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFmdXR1cmVCbG9ja1JlZlJlcXVlc3RzLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGFib3J0IGlmIG5vIHJlc3VsdCBvciBubyBibG9jayBudW1iZXJcbiAgICAgICAgaWYgKCEoKF9hID0gcmVzLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsb2NrTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQuYmxvY2tOdW1iZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBpZiBudW1iZXIgaXMgaGlnaGVyLCBzdWdnZXN0IGJsb2NrLXRyYWNrZXIgY2hlY2sgZm9yIGEgbmV3IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChyZXMucmVzdWx0LmJsb2NrTnVtYmVyLCAxNik7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogSWYgZ2V0Q3VycmVudEJsb2NrIHJldHVybnMgbnVsbCwgY3VycmVudEJsb2NrTnVtYmVyIHdpbGwgYmUgTmFOLCB3aGljaCBpcyBmaW5lLlxuICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKSwgMTYpO1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gY3VycmVudEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmxvY2tUcmFja2VyLmNoZWNrRm9yTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcHJvdmlkZXJGcm9tRW5naW5lXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlckZyb21FbmdpbmVcIik7XG5mdW5jdGlvbiBwcm92aWRlckZyb21NaWRkbGV3YXJlKG1pZGRsZXdhcmUpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcganNvbl9ycGNfZW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gKDAsIHByb3ZpZGVyRnJvbUVuZ2luZV8xLnByb3ZpZGVyRnJvbUVuZ2luZSkoZW5naW5lKTtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG59XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSBwcm92aWRlckZyb21NaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGcm9tTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG4vL1xuLy8gUmV0cnlPbkVtcHR5TWlkZGxld2FyZSB3aWxsIHJldHJ5IGFueSByZXF1ZXN0IHdpdGggYW4gZW1wdHkgcmVzcG9uc2UgdGhhdCBoYXNcbi8vIGEgbnVtYmVyZWQgYmxvY2sgcmVmZXJlbmNlIGF0IG9yIGxvd2VyIHRoYW4gdGhlIGJsb2NrVHJhY2tlcidzIGxhdGVzdCBibG9jay5cbi8vIEl0cyB1c2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBsb2FkLWJhbGFuY2VkIGV0aGVyZXVtIEpTT04gUlBDXG4vLyBub2RlcyB0aGF0IGFyZSBub3QgYWx3YXlzIGluIHN5bmMgd2l0aCBlYWNoIG90aGVyLlxuLy9cbi8vIGVtcHR5IHZhbHVlcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWRcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFtcbiAgICB1bmRlZmluZWQsXG4gICAgbnVsbCxcbiAgICAnXFx1MDAzY25pbFxcdTAwM2UnLFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSAoMCwgY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgpKHJlcSk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBleGFjdCBibG9jayByZWZlcmVuY2VzXG4gICAgICAgIGxldCBibG9ja1JlZiA9IChfYSA9IHJlcS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtibG9ja1JlZkluZGV4XTtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub24tbnVtYmVyIGJsb2NrIHJlZmVyZW5jZVxuICAgICAgICBpZiAoWydsYXRlc3QnLCAncGVuZGluZyddLmluY2x1ZGVzKGJsb2NrUmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIGJsb2NrIHJlZmVybmNlIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgICAgICBjb25zdCBibG9ja1JlZk51bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja1JlZi5zbGljZSgyKSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJsb2NrUmVmTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVySGV4ID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGxhdGVzdEJsb2NrTnVtYmVySGV4LnNsaWNlKDIpLCAxNik7XG4gICAgICAgIC8vIHNraXAgaWYgcmVxdWVzdCBibG9jayBudW1iZXIgaXMgaGlnaGVyIHRoYW4gY3VycmVudFxuICAgICAgICBpZiAoYmxvY2tSZWZOdW1iZXIgPiBsYXRlc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgY2hpbGQgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGJsb2NrLXJlZlxuICAgICAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSAoMCwgY2xvbmVfMS5kZWZhdWx0KShyZXEpO1xuICAgICAgICAvLyBhdHRlbXB0IGNoaWxkIHJlcXVlc3QgdW50aWwgbm9uLWVtcHR5IHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgIGNvbnN0IGNoaWxkUmVzcG9uc2UgPSBhd2FpdCByZXRyeSgxMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFJlc3BvbnNlID0gYXdhaXQgKDAsIHBpZnlfMS5kZWZhdWx0KShwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVzdWx0XG4gICAgICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMoYXR0ZW1wdFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIGVtcHR5IHJlc3BvbnNlIFwiJHtKU09OLnN0cmluZ2lmeShhdHRlbXB0UmVzcG9uc2UpfVwiIGZvciByZXF1ZXN0IFwiJHtKU09OLnN0cmluZ2lmeShjaGlsZFJlcXVlc3QpfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0ZW1wdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgcmVzLmVycm9yID0gY2hpbGRSZXNwb25zZS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmU7XG5hc3luYyBmdW5jdGlvbiByZXRyeShtYXhSZXRyaWVzLCBhc3luY0ZuKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1heFJldHJpZXM7IGluZGV4KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhc3luY0ZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dCgxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSByZXRyaWVzIGV4aGF1c3RlZCcpO1xufVxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlPbkVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgIC8vIGhhbmRsZSBib3RoIHJwYyBzZW5kIG1ldGhvZHNcbiAgICBwcm92aWRlci5zZW5kQXN5bmMgPSBlbmdpbmUuaGFuZGxlLmJpbmQoZW5naW5lKTtcbiAgICBwcm92aWRlci5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgICBpZiAoZW5naW5lLm9uKSB7XG4gICAgICAgIGVuZ2luZS5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoJ2RhdGEnLCBudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gcHJvdmlkZXJGcm9tRW5naW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGcm9tRW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9ICgwLCBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleCkocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gKDAsIGNsb25lXzEuZGVmYXVsdCkocmVxKTtcbiAgICAgICAgaWYgKGNoaWxkUmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgICAgIGNoaWxkUmVxdWVzdC5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoaWxkIHJlcXVlc3RcbiAgICAgICAgY29uc3QgY2hpbGRSZXMgPSBhd2FpdCAoMCwgcGlmeV8xLmRlZmF1bHQpKHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlcy5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzLmVycm9yO1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ1xcdTAwM2NuaWxcXHUwMDNlJ107XG4vL1xuLy8gQ2FjaGUgU3RyYXRlZ2llc1xuLy9cbmNsYXNzIEJsb2NrQ2FjaGVTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQoX3BheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtibG9ja051bWJlcl0gPSBuZXdDYWNoZTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tDYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIGxvb2t1cCBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKShwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyBibG9ja0NhY2hlW2lkZW50aWZpZXJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzZXQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlc3VsdCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gY2FjaGVkIHRoaXMgcmVzdWx0XG4gICAgICAgIGNvbnN0IGNhbkNhY2hlUmVzdWx0ID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWNhbkNhY2hlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQpKHBheWxvYWQsIHRydWUpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIC8vIGNoZWNrIHJlcXVlc3QgbWV0aG9kXG4gICAgICAgIGlmICghKDAsIGNhY2hlXzEuY2FuQ2FjaGUpKHBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYmxvY2tUYWdcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSAoMCwgY2FjaGVfMS5ibG9ja1RhZ0ZvclBheWxvYWQpKHBheWxvYWQpO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCkge1xuICAgICAgICAvLyBuZXZlciBjYWNoZSBlbXB0eSB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkKVxuICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgJiZcbiAgICAgICAgICAgIFsnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXS5pbmNsdWRlcyhwYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgIXJlc3VsdC5ibG9ja0hhc2ggfHxcbiAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID09PVxuICAgICAgICAgICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICAgIGNsZWFyQmVmb3JlKG9sZEJsb2NrSGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KG9sZEJsb2NrSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigobnVtKSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChudW0pID0+IGRlbGV0ZSB0aGlzLmNhY2hlW251bV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIFBvbGxpbmdCbG9ja1RyYWNrZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IEJsb2NrQ2FjaGVTdHJhdGVneSgpO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgICAgICBibG9jazogYmxvY2tDYWNoZSxcbiAgICAgICAgZm9yazogYmxvY2tDYWNoZSxcbiAgICB9O1xuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgICAgICBjb25zdCB0eXBlID0gKDAsIGNhY2hlXzEuY2FjaGVUeXBlRm9yUGF5bG9hZCkocmVxKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmxvY2sgcmVmZXJlbmNlIChudW1iZXIgb3Iga2V5d29yZClcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gKDAsIGNhY2hlXzEuYmxvY2tUYWdGb3JQYXlsb2FkKShyZXEpO1xuICAgICAgICBpZiAoIWJsb2NrVGFnKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBleGFjdCBibG9jayBudW1iZXJcbiAgICAgICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMganVzdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGggXCJsYXRlc3RcIlxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSAnMHgwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2tUYWcgPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBsYXRlc3QgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGNhY2hlIGJlZm9yZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUuY2xlYXJCZWZvcmUobGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBoZXggbnVtYmVyXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuZ2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gY2FzdCByZXMucmVzdWx0IGFzIEJsb2NrLCBkdWUgdG8gcnVudGltZSB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgLy8gcGVyZm9ybWVkIHdoZW4gc3RyYXRlZ3kuc2V0IGlzIGNhbGxlZFxuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3kuc2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVXYWxsZXRNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3Qgc2lnVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZXRoLXNpZy11dGlsXCIpKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5mdW5jdGlvbiBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlKHsgZ2V0QWNjb3VudHMsIHByb2Nlc3NEZWNyeXB0TWVzc2FnZSwgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXksIHByb2Nlc3NFdGhTaWduTWVzc2FnZSwgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSwgcHJvY2Vzc1RyYW5zYWN0aW9uLCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uLCBwcm9jZXNzVHlwZWRNZXNzYWdlLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNCwgfSkge1xuICAgIGlmICghZ2V0QWNjb3VudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmdldEFjY291bnRzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKSh7XG4gICAgICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgICAgICBldGhfYWNjb3VudHM6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGxvb2t1cEFjY291bnRzKSxcbiAgICAgICAgZXRoX2NvaW5iYXNlOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShsb29rdXBEZWZhdWx0QWNjb3VudCksXG4gICAgICAgIC8vIHR4IHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoc2VuZFRyYW5zYWN0aW9uKSxcbiAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoc2lnblRyYW5zYWN0aW9uKSxcbiAgICAgICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zaWduOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShldGhTaWduKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGE6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHNpZ25UeXBlZERhdGEpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92MzogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoc2lnblR5cGVkRGF0YVYzKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHNpZ25UeXBlZERhdGFWNCksXG4gICAgICAgIHBlcnNvbmFsX3NpZ246ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHBlcnNvbmFsU2lnbiksXG4gICAgICAgIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5OiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShlbmNyeXB0aW9uUHVibGljS2V5KSxcbiAgICAgICAgZXRoX2RlY3J5cHQ6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGRlY3J5cHRNZXNzYWdlKSxcbiAgICAgICAgcGVyc29uYWxfZWNSZWNvdmVyOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShwZXJzb25hbFJlY292ZXIpLFxuICAgIH0pO1xuICAgIC8vXG4gICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBBY2NvdW50cyhyZXEsIHJlcykge1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwRGVmYXVsdEFjY291bnQocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYWNjb3VudHNbMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB0cmFuc2FjdGlvbiBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1RyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzU2lnblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NTaWduVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBldGhTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMSc7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjMocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjMpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjMnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjQocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjQpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjQnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzUGVyc29uYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdFBhcmFtID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFyYW0gPSByZXEucGFyYW1zWzFdO1xuICAgICAgICAvLyBub24tc3RhbmRhcmQgXCJleHRyYVBhcmFtc1wiIHRvIGJlIGFwcGVuZGVkIHRvIG91ciBcIm1zZ1BhcmFtc1wiIG9ialxuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIC8vIFdlIGluaXRpYWxseSBpbmNvcnJlY3RseSBvcmRlcmVkIHRoZXNlIHBhcmFtZXRlcnMuXG4gICAgICAgIC8vIFRvIGdyYWNlZnVsbHkgcmVzcGVjdCB1c2VycyB3aG8gYWRvcHRlZCB0aGlzIEFQSSBlYXJseSxcbiAgICAgICAgLy8gd2UgYXJlIGN1cnJlbnRseSBncmFjZWZ1bGx5IHJlY292ZXJpbmcgZnJvbSB0aGUgd3JvbmcgcGFyYW0gb3JkZXJcbiAgICAgICAgLy8gd2hlbiBpdCBpcyBjbGVhcmx5IGlkZW50aWZpYWJsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhhdCBtZWFucyB3aGVuIHRoZSBmaXJzdCBwYXJhbSBpcyBkZWZpbml0ZWx5IGFuIGFkZHJlc3MsXG4gICAgICAgIC8vIGFuZCB0aGUgc2Vjb25kIHBhcmFtIGlzIGRlZmluaXRlbHkgbm90LCBidXQgaXMgaGV4LlxuICAgICAgICBsZXQgYWRkcmVzcywgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlc2VtYmxlc0FkZHJlc3MoZmlyc3RQYXJhbSkgJiYgIXJlc2VtYmxlc0FkZHJlc3Moc2Vjb25kUGFyYW0pKSB7XG4gICAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX3BlcnNvbmFsU2lnbiBtZXRob2QgcmVxdWlyZXMgcGFyYW1zIG9yZGVyZWQgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFttZXNzYWdlLCBhZGRyZXNzXS4gVGhpcyB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluY29ycmVjdGx5LCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgYW5kIGhhcyBiZWVuIGNvcnJlY3RlZCBhdXRvbWF0aWNhbGx5LiBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgUGxlYXNlIHN3aXRjaCB0aGlzIHBhcmFtIG9yZGVyIGZvciBzbW9vdGggYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5gO1xuICAgICAgICAgICAgcmVzLndhcm5pbmcgPSB3YXJuaW5nO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBtZXNzYWdlID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFJlY292ZXIocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgc2lnOiBzaWduYXR1cmUsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShtc2dQYXJhbXMpO1xuICAgICAgICByZXMucmVzdWx0ID0gc2lnbmVyQWRkcmVzcztcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdGlvblB1YmxpY0tleShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBkZWNyeXB0TWVzc2FnZShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NEZWNyeXB0TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBjaXBoZXJ0ZXh0IH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB1dGlsaXR5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGtleWhvbGRlciBhZGRyZXNzLCBhbmQgcmV0dXJucyBhIG5vcm1hbGl6ZWQgKGkuZS4gbG93ZXJjYXNlKVxuICAgICAqIGNvcHkgb2YgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBub3JtYWxpemVkIGFkZHJlc3MsIGlmIHZhbGlkLiBPdGhlcndpc2UsIHRocm93c1xuICAgICAqIGFuIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycgJiYgYWRkcmVzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYWRkcmVzcyBpcyBpbmNsdWRlZCBpbiBwcm92aWRlZCBhY2NvdW50c1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFjY291bnRzID0gYWNjb3VudHMubWFwKChfYWRkcmVzcykgPT4gX2FkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkQWNjb3VudHMuaW5jbHVkZXMobm9ybWFsaXplZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHBhcmFtZXRlcnM6IG11c3QgcHJvdmlkZSBhbiBFdGhlcmV1bSBhZGRyZXNzLmAsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IGNyZWF0ZVdhbGxldE1pZGRsZXdhcmU7XG5mdW5jdGlvbiByZXNlbWJsZXNBZGRyZXNzKHN0cikge1xuICAgIC8vIGhleCBwcmVmaXggMiArIDIwIGJ5dGVzXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDIgKyAyMCAqIDI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNBTkNFTExBQkxFX0lOVEVSVkFMID0gZXhwb3J0cy5ERUZBVUxUX0lOVEVSVkFMID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIik7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBtYXBWYWx1ZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFZhbHVlc1wiKSk7XG5jb25zdCBjbG9uZURlZXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHsgc2FmZWx5RXhlY3V0ZSB9ID0gY29udHJvbGxlcnNfMS51dGlsO1xuLy8gVE9ETzogSlNEb2MgYWxsIG1ldGhvZHNcbi8vIFRPRE86IFJlbW92ZSBhbGwgY29tbWVudHMgKCogISA/KVxuY29uc3QgU0VDT05EID0gMTAwMDtcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xuZXhwb3J0cy5ERUZBVUxUX0lOVEVSVkFMID0gU0VDT05EICogMTA7XG5leHBvcnRzLkNBTkNFTExBQkxFX0lOVEVSVkFMID0gTUlOVVRFO1xuY2xhc3MgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyIGV4dGVuZHMgY29udHJvbGxlcnNfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoeyBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgZ2V0Tm9uY2VMb2NrLCBnZXROZXR3b3JrLCBwcm92aWRlciwgY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb24sIHRyYWNrTWV0YU1ldHJpY3NFdmVudCwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IGV4cG9ydHMuREVGQVVMVF9JTlRFUlZBTCxcbiAgICAgICAgICAgIGNoYWluSWQ6IGNvbnN0YW50c18xLkNIQUlOX0lEUy5FVEhFUkVVTSxcbiAgICAgICAgICAgIGNsaWVudElkOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICBzdXBwb3J0ZWRDaGFpbklkczogW2NvbnN0YW50c18xLkNIQUlOX0lEUy5FVEhFUkVVTSwgY29uc3RhbnRzXzEuQ0hBSU5fSURTLlJJTktFQlldLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IHtcbiAgICAgICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uczoge30sXG4gICAgICAgICAgICAgICAgdXNlck9wdEluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmVlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxpdmVuZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVzdGltYXRlZEdhczoge1xuICAgICAgICAgICAgICAgICAgICB0eERhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxUeERhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXROb25jZUxvY2sgPSBnZXROb25jZUxvY2s7XG4gICAgICAgIHRoaXMuZ2V0TmV0d29yayA9IGdldE5ldHdvcms7XG4gICAgICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzXzEuZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLmNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uID0gY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMudHJhY2tNZXRhTWV0cmljc0V2ZW50ID0gdHJhY2tNZXRhTWV0cmljc0V2ZW50O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU21hcnRUcmFuc2FjdGlvbnNGb3JDaGFpbklkKCk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyOiBuZXdQcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IG5ld1Byb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBjaGFpbklkIH0pO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplU21hcnRUcmFuc2FjdGlvbnNGb3JDaGFpbklkKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUG9sbCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuZXRoZXJzUHJvdmlkZXIgPSBuZXcgZXRoZXJzXzEuZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKGN1cnJlbnRTdGF0ZSkgPT4gdGhpcy5jaGVja1BvbGwoY3VycmVudFN0YXRlKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgYXN5bmMgZmV0Y2gocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNsaWVudElkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCAoY2xpZW50SWQgJiYgeyAnWC1DbGllbnQtSWQnOiBjbGllbnRJZCB9KSkgfSk7XG4gICAgICAgIHJldHVybiB1dGlsc18xLmhhbmRsZUZldGNoKHJlcXVlc3QsIGZldGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGNoZWNrUG9sbChzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSBzdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPSBzbWFydFRyYW5zYWN0aW9uc1t0aGlzLmNvbmZpZy5jaGFpbklkXTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9ucyA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9PT0gbnVsbCB8fCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5maWx0ZXIodXRpbHNfMS5pc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVvdXRIYW5kbGUgJiYgKHBlbmRpbmdUcmFuc2FjdGlvbnMgPT09IG51bGwgfHwgcGVuZGluZ1RyYW5zYWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ1RyYW5zYWN0aW9ucy5sZW5ndGgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lb3V0SGFuZGxlICYmIChwZW5kaW5nVHJhbnNhY3Rpb25zID09PSBudWxsIHx8IHBlbmRpbmdUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdUcmFuc2FjdGlvbnMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZVNtYXJ0VHJhbnNhY3Rpb25zRm9yQ2hhaW5JZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc3VwcG9ydGVkQ2hhaW5JZHMuaW5jbHVkZXModGhpcy5jb25maWcuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHNtYXJ0VHJhbnNhY3Rpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUuc21hcnRUcmFuc2FjdGlvbnMpLCB7IFt0aGlzLmNvbmZpZy5jaGFpbklkXTogKF9hID0gc21hcnRUcmFuc2FjdGlvbnNTdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1t0aGlzLmNvbmZpZy5jaGFpbklkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10gfSkgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc3VwcG9ydGVkQ2hhaW5JZHMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGltZW91dEhhbmRsZSAmJiBjbGVhckludGVydmFsKHRoaXMudGltZW91dEhhbmRsZSk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ2hhaW5JZHMuaW5jbHVkZXMoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlU21hcnRUcmFuc2FjdGlvbnMoKSk7XG4gICAgICAgIHRoaXMudGltZW91dEhhbmRsZSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy51cGRhdGVTbWFydFRyYW5zYWN0aW9ucygpKTtcbiAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVvdXRIYW5kbGUpO1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldE9wdEluU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHVzZXJPcHRJbjogc3RhdGUgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFja1N0eFN0YXR1c0NoYW5nZShzbWFydFRyYW5zYWN0aW9uLCBwcmV2U21hcnRUcmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXByZXZTbWFydFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHRyYWNrIHRoZSBmaXJzdCBTVFgsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIGFsbCBuZWNlc3NhcnkgcGFyYW1zLlxuICAgICAgICB9XG4gICAgICAgIGxldCB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbiA9IGNsb25lRGVlcF8xLmRlZmF1bHQoc21hcnRUcmFuc2FjdGlvbik7XG4gICAgICAgIHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbG9uZURlZXBfMS5kZWZhdWx0KHByZXZTbWFydFRyYW5zYWN0aW9uKSksIHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKCF1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5zd2FwTWV0YURhdGEgfHxcbiAgICAgICAgICAgICh1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5zdGF0dXMgPT09IHByZXZTbWFydFRyYW5zYWN0aW9uLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgIHByZXZTbWFydFRyYW5zYWN0aW9uLnN3YXBNZXRhRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gSWYgc3RhdHVzIGhhc24ndCBjaGFuZ2VkLCBkb24ndCB0cmFjayBpdCBhZ2Fpbi5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5zaXRpdmVQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgc3R4X3N0YXR1czogdXBkYXRlZFNtYXJ0VHJhbnNhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgdG9rZW5fZnJvbV9hZGRyZXNzOiAoX2EgPSB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi50eFBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20sXG4gICAgICAgICAgICB0b2tlbl9mcm9tX3N5bWJvbDogdXBkYXRlZFNtYXJ0VHJhbnNhY3Rpb24uc291cmNlVG9rZW5TeW1ib2wsXG4gICAgICAgICAgICB0b2tlbl90b19hZGRyZXNzOiAoX2IgPSB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi50eFBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvLFxuICAgICAgICAgICAgdG9rZW5fdG9fc3ltYm9sOiB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5kZXN0aW5hdGlvblRva2VuU3ltYm9sLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ190aW1lOiB1dGlsc18xLmdldFN0eFByb2Nlc3NpbmdUaW1lKHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uLnRpbWUpLFxuICAgICAgICAgICAgc3R4X2VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBzdHhfdXNlcl9vcHRfaW46IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiAnU1RYIFN0YXR1cyBVcGRhdGVkJyxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnc3dhcHMnLFxuICAgICAgICAgICAgc2Vuc2l0aXZlUHJvcGVydGllcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzTmV3U21hcnRUcmFuc2FjdGlvbihzbWFydFRyYW5zYWN0aW9uVXVpZCkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnMgfSA9IHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9IHNtYXJ0VHJhbnNhY3Rpb25zW2NoYWluSWRdO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPT09IG51bGwgfHwgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMuZmluZEluZGV4KChzdHgpID0+IHN0eC51dWlkID09PSBzbWFydFRyYW5zYWN0aW9uVXVpZCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50SW5kZXggPT09IC0xIHx8IGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB1cGRhdGVTbWFydFRyYW5zYWN0aW9uKHNtYXJ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBzbWFydFRyYW5zYWN0aW9uc1N0YXRlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSBzbWFydFRyYW5zYWN0aW9uc1N0YXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPSBzbWFydFRyYW5zYWN0aW9uc1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID09PSBudWxsIHx8IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoc3R4KSA9PiBzdHgudXVpZCA9PT0gc21hcnRUcmFuc2FjdGlvbi51dWlkKTtcbiAgICAgICAgY29uc3QgaXNOZXdTbWFydFRyYW5zYWN0aW9uID0gdGhpcy5pc05ld1NtYXJ0VHJhbnNhY3Rpb24oc21hcnRUcmFuc2FjdGlvbi51dWlkKTtcbiAgICAgICAgdGhpcy50cmFja1N0eFN0YXR1c0NoYW5nZShzbWFydFRyYW5zYWN0aW9uLCBpc05ld1NtYXJ0VHJhbnNhY3Rpb25cbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uc1tjdXJyZW50SW5kZXhdKTtcbiAgICAgICAgaWYgKGlzTmV3U21hcnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gYWRkIHNtYXJ0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsZWROb25jZUluZGV4ID0gY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoc3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBzdHgudHhQYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub25jZSkgPT09ICgoX2IgPSBzbWFydFRyYW5zYWN0aW9uLnR4UGFyYW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9uY2UpICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2MgPSBzdHguc3RhdHVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aCgnY2FuY2VsbGVkJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lRGVlcF8xLmRlZmF1bHQoc21hcnRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gW3NuYXBzaG90XTtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcmlmaWVkU21hcnRUcmFuc2FjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbiksIHsgaGlzdG9yeSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTbWFydFRyYW5zYWN0aW9ucyA9IGNhbmNlbGxlZE5vbmNlSW5kZXggPiAtMVxuICAgICAgICAgICAgICAgID8gY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBjYW5jZWxsZWROb25jZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5zbGljZShjYW5jZWxsZWROb25jZUluZGV4ICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoaGlzdG9yaWZpZWRTbWFydFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIDogY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zLmNvbmNhdChoaXN0b3JpZmllZFNtYXJ0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSksIHsgc21hcnRUcmFuc2FjdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZS5zbWFydFRyYW5zYWN0aW9ucyksIHsgW2NoYWluSWRdOiBuZXh0U21hcnRUcmFuc2FjdGlvbnMgfSkgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNtYXJ0VHJhbnNhY3Rpb24uc3RhdHVzID09PSB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5TVUNDRVNTIHx8XG4gICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuUkVWRVJURUQpICYmXG4gICAgICAgICAgICAhc21hcnRUcmFuc2FjdGlvbi5jb25maXJtZWQpIHtcbiAgICAgICAgICAgIC8vIGNvbmZpcm0gc21hcnQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uID0gY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zW2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgICBjb25zdCBuZXh0U21hcnRUcmFuc2FjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb24pLCBzbWFydFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlybVNtYXJ0VHJhbnNhY3Rpb24obmV4dFNtYXJ0VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSksIHsgc21hcnRUcmFuc2FjdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZS5zbWFydFRyYW5zYWN0aW9ucyksIHsgW2NoYWluSWRdOiBzbWFydFRyYW5zYWN0aW9uc1N0YXRlLnNtYXJ0VHJhbnNhY3Rpb25zW2NoYWluSWRdLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gY3VycmVudEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCBzbWFydFRyYW5zYWN0aW9uKSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH0pIH0pIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlU21hcnRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGUuc21hcnRUcmFuc2FjdGlvbnNTdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID0gc21hcnRUcmFuc2FjdGlvbnMgPT09IG51bGwgfHwgc21hcnRUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNtYXJ0VHJhbnNhY3Rpb25zW2NoYWluSWRdO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnNUb1VwZGF0ZSA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcih1dGlsc18xLmlzU21hcnRUcmFuc2FjdGlvblBlbmRpbmcpXG4gICAgICAgICAgICAubWFwKChzbWFydFRyYW5zYWN0aW9uKSA9PiBzbWFydFRyYW5zYWN0aW9uLnV1aWQpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25zVG9VcGRhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFNtYXJ0VHJhbnNhY3Rpb25zU3RhdHVzKHRyYW5zYWN0aW9uc1RvVXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb25maXJtU21hcnRUcmFuc2FjdGlvbihzbWFydFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0eEhhc2ggPSAoX2EgPSBzbWFydFRyYW5zYWN0aW9uLnN0YXR1c01ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWluZWRIYXNoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25SZWNlaXB0ID0gYXdhaXQgdGhpcy5ldGhlcnNQcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5ldGhlcnNQcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICAgICAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gKF9iID0gdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gKF9jID0gdHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uUmVjZWlwdCA9PT0gbnVsbCB8fCB0cmFuc2FjdGlvblJlY2VpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrRGF0YSA9IGF3YWl0IHRoaXMuZXRoZXJzUHJvdmlkZXIuZ2V0QmxvY2sodHJhbnNhY3Rpb25SZWNlaXB0ID09PSBudWxsIHx8IHRyYW5zYWN0aW9uUmVjZWlwdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNhY3Rpb25SZWNlaXB0LmJsb2NrTnVtYmVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUZlZVBlckdhcyA9IGJsb2NrRGF0YSA9PT0gbnVsbCB8fCBibG9ja0RhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJsb2NrRGF0YS5iYXNlRmVlUGVyR2FzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0gbWFwVmFsdWVzXzEuZGVmYXVsdCh0cmFuc2FjdGlvblJlY2VpcHQsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBldGhlcnNfMS5ldGhlcnMuQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFR4UGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbWFydFRyYW5zYWN0aW9uLnR4UGFyYW1zKSwgeyBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFR4TWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbiksIHsgaWQ6IHNtYXJ0VHJhbnNhY3Rpb24udXVpZCwgc3RhdHVzOiAnY29uZmlybWVkJywgaGFzaDogdHhIYXNoLCB0eFBhcmFtczogdXBkYXRlZFR4UGFyYW1zIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0eE1ldGEgc25hcHNob3QgZm9yIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHV0aWxzXzEuc25hcHNob3RGcm9tVHhNZXRhKG9yaWdpbmFsVHhNZXRhKTtcbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHByZXZpb3VzIHR4IHN0YXRlIG9ialxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB1dGlsc18xLnJlcGxheUhpc3Rvcnkob3JpZ2luYWxUeE1ldGEuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgaGlzdG9yeSBlbnRyeSBhbmQgYWRkIHRvIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHV0aWxzXzEuZ2VuZXJhdGVIaXN0b3J5RW50cnkocHJldmlvdXNTdGF0ZSwgc25hcHNob3QsICd0eFN0YXRlTWFuYWdlcjogc2V0dGluZyBzdGF0dXMgdG8gY29uZmlybWVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhNZXRhID0gZW50cnkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxUeE1ldGEpLCB7IGhpc3Rvcnk6IG9yaWdpbmFsVHhNZXRhLmhpc3RvcnkuY29uY2F0KGVudHJ5KSB9KSA6IG9yaWdpbmFsVHhNZXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb24odHhNZXRhLCB0eFJlY2VpcHQsIGJhc2VGZWVQZXJHYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdTVFggQ29uZmlybWVkJyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdzd2FwcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTbWFydFRyYW5zYWN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbiksIHsgY29uZmlybWVkOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy50cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnU1RYIENvbmZpcm1hdGlvbiBGYWlsZWQnLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAnc3dhcHMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb25maXJtIGVycm9yJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gISBBc2sgYmFja2VuZCBBUEkgdG8gYWNjZXB0IGxpc3Qgb2YgdXVpZHMgYXMgcGFyYW1zXG4gICAgYXN5bmMgZmV0Y2hTbWFydFRyYW5zYWN0aW9uc1N0YXR1cyh1dWlkcykge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHV1aWRzOiB1dWlkcy5qb2luKCcsJyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkJBVENIX1NUQVRVUywgY2hhaW5JZCl9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW3V1aWQsIHNtYXJ0VHJhbnNhY3Rpb25dKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHN0YXR1c01ldGFkYXRhOiBzbWFydFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXR1czogdXRpbHNfMS5jYWxjdWxhdGVTdGF0dXMoc21hcnRUcmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgdXVpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFzeW5jIGFkZE5vbmNlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBub25jZUxvY2sgPSBhd2FpdCB0aGlzLmdldE5vbmNlTG9jayh0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBub25jZUxvY2submV4dE5vbmNlO1xuICAgICAgICBub25jZUxvY2sucmVsZWFzZUxvY2soKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb24pLCB7IG5vbmNlOiBgMHgke25vbmNlLnRvU3RyaW5nKDE2KX1gIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVzKHVuc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbldpdGhOb25jZSA9IGF3YWl0IHRoaXMuYWRkTm9uY2VUb1RyYW5zYWN0aW9uKHVuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkdFVF9GRUVTLCBjaGFpbklkKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHg6IHVuc2lnbmVkVHJhbnNhY3Rpb25XaXRoTm9uY2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlKSwgeyBmZWVzOiBkYXRhIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFzeW5jIGVzdGltYXRlR2FzKHVuc2lnbmVkVHJhbnNhY3Rpb24sIGFwcHJvdmVUeFBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBsZXQgYXBwcm92YWxUeERhdGE7XG4gICAgICAgIGlmIChhcHByb3ZlVHhQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkQXBwcm92YWxUcmFuc2FjdGlvbldpdGhOb25jZSA9IGF3YWl0IHRoaXMuYWRkTm9uY2VUb1RyYW5zYWN0aW9uKGFwcHJvdmVUeFBhcmFtcyk7XG4gICAgICAgICAgICBhcHByb3ZhbFR4RGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2godXRpbHNfMS5nZXRBUElSZXF1ZXN0VVJMKHR5cGVzXzEuQVBJVHlwZS5FU1RJTUFURV9HQVMsIGNoYWluSWQpLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eDogdW5zaWduZWRBcHByb3ZhbFRyYW5zYWN0aW9uV2l0aE5vbmNlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbldpdGhOb25jZSA9IGF3YWl0IHRoaXMuYWRkTm9uY2VUb1RyYW5zYWN0aW9uKHVuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkVTVElNQVRFX0dBUywgY2hhaW5JZCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IHR4OiB1bnNpZ25lZFRyYW5zYWN0aW9uV2l0aE5vbmNlIH0sIChhcHByb3ZlVHhQYXJhbXMgJiYgeyBwZW5kaW5nX3R4czogW2FwcHJvdmVUeFBhcmFtc10gfSkpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlKSwgeyBlc3RpbWF0ZWRHYXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHhEYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbFR4RGF0YSxcbiAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8vICogQWZ0ZXIgdGhpcyBzdWNjZXNzZnVsIGNhbGwgY2xpZW50IG11c3QgYWRkIGEgbm9uY2UgcmVwcmVzZW50YXRpdmUgdG9cbiAgICAvLyAqIHRyYW5zYWN0aW9uIGNvbnRyb2xsZXIgZXh0ZXJuYWwgdHJhbnNhY3Rpb25zIGxpc3RcbiAgICBhc3luYyBzdWJtaXRTaWduZWRUcmFuc2FjdGlvbnMoeyB0eFBhcmFtcywgc2lnbmVkVHJhbnNhY3Rpb25zLCBzaWduZWRDYW5jZWxlZFRyYW5zYWN0aW9ucywgfSkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLlNVQk1JVF9UUkFOU0FDVElPTlMsIGNoYWluSWQpLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByYXdUeHM6IHNpZ25lZFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICByYXdDYW5jZWxUeHM6IHNpZ25lZENhbmNlbGVkVHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgbWV0YW1hc2tOZXR3b3JrSWQgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgbGV0IHByZVR4QmFsYW5jZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByZVR4QmFsYW5jZUJOID0gYXdhaXQgdGhpcy5ldGhlcnNQcm92aWRlci5nZXRCYWxhbmNlKHR4UGFyYW1zID09PSBudWxsIHx8IHR4UGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eFBhcmFtcy5mcm9tKTtcbiAgICAgICAgICAgIHByZVR4QmFsYW5jZSA9IG5ldyBiaWdudW1iZXJfanNfMS5CaWdOdW1iZXIocHJlVHhCYWxhbmNlQk4udG9IZXhTdHJpbmcoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdldGhlcnMgZXJyb3InLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub25jZUxvY2sgPSBhd2FpdCB0aGlzLmdldE5vbmNlTG9jayh0eFBhcmFtcyA9PT0gbnVsbCB8fCB0eFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhQYXJhbXMuZnJvbSk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gZXRoZXJzXzEuZXRoZXJzLnV0aWxzLmhleGxpZnkobm9uY2VMb2NrLm5leHROb25jZSk7XG4gICAgICAgIGlmICh0eFBhcmFtcyAmJiAhKHR4UGFyYW1zID09PSBudWxsIHx8IHR4UGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eFBhcmFtcy5ub25jZSkpIHtcbiAgICAgICAgICAgIHR4UGFyYW1zLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBub25jZURldGFpbHMgfSA9IG5vbmNlTG9jaztcbiAgICAgICAgdGhpcy51cGRhdGVTbWFydFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBub25jZURldGFpbHMsXG4gICAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcbiAgICAgICAgICAgIHByZVR4QmFsYW5jZSxcbiAgICAgICAgICAgIHN0YXR1czogdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuUEVORElORyxcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgICAgIHV1aWQ6IGRhdGEudXVpZCxcbiAgICAgICAgICAgIGNhbmNlbGxhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNOZXdTbWFydFRyYW5zYWN0aW9uKGRhdGEudXVpZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgZm9yIGFuIGV4aXN0aW5nIHNtYXJ0IHRyYW5zYWN0aW9uLiBJZiBhbiBTVFggaXMgbm90IGluIHRoZSBsaXN0IGFueW1vcmVcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBiZWNhdXNlIGl0IHdhcyBjYW5jZWxsZWQgYW5kIGEgbmV3IG9uZSB3YXMgc3VibWl0dGVkLCB3aGljaCBkZWxldGVzIHRoZSBmaXJzdCBvbmUpLFxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCB0cnkgdG8gdXBkYXRlIHRoZSBvbGQgb25lLCBiZWNhdXNlIGl0IHdvdWxkIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBtb3N0XG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHJlcXVpcmVkIFNUWCBwYXJhbXMgbWlzc2luZy4gSXQgd291bGQgb25seSBoYXZlIFwidXVpZFwiIGFuZCBcImNhbmNlbGxhYmxlXCIgcGFyYW1zLlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU21hcnRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IGRhdGEudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBleHBvcnRzLkNBTkNFTExBQkxFX0lOVEVSVkFMKTtcbiAgICAgICAgbm9uY2VMb2NrLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvLyAhIFRoaXMgc2hvdWxkIHJldHVybiBpZiB0aGUgY2FuY2VsbGF0aW9uIHdhcyBvbiBjaGFpbiBvciBub3QgKGZvciBub25jZSBtYW5hZ2VtZW50KVxuICAgIC8vICogQWZ0ZXIgdGhpcyBzdWNjZXNzZnVsIGNhbGwgY2xpZW50IG11c3QgdXBkYXRlIG5vbmNlIHJlcHJlc2VudGF0aXZlXG4gICAgLy8gKiBpbiB0cmFuc2FjdGlvbiBjb250cm9sbGVyIGV4dGVybmFsIHRyYW5zYWN0aW9ucyBsaXN0XG4gICAgLy8gISBBc2sgYmFja2VuZCBBUEkgdG8gbWFrZSB0aGlzIGVuZHBvaW50IGEgUE9TVFxuICAgIGFzeW5jIGNhbmNlbFNtYXJ0VHJhbnNhY3Rpb24odXVpZCkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBhd2FpdCB0aGlzLmZldGNoKHV0aWxzXzEuZ2V0QVBJUmVxdWVzdFVSTCh0eXBlc18xLkFQSVR5cGUuQ0FOQ0VMLCBjaGFpbklkKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHV1aWQgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgdXVpZCxcbiAgICAgICAgICAgIHN0YXR1czogdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX1VTRVJfQ0FOQ0VMTEVELFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hMaXZlbmVzcygpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgbGV0IGxpdmVuZXNzID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXRpbHNfMS5nZXRBUElSZXF1ZXN0VVJMKHR5cGVzXzEuQVBJVHlwZS5MSVZFTkVTUywgY2hhaW5JZCkpO1xuICAgICAgICAgICAgbGl2ZW5lc3MgPSBCb29sZWFuKHJlc3BvbnNlLmxhc3RCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcImZldGNoTGl2ZW5lc3NcIiBBUEkgY2FsbCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSksIHsgbGl2ZW5lc3MgfSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGl2ZW5lc3M7XG4gICAgfVxuICAgIGFzeW5jIHNldFN0YXR1c1JlZnJlc2hJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgICAgICBpZiAoaW50ZXJ2YWwgIT09IHRoaXMuY29uZmlnLmludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25zKHsgYWRkcmVzc0Zyb20sIHN0YXR1cywgfSkge1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlLnNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9IHNtYXJ0VHJhbnNhY3Rpb25zID09PSBudWxsIHx8IHNtYXJ0VHJhbnNhY3Rpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbWFydFRyYW5zYWN0aW9uc1tjaGFpbklkXTtcbiAgICAgICAgaWYgKCFjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgfHwgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMuZmlsdGVyKChzdHgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBzdHguc3RhdHVzID09PSBzdGF0dXMgJiYgKChfYSA9IHN0eC50eFBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pID09PSBhZGRyZXNzRnJvbTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmpzLm1hcCIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIwIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCkge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLSA+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTApIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25zdGFudHMgPSBleHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbnZhciBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzEuQ2xpZW50OyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uc3RhbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5FWFRFUk5BTDsgfSB9KTtcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBjcyA9IHJlcXVpcmUoJ2NvaW5zdHJpbmcnKVxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpXG5cbnZhciBNQVNURVJfU0VDUkVUID0gQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JylcbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwXG52YXIgTEVOID0gNzhcblxuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdCwgY2FuIHVzZSBwYWNrYWdlIGBjb2luaW5mb2AgZm9yIG90aGVyc1xudmFyIEJJVENPSU5fVkVSU0lPTlMgPSB7cHJpdmF0ZTogMHgwNDg4QURFNCwgcHVibGljOiAweDA0ODhCMjFFfVxuXG5mdW5jdGlvbiBIREtleSAodmVyc2lvbnMpIHtcbiAgdGhpcy52ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdGhpcy5kZXB0aCA9IDBcbiAgdGhpcy5pbmRleCA9IDBcbiAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgdGhpcy5fcHVibGljS2V5ID0gbnVsbFxuICB0aGlzLmNoYWluQ29kZSA9IG51bGxcbiAgdGhpcy5fZmluZ2VycHJpbnQgPSAwXG4gIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdmaW5nZXJwcmludCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9maW5nZXJwcmludCB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnaWRlbnRpZmllcicsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZGVudGlmaWVyIH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJLZXlIYXNoJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaWRlbnRpZmllciB9IH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwcml2YXRlS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydC5lcXVhbCh2YWx1ZS5sZW5ndGgsIDMyLCAnUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHByaXZhdGUga2V5JylcblxuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSB2YWx1ZVxuICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUodmFsdWUsIHRydWUpXG4gICAgdGhpcy5faWRlbnRpZmllciA9IGhhc2gxNjAodGhpcy5wdWJsaWNLZXkpXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB0aGlzLl9pZGVudGlmaWVyLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCA9PT0gMzMgfHwgdmFsdWUubGVuZ3RoID09PSA2NSwgJ1B1YmxpYyBrZXkgbXVzdCBiZSAzMyBvciA2NSBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHZhbHVlKSA9PT0gdHJ1ZSwgJ0ludmFsaWQgcHVibGljIGtleScpXG5cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydCh2YWx1ZSwgdHJ1ZSkgLy8gZm9yY2UgY29tcHJlc3NlZCBwb2ludFxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUV4dGVuZGVkS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZUtleSkgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wcml2YXRlLCBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMSwgMCksIHRoaXMucHJpdmF0ZUtleV0pKSlcbiAgICBlbHNlIHJldHVybiBudWxsXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJsaWNFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHVibGljS2V5KSlcbiAgfVxufSlcblxuSERLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmIChwYXRoID09PSAnbScgfHwgcGF0aCA9PT0gJ00nIHx8IHBhdGggPT09IFwibSdcIiB8fCBwYXRoID09PSBcIk0nXCIpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSBwYXRoLnNwbGl0KCcvJylcbiAgdmFyIGhka2V5ID0gdGhpc1xuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KGMsICdtJywgJ0ludmFsaWQgcGF0aCcpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaGFyZGVuZWQgPSAoYy5sZW5ndGggPiAxKSAmJiAoY1tjLmxlbmd0aCAtIDFdID09PSBcIidcIilcbiAgICB2YXIgY2hpbGRJbmRleCA9IHBhcnNlSW50KGMsIDEwKSAvLyAmIChIQVJERU5FRF9PRkZTRVQgLSAxKVxuICAgIGFzc2VydChjaGlsZEluZGV4IDwgSEFSREVORURfT0ZGU0VULCAnSW52YWxpZCBpbmRleCcpXG4gICAgaWYgKGhhcmRlbmVkKSBjaGlsZEluZGV4ICs9IEhBUkRFTkVEX09GRlNFVFxuXG4gICAgaGRrZXkgPSBoZGtleS5kZXJpdmVDaGlsZChjaGlsZEluZGV4KVxuICB9KVxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5wcm90b3R5cGUuZGVyaXZlQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIGlzSGFyZGVuZWQgPSBpbmRleCA+PSBIQVJERU5FRF9PRkZTRVRcbiAgdmFyIGluZGV4QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIGluZGV4QnVmZmVyLndyaXRlVUludDMyQkUoaW5kZXgsIDApXG5cbiAgdmFyIGRhdGFcblxuICBpZiAoaXNIYXJkZW5lZCkgeyAvLyBIYXJkZW5lZCBjaGlsZFxuICAgIGFzc2VydCh0aGlzLnByaXZhdGVLZXksICdDb3VsZCBub3QgZGVyaXZlIGhhcmRlbmVkIGNoaWxkIGtleScpXG5cbiAgICB2YXIgcGsgPSB0aGlzLnByaXZhdGVLZXlcbiAgICB2YXIgemIgPSBCdWZmZXIuYWxsb2MoMSwgMClcbiAgICBwayA9IEJ1ZmZlci5jb25jYXQoW3piLCBwa10pXG5cbiAgICAvLyBkYXRhID0gMHgwMCB8fCBzZXIyNTYoa3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3BrLCBpbmRleEJ1ZmZlcl0pXG4gIH0gZWxzZSB7IC8vIE5vcm1hbCBjaGlsZFxuICAgIC8vIGRhdGEgPSBzZXJQKHBvaW50KGtwYXIpKSB8fCBzZXIzMihpbmRleClcbiAgICAvLyAgICAgID0gc2VyUChLcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbdGhpcy5wdWJsaWNLZXksIGluZGV4QnVmZmVyXSlcbiAgfVxuXG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIHRoaXMuY2hhaW5Db2RlKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgdmFyIElMID0gSS5zbGljZSgwLCAzMilcbiAgdmFyIElSID0gSS5zbGljZSgzMilcblxuICB2YXIgaGQgPSBuZXcgSERLZXkodGhpcy52ZXJzaW9ucylcblxuICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgIC8vIGtpID0gcGFyc2UyNTYoSUwpICsga3BhciAobW9kIG4pXG4gICAgdHJ5IHtcbiAgICAgIGhkLnByaXZhdGVLZXkgPSBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHRoaXMucHJpdmF0ZUtleSwgSUwpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChwcml2YXRlS2V5ICsgSUwpID09PSAwXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIGtpID09IDAsIG9uZSBzaG91bGQgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKVxuICAgIH1cbiAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIEtpID0gcG9pbnQocGFyc2UyNTYoSUwpKSArIEtwYXJcbiAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgdHJ5IHtcbiAgICAgIGhkLnB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZCh0aGlzLnB1YmxpY0tleSwgSUwsIHRydWUpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChnKipJTCArIHB1YmxpY0tleSkgaXMgaW5maW5pdHlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEluIGNhc2UgcGFyc2UyNTYoSUwpID49IG4gb3IgS2kgaXMgdGhlIHBvaW50IGF0IGluZmluaXR5LCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSwgaXNIYXJkZW5lZClcbiAgICB9XG4gIH1cblxuICBoZC5jaGFpbkNvZGUgPSBJUlxuICBoZC5kZXB0aCA9IHRoaXMuZGVwdGggKyAxXG4gIGhkLnBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5maW5nZXJwcmludC8vIC5yZWFkVUludDMyQkUoMClcbiAgaGQuaW5kZXggPSBpbmRleFxuXG4gIHJldHVybiBoZFxufVxuXG5IREtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gIHJldHVybiBzZWNwMjU2azEuc2lnbihoYXNoLCB0aGlzLnByaXZhdGVLZXkpLnNpZ25hdHVyZVxufVxuXG5IREtleS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGhhc2gsIHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHRoaXMucHVibGljS2V5KVxufVxuXG5IREtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICB4cHViOiB0aGlzLnB1YmxpY0V4dGVuZGVkS2V5XG4gIH1cbn1cblxuSERLZXkuZnJvbU1hc3RlclNlZWQgPSBmdW5jdGlvbiAoc2VlZEJ1ZmZlciwgdmVyc2lvbnMpIHtcbiAgdmFyIEkgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgTUFTVEVSX1NFQ1JFVCkudXBkYXRlKHNlZWRCdWZmZXIpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuICBoZGtleS5jaGFpbkNvZGUgPSBJUlxuICBoZGtleS5wcml2YXRlS2V5ID0gSUxcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKGJhc2U1OGtleSwgdmVyc2lvbnMpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuXG4gIHZhciBrZXlCdWZmZXIgPSBjcy5kZWNvZGUoYmFzZTU4a2V5KVxuXG4gIHZhciB2ZXJzaW9uID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHJpdmF0ZSB8fCB2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlIG9yIHB1YmxpYycpXG5cbiAgaGRrZXkuZGVwdGggPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDQpXG4gIGhka2V5LnBhcmVudEZpbmdlcnByaW50ID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSg1KVxuICBoZGtleS5pbmRleCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoOSlcbiAgaGRrZXkuY2hhaW5Db2RlID0ga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSlcblxuICB2YXIga2V5ID0ga2V5QnVmZmVyLnNsaWNlKDQ1KVxuICBpZiAoa2V5LnJlYWRVSW50OCgwKSA9PT0gMCkgeyAvLyBwcml2YXRlXG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHByaXZhdGUnKVxuICAgIGhka2V5LnByaXZhdGVLZXkgPSBrZXkuc2xpY2UoMSkgLy8gY3V0IG9mZiBmaXJzdCAweDAgYnl0ZVxuICB9IGVsc2Uge1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHB1YmxpYycpXG4gICAgaGRrZXkucHVibGljS2V5ID0ga2V5XG4gIH1cblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUpTT04gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBIREtleS5mcm9tRXh0ZW5kZWRLZXkob2JqLnhwcml2KVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGhka2V5LCB2ZXJzaW9uLCBrZXkpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKExFTilcblxuICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKVxuICBidWZmZXIud3JpdGVVSW50OChoZGtleS5kZXB0aCwgNClcblxuICB2YXIgZmluZ2VycHJpbnQgPSBoZGtleS5kZXB0aCA/IGhka2V5LnBhcmVudEZpbmdlcnByaW50IDogMHgwMDAwMDAwMFxuICBidWZmZXIud3JpdGVVSW50MzJCRShmaW5nZXJwcmludCwgNSlcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoaGRrZXkuaW5kZXgsIDkpXG5cbiAgaGRrZXkuY2hhaW5Db2RlLmNvcHkoYnVmZmVyLCAxMylcbiAga2V5LmNvcHkoYnVmZmVyLCA0NSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGhhc2gxNjAgKGJ1Zikge1xuICB2YXIgc2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKHNoYSkuZGlnZXN0KClcbn1cblxuSERLZXkuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUXG5tb2R1bGUuZXhwb3J0cyA9IEhES2V5XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX2V4cG9ydE5hbWVzID0ge307XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbk9iamVjdC5rZXlzKF9jb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jb25zdGFudHNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfY29uc3RhbnRzW2tleV07XG59KTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vZW52L25vZGVcIik7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHlwZXNba2V5XTtcbn0pO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVHJlem9yQ29ubmVjdCA9IHtcbiAgbWFuaWZlc3Q6IF9ub2RlLm1hbmlmZXN0LFxuICBpbml0OiBfbm9kZS5pbml0LFxuICBnZXRTZXR0aW5nczogX25vZGUuZ2V0U2V0dGluZ3MsXG4gIG9uOiBmdW5jdGlvbiBvbih0eXBlLCBmbikge1xuICAgIF9ub2RlLmV2ZW50RW1pdHRlci5vbih0eXBlLCBmbik7XG4gIH0sXG4gIG9mZjogZnVuY3Rpb24gb2ZmKHR5cGUsIGZuKSB7XG4gICAgX25vZGUuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGZuKTtcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgX25vZGUuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LFxuICB1aVJlc3BvbnNlOiBfbm9kZS51aVJlc3BvbnNlLFxuICAvLyBtZXRob2RzXG4gIGJsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3Rvcnk6IGZ1bmN0aW9uIGJsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3RvcnkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3RvcnknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRDdXJyZW50RmlhdFJhdGVzOiBmdW5jdGlvbiBibG9ja2NoYWluR2V0Q3VycmVudEZpYXRSYXRlcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkdldEN1cnJlbnRGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRGaWF0UmF0ZXNGb3JUaW1lc3RhbXBzOiBmdW5jdGlvbiBibG9ja2NoYWluR2V0RmlhdFJhdGVzRm9yVGltZXN0YW1wcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkdldEZpYXRSYXRlc0ZvclRpbWVzdGFtcHMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5EaXNjb25uZWN0OiBmdW5jdGlvbiBibG9ja2NoYWluRGlzY29ubmVjdChwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkRpc2Nvbm5lY3QnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5Fc3RpbWF0ZUZlZTogZnVuY3Rpb24gYmxvY2tjaGFpbkVzdGltYXRlRmVlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluRXN0aW1hdGVGZWUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnM6IGZ1bmN0aW9uIGJsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TZXRDdXN0b21CYWNrZW5kOiBmdW5jdGlvbiBibG9ja2NoYWluU2V0Q3VzdG9tQmFja2VuZChwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpblNldEN1c3RvbUJhY2tlbmQnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TdWJzY3JpYmU6IGZ1bmN0aW9uIGJsb2NrY2hhaW5TdWJzY3JpYmUocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5TdWJzY3JpYmUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXM6IGZ1bmN0aW9uIGJsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5VbnN1YnNjcmliZTogZnVuY3Rpb24gYmxvY2tjaGFpblVuc3Vic2NyaWJlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluVW5zdWJzY3JpYmUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5VbnN1YnNjcmliZUZpYXRSYXRlczogZnVuY3Rpb24gYmxvY2tjaGFpblVuc3Vic2NyaWJlRmlhdFJhdGVzKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluVW5zdWJzY3JpYmVGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGN1c3RvbU1lc3NhZ2U6IGZ1bmN0aW9uIGN1c3RvbU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jdXN0b21NZXNzYWdlKShwYXJhbXMpO1xuICB9LFxuICByZXF1ZXN0TG9naW46IGZ1bmN0aW9uIHJlcXVlc3RMb2dpbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLnJlcXVlc3RMb2dpbikocGFyYW1zKTtcbiAgfSxcbiAgY2FyZGFub0dldEFkZHJlc3M6IGZ1bmN0aW9uIGNhcmRhbm9HZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjYXJkYW5vR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgY2FyZGFub0dldE5hdGl2ZVNjcmlwdEhhc2g6IGZ1bmN0aW9uIGNhcmRhbm9HZXROYXRpdmVTY3JpcHRIYXNoKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjYXJkYW5vR2V0TmF0aXZlU2NyaXB0SGFzaCdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2FyZGFub0dldFB1YmxpY0tleTogZnVuY3Rpb24gY2FyZGFub0dldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2FyZGFub1NpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gY2FyZGFub1NpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2lwaGVyS2V5VmFsdWU6IGZ1bmN0aW9uIGNpcGhlcktleVZhbHVlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjaXBoZXJLZXlWYWx1ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY29tcG9zZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiBjb21wb3NlVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NvbXBvc2VUcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1HZXRBZGRyZXNzOiBmdW5jdGlvbiBldGhlcmV1bUdldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgZXRoZXJldW1HZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGV0aGVyZXVtR2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bUdldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1TaWduTWVzc2FnZTogZnVuY3Rpb24gZXRoZXJldW1TaWduTWVzc2FnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZXRoZXJldW1TaWduTWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1TaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1TaWduVHlwZWREYXRhOiBmdW5jdGlvbiBldGhlcmV1bVNpZ25UeXBlZERhdGEocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtU2lnblR5cGVkRGF0YSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1WZXJpZnlNZXNzYWdlOiBmdW5jdGlvbiBldGhlcmV1bVZlcmlmeU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtVmVyaWZ5TWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0QWNjb3VudEluZm86IGZ1bmN0aW9uIGdldEFjY291bnRJbmZvKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRBY2NvdW50SW5mbydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0QWRkcmVzczogZnVuY3Rpb24gZ2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgZ2V0RGV2aWNlU3RhdGU6IGZ1bmN0aW9uIGdldERldmljZVN0YXRlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXREZXZpY2VTdGF0ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0RmVhdHVyZXM6IGZ1bmN0aW9uIGdldEZlYXR1cmVzKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRGZWF0dXJlcydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0UHVibGljS2V5OiBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgbGlza0dldEFkZHJlc3M6IGZ1bmN0aW9uIGxpc2tHZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoe1xuICAgICAgbWV0aG9kOiAnbGlza0RlcHJlY2F0ZWQnXG4gICAgfSk7XG4gIH0sXG4gIGxpc2tHZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGxpc2tHZXRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbGlza1NpZ25NZXNzYWdlOiBmdW5jdGlvbiBsaXNrU2lnbk1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbGlza1NpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gbGlza1NpZ25UcmFuc2FjdGlvbigpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKHtcbiAgICAgIG1ldGhvZDogJ2xpc2tEZXByZWNhdGVkJ1xuICAgIH0pO1xuICB9LFxuICBsaXNrVmVyaWZ5TWVzc2FnZTogZnVuY3Rpb24gbGlza1ZlcmlmeU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbmVtR2V0QWRkcmVzczogZnVuY3Rpb24gbmVtR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnbmVtR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgbmVtU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBuZW1TaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ25lbVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcHVzaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiBwdXNoVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3B1c2hUcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmlwcGxlR2V0QWRkcmVzczogZnVuY3Rpb24gcmlwcGxlR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAncmlwcGxlR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgcmlwcGxlU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiByaXBwbGVTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3JpcHBsZVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc2lnbk1lc3NhZ2U6IGZ1bmN0aW9uIHNpZ25NZXNzYWdlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdzaWduTWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc3RlbGxhckdldEFkZHJlc3M6IGZ1bmN0aW9uIHN0ZWxsYXJHZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdzdGVsbGFyR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgc3RlbGxhclNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gc3RlbGxhclNpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnc3RlbGxhclNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdGV6b3NHZXRBZGRyZXNzOiBmdW5jdGlvbiB0ZXpvc0dldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3Rlem9zR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgdGV6b3NHZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIHRlem9zR2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICd0ZXpvc0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdGV6b3NTaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIHRlem9zU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICd0ZXpvc1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZW9zR2V0UHVibGljS2V5OiBmdW5jdGlvbiBlb3NHZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Vvc0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZW9zU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBlb3NTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Vvc1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmluYW5jZUdldEFkZHJlc3M6IGZ1bmN0aW9uIGJpbmFuY2VHZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdiaW5hbmNlR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgYmluYW5jZUdldFB1YmxpY0tleTogZnVuY3Rpb24gYmluYW5jZUdldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmluYW5jZUdldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmluYW5jZVNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gYmluYW5jZVNpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmluYW5jZVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdmVyaWZ5TWVzc2FnZTogZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAndmVyaWZ5TWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVzZXREZXZpY2U6IGZ1bmN0aW9uIHJlc2V0RGV2aWNlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyZXNldERldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgd2lwZURldmljZTogZnVuY3Rpb24gd2lwZURldmljZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnd2lwZURldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYXBwbHlGbGFnczogZnVuY3Rpb24gYXBwbHlGbGFncyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYXBwbHlGbGFncydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYXBwbHlTZXR0aW5nczogZnVuY3Rpb24gYXBwbHlTZXR0aW5ncyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYXBwbHlTZXR0aW5ncydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmFja3VwRGV2aWNlOiBmdW5jdGlvbiBiYWNrdXBEZXZpY2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2JhY2t1cERldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2hhbmdlUGluOiBmdW5jdGlvbiBjaGFuZ2VQaW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NoYW5nZVBpbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZmlybXdhcmVVcGRhdGU6IGZ1bmN0aW9uIGZpcm13YXJlVXBkYXRlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdmaXJtd2FyZVVwZGF0ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVjb3ZlcnlEZXZpY2U6IGZ1bmN0aW9uIHJlY292ZXJ5RGV2aWNlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyZWNvdmVyeURldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0Q29pbkluZm86IGZ1bmN0aW9uIGdldENvaW5JbmZvKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRDb2luSW5mbydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVib290VG9Cb290bG9hZGVyOiBmdW5jdGlvbiByZWJvb3RUb0Jvb3Rsb2FkZXIocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3JlYm9vdFRvQm9vdGxvYWRlcidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZGlzcG9zZTogX25vZGUuZGlzcG9zZSxcbiAgY2FuY2VsOiBfbm9kZS5jYW5jZWwsXG4gIHJlbmRlcldlYlVTQkJ1dHRvbjogX25vZGUucmVuZGVyV2ViVVNCQnV0dG9uLFxuICBkaXNhYmxlV2ViVVNCOiBfbm9kZS5kaXNhYmxlV2ViVVNCXG59O1xudmFyIF9kZWZhdWx0ID0gVHJlem9yQ29ubmVjdDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbnZhciBzaWdVdGlsID0gcmVxdWlyZSgnQG1ldGFtYXNrL2V0aC1zaWctdXRpbCcpOyAvLyBTYW5pdGl6YXRpb24gaXMgdXNlZCBmb3IgVDEgYXMgZXRoLXNpZy11dGlsIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XG5cblxuZnVuY3Rpb24gc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAge1xuICAgICAgICB2YXIgZW50cmllcyA9IE9iamVjdC5rZXlzKGRhdGEpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBbaywgc2FuaXRpemVEYXRhKGRhdGFba10pXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHNhbml0aXplRGF0YSh2KTtcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnW29iamVjdCBCaWdJbnRdJzpcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxudmFyIHRyYW5zZm9ybVR5cGVkRGF0YSA9IGZ1bmN0aW9uIHRyYW5zZm9ybVR5cGVkRGF0YShkYXRhLCBtZXRhbWFza192NF9jb21wYXQpIHtcbiAgaWYgKCFtZXRhbWFza192NF9jb21wYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyZXpvcjogT25seSB2ZXJzaW9uIDQgb2YgdHlwZWQgZGF0YSBzaWduaW5nIGlzIHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBzaWdVdGlsLlNpZ25UeXBlZERhdGFWZXJzaW9uLlY0O1xuXG4gIHZhciBfc2lnVXRpbCRUeXBlZERhdGFVdGkgPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLnNhbml0aXplRGF0YShkYXRhKSxcbiAgICAgIHR5cGVzID0gX3NpZ1V0aWwkVHlwZWREYXRhVXRpLnR5cGVzLFxuICAgICAgcHJpbWFyeVR5cGUgPSBfc2lnVXRpbCRUeXBlZERhdGFVdGkucHJpbWFyeVR5cGUsXG4gICAgICBkb21haW4gPSBfc2lnVXRpbCRUeXBlZERhdGFVdGkuZG9tYWluLFxuICAgICAgbWVzc2FnZSA9IF9zaWdVdGlsJFR5cGVkRGF0YVV0aS5tZXNzYWdlO1xuXG4gIHZhciBkb21haW5TZXBhcmF0b3JIYXNoID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZURhdGEoZG9tYWluKSwgdHlwZXMsIHZlcnNpb24pLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIG1lc3NhZ2VIYXNoID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KHByaW1hcnlUeXBlLCBzYW5pdGl6ZURhdGEobWVzc2FnZSksIHR5cGVzLCB2ZXJzaW9uKS50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICBkb21haW5fc2VwYXJhdG9yX2hhc2g6IGRvbWFpblNlcGFyYXRvckhhc2gsXG4gICAgbWVzc2FnZV9oYXNoOiBtZXNzYWdlSGFzaFxuICB9LCBkYXRhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtVHlwZWREYXRhOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmRvd21lbnRQZXJtaXNzaW9uQnVpbGRlcnMgPSBleHBvcnRzLnBlcm1pc3Npb25ScGNNZXRob2RzID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NhdmVhdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGVybWlzc2lvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGVybWlzc2lvbkNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIFRPRE86IE1vdmUgdGhlc2UgdG8gdGhlIGFwcHJvcHJpYXRlIHBhY2thZ2VcbmV4cG9ydHMucGVybWlzc2lvblJwY01ldGhvZHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcnBjLW1ldGhvZHNcIikpO1xudmFyIGVuZG93bWVudHNfMSA9IHJlcXVpcmUoXCIuL2VuZG93bWVudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmRvd21lbnRQZXJtaXNzaW9uQnVpbGRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZG93bWVudHNfMS5lbmRvd21lbnRQZXJtaXNzaW9uQnVpbGRlcnM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NuYXBDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uLXNjaGVtYXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQWJzdHJhY3RFeGVjdXRpb25TZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FeGVjdXRpb25TZXJ2aWNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9XZWJXb3JrZXJFeGVjdXRpb25TZXJ2aWNlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcGVybWlzc2lvblJwY01ldGhvZHMgfSBmcm9tICdAbWV0YW1hc2svc25hcC1jb250cm9sbGVycyc7XG5pbXBvcnQgeyBzZWxlY3RIb29rcyB9IGZyb20gJ0BtZXRhbWFzay9ycGMtbWV0aG9kcyc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBVTlNVUFBPUlRFRF9SUENfTUVUSE9EUyB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQgbG9jYWxIYW5kbGVycyBmcm9tICcuL2hhbmRsZXJzJztcblxuY29uc3QgYWxsSGFuZGxlcnMgPSBbLi4ubG9jYWxIYW5kbGVycywgLi4ucGVybWlzc2lvblJwY01ldGhvZHMuaGFuZGxlcnNdO1xuXG5jb25zdCBoYW5kbGVyTWFwID0gYWxsSGFuZGxlcnMucmVkdWNlKChtYXAsIGhhbmRsZXIpID0+IHtcbiAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIGhhbmRsZXIubWV0aG9kTmFtZXMpIHtcbiAgICBtYXAuc2V0KG1ldGhvZE5hbWUsIGhhbmRsZXIpO1xuICB9XG4gIHJldHVybiBtYXA7XG59LCBuZXcgTWFwKCkpO1xuXG5jb25zdCBleHBlY3RlZEhvb2tOYW1lcyA9IEFycmF5LmZyb20oXG4gIG5ldyBTZXQoXG4gICAgZmxhdHRlbihhbGxIYW5kbGVycy5tYXAoKHsgaG9va05hbWVzIH0pID0+IE9iamVjdC5rZXlzKGhvb2tOYW1lcykpKSxcbiAgKS52YWx1ZXMoKSxcbik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIG9mIFJQQyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIEhhbmRsZXJzIGNvbnN1bWUgZnVuY3Rpb25zIHRoYXQgaG9vayBpbnRvIHRoZSBiYWNrZ3JvdW5kLCBhbmQgb25seSBkZXBlbmRcbiAqIG9uIHRoZWlyIHNpZ25hdHVyZXMsIG5vdCBlLmcuIGNvbnRyb2xsZXIgaW50ZXJuYWxzLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGhvb2tzIC0gUmVxdWlyZWQgXCJob29rc1wiIGludG8gb3VyXG4gKiBjb250cm9sbGVycy5cbiAqIEByZXR1cm5zIHsocmVxOiBPYmplY3QsIHJlczogT2JqZWN0LCBuZXh0OiBGdW5jdGlvbiwgZW5kOiBGdW5jdGlvbikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoaG9va3MpIHtcbiAgLy8gRmFpbCBpbW1lZGlhdGVseSBpZiB3ZSBmb3Jnb3QgdG8gcHJvdmlkZSBhbnkgZXhwZWN0ZWQgaG9va3MuXG4gIGNvbnN0IG1pc3NpbmdIb29rTmFtZXMgPSBleHBlY3RlZEhvb2tOYW1lcy5maWx0ZXIoXG4gICAgKGhvb2tOYW1lKSA9PiAhT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoaG9va3MsIGhvb2tOYW1lKSxcbiAgKTtcbiAgaWYgKG1pc3NpbmdIb29rTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNaXNzaW5nIGV4cGVjdGVkIGhvb2tzOlxcblxcbiR7bWlzc2luZ0hvb2tOYW1lcy5qb2luKCdcXG4nKX1cXG5gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gbWV0aG9kTWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgZW5kKSB7XG4gICAgLy8gUmVqZWN0IHVuc3VwcG9ydGVkIG1ldGhvZHMuXG4gICAgaWYgKFVOU1VQUE9SVEVEX1JQQ19NRVRIT0RTLmhhcyhyZXEubWV0aG9kKSkge1xuICAgICAgcmV0dXJuIGVuZChldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlck1hcC5nZXQocmVxLm1ldGhvZCk7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgaW1wbGVtZW50YXRpb24sIGhvb2tOYW1lcyB9ID0gaGFuZGxlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEltcGxlbWVudGF0aW9ucyBtYXkgb3IgbWF5IG5vdCBiZSBhc3luYywgc28gd2UgbXVzdCBhd2FpdCB0aGVtLlxuICAgICAgICByZXR1cm4gYXdhaXQgaW1wbGVtZW50YXRpb24oXG4gICAgICAgICAgcmVxLFxuICAgICAgICAgIHJlcyxcbiAgICAgICAgICBuZXh0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBzZWxlY3RIb29rcyhob29rcywgaG9va05hbWVzKSxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9O1xufVxuXG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZSx0PXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nXCIpLHM9cmVxdWlyZShcImV2ZW50c1wiKSxuPXJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpLGk9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aFwiKSxyPXJlcXVpcmUoXCJ1dWlkXCIpLGM9cmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpLG89KGU9cmVxdWlyZShcInJscFwiKSkmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmU7Y2xhc3MgYSBleHRlbmRzIHMuRXZlbnRFbWl0dGVye2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoKSx0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudD0oKT0+bmV3IFByb21pc2UoKGUsdCk9Pnt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzeW5jOntyZWFkaW5nOiEwfX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKHQsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLGUocyl9KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20odCxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksZShzKX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiLCgpPT57dGhpcy5yZXNldFN0YXRlKCksdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSl9KX0pLHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLGUpfSx0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQ9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsZSl9LHRoaXMuY2FuY2VsU3luYz0oKT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpfSx0aGlzLnJlcXVlc3RTaWduYXR1cmU9KGUsdCxzKT0+bmV3IFByb21pc2UoKG4sYyk9Pntjb25zdCBvPWUudG9VUigpLGE9ZS5nZXRSZXF1ZXN0SWQoKSxoPXIuc3RyaW5naWZ5KGEpLHU9e3JlcXVlc3RJZDpoLHBheWxvYWQ6e3R5cGU6by50eXBlLGNib3I6by5jYm9yLnRvU3RyaW5nKFwiaGV4XCIpfSx0aXRsZTp0LGRlc2NyaXB0aW9uOnN9O3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e3JlcXVlc3Q6dX19KSx0aGlzLm9uY2UoaCtcIi1zaWduZWRcIixlPT57Y29uc3QgdD1pLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShlLFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxuKHQpfSksdGhpcy5vbmNlKGgrXCItY2FuY2VsZWRcIiwoKT0+e3RoaXMucmVzZXRTdGF0ZSgpLGMobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKX0pfSksdGhpcy5zdWJtaXRTaWduYXR1cmU9KGUsdCk9Pnt0aGlzLmVtaXQoZStcIi1zaWduZWRcIix0KX0sdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlPSgpPT57Y29uc3QgZT10aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O2lmKGUpe2NvbnN0e3JlcXVlc3RJZDp0fT1lO3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e319KSx0aGlzLmVtaXQodCtcIi1jYW5jZWxlZFwiKX19LHRoaXMucmVzZXRTdGF0ZT0oKT0+e3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3N5bmM6e3JlYWRpbmc6ITF9LHNpZ246e319KX0sYS5pbnN0YW5jZSlyZXR1cm4gYS5pbnN0YW5jZTt0aGlzLm1lbVN0b3JlPW5ldyBuLk9ic2VydmFibGVTdG9yZSh7c3luYzp7cmVhZGluZzohMX0sc2lnbjp7fSxfdmVyc2lvbjoxfSksYS5pbnN0YW5jZT10aGlzfX1jbGFzcyBoIGV4dGVuZHMgdC5CYXNlS2V5cmluZ3tjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmdldEludGVyYWN0aW9uPSgpPT5uZXcgYSx0aGlzLmdldE1lbVN0b3JlPSgpPT50aGlzLmdldEludGVyYWN0aW9uKCkubWVtU3RvcmUsdGhpcy5yZW1vdmVBY2NvdW50PWU9PntpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9LHRoaXMuZm9yZ2V0RGV2aWNlPSgpPT57dGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmluaXRpYWxpemVkPSExLHRoaXMueGZwPVwiXCIsdGhpcy54cHViPVwiXCIsdGhpcy5oZFBhdGg9XCJcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5oZGs9dm9pZCAwLHRoaXMucGF0aHM9e319LHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0hES2V5LHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudD10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudCx0aGlzLnN1Ym1pdFNpZ25hdHVyZT10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlLHRoaXMuY2FuY2VsU3luYz10aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsU3luYyx0aGlzLmNhbmNlbFNpZ25SZXF1ZXN0PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlLGguaW5zdGFuY2UpcmV0dXJuIGguaW5zdGFuY2UuZGVzZXJpYWxpemUoZSksaC5pbnN0YW5jZTtoLmluc3RhbmNlPXRoaXN9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcz0wPT09dC50eXBlP2kuRGF0YVR5cGUudHJhbnNhY3Rpb246aS5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBuO249MD09PXQudHlwZT9vLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKTp0LmdldE1lc3NhZ2VUb1NpZ24oITEpO2NvbnN0IGE9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLGg9dC5jb21tb24uY2hhaW5JZCgpLHU9ci52NCgpLHk9aS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG4scyxhLHRoaXMueGZwLHUsaCkse3I6ZyxzOm0sdjpkfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUodSx5LFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJykscD10LnRvSlNPTigpO3JldHVybiBwLnY9ZCxwLnM9bSxwLnI9ZyxwLnR5cGU9dC50eXBlLGMuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEocCx7Y29tbW9uOnQuY29tbW9ufSl9fWgudHlwZT10LkJhc2VLZXlyaW5nLnR5cGUsZXhwb3J0cy5NZXRhTWFza0tleXJpbmc9aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBiYXNlRXRoS2V5cmluZyA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciBvYnNTdG9yZSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9vYnMtc3RvcmUnKTtcbnZhciBiY1VyUmVnaXN0cnlFdGggPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIHR4ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKTtcbnZhciBybHAgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmxwJykpO1xuXG5jbGFzcyBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc3luYzoge1xuICAgICAgICAgICAgcmVhZGluZzogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2tleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleScsIGNib3IgPT4ge1xuICAgICAgICAgIGNvbnN0IGNyeXB0b0hES2V5ID0gYmNVclJlZ2lzdHJ5RXRoLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsICdoZXgnKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShjcnlwdG9IREtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudCcsIGNib3IgPT4ge1xuICAgICAgICAgIGNvbnN0IGNyeXB0b0FjY291bnQgPSBiY1VyUmVnaXN0cnlFdGguQ3J5cHRvQWNjb3VudC5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCAnaGV4JykpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoY3J5cHRvQWNjb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdrZXlzdG9uZS1zeW5jX2NhbmNlbCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeScpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9IREtleSA9IGNib3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXknLCBjYm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50ID0gY2JvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2tleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50JywgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsU3luYyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgna2V5c3RvbmUtc3luY19jYW5jZWwnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlID0gKHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdXIgPSBzaWduUmVxdWVzdC50b1VSKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZEJ1ZmZlciA9IHNpZ25SZXF1ZXN0LmdldFJlcXVlc3RJZCgpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnN0cmluZ2lmeShyZXF1ZXN0SWRCdWZmZXIpO1xuICAgICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgdHlwZTogdXIudHlwZSxcbiAgICAgICAgICAgIGNib3I6IHVyLmNib3IudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZTogcmVxdWVzdFRpdGxlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXF1ZXN0RGVzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc2lnbjoge1xuICAgICAgICAgICAgcmVxdWVzdDogc2lnblBheWxvYWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2UoYCR7cmVxdWVzdElkfS1zaWduZWRgLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBldGhTaWduYXR1cmUgPSBiY1VyUmVnaXN0cnlFdGguRVRIU2lnbmF0dXJlLmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsICdoZXgnKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShldGhTaWduYXR1cmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5JykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdFNpZ25hdHVyZSA9IChyZXF1ZXN0SWQsIGNib3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChgJHtyZXF1ZXN0SWR9LXNpZ25lZGAsIGNib3IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbFJlcXVlc3RTaWduYXR1cmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7XG5cbiAgICAgIGlmIChzaWduUGF5bG9hZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0gPSBzaWduUGF5bG9hZDtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc2lnbjoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChgJHtyZXF1ZXN0SWR9LWNhbmNlbGVkYCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICBzeW5jOiB7XG4gICAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbjoge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlO1xuICAgIH1cblxuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgb2JzU3RvcmUuT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN5bmM6IHtcbiAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzaWduOiB7fSxcbiAgICAgIF92ZXJzaW9uOiAxXG4gICAgfSk7XG4gICAgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlID0gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIE1ldGFNYXNrS2V5cmluZyBleHRlbmRzIGJhc2VFdGhLZXlyaW5nLkJhc2VLZXlyaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TWVtU3RvcmUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmFjdGlvbigpLm1lbVN0b3JlO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUFjY291bnQgPSBhZGRyZXNzID0+IHtcbiAgICAgIGlmICghdGhpcy5hY2NvdW50cy5tYXAoYSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoYSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuZm9yZ2V0RGV2aWNlID0gKCkgPT4ge1xuICAgICAgLy9jb21tb24gcHJvcHNcbiAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50QWNjb3VudCA9IDA7XG4gICAgICB0aGlzLm5hbWUgPSAnUVIgSGFyZHdhcmUnO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhmcCA9ICcnO1xuICAgICAgdGhpcy54cHViID0gJyc7XG4gICAgICB0aGlzLmhkUGF0aCA9ICcnO1xuICAgICAgdGhpcy5pbmRleGVzID0ge307XG4gICAgICB0aGlzLmhkayA9IHVuZGVmaW5lZDsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICAgIHRoaXMucGF0aHMgPSB7fTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9IREtleSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9IREtleTtcbiAgICB0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudDtcbiAgICB0aGlzLnN1Ym1pdFNpZ25hdHVyZSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRTaWduYXR1cmU7XG4gICAgdGhpcy5jYW5jZWxTeW5jID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFN5bmM7XG4gICAgdGhpcy5jYW5jZWxTaWduUmVxdWVzdCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlO1xuXG4gICAgaWYgKE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZSkge1xuICAgICAgTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlLmRlc2VyaWFsaXplKG9wdHMpO1xuICAgICAgcmV0dXJuIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4JDEpIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHR4JDEudHlwZSA9PT0gMCA/IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50cmFuc2FjdGlvbiA6IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO1xuICAgIGxldCBtZXNzYWdlVG9TaWduO1xuXG4gICAgaWYgKHR4JDEudHlwZSA9PT0gMCkge1xuICAgICAgbWVzc2FnZVRvU2lnbiA9IHJscC5lbmNvZGUodHgkMS5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gdHgkMS5jb21tb24uY2hhaW5JZCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG1lc3NhZ2VUb1NpZ24sIGRhdGFUeXBlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIGNoYWluSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgJ1NjYW4gd2l0aCB5b3VyIEtleXN0b25lJywgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIGNvbnN0IHR4SnNvbiA9IHR4JDEudG9KU09OKCk7XG4gICAgdHhKc29uLnYgPSB2O1xuICAgIHR4SnNvbi5zID0gcztcbiAgICB0eEpzb24uciA9IHI7XG4gICAgdHhKc29uLnR5cGUgPSB0eCQxLnR5cGU7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0eC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eEpzb24sIHtcbiAgICAgIGNvbW1vbjogdHgkMS5jb21tb25cbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxufVxuTWV0YU1hc2tLZXlyaW5nLnR5cGUgPSBiYXNlRXRoS2V5cmluZy5CYXNlS2V5cmluZy50eXBlO1xuXG5leHBvcnRzLk1ldGFNYXNrS2V5cmluZyA9IE1ldGFNYXNrS2V5cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsImZ1bmN0aW9uIGRlbGF5KHRpbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEZyb21Nb2NrM0JveChrZXkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93LmZldGNoKGBodHRwOi8vbG9jYWxob3N0Ojg4ODk/a2V5PSR7a2V5fWApO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgcmV0dXJuIHRleHQubGVuZ3RoID8gSlNPTi5wYXJzZSh0ZXh0KSA6IG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhdmVUb01vY2szQm94KGtleSwgbmV3RGF0YUF0S2V5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHdpbmRvdy5mZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4ODg5Jywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGtleSxcbiAgICAgIGRhdGE6IG5ld0RhdGFBdEtleSxcbiAgICB9KSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcy50ZXh0KCk7XG59XG5cbmNsYXNzIE1vY2szQm94IHtcbiAgc3RhdGljIG9wZW5Cb3goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBvblN5bmNEb25lOiAoY2IpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMjAwKTtcbiAgICAgIH0sXG4gICAgICBvcGVuU3BhY2U6IGFzeW5jIChzcGFjZU5hbWUsIGNvbmZpZykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uU3luY0RvbmUgfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zcGFjZU5hbWUgPSBzcGFjZU5hbWU7XG5cbiAgICAgICAgc2V0VGltZW91dChvblN5bmNEb25lLCAxNTApO1xuXG4gICAgICAgIGF3YWl0IGRlbGF5KDUwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByaXZhdGU6IHtcbiAgICAgICAgICAgIGdldDogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGxvYWRGcm9tTW9jazNCb3goXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5hZGRyZXNzfS0ke3RoaXMuc3BhY2VOYW1lfS0ke2tleX1gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogYXN5bmMgKGtleSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBzYXZlVG9Nb2NrM0JveChcbiAgICAgICAgICAgICAgICBgJHt0aGlzLmFkZHJlc3N9LSR7dGhpcy5zcGFjZU5hbWV9LSR7a2V5fWAsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoNTApO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsb2dvdXQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRDb25maWcoYWRkcmVzcykge1xuICAgIGNvbnN0IGJhY2t1cCA9IGF3YWl0IGxvYWRGcm9tTW9jazNCb3goYCR7YWRkcmVzc30tbWV0YW1hc2stbWV0YW1hc2tCYWNrdXBgKTtcbiAgICByZXR1cm4gYmFja3VwID8geyBzcGFjZXM6IHsgbWV0YW1hc2s6IHt9IH0gfSA6IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9jazNCb3g7XG4iLCJpbXBvcnQgeyBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIG1lcmdlTWlkZGxld2FyZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGVuZGluZ05vbmNlTWlkZGxld2FyZSxcbiAgY3JlYXRlUGVuZGluZ1R4TWlkZGxld2FyZSxcbn0gZnJvbSAnLi9taWRkbGV3YXJlL3BlbmRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUoe1xuICB2ZXJzaW9uLFxuICBnZXRBY2NvdW50cyxcbiAgcHJvY2Vzc1RyYW5zYWN0aW9uLFxuICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsXG4gIHByb2Nlc3NUeXBlZE1lc3NhZ2UsXG4gIHByb2Nlc3NUeXBlZE1lc3NhZ2VWMyxcbiAgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LFxuICBwcm9jZXNzUGVyc29uYWxNZXNzYWdlLFxuICBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UsXG4gIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LFxuICBnZXRQZW5kaW5nTm9uY2UsXG4gIGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaCxcbn0pIHtcbiAgY29uc3QgbWV0YW1hc2tNaWRkbGV3YXJlID0gbWVyZ2VNaWRkbGV3YXJlKFtcbiAgICBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgICAgZXRoX3N5bmNpbmc6IGZhbHNlLFxuICAgICAgd2ViM19jbGllbnRWZXJzaW9uOiBgTWV0YU1hc2svdiR7dmVyc2lvbn1gLFxuICAgIH0pLFxuICAgIGNyZWF0ZVdhbGxldE1pZGRsZXdhcmUoe1xuICAgICAgZ2V0QWNjb3VudHMsXG4gICAgICBwcm9jZXNzVHJhbnNhY3Rpb24sXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LFxuICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSxcbiAgICAgIHByb2Nlc3NEZWNyeXB0TWVzc2FnZSxcbiAgICAgIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LFxuICAgIH0pLFxuICAgIGNyZWF0ZVBlbmRpbmdOb25jZU1pZGRsZXdhcmUoeyBnZXRQZW5kaW5nTm9uY2UgfSksXG4gICAgY3JlYXRlUGVuZGluZ1R4TWlkZGxld2FyZSh7IGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaCB9KSxcbiAgXSk7XG4gIHJldHVybiBtZXRhbWFza01pZGRsZXdhcmU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIikpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBsb2NhbHN0b3JhZ2UgPSByZXF1aXJlKCdzdG9yZScpO1xuXG52YXIgSVBGUyA9IHJlcXVpcmUoJ2lwZnMnKTtcblxudmFyIE9yYml0REIgPSByZXF1aXJlKCdvcmJpdC1kYicpO1xuXG52YXIgUHVic3ViID0gcmVxdWlyZSgnb3JiaXQtZGItcHVic3ViJyk7IC8vIGNvbnN0IE9yYml0REJDYWNoZVByb3h5ID0gcmVxdWlyZSgnb3JiaXQtZGItY2FjaGUtcG9zdG1zZy1wcm94eScpLkNsaWVudFxuLy8gY29uc3QgeyBjcmVhdGVQcm94eUNsaWVudCB9ID0gcmVxdWlyZSgnaXBmcy1wb3N0bXNnLXByb3h5JylcblxuXG52YXIgQWNjZXNzQ29udHJvbGxlcnMgPSByZXF1aXJlKCdvcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnM2JveC1vcmJpdGRiLXBsdWdpbnMnKSxcbiAgICBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIgPSBfcmVxdWlyZS5MZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIsXG4gICAgVGhyZWFkQWNjZXNzQ29udHJvbGxlciA9IF9yZXF1aXJlLlRocmVhZEFjY2Vzc0NvbnRyb2xsZXIsXG4gICAgTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlciA9IF9yZXF1aXJlLk1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXI7XG5cbkFjY2Vzc0NvbnRyb2xsZXJzLmFkZEFjY2Vzc0NvbnRyb2xsZXIoe1xuICBBY2Nlc3NDb250cm9sbGVyOiBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuQWNjZXNzQ29udHJvbGxlcnMuYWRkQWNjZXNzQ29udHJvbGxlcih7XG4gIEFjY2Vzc0NvbnRyb2xsZXI6IFRocmVhZEFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuQWNjZXNzQ29udHJvbGxlcnMuYWRkQWNjZXNzQ29udHJvbGxlcih7XG4gIEFjY2Vzc0NvbnRyb2xsZXI6IE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuXG52YXIgVGhyZWVJZCA9IHJlcXVpcmUoJy4vM2lkJyk7XG5cbnZhciBQdWJsaWNTdG9yZSA9IHJlcXVpcmUoJy4vcHVibGljU3RvcmUnKTtcblxudmFyIFByaXZhdGVTdG9yZSA9IHJlcXVpcmUoJy4vcHJpdmF0ZVN0b3JlJyk7XG5cbnZhciBWZXJpZmllZCA9IHJlcXVpcmUoJy4vdmVyaWZpZWQnKTtcblxudmFyIFNwYWNlID0gcmVxdWlyZSgnLi9zcGFjZScpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBpZFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZCcpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcuanMnKTtcblxudmFyIEFQSSA9IHJlcXVpcmUoJy4vYXBpJyk7XG5cbnZhciBBQ0NPVU5UX1RZUEVTID0ge1xuICBldGhlcmV1bTogJ2V0aGVyZXVtJyxcbiAgZXRoZXJldW1FT0E6ICdldGhlcmV1bS1lb2EnXG59O1xudmFyIEFERFJFU1NfU0VSVkVSX1VSTCA9IGNvbmZpZy5hZGRyZXNzX3NlcnZlcl91cmw7XG52YXIgUElOTklOR19OT0RFID0gY29uZmlnLnBpbm5pbmdfbm9kZTtcbnZhciBQSU5OSU5HX1JPT00gPSBjb25maWcucGlubmluZ19yb29tOyAvLyBjb25zdCBJRlJBTUVfU1RPUkVfVkVSU0lPTiA9ICcwLjAuMydcbi8vIGNvbnN0IElGUkFNRV9TVE9SRV9VUkwgPSBgaHR0cHM6Ly9pZnJhbWUuM2JveC5pby8ke0lGUkFNRV9TVE9SRV9WRVJTSU9OfS9pZnJhbWUuaHRtbGBcblxudmFyIElQRlNfT1BUSU9OUyA9IGNvbmZpZy5pcGZzX29wdGlvbnM7XG52YXIgT1JCSVREQl9PUFRTID0gY29uZmlnLm9yYml0ZGJfb3B0aW9ucztcbnZhciBnbG9iYWxJUEZTLCBnbG9iYWxPcmJpdERCOyAvLyAsIGlwZnNQcm94eSwgY2FjaGVQcm94eSwgaWZyYW1lTG9hZGVkUHJvbWlzZVxuXG4vKlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgaWZyYW1lLnNyYyA9IElGUkFNRV9TVE9SRV9VUkxcbiAgaWZyYW1lLnN0eWxlID0gJ3dpZHRoOjA7IGhlaWdodDowOyBib3JkZXI6MDsgYm9yZGVyOm5vbmUgIWltcG9ydGFudCdcblxuICBpZnJhbWVMb2FkZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoKSB9XG4gIH0pXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG4gIC8vIENyZWF0ZSBwcm94eSBjbGllbnRzIHRoYXQgdGFsa3MgdG8gdGhlIGlmcmFtZVxuICBjb25zdCBwb3N0TWVzc2FnZSA9IGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlLmJpbmQoaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gIGlwZnNQcm94eSA9IGNyZWF0ZVByb3h5Q2xpZW50KHsgcG9zdE1lc3NhZ2UgfSlcbiAgY2FjaGVQcm94eSA9IE9yYml0REJDYWNoZVByb3h5KHsgcG9zdE1lc3NhZ2UgfSlcbn0gKi9cblxudmFyIEJveCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBQbGVhc2UgdXNlIHRoZSAqKm9wZW5Cb3gqKiBtZXRob2QgdG8gaW5zdGFudGlhdGUgYSAzQm94XG4gICAqL1xuICBmdW5jdGlvbiBCb3godGhyZWVJZCwgZXRoZXJldW1Qcm92aWRlciwgaXBmcykge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJveCk7XG4gICAgdGhpcy5fM2lkID0gdGhyZWVJZDtcbiAgICB0aGlzLl93ZWIzcHJvdmlkZXIgPSBldGhlcmV1bVByb3ZpZGVyO1xuICAgIHRoaXMuX2lwZnMgPSBpcGZzO1xuICAgIHRoaXMuX3NlcnZlclVybCA9IG9wdHMuYWRkcmVzc1NlcnZlciB8fCBBRERSRVNTX1NFUlZFUl9VUkw7XG5cbiAgICB0aGlzLl9vblN5bmNEb25lQ0IgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuX2JveFN5bmNlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7S2V5VmFsdWVTdG9yZX0gcHVibGljICAgICAgICAgYWNjZXNzIHRoZSBwcm9maWxlIHN0b3JlIG9mIHRoZSB1c2VycyAzQm94XG4gICAgICovXG5cbiAgICB0aGlzW1wicHVibGljXCJdID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0tleVZhbHVlU3RvcmV9IHByaXZhdGUgICAgICAgIGFjY2VzcyB0aGUgcHJpdmF0ZSBzdG9yZSBvZiB0aGUgdXNlcnMgM0JveFxuICAgICAqL1xuXG4gICAgdGhpc1tcInByaXZhdGVcIl0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVyaWZpZWR9IHZlcmlmaWVkICAgICAgICBjaGVjayBhbmQgY3JlYXRlIHZlcmlmaWNhdGlvbnNcbiAgICAgKi9cblxuICAgIHRoaXMudmVyaWZpZWQgPSBuZXcgVmVyaWZpZWQodGhpcyk7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNwYWNlcyAgICAgICAgICAgIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvcGVuIHNwYWNlcyBpbmRleGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG5cbiAgICB0aGlzLnNwYWNlcyA9IHt9OyAvLyBsb2NhbCBzdG9yZSBvZiBhbGwgcGlubmluZyBzZXJ2ZXIgcHVic3ViIG1lc3NhZ2VzIHNlZW4gcmVsYXRlZCB0byBzcGFjZXNcblxuICAgIHRoaXMuc3BhY2VzUHViU3ViTWVzc2FnZXMgPSB7fTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm94LCBbe1xuICAgIGtleTogXCJfbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgcm9vdFN0b3JlTmFtZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJvb3RTdG9yZUFkZHJlc3MsXG4gICAgICAgICAgICBvbk5ld1BlZXIsXG4gICAgICAgICAgICBfcmVmMixcbiAgICAgICAgICAgIF9yZWYzLFxuICAgICAgICAgICAgcHViU3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgcHJpdlN0b3JlQWRkcmVzcyxcbiAgICAgICAgICAgIHN5bmNQcm9taXNlcyxcbiAgICAgICAgICAgIGhhc1Jlc3BvbnNlLFxuICAgICAgICAgICAgc3BhY2VNZXNzYWdlRmlsdGVyQWN0aXZlLFxuICAgICAgICAgICAgZmlsdGVyVGltZVNldCxcbiAgICAgICAgICAgIG9uTWVzc2FnZVJlcyxcbiAgICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzLmxlbmd0aCA+IDAgJiYgX2FyZ3MzWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczNbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICByb290U3RvcmVOYW1lID0gdGhpcy5fM2lkLm11cG9ydEZpbmdlcnByaW50ICsgJy5yb290JztcbiAgICAgICAgICAgICAgICB0aGlzLnBpbm5pbmdOb2RlID0gb3B0cy5waW5uaW5nTm9kZSB8fCBQSU5OSU5HX05PREU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pcGZzLnN3YXJtLmNvbm5lY3QodGhpcy5waW5uaW5nTm9kZSwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gT3JiaXREQjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDEgPSB0aGlzLl9pcGZzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MiA9IG9wdHMub3JiaXRQYXRoO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fM2lkLmdldE9kYklkKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NCA9IHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogX2NvbnRleHQzLnQyLFxuICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IF9jb250ZXh0My50M1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnQwLmNyZWF0ZUluc3RhbmNlLmNhbGwoX2NvbnRleHQzLnQwLCBfY29udGV4dDMudDEsIF9jb250ZXh0My50NCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmJpdGRiID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgLy8gLCB7IGNhY2hlIH0pXG4gICAgICAgICAgICAgICAgZ2xvYmFsT3JiaXREQiA9IHRoaXMuX29yYml0ZGI7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5fM2lkLmdldEtleXJpbmdCeVNwYWNlTmFtZShyb290U3RvcmVOYW1lKS5nZXRQdWJsaWNLZXlzKHRydWUpLnNpZ25pbmdLZXk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JiaXRkYi5mZWVkKHJvb3RTdG9yZU5hbWUsIF9vYmplY3RTcHJlYWQoe30sIE9SQklUREJfT1BUUywge1xuICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgICAgICAgICAgICAgICAgIGFjY2Vzc0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGU6IFtrZXldLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGVnYWN5LWlwZnMtM2JveCcsXG4gICAgICAgICAgICAgICAgICAgIHNraXBNYW5pZmVzdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RTdG9yZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIHJvb3RTdG9yZUFkZHJlc3MgPSB0aGlzLl9yb290U3RvcmUuYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NSA9IFB1YnN1YjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDYgPSB0aGlzLl9pcGZzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lwZnMuaWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NyA9IF9jb250ZXh0My5zZW50LmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1YiA9IG5ldyBfY29udGV4dDMudDUoX2NvbnRleHQzLnQ2LCBfY29udGV4dDMudDcpO1xuXG4gICAgICAgICAgICAgICAgb25OZXdQZWVyID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0b3BpYywgcGVlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyID09PSBfdGhpcy5waW5uaW5nTm9kZS5zcGxpdCgnLycpLnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHVic3ViLnB1Ymxpc2goUElOTklOR19ST09NLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQSU5fREInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiByb290U3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWQ6IF90aGlzLkRJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTmV3UGVlcihfeDIsIF94Mykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzW1wicHVibGljXCJdID0gbmV3IFB1YmxpY1N0b3JlKHRoaXMuX29yYml0ZGIsIHRoaXMuXzNpZC5tdXBvcnRGaW5nZXJwcmludCArICcucHVibGljJywgdGhpcy5fbGlua1Byb2ZpbGUuYmluZCh0aGlzKSwgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSwgdGhpcy5fM2lkKTtcbiAgICAgICAgICAgICAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IG5ldyBQcml2YXRlU3RvcmUodGhpcy5fb3JiaXRkYiwgdGhpcy5fM2lkLm11cG9ydEZpbmdlcnByaW50ICsgJy5wcml2YXRlJywgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSwgdGhpcy5fM2lkKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDMxO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpc1tcInB1YmxpY1wiXS5fbG9hZCgpLCB0aGlzW1wicHJpdmF0ZVwiXS5fbG9hZCgpXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICBfcmVmMiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIF9yZWYzID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF9yZWYyLCAyKTtcbiAgICAgICAgICAgICAgICBwdWJTdG9yZUFkZHJlc3MgPSBfcmVmM1swXTtcbiAgICAgICAgICAgICAgICBwcml2U3RvcmVBZGRyZXNzID0gX3JlZjNbMV07XG4gICAgICAgICAgICAgICAgc3luY1Byb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgaGFzUmVzcG9uc2UgPSB7fTsgLy8gRmlsdGVycyBhbmQgc3RvcmUgc3BhY2UgcmVsYXRlZCBtZXNzYWdlcyBmb3IgM3NlY3MsIHRoZSBiZXN0IGVmZm9ydFxuICAgICAgICAgICAgICAgIC8vIHNpbXBsZSBhcHByb2FjaCwgdW50aWwgcmVmYWN0b3JcblxuICAgICAgICAgICAgICAgIHNwYWNlTWVzc2FnZUZpbHRlckFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGltZVNldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgb25NZXNzYWdlUmVzID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHRvcGljLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJUaW1lU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUaW1lU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZU1lc3NhZ2VGaWx0ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEudHlwZSA9PT0gJ0hBU19FTlRSSUVTJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5vZGJBZGRyZXNzID09PSBwcml2U3RvcmVBZGRyZXNzICYmICFoYXNSZXNwb25zZVtwcml2U3RvcmVBZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzLnB1c2goX3RoaXNbXCJwcml2YXRlXCJdLl9zeW5jKGRhdGEubnVtRW50cmllcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVzcG9uc2VbcHJpdlN0b3JlQWRkcmVzc10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm9kYkFkZHJlc3MgPT09IHB1YlN0b3JlQWRkcmVzcyAmJiAhaGFzUmVzcG9uc2VbcHViU3RvcmVBZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzLnB1c2goX3RoaXNbXCJwdWJsaWNcIl0uX3N5bmMoZGF0YS5udW1FbnRyaWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSZXNwb25zZVtwdWJTdG9yZUFkZHJlc3NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2VNZXNzYWdlRmlsdGVyQWN0aXZlICYmIGRhdGEub2RiQWRkcmVzcy5pbmNsdWRlcygnc3BhY2UnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3BhY2VzUHViU3ViTWVzc2FnZXNbZGF0YS5vZGJBZGRyZXNzXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3luY1Byb21pc2VzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHN5bmNQcm9taXNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYm94U3luY2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vblN5bmNEb25lQ0IoKTsgLy8gdGhpcy5fcHVic3ViLnVuc3Vic2NyaWJlKFBJTk5JTkdfUk9PTSlcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTWVzc2FnZVJlcyhfeDQsIF94NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVic3ViLnN1YnNjcmliZShQSU5OSU5HX1JPT00sIG9uTWVzc2FnZVJlcywgb25OZXdQZWVyKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVJvb3RTdG9yZShyb290U3RvcmVBZGRyZXNzLCBwcml2U3RvcmVBZGRyZXNzLCBwdWJTdG9yZUFkZHJlc3MsIHRoaXMucGlubmluZ05vZGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2xvYWQoKSB7XG4gICAgICAgIHJldHVybiBfbG9hZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9sb2FkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVSb290U3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVSb290U3RvcmUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHJvb3RTdG9yZUFkZHJlc3MsIHByaXZPZGJBZGRyZXNzLCBwdWJPZGJBZGRyZXNzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbnRyaWVzLCBwaW5BZGRyZXNzTGlua3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLmxvYWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXlsb2FkLnZhbHVlLm9kYkFkZHJlc3MgPT09IHB1Yk9kYkFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLmFkZCh7XG4gICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiBwdWJPZGJBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLnBheWxvYWQudmFsdWUub2RiQWRkcmVzcyA9PT0gcHJpdk9kYkFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIG9kYkFkZHJlc3M6IHByaXZPZGJBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoUm9vdFN0b3JlKHJvb3RTdG9yZUFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgICAgcGluQWRkcmVzc0xpbmtzID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZm9yIGFkZHJlc3MtbGlua3MsIGdldCBDSUQsIGFuZCBnZXQgdG8gcGluIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucGF5bG9hZC52YWx1ZS50eXBlID09PSAnYWRkcmVzcy1saW5rJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuX2lwZnMuZGFnLmdldChlbnRyeS5wYXlsb2FkLnZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTQpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGluQWRkcmVzc0xpbmtzKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgcGluQWRkcmVzc0xpbmtzKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfY3JlYXRlUm9vdFN0b3JlKF94NiwgX3g3LCBfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb290U3RvcmUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY3JlYXRlUm9vdFN0b3JlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIHByb2ZpbGUgb2YgYSBnaXZlbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIG9wdHMuYmxvY2tsaXN0ICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhZGRyZXNzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZXRhZGF0YSAgICAgICAgICAgZmxhZyB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5hZGRyZXNzU2VydmVyICAgICAgVVJMIG9mIHRoZSBBZGRyZXNzIFNlcnZlclxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cy5pcGZzICAgICAgICAgICAgICAgQSBqcy1pcGZzIGlwZnMgb2JqZWN0XG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLnVzZUNhY2hlU2VydmljZSAgICBVc2UgM0JveCBBUEkgYW5kIENhY2hlIFNlcnZpY2UgdG8gZmV0Y2ggcHJvZmlsZSBpbnN0ZWFkIG9mIE9yYml0REIuIERlZmF1bHQgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMucHJvZmlsZVNlcnZlciAgICAgIFVSTCBvZiBQcm9maWxlIEFQSSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEganNvbiBvYmplY3Qgd2l0aCB0aGUgcHJvZmlsZSBmb3IgdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5TcGFjZVwiLFxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHNwYWNlIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIHVzZXJzIDNCb3hcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3BhY2VcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge0Z1bmN0aW9ufSAgICAgICAgICBvcHRzLmNvbnNlbnRDYWxsYmFjayAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgY29uc2VudGVkIHRvIG9wZW5pbmcgdGhlIGJveFxuICAgICAqIEBwYXJhbSAgICAge0Z1bmN0aW9ufSAgICAgICAgICBvcHRzLm9uU3luY0RvbmUgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc3BhY2UgaGFzIGZpbmlzaGVkIHN5bmNpbmcgd2l0aCB0aGUgcGlubmluZyBub2RlXG4gICAgICogQHJldHVybiAgICB7U3BhY2V9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBTcGFjZSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIHNwYWNlIG5hbWVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuU3BhY2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYobmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzNiA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzNi5sZW5ndGggPiAxICYmIF9hcmdzNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzFdIDoge307XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGFjZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlc1tuYW1lXSA9IG5ldyBTcGFjZShuYW1lLCB0aGlzLl8zaWQsIHRoaXMuX29yYml0ZGIsIHRoaXMuX3Jvb3RTdG9yZSwgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgIG51bUVudHJpZXNNZXNzYWdlczogdGhpcy5zcGFjZXNQdWJTdWJNZXNzYWdlc1xuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjZXNbbmFtZV0ub3BlbihvcHRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWRkcmVzc0xpbmtlZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQ2LnNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtBZGRyZXNzKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxMztcbiAgICAgICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zcGFjZXNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0Ni50MC5tZXNzYWdlLmluY2x1ZGVzKCdVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBkZW5pZWQgc3BhY2UgY29uc2VudC4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBvcGVuaW5nIHNwYWNlOiAnLCBfY29udGV4dDYudDAubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMub25TeW5jRG9uZSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIHNwYWNlIGlzIGFscmVhZHkgb3BlbiB3ZSBjYW4gY2FsbCBvblN5bmNEb25lIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICBvcHRzLm9uU3luY0RvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnNwYWNlc1tuYW1lXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMywgMTNdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5TcGFjZShfeDkpIHtcbiAgICAgICAgcmV0dXJuIF9vcGVuU3BhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZW5TcGFjZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgZGIgaXMgZnVsbHkgc3luY2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICAgICAgc3luY0RvbmUgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN5bmNEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3luY0RvbmUoc3luY0RvbmUpIHtcbiAgICAgIHRoaXMuX29uU3luY0RvbmVDQiA9IHN5bmNEb25lO1xuXG4gICAgICBpZiAodGhpcy5fYm94U3luY2VkKSB7XG4gICAgICAgIHRoaXMuX29uU3luY0RvbmVDQigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHVibGlzaFJvb3RTdG9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3B1Ymxpc2hSb290U3RvcmUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJvb3RTdG9yZUFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NUb2tlbjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8zaWQuc2lnbkpXVCh7XG4gICAgICAgICAgICAgICAgICByb290U3RvcmVBZGRyZXNzOiByb290U3RvcmVBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFkZHJlc3NUb2tlbiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMztcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih0aGlzLl9zZXJ2ZXJVcmwgKyAnL29kYkFkZHJlc3MnLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzX3Rva2VuOiBhZGRyZXNzVG9rZW5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0Ny50MC5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9jb250ZXh0Ny50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcywgW1szLCA4XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcHVibGlzaFJvb3RTdG9yZShfeDEwKSB7XG4gICAgICAgIHJldHVybiBfcHVibGlzaFJvb3RTdG9yZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wdWJsaXNoUm9vdFN0b3JlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBESUQgICAgICAgIHRoZSBESUQgb2YgdGhlIHVzZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpbmtBZGRyZXNzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvb2YgdGhhdCBsaW5rcyBhbiBldGhlcmV1bSBhZGRyZXNzIHRvIHRoZSAzQm94IGFjY291bnQgb2YgdGhlIHVzZXIuIElmIGdpdmVuIHByb29mLCBpdCB3aWxsIHNpbXBseSBiZSBhZGRlZCB0byB0aGUgcm9vdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgW2xpbmtdICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIGxpbmsgb2JqZWN0IHdpdGggdHlwZSBvciBwcm9vZlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW2xpbmsudHlwZT0nZXRoZXJldW0tZW9hJ10gICAgIFRoZSB0eXBlIG9mIGxpbmsgKGRlZmF1bHQgJ2V0aGVyZXVtJylcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIFtsaW5rLnByb29mXSAgICAgICAgICAgICAgICAgICBQcm9vZiBvYmplY3QsIHNob3VsZCBmb2xsb3cgW3NwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS8zYm94LzNib3gvYmxvYi9tYXN0ZXIvM0lQcy8zaXAtNS5tZClcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saW5rQWRkcmVzcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgdmFyIGxpbmssXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGxpbmsgPSBfYXJnczgubGVuZ3RoID4gMCAmJiBfYXJnczhbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFswXSA6IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rLnByb29mKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlQWRkcmVzc0xpbmsobGluay5wcm9vZik7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAoISghbGluay50eXBlIHx8IGxpbmsudHlwZSA9PT0gQUNDT1VOVF9UWVBFUy5ldGhlcmV1bUVPQSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua1Byb2ZpbGUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlua0FkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfbGlua0FkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmtBZGRyZXNzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImxpbmtBY2NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlua0FjY291bnQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoKSB7XG4gICAgICAgIHZhciB0eXBlLFxuICAgICAgICAgICAgX2FyZ3M5ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0eXBlID0gX2FyZ3M5Lmxlbmd0aCA+IDAgJiYgX2FyZ3M5WzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczlbMF0gOiBBQ0NPVU5UX1RZUEVTLmV0aGVyZXVtRU9BO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbGlua0FjY291bnQ6IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbGlua0FkZHJlc3MgZ29pbmcgZm9yd2FyZCcpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saW5rQWRkcmVzcyh0eXBlKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlua0FjY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfbGlua0FjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmtBY2NvdW50O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBnaXZlbiBhZGRyZXNzIGxpbmssIHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgYWRkcmVzcyAgICAgIGFkZHJlc3MgdGhhdCBpcyBsaW5rZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlQWRkcmVzc0xpbmsgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGxpbmtFeGlzdCwgcGF5bG9hZCwgb25lSG91ciwgZGVsZXRlVG9rZW47XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBZGRyZXNzTGlua2VkKHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbGlua0V4aXN0ID0gX2NvbnRleHQxMC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQWRkcmVzc0xpbms6IGxpbmsgZm9yIGdpdmVuIGFkZHJlc3MgZG9lcyBub3QgZXhpc3QnKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZS1hZGRyZXNzLWxpbmtcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25lSG91ciA9IDYwICogNjA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5zaWduSldUKHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgIGV4cGlyZXNJbjogb25lSG91clxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgZGVsZXRlVG9rZW4gPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih0aGlzLl9zZXJ2ZXJVcmwgKyAnL2xpbmtkZWxldGUnLCB7XG4gICAgICAgICAgICAgICAgICBkZWxldGVfdG9rZW46IGRlbGV0ZVRva2VuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMTEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0MTAudDAuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQxMC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZXRlQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcywgW1sxMSwgMTZdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUFkZHJlc3NMaW5rKF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVBZGRyZXNzTGluay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgcHJvb2YgdGhhdCBsaW5rcyBhbiBleHRlcm5hbCBhY2NvdW50IHRvIHRoZSAzQm94IGFjY291bnQgb2YgdGhlIHVzZXIuIElmIG5vdCBwYXJhbXMgZ2l2ZW4gYW5kIGFueSBsaW5rIGV4aXN0cywgcmV0dXJucyB0cnVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIFtxdWVyeV0gICAgICAgICAgICBPcHRpb25hbCBvYmplY3Qgd2l0aCBhZGRyZXNzIGFuZC9vciB0eXBlLlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW3F1ZXJ5LnR5cGVdICAgICAgIERvZXMgdGhlIGdpdmVuIHR5cGUgb2YgbGluayBleGlzdFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW3F1ZXJ5LmFkZHJlc3NdICAgIElzIHRoZSBnaXZlbiBhZHJlc3NlZCBsaW5rZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQWRkcmVzc0xpbmtlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2lzQWRkcmVzc0xpbmtlZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoKSB7XG4gICAgICAgIHZhciBxdWVyeSxcbiAgICAgICAgICAgIGxpbmtzLFxuICAgICAgICAgICAgbGlua3NRdWVyeSxcbiAgICAgICAgICAgIF9hcmdzMTEgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF9hcmdzMTEubGVuZ3RoID4gMCAmJiBfYXJnczExWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczExWzBdIDoge307XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFkZHJlc3MpIHF1ZXJ5LmFkZHJlc3MgPSBxdWVyeS5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEFkZHJlc3NMaW5rcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBsaW5rcyA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICBsaW5rc1F1ZXJ5ID0gbGlua3MuZmluZChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHF1ZXJ5LmFkZHJlc3MgPyBsaW5rLmFkZHJlc3MgPT09IHF1ZXJ5LmFkZHJlc3MgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5LnR5cGUgPyByZXMgJiYgbGluay50eXBlID09PSBxdWVyeS50eXBlIDogcmVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBCb29sZWFuKGxpbmtzUXVlcnkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpc0FkZHJlc3NMaW5rZWQoKSB7XG4gICAgICAgIHJldHVybiBfaXNBZGRyZXNzTGlua2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0FkZHJlc3NMaW5rZWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBY2NvdW50TGlua2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaXNBY2NvdW50TGlua2VkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMigpIHtcbiAgICAgICAgdmFyIHR5cGUsXG4gICAgICAgICAgICBfYXJnczEyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdHlwZSA9IF9hcmdzMTIubGVuZ3RoID4gMCAmJiBfYXJnczEyWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczEyWzBdIDogQUNDT1VOVF9UWVBFUy5ldGhlcmV1bUVPQTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2lzQWNjb3VudExpbmtlZDogZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBpc0FkZHJlc3NMaW5rZWQgZ29pbmcgZm9yd2FyZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCB0aGlzLmlzQWRkcmVzc0xpbmtlZCh0eXBlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaXNBY2NvdW50TGlua2VkKCkge1xuICAgICAgICByZXR1cm4gX2lzQWNjb3VudExpbmtlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNBY2NvdW50TGlua2VkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFkZHJlc3MgbGlua3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgM0JveFxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgbGluayBvYmplY3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0QWRkcmVzc0xpbmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlzdEFkZHJlc3NMaW5rcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoKSB7XG4gICAgICAgIHZhciBlbnRyaWVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEFkZHJlc3NMaW5rcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgaXRlbS5saW5rSWQgPSBpdGVtLmVudHJ5Lmhhc2g7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5lbnRyeTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH0sIFtdKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlzdEFkZHJlc3NMaW5rcygpIHtcbiAgICAgICAgcmV0dXJuIF9saXN0QWRkcmVzc0xpbmtzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0QWRkcmVzc0xpbmtzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9saW5rUHJvZmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xpbmtQcm9maWxlMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzLCBsaW5rRGF0YSwgZGlkLCBjb25zZW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuXzNpZC5tYW5hZ2VtZW50QWRkcmVzcztcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGxpbmtEYXRhID0gX2NvbnRleHQxNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtEYXRhKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpZCA9IHRoaXMuRElEO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0TGlua0NvbnNlbnQoYWRkcmVzcywgZGlkLCB0aGlzLl93ZWIzcHJvdmlkZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjb25zZW50ID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC50MCA9IF9jb250ZXh0MTRbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDE0LnQwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgY29uc2VudCBtZXNzYWdlIG11c3QgYmUgc2lnbmVkIGJlZm9yZSBhZGRpbmcgZGF0YSwgdG8gbGluayBhZGRyZXNzIHRvIHN0b3JlJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBsaW5rRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBBQ0NPVU5UX1RZUEVTLmV0aGVyZXVtRU9BLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc2VudC5tc2csXG4gICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGNvbnNlbnQuc2lnLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBjb25zZW50LnRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlQWRkcmVzc0xpbmsobGlua0RhdGEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uZ2V0KCdwcm9vZl9kaWQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDE0LnNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC50MSA9IHRoaXNbXCJwdWJsaWNcIl07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5zaWduSldUKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0LnQyID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQudDMgPSB7XG4gICAgICAgICAgICAgICAgICBub0xpbms6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnQxLnNldC5jYWxsKF9jb250ZXh0MTQudDEsICdwcm9vZl9kaWQnLCBfY29udGV4dDE0LnQyLCBfY29udGV4dDE0LnQzKTtcblxuICAgICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAgIC8vIFNlbmQgY29uc2VudFNpZ25hdHVyZSB0byAzYm94LWFkZHJlc3Mtc2VydmVyIHRvIGxpbmsgcHJvZmlsZSB3aXRoIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgICAgICAgICAgICB1dGlscy5mZXRjaEpzb24odGhpcy5fc2VydmVyVXJsICsgJy9saW5rJywgbGlua0RhdGEpW1wiY2F0Y2hcIl0oY29uc29sZS5lcnJvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNCwgdGhpcywgW1s2LCAxMl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2xpbmtQcm9maWxlKCkge1xuICAgICAgICByZXR1cm4gX2xpbmtQcm9maWxlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xpbmtQcm9maWxlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl93cml0ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd3JpdGVBZGRyZXNzTGluazIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE1KHByb29mKSB7XG4gICAgICAgIHZhciBkYXRhLCBsaW5rRXhpc3QsIGxpbms7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNS5wcmV2ID0gX2NvbnRleHQxNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pcGZzLmRhZy5wdXQocHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQxNS5zZW50LnRvQmFzZUVuY29kZWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rQ0lERXhpc3RzKGRhdGEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBsaW5rRXhpc3QgPSBfY29udGV4dDE1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgbGluayA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzLWxpbmsnLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5hZGQobGluayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF93cml0ZUFkZHJlc3NMaW5rKF94MTIpIHtcbiAgICAgICAgcmV0dXJuIF93cml0ZUFkZHJlc3NMaW5rMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3dyaXRlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xpbmtDSURFeGlzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saW5rQ0lERXhpc3RzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYoY2lkKSB7XG4gICAgICAgIHZhciBlbnRyaWVzLCBsaW5rRW50cmllcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTYkKF9jb250ZXh0MTYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE2LnByZXYgPSBfY29udGV4dDE2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5pdGVyYXRvcih7XG4gICAgICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgICAgICB9KS5jb2xsZWN0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDE2LnNlbnQ7XG4gICAgICAgICAgICAgICAgbGlua0VudHJpZXMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucGF5bG9hZC52YWx1ZS50eXBlID09PSAnYWRkcmVzcy1saW5rJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwgbGlua0VudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5kYXRhID09PSBjaWQ7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9saW5rQ0lERXhpc3RzKF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9saW5rQ0lERXhpc3RzMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xpbmtDSURFeGlzdHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlbGV0ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVsZXRlQWRkcmVzc0xpbmsyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNyhhZGRyZXNzKSB7XG4gICAgICAgIHZhciBsaW5rO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGxpbmsgPSBfY29udGV4dDE3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX2RlbGV0ZUFkZHJlc3NMaW5rOiBsaW5rIGZvciBnaXZlbiBhZGRyZXNzIGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yb290U3RvcmUucmVtb3ZlKGxpbmsuZW50cnkuaGFzaCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9kZWxldGVBZGRyZXNzTGluayhfeDE0KSB7XG4gICAgICAgIHJldHVybiBfZGVsZXRlQWRkcmVzc0xpbmsyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZGVsZXRlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWRBZGRyZXNzTGlua3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkQWRkcmVzc0xpbmtzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbnRyaWVzLCBsaW5rRW50cmllcywgcmVzb2x2ZUxpbmtzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOSQoX2NvbnRleHQxOSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxOS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLml0ZXJhdG9yKHtcbiAgICAgICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgICAgIH0pLmNvbGxlY3QoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZW50cmllcyA9IF9jb250ZXh0MTkuc2VudDtcbiAgICAgICAgICAgICAgICBsaW5rRW50cmllcyA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXlsb2FkLnZhbHVlLnR5cGUgPT09ICdhZGRyZXNzLWxpbmsnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaW5rcyA9IGxpbmtFbnRyaWVzLm1hcChcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9pcGZzLmRhZy5nZXQoZW50cnkucGF5bG9hZC52YWx1ZS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX2NvbnRleHQxOC5zZW50LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMucmVjb3ZlclBlcnNvbmFsU2lnbihvYmoubWVzc2FnZSwgb2JqLnNpZ25hdHVyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRyZXNzID0gX2NvbnRleHQxOC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXCJyZXR1cm5cIiwgb2JqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTgpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UuYWxsKHJlc29sdmVMaW5rcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWFkQWRkcmVzc0xpbmtzKCkge1xuICAgICAgICByZXR1cm4gX3JlYWRBZGRyZXNzTGlua3MyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhZEFkZHJlc3NMaW5rcztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVhZEFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZEFkZHJlc3NMaW5rMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjAoYWRkcmVzcykge1xuICAgICAgICB2YXIgbGlua3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIwJChfY29udGV4dDIwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMC5wcmV2ID0gX2NvbnRleHQyMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRBZGRyZXNzTGlua3MoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbGlua3MgPSBfY29udGV4dDIwLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuYWJydXB0KFwicmV0dXJuXCIsIGxpbmtzLmZpbmQoZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3JlYWRBZGRyZXNzTGluayhfeDE2KSB7XG4gICAgICAgIHJldHVybiBfcmVhZEFkZHJlc3NMaW5rMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JlYWRBZGRyZXNzTGluaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9lbnN1cmVQaW5uaW5nTm9kZUNvbm5lY3RlZDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIxKG9kYkFkZHJlc3MsIGlzVGhyZWFkKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciByb29tUGVlcnMsIHJvb3RTdG9yZUFkZHJlc3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIxJChfY29udGV4dDIxKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMS5wcmV2ID0gX2NvbnRleHQyMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pcGZzLnB1YnN1Yi5wZWVycyhvZGJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcm9vbVBlZXJzID0gX2NvbnRleHQyMS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb29tUGVlcnMuZmluZChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgPT09IF90aGlzNC5waW5uaW5nTm9kZS5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pcGZzLnN3YXJtLmNvbm5lY3QodGhpcy5waW5uaW5nTm9kZSwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgICAgICAgICAgICByb290U3RvcmVBZGRyZXNzID0gdGhpcy5fcm9vdFN0b3JlLmFkZHJlc3MudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKFBJTk5JTkdfUk9PTSwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTWU5DX0RCJyxcbiAgICAgICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiBvZGJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHRocmVhZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKFBJTk5JTkdfUk9PTSwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQSU5fREInLFxuICAgICAgICAgICAgICAgICAgICAgIG9kYkFkZHJlc3M6IHJvb3RTdG9yZUFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9lbnN1cmVQaW5uaW5nTm9kZUNvbm5lY3RlZChfeDE3LCBfeDE4KSB7XG4gICAgICAgIHJldHVybiBfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIyJChfY29udGV4dDIyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMi5wcmV2ID0gX2NvbnRleHQyMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmJpdGRiLnN0b3AoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVic3ViLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZ2xvYmFsT3JiaXREQiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgM2JveCBpbnN0YW5jZSBhbmQgY2xlYXJzIGxvY2FsIGNhY2hlLiBJZiB5b3UgY2FsbCB0aGlzLFxuICAgICAqIHVzZXJzIHdpbGwgbmVlZCB0byBzaWduIGEgY29uc2VudCBtZXNzYWdlIHRvIGxvZyBpbiB0aGUgbmV4dCB0aW1lXG4gICAgICogeW91IGNhbGwgb3BlbkJveC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvZ291dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvZ291dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjMoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMyQoX2NvbnRleHQyMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjMucHJldiA9IF9jb250ZXh0MjMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLl8zaWQubG9nb3V0KCk7XG5cbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fM2lkLm1hbmFnZW1lbnRBZGRyZXNzO1xuICAgICAgICAgICAgICAgIGxvY2Fsc3RvcmFnZS5yZW1vdmUoJ2xpbmtDb25zZW50XycgKyBhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgICAgIHJldHVybiBfbG9nb3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2dvdXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgbG9nZ2VkIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuICAgIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIGluXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJESURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl8zaWQubXVwb3J0RElEO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldFByb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQcm9maWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBwcm9maWxlLFxuICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MsXG4gICAgICAgICAgICBfYXJnczI0ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNCQoX2NvbnRleHQyNCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjQucHJldiA9IF9jb250ZXh0MjQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjQubGVuZ3RoID4gMSAmJiBfYXJnczI0WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI0WzFdIDoge307XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBvcHRzLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgIHVzZUNhY2hlU2VydmljZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLnVzZUNhY2hlU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRQcm9maWxlKGFkZHJlc3MsIG9wdHMucHJvZmlsZVNlcnZlciwge1xuICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHByb2ZpbGUgPSBfY29udGV4dDI0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXR0aW5nIG1ldGFkYXRhIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIG91dHNpZGUgb2YgdGhlIEFQSScpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb2ZpbGVPcmJpdChub3JtYWxpemVkQWRkcmVzcywgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBwcm9maWxlID0gX2NvbnRleHQyNC5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFwicmV0dXJuXCIsIHByb2ZpbGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9maWxlKF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQcm9maWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQcm9maWxlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgcHVibGljIHByb2ZpbGVzIGZvciBnaXZlbiBhZGRyZXNzZXMuIFRoaXMgcmVsaWVzIG9uIDNCb3ggcHJvZmlsZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtBcnJheX0gICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGV0aGVyZXVtIGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIGVhY2gga2V5IGFuIGFkZHJlc3MgYW5kIHZhbHVlIHRoZSBwcm9maWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9maWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFByb2ZpbGVzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNShhZGRyZXNzQXJyYXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczI1ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNSQoX2NvbnRleHQyNSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjUucHJldiA9IF9jb250ZXh0MjUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjUubGVuZ3RoID4gMSAmJiBfYXJnczI1WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI1WzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIEFQSS5nZXRQcm9maWxlcyhhZGRyZXNzQXJyYXksIG9wdHMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjUpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9maWxlcyhfeDIwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0UHJvZmlsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFByb2ZpbGVzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIGRhdGEgaW4gYSBzcGFjZSBvZiBhIGdpdmVuIGFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBBbiBldGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBuYW1lICAgICAgICAgICAgICAgICAgICBBIHNwYWNlIG5hbWVcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIG9wdHMuYmxvY2tsaXN0ICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhZGRyZXNzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZXRhZGF0YSAgICAgICAgICAgZmxhZyB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIHRoZSBwdWJsaWMgc3BhY2UgZGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTcGFjZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYoYWRkcmVzcywgbmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMjYgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNi5wcmV2ID0gX2NvbnRleHQyNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyNi5sZW5ndGggPiAyICYmIF9hcmdzMjZbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMjZbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldFNwYWNlKGFkZHJlc3MsIG5hbWUsIG9wdHMucHJvZmlsZVNlcnZlciwgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNwYWNlKF94MjEsIF94MjIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTcGFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0U3BhY2U7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwb3N0cyB0aGF0IGFyZSBtYWRlIHRvIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBzcGFjZSAgICAgICAgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3BhY2UgdGhlIHRocmVhZCBpcyBpblxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgbmFtZSAgICAgICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRocmVhZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgZmlyc3RNb2RlcmF0b3IgICAgICAgICAgVGhlIERJRCAob3IgZXRoZXJldW0gYWRkcmVzcykgb2YgdGhlIGZpcnN0IG1vZGVyYXRvclxuICAgICAqIEBwYXJhbSAgICAge0Jvb2xlYW59ICAgbWVtYmVycyAgICAgICAgICAgICAgICAgVHJ1ZSBpZiBvbmx5IG1lbWJlcnMgYXJlIGFsbG93ZWQgdG8gcG9zdFxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgcG9zdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRocmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjcoc3BhY2UsIG5hbWUsIGZpcnN0TW9kZXJhdG9yLCBtZW1iZXJzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgX2FyZ3MyNyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjckKF9jb250ZXh0MjcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI3LnByZXYgPSBfY29udGV4dDI3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczI3Lmxlbmd0aCA+IDQgJiYgX2FyZ3MyN1s0XSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyN1s0XSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LmFicnVwdChcInJldHVyblwiLCBBUEkuZ2V0VGhyZWFkKHNwYWNlLCBuYW1lLCBmaXJzdE1vZGVyYXRvciwgbWVtYmVycywgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRocmVhZChfeDIzLCBfeDI0LCBfeDI1LCBfeDI2KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VGhyZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRUaHJlYWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwb3N0cyB0aGF0IGFyZSBtYWRlIHRvIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgb3JiaXRkYi1hZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMucHJvZmlsZVNlcnZlciAgICAgIFVSTCBvZiBQcm9maWxlIEFQSSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3Q+fSAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIHBvc3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaHJlYWRCeUFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRUaHJlYWRCeUFkZHJlc3MgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI4KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczI4ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyOCQoX2NvbnRleHQyOCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjgucHJldiA9IF9jb250ZXh0MjgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjgubGVuZ3RoID4gMSAmJiBfYXJnczI4WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI4WzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIEFQSS5nZXRUaHJlYWRCeUFkZHJlc3MoYWRkcmVzcywgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyOCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRocmVhZEJ5QWRkcmVzcyhfeDI3KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VGhyZWFkQnlBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRUaHJlYWRCeUFkZHJlc3M7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIGEgdXNlcnMgM0JveFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgZXRoZXJldW0gYWRkcmVzc1xuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgcG9zdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldENvbmZpZyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjkoYWRkcmVzcykge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMjkgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI5JChfY29udGV4dDI5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyOS5sZW5ndGggPiAxICYmIF9hcmdzMjlbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMjlbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldENvbmZpZyhhZGRyZXNzLCBvcHRzKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI5KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Q29uZmlnKF94MjgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvbmZpZztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWVzIG9mIGFsbCBzcGFjZXMgYSB1c2VyIGhhc1xuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBBbiBldGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBvcHRzICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLnByb2ZpbGVTZXJ2ZXIgICAgICBVUkwgb2YgUHJvZmlsZSBBUEkgc2VydmVyXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSB3aXRoIGFsbCBzcGFjZXMgYXMgc3RyaW5nc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdFNwYWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xpc3RTcGFjZXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMwKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczMwID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMCQoX2NvbnRleHQzMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzAucHJldiA9IF9jb250ZXh0MzAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMzAubGVuZ3RoID4gMSAmJiBfYXJnczMwWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczMwWzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzAuYWJydXB0KFwicmV0dXJuXCIsIEFQSS5saXN0U3BhY2VzKGFkZHJlc3MsIG9wdHMucHJvZmlsZVNlcnZlcikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RTcGFjZXMoX3gyOSkge1xuICAgICAgICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RTcGFjZXM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFByb2ZpbGVPcmJpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFByb2ZpbGVPcmJpdDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMyKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICByb290U3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgdXNpbmdHbG9iYWxJUEZTLFxuICAgICAgICAgICAgaXBmcyxcbiAgICAgICAgICAgIG9yYml0ZGIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHBpbm5pbmdOb2RlLFxuICAgICAgICAgICAgcHVibGljU3RvcmUsXG4gICAgICAgICAgICByb290U3RvcmUsXG4gICAgICAgICAgICByZWFkeVByb21pc2UsXG4gICAgICAgICAgICBwcm9maWxlRW50cnksXG4gICAgICAgICAgICBwcm9maWxlLFxuICAgICAgICAgICAgY2xvc2VBbGwsXG4gICAgICAgICAgICBfYXJnczMyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMiQoX2NvbnRleHQzMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzIucHJldiA9IF9jb250ZXh0MzIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMzIubGVuZ3RoID4gMSAmJiBfYXJnczMyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczMyWzFdIDoge307XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlkVXRpbHMuaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RJRCBhcmUgc3VwcG9ydGVkIGluIHRoZSBjYWNoZWQgdmVyc2lvbiBvbmx5Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRSb290U3RvcmVBZGRyZXNzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSwgb3B0cy5hZGRyZXNzU2VydmVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcm9vdFN0b3JlQWRkcmVzcyA9IF9jb250ZXh0MzIuc2VudDtcbiAgICAgICAgICAgICAgICB1c2luZ0dsb2JhbElQRlMgPSBmYWxzZTsgLy8gbGV0IHVzaW5nR2xvYmFsT3JiaXREQiA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbElQRlMpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXBmcyA9IGdsb2JhbElQRlM7XG4gICAgICAgICAgICAgICAgdXNpbmdHbG9iYWxJUEZTID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0SVBGUyhvcHRzLmlwZnMsIG9wdHMuaWZyYW1lU3RvcmUsIG9wdHMuaXBmc09wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgaXBmcyA9IF9jb250ZXh0MzIuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxPcmJpdERCKSB7XG4gICAgICAgICAgICAgICAgICBvcmJpdGRiID0gZ2xvYmFsT3JiaXREQjtcbiAgICAgICAgICAgICAgICAgIHVzaW5nR2xvYmFsSVBGUyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlID0gbnVsbDsgLy8gKG9wdHMuaWZyYW1lU3RvcmUgJiYgISFjYWNoZVByb3h5KSA/IGNhY2hlUHJveHkgOiBudWxsXG5cbiAgICAgICAgICAgICAgICAgIG9yYml0ZGIgPSBuZXcgT3JiaXREQihpcGZzLCBvcHRzLm9yYml0UGF0aCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBpbm5pbmdOb2RlID0gb3B0cy5waW5uaW5nTm9kZSB8fCBQSU5OSU5HX05PREU7XG4gICAgICAgICAgICAgICAgaXBmcy5zd2FybS5jb25uZWN0KHBpbm5pbmdOb2RlLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgcHVibGljU3RvcmUgPSBuZXcgUHVibGljU3RvcmUob3JiaXRkYik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTdG9yZUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDQxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yYml0ZGIub3Blbihyb290U3RvcmVBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgIHJvb3RTdG9yZSA9IF9jb250ZXh0MzIuc2VudDtcbiAgICAgICAgICAgICAgICByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICByb290U3RvcmUuZXZlbnRzLm9uKCdyZWFkeScsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvb3RTdG9yZS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWR5UHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIGlmIChyb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDMyLm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgcm9vdFN0b3JlLmV2ZW50cy5vbigncmVwbGljYXRlLnByb2dyZXNzJywgZnVuY3Rpb24gKF94LCBfeSwgX3osIG51bSwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW0gPT09IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJvb3RTdG9yZS5ldmVudHMub24oJ3JlcGxpY2F0ZWQnLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgICBwcm9maWxlRW50cnkgPSByb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucGF5bG9hZC52YWx1ZS5vZGJBZGRyZXNzLnNwbGl0KCcuJylbMV0gPT09ICdwdWJsaWMnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNTdG9yZS5fbG9hZChwcm9maWxlRW50cnkucGF5bG9hZC52YWx1ZS5vZGJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDM1O1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNTdG9yZS5fc3luYygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgICAgcHJvZmlsZSA9IHB1YmxpY1N0b3JlLmFsbCgpO1xuXG4gICAgICAgICAgICAgICAgY2xvc2VBbGwgPVxuICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjcgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMxKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMSQoX2NvbnRleHQzMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzEucHJldiA9IF9jb250ZXh0MzEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFN0b3JlLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzEubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1N0b3JlLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICghdXNpbmdHbG9iYWxPcmJpdERCKSBhd2FpdCBvcmJpdGRiLnN0b3AoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNpbmdHbG9iYWxJUEZTKSB7fSAvLyBhd2FpdCBpcGZzLnN0b3AoKVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMxKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlQWxsKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpOyAvLyBjbG9zZSBidXQgZG9uJ3Qgd2FpdCBmb3IgaXRcblxuXG4gICAgICAgICAgICAgICAgY2xvc2VBbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMi5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJvZmlsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9nZXRQcm9maWxlT3JiaXQoX3gzMCkge1xuICAgICAgICByZXR1cm4gX2dldFByb2ZpbGVPcmJpdDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRQcm9maWxlT3JiaXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBmb3IgM0JveCBwcm9maWxlIEFQSVxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBxdWVyeSAgICAgICAgICAgICAgIEEgZ3JhcGhRTCBxdWVyeSBvYmplY3QuXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBvcHRzICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZ3JhcGhxbFNlcnZlciAgVVJMIG9mIGdyYXBoUUwgM0JveCBwcm9maWxlIHNlcnZpY2VcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIGVhY2gga2V5IGFuIGFkZHJlc3MgYW5kIHZhbHVlIHRoZSBwcm9maWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9maWxlR3JhcGhRTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Byb2ZpbGVHcmFwaFFMID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMyhxdWVyeSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMzMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMzJChfY29udGV4dDMzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzMy5wcmV2ID0gX2NvbnRleHQzMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzMy5sZW5ndGggPiAxICYmIF9hcmdzMzNbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMzNbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLnByb2ZpbGVHcmFwaFFMKHF1ZXJ5LCBvcHRzLmdyYXBocWxTZXJ2ZXIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMzMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwcm9maWxlR3JhcGhRTChfeDMxKSB7XG4gICAgICAgIHJldHVybiBfcHJvZmlsZUdyYXBoUUwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2ZpbGVHcmFwaFFMO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSBwcm9vZnMgb2Ygc29jaWFsIGFjY291bnRzIHRoYXQgaXMgcHJlc2VudCBpbiB0aGUgcHJvZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgICAgICBwcm9maWxlICAgICAgICAgICAgICAgICBBIHVzZXIgcHJvZmlsZSBvYmplY3QsIHJlY2VpdmVkIGZyb20gdGhlIGBnZXRQcm9maWxlYCBmdW5jdGlvblxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYWNjb3VudHMgdGhhdCBoYXZlIGJlZW4gdmVyaWZpZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZlcmlmaWVkQWNjb3VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRWZXJpZmllZEFjY291bnRzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNChwcm9maWxlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM0JChfY29udGV4dDM0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzNC5wcmV2ID0gX2NvbnRleHQzNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldFZlcmlmaWVkQWNjb3VudHMocHJvZmlsZSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFZlcmlmaWVkQWNjb3VudHMoX3gzMikge1xuICAgICAgICByZXR1cm4gX2dldFZlcmlmaWVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFZlcmlmaWVkQWNjb3VudHM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIDNCb3ggYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgYWRkcmVzcyAgICAgICAgICAgICAgICAgQW4gZXRoZXJldW0gYWRkcmVzc1xuICAgICAqIEBwYXJhbSAgICAge2V0aGVyZXVtUHJvdmlkZXJ9ICBldGhlcmV1bVByb3ZpZGVyICAgICAgICBBbiBldGhlcmV1bSBwcm92aWRlclxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgICAgICBvcHRzICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICAgICAgICAgIG9wdHMuY29uc2VudENhbGxiYWNrICAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBjb25zZW50ZWQgdG8gb3BlbmluZyB0aGUgYm94XG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdHMucGlubmluZ05vZGUgICAgICAgIEEgc3RyaW5nIHdpdGggYW4gaXBmcyBtdWx0aS1hZGRyZXNzIHRvIGEgM2JveCBwaW5uaW5nIG5vZGVcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgb3B0cy5pcGZzICAgICAgICAgICAgICAgQSBqcy1pcGZzIGlwZnMgb2JqZWN0XG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdHMuYWRkcmVzc1NlcnZlciAgICAgIFVSTCBvZiB0aGUgQWRkcmVzcyBTZXJ2ZXJcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgb3B0cy5jb250ZW50U2lnbmF0dXJlICAgQSBzaWduYXR1cmUsIHByb3ZpZGVkIGJ5IGEgY2xpZW50IG9mIDNib3ggdXNpbmcgdGhlIHByaXZhdGUga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFkZHJlc3MsIG9mIHRoZSAzYm94IGNvbnNlbnQgbWVzc2FnZVxuICAgICAqIEByZXR1cm4gICAge0JveH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgM0JveCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5Cb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuQm94ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNShhZGRyZXNzLCBldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgaXBmcyxcbiAgICAgICAgICAgIF8zaWQsXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICBfYXJnczM1ID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM1JChfY29udGV4dDM1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzNS5wcmV2ID0gX2NvbnRleHQzNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzNS5sZW5ndGggPiAyICYmIF9hcmdzMzVbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMzVbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM1LnQwID0gZ2xvYmFsSVBGUztcblxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDM1LnQwKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdElQRlMob3B0cy5pcGZzLCBvcHRzLmlmcmFtZVN0b3JlLCBvcHRzLmlwZnNPcHRpb25zKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS50MCA9IF9jb250ZXh0MzUuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgaXBmcyA9IF9jb250ZXh0MzUudDA7XG4gICAgICAgICAgICAgICAgZ2xvYmFsSVBGUyA9IGlwZnM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRocmVlSWQuZ2V0SWRGcm9tRXRoQWRkcmVzcyhhZGRyZXNzLCBldGhlcmV1bVByb3ZpZGVyLCBpcGZzLCBvcHRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF8zaWQgPSBfY29udGV4dDM1LnNlbnQ7XG4gICAgICAgICAgICAgICAgYm94ID0gbmV3IEJveChfM2lkLCBldGhlcmV1bVByb3ZpZGVyLCBpcGZzLCBvcHRzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM1Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94Ll9sb2FkKG9wdHMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzUuYWJydXB0KFwicmV0dXJuXCIsIGJveCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5Cb3goX3gzMywgX3gzNCkge1xuICAgICAgICByZXR1cm4gX29wZW5Cb3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZW5Cb3g7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMb2dnZWRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xvZ2dlZEluKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBUaHJlZUlkLmlzTG9nZ2VkSW4oYWRkcmVzcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbmZ1bmN0aW9uIGluaXRJUEZTKF94MzUsIF94MzYsIF94MzcpIHtcbiAgcmV0dXJuIF9pbml0SVBGUy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5pdElQRlMoKSB7XG4gIF9pbml0SVBGUyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTM2KGlwZnMsIGlmcmFtZVN0b3JlLCBpcGZzT3B0aW9ucykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM2JChfY29udGV4dDM2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzYucHJldiA9IF9jb250ZXh0MzYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIGlmICghaXBmcyAmJiAhaXBmc1Byb3h5KSB0aHJvdyBuZXcgRXJyb3IoJ05vIElQRlMgb2JqZWN0IGNvbmZpZ3VyZWQgYW5kIG5vIGRlZmF1bHQgYXZhaWxhYmxlIGZvciBlbnZpcm9ubWVudCcpXG4gICAgICAgICAgICBpZiAoISFpcGZzICYmIGlmcmFtZVN0b3JlKSBjb25zb2xlLmxvZygnV2FybmluZzogaWZyYW1lU3RvcmUgdHJ1ZSwgb3JiaXQgZGIgY2FjaGUgaW4gaWZyYW1lLCBidXQgdGhlIGdpdmVuIGlwZnMgb2JqZWN0IGlzIGJlaW5nIHVzZWQsIGFuZCBtYXkgbm90IGJlIHJ1bm5pbmcgaW4gc2FtZSBpZnJhbWUuJyk7XG5cbiAgICAgICAgICAgIGlmICghaXBmcykge1xuICAgICAgICAgICAgICBfY29udGV4dDM2Lm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIGlwZnMpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgaXBmcyA9IG5ldyBJUEZTKGlwZnNPcHRpb25zIHx8IElQRlNfT1BUSU9OUyk7XG4gICAgICAgICAgICAgIGlwZnMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlwZnMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGlwZnMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMzYpO1xuICB9KSk7XG4gIHJldHVybiBfaW5pdElQRlMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuQm94LmlkVXRpbHMgPSBpZFV0aWxzO1xubW9kdWxlLmV4cG9ydHMgPSBCb3g7IiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG4vKiBleHBvcnQgYWxsIGNvcmUgZnVuY3Rpb25zIGFuZCB0eXBlcyAqL1xudmFyIGNvcmVfMiA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gY29yZV8yLmFwcGx5T3BlcmF0aW9uO1xuZXhwb3J0cy5hcHBseVBhdGNoID0gY29yZV8yLmFwcGx5UGF0Y2g7XG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGNvcmVfMi5hcHBseVJlZHVjZXI7XG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gY29yZV8yLmdldFZhbHVlQnlQb2ludGVyO1xuZXhwb3J0cy52YWxpZGF0ZSA9IGNvcmVfMi52YWxpZGF0ZTtcbmV4cG9ydHMudmFsaWRhdG9yID0gY29yZV8yLnZhbGlkYXRvcjtcbi8qIGV4cG9ydCBzb21lIGhlbHBlcnMgKi9cbnZhciBoZWxwZXJzXzIgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMi5QYXRjaEVycm9yO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzXzIuX2RlZXBDbG9uZTtcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi5lc2NhcGVQYXRoQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSBoZWxwZXJzXzIudW5lc2NhcGVQYXRoQ29tcG9uZW50O1xudmFyIGJlZm9yZURpY3QgPSBuZXcgV2Vha01hcCgpO1xudmFyIE1pcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3Iob2JqKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG4gICAgcmV0dXJuIE1pcnJvcjtcbn0oKSk7XG52YXIgT2JzZXJ2ZXJJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlckluZm87XG59KCkpO1xuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbmV4cG9ydHMudW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xuICAgIGlmICghbWlycm9yKSB7XG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcbiAgICAgICAgYmVmb3JlRGljdC5zZXQob2JqLCBtaXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lKG9iaik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xuICAgICAgICB2YXIgZGlydHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy9ub3QgTm9kZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKGludmVydGlibGUgPT09IHZvaWQgMCkgeyBpbnZlcnRpYmxlID0gZmFsc2U7IH1cbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBjb3JlXzEuYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gaGVscGVyc18xLl9vYmplY3RLZXlzKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSBoZWxwZXJzXzEuX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIGludmVydGlibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShuZXdWYWwpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShvbGRWYWwpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghaGVscGVyc18xLmhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKG9ialtrZXldKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIsIGludmVydGlibGUpIHtcbiAgICBpZiAoaW52ZXJ0aWJsZSA9PT0gdm9pZCAwKSB7IGludmVydGlibGUgPSBmYWxzZTsgfVxuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgJycsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuLy8gaW1wb3J0IGp1c3QgdG8gcmUtZXhwb3J0IGFzIGRlZmF1bHRcbnZhciBjb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBoZWxwZXJzXzMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gX19hc3NpZ24oe30sIGNvcmUsIHsgXG4gICAgLy8gZHVwbGV4XG4gICAgdW5vYnNlcnZlOiB1bm9ic2VydmUsXG4gICAgb2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUsXG4gICAgY29tcGFyZTogY29tcGFyZSxcbiAgICAvLyBoZWxwZXJzXG4gICAgSnNvblBhdGNoRXJyb3I6IGhlbHBlcnNfMy5QYXRjaEVycm9yLCBkZWVwQ2xvbmU6IGhlbHBlcnNfMS5fZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50OiBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQ6IGhlbHBlcnNfMy51bmVzY2FwZVBhdGhDb21wb25lbnQgfSk7XG4iLCIvKlxuXHRJU0MgTGljZW5zZVxuXG5cdENvcHlyaWdodCAoYykgMjAxOSwgUGllcnJlLUxvdWlzIERlc3BhaWduZVxuXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG5cdGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcblx0V0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuXHRNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuXHRBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG5cdFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuXHRBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuXHRPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKi9cblxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpO1xuXG4vLyBMYWJlbCdzIG1heCBsZW5ndGggaW4gRE5TIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNCNwYWdlLTcpXG5jb25zdCBkbnNMYWJlbE1heExlbmd0aCA9IDYzO1xuXG4vKipcbiAqIFRha2UgYW55IGlwZnNIYXNoIGFuZCBjb252ZXJ0IGl0IHRvIEROUy1jb21wYXRpYmxlIENJRFxuICogQHBhcmFtIHtzdHJpbmd9IGlwZnNIYXNoIGEgcmVndWxhciBpcGZzIGhhc2ggZWl0aGVyIGEgY2lkIHYwIG9yIHYxXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgaXBmcyBoYXNoIGFzIGEgY2lkIHYxXG4gKi9cbmNvbnN0IGNpZEZvcldlYiA9IChpcGZzSGFzaCkgPT4ge1xuXHRsZXQgY2lkID0gbmV3IENJRChpcGZzSGFzaCk7XG5cdGlmIChjaWQudmVyc2lvbiA9PT0gMCkge1xuXHRcdGNpZCA9IGNpZC50b1YxKCk7XG5cdH1cbiAgbGV0IGRuc0xhYmVsID0gY2lkLnRvU3RyaW5nKCdiYXNlMzInKTtcbiAgaWYgKGRuc0xhYmVsLmxlbmd0aCA+IGRuc0xhYmVsTWF4TGVuZ3RoKSB7XG4gICAgY29uc3QgYjM2ID0gY2lkLnRvU3RyaW5nKCdiYXNlMzYnKTtcbiAgICBpZiAoYjM2Lmxlbmd0aCA8PSBkbnNMYWJlbE1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIGIzNjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ0NJRCBpcyBsb25nZXIgdGhhbiBETlMgbGltaXQgb2YgNjMgY2hhcmFjdGVycyBhbmQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBwdWJsaWMgZ2F0ZXdheXMnKTtcbiAgfVxuXHRyZXR1cm4gZG5zTGFiZWw7XG59XG5cbmV4cG9ydHMuY2lkRm9yV2ViID0gY2lkRm9yV2ViO1xuXG5cbi8qKlxuICogVGFrZSBhbnkgaXBmc0hhc2ggYW5kIGNvbnZlcnQgaXQgdG8gYSBDSUQgdjEgZW5jb2RlZCBpbiBiYXNlMzIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggYSByZWd1bGFyIGlwZnMgaGFzaCBlaXRoZXIgYSBjaWQgdjAgb3IgdjEgKHYxIHdpbGwgcmVtYWluIHVuY2hhbmdlZClcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpcGZzIGhhc2ggYXMgYSBjaWQgdjFcbiAqL1xuY29uc3QgY2lkVjBUb1YxQmFzZTMyID0gKGlwZnNIYXNoKSA9PiB7XG5cdGxldCBjaWQgPSBuZXcgQ0lEKGlwZnNIYXNoKTtcblx0aWYgKGNpZC52ZXJzaW9uID09PSAwKSB7XG5cdFx0Y2lkID0gY2lkLnRvVjEoKTtcblx0fVxuXHRyZXR1cm4gY2lkLnRvU3RyaW5nKCdiYXNlMzInKTtcbn1cblxuZXhwb3J0cy5jaWRWMFRvVjFCYXNlMzIgPSBjaWRWMFRvVjFCYXNlMzI7XG4iLCIvLyBAdHMtY2hlY2tcbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyoqXG4gKiBNdWx0aWhhc2ggaW1wbGVtZW50YXRpb24gaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11bHRpaGFzaFxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbmNvbnN0IGNvZGVzID0ge31cblxuZm9yIChjb25zdCBrZXkgaW4gbmFtZXMpIHtcbiAgY29kZXNbbmFtZXNba2V5XV0gPSBrZXlcbn1cbmV4cG9ydHMubmFtZXMgPSBuYW1lc1xuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoY29kZXMpXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0hleFN0cmluZyA9IGZ1bmN0aW9uIHRvSGV4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihoYXNoKVxuICAgID8gaGFzaFxuICAgIDogQnVmZmVyLmZyb20oaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKVxuXG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nIChoYXNoKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLCAnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBiYXNlNTggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvQjU4U3RyaW5nID0gZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCEoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNThidGMnLCBoYXNoKSkuc2xpY2UoMSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBiYXNlNTggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUI1OFN0cmluZyAoaGFzaCkge1xuICBjb25zdCBlbmNvZGVkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICA/IHRleHREZWNvZGVyLmRlY29kZShoYXNoKVxuICAgIDogaGFzaFxuXG4gIHJldHVybiBtdWx0aWJhc2UuZGVjb2RlKCd6JyArIGVuY29kZWQpXG59XG5cbi8qKlxuICogRGVjb2RlIGEgaGFzaCBmcm9tIHRoZSBnaXZlbiBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge3tjb2RlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogQnVmZmVyfX0gcmVzdWx0XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChieXRlcykge1xuICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggbXVzdCBiZSBhIFVpbnQ4QXJyYXknKVxuICB9XG4gIGxldCBidWYgPSBCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpXG4gICAgPyBieXRlc1xuICAgIDogQnVmZmVyLmZyb20oYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKVxuXG4gIGlmIChidWYubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIHRvbyBzaG9ydC4gbXVzdCBiZSA+IDIgYnl0ZXMuJylcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKCFleHBvcnRzLmlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggdW5rbm93biBmdW5jdGlvbiBjb2RlOiAweCR7Y29kZS50b1N0cmluZygxNil9YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBjb25zdCBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKGxlbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBpbnZhbGlkIGxlbmd0aDogJHtsZW59YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggbGVuZ3RoIGluY29uc2lzdGVudDogMHgke2J1Zi50b1N0cmluZygnaGV4Jyl9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBuYW1lOiBjb2Rlc1tjb2RlXSxcbiAgICBsZW5ndGg6IGxlbixcbiAgICBkaWdlc3Q6IGJ1ZlxuICB9XG59XG5cbi8qKlxuICogIEVuY29kZSBhIGhhc2ggZGlnZXN0IGFsb25nIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjb2RlLlxuICpcbiAqID4gKipOb3RlOioqIHRoZSBsZW5ndGggaXMgZGVyaXZlZCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2VzdCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkaWdlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAoZGlnZXN0LCBjb2RlLCBsZW5ndGgpIHtcbiAgaWYgKCFkaWdlc3QgfHwgY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZW5jb2RlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBhcmdzOiBkaWdlc3QsIGNvZGUnKVxuICB9XG5cbiAgLy8gZW5zdXJlIGl0J3MgYSBoYXNoZnVuY3Rpb24gY29kZS5cbiAgY29uc3QgaGFzaGZuID0gZXhwb3J0cy5jb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoZGlnZXN0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBzaG91bGQgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICBjb25zdCBoYXNoID0gdmFyaW50LmVuY29kZShoYXNoZm4pXG4gIGNvbnN0IGxlbiA9IHZhcmludC5lbmNvZGUobGVuZ3RoKVxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoaGFzaC5sZW5ndGggKyBsZW4ubGVuZ3RoICsgZGlnZXN0Lmxlbmd0aClcbiAgYnVmZmVyLnNldChoYXNoLCAwKVxuICBidWZmZXIuc2V0KGxlbiwgaGFzaC5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoZGlnZXN0LCBoYXNoLmxlbmd0aCArIGxlbi5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhhc2ggZnVuY3Rpb24gbmFtZSBpbnRvIHRoZSBtYXRjaGluZyBjb2RlLlxuICogSWYgcGFzc2VkIGEgbnVtYmVyIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgaWYgaXQncyBhIHZhbGlkIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuY29lcmNlQ29kZSA9IGZ1bmN0aW9uIGNvZXJjZUNvZGUgKG5hbWUpIHtcbiAgbGV0IGNvZGUgPSBuYW1lXG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmIChuYW1lc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZ1bmN0aW9uIG5hbWVkOiAke25hbWV9YClcbiAgICB9XG4gICAgY29kZSA9IG5hbWVzW25hbWVdXG4gIH1cblxuICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIGZ1bmN0aW9uIGNvZGUgc2hvdWxkIGJlIGEgbnVtYmVyLiBHb3Q6ICR7Y29kZX1gKVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdID09PSB1bmRlZmluZWQgJiYgIWV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZnVuY3Rpb24gY29kZTogJHtjb2RlfWApXG4gIH1cblxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgYSBjb2RlIGlzIHBhcnQgb2YgdGhlIGFwcCByYW5nZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0FwcENvZGUgPSBmdW5jdGlvbiBhcHBDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID4gMCAmJiBjb2RlIDwgMHgxMFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbXVsdGloYXNoIGNvZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDb2RlID0gZnVuY3Rpb24gdmFsaWRDb2RlIChjb2RlKSB7XG4gIGlmIChleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY29kZXNbY29kZV0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJ1ZmZlciBpcyBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBleHBvcnRzLmRlY29kZShtdWx0aWhhc2gpIC8vIHRocm93cyBpZiBiYWQuXG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5wcmVmaXggPSBmdW5jdGlvbiBwcmVmaXggKG11bHRpaGFzaCkge1xuICB2YWxpZGF0ZShtdWx0aWhhc2gpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG11bHRpaGFzaC5idWZmZXIsIG11bHRpaGFzaC5ieXRlT2Zmc2V0LCAyKVxufVxuIiwiLypcblx0SVNDIExpY2Vuc2VcblxuXHRDb3B5cmlnaHQgKGMpIDIwMTksIFBpZXJyZS1Mb3VpcyBEZXNwYWlnbmVcblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuXHRjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG5cdFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcblx0TUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcblx0QU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuXHRXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cblx0QUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcblx0T1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKTtcbmNvbnN0IG11bHRpSCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJyk7XG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdqcy1iYXNlNjQnKVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgQnVmZmVyLCB0aGUgc3RyaW5nIGNhbiBzdGFydCB3aXRoIG9yIHdpdGhvdXQgJzB4J1xuICogQHBhcmFtIHtzdHJpbmd9IGhleCBhbiBoZXhhZGVjaW1hbCB2YWx1ZVxuICogQHJldHVybiB7QnVmZmVyfSB0aGUgcmVzdWx0aW5nIEJ1ZmZlclxuICovXG5jb25zdCBoZXhTdHJpbmdUb0J1ZmZlciA9IChoZXgpID0+IHtcblx0bGV0IHByZWZpeCA9IGhleC5zbGljZSgwLCAyKTtcblx0bGV0IHZhbHVlID0gaGV4LnNsaWNlKDIpO1xuXHRsZXQgcmVzID0gJyc7XG5cdGlmIChwcmVmaXggPT09ICcweCcpIHJlcyA9IHZhbHVlO1xuXHRlbHNlIHJlcyA9IGhleDtcblx0cmV0dXJuIG11bHRpSC5mcm9tSGV4U3RyaW5nKHJlcyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIElQTlMgaWRlbnRpZmllciAgdG8gc2FmZWd1YXJkIGFnYWluc3QgaW5zZWN1cmUgbmFtZXMuXG4gKiBAcGFyYW0ge0NJRH0gbmFtZSBpc2VkIGluIGlwbnMtbnNcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbmNvbnN0IGlzQ3J5cHRvZ3JhcGhpY0lQTlMgPSAgKGNpZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgbXVsdGloYXNoIH0gPSBjaWRcbiAgICAvLyBBZGRpdGlvbmFsIGNoZWNrIGZvciBpZGVudGlmaWVycyBzaG9ydGVyXG4gICAgLy8gdGhhbiB3aGF0IGlubGluZWQgRUQyNTUxOSBwdWJrZXkgd291bGQgYmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW5zZG9tYWlucy9lbnMtYXBwL2lzc3Vlcy84NDkjaXNzdWVjb21tZW50LTc3NzA4ODk1MFxuICAgIGlmIChtdWx0aWhhc2gubGVuZ3RoIDwgMzgpIHtcbiAgICAgIGNvbnN0IG1oID0gbXVsdGlILmRlY29kZShtdWx0aWhhc2gpXG4gICAgICAvLyBFRDI1NTE5IHB1YmtleXMgYXJlIGlubGluZWQgdXNpbmcgaWRlbnRpdHkgaGFzaCBmdW5jdGlvblxuICAgICAgLy8gYW5kIHdlIHNob3VsZCBub3Qgc2VlIGFueXRoaW5nIHNob3J0ZXIgdGhhbiB0aGF0XG4gICAgICBpZiAobWgubmFtZSA9PT0gJ2lkZW50aXR5JyAmJiBtaC5sZW5ndGggPCAzNikge1xuICAgICAgICAvLyBPbmUgY2FuIHJlYWQgaW5saW5lZCBzdHJpbmcgdmFsdWUgdmlhOlxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXBucy1ucyBpZDonLCBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvaywgQ0lEIGxvb2tzIGZpbmVcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChfKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZyxcbiogZW5jb2Rpbmcgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGBzdHJpbmdgIGlucHV0LFxuKiBhbmQgcmV0dXJuIGEgYEJ1ZmZlcmAgcmVzdWx0XG4qL1xuY29uc3QgZW5jb2RlcyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBza3luZXQ6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBiYXNlNjQudG9VaW50OEFycmF5KHZhbHVlKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIHN3YXJtOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBtdWx0aUguZW5jb2RlKGhleFN0cmluZ1RvQnVmZmVyKHZhbHVlKSwgJ2tlY2Nhay0yNTYnKTtcblx0XHRyZXR1cm4gbmV3IENJRCgxLCAnc3dhcm0tbWFuaWZlc3QnLCBtdWx0aWhhc2gpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuZXcgQ0lEKHZhbHVlKS50b1YxKCkuYnl0ZXM7XG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSlcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgLy8gUmVwcmVzZW50IElQTlMgbmFtZSBhcyBhIENJRCB3aXRoIGxpYnAycC1rZXkgY29kZWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL3NwZWNzL2Jsb2IvbWFzdGVyL1JGQy8wMDAxLXRleHQtcGVlcmlkLWNpZC5tZFxuICAgIHJldHVybiBuZXcgQ0lEKDEsICdsaWJwMnAta2V5JywgY2lkLm11bHRpaGFzaCkuYnl0ZXNcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gIH0sXG59O1xuXG4vKiogXG4qIGxpc3Qgb2Yga25vd24gZGVjb2RpbmcsXG4qIGRlY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgQnVmZmVyYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBzdHJpbmdgIHJlc3VsdFxuKi9cbmNvbnN0IGRlY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaGV4TXVsdGlIYXNoOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKTtcbiAgICByZXR1cm4gbXVsdGlILmRlY29kZShjaWQubXVsdGloYXNoKS5kaWdlc3QudG9TdHJpbmcoJ2hleCcpO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpLnRvVjEoKTtcbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKGNpZC5jb2RlYyA9PT0gJ2xpYnAycC1rZXknID8gJ2Jhc2UzNicgOiAnYmFzZTMyJylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcG5zOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKClcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICAvLyBWYWx1ZSBpcyBub3QgYSBsaWJwMnAta2V5LCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgIGNvbnNvbGUud2FybignW2Vuc2RvbWFpbnMvY29udGVudC1oYXNoXSB1c2Ugb2Ygbm9uLWNyeXB0b2dyYXBoaWMgaWRlbnRpZmllcnMgaW4gaXBucy1ucyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQsIG1pZ3JhdGUgdG8gRUQyNTUxOSBsaWJwMnAta2V5JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtdWx0aUguZGVjb2RlKG5ldyBDSUQodmFsdWUpLm11bHRpaGFzaCkuZGlnZXN0KVxuICAgICAgICAvLyBUT0RPOiBzdGFydCB0aHJvd2luZyBhbiBlcnJvciAoYWZ0ZXIgc29tZSBkZXByZWNhdGlvbiBwZXJpb2QpXG4gICAgICAgIC8vIHRocm93IEVycm9yKCdpcG5zLW5zIGFsbG93cyBvbmx5IHZhbGlkIGNyeXB0b2dyYXBoaWMgbGlicDJwLWtleSBpZGVudGlmaWVycywgdHJ5IHVzaW5nIEVEMjU1MTkgcHVia2V5IGluc3RlYWQnKVxuICAgIH1cbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKCdiYXNlMzYnKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIHV0Zjg6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuICB9LFxuICBiYXNlNjQ6ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGB0cnVlYCBvcHRpb24gbWFrZXMgaXQgVVJMIHNhZmUgKHJlcGxhY2VzIC8gYW5kICsgd2l0aCAtIGFuZCBfIClcbiAgICByZXR1cm4gYmFzZTY0LmZyb21VaW50OEFycmF5KHZhbHVlLCB0cnVlKVxuICB9XG59O1xuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZy9kZWNvZGluZyBmb3IgYSBnaXZlbiBjb2RlYyxcbiogYGVuY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGVuY29kZXNgIGZ1bmN0aW9uc1xuKiBgZGVjb2RlYCBzaG91bGQgYmUgY2hvc2VuIGFtb25nIHRoZSBgZGVjb2Rlc2AgZnVuY3Rpb25zXG4qL1xuY29uc3QgcHJvZmlsZXMgPSB7XG4gICdza3luZXQtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnNreW5ldCxcbiAgICBkZWNvZGU6IGRlY29kZXMuYmFzZTY0LFxuICB9LFxuICAnc3dhcm0tbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnN3YXJtLFxuICAgIGRlY29kZTogZGVjb2Rlcy5oZXhNdWx0aUhhc2gsXG4gIH0sXG4gICdpcGZzLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5pcGZzLFxuICAgIGRlY29kZTogZGVjb2Rlcy5pcGZzLFxuICB9LFxuICAnaXBucy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBucyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBucyxcbiAgfSxcbiAgJ2RlZmF1bHQnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnV0ZjgsXG4gICAgZGVjb2RlOiBkZWNvZGVzLnV0ZjgsXG4gIH0sXG59O1xuXG5leHBvcnRzLmhleFN0cmluZ1RvQnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXI7XG5leHBvcnRzLnByb2ZpbGVzID0gcHJvZmlsZXM7XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBtdWx0aWNvZGVjIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtdWx0aWNvZGVjXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuICpcbiAqIGNvbnN0IHByZWZpeGVkUHJvdG9idWYgPSBtdWx0aWNvZGVjLmFkZFByZWZpeCgncHJvdG9idWYnLCBwcm90b2J1ZkJ1ZmZlcilcbiAqIC8vIHByZWZpeGVkUHJvdG9idWYgMHg1MC4uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTnVtYmVyfSBDb2RlY051bWJlciAqL1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgaW50VGFibGUgPSByZXF1aXJlKCcuL2ludC10YWJsZScpXG5jb25zdCBjb2RlY05hbWVUb0NvZGVWYXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC10YWJsZScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHVpbnQ4QXJyYXlDb25jYXQgPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG4vKipcbiAqIFByZWZpeCBhIGJ1ZmZlciB3aXRoIGEgbXVsdGljb2RlYy1wYWNrZWQuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV8VWludDhBcnJheX0gbXVsdGljb2RlY1N0ck9yQ29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gYWRkUHJlZml4IChtdWx0aWNvZGVjU3RyT3JDb2RlLCBkYXRhKSB7XG4gIGxldCBwcmVmaXhcblxuICBpZiAobXVsdGljb2RlY1N0ck9yQ29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBwcmVmaXggPSB1dGlsLnZhcmludFVpbnQ4QXJyYXlFbmNvZGUobXVsdGljb2RlY1N0ck9yQ29kZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29kZWNOYW1lVG9Db2RlVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdKSB7XG4gICAgICBwcmVmaXggPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWNvZGVjIG5vdCByZWNvZ25pemVkJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW3ByZWZpeCwgZGF0YV0sIHByZWZpeC5sZW5ndGggKyBkYXRhLmxlbmd0aClcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZSB0aGUgbXVsdGljb2RlYy1wYWNrZWQgcHJlZml4IGZyb20gdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gcm1QcmVmaXggKGRhdGEpIHtcbiAgdmFyaW50LmRlY29kZShkYXRhKVxuICByZXR1cm4gZGF0YS5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVjIChwcmVmaXhlZERhdGEpIHtcbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUocHJlZml4ZWREYXRhKVxuICBjb25zdCBjb2RlY05hbWUgPSBpbnRUYWJsZS5nZXQoY29kZSlcbiAgaWYgKGNvZGVjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlICR7Y29kZX0gbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gY29kZWNOYW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2RlYy5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTnVtYmVyfSBjb2RlY1xuICogQHJldHVybnMge0NvZGVjTmFtZXx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUgKGNvZGVjKSB7XG4gIHJldHVybiBpbnRUYWJsZS5nZXQoY29kZWMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBjb2RlY1xuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7Q29kZWNOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlciAobmFtZSkge1xuICBjb25zdCBjb2RlID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgbmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIHZhcmludC5kZWNvZGUoY29kZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZSAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gY29kZWNOYW1lXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZVZhcmludCAoY29kZWNOYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbY29kZWNOYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYyBgJyArIGNvZGVjTmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb2RlY051bWJlcn0gY29kZVxuICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnQgKGNvZGUpIHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGUoY29kZSlcbn1cblxuLy8gTWFrZSB0aGUgY29uc3RhbnRzIHRvcC1sZXZlbCBjb25zdGFudHNcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gSHVtYW4gZnJpZW5kbHkgbmFtZXMgZm9yIHByaW50aW5nLCBlLmcuIGluIGVycm9yIG1lc3NhZ2VzXG5jb25zdCBwcmludCA9IHJlcXVpcmUoJy4vcHJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkUHJlZml4LFxuICBybVByZWZpeCxcbiAgZ2V0Q29kZWMsXG4gIGdldE5hbWUsXG4gIGdldE51bWJlcixcbiAgZ2V0Q29kZSxcbiAgZ2V0Q29kZVZhcmludCxcbiAgZ2V0VmFyaW50LFxuICBwcmludCxcbiAgLi4uY29uc3RhbnRzXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImFuYWx5dGljcy1ub2RlXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuNC4wLWJldGEuM1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhhc3NsZS1mcmVlIHdheSB0byBpbnRlZ3JhdGUgYW5hbHl0aWNzIGludG8gYW55IE5vZGUuanMgYXBwbGljYXRpb25cIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwicmVwb3NpdG9yeVwiOiBcInNlZ21lbnRpby9hbmFseXRpY3Mtbm9kZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VnbWVudFwiLFxuICAgIFwiZW1haWxcIjogXCJ0b29scytucG1Ac2VnbWVudC5jb21cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vc2VnbWVudC5jb21cIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NFwiXG4gIH0sXG4gIFwic2l6ZS1saW1pdFwiOiBbXG4gICAge1xuICAgICAgXCJsaW1pdFwiOiBcIjI1IEtCXCIsXG4gICAgICBcInBhdGhcIjogXCJpbmRleC5qc1wiXG4gICAgfVxuICBdLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiY2lyY2xlLWxpbnRcIjogXCIuYnVpbGRzY3JpcHQvY2lyY2xlLnNoXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIjogXCJ5YXJuXCIsXG4gICAgXCJzaXplXCI6IFwic2l6ZS1saW1pdFwiLFxuICAgIFwidGVzdFwiOiBcInN0YW5kYXJkICYmIG55YyBhdmEgLS10aW1lb3V0PTIwcyYmIC5idWlsZHNjcmlwdC9lMmUuc2hcIixcbiAgICBcInJlcG9ydC1jb3ZlcmFnZVwiOiBcIm55YyByZXBvcnQgLS1yZXBvcnRlcj1sY292ID4gY292ZXJhZ2UubGNvdiAmJiBjb2RlY292XCIsXG4gICAgXCJucFwiOiBcIm5wIC0tbm8tcHVibGlzaFwiLFxuICAgIFwicmVsZWFzZVwiOiBcInlhcm4gcnVuIG5wXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJpbmRleC5qc1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiYW5hbHl0aWNzXCIsXG4gICAgXCJzdGF0c1wiLFxuICAgIFwic2VnbWVudC5pb1wiLFxuICAgIFwic2VnbWVudGlvXCIsXG4gICAgXCJzZWdtZW50XCIsXG4gICAgXCJjbGllbnRcIixcbiAgICBcImRyaXZlclwiXG4gIF0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBzZWdtZW50L2xvb3NlbHktdmFsaWRhdGUtZXZlbnRcIjogXCJeMi4wLjBcIixcbiAgICBcImF4aW9zXCI6IFwiXjAuMTkuMlwiLFxuICAgIFwiYXhpb3MtcmV0cnlcIjogXCJeMy4wLjJcIixcbiAgICBcImxvZGFzaC5pc3N0cmluZ1wiOiBcIl40LjAuMVwiLFxuICAgIFwibWQ1XCI6IFwiXjIuMi4xXCIsXG4gICAgXCJtc1wiOiBcIl4yLjAuMFwiLFxuICAgIFwicmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJ1dWlkXCI6IFwiXjMuMi4xXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYXZhXCI6IFwiXjAuMjUuMFwiLFxuICAgIFwiYmFzaWMtYXV0aFwiOiBcIl4yLjAuMVwiLFxuICAgIFwiYm9keS1wYXJzZXJcIjogXCJeMS4xNy4xXCIsXG4gICAgXCJjb2RlY292XCI6IFwiXjMuMC4wXCIsXG4gICAgXCJjb21tYW5kZXJcIjogXCJeMi45LjBcIixcbiAgICBcImRlbGF5XCI6IFwiXjQuMi4wXCIsXG4gICAgXCJleHByZXNzXCI6IFwiXjQuMTUuMlwiLFxuICAgIFwiaHVza3lcIjogXCJeMy4wLjRcIixcbiAgICBcIm55Y1wiOiBcIl4xNC4xLjFcIixcbiAgICBcInBpZnlcIjogXCJeNC4wLjFcIixcbiAgICBcInNpbm9uXCI6IFwiXjcuMy4yXCIsXG4gICAgXCJzaXplLWxpbWl0XCI6IFwiXjEuMy41XCIsXG4gICAgXCJzbnlrXCI6IFwiXjEuMTcxLjFcIixcbiAgICBcInN0YW5kYXJkXCI6IFwiXjEyLjAuMVwiXG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgc2xhc2hlcyBmcm9tIHRoZSBnaXZlbiBgc3RyYFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoZXhwb3J0cy5leHByLCAnJyk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgcmVnZXhcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmV4cG9ydHMuZXhwciA9IC9cXC8rJC87XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvKipcbiAqIGxvZGFzaCA0LjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXHJcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcclxuICAgICAgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKSxcclxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKVxyXG4gICAgICAgIG1lc3NhZ2UgPSBiaW4uc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmIChpc0J1ZmZlcihtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQgJyArIG1lc3NhZ2UpO1xyXG5cclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcbiIsInZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKVxudmFyIGpvaW4gPSByZXF1aXJlKCdqb2luLWNvbXBvbmVudCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuLy8gU2VnbWVudCBtZXNzYWdlcyBjYW4gYmUgYSBtYXhpbXVtIG9mIDMya2IuXG52YXIgTUFYX1NJWkUgPSAzMiA8PCAxMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb3NlbHlWYWxpZGF0ZUV2ZW50XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gZXZlbnQuXG4gKi9cblxuZnVuY3Rpb24gbG9vc2VseVZhbGlkYXRlRXZlbnQgKGV2ZW50LCB0eXBlKSB7XG4gIHZhbGlkYXRlR2VuZXJpY0V2ZW50KGV2ZW50KVxuICB0eXBlID0gdHlwZSB8fCBldmVudC50eXBlXG4gIGFzc2VydCh0eXBlLCAnWW91IG11c3QgcGFzcyBhbiBldmVudCB0eXBlLicpXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgIHJldHVybiB2YWxpZGF0ZVRyYWNrRXZlbnQoZXZlbnQpXG4gICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgcmV0dXJuIHZhbGlkYXRlR3JvdXBFdmVudChldmVudClcbiAgICBjYXNlICdpZGVudGlmeSc6XG4gICAgICByZXR1cm4gdmFsaWRhdGVJZGVudGlmeUV2ZW50KGV2ZW50KVxuICAgIGNhc2UgJ3BhZ2UnOlxuICAgICAgcmV0dXJuIHZhbGlkYXRlUGFnZUV2ZW50KGV2ZW50KVxuICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICByZXR1cm4gdmFsaWRhdGVTY3JlZW5FdmVudChldmVudClcbiAgICBjYXNlICdhbGlhcyc6XG4gICAgICByZXR1cm4gdmFsaWRhdGVBbGlhc0V2ZW50KGV2ZW50KVxuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnQoMCwgJ0ludmFsaWQgZXZlbnQgdHlwZTogXCInICsgdHlwZSArICdcIicpXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIFwidHJhY2tcIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYWNrRXZlbnQgKGV2ZW50KSB7XG4gIGFzc2VydChldmVudC5hbm9ueW1vdXNJZCB8fCBldmVudC51c2VySWQsICdZb3UgbXVzdCBwYXNzIGVpdGhlciBhbiBcImFub255bW91c0lkXCIgb3IgYSBcInVzZXJJZFwiLicpXG4gIGFzc2VydChldmVudC5ldmVudCwgJ1lvdSBtdXN0IHBhc3MgYW4gXCJldmVudFwiLicpXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSBcImdyb3VwXCIgZXZlbnQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVHcm91cEV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxuICBhc3NlcnQoZXZlbnQuZ3JvdXBJZCwgJ1lvdSBtdXN0IHBhc3MgYSBcImdyb3VwSWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgXCJpZGVudGlmeVwiIGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlSWRlbnRpZnlFdmVudCAoZXZlbnQpIHtcbiAgYXNzZXJ0KGV2ZW50LmFub255bW91c0lkIHx8IGV2ZW50LnVzZXJJZCwgJ1lvdSBtdXN0IHBhc3MgZWl0aGVyIGFuIFwiYW5vbnltb3VzSWRcIiBvciBhIFwidXNlcklkXCIuJylcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIFwicGFnZVwiIGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFnZUV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgXCJzY3JlZW5cIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVNjcmVlbkV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIFwiYWxpYXNcIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFsaWFzRXZlbnQgKGV2ZW50KSB7XG4gIGFzc2VydChldmVudC51c2VySWQsICdZb3UgbXVzdCBwYXNzIGEgXCJ1c2VySWRcIi4nKVxuICBhc3NlcnQoZXZlbnQucHJldmlvdXNJZCwgJ1lvdSBtdXN0IHBhc3MgYSBcInByZXZpb3VzSWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRpb24gcnVsZXMuXG4gKi9cblxudmFyIGdlbmVyaWNWYWxpZGF0aW9uUnVsZXMgPSB7XG4gIGFub255bW91c0lkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICBjYXRlZ29yeTogJ3N0cmluZycsXG4gIGNvbnRleHQ6ICdvYmplY3QnLFxuICBldmVudDogJ3N0cmluZycsXG4gIGdyb3VwSWQ6IFsgJ3N0cmluZycsICdudW1iZXInIF0sXG4gIGludGVncmF0aW9uczogJ29iamVjdCcsXG4gIG5hbWU6ICdzdHJpbmcnLFxuICBwcmV2aW91c0lkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICB0aW1lc3RhbXA6ICdkYXRlJyxcbiAgdXNlcklkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICB0eXBlOiAnc3RyaW5nJ1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGV2ZW50IG9iamVjdC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUdlbmVyaWNFdmVudCAoZXZlbnQpIHtcbiAgYXNzZXJ0KHR5cGUoZXZlbnQpID09PSAnb2JqZWN0JywgJ1lvdSBtdXN0IHBhc3MgYSBtZXNzYWdlIG9iamVjdC4nKVxuICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KVxuICAvLyBTdHJpbmdzIGFyZSB2YXJpYWJsZSBieXRlIGVuY29kZWQsIHNvIGpzb24ubGVuZ3RoIGlzIG5vdCBzdWZmaWNpZW50LlxuICBhc3NlcnQoQnVmZmVyLmJ5dGVMZW5ndGgoanNvbiwgJ3V0ZjgnKSA8IE1BWF9TSVpFLCAnWW91ciBtZXNzYWdlIG11c3QgYmUgPCAzMmtiLicpXG5cbiAgZm9yICh2YXIga2V5IGluIGdlbmVyaWNWYWxpZGF0aW9uUnVsZXMpIHtcbiAgICB2YXIgdmFsID0gZXZlbnRba2V5XVxuICAgIGlmICghdmFsKSBjb250aW51ZVxuICAgIHZhciBydWxlID0gZ2VuZXJpY1ZhbGlkYXRpb25SdWxlc1trZXldXG4gICAgaWYgKHR5cGUocnVsZSkgIT09ICdhcnJheScpIHtcbiAgICAgIHJ1bGUgPSBbIHJ1bGUgXVxuICAgIH1cbiAgICB2YXIgYSA9IHJ1bGVbMF0gPT09ICdvYmplY3QnID8gJ2FuJyA6ICdhJ1xuICAgIGFzc2VydChcbiAgICAgIHJ1bGUuc29tZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gdHlwZSh2YWwpID09PSBlIH0pLFxuICAgICAgJ1wiJyArIGtleSArICdcIiBtdXN0IGJlICcgKyBhICsgJyAnICsgam9pbihydWxlLCAnb3InKSArICcuJ1xuICAgIClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpLmRlZmF1bHQ7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBleHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG5leHBvcnRzLkJOID0gQk47XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbmV4cG9ydHMucmxwID0gcmxwO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBldGhqc1V0aWwpO1xuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFB1YmxpYy1rZXkgY3J5cHRvZ3JhcGh5IChzZWNwMjU2azEpIGFuZCBhZGRyZXNzZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIYXNoIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEVDRFNBIHNpZ25hdHVyZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRnVuY3Rpb24gZm9yIGRlZmluaW5pbmcgcHJvcGVydGllcyBvbiBhbiBvYmplY3RcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgcGJrZGYyU3luYyA9IHJlcXVpcmUoJ3Bia2RmMicpLnBia2RmMlN5bmNcblxudmFyIE1BWF9WQUxVRSA9IDB4N2ZmZmZmZmZcblxuLy8gTiA9IENwdSBjb3N0LCByID0gTWVtb3J5IGNvc3QsIHAgPSBwYXJhbGxlbGl6YXRpb24gY29zdFxuZnVuY3Rpb24gc2NyeXB0IChrZXksIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIGlmIChOID09PSAwIHx8IChOICYgKE4gLSAxKSkgIT09IDApIHRocm93IEVycm9yKCdOIG11c3QgYmUgPiAwIGFuZCBhIHBvd2VyIG9mIDInKVxuXG4gIGlmIChOID4gTUFYX1ZBTFVFIC8gMTI4IC8gcikgdGhyb3cgRXJyb3IoJ1BhcmFtZXRlciBOIGlzIHRvbyBsYXJnZScpXG4gIGlmIChyID4gTUFYX1ZBTFVFIC8gMTI4IC8gcCkgdGhyb3cgRXJyb3IoJ1BhcmFtZXRlciByIGlzIHRvbyBsYXJnZScpXG5cbiAgdmFyIFhZID0gbmV3IEJ1ZmZlcigyNTYgKiByKVxuICB2YXIgViA9IG5ldyBCdWZmZXIoMTI4ICogciAqIE4pXG5cbiAgLy8gcHNldWRvIGdsb2JhbFxuICB2YXIgQjMyID0gbmV3IEludDMyQXJyYXkoMTYpIC8vIHNhbHNhMjBfOFxuICB2YXIgeCA9IG5ldyBJbnQzMkFycmF5KDE2KSAvLyBzYWxzYTIwXzhcbiAgdmFyIF9YID0gbmV3IEJ1ZmZlcig2NCkgLy8gYmxvY2ttaXhfc2Fsc2E4XG5cbiAgLy8gcHNldWRvIGdsb2JhbFxuICB2YXIgQiA9IHBia2RmMlN5bmMoa2V5LCBzYWx0LCAxLCBwICogMTI4ICogciwgJ3NoYTI1NicpXG5cbiAgdmFyIHRpY2tDYWxsYmFja1xuICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHZhciB0b3RhbE9wcyA9IHAgKiBOICogMlxuICAgIHZhciBjdXJyZW50T3AgPSAwXG5cbiAgICB0aWNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICArK2N1cnJlbnRPcFxuXG4gICAgICAvLyBzZW5kIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgb25jZSBldmVyeSAxLDAwMCBvcHNcbiAgICAgIGlmIChjdXJyZW50T3AgJSAxMDAwID09PSAwKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRPcCxcbiAgICAgICAgICB0b3RhbDogdG90YWxPcHMsXG4gICAgICAgICAgcGVyY2VudDogKGN1cnJlbnRPcCAvIHRvdGFsT3BzKSAqIDEwMC4wXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwOyBpKyspIHtcbiAgICBzbWl4KEIsIGkgKiAxMjggKiByLCByLCBOLCBWLCBYWSlcbiAgfVxuXG4gIHJldHVybiBwYmtkZjJTeW5jKGtleSwgQiwgMSwgZGtMZW4sICdzaGEyNTYnKVxuXG4gIC8vIGFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgYXJlIGFjdHVhbGx5IG1vdmVkIHRvIHRoZSB0b3BcbiAgLy8gZHVlIHRvIGZ1bmN0aW9uIGhvaXN0aW5nXG5cbiAgZnVuY3Rpb24gc21peCAoQiwgQmksIHIsIE4sIFYsIFhZKSB7XG4gICAgdmFyIFhpID0gMFxuICAgIHZhciBZaSA9IDEyOCAqIHJcbiAgICB2YXIgaVxuXG4gICAgQi5jb3B5KFhZLCBYaSwgQmksIEJpICsgWWkpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBYWS5jb3B5KFYsIGkgKiBZaSwgWGksIFhpICsgWWkpXG4gICAgICBibG9ja21peF9zYWxzYTgoWFksIFhpLCBZaSwgcilcblxuICAgICAgaWYgKHRpY2tDYWxsYmFjaykgdGlja0NhbGxiYWNrKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gWGkgKyAoMiAqIHIgLSAxKSAqIDY0XG4gICAgICB2YXIgaiA9IFhZLnJlYWRVSW50MzJMRShvZmZzZXQpICYgKE4gLSAxKVxuICAgICAgYmxvY2t4b3IoViwgaiAqIFlpLCBYWSwgWGksIFlpKVxuICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBYaSwgWWksIHIpXG5cbiAgICAgIGlmICh0aWNrQ2FsbGJhY2spIHRpY2tDYWxsYmFjaygpXG4gICAgfVxuXG4gICAgWFkuY29weShCLCBCaSwgWGksIFhpICsgWWkpXG4gIH1cblxuICBmdW5jdGlvbiBibG9ja21peF9zYWxzYTggKEJZLCBCaSwgWWksIHIpIHtcbiAgICB2YXIgaVxuXG4gICAgYXJyYXljb3B5KEJZLCBCaSArICgyICogciAtIDEpICogNjQsIF9YLCAwLCA2NClcblxuICAgIGZvciAoaSA9IDA7IGkgPCAyICogcjsgaSsrKSB7XG4gICAgICBibG9ja3hvcihCWSwgaSAqIDY0LCBfWCwgMCwgNjQpXG4gICAgICBzYWxzYTIwXzgoX1gpXG4gICAgICBhcnJheWNvcHkoX1gsIDAsIEJZLCBZaSArIChpICogNjQpLCA2NClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyKSAqIDY0LCBCWSwgQmkgKyAoaSAqIDY0KSwgNjQpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMiArIDEpICogNjQsIEJZLCBCaSArIChpICsgcikgKiA2NCwgNjQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gUiAoYSwgYikge1xuICAgIHJldHVybiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbHNhMjBfOCAoQikge1xuICAgIHZhciBpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgQjMyW2ldID0gKEJbaSAqIDQgKyAwXSAmIDB4ZmYpIDw8IDBcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDFdICYgMHhmZikgPDwgOFxuICAgICAgQjMyW2ldIHw9IChCW2kgKiA0ICsgMl0gJiAweGZmKSA8PCAxNlxuICAgICAgQjMyW2ldIHw9IChCW2kgKiA0ICsgM10gJiAweGZmKSA8PCAyNFxuICAgICAgLy8gQjMyW2ldID0gQi5yZWFkVUludDMyTEUoaSo0KSAgIDwtLS0gdGhpcyBpcyBzaWduZmljYW50bHkgc2xvd2VyIGV2ZW4gaW4gTm9kZS5qc1xuICAgIH1cblxuICAgIGFycmF5Y29weShCMzIsIDAsIHgsIDAsIDE2KVxuXG4gICAgZm9yIChpID0gODsgaSA+IDA7IGkgLT0gMikge1xuICAgICAgeFsgNF0gXj0gUih4WyAwXSArIHhbMTJdLCA3KVxuICAgICAgeFsgOF0gXj0gUih4WyA0XSArIHhbIDBdLCA5KVxuICAgICAgeFsxMl0gXj0gUih4WyA4XSArIHhbIDRdLCAxMylcbiAgICAgIHhbIDBdIF49IFIoeFsxMl0gKyB4WyA4XSwgMTgpXG4gICAgICB4WyA5XSBePSBSKHhbIDVdICsgeFsgMV0sIDcpXG4gICAgICB4WzEzXSBePSBSKHhbIDldICsgeFsgNV0sIDkpXG4gICAgICB4WyAxXSBePSBSKHhbMTNdICsgeFsgOV0sIDEzKVxuICAgICAgeFsgNV0gXj0gUih4WyAxXSArIHhbMTNdLCAxOClcbiAgICAgIHhbMTRdIF49IFIoeFsxMF0gKyB4WyA2XSwgNylcbiAgICAgIHhbIDJdIF49IFIoeFsxNF0gKyB4WzEwXSwgOSlcbiAgICAgIHhbIDZdIF49IFIoeFsgMl0gKyB4WzE0XSwgMTMpXG4gICAgICB4WzEwXSBePSBSKHhbIDZdICsgeFsgMl0sIDE4KVxuICAgICAgeFsgM10gXj0gUih4WzE1XSArIHhbMTFdLCA3KVxuICAgICAgeFsgN10gXj0gUih4WyAzXSArIHhbMTVdLCA5KVxuICAgICAgeFsxMV0gXj0gUih4WyA3XSArIHhbIDNdLCAxMylcbiAgICAgIHhbMTVdIF49IFIoeFsxMV0gKyB4WyA3XSwgMTgpXG4gICAgICB4WyAxXSBePSBSKHhbIDBdICsgeFsgM10sIDcpXG4gICAgICB4WyAyXSBePSBSKHhbIDFdICsgeFsgMF0sIDkpXG4gICAgICB4WyAzXSBePSBSKHhbIDJdICsgeFsgMV0sIDEzKVxuICAgICAgeFsgMF0gXj0gUih4WyAzXSArIHhbIDJdLCAxOClcbiAgICAgIHhbIDZdIF49IFIoeFsgNV0gKyB4WyA0XSwgNylcbiAgICAgIHhbIDddIF49IFIoeFsgNl0gKyB4WyA1XSwgOSlcbiAgICAgIHhbIDRdIF49IFIoeFsgN10gKyB4WyA2XSwgMTMpXG4gICAgICB4WyA1XSBePSBSKHhbIDRdICsgeFsgN10sIDE4KVxuICAgICAgeFsxMV0gXj0gUih4WzEwXSArIHhbIDldLCA3KVxuICAgICAgeFsgOF0gXj0gUih4WzExXSArIHhbMTBdLCA5KVxuICAgICAgeFsgOV0gXj0gUih4WyA4XSArIHhbMTFdLCAxMylcbiAgICAgIHhbMTBdIF49IFIoeFsgOV0gKyB4WyA4XSwgMTgpXG4gICAgICB4WzEyXSBePSBSKHhbMTVdICsgeFsxNF0sIDcpXG4gICAgICB4WzEzXSBePSBSKHhbMTJdICsgeFsxNV0sIDkpXG4gICAgICB4WzE0XSBePSBSKHhbMTNdICsgeFsxMl0sIDEzKVxuICAgICAgeFsxNV0gXj0gUih4WzE0XSArIHhbMTNdLCAxOClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgQjMyW2ldID0geFtpXSArIEIzMltpXVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHZhciBiaSA9IGkgKiA0XG4gICAgICBCW2JpICsgMF0gPSAoQjMyW2ldID4+IDAgJiAweGZmKVxuICAgICAgQltiaSArIDFdID0gKEIzMltpXSA+PiA4ICYgMHhmZilcbiAgICAgIEJbYmkgKyAyXSA9IChCMzJbaV0gPj4gMTYgJiAweGZmKVxuICAgICAgQltiaSArIDNdID0gKEIzMltpXSA+PiAyNCAmIDB4ZmYpXG4gICAgICAvLyBCLndyaXRlSW50MzJMRShCMzJbaV0sIGkqNCkgIC8vPC0tLSB0aGlzIGlzIHNpZ25maWNhbnRseSBzbG93ZXIgZXZlbiBpbiBOb2RlLmpzXG4gICAgfVxuICB9XG5cbiAgLy8gbmFpdmUgYXBwcm9hY2guLi4gZ29pbmcgYmFjayB0byBsb29wIHVucm9sbGluZyBtYXkgeWllbGQgYWRkaXRpb25hbCBwZXJmb3JtYW5jZVxuICBmdW5jdGlvbiBibG9ja3hvciAoUywgU2ksIEQsIERpLCBsZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBEW0RpICsgaV0gXj0gU1tTaSArIGldXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5Y29weSAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykgJiYgQnVmZmVyLmlzQnVmZmVyKGRlc3QpKSB7XG4gICAgc3JjLmNvcHkoZGVzdCwgZGVzdFBvcywgc3JjUG9zLCBzcmNQb3MgKyBsZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2NyeXB0XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiY29uc3QgY3JlYXRlU3dhcHBhYmxlUHJveHkgPSByZXF1aXJlKCcuL2NyZWF0ZVN3YXBwYWJsZVByb3h5JylcbmNvbnN0IGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi9jcmVhdGVFdmVudEVtaXR0ZXJQcm94eScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTd2FwcGFibGVQcm94eSxcbiAgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVBc3luY01pZGRsZXdhcmUsIG1lcmdlTWlkZGxld2FyZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQge1xuICBjcmVhdGVGZXRjaE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlLFxuICBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSxcbiAgY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSxcbiAgcHJvdmlkZXJGcm9tTWlkZGxld2FyZSxcbn0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrVHJhY2tlciB9IGZyb20gJ2V0aC1ibG9jay10cmFja2VyJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5cbmNvbnN0IGluVGVzdCA9IHByb2Nlc3MuZW52LklOX1RFU1Q7XG5jb25zdCBibG9ja1RyYWNrZXJPcHRzID0gaW5UZXN0ID8geyBwb2xsaW5nSW50ZXJ2YWw6IFNFQ09ORCB9IDoge307XG5jb25zdCBnZXRUZXN0TWlkZGxld2FyZXMgPSAoKSA9PiB7XG4gIHJldHVybiBpblRlc3QgPyBbY3JlYXRlRXN0aW1hdGVHYXNEZWxheVRlc3RNaWRkbGV3YXJlKCldIDogW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVKc29uUnBjQ2xpZW50KHsgcnBjVXJsLCBjaGFpbklkIH0pIHtcbiAgY29uc3QgZmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKHsgcnBjVXJsIH0pO1xuICBjb25zdCBibG9ja1Byb3ZpZGVyID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShmZXRjaE1pZGRsZXdhcmUpO1xuICBjb25zdCBibG9ja1RyYWNrZXIgPSBuZXcgUG9sbGluZ0Jsb2NrVHJhY2tlcih7XG4gICAgLi4uYmxvY2tUcmFja2VyT3B0cyxcbiAgICBwcm92aWRlcjogYmxvY2tQcm92aWRlcixcbiAgfSk7XG5cbiAgY29uc3QgbmV0d29ya01pZGRsZXdhcmUgPSBtZXJnZU1pZGRsZXdhcmUoW1xuICAgIC4uLmdldFRlc3RNaWRkbGV3YXJlcygpLFxuICAgIGNyZWF0ZUNoYWluSWRNaWRkbGV3YXJlKGNoYWluSWQpLFxuICAgIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSxcbiAgICBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyIH0pLFxuICAgIGZldGNoTWlkZGxld2FyZSxcbiAgXSk7XG5cbiAgcmV0dXJuIHsgbmV0d29ya01pZGRsZXdhcmUsIGJsb2NrVHJhY2tlciB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbklkTWlkZGxld2FyZShjaGFpbklkKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGlmIChyZXEubWV0aG9kID09PSAnZXRoX2NoYWluSWQnKSB7XG4gICAgICByZXMucmVzdWx0ID0gY2hhaW5JZDtcbiAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3IgdXNlIGluIHRlc3RzIG9ubHkuXG4gKiBBZGRzIGEgZGVsYXkgdG8gYGV0aF9lc3RpbWF0ZUdhc2AgY2FsbHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVzdGltYXRlR2FzRGVsYXlUZXN0TWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCBfLCBuZXh0KSA9PiB7XG4gICAgaWYgKHJlcS5tZXRob2QgPT09ICdldGhfZXN0aW1hdGVHYXMnKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBTRUNPTkQgKiAyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLCBtZXJnZU1pZGRsZXdhcmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlLFxuICBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlLFxuICBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSxcbiAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUsXG4gIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsXG59IGZyb20gJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlJztcblxuaW1wb3J0IGNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgZnJvbSAnZXRoLWpzb24tcnBjLWluZnVyYSc7XG5pbXBvcnQgeyBQb2xsaW5nQmxvY2tUcmFja2VyIH0gZnJvbSAnZXRoLWJsb2NrLXRyYWNrZXInO1xuXG5pbXBvcnQgeyBORVRXT1JLX1RZUEVfVE9fSURfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSW5mdXJhQ2xpZW50KHsgbmV0d29yaywgcHJvamVjdElkIH0pIHtcbiAgY29uc3QgaW5mdXJhTWlkZGxld2FyZSA9IGNyZWF0ZUluZnVyYU1pZGRsZXdhcmUoe1xuICAgIG5ldHdvcmssXG4gICAgcHJvamVjdElkLFxuICAgIG1heEF0dGVtcHRzOiA1LFxuICAgIHNvdXJjZTogJ21ldGFtYXNrJyxcbiAgfSk7XG4gIGNvbnN0IGluZnVyYVByb3ZpZGVyID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShpbmZ1cmFNaWRkbGV3YXJlKTtcbiAgY29uc3QgYmxvY2tUcmFja2VyID0gbmV3IFBvbGxpbmdCbG9ja1RyYWNrZXIoeyBwcm92aWRlcjogaW5mdXJhUHJvdmlkZXIgfSk7XG5cbiAgY29uc3QgbmV0d29ya01pZGRsZXdhcmUgPSBtZXJnZU1pZGRsZXdhcmUoW1xuICAgIGNyZWF0ZU5ldHdvcmtBbmRDaGFpbklkTWlkZGxld2FyZSh7IG5ldHdvcmsgfSksXG4gICAgY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSxcbiAgICBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlciB9KSxcbiAgICBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCBwcm92aWRlcjogaW5mdXJhUHJvdmlkZXIgfSksXG4gICAgY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciB9KSxcbiAgICBpbmZ1cmFNaWRkbGV3YXJlLFxuICBdKTtcbiAgcmV0dXJuIHsgbmV0d29ya01pZGRsZXdhcmUsIGJsb2NrVHJhY2tlciB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXR3b3JrQW5kQ2hhaW5JZE1pZGRsZXdhcmUoeyBuZXR3b3JrIH0pIHtcbiAgaWYgKCFORVRXT1JLX1RZUEVfVE9fSURfTUFQW25ldHdvcmtdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVJbmZ1cmFDbGllbnQgLSB1bmtub3duIG5ldHdvcmsgXCIke25ldHdvcmt9XCJgKTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hhaW5JZCwgbmV0d29ya0lkIH0gPSBORVRXT1JLX1RZUEVfVE9fSURfTUFQW25ldHdvcmtdO1xuXG4gIHJldHVybiBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgIGV0aF9jaGFpbklkOiBjaGFpbklkLFxuICAgIG5ldF92ZXJzaW9uOiBuZXR3b3JrSWQsXG4gIH0pO1xufVxuIiwidmFyIGJhc2U1OCA9IHJlcXVpcmUoJ2JzNTgnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5cbmZ1bmN0aW9uIGVuY29kZSAocGF5bG9hZCwgdmVyc2lvbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSB8fCBwYXlsb2FkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHBheWxvYWQgPSBuZXcgQnVmZmVyKHBheWxvYWQpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmICh2ZXJzaW9uICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IEJ1ZmZlcihbdmVyc2lvbl0pXG4gICAgfVxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ZlcnNpb24sIHBheWxvYWRdKVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IHBheWxvYWRcbiAgfVxuXG4gIHZhciBjaGVja3N1bSA9IHNoYTI1NngyKGJ1Zikuc2xpY2UoMCwgNClcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgY2hlY2tzdW1dKVxuICByZXR1cm4gYmFzZTU4LmVuY29kZShyZXN1bHQpXG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoYmFzZTU4c3RyLCB2ZXJzaW9uKSB7XG4gIHZhciBhcnIgPSBiYXNlNTguZGVjb2RlKGJhc2U1OHN0cilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYXJyKVxuICB2YXIgdmVyc2lvbkxlbmd0aFxuXG4gIGlmICh2ZXJzaW9uID09IG51bGwpIHtcbiAgICB2ZXJzaW9uTGVuZ3RoID0gMFxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHZlcnNpb24gPSBuZXcgQnVmZmVyKFt2ZXJzaW9uXSlcblxuICAgIHZlcnNpb25MZW5ndGggPSB2ZXJzaW9uLmxlbmd0aFxuICAgIHZhciB2ZXJzaW9uQ29tcGFyZSA9IGJ1Zi5zbGljZSgwLCB2ZXJzaW9uTGVuZ3RoKVxuICAgIGlmICh2ZXJzaW9uQ29tcGFyZS50b1N0cmluZygnaGV4JykgIT09IHZlcnNpb24udG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbicpXG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrc3VtID0gYnVmLnNsaWNlKC00KVxuICB2YXIgZW5kUG9zID0gYnVmLmxlbmd0aCAtIDRcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKDAsIGVuZFBvcylcblxuICB2YXIgbmV3Q2hlY2tzdW0gPSBzaGEyNTZ4MihieXRlcykuc2xpY2UoMCwgNClcbiAgaWYgKGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSAhPT0gbmV3Q2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJylcbiAgfVxuXG4gIHJldHVybiBieXRlcy5zbGljZSh2ZXJzaW9uTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkIChiYXNlNThzdHIsIHZlcnNpb24pIHtcbiAgdHJ5IHtcbiAgICBkZWNvZGUoYmFzZTU4c3RyLCB2ZXJzaW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHJldHVybiBlbmNvZGUocGF5bG9hZCwgdmVyc2lvbilcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmFzZTU4c3RyKSB7XG4gICAgcmV0dXJuIGRlY29kZShiYXNlNThzdHIsIHZlcnNpb24pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmFzZTU4c3RyKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQoYmFzZTU4c3RyLCB2ZXJzaW9uKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTI1NngyIChidWZmZXIpIHtcbiAgdmFyIHNoYSA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhKS5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlLFxuICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICBjcmVhdGVFbmNvZGVyOiBjcmVhdGVFbmNvZGVyLFxuICBjcmVhdGVEZWNvZGVyOiBjcmVhdGVEZWNvZGVyLFxuICBjcmVhdGVWYWxpZGF0b3I6IGNyZWF0ZVZhbGlkYXRvclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoJ2tlY2NhaycpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsnICsgYml0cykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBleHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gZXhwb3J0cy5ibG9ja1RhZ0ZvclBheWxvYWQgPSBleHBvcnRzLmNhbkNhY2hlID0gZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QganNvbl9zdGFibGVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKSk7XG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHNraXBCbG9ja1JlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaW1wbGVQYXJhbXMgPSBza2lwQmxvY2tSZWZcbiAgICAgICAgPyBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgICAgICAgOiAoX2EgPSBwYXlsb2FkLnBhcmFtcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKGNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBgJHtwYXlsb2FkLm1ldGhvZH06JHsoMCwganNvbl9zdGFibGVfc3RyaW5naWZ5XzEuZGVmYXVsdCkoc2ltcGxlUGFyYW1zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQ7XG5mdW5jdGlvbiBjYW5DYWNoZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkgIT09ICduZXZlcic7XG59XG5leHBvcnRzLmNhbkNhY2hlID0gY2FuQ2FjaGU7XG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGJsb2NrVGFnRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbmV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gcGFyYW1zV2l0aG91dEJsb2NrVGFnO1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDJcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMFxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gYmxvY2tUYWdcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXg7XG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAncGVybWEnO1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdmb3JrJztcbiAgICAgICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICAgICAgY2FzZSAndGVzdF9ibG9ja0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICduZXZlcic7XG4gICAgfVxufVxuZXhwb3J0cy5jYWNoZVR5cGVGb3JQYXlsb2FkID0gY2FjaGVUeXBlRm9yUGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNvbmNhdFNpZzogZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gJyByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCkgKyAnOiAnICsgaW5wdXRcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduOiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIHZhciBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgdmFyIHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlOiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXk6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIHJldHVybiAnMHgnICsgcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIHR5cGVkU2lnbmF0dXJlSGFzaDogZnVuY3Rpb24gKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YTogZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmU6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gZXRoVXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gZXRoQWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZXRoVXRpbC50b0J1ZmZlcihzaWcpXG4gIGNvbnN0IHNpZ1BhcmFtcyA9IGV0aFV0aWwuZnJvbVJwY1NpZyhzaWduYXR1cmUpXG4gIHJldHVybiBldGhVdGlsLmVjcmVjb3ZlcihoYXNoLCBzaWdQYXJhbXMudiwgc2lnUGFyYW1zLnIsIHNpZ1BhcmFtcy5zKVxufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IgKG1zZ1BhcmFtcykge1xuICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgY29uc3QgbXNnSGFzaCA9IGV0aFV0aWwuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKVxuICByZXR1cm4gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxufVxuXG5cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMgKG51bWJlciwgbGVuZ3RoKSB7XG4gIHZhciBteVN0cmluZyA9ICcnICsgbnVtYmVyXG4gIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBteVN0cmluZyA9ICcwJyArIG15U3RyaW5nXG4gIH1cbiAgcmV0dXJuIG15U3RyaW5nXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKiBBUEkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FuY2VsbGF0aW9uUmVhc29uVG9TdGF0dXNNYXAgPSBleHBvcnRzLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcyA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbiA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHggPSBleHBvcnRzLkFQSVR5cGUgPSB2b2lkIDA7XG52YXIgQVBJVHlwZTtcbihmdW5jdGlvbiAoQVBJVHlwZSkge1xuICAgIEFQSVR5cGVbQVBJVHlwZVtcIkdFVF9GRUVTXCJdID0gMF0gPSBcIkdFVF9GRUVTXCI7XG4gICAgQVBJVHlwZVtBUElUeXBlW1wiRVNUSU1BVEVfR0FTXCJdID0gMV0gPSBcIkVTVElNQVRFX0dBU1wiO1xuICAgIEFQSVR5cGVbQVBJVHlwZVtcIlNVQk1JVF9UUkFOU0FDVElPTlNcIl0gPSAyXSA9IFwiU1VCTUlUX1RSQU5TQUNUSU9OU1wiO1xuICAgIEFQSVR5cGVbQVBJVHlwZVtcIkNBTkNFTFwiXSA9IDNdID0gXCJDQU5DRUxcIjtcbiAgICBBUElUeXBlW0FQSVR5cGVbXCJCQVRDSF9TVEFUVVNcIl0gPSA0XSA9IFwiQkFUQ0hfU1RBVFVTXCI7XG4gICAgQVBJVHlwZVtBUElUeXBlW1wiTElWRU5FU1NcIl0gPSA1XSA9IFwiTElWRU5FU1NcIjtcbn0pKEFQSVR5cGUgPSBleHBvcnRzLkFQSVR5cGUgfHwgKGV4cG9ydHMuQVBJVHlwZSA9IHt9KSk7XG4vKiogU21hcnRUcmFuc2FjdGlvbnMgKi9cbnZhciBTbWFydFRyYW5zYWN0aW9uTWluZWRUeDtcbihmdW5jdGlvbiAoU21hcnRUcmFuc2FjdGlvbk1pbmVkVHgpIHtcbiAgICBTbWFydFRyYW5zYWN0aW9uTWluZWRUeFtcIk5PVF9NSU5FRFwiXSA9IFwibm90X21pbmVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbk1pbmVkVHhbXCJTVUNDRVNTXCJdID0gXCJzdWNjZXNzXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbk1pbmVkVHhbXCJDQU5DRUxMRURcIl0gPSBcImNhbmNlbGxlZFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4W1wiUkVWRVJURURcIl0gPSBcInJldmVydGVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbk1pbmVkVHhbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XG59KShTbWFydFRyYW5zYWN0aW9uTWluZWRUeCA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHggfHwgKGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHggPSB7fSkpO1xudmFyIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb247XG4oZnVuY3Rpb24gKFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24pIHtcbiAgICBTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uW1wiV09VTERfUkVWRVJUXCJdID0gXCJ3b3VsZF9yZXZlcnRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uW1wiVE9PX0NIRUFQXCJdID0gXCJ0b29fY2hlYXBcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uW1wiREVBRExJTkVfTUlTU0VEXCJdID0gXCJkZWFkbGluZV9taXNzZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uW1wiSU5WQUxJRF9OT05DRVwiXSA9IFwiaW52YWxpZF9ub25jZVwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJVU0VSX0NBTkNFTExFRFwiXSA9IFwidXNlcl9jYW5jZWxsZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uW1wiTk9UX0NBTkNFTExFRFwiXSA9IFwibm90X2NhbmNlbGxlZFwiO1xufSkoU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbiA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbiB8fCAoZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uID0ge30pKTtcbnZhciBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXM7XG4oZnVuY3Rpb24gKFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcykge1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJTVUNDRVNTXCJdID0gXCJzdWNjZXNzXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiUkVWRVJURURcIl0gPSBcInJldmVydGVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIkNBTkNFTExFRF9XT1VMRF9SRVZFUlRcIl0gPSBcImNhbmNlbGxlZF93b3VsZF9yZXZlcnRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJDQU5DRUxMRURfVE9PX0NIRUFQXCJdID0gXCJjYW5jZWxsZWRfdG9vX2NoZWFwXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiQ0FOQ0VMTEVEX0RFQURMSU5FX01JU1NFRFwiXSA9IFwiY2FuY2VsbGVkX2RlYWRsaW5lX21pc3NlZFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIkNBTkNFTExFRF9JTlZBTElEX05PTkNFXCJdID0gXCJjYW5jZWxsZWRfaW52YWxpZF9ub25jZVwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIkNBTkNFTExFRF9VU0VSX0NBTkNFTExFRFwiXSA9IFwiY2FuY2VsbGVkX3VzZXJfY2FuY2VsbGVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiUkVTT0xWRURcIl0gPSBcInJlc29sdmVkXCI7XG59KShTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMgPSBleHBvcnRzLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcyB8fCAoZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMgPSB7fSkpO1xuZXhwb3J0cy5jYW5jZWxsYXRpb25SZWFzb25Ub1N0YXR1c01hcCA9IHtcbiAgICBbU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbi5XT1VMRF9SRVZFUlRdOiBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX1dPVUxEX1JFVkVSVCxcbiAgICBbU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbi5UT09fQ0hFQVBdOiBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX1RPT19DSEVBUCxcbiAgICBbU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbi5ERUFETElORV9NSVNTRURdOiBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX0RFQURMSU5FX01JU1NFRCxcbiAgICBbU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbi5JTlZBTElEX05PTkNFXTogU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLkNBTkNFTExFRF9JTlZBTElEX05PTkNFLFxuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLlVTRVJfQ0FOQ0VMTEVEXTogU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLkNBTkNFTExFRF9VU0VSX0NBTkNFTExFRCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hBSU5fSURTID0gZXhwb3J0cy5BUElfQkFTRV9VUkwgPSB2b2lkIDA7XG5leHBvcnRzLkFQSV9CQVNFX1VSTCA9ICdodHRwczovL3RyYW5zYWN0aW9uLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcbmV4cG9ydHMuQ0hBSU5fSURTID0ge1xuICAgIEVUSEVSRVVNOiAnMHgxJyxcbiAgICBSSU5LRUJZOiAnMHg0JyxcbiAgICBCU0M6ICcweDM4Jyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMC4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjAgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCkge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhbmRsZUZldGNoID0gZXhwb3J0cy5nZXRTdHhQcm9jZXNzaW5nVGltZSA9IGV4cG9ydHMuc25hcHNob3RGcm9tVHhNZXRhID0gZXhwb3J0cy5yZXBsYXlIaXN0b3J5ID0gZXhwb3J0cy5nZW5lcmF0ZUhpc3RvcnlFbnRyeSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RhdHVzID0gZXhwb3J0cy5nZXRBUElSZXF1ZXN0VVJMID0gZXhwb3J0cy5pc1NtYXJ0VHJhbnNhY3Rpb25TdGF0dXNSZXNvbHZlZCA9IGV4cG9ydHMuaXNTbWFydFRyYW5zYWN0aW9uUGVuZGluZyA9IHZvaWQgMDtcbmNvbnN0IGZhc3RfanNvbl9wYXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmYXN0LWpzb24tcGF0Y2hcIikpO1xuY29uc3QgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5mdW5jdGlvbiBpc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nKHNtYXJ0VHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gc21hcnRUcmFuc2FjdGlvbi5zdGF0dXMgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlBFTkRJTkc7XG59XG5leHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblBlbmRpbmcgPSBpc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nO1xuY29uc3QgaXNTbWFydFRyYW5zYWN0aW9uU3RhdHVzUmVzb2x2ZWQgPSAoc3RhdHVzKSA9PiBzdGF0dXMgPT09ICd1dWlkX25vdF9mb3VuZCc7XG5leHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblN0YXR1c1Jlc29sdmVkID0gaXNTbWFydFRyYW5zYWN0aW9uU3RhdHVzUmVzb2x2ZWQ7XG4vLyBUT0RPIHVzZSBhY3R1YWwgdXJsIG9uY2UgQVBJIGlzIGRlZmluZWRcbmZ1bmN0aW9uIGdldEFQSVJlcXVlc3RVUkwoYXBpVHlwZSwgY2hhaW5JZCkge1xuICAgIGNvbnN0IGNoYWluSWREZWMgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgc3dpdGNoIChhcGlUeXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkdFVF9GRUVTOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7Y29uc3RhbnRzXzEuQVBJX0JBU0VfVVJMfS9uZXR3b3Jrcy8ke2NoYWluSWREZWN9L2dldEZlZXNgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkVTVElNQVRFX0dBUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9lc3RpbWF0ZUdhc2A7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlc18xLkFQSVR5cGUuU1VCTUlUX1RSQU5TQUNUSU9OUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9zdWJtaXRUcmFuc2FjdGlvbnNgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkNBTkNFTDoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9jYW5jZWxgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkJBVENIX1NUQVRVUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9iYXRjaFN0YXR1c2A7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlc18xLkFQSVR5cGUuTElWRU5FU1M6IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtjb25zdGFudHNfMS5BUElfQkFTRV9VUkx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY30vaGVhbHRoYDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQVBJVHlwZWApOyAvLyBJdCBjYW4gbmV2ZXIgZ2V0IGhlcmUgdGhhbmtzIHRvIFR5cGVTY3JpcHQuXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmdldEFQSVJlcXVlc3RVUkwgPSBnZXRBUElSZXF1ZXN0VVJMO1xuY29uc3QgY2FsY3VsYXRlU3RhdHVzID0gKHN0YXR1cykgPT4ge1xuICAgIGlmIChleHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblN0YXR1c1Jlc29sdmVkKHN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlJFU09MVkVEO1xuICAgIH1cbiAgICBjb25zdCBjYW5jZWxsYXRpb25zID0gW1xuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uV09VTERfUkVWRVJULFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uVE9PX0NIRUFQLFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uREVBRExJTkVfTUlTU0VELFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uSU5WQUxJRF9OT05DRSxcbiAgICAgICAgdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLlVTRVJfQ0FOQ0VMTEVELFxuICAgIF07XG4gICAgaWYgKChzdGF0dXMgPT09IG51bGwgfHwgc3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0dXMubWluZWRUeCkgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHguTk9UX01JTkVEKSB7XG4gICAgICAgIGlmIChzdGF0dXMuY2FuY2VsbGF0aW9uUmVhc29uID09PVxuICAgICAgICAgICAgdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLk5PVF9DQU5DRUxMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5QRU5ESU5HO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ2FuY2VsbGF0aW9uID0gY2FuY2VsbGF0aW9ucy5maW5kSW5kZXgoKGNhbmNlbGxhdGlvbikgPT4gY2FuY2VsbGF0aW9uID09PSBzdGF0dXMuY2FuY2VsbGF0aW9uUmVhc29uKSA+IC0xO1xuICAgICAgICBpZiAoc3RhdHVzLmNhbmNlbGxhdGlvblJlYXNvbiAmJiBpc0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuY2FuY2VsbGF0aW9uUmVhc29uVG9TdGF0dXNNYXBbc3RhdHVzLmNhbmNlbGxhdGlvblJlYXNvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHN0YXR1cyA9PT0gbnVsbCB8fCBzdGF0dXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXR1cy5taW5lZFR4KSA9PT0gdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uTWluZWRUeC5TVUNDRVNTKSB7XG4gICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5TVUNDRVNTO1xuICAgIH1cbiAgICBlbHNlIGlmICgoc3RhdHVzID09PSBudWxsIHx8IHN0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHVzLm1pbmVkVHgpID09PSB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4LlJFVkVSVEVEKSB7XG4gICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5SRVZFUlRFRDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHN0YXR1cyA9PT0gbnVsbCB8fCBzdGF0dXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXR1cy5taW5lZFR4KSA9PT0gdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uTWluZWRUeC5VTktOT1dOKSB7XG4gICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5VTktOT1dOO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuVU5LTk9XTjtcbn07XG5leHBvcnRzLmNhbGN1bGF0ZVN0YXR1cyA9IGNhbGN1bGF0ZVN0YXR1cztcbi8qKlxuICBHZW5lcmF0ZXMgYW4gYXJyYXkgb2YgaGlzdG9yeSBvYmplY3RzIHNlbnNlIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgVGhlIG9iamVjdCBoYXMgdGhlIGtleXNcbiAgICBvcCAodGhlIG9wZXJhdGlvbiBwZXJmb3JtZWQpLFxuICAgIHBhdGggKHRoZSBrZXkgYW5kIGlmIGEgbmVzdGVkIG9iamVjdCB0aGVuIGVhY2gga2V5IHdpbGwgYmUgc2VwYXJhdGVkIHdpdGggYSBgL2ApXG4gICAgdmFsdWVcbiAgd2l0aCB0aGUgZmlyc3QgZW50cnkgaGF2aW5nIHRoZSBub3RlIGFuZCBhIHRpbWVzdGFtcCB3aGVuIHRoZSBjaGFuZ2UgdG9vayBwbGFjZVxuICBAcGFyYW0ge09iamVjdH0gcHJldmlvdXNTdGF0ZSAtIHRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgb2JqZWN0XG4gIEBwYXJhbSB7T2JqZWN0fSBuZXdTdGF0ZSAtIHRoZSB1cGRhdGUgb2JqZWN0XG4gIEBwYXJhbSB7c3RyaW5nfSBbbm90ZV0gLSBhIG9wdGlvbmFsIG5vdGUgZm9yIHRoZSBzdGF0ZSBjaGFuZ2VcbiAgQHJldHVybnMge0FycmF5fVxuKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSGlzdG9yeUVudHJ5KHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBub3RlKSB7XG4gICAgY29uc3QgZW50cnkgPSBmYXN0X2pzb25fcGF0Y2hfMS5kZWZhdWx0LmNvbXBhcmUocHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIC8vIEFkZCBhIG5vdGUgdG8gdGhlIGZpcnN0IG9wLCBzaW5jZSBpdCBicmVha3MgaWYgd2UgYXBwZW5kIGl0IHRvIHRoZSBlbnRyeVxuICAgIGlmIChlbnRyeVswXSkge1xuICAgICAgICBpZiAobm90ZSkge1xuICAgICAgICAgICAgZW50cnlbMF0ubm90ZSA9IG5vdGU7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnlbMF0udGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xufVxuZXhwb3J0cy5nZW5lcmF0ZUhpc3RvcnlFbnRyeSA9IGdlbmVyYXRlSGlzdG9yeUVudHJ5O1xuLyoqXG4gIFJlY292ZXJzIHByZXZpb3VzIHR4TWV0YSBzdGF0ZSBvYmpcbiAgQHJldHVybnMge09iamVjdH1cbiovXG5mdW5jdGlvbiByZXBsYXlIaXN0b3J5KF9zaG9ydEhpc3RvcnkpIHtcbiAgICBjb25zdCBzaG9ydEhpc3RvcnkgPSBsb2Rhc2hfMS5jbG9uZURlZXAoX3Nob3J0SGlzdG9yeSk7XG4gICAgcmV0dXJuIHNob3J0SGlzdG9yeS5yZWR1Y2UoKHZhbCwgZW50cnkpID0+IGZhc3RfanNvbl9wYXRjaF8xLmRlZmF1bHQuYXBwbHlQYXRjaCh2YWwsIGVudHJ5KS5uZXdEb2N1bWVudCk7XG59XG5leHBvcnRzLnJlcGxheUhpc3RvcnkgPSByZXBsYXlIaXN0b3J5O1xuLyoqXG4gKiBTbmFwc2hvdCB7QGNvZGUgdHhNZXRhfVxuICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0eCBtZXRhZGF0YSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGEgZGVlcCBjbG9uZSB3aXRob3V0IGhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSkge1xuICAgIGNvbnN0IHNoYWxsb3cgPSBPYmplY3QuYXNzaWduKHt9LCB0eE1ldGEpO1xuICAgIGRlbGV0ZSBzaGFsbG93Lmhpc3Rvcnk7XG4gICAgcmV0dXJuIGxvZGFzaF8xLmNsb25lRGVlcChzaGFsbG93KTtcbn1cbmV4cG9ydHMuc25hcHNob3RGcm9tVHhNZXRhID0gc25hcHNob3RGcm9tVHhNZXRhO1xuLyoqXG4gKiBSZXR1cm5zIHByb2Nlc3NpbmcgdGltZSBmb3IgYW4gU1RYIGluIHNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc21hcnRUcmFuc2FjdGlvblN1Ym1pdHRlZHRpbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFByb2Nlc3NpbmcgdGltZSBpbiBzZWNvbmRzLlxuICovXG5jb25zdCBnZXRTdHhQcm9jZXNzaW5nVGltZSA9IChzbWFydFRyYW5zYWN0aW9uU3VibWl0dGVkdGltZSkgPT4ge1xuICAgIGlmICghc21hcnRUcmFuc2FjdGlvblN1Ym1pdHRlZHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKERhdGUubm93KCkgLSBzbWFydFRyYW5zYWN0aW9uU3VibWl0dGVkdGltZSkgLyAxMDAwKTtcbn07XG5leHBvcnRzLmdldFN0eFByb2Nlc3NpbmdUaW1lID0gZ2V0U3R4UHJvY2Vzc2luZ1RpbWU7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogdHlwZSwgZXJyb3JfZGV0YWlsczogbWVzc2FnZSB9ID0ganNvbjtcbiAgICAgICAgY29uc29sZS5sb2coYHJlc3BvbnNlYCwgcmVzcG9uc2UpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoIGVycm9yOiR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGhhbmRsZUZldGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSBleHBvcnRzLk1BWF9DSEFJTl9JRF9CWVRFUyA9IGV4cG9ydHMuSEFORExFX0xBUkdFUl9DSEFJTl9JRCA9IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gZXhwb3J0cy5WRVJTSU9OX0JZVEUgPSBleHBvcnRzLlJFUVVFU1RfVFlQRV9CWVRFID0gZXhwb3J0cy5zaWduaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNwb25zZU1zZ3MgPSBleHBvcnRzLnJlc3BvbnNlQ29kZXMgPSBleHBvcnRzLm1lc3NhZ2VDb25zdGFudHMgPSBleHBvcnRzLmV0aE1zZ1Byb3RvY29sID0gZXhwb3J0cy5lbmNSZXFDb2RlcyA9IGV4cG9ydHMuZGV2aWNlQ29kZXMgPSBleHBvcnRzLmRlY1Jlc0xlbmd0aHMgPSBleHBvcnRzLmFkZHJlc3NTaXplcyA9IGV4cG9ydHMuRU5DX01TR19MRU4gPSBleHBvcnRzLkJBU0VfVVJMID0gZXhwb3J0cy5CSVBfQ09OU1RBTlRTID0gZXhwb3J0cy5BRVNfSVYgPSBleHBvcnRzLkFERFJfU1RSX0xFTiA9IGV4cG9ydHMuZ2V0RndWZXJzaW9uQ29uc3QgPSBleHBvcnRzLkFTQ0lJX1JFR0VYID0gZXhwb3J0cy5FWFRFUk5BTCA9IHZvaWQgMDtcbi8vIENvbnNpc3RlbnQgd2l0aCBMYXR0aWNlJ3MgSVZcbnZhciBBRVNfSVYgPSBbXG4gICAgMHg2ZCwgMHg3OSwgMHg3MywgMHg2NSwgMHg2MywgMHg3MiwgMHg2NSwgMHg3NCwgMHg3MCwgMHg2MSwgMHg3MywgMHg3MywgMHg3NyxcbiAgICAweDZmLCAweDcyLCAweDY0LFxuXTtcbmV4cG9ydHMuQUVTX0lWID0gQUVTX0lWO1xudmFyIEFERFJfU1RSX0xFTiA9IDEyOTsgLy8gMTI4LWNoYXIgc3RyaW5ncyAobnVsbCB0ZXJtaW5hdGVkKVxuZXhwb3J0cy5BRERSX1NUUl9MRU4gPSBBRERSX1NUUl9MRU47XG4vLyBEZWNyeXB0ZWQgcmVzcG9uc2UgbGVuZ3RocyB3aWxsIGJlIGZpeGVkIGZvciBhbnkgZ2l2ZW4gbWVzc2FnZSB0eXBlLlxuLy8gVGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIExhdHRpY2Ugc3BlYy5cbi8vIEV2ZXJ5IGRlY3J5cHRlZCByZXNwb25zZSBzaG91bGQgaGF2ZSBhIDY1LWJ5dGUgcHVia2V5IHByZWZpeGluZyBpdCAoYW5kIGEgNC1ieXRlIHJlcXVlc3QgSUQpXG4vLyBUaGVzZSBhcmUgTk9UIGNvdW50ZWQgaW4gYGRlY1Jlc0xlbmd0aHNgLCBtZWFuaW5nIHRoZXNlIHZhbHVlcyBhcmUgNjktYnl0ZXMgc21hbGxlciB0aGFuIHRoZVxuLy8gY29ycmVzcG9uZGluZyBzdHJ1Y3RzIGluIGZpcm13YXJlLlxudmFyIGRlY1Jlc0xlbmd0aHMgPSB7XG4gICAgZW1wdHk6IDAsXG4gICAgZ2V0QWRkcmVzc2VzOiAxMCAqIEFERFJfU1RSX0xFTixcbiAgICBzaWduOiAxMDkwLFxuICAgIGdldFdhbGxldHM6IDE0MixcbiAgICBhZGRBYmlEZWZzOiA4LFxuICAgIGdldEt2UmVjb3JkczogMTM5NSxcbiAgICBnZXRBYmlSZWNvcmRzOiAxMjE1LFxuICAgIHJlbW92ZUFiaVJlY29yZHM6IDEsXG4gICAgdGVzdDogMTY0NiwgLy8gTWF4IHNpemUgb2YgdGVzdCByZXNwb25zZSBwYXlsb2FkXG59O1xuZXhwb3J0cy5kZWNSZXNMZW5ndGhzID0gZGVjUmVzTGVuZ3Rocztcbi8vIEV2ZXJ5IGNvcnJlc3BvbmRpbmcgZGVjcnlwdGVkIHJlc3BvbnNlIHN0cnVjdCBpbiBmaXJtd2FyZSBoYXMgYSBwdWJrZXlcbi8vIGFuZCBjaGVja3N1bSBhZGRlZC4gVGhlc2UgYXJlIG5vdCBpbmNsdWRlZCBpbiBgZGVjUmVzTGVuZ3Roc2BcbnZhciBERVNfUkVTX0VYVFJBREFUQV9MRU4gPSA2OTtcbi8vIEVuY3J5cHRlZCByZXNwb25zZXMgYWxzbyBoYXZlIG1ldGFkYXRhXG4vLyBQcmVmaXg6XG4vLyAqIHByb3RvY29sIHZlcnNpb24gKDEgYnl0ZSlcbi8vICogcmVzcG9uc2UgdHlwZSwgcmVzZXJ2ZWQgKDEgYnl0ZSkgLS0gbm90IHVzZWRcbi8vICogcmVzcG9uc2UgaWQgKDQgYnl0ZXMpIC0tIG5vdCB1c2VkXG4vLyAqIHBheWxvYWQgbGVuZ3RoICgyIGJ5dGVzKVxuLy8gKiByZXNwb25zZSBjb2RlICgxIGJ5dGUpXG4vLyBTdWZmaXg6XG4vLyAqIGNoZWNrc3VtICg0IGJ5dGVzKSAtLSBOT1QgdGhlIHNhbWUgY2hlY2tzdW0gYXMgaW5zaWRlIHRoZSBkZWNyeXB0ZWQgbXNnXG52YXIgRU5DX01TR19NRVRBREFUQV9MRU4gPSAxMztcbnZhciBFTkNfTVNHX0VYVFJBX0xFTiA9IERFU19SRVNfRVhUUkFEQVRBX0xFTiArIEVOQ19NU0dfTUVUQURBVEFfTEVOO1xuLy8gUGVyIExhdHRpY2Ugc3BlYywgYWxsIGVuY3J5cHRlZCBtZXNzYWdlcyBtdXN0IGZpdCBpbiBhIGJ1ZmZlciBvZiB0aGlzIHNpemUuXG4vLyBUaGUgbGVuZ3RoIGNvbWVzIGZyb20gdGhlIGxhcmdlc3QgcmVxdWVzdC9yZXNwb25zZSBkYXRhIHR5cGUgc2l6ZVxuLy8gV2UgYWxzbyBhZGQgdGhlIHByZWZpeCBsZW5ndGhcbnZhciBFTkNfTVNHX0xFTiA9IDA7XG5leHBvcnRzLkVOQ19NU0dfTEVOID0gRU5DX01TR19MRU47XG5PYmplY3Qua2V5cyhkZWNSZXNMZW5ndGhzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGRlY1Jlc0xlbmd0aHNba10gKyBFTkNfTVNHX0VYVFJBX0xFTiA+IEVOQ19NU0dfTEVOKVxuICAgICAgICBleHBvcnRzLkVOQ19NU0dfTEVOID0gRU5DX01TR19MRU4gPSBkZWNSZXNMZW5ndGhzW2tdICsgRU5DX01TR19FWFRSQV9MRU47XG59KTtcbnZhciBkZXZpY2VDb2RlcyA9IHtcbiAgICBDT05ORUNUOiAxLFxuICAgIEVOQ1JZUFRFRF9SRVFVRVNUOiAyLFxufTtcbmV4cG9ydHMuZGV2aWNlQ29kZXMgPSBkZXZpY2VDb2RlcztcbnZhciBlbmNSZXFDb2RlcyA9IHtcbiAgICBGSU5BTElaRV9QQUlSSU5HOiAwLFxuICAgIEdFVF9BRERSRVNTRVM6IDEsXG4gICAgQUREX1BFUk1JU1NJT046IDIsXG4gICAgU0lHTl9UUkFOU0FDVElPTjogMyxcbiAgICBHRVRfV0FMTEVUUzogNCxcbiAgICBBRERfUEVSTUlTU0lPTl9WMDogNSxcbiAgICBBRERfQUJJX0RFRlM6IDYsXG4gICAgR0VUX0tWX1JFQ09SRFM6IDcsXG4gICAgQUREX0tWX1JFQ09SRFM6IDgsXG4gICAgUkVNT1ZFX0tWX1JFQ09SRFM6IDksXG4gICAgR0VUX0FCSV9SRUNPUkRTOiAxMCxcbiAgICBSRU1PVkVfQUJJX1JFQ09SRFM6IDExLFxuICAgIFRFU1Q6IDEyLFxufTtcbmV4cG9ydHMuZW5jUmVxQ29kZXMgPSBlbmNSZXFDb2RlcztcbnZhciBtZXNzYWdlQ29uc3RhbnRzID0ge1xuICAgIE5PVF9QQUlSRUQ6IDB4MDAsXG4gICAgUEFJUkVEOiAweDAxLFxufTtcbmV4cG9ydHMubWVzc2FnZUNvbnN0YW50cyA9IG1lc3NhZ2VDb25zdGFudHM7XG52YXIgYWRkcmVzc1NpemVzID0ge1xuICAgIEJUQzogMjAsXG4gICAgRVRIOiAyMCwgLy8gMjAgYnl0ZSBhZGRyZXNzIG5vdCBpbmNsdWRpbmcgMHggcHJlZml4XG59O1xuZXhwb3J0cy5hZGRyZXNzU2l6ZXMgPSBhZGRyZXNzU2l6ZXM7XG52YXIgcmVzcG9uc2VDb2RlcyA9IHtcbiAgICBSRVNQX1NVQ0NFU1M6IDB4MDAsXG4gICAgUkVTUF9FUlJfSU5WQUxJRF9NU0c6IDB4ODAsXG4gICAgUkVTUF9FUlJfVU5TVVBQT1JURURfVkVSOiAweDgxLFxuICAgIFJFU1BfRVJSX0RFVl9CVVNZOiAweDgyLFxuICAgIFJFU1BfRVJSX1VTRVJfVElNRU9VVDogMHg4MyxcbiAgICBSRVNQX0VSUl9VU0VSX0RFQ0xJTkVEOiAweDg0LFxuICAgIFJFU1BfRVJSX1BBSVJfRkFJTDogMHg4NSxcbiAgICBSRVNQX0VSUl9QQUlSX0RJU0FCTEVEOiAweDg2LFxuICAgIFJFU1BfRVJSX1BFUk1JU1NJT05fRElTQUJMRUQ6IDB4ODcsXG4gICAgUkVTUF9FUlJfSU5URVJOQUw6IDB4ODgsXG4gICAgUkVTUF9FUlJfR0NFX1RJTUVPVVQ6IDB4ODksXG4gICAgUkVTUF9FUlJfV1JPTkdfV0FMTEVUOiAweDhhLFxuICAgIFJFU1BfRVJSX0RFVl9MT0NLRUQ6IDB4OGIsXG4gICAgUkVTUF9FUlJfRElTQUJMRUQ6IDB4OGMsXG4gICAgUkVTUF9FUlJfQUxSRUFEWTogMHg4ZCxcbiAgICBSRVNQX0VSUl9JTlZBTElEX0VQSEVNX0lEOiAweDhlLFxufTtcbmV4cG9ydHMucmVzcG9uc2VDb2RlcyA9IHJlc3BvbnNlQ29kZXM7XG52YXIgcmVzcG9uc2VNc2dzID0gKF9hID0ge30sXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX1NVQ0NFU1NdID0gMHgwMCxcbiAgICBfYVtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0lOVkFMSURfTVNHXSA9ICdJbnZhbGlkIHJlcXVlc3QnLFxuICAgIF9hW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfVU5TVVBQT1JURURfVkVSXSA9ICdVbnN1cHBvcnRlZCB2ZXJzaW9uJyxcbiAgICBfYVtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0RFVl9CVVNZXSA9ICdEZXZpY2UgYnVzeScsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9VU0VSX1RJTUVPVVRdID0gJ1RpbWVvdXQgd2FpdGluZyBmb3IgdXNlcicsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9VU0VSX0RFQ0xJTkVEXSA9ICdSZXF1ZXN0IGRlY2xpbmVkIGJ5IHVzZXInLFxuICAgIF9hW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfUEFJUl9GQUlMXSA9ICdQYWlyaW5nIGZhaWxlZCcsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9QQUlSX0RJU0FCTEVEXSA9ICdQYWlyaW5nIGlzIGN1cnJlbnRseSBkaXNhYmxlZCcsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9QRVJNSVNTSU9OX0RJU0FCTEVEXSA9ICdBdXRvbWF0ZWQgc2lnbmluZyBpcyBjdXJyZW50bHkgZGlzYWJsZWQnLFxuICAgIF9hW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfSU5URVJOQUxdID0gJ0RldmljZSBlcnJvcicsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9HQ0VfVElNRU9VVF0gPSAnVGltZW91dCcsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9XUk9OR19XQUxMRVRdID0gJ0FjdGl2ZSB3YWxsZXQgZG9lcyBub3QgbWF0Y2ggcmVxdWVzdCcsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9ERVZfTE9DS0VEXSA9ICdEZXZpY2UgbG9ja2VkJyxcbiAgICBfYVtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0RJU0FCTEVEXSA9ICdEaXNhYmxlZCcsXG4gICAgX2FbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9BTFJFQURZXSA9ICdSZWNvcmQgYWxyZWFkeSBleGlzdHMuIFlvdSBtdXN0IGZpcnN0IHJlbW92ZSBpdCBvbiB5b3VyIGRldmljZS4nLFxuICAgIF9hW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfSU5WQUxJRF9FUEhFTV9JRF0gPSAnQ291bGQgbm90IGZpbmQgcmVxdWVzdGVyLiBQbGVhc2UgcmVjb25uZWN0LicsXG4gICAgX2EpO1xuZXhwb3J0cy5yZXNwb25zZU1zZ3MgPSByZXNwb25zZU1zZ3M7XG52YXIgc2lnbmluZ1NjaGVtYSA9IHtcbiAgICBCVENfVFJBTlNGRVI6IDAsXG4gICAgRVRIX1RSQU5TRkVSOiAxLFxuICAgIEVSQzIwX1RSQU5TRkVSOiAyLFxuICAgIEVUSF9NU0c6IDMsXG4gICAgRVhUUkFfREFUQTogNCxcbiAgICBHRU5FUkFMX1NJR05JTkc6IDUsXG59O1xuZXhwb3J0cy5zaWduaW5nU2NoZW1hID0gc2lnbmluZ1NjaGVtYTtcbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwOyAvLyBIYXJkZW5lZCBvZmZzZXRcbmV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUO1xudmFyIEJJUF9DT05TVEFOVFMgPSB7XG4gICAgUFVSUE9TRVM6IHtcbiAgICAgICAgRVRIOiBIQVJERU5FRF9PRkZTRVQgKyA0NCxcbiAgICAgICAgQlRDX0xFR0FDWTogSEFSREVORURfT0ZGU0VUICsgNDQsXG4gICAgICAgIEJUQ19XUkFQUEVEX1NFR1dJVDogSEFSREVORURfT0ZGU0VUICsgNDksXG4gICAgICAgIEJUQ19TRUdXSVQ6IEhBUkRFTkVEX09GRlNFVCArIDg0LFxuICAgIH0sXG4gICAgQ09JTlM6IHtcbiAgICAgICAgRVRIOiBIQVJERU5FRF9PRkZTRVQgKyA2MCxcbiAgICAgICAgQlRDOiBIQVJERU5FRF9PRkZTRVQsXG4gICAgICAgIEJUQ19URVNUTkVUOiBIQVJERU5FRF9PRkZTRVQgKyAxLFxuICAgIH0sXG59O1xuZXhwb3J0cy5CSVBfQ09OU1RBTlRTID0gQklQX0NPTlNUQU5UUztcbnZhciBSRVFVRVNUX1RZUEVfQllURSA9IDB4MDI7IC8vIEZvciBhbGwgSFNNLWJvdW5kIHJlcXVlc3RzXG5leHBvcnRzLlJFUVVFU1RfVFlQRV9CWVRFID0gUkVRVUVTVF9UWVBFX0JZVEU7XG52YXIgVkVSU0lPTl9CWVRFID0gMTtcbmV4cG9ydHMuVkVSU0lPTl9CWVRFID0gVkVSU0lPTl9CWVRFO1xudmFyIEhBTkRMRV9MQVJHRVJfQ0hBSU5fSUQgPSAyNTU7IC8vIENoYWluSWQgdmFsdWUgdG8gc2lnbmlmeSBsYXJnZXIgY2hhaW5JRCBpcyBpbiBkYXRhIGJ1ZmZlclxuZXhwb3J0cy5IQU5ETEVfTEFSR0VSX0NIQUlOX0lEID0gSEFORExFX0xBUkdFUl9DSEFJTl9JRDtcbnZhciBNQVhfQ0hBSU5fSURfQllURVMgPSA4OyAvLyBNYXggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnRhaW4gbGFyZ2VyIGNoYWluSUQgaW4gZGF0YSBidWZmZXJcbmV4cG9ydHMuTUFYX0NIQUlOX0lEX0JZVEVTID0gTUFYX0NIQUlOX0lEX0JZVEVTO1xudmFyIEJBU0VfVVJMID0gJ2h0dHBzOi8vc2lnbmluZy5ncmlkcGwudXMnO1xuZXhwb3J0cy5CQVNFX1VSTCA9IEJBU0VfVVJMO1xudmFyIEVJUDcxMl9BQklfTEFUVElDRV9GV19UWVBFX01BUCA9IHtcbiAgICBhZGRyZXNzOiAxLFxuICAgIGJvb2w6IDIsXG4gICAgdWludDg6IDMsXG4gICAgdWludDE2OiA0LFxuICAgIHVpbnQyNDogNSxcbiAgICB1aW50MzI6IDYsXG4gICAgdWludDQwOiA3LFxuICAgIHVpbnQ0ODogOCxcbiAgICB1aW50NTY6IDksXG4gICAgdWludDY0OiAxMCxcbiAgICB1aW50NzI6IDExLFxuICAgIHVpbnQ4MDogMTIsXG4gICAgdWludDg4OiAxMyxcbiAgICB1aW50OTY6IDE0LFxuICAgIHVpbnQxMDQ6IDE1LFxuICAgIHVpbnQxMTI6IDE2LFxuICAgIHVpbnQxMjA6IDE3LFxuICAgIHVpbnQxMjg6IDE4LFxuICAgIHVpbnQxMzY6IDE5LFxuICAgIHVpbnQxNDQ6IDIwLFxuICAgIHVpbnQxNTI6IDIxLFxuICAgIHVpbnQxNjA6IDIyLFxuICAgIHVpbnQxNjg6IDIzLFxuICAgIHVpbnQxNzY6IDI0LFxuICAgIHVpbnQxODQ6IDI1LFxuICAgIHVpbnQxOTI6IDI2LFxuICAgIHVpbnQyMDA6IDI3LFxuICAgIHVpbnQyMDg6IDI4LFxuICAgIHVpbnQyMTY6IDI5LFxuICAgIHVpbnQyMjQ6IDMwLFxuICAgIHVpbnQyMzI6IDMxLFxuICAgIHVpbnQyNDA6IDMyLFxuICAgIHVpbnQyNDg6IDMzLFxuICAgIHVpbnQyNTY6IDM0LFxuICAgIGludDg6IDM1LFxuICAgIGludDE2OiAzNixcbiAgICBpbnQyNDogMzcsXG4gICAgaW50MzI6IDM4LFxuICAgIGludDQwOiAzOSxcbiAgICBpbnQ0ODogNDAsXG4gICAgaW50NTY6IDQxLFxuICAgIGludDY0OiA0MixcbiAgICBpbnQ3MjogNDMsXG4gICAgaW50ODA6IDQ0LFxuICAgIGludDg4OiA0NSxcbiAgICBpbnQ5NjogNDYsXG4gICAgaW50MTA0OiA0NyxcbiAgICBpbnQxMTI6IDQ4LFxuICAgIGludDEyMDogNDksXG4gICAgaW50MTI4OiA1MCxcbiAgICBpbnQxMzY6IDUxLFxuICAgIGludDE0NDogNTIsXG4gICAgaW50MTUyOiA1MyxcbiAgICBpbnQxNjA6IDU0LFxuICAgIGludDE2ODogNTUsXG4gICAgaW50MTc2OiA1NixcbiAgICBpbnQxODQ6IDU3LFxuICAgIGludDE5MjogNTgsXG4gICAgaW50MjAwOiA1OSxcbiAgICBpbnQyMDg6IDYwLFxuICAgIGludDIxNjogNjEsXG4gICAgaW50MjI0OiA2MixcbiAgICBpbnQyMzI6IDYzLFxuICAgIGludDI0MDogNjQsXG4gICAgaW50MjQ4OiA2NSxcbiAgICBpbnQyNTY6IDY2LFxuICAgIHVpbnQ6IDY3LFxuICAgIGJ5dGVzMTogNjksXG4gICAgYnl0ZXMyOiA3MCxcbiAgICBieXRlczM6IDcxLFxuICAgIGJ5dGVzNDogNzIsXG4gICAgYnl0ZXM1OiA3MyxcbiAgICBieXRlczY6IDc0LFxuICAgIGJ5dGVzNzogNzUsXG4gICAgYnl0ZXM4OiA3NixcbiAgICBieXRlczk6IDc3LFxuICAgIGJ5dGVzMTA6IDc4LFxuICAgIGJ5dGVzMTE6IDc5LFxuICAgIGJ5dGVzMTI6IDgwLFxuICAgIGJ5dGVzMTM6IDgxLFxuICAgIGJ5dGVzMTQ6IDgyLFxuICAgIGJ5dGVzMTU6IDgzLFxuICAgIGJ5dGVzMTY6IDg0LFxuICAgIGJ5dGVzMTc6IDg1LFxuICAgIGJ5dGVzMTg6IDg2LFxuICAgIGJ5dGVzMTk6IDg3LFxuICAgIGJ5dGVzMjA6IDg4LFxuICAgIGJ5dGVzMjE6IDg5LFxuICAgIGJ5dGVzMjI6IDkwLFxuICAgIGJ5dGVzMjM6IDkxLFxuICAgIGJ5dGVzMjQ6IDkyLFxuICAgIGJ5dGVzMjU6IDkzLFxuICAgIGJ5dGVzMjY6IDk0LFxuICAgIGJ5dGVzMjc6IDk1LFxuICAgIGJ5dGVzMjg6IDk2LFxuICAgIGJ5dGVzMjk6IDk3LFxuICAgIGJ5dGVzMzA6IDk4LFxuICAgIGJ5dGVzMzE6IDk5LFxuICAgIGJ5dGVzMzI6IDEwMCxcbiAgICBieXRlczogMTAxLFxuICAgIHN0cmluZzogMTAyLFxufTtcbnZhciBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRUlQNzEyX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQKSwgeyB0dXBsZTE6IDEwMywgdHVwbGUyOiAxMDQsIHR1cGxlMzogMTA1LCB0dXBsZTQ6IDEwNiwgdHVwbGU1OiAxMDcsIHR1cGxlNjogMTA4LCB0dXBsZTc6IDEwOSwgdHVwbGU4OiAxMTAsIHR1cGxlOTogMTExLCB0dXBsZTEwOiAxMTIsIHR1cGxlMTE6IDExMywgdHVwbGUxMjogMTE0LCB0dXBsZTEzOiAxMTUsIHR1cGxlMTQ6IDExNiwgdHVwbGUxNTogMTE3LCB0dXBsZTE2OiAxMTgsIHR1cGxlMTc6IDExOSB9KTtcbmV4cG9ydHMuRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQID0gRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQO1xudmFyIGV0aE1zZ1Byb3RvY29sID0ge1xuICAgIFNJR05fUEVSU09OQUw6IHtcbiAgICAgICAgc3RyOiAnc2lnblBlcnNvbmFsJyxcbiAgICAgICAgZW51bUlkeDogMCwgLy8gRW51bSBpbmRleCBvZiB0aGlzIHByb3RvY29sIGluIExhdHRpY2UgZmlybXdhcmVcbiAgICB9LFxuICAgIFRZUEVEX0RBVEE6IHtcbiAgICAgICAgc3RyOiAndHlwZWREYXRhJyxcbiAgICAgICAgZW51bUlkeDogMSxcbiAgICAgICAgcmF3RGF0YU1heExlbjogMTYyOSxcbiAgICAgICAgdHlwZUNvZGVzOiBFSVA3MTJfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAsIC8vIEVudW0gaW5kaWNlcyBvZiBkYXRhIHR5cGVzIGluIExhdHRpY2UgZmlybXdhcmVcbiAgICB9LFxufTtcbmV4cG9ydHMuZXRoTXNnUHJvdG9jb2wgPSBldGhNc2dQcm90b2NvbDtcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFWFRFUk5BTExZIEVYUE9SVEVEIENPTlNUQU5UU1xuLy8gVGhlc2UgYXJlIHVzZWQgZm9yIGJ1aWxkaW5nIHJlcXVlc3RzXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0cy5FWFRFUk5BTCA9IHtcbiAgICAvLyBPcHRpb25hbCBmbGFncyBmb3IgYGdldEFkZHJlc3Nlc2BcbiAgICBHRVRfQUREUl9GTEFHUzoge1xuICAgICAgICBTRUNQMjU2SzFfUFVCOiAzLFxuICAgICAgICBFRDI1NTE5X1BVQjogNCxcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgZm9yIGJ1aWxkaW5nIGdlbmVyYWwgc2lnbmluZyByZXF1ZXN0c1xuICAgIFNJR05JTkc6IHtcbiAgICAgICAgSEFTSEVTOiB7XG4gICAgICAgICAgICBOT05FOiAwLFxuICAgICAgICAgICAgS0VDQ0FLMjU2OiAxLFxuICAgICAgICAgICAgU0hBMjU2OiAyLFxuICAgICAgICB9LFxuICAgICAgICBDVVJWRVM6IHtcbiAgICAgICAgICAgIFNFQ1AyNTZLMTogMCxcbiAgICAgICAgICAgIEVEMjU1MTk6IDFcbiAgICAgICAgfSxcbiAgICAgICAgRU5DT0RJTkdTOiB7XG4gICAgICAgICAgICBBU0NJSTogMCxcbiAgICAgICAgICAgIEhFWDogMSxcbiAgICAgICAgICAgIFNPTEFOQTogMixcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRGd1ZlcnNpb25Db25zdCh2KSB7XG4gICAgdmFyIGMgPSB7XG4gICAgICAgIGV4dHJhRGF0YUZyYW1lU3o6IDAsXG4gICAgICAgIGV4dHJhRGF0YU1heEZyYW1lczogMCxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGd0ZSh2LCBleHApIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGB2YCBmaWVsZHMgY29tZSBpbiBhcyBbZml4fG1pbm9yfG1ham9yXVxuICAgICAgICByZXR1cm4gKHZbMl0gPiBleHBbMF0gfHxcbiAgICAgICAgICAgICh2WzJdID09PSBleHBbMF0gJiYgdlsxXSA+IGV4cFsxXSkgfHxcbiAgICAgICAgICAgICh2WzJdID09PSBleHBbMF0gJiYgdlsxXSA9PT0gZXhwWzFdICYmIHZbMF0gPiBleHBbMl0pIHx8XG4gICAgICAgICAgICAodlsyXSA9PT0gZXhwWzBdICYmIHZbMV0gPT09IGV4cFsxXSAmJiB2WzBdID09PSBleHBbMl0pKTtcbiAgICB9XG4gICAgLy8gVmVyeSBvbGQgbGVnYWN5IHZlcnNpb25zIGRvIG5vdCBnaXZlIGEgdmVyc2lvbiBudW1iZXJcbiAgICB2YXIgbGVnYWN5ID0gdi5sZW5ndGggPT09IDA7XG4gICAgLy8gQkFTRSBGSUVMRFNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVmFyaW91cyBzaXplIGNvbnN0YW50cyBoYXZlIGNoYW5nZWQgb24gdGhlIGZpcm13YXJlIHNpZGUgb3ZlciB0aW1lIGFuZFxuICAgIC8vIGFyZSBjYXB0dXJlZCBoZXJlXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgNF0pKSB7XG4gICAgICAgIC8vID49MC4xMC4zXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTY3ODtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDIwMDAwMDAwMDAwMDAwOyAvLyAyMDAwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgMF0pKSB7XG4gICAgICAgIC8vID49MC4xMC4wXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTY3ODtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDIwMDAwMDAwMDAwMDAwOyAvLyAyMDAwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMZWdhY3kgb3IgPDAuMTAuMFxuICAgICAgICBjLnJlcU1heERhdGFTeiA9IDExNTI7XG4gICAgICAgIGMuZXRoTWF4R2FzUHJpY2UgPSA1MDAwMDAwMDAwMDA7IC8vIDUwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGVzZSB0cmFuc2Zvcm1hdGlvbnMgYXBwbHkgdG8gYWxsIHZlcnNpb25zLiBUaGUgc3VidHJhY3Rpb25cbiAgICAvLyBvZiAxMjggYnl0ZXMgYWNjb3VudHMgZm9yIG1ldGFkYXRhIGFuZCBpcyBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gICAgLy8gRm9yIGFsbCBtb2Rlcm4gdmVyc2lvbnMsIHRoZXNlIGFyZSAxNTUwIGJ5dGVzLlxuICAgIC8vIE5PVEU6IE5vbi1sZWdhY3kgRVRIIHR4cyAoZS5nLiBFSVAxNTU5KSB3aWxsIHNocmlua1xuICAgIC8vIHRoaXMgbnVtYmVyLlxuICAgIC8vIFNlZSBgRVRIX0JBU0VfVFhfTUFYX0RBVEFfU1pgIGFuZCBgRVRIX01BWF9CQVNFX01TR19TWmAgaW4gZmlybXdhcmVcbiAgICBjLmV0aE1heERhdGFTeiA9IGMucmVxTWF4RGF0YVN6IC0gMTI4O1xuICAgIGMuZXRoTWF4TXNnU3ogPSBjLmV0aE1heERhdGFTejtcbiAgICAvLyBNYXggbnVtYmVyIG9mIHBhcmFtcyBpbiBhbiBFSVA3MTIgdHlwZS4gVGhpcyB3YXMgYWRkZWQgdG8gZmlybXdhcmVcbiAgICAvLyB0byBhdm9pZCBibG93aW5nIHN0YWNrIHNpemUuXG4gICAgYy5laXA3MTJNYXhUeXBlUGFyYW1zID0gMTg7XG4gICAgLy8gRVhUUkEgRklFTERTIEFEREVEIElOIExBVEVSIFZFUlNJT05TXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVjAuMTQuMCBhZGRlZCBzdXBwb3J0IGZvciBhIG1vcmUgcm9idXN0IEFQSSBhcm91bmQgQUJJIGRlZmluaXRpb25zXG4gICAgLy8gYW5kIGdlbmVyaWMgc2lnbmluZyBmdW5jdGlvbmFsaXR5XG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMywgMF0pKSB7XG4gICAgICAgIC8vIFNpemUgb2YgYGNhdGVnb3J5YCBidWZmZXIuIEluY2x1c2l2ZSBvZiBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cbiAgICAgICAgYy5hYmlDYXRlZ29yeVN6ID0gMzI7XG4gICAgICAgIGMuYWJpTWF4Um12ID0gMjAwOyAvLyBNYXggbnVtYmVyIG9mIEFCSSBkZWZzIHRoYXQgY2FuIGJlIHJlbW92ZWQgd2l0aFxuICAgICAgICAvLyBhIHNpbmdsZSByZXF1ZXN0XG4gICAgICAgIGlmICghYy5nZW5lcmljU2lnbmluZykge1xuICAgICAgICAgICAgYy5nZW5lcmljU2lnbmluZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBgc2l6ZW9mKEdlbmVyaWNTaWduaW5nUmVxdWVzdF90KWAgaW4gZmlybXdhcmVcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5iYXNlUmVxU3ogPSAxNTUyO1xuICAgICAgICAvLyBTZWUgYEdFTkVSSUNfU0lHTklOR19CQVNFX01TR19TWmAgaW4gZmlybXdhcmVcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5iYXNlRGF0YVN6ID0gMTUxOTtcbiAgICAgICAgYy5nZW5lcmljU2lnbmluZy5oYXNoVHlwZXMgPSBleHBvcnRzLkVYVEVSTkFMLlNJR05JTkcuSEFTSEVTO1xuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmN1cnZlVHlwZXMgPSBleHBvcnRzLkVYVEVSTkFMLlNJR05JTkcuQ1VSVkVTO1xuICAgICAgICBjLmdlbmVyaWNTaWduaW5nLmVuY29kaW5nVHlwZXMgPSBleHBvcnRzLkVYVEVSTkFMLlNJR05JTkcuRU5DT0RJTkdTO1xuICAgICAgICAvLyBTdXBwb3J0ZWQgZmxhZ3MgZm9yIGBnZXRBZGRyZXNzZXNgXG4gICAgICAgIGMuZ2V0QWRkcmVzc0ZsYWdzID0gW1xuICAgICAgICAgICAgZXhwb3J0cy5FWFRFUk5BTC5HRVRfQUREUl9GTEFHUy5FRDI1NTE5X1BVQixcbiAgICAgICAgICAgIGV4cG9ydHMuRVhURVJOQUwuR0VUX0FERFJfRkxBR1MuU0VDUDI1NksxX1BVQlxuICAgICAgICBdO1xuICAgICAgICAvLyBXZSB1cGRhdGVkIHRoZSBtYXggbnVtYmVyIG9mIHBhcmFtcyBpbiBFSVA3MTIgdHlwZXNcbiAgICAgICAgYy5laXA3MTJNYXhUeXBlUGFyYW1zID0gMzY7XG4gICAgfVxuICAgIC8vIFYwLjEzLjAgYWRkZWQgbmF0aXZlIHNlZ3dpdCBhZGRyZXNzZXMgYW5kIGZpeGVkIGEgYnVnIGluIGV4cG9ydGluZ1xuICAgIC8vIGxlZ2FjeSBiaXRjb2luIGFkZHJlc3Nlc1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTMsIDBdKSkge1xuICAgICAgICBjLmFsbG93QnRjTGVnYWN5QW5kU2Vnd2l0QWRkcnMgPSB0cnVlO1xuICAgICAgICAvLyBSYW5kb20gYWRkcmVzcyB0byBiZSB1c2VkIHdoZW4gdHJ5aW5nIHRvIGRlcGxveSBhIGNvbnRyYWN0XG4gICAgICAgIGMuY29udHJhY3REZXBsb3lLZXkgPSAnMHgwODAwMmUwZmVjOGU2YWNmMDA4MzVmNDNjOTc2NGY3MzY0ZmEzZjQyJztcbiAgICB9XG4gICAgLy8gVjAuMTIuMCBhZGRlZCBhbiBBUEkgZm9yIGNyZWF0aW5nLCByZW1vdmluZywgYW5kIGZldGNoaW5nIGtleS12YWwgZmlsZVxuICAgIC8vIHJlY29yZHMuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBTREssIHdlIG9ubHkgaG9vayBpbnRvIG9uZSB0eXBlIG9mIGt2XG4gICAgLy8gZmlsZTogYWRkcmVzcyBuYW1lcy5cbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEyLCAwXSkpIHtcbiAgICAgICAgYy5rdkFjdGlvbnNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgYy5rdktleU1heFN0clN6ID0gNjM7XG4gICAgICAgIGMua3ZWYWxNYXhTdHJTeiA9IDYzO1xuICAgICAgICBjLmt2QWN0aW9uTWF4TnVtID0gMTA7XG4gICAgICAgIGMua3ZSZW1vdmVNYXhOdW0gPSAxMDA7XG4gICAgfVxuICAgIC8vIFYwLjExLjIgY2hhbmdlZCBob3cgbWVzc2FnZXMgYXJlIGRpc3BsYXllZC4gRm9yIHBlcnNvbmFsX3NpZ24gbWVzc2FnZXNcbiAgICAvLyB3ZSBub3cgd3JpdGUgdGhlIGhlYWRlciAoYFNpZ25lcjogPHBhdGg+YCkgaW50byB0aGUgbWFpbiBib2R5IG9mIHRoZSBzY3JlZW4uXG4gICAgLy8gVGhpcyBtZWFucyBwZXJzb25hbCBzaWduIG1lc3NhZ2UgbWF4IHNpemUgaXMgc2xpZ2h0bHkgc21hbGxlciB0aGFuIGZvclxuICAgIC8vIEVJUDcxMiBtZXNzYWdlcyBiZWNhdXNlIGluIHRoZSBsYXR0ZXIgY2FzZSB0aGVyZSBpcyBubyBoZWFkZXJcbiAgICAvLyBOb3RlIHRoYXQgYDxwYXRoPmAgaGFzIG1heCBzaXplIG9mIDYyIGJ5dGVzIChgbS9YL1gvLi4uYClcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDExLCAyXSkpIHtcbiAgICAgICAgYy5wZXJzb25hbFNpZ25IZWFkZXJTeiA9IDcyO1xuICAgIH1cbiAgICAvLyBWMC4xMS4wIGFsbG93cyBuZXcgRVRIIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMSwgMF0pKSB7XG4gICAgICAgIGMuYWxsb3dlZEV0aFR4VHlwZXNWZXJzaW9uID0gMTtcbiAgICAgICAgYy5hbGxvd2VkRXRoVHhUeXBlcyA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAyLCAvLyBlaXAxNTU5XG4gICAgICAgIF07XG4gICAgICAgIGMudG90YWxFeHRyYUV0aFR4RGF0YVN6ID0gMTA7XG4gICAgfVxuICAgIC8vIFYwLjEwLjEwIGFsbG93cyBhIHVzZXIgdG8gc2lnbiBhIHByZWhhc2hlZCBFVEggbWVzc2FnZSBpZiBwYXlsb2FkIHRvbyBiaWdcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCAxMF0pKSB7XG4gICAgICAgIGMuZXRoTXNnUHJlSGFzaEFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBWMC4xMC44IGFsbG93cyBhIHVzZXIgdG8gc2lnbiBhIHByZWhhc2hlZCB0cmFuc2FjdGlvbiBpZiB0aGUgcGF5bG9hZFxuICAgIC8vIGlzIHRvbyBiaWdcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA4XSkpIHtcbiAgICAgICAgYy5wcmVoYXNoQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFYwLjEwLjUgYWRkZWQgdGhlIGFiaWxpdHkgdG8gdXNlIGZsZXhpYmxlIGFkZHJlc3MgcGF0aCBzaXplcywgd2hpY2hcbiAgICAvLyBjaGFuZ2VzIHRoZSBgZ2V0QWRkcmVzc2AgQVBJLiBJdCBhbHNvIGFkZGVkIHN1cHBvcnQgZm9yIEVJUDcxMlxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDVdKSkge1xuICAgICAgICBjLnZhckFkZHJQYXRoU3pBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgYy5laXA3MTJTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBWMC4xMC40IGludHJvZHVjZWQgdGhlIGFiaWxpdHkgdG8gc2VuZCBzaWduaW5nIHJlcXVlc3RzIG92ZXIgbXVsdGlwbGVcbiAgICAvLyBkYXRhIGZyYW1lcyAoaS5lLiBpbiBtdWx0aXBsZSByZXF1ZXN0cylcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA0XSkpIHtcbiAgICAgICAgYy5leHRyYURhdGFGcmFtZVN6ID0gMTUwMDsgLy8gMTUwMCBieXRlcyBwZXIgZnJhbWUgb2YgZXh0cmFEYXRhIGFsbG93ZWRcbiAgICAgICAgYy5leHRyYURhdGFNYXhGcmFtZXMgPSAxOyAvLyAxIGZyYW1lIG9mIGV4dHJhRGF0YSBhbGxvd2VkXG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuZXhwb3J0cy5nZXRGd1ZlcnNpb25Db25zdCA9IGdldEZ3VmVyc2lvbkNvbnN0O1xudmFyIEFTQ0lJX1JFR0VYID0gL15bXFx4MDAtXFx4N0ZdKyQvO1xuZXhwb3J0cy5BU0NJSV9SRUdFWCA9IEFTQ0lJX1JFR0VYO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG52YXIgYml0d2lzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaXR3aXNlXCIpKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xudmFyIHN1cGVyYWdlbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3VwZXJhZ2VudFwiKSk7XG52YXIgYml0Y29pbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2JpdGNvaW5cIikpO1xudmFyIHNoYV8xID0gcmVxdWlyZShcImhhc2guanMvbGliL2hhc2gvc2hhXCIpO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBldGhlcmV1bV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2V0aGVyZXVtXCIpKTtcbnZhciBldGhlcmV1bUFiaV8xID0gcmVxdWlyZShcIi4vZXRoZXJldW1BYmlcIik7XG52YXIgZ2VuZXJpY1NpZ25pbmdfMSA9IHJlcXVpcmUoXCIuL2dlbmVyaWNTaWduaW5nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRU1QVFlfV0FMTEVUX1VJRCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzMik7XG4vKipcbiAqIGBDbGllbnRgIGlzIGEgY2xhc3MtYmFzZWQgaW50ZXJmYWNlIGZvciBtYW5hZ2luZyBhIExhdHRpY2UgZGV2aWNlLlxuICovXG52YXIgQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGFyZSBwYXNzZWQgYXMgYW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsaWVudChfYSkge1xuICAgICAgICB2YXIgYmFzZVVybCA9IF9hLmJhc2VVcmwsIG5hbWUgPSBfYS5uYW1lLCBwcml2S2V5ID0gX2EucHJpdktleSwgc3RhdGVEYXRhID0gX2Euc3RhdGVEYXRhLCB0aW1lb3V0ID0gX2EudGltZW91dCwgcmV0cnlDb3VudCA9IF9hLnJldHJ5Q291bnQ7XG4gICAgICAgIC8vIERlZmF1bHQgc3RhdGUgcGFyYW1zXG4gICAgICAgIC8vIC0tLS0tXG4gICAgICAgIHRoaXMuZXBoZW1lcmFsUHViID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXZpY2VJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQYWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzID0ge1xuICAgICAgICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgICAgICAgICB1aWQ6IEVNUFRZX1dBTExFVF9VSUQsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dGVybmFsOiB7XG4gICAgICAgICAgICAgICAgdWlkOiBFTVBUWV9XQUxMRVRfVUlELFxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHBhc3MgaW4gc3RhdGUgZGF0YSB0byByZWh5ZHJhdGUgYSBzZXNzaW9uIHRoYXQgd2FzIHByZXZpb3VzbHkgY2FjaGVkXG4gICAgICAgIC8vIC0tLS0tXG4gICAgICAgIGlmIChzdGF0ZURhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3VucGFja0FuZEFwcGx5U3RhdGVEYXRhKHN0YXRlRGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXIgcGFyYW1zIHRvIGNoZWNrIGlmIGBzdGF0ZURhdGFgIGlzIG5vdCBpbmNsdWRlZFxuICAgICAgICAvLyAtLS0tLVxuICAgICAgICAvLyBgYmFzZVVybGAgZGVzY3JpYmVzIHdoZXJlIHRvIHNlbmQgSFRUUCByZXF1ZXN0c1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsIHx8IGNvbnN0YW50c18xLkJBU0VfVVJMO1xuICAgICAgICAvLyBgbmFtZWAgaXMgYSBodW1hbiByZWFkYWJsZSBzdHJpbmcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXBwIG9uIHRoZSBMYXR0aWNlXG4gICAgICAgIGlmIChuYW1lICYmIChuYW1lLmxlbmd0aCA8IDUgfHwgbmFtZS5sZW5ndGggPiAyNCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG5hbWVgIG11c3QgYmUgNS0yNCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnVW5rbm93bic7XG4gICAgICAgIC8vIGBwcml2S2V5YCBpcyB1c2VkIHRvIGdlbmVyYXRlIGEga2V5cGFpciwgd2hpY2ggaXMgdXNlZCBmb3IgbWFpbnRhaW5pbmdcbiAgICAgICAgLy8gYW4gZW5jcnlwdGVkIG1lc3NhZ2luZyBjaGFubmVsIHdpdGggdGhlIHRhcmdldCBMYXR0aWNlXG4gICAgICAgIHRoaXMucHJpdktleSA9IHByaXZLZXkgfHwgKDAsIHV0aWxfMS5yYW5kb21CeXRlcykoMzIpO1xuICAgICAgICB0aGlzLmtleSA9ICgwLCB1dGlsXzEuZ2V0UDI1NktleVBhaXIpKHRoaXMucHJpdktleSk7XG4gICAgICAgIC8vIGByZXRyeUNvdW50YCBkZWZpbmVzIHRoZSBudW1iZXIgb2YgYXV0b21hdGljIHJldHJpZXMgZm9yIGFzeW5jaHJvbm91cyByZXF1ZXN0cy5cbiAgICAgICAgLy8gUmV0cmllcyBvbmx5IGhhcHBlbiBmb3IgY2VydGFpbiBkZXZpY2UgZXJyb3JzIHdoaWNoIGluZGljYXRlIHJldHJ5aW5nIGlzIGFsbG93ZWQuXG4gICAgICAgIHRoaXMucmV0cnlDb3VudCA9IHJldHJ5Q291bnQgfHwgMztcbiAgICAgICAgLy8gYHRpbWVvdXRgIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFsbG93ZWQgYmVmb3JlIHRlcm1pbmF0aW5nXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyByZXF1ZXN0cyBpZiBubyByZXNwb25zZSBpcyByZXR1cm5lZCBpbiB0aW1lXG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQgfHwgNjAwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGUgZGF0YSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIHNlc3Npb24uXG4gICAgICogUGFzcyB0aGUgY29udGVudHMgb2YgdGhpcyB0byB0aGUgY29uc3RydWN0b3IgYXMgYHN0YXRlRGF0YWAgdG8gcmVoeWRyYXRlLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0U3RhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFja1N0YXRlRGF0YSgpO1xuICAgIH07XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIExBVFRJQ0UgRlVOQ1RJT05TXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8qKlxuICAgICAqIGBjb25uZWN0YCB3aWxsIGF0dGVtcHQgdG8gY29udGFjdCBhIGRldmljZSBiYXNlZCBvbiBpdHMgZGV2aWNlSWQuIFRoZSByZXNwb25zZSBzaG91bGQgaW5jbHVkZVxuICAgICAqIGFuIGVwaGVtZXJhbCBwdWJsaWMga2V5LCB3aGljaCBpcyB1c2VkIHRvIHBhaXIgd2l0aCB0aGUgZGV2aWNlIGluIGEgbGF0ZXIgcmVxdWVzdC5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChkZXZpY2VJZCwgX2NiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICAvLyBVc2VyIG1heSBcInJlLWNvbm5lY3RcIiBpZiBhIGRldmljZSBJRCBoYXMgcHJldmlvdXNseSBiZWVuIHN0b3JlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZGV2aWNlSWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYignTm8gZGV2aWNlIElEIGhhcyBiZWVuIHN0b3JlZC4gUGxlYXNlIGNvbm5lY3Qgd2l0aCB5b3VyIGRldmljZSBJRCBmaXJzdC4nKTtcbiAgICAgICAgICAgICAgICBjYiA9IGRldmljZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgZGV2aWNlIElELCBjb25uZWN0IHRvIHRoYXQgZGV2aWNlIGFuZCBzYXZlXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5ldyBJRCBmb3IgZnV0dXJlIHVzZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtID0gX3RoaXMuX2J1aWxkUmVxdWVzdChjb25zdGFudHNfMS5kZXZpY2VDb2Rlcy5DT05ORUNULCBfdGhpcy5wdWJLZXlCeXRlcygpKTtcbiAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0KHBhcmFtLCBudWxsLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1BhaXJlZCA9IF90aGlzLl9oYW5kbGVDb25uZWN0KHJlcykgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFuIGFjdGl2ZSB3YWxsZXQuIFRoaXMgd2lsbCBnZXQgYnlwYXNzZWQgaWYgd2UgYXJlIG5vdCBwYWlyZWQuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzUGFpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXRBY3RpdmVXYWxsZXQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyciwgX3RoaXMuaXNQYWlyZWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgYSBwYWlyaW5nIHNlY3JldCBpcyBwcm92aWRlZCwgYHBhaXJgIHVzZXMgaXQgdG8gc2lnbiBhIGhhc2ggb2YgdGhlIHB1YmxpYyBrZXksIG5hbWUsIGFuZFxuICAgICAqIHBhaXJpbmcgc2VjcmV0LiBJdCB0aGVuIHNlbmRzIHRoZSBuYW1lIGFuZCBzaWduYXR1cmUgdG8gdGhlIGRldmljZS4gSWYgbm8gcGFpcmluZyBzZWNyZXQgaXNcbiAgICAgKiBwcm92aWRlZCwgYHBhaXJgIHNlbmRzIGEgemVyby1sZW5ndGggbmFtZSBidWZmZXIgdG8gdGhlIGRldmljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqIEByZXR1cm5zIFRoZSBhY3RpdmUgd2FsbGV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnBhaXIgPSBmdW5jdGlvbiAocGFpcmluZ1NlY3JldCwgX2NiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgc2VjcmV0IGhhc2ggZnJvbSB0aGUgc2FsdFxuICAgICAgICAgICAgdmFyIHB1YktleSA9IF90aGlzLnB1YktleUJ5dGVzKCk7XG4gICAgICAgICAgICB2YXIgbmFtZUJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygyNSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMubmFtZS5sZW5ndGggPCA1IHx8IF90aGlzLm5hbWUubGVuZ3RoID4gMjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ0ludmFsaWQgbGVuZ3RoIGZvciBuYW1lIHByb3ZpZGVkLiBNdXN0IGJlIDUtMjQgY2hhcmFjdGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWlyaW5nU2VjcmV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHBhaXJpbmcgc2VjcmV0IG9mIHplcm8gbGVuZ3RoIGlzIHBhc3NlZCBpbiwgaXQgdXN1YWxseSBpbmRpY2F0ZXNcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGNhbmNlbCB0aGUgcGFpcmluZyBhdHRlbXB0LiBJbiB0aGlzIGNhc2Ugd2UgcGFzcyBhIHplcm8tbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy8gbmFtZSBidWZmZXIgc28gdGhlIGZpcm13YXJlIGNhbiBrbm93IG5vdCB0byBkcmF3IHRoZSBlcnJvciBzY3JlZW4uXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHN0aWxsIGV4cGVjdCBhbiBlcnJvciB0byBjb21lIGJhY2sgKFJFU1BfRVJSX1BBSVJfRkFJTClcbiAgICAgICAgICAgICAgICBuYW1lQnVmLndyaXRlKF90aGlzLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIG51bGwgdGVybWluYXRpb24gYnl0ZSB0byB0aGUgcGFpcmluZyBzZWNyZXRcbiAgICAgICAgICAgIHZhciBwcmVJbWFnZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgIHB1YktleSxcbiAgICAgICAgICAgICAgICBuYW1lQnVmLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHBhaXJpbmdTZWNyZXQpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKHByZUltYWdlKS5kaWdlc3QoJ2hleCcpLCAnaGV4Jyk7XG4gICAgICAgICAgICB2YXIgc2lnID0gX3RoaXMua2V5LnNpZ24oaGFzaCk7IC8vIHJldHVybnMgYW4gYXJyYXksIG5vdCBhIGJ1ZmZlclxuICAgICAgICAgICAgdmFyIGRlclNpZyA9ICgwLCB1dGlsXzEudG9QYWRkZWRERVIpKHNpZyk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW25hbWVCdWYsIGRlclNpZ10pO1xuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0KHBheWxvYWQsICdGSU5BTElaRV9QQUlSSU5HJywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgLy8gUmVjb3ZlciB0aGUgZXBoZW1lcmFsIGtleVxuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSBfdGhpcy5faGFuZGxlUGFpcihyZXMpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJTdHIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnJTdHIpO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgdGhlIGFjdGl2ZSB3YWxsZXQgb25jZSBwYWlyaW5nIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0QWN0aXZlV2FsbGV0KGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgX3RoaXMuaGFzQWN0aXZlV2FsbGV0KCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYHRlc3RgIHRha2VzIGEgZGF0YSBvYmplY3Qgd2l0aCBhIHRlc3RJRCBhbmQgYSBwYXlsb2FkLCBhbmQgc2VuZHMgdGhlbSB0byB0aGUgZGV2aWNlLlxuICAgICAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKGRhdGEsIF9jYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGNiID0gKDAsIHV0aWxfMS5wcm9taXNpZnlDYikocmVzb2x2ZSwgcmVqZWN0LCBfY2IpO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnBheWxvYWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdGaXJzdCBhcmd1bWVudCBtdXN0IGNvbnRhaW4gYHRlc3RJRGAgYW5kIGBwYXlsb2FkYCBmaWVsZHMuJyk7XG4gICAgICAgICAgICB2YXIgVEVTVF9EQVRBX1NaID0gNTAwO1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoVEVTVF9EQVRBX1NaICsgNik7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyQkUoZGF0YS50ZXN0SUQsIDApO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQxNkJFKGRhdGEucGF5bG9hZC5sZW5ndGgsIDQpO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkLmNvcHkocGF5bG9hZCwgNik7XG4gICAgICAgICAgICBfdGhpcy5fcmVxdWVzdChwYXlsb2FkLCAnVEVTVCcsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWQgPSBfdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBjb25zdGFudHNfMS5kZWNSZXNMZW5ndGhzLnRlc3QpO1xuICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0ZWQuZXJyICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZGVjcnlwdGVkLmVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGRlY3J5cHRlZC5kYXRhLnNsaWNlKDY1KSk7IC8vIHJlbW92ZSBlcGhlbSBwdWJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBnZXRBZGRyZXNzZXNgIHRha2VzIGEgc3RhcnRpbmcgcGF0aCBhbmQgYSBudW1iZXIgdG8gZ2V0IHRoZSBhZGRyZXNzZXMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqIGFjdGl2ZSB3YWxsZXQuXG4gICAgICogQGNhdGVnb3J5IExhdHRpY2VcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhZGRyZXNzZXMuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRBZGRyZXNzZXMgPSBmdW5jdGlvbiAob3B0cywgX2NiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICB2YXIgTUFYX0FERFIgPSAxMDtcbiAgICAgICAgICAgIHZhciBzdGFydFBhdGggPSBvcHRzLnN0YXJ0UGF0aCwgbiA9IG9wdHMubiwgX2EgPSBvcHRzLmZsYWcsIGZsYWcgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UGF0aCA9PT0gdW5kZWZpbmVkIHx8IG4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ1BsZWFzZSBwcm92aWRlIGBzdGFydFBhdGhgIGFuZCBgbmAgb3B0aW9ucycpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UGF0aC5sZW5ndGggPCAyIHx8IHN0YXJ0UGF0aC5sZW5ndGggPiA1KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYignUGF0aCBtdXN0IGluY2x1ZGUgYmV0d2VlbiAyIGFuZCA1IGluZGljZXMnKTtcbiAgICAgICAgICAgIGlmIChuID4gTUFYX0FERFIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiWW91IG1heSBvbmx5IHJlcXVlc3QgXCIuY29uY2F0KE1BWF9BRERSLCBcIiBhZGRyZXNzZXMgYXQgb25jZS5cIikpO1xuICAgICAgICAgICAgdmFyIGZ3Q29uc3RhbnRzID0gKDAsIGNvbnN0YW50c18xLmdldEZ3VmVyc2lvbkNvbnN0KShfdGhpcy5md1ZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbF8xLmlzVmFsaWRBc3NldFBhdGgpKHN0YXJ0UGF0aCwgZndDb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYignUGFyZW50IGRlcml2YXRpb24gcGF0aCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB2YXIgc3ogPSAzMiArIDIwICsgMTsgLy8gd2FsbGV0VUlEICsgNSB1MzIgaW5kaWNlcyArIGNvdW50L2ZsYWdcbiAgICAgICAgICAgIGlmIChmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHN6ICs9IDE7IC8vIHBhdGhEZXB0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRQYXRoLmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignWW91ciBMYXR0aWNlIGZpcm13YXJlIG9ubHkgc3VwcG9ydHMgZGVyaXZhdGlvbiBwYXRocyB3aXRoIDUgaW5kaWNlcy4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhzeik7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIC8vIFdhbGxldFVJRFxuICAgICAgICAgICAgdmFyIHdhbGxldCA9IF90aGlzLmdldEFjdGl2ZVdhbGxldCgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ05vIGFjdGl2ZSB3YWxsZXQuJyk7XG4gICAgICAgICAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAzMjtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBzdGFydCBwYXRoICg1eCB1MzIgaW5kaWNlcylcbiAgICAgICAgICAgIGlmIChmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50OChzdGFydFBhdGgubGVuZ3RoLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBzdGFydFBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyQkUoc3RhcnRQYXRoW2ldLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlY2lmeSB0aGUgbnVtYmVyIG9mIHN1YnNlcXVlbnQgYWRkcmVzc2VzIHRvIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBXZSBhbHNvIGFsbG93IHRoZSB1c2VyIHRvIHNraXAgdGhlIGNhY2hlIGFuZCByZXF1ZXN0IGFueSBhZGRyZXNzIHJlbGF0ZWQgdG8gdGhlIGFzc2V0XG4gICAgICAgICAgICAvLyBpbiB0aGUgd2FsbGV0LlxuICAgICAgICAgICAgdmFyIHZhbCwgZmxhZ1ZhbCA9IDA7XG4gICAgICAgICAgICBpZiAoZndDb25zdGFudHMuYWRkckZsYWdzQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgNC1iaXQgZmxhZyBjYW4gYmUgdXNlZCBmb3Igbm9uLXN0YW5kYXJkIGFkZHJlc3MgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNvbWJpbmVkIHdpdGggYG5gIGFzIGEgNCBiaXQgdmFsdWVcbiAgICAgICAgICAgICAgICBmbGFnVmFsID0gKGZ3Q29uc3RhbnRzLmdldEFkZHJlc3NGbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBmd0NvbnN0YW50cy5nZXRBZGRyZXNzRmxhZ3MuaW5kZXhPZihmbGFnKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICA/IGZsYWcgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBmbGFnQml0cyA9IGJpdHdpc2VfMS5kZWZhdWx0Lm5pYmJsZS5yZWFkKGZsYWdWYWwpO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudEJpdHMgPSBiaXR3aXNlXzEuZGVmYXVsdC5uaWJibGUucmVhZChuKTtcbiAgICAgICAgICAgICAgICB2YWwgPSBiaXR3aXNlXzEuZGVmYXVsdC5ieXRlLndyaXRlKGZsYWdCaXRzLmNvbmNhdChjb3VudEJpdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFZlcnkgb2xkIGZpcm13YXJlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBmbGFnLiBXZSBjYW4gZGVwcmVjYXRlIHRoaXMgc29vbi5cbiAgICAgICAgICAgICAgICB2YWwgPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KHZhbCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZisrO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZXF1ZXN0KHBheWxvYWQsICdHRVRfQUREUkVTU0VTJywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZFJlcyA9IF90aGlzLl9oYW5kbGVHZXRBZGRyZXNzZXMocmVzLCBmbGFnVmFsKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVzLmVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKHBhcnNlZFJlcy5lcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBwYXJzZWRSZXMuZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgc2lnbmAgYnVpbGRzIGFuZCBzZW5kcyBhIHJlcXVlc3QgZm9yIHNpZ25pbmcgdG8gdGhlIGRldmljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBkZXZpY2UuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKG9wdHMsIF9jYiwgY2FjaGVkRGF0YSwgbmV4dENvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNhY2hlZERhdGEgPT09IHZvaWQgMCkgeyBjYWNoZWREYXRhID0gbnVsbDsgfVxuICAgICAgICBpZiAobmV4dENvZGUgPT09IHZvaWQgMCkgeyBuZXh0Q29kZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjYiA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5Q2IpKHJlc29sdmUsIHJlamVjdCwgX2NiKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW5jeSA9IG9wdHMuY3VycmVuY3k7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG9wdHMuZGF0YTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignWW91IG11c3QgcHJvdmlkZSBgZGF0YWAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCB0cmFuc2FjdGlvbiByZXF1ZXN0cyBtdXN0IGJlIHB1dCBpbnRvIHRoZSBzYW1lIHNpemVkIGJ1ZmZlci5cbiAgICAgICAgICAgIC8vIFRoaXMgY29tZXMgZnJvbSBzaXplb2YoR3BUcmFuc2FjdGlvblJlcXVlc3RfdCksIGJ1dCBub3RlIHdlIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhlIDItYnl0ZSBzY2hlbWFJZCBzaW5jZSBpdCBpcyBub3QgcmV0dXJuZWQgZnJvbSBvdXIgcmVzb2x2ZXIuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgZGlmZmVyZW50IGZpcm13YXJlIHZlcnNpb25zIG1heSBoYXZlIGRpZmZlcmVudCBkYXRhIHNpemVzLlxuICAgICAgICAgICAgdmFyIGZ3Q29uc3RhbnRzID0gKDAsIGNvbnN0YW50c18xLmdldEZ3VmVyc2lvbkNvbnN0KShfdGhpcy5md1ZlcnNpb24pO1xuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHNpZ25pbmcgcmVxdWVzdCBwYXlsb2FkIHRvIHNlbmQgdG8gdGhlIGRldmljZS4gSWYgd2UgY2F0Y2hcbiAgICAgICAgICAgIC8vIGJhZCBwYXJhbXMsIHJldHVybiBhbiBlcnJvciBpbnN0ZWFkXG4gICAgICAgICAgICBkYXRhID0gX19hc3NpZ24oeyBmd0NvbnN0YW50czogZndDb25zdGFudHMgfSwgZGF0YSk7XG4gICAgICAgICAgICB2YXIgcmVxLCByZXFQYXlsb2FkO1xuICAgICAgICAgICAgdmFyIHNjaGVtYTtcbiAgICAgICAgICAgIGlmIChjYWNoZWREYXRhICE9PSBudWxsICYmIG5leHRDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxID0gY2FjaGVkRGF0YTtcbiAgICAgICAgICAgICAgICByZXFQYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbbmV4dENvZGUsIHJlcS5leHRyYURhdGFQYXlsb2Fkcy5zaGlmdCgpXSk7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gY29uc3RhbnRzXzEuc2lnbmluZ1NjaGVtYS5FWFRSQV9EQVRBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5ID09PSAnRVRIJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gZXRoZXJldW1fMS5kZWZhdWx0LmJ1aWxkRXRoZXJldW1UeFJlcXVlc3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVuY3kgPT09ICdFVEhfTVNHJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gZXRoZXJldW1fMS5kZWZhdWx0LmJ1aWxkRXRoZXJldW1Nc2dSZXF1ZXN0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbmN5ID09PSAnQlRDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gYml0Y29pbl8xLmRlZmF1bHQuYnVpbGRCaXRjb2luVHhSZXF1ZXN0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gKDAsIGdlbmVyaWNTaWduaW5nXzEuYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QpKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiRXJyb3IgYnVpbGRpbmcgc2lnbmluZyByZXF1ZXN0OiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5lcnIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKHJlcS5lcnIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXEucGF5bG9hZC5sZW5ndGggPiBmd0NvbnN0YW50cy5yZXFNYXhEYXRhU3opXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYignVHJhbnNhY3Rpb24gaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAgICAgcmVxUGF5bG9hZCA9IHJlcS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHJlcS5zY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMiArIGZ3Q29uc3RhbnRzLnJlcU1heERhdGFTeik7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlcmUgd2lsbCBiZSBmb2xsb3cgdXAgcmVxdWVzdHNcbiAgICAgICAgICAgIHZhciBoYXNFeHRyYVBheWxvYWRzID0gcmVxLmV4dHJhRGF0YVBheWxvYWRzICYmIE51bWJlcihyZXEuZXh0cmFEYXRhUGF5bG9hZHMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoaGFzRXh0cmFQYXlsb2Fkcywgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgLy8gQ29weSByZXF1ZXN0IHNjaGVtYSAoZS5nLiBFVEggb3IgQlRDIHRyYW5zZmVyKVxuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNjaGVtYSwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgLy8gQ29weSB0aGUgd2FsbGV0IFVJRFxuICAgICAgICAgICAgdmFyIHdhbGxldCA9IF90aGlzLmdldEFjdGl2ZVdhbGxldCgpO1xuICAgICAgICAgICAgaWYgKHdhbGxldCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ05vIGFjdGl2ZSB3YWxsZXQuJyk7XG4gICAgICAgICAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSB3YWxsZXQudWlkLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEJ1aWxkIGRhdGEgYmFzZWQgb24gdGhlIHR5cGUgb2YgcmVxdWVzdFxuICAgICAgICAgICAgLy8gQ29weSB0aGUgcGF5bG9hZCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgcmVxUGF5bG9hZC5jb3B5KHBheWxvYWQsIG9mZik7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVuY3J5cHRlZCByZXF1ZXN0IGFuZCBzZW5kIGl0XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ1NJR05fVFJBTlNBQ1RJT04nLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbm90aGVyIGVycm9yIGNhdWdodCwgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRXh0cmFQYXlsb2Fkcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcnlwdGVkID0gX3RoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKHJlcywgY29uc3RhbnRzXzEuZGVjUmVzTGVuZ3Rocy5zaWduKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvZGUgPSBkZWNyeXB0ZWQuZGF0YS5zbGljZSg2NSwgNzMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZERhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWREYXRhID0gcmVxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2lnbihvcHRzLCBjYiwgY2FjaGVkRGF0YSwgbmV4dENvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB3YWxsZXQgYW5kIG5vIGVycm9ycyAtLSBoYW5kbGUgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkUmVzID0gX3RoaXMuX2hhbmRsZVNpZ24ocmVzLCBjdXJyZW5jeSwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBwYXJzZWRSZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgYWRkQWJpRGVmc2Agc2VuZHMgYSBsaXN0IG9mIEFCSSBkZWZpbml0aW9ucyB0byB0aGUgZGV2aWNlIGluIGNodW5rcyBvZiB1cCB0byBgTUFYX0FCSV9ERUZTYC5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgcmVzcG9uc2UuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5hZGRBYmlEZWZzID0gZnVuY3Rpb24gKGRlZnMsIF9jYiwgbmV4dENvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5leHRDb2RlID09PSB2b2lkIDApIHsgbmV4dENvZGUgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICB2YXIgZGVmc1RvQWRkID0gZGVmcy5zbGljZSgwLCBldGhlcmV1bUFiaV8xLk1BWF9BQklfREVGUyk7XG4gICAgICAgICAgICBkZWZzID0gZGVmcy5zbGljZShldGhlcmV1bUFiaV8xLk1BWF9BQklfREVGUyk7XG4gICAgICAgICAgICB2YXIgYWJpUGF5bG9hZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWJpUGF5bG9hZCA9ICgwLCBldGhlcmV1bUFiaV8xLmJ1aWxkQWRkQWJpUGF5bG9hZCkoZGVmc1RvQWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKGFiaVBheWxvYWQubGVuZ3RoICsgMTApO1xuICAgICAgICAgICAgLy8gTGV0IHRoZSBmaXJtd2FyZSBrbm93IGhvdyBtYW55IGRlZnMgYXJlIHJlbWFpbmluZyAqYWZ0ZXIgdGhpcyBvbmUqLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aXZlIG51bWJlciwgZmlybXdhcmUgd2lsbCBzZW5kIHVzIGEgdGVtcG9yYXJ5IGNvZGVcbiAgICAgICAgICAgIC8vIHRvIGJ5cGFzcyB1c2VyIGF1dGhvcml6YXRpb24gaWYgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZWFzeSBBQkkgbG9hZGluZy5cbiAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50MTZMRShkZWZzLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZm9sbG93LXVwIHJlcXVlc3QsIHdlIGRvbid0IG5lZWQgdG8gYXNrIGZvciB1c2VyIGF1dGhvcml6YXRpb25cbiAgICAgICAgICAgIC8vIGlmIHdlIHVzZSB0aGUgY29ycmVjdCB0ZW1wb3JhcnkgdTY0XG4gICAgICAgICAgICBpZiAobmV4dENvZGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgbmV4dENvZGUuY29weShwYXlsb2FkLCAyKTtcbiAgICAgICAgICAgIGFiaVBheWxvYWQuY29weShwYXlsb2FkLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ0FERF9BQklfREVGUycsIGZ1bmN0aW9uIChlcnIsIHJlcywgcmVzcG9uc2VDb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQ29kZSAmJiByZXNwb25zZUNvZGUgIT09IGNvbnN0YW50c18xLnJlc3BvbnNlQ29kZXMuUkVTUF9TVUNDRVNTKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ0Vycm9yIG1ha2luZyByZXF1ZXN0LicpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgdmFyIGRlY3J5cHRlZCA9IF90aGlzLl9oYW5kbGVFbmNSZXNwb25zZShyZXMsIGNvbnN0YW50c18xLmRlY1Jlc0xlbmd0aHMuYWRkQWJpRGVmcyk7XG4gICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgOCBieXRlIGNvZGUgdG8gZmFzdCB0cmFjayBvdXIgbmV4dCByZXF1ZXN0LCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IGRlY3J5cHRlZC5kYXRhLnNsaWNlKDY1LCA3Myk7XG4gICAgICAgICAgICAgICAgLy8gTm8gZGVmcyBsZWZ0PyBSZXR1cm4gc3VjY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBzZXRcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRBYmlEZWZzKGRlZnMsIGNiLCBuZXh0Q29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgZ2V0QWJpUmVjb3Jkc2AgZmV0Y2hlcyBhIHNldCBvZiBBQkkgcmVjb3JkcyBzYXZlZCBvbiB0aGUgTGF0dGljZS4gWW91IGNhbiBmZXRjaFxuICAgICAqIHNlcXVlbnRpYWwgcmVjb3JkcyBiYXNlZCBvbiBhIHN0YXJ0aW5nIGluZGV4IGFuZCBjb3VudC5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgcmVzcG9uc2UuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRBYmlSZWNvcmRzID0gZnVuY3Rpb24gKG9wdHMsIF9jYiwgZmV0Y2hlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGNiID0gKDAsIHV0aWxfMS5wcm9taXNpZnlDYikocmVzb2x2ZSwgcmVqZWN0LCBfY2IpO1xuICAgICAgICAgICAgdmFyIF9hID0gb3B0cy5uLCBuID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYSwgX2IgPSBvcHRzLnN0YXJ0SWR4LCBzdGFydElkeCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gb3B0cy5jYXRlZ29yeSwgY2F0ZWdvcnkgPSBfYyA9PT0gdm9pZCAwID8gJycgOiBfYztcbiAgICAgICAgICAgIHZhciBmd0NvbnN0YW50cyA9ICgwLCBjb25zdGFudHNfMS5nZXRGd1ZlcnNpb25Db25zdCkoX3RoaXMuZndWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignTXVzdCByZXF1ZXN0IGF0IGxlYXN0IG9uZSByZWNvcmQgKG49MCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG4gPCAwIHx8IHN0YXJ0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignQm90aCBgbmAgYW5kIGBzdGFydElkeGAgbXVzdCBiZSA+PTAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmd0NvbnN0YW50cy5hYmlDYXRlZ29yeVN6KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdPdXRkYXRlZCBMYXR0aWNlIGZpcm13YXJlLiBQbGVhc2UgdXBkYXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2F0ZWdvcnkubGVuZ3RoID49IGZ3Q29uc3RhbnRzLmFiaUNhdGVnb3J5U3opIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoXCJjYXRlZ29yeSBtdXN0IGJlIDxcIi5jb25jYXQoZndDb25zdGFudHMuYWJpQ2F0ZWdvcnlTeiAtIDEsIFwiIGNoYXJhY3RlcnMsIGdvdCBcIikuY29uY2F0KGNhdGVnb3J5Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmZXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJZHg6IHN0YXJ0SWR4LFxuICAgICAgICAgICAgICAgICAgICBudW1SZW1haW5pbmc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bUZldGNoZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0ICsgZndDb25zdGFudHMuYWJpQ2F0ZWdvcnlTeik7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDE2TEUoc3RhcnRJZHgsIDApO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQxNkxFKG4sIDIpO1xuICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oY2F0ZWdvcnkpLmNvcHkocGF5bG9hZCwgNCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ0dFVF9BQklfUkVDT1JEUycsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvcnJlY3Qgd2FsbGV0IGFuZCBubyBlcnJvcnMgLS0gaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciBkID0gX3RoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKHJlcywgY29uc3RhbnRzXzEuZGVjUmVzTGVuZ3Rocy5nZXRBYmlSZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihkLmVycik7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciBvZmYgPSA2NTsgLy8gU2tpcCA2NSBieXRlIHB1YmtleSBwcmVmaXhcbiAgICAgICAgICAgICAgICB2YXIgbnVtUmVtYWluaW5nID0gZC5kYXRhLnJlYWRVSW50MzJMRShvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICAgICAgICAgIHZhciBudW1SZXR1cm5lZCA9IGQuZGF0YS5yZWFkVUludDgob2ZmKTtcbiAgICAgICAgICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBhZGRpbmcgZGF0YSBpZiB0aGVyZSBpcyBkYXRhIHRvIGFkZFxuICAgICAgICAgICAgICAgIGZldGNoZWQubnVtUmVtYWluaW5nID0gbnVtUmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIGlmICghZmV0Y2hlZC5yZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWQucmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVJldHVybmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIGFkZCB0aGUgZGVmXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWNrZWREZWYgPSBkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBldGhlcmV1bUFiaV8xLkFCSV9ERUZfU1opO1xuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZXRoZXJldW1BYmlfMS5BQklfREVGX1NaO1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGVkLnJlY29yZHMucHVzaCgoMCwgZXRoZXJldW1BYmlfMS51bnBhY2tBYmlEZWYpKHBhY2tlZERlZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIHRvdGFsIGNvdW50ZXJcbiAgICAgICAgICAgICAgICBvcHRzLm4gLT0gbnVtUmV0dXJuZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubiA8IDEgfHwgbnVtUmV0dXJuZWQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZWQubnVtRmV0Y2hlZCA9IGZldGNoZWQucmVjb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBmZXRjaGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgdGhlcmUgaXMgbW9yZSB0byBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBvcHRzLnN0YXJ0SWR4ICs9IG51bVJldHVybmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QWJpUmVjb3JkcyhvcHRzLCBjYiwgZmV0Y2hlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYHJlbW92ZUFiaVJlY29yZHNgIHJlcXVlc3RzIHJlbW92YWwgb2YgQUJJIHJlY29yZHMgb24gdGhlIGRldmljZS4gWW91IGNhbiByZXF1ZXN0XG4gICAgICogcmVtb3ZhbCBiYXNlZCBvbiBhIGRlc2lyZWQgc2V0IG9mIGZ1bmN0aW9uIHNpZ25hdHVyZXMuXG4gICAgICogQGNhdGVnb3J5IExhdHRpY2VcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUucmVtb3ZlQWJpUmVjb3JkcyA9IGZ1bmN0aW9uIChvcHRzLCBfY2IsIGNiRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY2JEYXRhID09PSB2b2lkIDApIHsgY2JEYXRhID0geyBudW1SZW1vdmVkOiAwLCBudW1UcmllZDogMCB9OyB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICB2YXIgc2lncyA9IG9wdHMuc2lncztcbiAgICAgICAgICAgIHZhciBmd0NvbnN0YW50cyA9ICgwLCBjb25zdGFudHNfMS5nZXRGd1ZlcnNpb25Db25zdCkoX3RoaXMuZndWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmICghZndDb25zdGFudHMuYWJpTWF4Um12KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdPdXRkYXRlZCBMYXR0aWNlIGZpcm13YXJlLiBQbGVhc2UgdXBkYXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ0F0IGxlYXN0IG9uZSBzaWduYXR1cmUgaW4gYHNpZ3NgIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2lnc1NsaWNlID0gc2lncy5zbGljZShjYkRhdGEubnVtVHJpZWQsIGNiRGF0YS5udW1UcmllZCArIGZ3Q29uc3RhbnRzLmFiaU1heFJtdik7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygxICsgKDQgKiBmd0NvbnN0YW50cy5hYmlNYXhSbXYpKTtcbiAgICAgICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNpZ3NTbGljZS5sZW5ndGgsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgICAgIHNpZ3NTbGljZS5mb3JFYWNoKGZ1bmN0aW9uIChzaWcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnQnVmID0gZXRoZXJldW1fMS5kZWZhdWx0LmVuc3VyZUhleEJ1ZmZlcihzaWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnQnVmLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdTaWduYXR1cmVzIG11c3QgYmUgNCBieXRlcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaWdCdWYuY29weShwYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoXCJFcnJvciB3cml0aW5nIHNpZ25hdHVyZTogXCIuY29uY2F0KGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ1JFTU9WRV9BQklfUkVDT1JEUycsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvcnJlY3Qgd2FsbGV0IGFuZCBubyBlcnJvcnMgLS0gaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciBkID0gX3RoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKHJlcywgY29uc3RhbnRzXzEuZGVjUmVzTGVuZ3Rocy5yZW1vdmVBYmlSZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihkLmVycik7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIHZhciBvZmYgPSA2NTsgLy8gU2tpcCA2NSBieXRlIHB1YmtleSBwcmVmaXhcbiAgICAgICAgICAgICAgICB2YXIgcm12ID0gZC5kYXRhLnJlYWRVSW50OChvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgICAgIGNiRGF0YS5udW1SZW1vdmVkICs9IHJtdjtcbiAgICAgICAgICAgICAgICBjYkRhdGEubnVtVHJpZWQgKz0gc2lnc1NsaWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2JEYXRhLm51bVRyaWVkID49IG9wdHMuc2lncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGNiRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHRoZXJlIGFyZSBtb3JlIHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlQWJpUmVjb3JkcyhvcHRzLCBjYiwgY2JEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgYWRkUGVybWlzc2lvblYwYCB0YWtlcyBpbiBhIGN1cnJlbmN5LCB0aW1lIHdpbmRvdywgc3BlbmRpbmcgbGltaXQsIGFuZCBkZWNpbWFscywgYW5kIGJ1aWxkcyBhXG4gICAgICogcGF5bG9hZCB0byBzZW5kIHRvIHRoZSBMYXR0aWNlLlxuICAgICAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5hZGRQZXJtaXNzaW9uVjAgPSBmdW5jdGlvbiAob3B0cywgX2NiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICB2YXIgY3VycmVuY3kgPSBvcHRzLmN1cnJlbmN5LCB0aW1lV2luZG93ID0gb3B0cy50aW1lV2luZG93LCBsaW1pdCA9IG9wdHMubGltaXQsIGRlY2ltYWxzID0gb3B0cy5kZWNpbWFscywgYXNzZXQgPSBvcHRzLmFzc2V0O1xuICAgICAgICAgICAgaWYgKCFjdXJyZW5jeSB8fFxuICAgICAgICAgICAgICAgIHRpbWVXaW5kb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIGxpbWl0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBkZWNpbWFscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdGltZVdpbmRvdyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGxpbWl0ID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdjdXJyZW5jeSwgdGltZVdpbmRvdywgZGVjaW1hbHMsIGFuZCBsaW1pdCBhcmUgYWxsIHJlcXVpcmVkIG9wdGlvbnMuJyk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lV2luZG93ID09PSAwIHx8IGxpbWl0ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYignVGltZSB3aW5kb3cgYW5kIHNwZW5kaW5nIGxpbWl0IG11c3QgYmUgcG9zaXRpdmUuJyk7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbmFtZSBvZiB0aGUgcGVybWlzc2lvblxuICAgICAgICAgICAgdmFyIG5hbWUgPSBjdXJyZW5jeTtcbiAgICAgICAgICAgIGlmIChhc3NldClcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiX1wiLmNvbmNhdChhc3NldCk7XG4gICAgICAgICAgICAvLyBTdGFydCBidWlsZGluZyB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMjkzKTtcbiAgICAgICAgICAgIC8vIENvcHkgdGhlIG5hbWVcbiAgICAgICAgICAgIGlmIChidWZmZXJfMS5CdWZmZXIuZnJvbShuYW1lKS5sZW5ndGggPiAyNTUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdBc3NldCBuYW1lIHRvbyBsb25nLicpO1xuICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20obmFtZSkuY29weShwYXlsb2FkLCAwKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGxpbWl0IHRvIGEgMzIgYnl0ZSBoZXggYnVmZmVyIGFuZCBjb3B5IGl0IGluXG4gICAgICAgICAgICB2YXIgbGltaXRCdWYgPSBldGhlcmV1bV8xLmRlZmF1bHQuZW5zdXJlSGV4QnVmZmVyKGxpbWl0KTtcbiAgICAgICAgICAgIGlmIChsaW1pdEJ1Zi5sZW5ndGggPiAzMilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ0xpbWl0IHRvbyBsYXJnZS4nKTtcbiAgICAgICAgICAgIGxpbWl0QnVmLmNvcHkocGF5bG9hZCwgMjU2ICsgKDMyIC0gbGltaXRCdWYubGVuZ3RoKSk7XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSB0aW1lIHdpbmRvdyAoc2Vjb25kcylcbiAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJCRSh0aW1lV2luZG93LCAyODgpO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KGRlY2ltYWxzLCAyOTIpO1xuICAgICAgICAgICAgLy8gRW5jcnlwdCB0aGUgcmVxdWVzdCBhbmQgc2VuZCBpdCB0byB0aGUgTGF0dGljZS5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVxdWVzdChwYXlsb2FkLCAnQUREX1BFUk1JU1NJT05fVjAnLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbm90aGVyIGVycm9yIGNhdWdodCwgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3Qgd2FsbGV0IGFuZCBubyBlcnJvcnMgLS0gaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF90aGlzLl9oYW5kbGVFbmNSZXNwb25zZShyZXMsIGNvbnN0YW50c18xLmRlY1Jlc0xlbmd0aHMuZW1wdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZC5lcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYGdldEt2UmVjb3Jkc2AgZmV0Y2hlcyBhIGxpc3Qgb2Yga2V5LXZhbHVlIHJlY29yZHMgZnJvbSB0aGUgTGF0dGljZS5cbiAgICAgKiBAY2F0ZWdvcnkgTGF0dGljZVxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S3ZSZWNvcmRzID0gZnVuY3Rpb24gKG9wdHMsIF9jYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGNiID0gKDAsIHV0aWxfMS5wcm9taXNpZnlDYikocmVzb2x2ZSwgcmVqZWN0LCBfY2IpO1xuICAgICAgICAgICAgdmFyIF9hID0gb3B0cy50eXBlLCB0eXBlID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgX2IgPSBvcHRzLm4sIG4gPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iLCBfYyA9IG9wdHMuc3RhcnQsIHN0YXJ0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICAgICAgICAgIHZhciBmd0NvbnN0YW50cyA9ICgwLCBjb25zdGFudHNfMS5nZXRGd1ZlcnNpb25Db25zdCkoX3RoaXMuZndWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmICghZndDb25zdGFudHMua3ZBY3Rpb25zQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignVW5zdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgZmlybXdhcmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignWW91IG11c3QgcmVxdWVzdCBhdCBsZWFzdCBvbmUgcmVjb3JkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobiA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiWW91IG1heSBvbmx5IHJlcXVlc3QgdXAgdG8gXCIuY29uY2F0KGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtLCBcIiByZWNvcmRzIGF0IG9uY2UuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDkpO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIDApO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KG4sIDQpO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHN0YXJ0LCA1KTtcbiAgICAgICAgICAgIC8vIEVuY3J5cHQgdGhlIHJlcXVlc3QgYW5kIHNlbmQgaXQgdG8gdGhlIExhdHRpY2UuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ0dFVF9LVl9SRUNPUkRTJywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW5vdGhlciBlcnJvciBjYXVnaHQsIHJldHVybiBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHdhbGxldCBhbmQgbm8gZXJyb3JzIC0tIGhhbmRsZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBjb25zdGFudHNfMS5kZWNSZXNMZW5ndGhzLmdldEt2UmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihkLmVycik7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlY29kZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZiA9IDY1OyAvLyBTa2lwIDY1IGJ5dGUgcHVia2V5IHByZWZpeFxuICAgICAgICAgICAgICAgICAgICB2YXIgblRvdGFsID0gcGFyc2VJbnQoZC5kYXRhLnNsaWNlKG9mZiwgb2ZmICsgNCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbkZldGNoZWQgPSBwYXJzZUludChkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAxKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRmV0Y2hlZCA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdUb28gbWFueSByZWNvcmRzIGZldGNoZWQuIEZpcm13YXJlIGVycm9yLicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5GZXRjaGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICByLmlkID0gcGFyc2VJbnQoZC5kYXRhLnNsaWNlKG9mZiwgb2ZmICsgNCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudHlwZSA9IHBhcnNlSW50KGQuZGF0YS5zbGljZShvZmYsIG9mZiArIDQpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByLmNhc2VTZW5zaXRpdmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGQuZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5U3ogPSBwYXJzZUludChkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAxKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5rZXkgPSBkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBrZXlTeiAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsU3ogPSBwYXJzZUludChkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyAxKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgci52YWwgPSBkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyB2YWxTeiAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZndDb25zdGFudHMua3ZWYWxNYXhTdHJTeiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHsgcmVjb3JkczogcmVjb3JkcywgdG90YWw6IG5Ub3RhbCwgZmV0Y2hlZDogbkZldGNoZWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYGFkZEt2UmVjb3Jkc2AgdGFrZXMgaW4gYSBzZXQgb2Yga2V5LXZhbHVlIHJlY29yZHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byBhZGQgdGhlbSB0byB0aGVcbiAgICAgKiBMYXR0aWNlLlxuICAgICAqIEBjYXRlZ29yeSBMYXR0aWNlXG4gICAgICogQHJldHVybnMgQSBjYWxsYmFjayB3aXRoIGFuIGVycm9yIG9yIG51bGwuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5hZGRLdlJlY29yZHMgPSBmdW5jdGlvbiAob3B0cywgX2NiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2IgPSAoMCwgdXRpbF8xLnByb21pc2lmeUNiKShyZXNvbHZlLCByZWplY3QsIF9jYik7XG4gICAgICAgICAgICB2YXIgX2EgPSBvcHRzLnR5cGUsIHR5cGUgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLCBfYiA9IG9wdHMucmVjb3JkcywgcmVjb3JkcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBfYyA9IG9wdHMuY2FzZVNlbnNpdGl2ZSwgY2FzZVNlbnNpdGl2ZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAgICAgdmFyIGZ3Q29uc3RhbnRzID0gKDAsIGNvbnN0YW50c18xLmdldEZ3VmVyc2lvbkNvbnN0KShfdGhpcy5md1ZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKCFmd0NvbnN0YW50cy5rdkFjdGlvbnNBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZWNvcmRzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignT25lIG9yIG1vcmUga2V5LXZhbHVlIG1hcHBpbmcgbXVzdCBiZSBwcm92aWRlZCBpbiBgcmVjb3Jkc2AgcGFyYW0uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhyZWNvcmRzKS5sZW5ndGggPiBmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihcIlRvbyBtYW55IGtleXMgcHJvdmlkZWQuIFBsZWFzZSBvbmx5IHByb3ZpZGUgdXAgdG8gXCIuY29uY2F0KGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtLCBcIi5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmtleXMocmVjb3JkcykubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYignWW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUga2V5IHRvIGFkZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDEgKyAxMzkgKiBmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSk7XG4gICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoT2JqZWN0LmtleXMocmVjb3JkcykubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIHZhciBvZmYgPSAxO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZWNvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcoa2V5KS5sZW5ndGggPiBmd0NvbnN0YW50cy5rdktleU1heFN0clN6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgXCIuY29uY2F0KGtleSwgXCIgdG9vIGxhcmdlLiBNdXN0IGJlIDw9XCIpLmNvbmNhdChmd0NvbnN0YW50cy5rdktleU1heFN0clN6LCBcIiBjaGFyYWN0ZXJzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlY29yZHNba2V5XSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyhyZWNvcmRzW2tleV0pLmxlbmd0aCA+IGZ3Q29uc3RhbnRzLmt2VmFsTWF4U3RyU3opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIFwiLmNvbmNhdChyZWNvcmRzW2tleV0sIFwiIHRvbyBsYXJnZS4gTXVzdCBiZSA8PVwiKS5jb25jYXQoZndDb25zdGFudHMua3ZWYWxNYXhTdHJTeiwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFN0cmluZyhrZXkpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nKHJlY29yZHNba2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXMgYW5kIHZhbHVlcyBtdXN0IGJlID4wIGNoYXJhY3RlcnMuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNvbnN0YW50c18xLkFTQ0lJX1JFR0VYLnRlc3Qoa2V5KSB8fCAhY29uc3RhbnRzXzEuQVNDSUlfUkVHRVgudGVzdChyZWNvcmRzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaWNvZGUgY2hhcmFjdGVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBJRCBwb3J0aW9uLiBUaGlzIHdpbGwgZ2V0IGFkZGVkIGJ5IGZpcm13YXJlLlxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoMCwgb2ZmKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSh0eXBlLCBvZmYpO1xuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KGNhc2VTZW5zaXRpdmUgPyAxIDogMCwgb2ZmKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQud3JpdGVVSW50OChTdHJpbmcoa2V5KS5sZW5ndGggKyAxLCBvZmYpO1xuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oU3RyaW5nKGtleSkpLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IGZ3Q29uc3RhbnRzLmt2S2V5TWF4U3RyU3ogKyAxO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoU3RyaW5nKHJlY29yZHNba2V5XSkubGVuZ3RoICsgMSwgb2ZmKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFN0cmluZyhyZWNvcmRzW2tleV0pKS5jb3B5KHBheWxvYWQsIG9mZik7XG4gICAgICAgICAgICAgICAgICAgIG9mZiArPSBmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6ICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoXCJFcnJvciBidWlsZGluZyByZXF1ZXN0OiBcIi5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuY3J5cHQgdGhlIHJlcXVlc3QgYW5kIHNlbmQgaXQgdG8gdGhlIExhdHRpY2UuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ0FERF9LVl9SRUNPUkRTJywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW5vdGhlciBlcnJvciBjYXVnaHQsIHJldHVybiBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHdhbGxldCBhbmQgbm8gZXJyb3JzIC0tIGhhbmRsZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBjb25zdGFudHNfMS5kZWNSZXNMZW5ndGhzLmVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQuZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGQuZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGByZW1vdmVLdlJlY29yZHNgIHRha2VzIGluIGFuIGFycmF5IG9mIGlkcyBhbmQgc2VuZHMgYSByZXF1ZXN0IHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIExhdHRpY2UuXG4gICAgICogQGNhdGVnb3J5IExhdHRpY2VcbiAgICAgKiBAcmV0dXJucyBBIGNhbGxiYWNrIHdpdGggYW4gZXJyb3Igb3IgbnVsbC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnJlbW92ZUt2UmVjb3JkcyA9IGZ1bmN0aW9uIChvcHRzLCBfY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjYiA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5Q2IpKHJlc29sdmUsIHJlamVjdCwgX2NiKTtcbiAgICAgICAgICAgIHZhciBfYSA9IG9wdHMudHlwZSwgdHlwZSA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsIF9iID0gb3B0cy5pZHMsIGlkcyA9IF9iID09PSB2b2lkIDAgPyBbXSA6IF9iO1xuICAgICAgICAgICAgdmFyIGZ3Q29uc3RhbnRzID0gKDAsIGNvbnN0YW50c18xLmdldEZ3VmVyc2lvbkNvbnN0KShfdGhpcy5md1ZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKCFmd0NvbnN0YW50cy5rdkFjdGlvbnNBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGlkcykgfHwgaWRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ1lvdSBtdXN0IGluY2x1ZGUgb25lIG9yIG1vcmUgYGlkc2AgdG8gcmVtb3ZlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkcy5sZW5ndGggPiBmd0NvbnN0YW50cy5rdlJlbW92ZU1heE51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihcIk9ubHkgdXAgdG8gXCIuY29uY2F0KGZ3Q29uc3RhbnRzLmt2UmVtb3ZlTWF4TnVtLCBcIiByZWNvcmRzIG1heSBiZSByZW1vdmVkIGF0IG9uY2UuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDUgKyA0ICogZndDb25zdGFudHMua3ZSZW1vdmVNYXhOdW0pO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIDApO1xuICAgICAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KGlkcy5sZW5ndGgsIDQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoaWRzW2ldLCA1ICsgNCAqIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5jcnlwdCB0aGUgcmVxdWVzdCBhbmQgc2VuZCBpdCB0byB0aGUgTGF0dGljZS5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVxdWVzdChwYXlsb2FkLCAnUkVNT1ZFX0tWX1JFQ09SRFMnLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbm90aGVyIGVycm9yIGNhdWdodCwgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3Qgd2FsbGV0IGFuZCBubyBlcnJvcnMgLS0gaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF90aGlzLl9oYW5kbGVFbmNSZXNwb25zZShyZXMsIGNvbnN0YW50c18xLmRlY1Jlc0xlbmd0aHMuZW1wdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZC5lcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIElOVEVSTkFMIEZVTkNUSU9OU1xuICAgIC8vIFRoZXNlIGhhbmRsZSB0aGUgbG9naWMgYXJvdW5kIGJ1aWxkaW5nIHJlcXVlc3RzIGFuZCBjb25zdW1pbmdcbiAgICAvLyByZXNwb25zZXMuIFRoZXkgdGFrZSBpbnRvIGFjY291bnQgdGhlIExhdHRpY2UncyBzZXJpYWxpemF0aW9uIHNjaGVtZVxuICAgIC8vIGFtb25nIG90aGVyIHByb3RvY29scy5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhY3RpdmUgd2FsbGV0IGluIHRoZSBkZXZpY2UuIElmIHdlIGFscmVhZHkgaGF2ZSBvbmUgcmVjb3JkZWQsIHdlIGRvbid0IG5lZWQgdG8gZG9cbiAgICAgKiBhbnl0aGluZ1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEByZXR1cm5zIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5fZ2V0QWN0aXZlV2FsbGV0ID0gZnVuY3Rpb24gKGNiLCBmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCA9PT0gdm9pZCAwKSB7IGZvcmNlUmVmcmVzaCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2ggIT09IHRydWUgJiZcbiAgICAgICAgICAgICh0aGlzLmhhc0FjdGl2ZVdhbGxldCgpID09PSB0cnVlIHx8IHRoaXMuaXNQYWlyZWQgIT09IHRydWUpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYWN0aXZlIHdhbGxldCBhbHJlYWR5IGV4aXN0cywgb3IgaWYgd2UgYXJlIG5vdCBwYWlyZWQsIHNraXAgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGFjdGl2ZSB3YWxsZXQ/IEdldCBpdCBmcm9tIHRoZSBkZXZpY2VcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QocGF5bG9hZCwgJ0dFVF9XQUxMRVRTJywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRBY3RpdmVXYWxsZXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoX3RoaXMuX2hhbmRsZUdldFdhbGxldHMocmVzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHZpYSBFQ0RIIGZyb20gdGhlIGxvY2FsIHByaXZhdGUga2V5IGFuZCB0aGUgZXBoZW1lcmFsIHB1YmxpYyBrZXlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJucyBCdWZmZXJcbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLl9nZXRTaGFyZWRTZWNyZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9uY2UgZXZlcnkgfjI1NiBhdHRlbXB0cywgd2Ugd2lsbCBnZXQgYSBrZXkgdGhhdCBzdGFydHMgd2l0aCBhIGAwMGAgYnl0ZSwgd2hpY2hcbiAgICAgICAgLy8gY2FuIGxlYWQgdG8gcHJvYmxlbXMgaW5pdGlhbGl6aW5nIEFFUyBpZiB3ZSBkb24ndCBmb3JjZSBhIDMyIGJ5dGUgQkUgYnVmZmVyLlxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odGhpcy5rZXkuZGVyaXZlKHRoaXMuZXBoZW1lcmFsUHViLmdldFB1YmxpYygpKS50b0FycmF5KCdiZScsIDMyKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVwaGVtZXJhbCBpZCwgd2hpY2ggaXMgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHNoYXJlZCBzZWNyZXQgZ2VuZXJhdGVkIGZyb20gdGhlIGxvY2FsXG4gICAgICogcHJpdmF0ZSBrZXkgYW5kIHRoZSBlcGhlbWVyYWwgcHVibGljIGtleSBmcm9tIHRoZSBkZXZpY2UuXG4gICAgICogQGludGVybmFsXG4gICAgICogQHJldHVybnMgQnVmZmVyXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5fZ2V0RXBoZW1JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXBoZW1lcmFsUHViID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEVwaGVtSWQgaXMgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIGhhc2ggb2YgdGhlIHNoYXJlZCBzZWNyZXRcbiAgICAgICAgdmFyIHNlY3JldCA9IHRoaXMuX2dldFNoYXJlZFNlY3JldCgpO1xuICAgICAgICB2YXIgaGFzaCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKHNlY3JldCkuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xuICAgICAgICByZXR1cm4gaGFzaC5zbGljZSgwLCA0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBlbmNyeXB0ZWQgcmVxdWVzdFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX2J1aWxkRW5jUmVxdWVzdCA9IGZ1bmN0aW9uIChlbmNfcmVxdWVzdF9jb2RlLCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZXBoZW1lcmFsIGlkIC0gYWxsIGVuY3J5cHRlZCByZXF1ZXN0cyByZXF1aXJlIHRoZXJlIHRvIGJlIGFuXG4gICAgICAgIC8vIGVwZWhlbWVyYWwgcHVibGljIGtleSBpbiBvcmRlciB0byBzZW5kXG4gICAgICAgIHZhciBlcGhlbUlkID0gcGFyc2VJbnQodGhpcy5fZ2V0RXBoZW1JZCgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgcGF5bG9hZCBhbmQgY2hlY2tzdW1cbiAgICAgICAgdmFyIHBheWxvYWRQcmVDcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oW2VuY19yZXF1ZXN0X2NvZGVdKSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgY3MgPSAoMCwgdXRpbF8xLmNoZWNrc3VtKShwYXlsb2FkUHJlQ3MpO1xuICAgICAgICB2YXIgcGF5bG9hZEJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhwYXlsb2FkUHJlQ3MubGVuZ3RoICsgNCk7XG4gICAgICAgIC8vIExhdHRpY2UgdmFsaWRhdGVzIGNoZWNrc3VtcyBpbiBsaXR0bGUgZW5kaWFuXG4gICAgICAgIHBheWxvYWRQcmVDcy5jb3B5KHBheWxvYWRCdWYsIDApO1xuICAgICAgICBwYXlsb2FkQnVmLndyaXRlVUludDMyTEUoY3MsIHBheWxvYWRQcmVDcy5sZW5ndGgpO1xuICAgICAgICAvLyBFbmNyeXB0IHRoaXMgcGF5bG9hZFxuICAgICAgICB2YXIgc2VjcmV0ID0gdGhpcy5fZ2V0U2hhcmVkU2VjcmV0KCk7XG4gICAgICAgIHZhciBuZXdFbmNQYXlsb2FkID0gKDAsIHV0aWxfMS5hZXMyNTZfZW5jcnlwdCkocGF5bG9hZEJ1Ziwgc2VjcmV0KTtcbiAgICAgICAgLy8gV3JpdGUgdG8gdGhlIG92ZXJhbGwgcGF5bG9hZC4gV2UgbXVzdCB1c2UgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgIC8vIGZvciBldmVyeSBlbmNyeXB0ZWQgcmVxdWVzdCBhbmQgbXVzdCBpbmNsdWRlIGEgMzItYml0IGVwaGVtSWRcbiAgICAgICAgLy8gYWxvbmcgd2l0aCB0aGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoY29uc3RhbnRzXzEuRU5DX01TR19MRU4gKyA0KTtcbiAgICAgICAgLy8gRmlyc3QgNCBieXRlcyBhcmUgdGhlIGVwaGVtZXJhbCBpZCAoaW4gbGl0dGxlIGVuZGlhbilcbiAgICAgICAgbmV3UGF5bG9hZC53cml0ZVVJbnQzMkxFKGVwaGVtSWQsIDApO1xuICAgICAgICAvLyBOZXh0IE4gYnl0ZXNcbiAgICAgICAgbmV3RW5jUGF5bG9hZC5jb3B5KG5ld1BheWxvYWQsIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZXF1ZXN0KGNvbnN0YW50c18xLmRldmljZUNvZGVzLkVOQ1JZUFRFRF9SRVFVRVNULCBuZXdQYXlsb2FkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgcmVxdWVzdCB0byBzZW5kIHRvIHRoZSBkZXZpY2UuXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHJlcXVlc3RfY29kZSB7dWludDh9IC0gOC1iaXQgdW5zaWduZWQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG1lc3NhZ2UgcmVxdWVzdCBjb2RlXG4gICAgICogQHBhcmFtIGlkIHtidWZmZXJ9IC0gNCBieXRlIGlkZW50aWZpZXIgKGNvbWVzIGZyb20gSFNNIGZvciBzdWJzZXF1ZW50IGVuY3J5cHRlZCByZXFzKVxuICAgICAqIEBwYXJhbSBwYXlsb2FkIHtidWZmZXJ9IC0gc2VyaWFsaXplZCBwYXlsb2FkXG4gICAgICogQHJldHVybnMge2J1ZmZlcn1cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLl9idWlsZFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdF9jb2RlLCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIExlbmd0aCBvZiBwYXlsb2FkO1xuICAgICAgICAvLyB3ZSBhZGQgMSB0byB0aGUgcGF5bG9hZCBsZW5ndGggdG8gYWNjb3VudCBmb3IgdGhlIHJlcXVlc3RfY29kZSBieXRlXG4gICAgICAgIHZhciBMID0gcGF5bG9hZCAmJiBidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkgPyBwYXlsb2FkLmxlbmd0aCArIDEgOiAxO1xuICAgICAgICBpZiAocmVxdWVzdF9jb2RlID09PSBjb25zdGFudHNfMS5kZXZpY2VDb2Rlcy5FTkNSWVBURURfUkVRVUVTVCkge1xuICAgICAgICAgICAgTCA9IDEgKyBwYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBwcmVSZXEgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoTCArIDgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgaGVhZGVyXG4gICAgICAgIGkgPSBwcmVSZXEud3JpdGVVSW50OChjb25zdGFudHNfMS5WRVJTSU9OX0JZVEUsIGkpO1xuICAgICAgICBpID0gcHJlUmVxLndyaXRlVUludDgoY29uc3RhbnRzXzEuUkVRVUVTVF9UWVBFX0JZVEUsIGkpO1xuICAgICAgICB2YXIgaWQgPSAoMCwgdXRpbF8xLnJhbmRvbUJ5dGVzKSg0KTtcbiAgICAgICAgaSA9IHByZVJlcS53cml0ZVVJbnQzMkJFKHBhcnNlSW50KFwiMHhcIi5jb25jYXQoaWQudG9TdHJpbmcoJ2hleCcpKSksIGkpO1xuICAgICAgICBpID0gcHJlUmVxLndyaXRlVUludDE2QkUoTCwgaSk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBwYXlsb2FkXG4gICAgICAgIGkgPSBwcmVSZXEud3JpdGVVSW50OChyZXF1ZXN0X2NvZGUsIGkpO1xuICAgICAgICBpZiAoTCA+IDEpXG4gICAgICAgICAgICBpID0gcGF5bG9hZC5jb3B5KHByZVJlcSwgaSk7XG4gICAgICAgIC8vIEFkZCB0aGUgY2hlY2tzdW1cbiAgICAgICAgdmFyIGNzID0gKDAsIHV0aWxfMS5jaGVja3N1bSkocHJlUmVxKTtcbiAgICAgICAgdmFyIHJlcSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhwcmVSZXEubGVuZ3RoICsgNCk7IC8vIDQtYnl0ZSBjaGVja3N1bVxuICAgICAgICBpID0gcHJlUmVxLmNvcHkocmVxKTtcbiAgICAgICAgcmVxLndyaXRlVUludDMyQkUoY3MsIGkpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3QgdG8gdGhlIGRldmljZSBhbmQgd2FpdCBmb3IgYSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29kZS5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIGVuY1JlcUNvZGUsIGNiLCByZXRyeUNvdW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyZXRyeUNvdW50ID09PSB2b2lkIDApIHsgcmV0cnlDb3VudCA9IHRoaXMucmV0cnlDb3VudDsgfVxuICAgICAgICBpZiAoIXRoaXMuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYignRGV2aWNlIElEIGlzIG5vdCBzZXQuIFBsZWFzZSBzZXQgaXQgYW5kIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNSZXFDb2RlICYmIGNvbnN0YW50c18xLmVuY1JlcUNvZGVzW2VuY1JlcUNvZGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYignVW5rbm93biBlbmNyeXB0ZWQgcmVxdWVzdCBjb2RlLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuY3J5cHQgdGhlIGRhdGEgaWYgYXBwcm9wcmlhdGUuIE1vc3QgcmVxdWVzdHMgYXJlIGVuZC10by1lbmQgZW5jcnlwdGVkLFxuICAgICAgICAvLyBidXQgc29tZSAoZS5nLiBDT05OTkVDVCkgYXJlIG5vdCBlbmNyeXB0ZWQuXG4gICAgICAgIHZhciBkYXRhID0gZW5jUmVxQ29kZVxuICAgICAgICAgICAgPyB0aGlzLl9idWlsZEVuY1JlcXVlc3QoY29uc3RhbnRzXzEuZW5jUmVxQ29kZXNbZW5jUmVxQ29kZV0sIHBheWxvYWQpXG4gICAgICAgICAgICA6IHBheWxvYWQ7XG4gICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdCh0aGlzLmJhc2VVcmwsIFwiL1wiKS5jb25jYXQodGhpcy5kZXZpY2VJZCk7XG4gICAgICAgIHN1cGVyYWdlbnRfMS5kZWZhdWx0XG4gICAgICAgICAgICAucG9zdCh1cmwpXG4gICAgICAgICAgICAudGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICAgICAgICAuc2VuZCh7IGRhdGE6IGRhdGEgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBmb3JtYXR0aW5nIG9yIGdlbmVyaWMgSFRUUCBlcnJvcnNcbiAgICAgICAgICAgIGlmICghcmVzIHx8ICFyZXMuYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihcIkludmFsaWQgcmVzcG9uc2U6IFwiLmNvbmNhdChyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5ib2R5LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiRXJyb3IgY29kZSBcIi5jb25jYXQocmVzLmJvZHkuc3RhdHVzLCBcIjogXCIpLmNvbmNhdChyZXMuYm9keS5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcmV0cnkgbG9naWNcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSAoMCwgdXRpbF8xLnBhcnNlTGF0dGljZTFSZXNwb25zZSkocmVzLmJvZHkubWVzc2FnZSk7XG4gICAgICAgICAgICB2YXIgZGV2aWNlQnVzeSA9IHBhcnNlZC5yZXNwb25zZUNvZGUgPT09IGNvbnN0YW50c18xLnJlc3BvbnNlQ29kZXMuUkVTUF9FUlJfREVWX0JVU1kgfHxcbiAgICAgICAgICAgICAgICBwYXJzZWQucmVzcG9uc2VDb2RlID09PSBjb25zdGFudHNfMS5yZXNwb25zZUNvZGVzLlJFU1BfRVJSX0dDRV9USU1FT1VUO1xuICAgICAgICAgICAgdmFyIHdyb25nV2FsbGV0ID0gcGFyc2VkLnJlc3BvbnNlQ29kZSA9PT0gY29uc3RhbnRzXzEucmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9XUk9OR19XQUxMRVQ7XG4gICAgICAgICAgICB2YXIgaW52YWxpZEVwaGVtSWQgPSBwYXJzZWQucmVzcG9uc2VDb2RlID09PSBjb25zdGFudHNfMS5yZXNwb25zZUNvZGVzLlJFU1BfRVJSX0lOVkFMSURfRVBIRU1fSUQ7XG4gICAgICAgICAgICB2YXIgY2FuUmV0cnkgPSByZXRyeUNvdW50ID4gMDtcbiAgICAgICAgICAgIC8vIFJlLWNvbm5lY3QgYW5kL29yIHJldHJ5IHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoY2FuUmV0cnkgJiYgZGV2aWNlQnVzeSkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgYSBmZXcgc2Vjb25kcyBhbmQgcmV0cnlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgZW5jUmVxQ29kZSwgY2IsIHJldHJ5Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhblJldHJ5ICYmIGludmFsaWRFcGhlbUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5jcnlwdGVkIGNoYW5uZWwgZ290IG91dCBvZiBzeW5jLiBSZWNvbm5lY3QgYW5kIHJldHJ5LlxuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoX3RoaXMuZGV2aWNlSWQsIGZ1bmN0aW9uIChlcnIsIGlzUGFpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IG9uIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1BhaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgd2UgYXJlIG5vdCBwYWlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYignTm90IHBhaXJlZCB0byBkZXZpY2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcXVlc3QocGF5bG9hZCwgZW5jUmVxQ29kZSwgY2IsIHJldHJ5Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhblJldHJ5ICYmIHdyb25nV2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jb3JyZWN0IHdhbGxldCBiZWluZyByZXF1ZXN0ZWQuIENsZWFyIHdhbGxldCBzdGF0ZS5cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRBY3RpdmVXYWxsZXRzKCk7XG4gICAgICAgICAgICAgICAgLy8gUmVjb25uZWN0LCB1cGRhdGUgd2FsbGV0IFVJRCwgYW5kIHJldHJ5XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdChfdGhpcy5kZXZpY2VJZCwgZnVuY3Rpb24gKGVyciwgaXNQYWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgb24gY29ubmVjdGlvbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUGFpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiB3ZSBhcmUgbm90IHBhaXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdOb3QgcGFpcmVkIHRvIGRldmljZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBuZXcgd2FsbGV0IFVJRCBpbiB0aGUgcGF5bG9hZCBhbmQgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IF90aGlzLl9yZXBsYWNlV2FsbGV0VUlEKGVuY1JlcUNvZGUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhbGxvd2VkIHRvIHJldHJ5LiBFeGl0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoJ1dyb25nIHdhbGxldC4gRmFpbGVkIHRvIHN3aXRjaC4gUGxlYXNlIHJlY29ubmVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdChwYXlsb2FkLCBlbmNSZXFDb2RlLCBjYiwgcmV0cnlDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VkLnJlc3BvbnNlQ29kZSB8fCBwYXJzZWQuZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKHBhcnNlZC5lcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYihjb25zdGFudHNfMS5yZXNwb25zZU1zZ3NbcGFyc2VkLnJlc3BvbnNlQ29kZV0gfHwgJ1Vua25vd24gcmVxdWVzdCBmYWlsdXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZFxuICAgICAgICAgICAgICAgIGNiKG51bGwsIHBhcnNlZC5kYXRhLCBwYXJzZWQucmVzcG9uc2VDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgaXNUaW1lb3V0ID0gZXJyLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnICYmIGVyci5lcnJubyA9PT0gJ0VUSU1FJztcbiAgICAgICAgICAgIGlmIChpc1RpbWVvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKCdUaW1lb3V0IHdhaXRpbmcgZm9yIGRldmljZS4gUGxlYXNlIGVuc3VyZSBpdCBpcyBjb25uZWN0ZWQgdG8gdGhlIGludGVybmV0IGFuZCB0cnkgYWdhaW4gaW4gYSBtaW51dGUuJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiRmFpbGVkIHRvIG1ha2UgcmVxdWVzdCB0byBkZXZpY2U6IFwiLmNvbmNhdChlcnIubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIC0tLS0tIERldmljZSByZXNwb25zZSAtLS0tLVxuICAgIC8qKlxuICAgICogYF9oYW5kbGVDb25uZWN0YCB3aWxsIGNhbGwgYFN0YXJ0UGFpcmluZ01vZGVgIG9uIHRoZSBkZXZpY2UsIHdoaWNoIGdpdmVzIHRoZSB1c2VyIDYwIHNlY29uZHMgdG8gZmluYWxpemVcbiAgICAqIHRoZSBwYWlyaW5nLiBUaGlzIHdpbGwgcmV0dXJuIGFuIGVwaGVtZXJhbCBwdWJsaWMga2V5LCB3aGljaCBpcyBuZWVkZWQgZm9yIHRoZSBuZXh0IHJlcXVlc3QuXG4gICAgKiAtIElmIHRoZSBkZXZpY2UgaXMgYWxyZWFkeSBwYWlyZWQsIHRoaXMgZXBoZW1QdWIgaXMgc2ltcGx5IHVzZWQgdG8gZW5jcnlwdCB0aGUgbmV4dCByZXF1ZXN0LlxuICAgICogLSBJZiB0aGUgZGV2aWNlIGlzIG5vdCBwYWlyZWQsIGl0IGlzIG5lZWRlZCB0byBwYWlyIHRoZSBkZXZpY2Ugd2l0aGluIDYwIHNlY29uZHMuXG4gICAgKiBAY2F0ZWdvcnkgRGV2aWNlIFJlc3BvbnNlXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqIEByZXR1cm5zIHRydWUgaWYgd2UgYXJlIHBhaXJlZCB0byB0aGUgZGV2aWNlIGFscmVhZHlcbiAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX2hhbmRsZUNvbm5lY3QgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICB2YXIgcGFpcmluZ1N0YXR1cyA9IHJlcy5yZWFkVUludDgob2ZmKTtcbiAgICAgICAgb2ZmKys7XG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHBhaXJlZCwgd2UgZ2V0IHRoZSBuZXh0IGVwaGVtZXJhbCBrZXlcbiAgICAgICAgdmFyIHB1YiA9IHJlcy5zbGljZShvZmYsIG9mZiArIDY1KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIG9mZiArPSA2NTtcbiAgICAgICAgLy8gR3JhYiB0aGUgZmlybXdhcmUgdmVyc2lvbiAod2lsbCBiZSAwLWxlbmd0aCBmb3Igb2xkZXIgZncgdmVyc2lvbnMpXG4gICAgICAgIC8vIEl0IGlzIG9mIGZvcm1hdCB8Zml4fG1pbm9yfG1ham9yfHJlc2VydmVkfFxuICAgICAgICB0aGlzLmZ3VmVyc2lvbiA9IHJlcy5zbGljZShvZmYsIG9mZiArIDQpO1xuICAgICAgICAvLyBTZXQgdGhlIHB1YmxpYyBrZXlcbiAgICAgICAgdGhpcy5lcGhlbWVyYWxQdWIgPSAoMCwgdXRpbF8xLmdldFAyNTZLZXlQYWlyRnJvbVB1YikocHViKTtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzdGF0ZSBvZiBvdXIgcGFpcmluZ1xuICAgICAgICByZXR1cm4gcGFpcmluZ1N0YXR1cyA9PT0gY29uc3RhbnRzXzEubWVzc2FnZUNvbnN0YW50cy5QQUlSRUQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGwgZW5jcnlwdGVkIHJlc3BvbnNlcyBtdXN0IGJlIGRlY3J5cHRlZCB3aXRoIHRoZSBwcmV2aW91cyBzaGFyZWQgc2VjcmV0LiBQZXIgc3BlY2lmaWNhdGlvbixcbiAgICAgKiBkZWNyeXB0ZWQgcmVzcG9uc2VzIHdpbGwgYWxsIGNvbnRhaW4gYSA2NS1ieXRlIHB1YmxpYyBrZXkgYXMgdGhlIHByZWZpeCwgd2hpY2ggYmVjb21lcyB0aGUgbmV3XG4gICAgICogYGVwaGVtZXJhbFB1YmAuXG4gICAgICogQGNhdGVnb3J5IERldmljZSBSZXNwb25zZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX2hhbmRsZUVuY1Jlc3BvbnNlID0gZnVuY3Rpb24gKGVuY1JlcywgbGVuKSB7XG4gICAgICAgIC8vIERlY3J5cHQgcmVzcG9uc2VcbiAgICAgICAgdmFyIHNlY3JldCA9IHRoaXMuX2dldFNoYXJlZFNlY3JldCgpO1xuICAgICAgICB2YXIgZW5jRGF0YSA9IGVuY1Jlcy5zbGljZSgwLCBjb25zdGFudHNfMS5FTkNfTVNHX0xFTik7XG4gICAgICAgIHZhciByZXMgPSAoMCwgdXRpbF8xLmFlczI1Nl9kZWNyeXB0KShlbmNEYXRhLCBzZWNyZXQpO1xuICAgICAgICAvLyBsZW4gZG9lcyBub3QgaW5jbHVkZSBhIDY1LWJ5dGUgcHVia2V5IHRoYXQgcHJlZmllcyBlYWNoIGVuY1Jlc3BvbnNlXG4gICAgICAgIGxlbiArPSA2NTtcbiAgICAgICAgLy8gVmFsaWRhdGUgY2hlY2tzdW0uIEl0IHdpbGwgYmUgdGhlIGxhc3QgNCBieXRlcyBvZiB0aGUgZGVjcnlwdGVkIHBheWxvYWQuXG4gICAgICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIGRlY3J5cHRlZCBwYXlsb2FkIHdpbGwgYmUgZml4ZWQgZm9yIGVhY2ggZ2l2ZW4gbWVzc2FnZSB0eXBlLlxuICAgICAgICB2YXIgdG9DaGVjayA9IHJlcy5zbGljZSgwLCBsZW4pO1xuICAgICAgICB2YXIgY3MgPSBwYXJzZUludChcIjB4XCIuY29uY2F0KHJlcy5zbGljZShsZW4sIGxlbiArIDQpLnRvU3RyaW5nKCdoZXgnKSkpO1xuICAgICAgICB2YXIgY3NDaGVjayA9ICgwLCB1dGlsXzEuY2hlY2tzdW0pKHRvQ2hlY2spO1xuICAgICAgICBpZiAoY3MgIT09IGNzQ2hlY2spXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycjogXCJDaGVja3N1bSBtaXNtYXRjaCBpbiByZXNwb25zZSBmcm9tIExhdHRpY2UgKGNhbGN1bGF0ZWQgXCIuY29uY2F0KGNzQ2hlY2ssIFwiLCB3YW50ZWQgXCIpLmNvbmNhdChjcywgXCIpXCIpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gRmlyc3QgNjUgYnl0ZXMgaXMgdGhlIG5leHQgZXBoZW1lcmFsIHB1YmtleVxuICAgICAgICB2YXIgcHViID0gcmVzLnNsaWNlKDAsIDY1KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmVwaGVtZXJhbFB1YiA9ICgwLCB1dGlsXzEuZ2V0UDI1NktleVBhaXJGcm9tUHViKShwdWIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyOiBudWxsLCBkYXRhOiByZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyOiBcIkVycm9yIGhhbmRsaW5nIGdldEFkZHJlc3NlcyByZXNwb25zZTogXCIuY29uY2F0KGUudG9TdHJpbmcoKSkgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFpciB3aWxsIGNyZWF0ZSBhIG5ldyBwYWlyaW5nIGlmIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBlbnRlcnMgdGhlIHNlY3JldCBpbnRvIHRoZSBkZXZpY2UgaW5cbiAgICAgKiB0aW1lLiBJZiBzdWNjZXNzZnVsIChgc3RhdHVzPTBgKSwgdGhlIGRldmljZSB3aWxsIHJldHVybiBhIG5ldyBlcGhlbWVyYWwgcHVibGljIGtleSwgd2hpY2ggaXNcbiAgICAgKiB1c2VkIHRvIGRlcml2ZSBhIHNoYXJlZCBzZWNyZXQgZm9yIHRoZSBuZXh0IHJlcXVlc3RcbiAgICAgKiBAY2F0ZWdvcnkgRGV2aWNlIFJlc3BvbnNlXG4gICAgICogQGludGVybmFsXG4gICAgICogQHJldHVybnMgZXJyb3IgKG9yIG51bGwpXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGFpciA9IGZ1bmN0aW9uIChlbmNSZXMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShlbmNSZXMsIGNvbnN0YW50c18xLmRlY1Jlc0xlbmd0aHMuZW1wdHkpO1xuICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgICByZXR1cm4gZC5lcnI7XG4gICAgICAgIHRoaXMuaXNQYWlyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBjYXRlZ29yeSBEZXZpY2UgUmVzcG9uc2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFkZHJlc3Mgc3RyaW5nc1xuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX2hhbmRsZUdldEFkZHJlc3NlcyA9IGZ1bmN0aW9uIChlbmNSZXMsIGZsYWcpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBlbmNyeXB0ZWQgcmVzcG9uc2VcbiAgICAgICAgdmFyIGRlY3J5cHRlZCA9IHRoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKGVuY1JlcywgY29uc3RhbnRzXzEuZGVjUmVzTGVuZ3Rocy5nZXRBZGRyZXNzZXMpO1xuICAgICAgICBpZiAoZGVjcnlwdGVkLmVyciAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBkZWNyeXB0ZWQ7XG4gICAgICAgIHZhciBhZGRyRGF0YSA9IGRlY3J5cHRlZC5kYXRhO1xuICAgICAgICB2YXIgb2ZmID0gNjU7IC8vIFNraXAgNjUgYnl0ZSBwdWJrZXkgcHJlZml4XG4gICAgICAgIC8vIExvb2sgZm9yIGFkZHJlc3NlcyB1bnRpbCB3ZSByZWFjaCB0aGUgZW5kIChhIDQgYnl0ZSBjaGVja3N1bSlcbiAgICAgICAgdmFyIGFkZHJzID0gW107XG4gICAgICAgIC8vIFB1YmtleXMgYXJlIGZvcm1hdHRlZCBkaWZmZXJlbnRseSBpbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgdmFyIF9hID0gaW5kZXhfMS5Db25zdGFudHMuR0VUX0FERFJfRkxBR1MsIEVEMjU1MTlfUFVCID0gX2EuRUQyNTUxOV9QVUIsIFNFQ1AyNTZLMV9QVUIgPSBfYS5TRUNQMjU2SzFfUFVCO1xuICAgICAgICB2YXIgYXJlUHVia2V5cyA9IGZsYWcgPT09IEVEMjU1MTlfUFVCIHx8XG4gICAgICAgICAgICBmbGFnID09PSBTRUNQMjU2SzFfUFVCO1xuICAgICAgICBpZiAoYXJlUHVia2V5cykge1xuICAgICAgICAgICAgb2ZmICs9IDE7IC8vIHNraXAgdWludDggcmVwcmVzZW50aW5nIHB1YmtleSB0eXBlXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9mZiArIDQgPCBjb25zdGFudHNfMS5kZWNSZXNMZW5ndGhzLmdldEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKGFyZVB1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBQdWJrZXlzIGFyZSBzaG9ydGVyIGFuZCBhcmUgcmV0dXJuZWQgYXMgYnVmZmVyc1xuICAgICAgICAgICAgICAgIHZhciBwdWJCeXRlcyA9IGFkZHJEYXRhLnNsaWNlKG9mZiwgb2ZmICsgNjUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gcHViQnl0ZXMuZXZlcnkoZnVuY3Rpb24gKGJ5dGUpIHsgcmV0dXJuIGJ5dGUgPT09IDB4MDA7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSAmJiBmbGFnID09PSBFRDI1NTE5X1BVQikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFRDI1NTE5IHB1YmtleXMgYXJlIDMyIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIGFkZHJzLnB1c2gocHViQnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBvdGhlciByZXR1cm5lZCBwdWJrZXlzIGFyZSBFQ0MsIG9yIDY1IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSByZXR1cm4gZnVsbCAodW5jb21wcmVzc2VkKSBFQ0MgcHVia2V5c1xuICAgICAgICAgICAgICAgICAgICBhZGRycy5wdXNoKHB1YkJ5dGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmICs9IDY1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBkZWFsaW5nIHdpdGggYWRkcmVzcyBzdHJpbmdzXG4gICAgICAgICAgICAgICAgdmFyIGFkZHJCeXRlcyA9IGFkZHJEYXRhLnNsaWNlKG9mZiwgb2ZmICsgY29uc3RhbnRzXzEuQUREUl9TVFJfTEVOKTtcbiAgICAgICAgICAgICAgICBvZmYgKz0gY29uc3RhbnRzXzEuQUREUl9TVFJfTEVOO1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgVVRGLTggcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYWRkckJ5dGVzLmluZGV4T2YoMCk7IC8vIEZpcnN0IDAgaXMgdGhlIG51bGwgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJzLnB1c2goYWRkckJ5dGVzLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGFkZHJzLCBlcnI6IG51bGwgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGFuIGFjdGl2ZSB3YWxsZXQsIHJldHVybiBudWxsLiBPdGhlcndpc2UsIHJldHVybiBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBjYXRlZ29yeSBEZXZpY2UgUmVzcG9uc2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gZW5jUmVzIC0gVGhlIGVuY3J5cHRlZCByZXNwb25zZSBmcm9tIHRoZSBkZXZpY2UuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5faGFuZGxlR2V0V2FsbGV0cyA9IGZ1bmN0aW9uIChlbmNSZXMpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlZCA9IHRoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKGVuY1JlcywgY29uc3RhbnRzXzEuZGVjUmVzTGVuZ3Rocy5nZXRXYWxsZXRzKTtcbiAgICAgICAgaWYgKGRlY3J5cHRlZC5lcnIgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZGVjcnlwdGVkO1xuICAgICAgICB2YXIgcmVzID0gZGVjcnlwdGVkLmRhdGE7XG4gICAgICAgIHZhciB3YWxsZXRVSUQ7XG4gICAgICAgIC8vIFJlYWQgdGhlIGV4dGVybmFsIHdhbGxldCBkYXRhIGZpcnN0LiBJZiBpdCBpcyBub24tbnVsbCwgdGhlIGV4dGVybmFsIHdhbGxldCB3aWxsXG4gICAgICAgIC8vIGJlIHRoZSBhY3RpdmUgd2FsbGV0IG9mIHRoZSBkZXZpY2UgYW5kIHdlIHNob3VsZCBzYXZlIGl0LlxuICAgICAgICAvLyBJZiB0aGUgZXh0ZXJuYWwgd2FsbGV0IGlzIGJsYW5rLCBpdCBtZWFucyB0aGVyZSBpcyBubyBjYXJkIHByZXNlbnQgYW5kIHdlIHNob3VsZFxuICAgICAgICAvLyBzYXZlIGFuZCB1c2UgdGhlIGludGVyYWwgd2FsbGV0LlxuICAgICAgICAvLyBJZiBib3RoIHdhbGxldHMgYXJlIGVtcHR5LCBpdCBtZWFucyB0aGUgZGV2aWNlIHN0aWxsIG5lZWRzIHRvIGJlIHNldCB1cC5cbiAgICAgICAgdmFyIHdhbGxldERlc2NyaXB0b3JMZW4gPSA3MTtcbiAgICAgICAgLy8gU2tpcCA2NWJ5dGUgcHVia2V5IHByZWZpeC4gV2FsbGV0RGVzY3JpcHRvciBjb250YWlucyAzMmJ5dGUgaWQgKyA0Ynl0ZSBmbGFnICsgMzVieXRlIG5hbWVcbiAgICAgICAgdmFyIG9mZiA9IDY1O1xuICAgICAgICAvLyBJbnRlcm5hbCBmaXJzdFxuICAgICAgICB2YXIgaGFzQWN0aXZlV2FsbGV0ID0gZmFsc2U7XG4gICAgICAgIHdhbGxldFVJRCA9IHJlcy5zbGljZShvZmYsIG9mZiArIDMyKTtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCA9IHdhbGxldFVJRDtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyA9IHJlcy5yZWFkVUludDMyQkUob2ZmICsgMzIpO1xuICAgICAgICB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwubmFtZSA9IHJlcy5zbGljZShvZmYgKyAzNiwgb2ZmICsgd2FsbGV0RGVzY3JpcHRvckxlbik7XG4gICAgICAgIGlmICghd2FsbGV0VUlELmVxdWFscyhFTVBUWV9XQUxMRVRfVUlEKSlcbiAgICAgICAgICAgIGhhc0FjdGl2ZVdhbGxldCA9IHRydWU7XG4gICAgICAgIC8vIE9mZnNldCB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBvZmYgKz0gd2FsbGV0RGVzY3JpcHRvckxlbjtcbiAgICAgICAgLy8gRXh0ZXJuYWxcbiAgICAgICAgd2FsbGV0VUlEID0gcmVzLnNsaWNlKG9mZiwgb2ZmICsgMzIpO1xuICAgICAgICB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkID0gd2FsbGV0VUlEO1xuICAgICAgICB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwuY2FwYWJpbGl0aWVzID0gcmVzLnJlYWRVSW50MzJCRShvZmYgKyAzMik7XG4gICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5uYW1lID0gcmVzLnNsaWNlKG9mZiArIDM2LCBvZmYgKyB3YWxsZXREZXNjcmlwdG9yTGVuKTtcbiAgICAgICAgaWYgKCF3YWxsZXRVSUQuZXF1YWxzKEVNUFRZX1dBTExFVF9VSUQpKVxuICAgICAgICAgICAgaGFzQWN0aXZlV2FsbGV0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhc0FjdGl2ZVdhbGxldCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gJ05vIGFjdGl2ZSB3YWxsZXQuJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBfaGFuZGxlU2lnbmAgdGFrZXMgdGhlIGVuY3J5cHRlZCByZXNwb25zZSBmcm9tIHRoZSBkZXZpY2UgYW5kIGRlY3J5cHRzIGl0LiBJdCB0aGVuIHBhcnNlcyB0aGVcbiAgICAgKiBkZWNyeXB0ZWQgcmVzcG9uc2UgYW5kIHJldHVybnMgdGhlIGRhdGEuXG4gICAgICogQGNhdGVnb3J5IERldmljZSBSZXNwb25zZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBlbmNSZXMgLSBUaGUgZW5jcnlwdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBjdXJyZW5jeVR5cGUgLSBUaGUgdHlwZSBvZiBjdXJyZW5jeSBiZWluZyBzaWduZWQuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IGRhdGFcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gZGF0YSwgdGhlIHRyYW5zYWN0aW9uIGhhc2gsIGFuZCB0aGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVNpZ24gPSBmdW5jdGlvbiAoZW5jUmVzLCBjdXJyZW5jeVR5cGUsIHJlcSkge1xuICAgICAgICBpZiAocmVxID09PSB2b2lkIDApIHsgcmVxID0gbnVsbDsgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGVuY3J5cHRlZCByZXNwb25zZVxuICAgICAgICB2YXIgZGVjcnlwdGVkID0gdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UoZW5jUmVzLCBjb25zdGFudHNfMS5kZWNSZXNMZW5ndGhzLnNpZ24pO1xuICAgICAgICBpZiAoZGVjcnlwdGVkLmVyciAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGVycjogZGVjcnlwdGVkLmVyciB9O1xuICAgICAgICB2YXIgUFVCS0VZX1BSRUZJWF9MRU4gPSA2NTtcbiAgICAgICAgdmFyIFBLSF9QUkVGSVhfTEVOID0gMjA7XG4gICAgICAgIHZhciBvZmYgPSBQVUJLRVlfUFJFRklYX0xFTjsgLy8gU2tpcCBwYXN0IHB1YmtleSBwcmVmaXhcbiAgICAgICAgdmFyIHJlcyA9IGRlY3J5cHRlZC5kYXRhO1xuICAgICAgICAvLyBHZXQgdGhlIGNoYW5nZSBkYXRhIGlmIHdlIGFyZSBtYWtpbmcgYSBCVEMgdHJhbnNhY3Rpb25cbiAgICAgICAgdmFyIGNoYW5nZVJlY2lwaWVudDtcbiAgICAgICAgaWYgKGN1cnJlbmN5VHlwZSA9PT0gJ0JUQycpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VWZXJzaW9uID0gYml0Y29pbl8xLmRlZmF1bHQuZ2V0QWRkcmVzc0Zvcm1hdChyZXEub3JpZ0RhdGEuY2hhbmdlUGF0aCk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlUHVia2V5aGFzaCA9IHJlcy5zbGljZShvZmYsIG9mZiArIFBLSF9QUkVGSVhfTEVOKTtcbiAgICAgICAgICAgIG9mZiArPSBQS0hfUFJFRklYX0xFTjtcbiAgICAgICAgICAgIGNoYW5nZVJlY2lwaWVudCA9IGJpdGNvaW5fMS5kZWZhdWx0LmdldEJpdGNvaW5BZGRyZXNzKGNoYW5nZVB1YmtleWhhc2gsIGNoYW5nZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBERVJMZW5ndGggPSA3NDsgLy8gbWF4IHNpemUgb2YgYSBERVIgc2lnbmF0dXJlIC0tIGFsbCBMYXR0aWNlIHNpZ3MgYXJlIHRoaXMgbG9uZ1xuICAgICAgICB2YXIgU0lHU19PRkZTRVQgPSAxMCAqIERFUkxlbmd0aDsgLy8gMTAgc2lnbmF0dXJlIHNsb3RzIHByZWNlZGUgMTAgcHVia2V5IHNsb3RzXG4gICAgICAgIHZhciBQVUJLRVlTX09GRlNFVCA9IFBVQktFWV9QUkVGSVhfTEVOICsgUEtIX1BSRUZJWF9MRU4gKyBTSUdTX09GRlNFVDtcbiAgICAgICAgaWYgKGN1cnJlbmN5VHlwZSA9PT0gJ0JUQycpIHtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkUHViTGVuZ3RoID0gMzM7IC8vIFNpemUgb2YgY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICAgICAgICB2YXIgcHVia2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBzaWduYXR1cmUgZm9yIGVhY2ggb3V0cHV0IC0tIHRoZXkgYXJlIHJldHVybmVkXG4gICAgICAgICAgICAvLyBpbiB0aGUgc2VyaWFsaXplZCBwYXlsb2FkIGluIGZvcm0gW3B1YmtleSwgc2lnXVxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgb25lIHNpZ25hdHVyZSBwZXIgb3V0cHV0XG4gICAgICAgICAgICB3aGlsZSAob2ZmIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEV4aXQgb3V0IGlmIHdlIGhhdmUgc2VlbiBhbGwgdGhlIHJldHVybmVkIHNpZ3MgYW5kIHB1YmtleXNcbiAgICAgICAgICAgICAgICBpZiAocmVzW29mZl0gIT09IDB4MzApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBncmFiIGFub3RoZXIgc2V0XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFsbCBERVIgc2lncyByZXR1cm5lZCBmaWxsIHRoZSBtYXhpbXVtIDc0IGJ5dGUgYnVmZmVyLCBidXQgYWxzb1xuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW4gYSBsZW5ndGggYXQgb2ZmKzEsIHdoaWNoIHdlIHVzZSB0byBwYXJzZSB0aGUgbm9uLXplcm8gZGF0YS5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBnZXQgdGhlIHNpZ25hdHVyZSBmcm9tIGl0cyBzbG90XG4gICAgICAgICAgICAgICAgdmFyIHNpZ1N0YXJ0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIHZhciBzaWdFbmQgPSBvZmYgKyAyICsgcmVzW29mZiArIDFdO1xuICAgICAgICAgICAgICAgIHNpZ3MucHVzaChyZXMuc2xpY2Uoc2lnU3RhcnQsIHNpZ0VuZCkpO1xuICAgICAgICAgICAgICAgIC8vIE5leHQsIHNoaWZ0IGJ5IHRoZSBmdWxsIHNldCBvZiBzaWduYXR1cmVzIHRvIGhpdCB0aGUgcmVzcGVjdGl2ZSBwdWJrZXlcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGUgZGF0YSByZXR1cm5lZCBpczogWzxzaWcwPiwgPHNpZzE+LCAuLi4gPHNpZzk+XVs8cHVia2V5MD4sIDxwdWJrZXkxPiwgLi4uIDxwdWJrZXk5Pl1cbiAgICAgICAgICAgICAgICB2YXIgcHViU3RhcnQgPSBuICogY29tcHJlc3NlZFB1Ykxlbmd0aCArIFBVQktFWVNfT0ZGU0VUO1xuICAgICAgICAgICAgICAgIHZhciBwdWJFbmQgPSAobiArIDEpICogY29tcHJlc3NlZFB1Ykxlbmd0aCArIFBVQktFWVNfT0ZGU0VUO1xuICAgICAgICAgICAgICAgIHB1YmtleXMucHVzaChyZXMuc2xpY2UocHViU3RhcnQsIHB1YkVuZCkpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBvZmZzZXQgdG8gaGl0IHRoZSBuZXh0IHNpZ25hdHVyZSBzbG90XG4gICAgICAgICAgICAgICAgb2ZmICs9IERFUkxlbmd0aDtcbiAgICAgICAgICAgICAgICBuICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgICAgICB2YXIgcHJlU2VyaWFsaXplZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBGaXJzdCBvdXRwdXQgY29tZXMgZnJvbSByZXF1ZXN0IGR0YVxuICAgICAgICAgICAgcHJlU2VyaWFsaXplZERhdGEub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVxLm9yaWdEYXRhLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogcmVxLm9yaWdEYXRhLnJlY2lwaWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlcS5jaGFuZ2VEYXRhLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNlY29uZCBvdXRwdXQgY29tZXMgZnJvbSBjaGFuZ2UgZGF0YVxuICAgICAgICAgICAgICAgIHByZVNlcmlhbGl6ZWREYXRhLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXEuY2hhbmdlRGF0YS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjaXBpZW50OiBjaGFuZ2VSZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGlucHV0c1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJlU2VyaWFsaXplZERhdGEuaW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBoYXNoOiByZXEub3JpZ0RhdGEucHJldk91dHNbaV0udHhIYXNoLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcmVxLm9yaWdEYXRhLnByZXZPdXRzW2ldLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBzaWc6IHNpZ3NbaV0sXG4gICAgICAgICAgICAgICAgICAgIHB1YmtleTogcHVia2V5c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyUGF0aDogcmVxLm9yaWdEYXRhLnByZXZPdXRzW2ldLnNpZ25lclBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBzZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZFR4ID0gYml0Y29pbl8xLmRlZmF1bHQuc2VyaWFsaXplVHgocHJlU2VyaWFsaXplZERhdGEpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHRyYW5zYWN0aW9uIGhhc2ggc28gdGhlIHVzZXIgY2FuIGxvb2sgdGhpcyB0cmFuc2FjdGlvbiB1cCBsYXRlclxuICAgICAgICAgICAgdmFyIHByZUltYWdlVHhIYXNoID0gc2VyaWFsaXplZFR4O1xuICAgICAgICAgICAgdmFyIHR4SGFzaFByZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHByZUltYWdlVHhIYXNoLCAnaGV4JykpLmRpZ2VzdCgnaGV4JyksICdoZXgnKTtcbiAgICAgICAgICAgIC8vIEFkZCBleHRyYSBkYXRhIGZvciBkZWJ1Z2dpbmcvbG9va3VwIHB1cnBvc2VzXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR4OiBzZXJpYWxpemVkVHgsXG4gICAgICAgICAgICAgICAgdHhIYXNoOiAoMCwgc2hhXzEuc2hhMjU2KSgpLnVwZGF0ZSh0eEhhc2hQcmUpLmRpZ2VzdCgnaGV4JyksXG4gICAgICAgICAgICAgICAgY2hhbmdlUmVjaXBpZW50OiBjaGFuZ2VSZWNpcGllbnQsXG4gICAgICAgICAgICAgICAgc2lnczogc2lncyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVuY3lUeXBlID09PSAnRVRIJykge1xuICAgICAgICAgICAgdmFyIHNpZyA9ICgwLCB1dGlsXzEucGFyc2VERVIpKHJlcy5zbGljZShvZmYsIG9mZiArIDIgKyByZXNbb2ZmICsgMV0pKTtcbiAgICAgICAgICAgIG9mZiArPSBERVJMZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXRoQWRkciA9IHJlcy5zbGljZShvZmYsIG9mZiArIDIwKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgYHZgIHBhcmFtIGFuZCBhZGQgaXQgdG8gdGhlIHNpZyBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgICAgICB2YXIgX2EgPSBldGhlcmV1bV8xLmRlZmF1bHQuYnVpbGRFdGhSYXdUeChyZXEsIHNpZywgZXRoQWRkciksIHJhd1R4ID0gX2EucmF3VHgsIHNpZ1dpdGhWID0gX2Euc2lnV2l0aFY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR4OiBcIjB4XCIuY29uY2F0KHJhd1R4KSxcbiAgICAgICAgICAgICAgICB0eEhhc2g6IFwiMHhcIi5jb25jYXQoZXRoZXJldW1fMS5kZWZhdWx0Lmhhc2hUcmFuc2FjdGlvbihyYXdUeCkpLFxuICAgICAgICAgICAgICAgIHNpZzoge1xuICAgICAgICAgICAgICAgICAgICB2OiBzaWdXaXRoVi52LFxuICAgICAgICAgICAgICAgICAgICByOiBzaWdXaXRoVi5yLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgczogc2lnV2l0aFYucy50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWduZXI6IGV0aEFkZHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbmN5VHlwZSA9PT0gJ0VUSF9NU0cnKSB7XG4gICAgICAgICAgICB2YXIgc2lnID0gKDAsIHV0aWxfMS5wYXJzZURFUikocmVzLnNsaWNlKG9mZiwgb2ZmICsgMiArIHJlc1tvZmYgKyAxXSkpO1xuICAgICAgICAgICAgb2ZmICs9IERFUkxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzaWduZXIgPSByZXMuc2xpY2Uob2ZmLCBvZmYgKyAyMCk7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVkU2lnID0gZXRoZXJldW1fMS5kZWZhdWx0LnZhbGlkYXRlRXRoZXJldW1Nc2dSZXNwb25zZSh7IHNpZ25lcjogc2lnbmVyLCBzaWc6IHNpZyB9LCByZXEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdjogdmFsaWRhdGVkU2lnLnYsXG4gICAgICAgICAgICAgICAgICAgIHI6IHZhbGlkYXRlZFNpZy5yLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgczogdmFsaWRhdGVkU2lnLnMudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lnbmVyOiBzaWduZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VuZXJpYyBzaWduaW5nIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiAoMCwgZ2VuZXJpY1NpZ25pbmdfMS5wYXJzZUdlbmVyaWNTaWduaW5nUmVzcG9uc2UpKHJlcywgb2ZmLCByZXEuY3VydmVUeXBlLCByZXEub21pdFB1YmtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBhY3RpdmUgd2FsbGV0cyB0byBlbXB0eSB2YWx1ZXMuXG4gICAgICogQGNhdGVnb3J5IERldmljZSBSZXNwb25zZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX3Jlc2V0QWN0aXZlV2FsbGV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCA9IEVNUFRZX1dBTExFVF9VSUQ7XG4gICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC51aWQgPSBFTVBUWV9XQUxMRVRfVUlEO1xuICAgICAgICB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwubmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5jYXBhYmlsaXRpZXMgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBheWxvYWQgd2l0aCB0aGUgY3VycmVudCB3YWxsZXQgVUlELlxuICAgICAqIFNvbWUgKG5vdCBhbGwpIHJlcXVlc3RzIHJlcXVpcmUgdGhlIGFjdGl2ZSB3YWxsZXQgVUlEXG4gICAgICogaW4gb3JkZXIgZm9yIExhdHRpY2UgZmlybXdhcmUgdG8gYWNjZXB0IHRoZW0uIElmIHdlIGdldFxuICAgICAqIGEgXCJ3cm9uZyB3YWxsZXRcIiBlcnJvciwgdGhlIFNESyB3aWxsIGF1dG9tYXRpY2FsbHkgcmVxdWVzdFxuICAgICAqIHRoZSBjdXJyZW50IHdhbGxldCBVSUQgZnJvbSB0aGUgZGV2aWNlIGFuZCBtYXkgcmV0cnkgdGhlXG4gICAgICogcmVxdWVzdCwgYnV0IHRoZSBvcmlnaW5hbCByZXF1ZXN0IHBheWxvYWQgbXVzdCBiZSBtb2RpZmllZC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLl9yZXBsYWNlV2FsbGV0VUlEID0gZnVuY3Rpb24gKGVuY1JlcUNvZGUsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdhbGxldCA9IHRoaXMuZ2V0QWN0aXZlV2FsbGV0KCk7XG4gICAgICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIG1vZGlmeSB0aGUgcGF5bG9hZCBhbmQgcmV0cnlcbiAgICAgICAgaWYgKGVuY1JlcUNvZGUgPT09ICdHRVRfQUREUkVTU0VTJykge1xuICAgICAgICAgICAgd2FsbGV0LnVpZC5jb3B5KHBheWxvYWQsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jUmVxQ29kZSA9PT0gJ1NJR05fVFJBTlNBQ1RJT04nKSB7XG4gICAgICAgICAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgMik7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgYWxsb3dlZCB0byByZXRyeVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBKU09OLXN0cmluZ2lmaWVkIHZlcnNpb24gb2Ygc3RhdGUgZGF0YS4gQ2FuIGJlIHVzZWQgdG9cbiAgICAgKiByZWh5ZHJhdGUgYW4gU0RLIHNlc3Npb24gd2l0aG91dCByZWNvbm5lY3RpbmcgdG8gdGhlIHRhcmdldCBMYXR0aWNlLlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuX3BhY2tTdGF0ZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVXYWxsZXRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC51aWQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLm5hbWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZC50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwubmFtZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcGhlbWVyYWxQdWI6IHRoaXMuZXBoZW1lcmFsUHViLmdldFB1YmxpYygpLmVuY29kZSgnaGV4JyksXG4gICAgICAgICAgICAgICAgZndWZXJzaW9uOiB0aGlzLmZ3VmVyc2lvbi50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGJhc2VVcmw6IHRoaXMuYmFzZVVybCxcbiAgICAgICAgICAgICAgICBwcml2S2V5OiB0aGlzLnByaXZLZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IHRoaXMucmV0cnlDb3VudCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHBhY2sgc3RhdGUgZGF0YS4nKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnBhY2sgYSBKU09OLXN0cmluZ2lmaWVkIHZlcnNpb24gb2Ygc3RhdGUgZGF0YSBhbmQgYXBwbHkgaXQgdG8gc3RhdGUuXG4gICAgICogVGhpcyB3aWxsIGFsbG93IHVzIHRvIHJlaHlkcmF0ZSBhbiBvbGQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLl91bnBhY2tBbmRBcHBseVN0YXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdW5wYWNrZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdHkgdG8gcGFyc2UgdGhlIGRhdGFcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbFdhbGxldCA9IHtcbiAgICAgICAgICAgICAgICB1aWQ6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHVucGFja2VkLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwudWlkLCAnaGV4JyksXG4gICAgICAgICAgICAgICAgbmFtZTogYnVmZmVyXzEuQnVmZmVyLmZyb20odW5wYWNrZWQuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5uYW1lKSxcbiAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHVucGFja2VkLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxXYWxsZXQgPSB7XG4gICAgICAgICAgICAgICAgdWlkOiBidWZmZXJfMS5CdWZmZXIuZnJvbSh1bnBhY2tlZC5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCwgJ2hleCcpLFxuICAgICAgICAgICAgICAgIG5hbWU6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHVucGFja2VkLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwubmFtZSksXG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB1bnBhY2tlZC5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLmNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXBoZW1lcmFsUHViQnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuZnJvbSh1bnBhY2tlZC5lcGhlbWVyYWxQdWIsICdoZXgnKTtcbiAgICAgICAgICAgIHZhciBmd1ZlcnNpb25CeXRlcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHVucGFja2VkLmZ3VmVyc2lvbiwgJ2hleCcpO1xuICAgICAgICAgICAgdmFyIHByaXZLZXlCeXRlcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHVucGFja2VkLnByaXZLZXksICdoZXgnKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHVucGFja2VkIHBhcmFtc1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsID0gaW50ZXJuYWxXYWxsZXQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwgPSBleHRlcm5hbFdhbGxldDtcbiAgICAgICAgICAgIHRoaXMuZXBoZW1lcmFsUHViID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpckZyb21QdWIpKGVwaGVtZXJhbFB1YkJ5dGVzKTtcbiAgICAgICAgICAgIHRoaXMuZndWZXJzaW9uID0gZndWZXJzaW9uQnl0ZXM7XG4gICAgICAgICAgICB0aGlzLmRldmljZUlkID0gdW5wYWNrZWQuZGV2aWNlSWQ7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB1bnBhY2tlZC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5iYXNlVXJsID0gdW5wYWNrZWQuYmFzZVVybDtcbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9IHByaXZLZXlCeXRlcztcbiAgICAgICAgICAgIHRoaXMua2V5ID0gKDAsIHV0aWxfMS5nZXRQMjU2S2V5UGFpcikodGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudCA9IHVucGFja2VkLnJldHJ5Q291bnQ7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB1bnBhY2tlZC50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGFwcGx5IHN0YXRlIGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWN0aXZlIHdhbGxldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWN0aXZlIHdhbGxldC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLmdldEFjdGl2ZVdhbGxldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFFTVBUWV9XQUxMRVRfVUlELmVxdWFscyh0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwudWlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghRU1QVFlfV0FMTEVUX1VJRC5lcXVhbHModGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHVzZXIgaGFzIGFuIGFjdGl2ZSB3YWxsZXRcIlxuICAgICAqIEByZXR1cm5zIHRydWUgaXMgdXNlciBoYXMgYWN0aXZlIHdhbGxldFxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUuaGFzQWN0aXZlV2FsbGV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVXYWxsZXQoKSAhPT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCA2NCBieXRlcyByZXByZXNlbnRpbmcgdGhlIHB1YmxpYyBrZXlcbiAgICAgKiBUaGlzIGlzIHRoZSB1bmNvbXByZXNzZWQga2V5IHdpdGhvdXQgdGhlIGxlYWRpbmcgMDQgYnl0ZVxuICAgICAqIEBwYXJhbSBMRSAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwdWJsaWMga2V5IGluIGxpdHRsZSBlbmRpYW4gZm9ybWF0LlxuICAgICAqIEByZXR1cm5zIEEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5wdWJLZXlCeXRlcyA9IGZ1bmN0aW9uIChMRSkge1xuICAgICAgICBpZiAoTEUgPT09IHZvaWQgMCkgeyBMRSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBrID0gdGhpcy5rZXkuZ2V0UHVibGljKCk7XG4gICAgICAgIHZhciBwID0gay5lbmNvZGUoJ2hleCcpO1xuICAgICAgICB2YXIgcGIgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShwLCAnaGV4Jyk7XG4gICAgICAgIGlmIChMRSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBmbGlwIFggYW5kIFkgY29tcG9uZW50cyB0byBsaXR0bGUgZW5kaWFuXG4gICAgICAgICAgICB2YXIgeCA9IHBiLnNsaWNlKDEsIDMzKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB2YXIgeSA9IHBiLnNsaWNlKDMzLCA2NSkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRPRE86IEZpbmQgb3V0IHdoeSBCdWZmZXIgd29uJ3QgYWNjZXB0IHBiWzBdXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbcGJbMF0sIHgsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gZXhwb3J0IHRoaXMuXG4gICAgICogYHBhcnNlQWJpYCB0YWtlcyBhIHNvdXJjZSBhbmQgZGF0YSBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBwYXJzZWQgQUJJLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIG9mIHRoZSBBQkkgZGF0YS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSBza2lwRXJyb3JzIC0gSWYgdHJ1ZSwgZXJyb3JzIHdpbGwgYmUgc2tpcHBlZCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoXG4gICAgICogYW4gZXJyb3IgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCBBQkkuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5wYXJzZUFiaSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRhdGEsIHNraXBFcnJvcnMpIHtcbiAgICAgICAgaWYgKHNraXBFcnJvcnMgPT09IHZvaWQgMCkgeyBza2lwRXJyb3JzID0gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aGVyc2Nhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV0aGVyZXVtQWJpXzEuYWJpUGFyc2Vyc1tzb3VyY2VdKGRhdGEsIHNraXBFcnJvcnMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnI6IFwiTm8gXCIuY29uY2F0KHNvdXJjZSwgXCIgcGFyc2VyIGF2YWlsYWJsZS5cIikgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpKHJlcXVpcmUoJy4vbGliL2VsbGlwdGljJykpXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9hcGkgPSByZXF1aXJlKFwiLi9hcGlcIik7XG5cbk9iamVjdC5rZXlzKF9hcGkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9hcGlba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfYXBpW2tleV07XG59KTtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XG5cbk9iamVjdC5rZXlzKF9ldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9ldmVudHNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfZXZlbnRzW2tleV07XG59KTtcblxudmFyIF9taXNjID0gcmVxdWlyZShcIi4vbWlzY1wiKTtcblxuT2JqZWN0LmtleXMoX21pc2MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9taXNjW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX21pc2Nba2V5XTtcbn0pO1xuXG52YXIgX3BhcmFtcyA9IHJlcXVpcmUoXCIuL3BhcmFtc1wiKTtcblxuT2JqZWN0LmtleXMoX3BhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3BhcmFtc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9wYXJhbXNba2V5XTtcbn0pO1xuXG52YXIgX2FjY291bnQgPSByZXF1aXJlKFwiLi9hY2NvdW50XCIpO1xuXG5PYmplY3Qua2V5cyhfYWNjb3VudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2FjY291bnRba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfYWNjb3VudFtrZXldO1xufSk7XG5cbnZhciBfZGV2aWNlID0gcmVxdWlyZShcIi4vdHJlem9yL2RldmljZVwiKTtcblxuT2JqZWN0LmtleXMoX2RldmljZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2RldmljZVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9kZXZpY2Vba2V5XTtcbn0pO1xuXG52YXIgX21hbmFnZW1lbnQgPSByZXF1aXJlKFwiLi90cmV6b3IvbWFuYWdlbWVudFwiKTtcblxuT2JqZWN0LmtleXMoX21hbmFnZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9tYW5hZ2VtZW50W2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX21hbmFnZW1lbnRba2V5XTtcbn0pO1xuXG52YXIgX2JpdGNvaW4gPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaXRjb2luXCIpO1xuXG5PYmplY3Qua2V5cyhfYml0Y29pbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2JpdGNvaW5ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfYml0Y29pbltrZXldO1xufSk7XG5cbnZhciBfYmluYW5jZSA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2JpbmFuY2VcIik7XG5cbk9iamVjdC5rZXlzKF9iaW5hbmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYmluYW5jZVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9iaW5hbmNlW2tleV07XG59KTtcblxudmFyIF9jYXJkYW5vID0gcmVxdWlyZShcIi4vbmV0d29ya3MvY2FyZGFub1wiKTtcblxuT2JqZWN0LmtleXMoX2NhcmRhbm8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jYXJkYW5vW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2NhcmRhbm9ba2V5XTtcbn0pO1xuXG52YXIgX2NvaW5JbmZvID0gcmVxdWlyZShcIi4vbmV0d29ya3MvY29pbkluZm9cIik7XG5cbk9iamVjdC5rZXlzKF9jb2luSW5mbykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2NvaW5JbmZvW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2NvaW5JbmZvW2tleV07XG59KTtcblxudmFyIF9lb3MgPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9lb3NcIik7XG5cbk9iamVjdC5rZXlzKF9lb3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9lb3Nba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfZW9zW2tleV07XG59KTtcblxudmFyIF9ldGhlcmV1bSA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2V0aGVyZXVtXCIpO1xuXG5PYmplY3Qua2V5cyhfZXRoZXJldW0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9ldGhlcmV1bVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9ldGhlcmV1bVtrZXldO1xufSk7XG5cbnZhciBfbmVtID0gcmVxdWlyZShcIi4vbmV0d29ya3MvbmVtXCIpO1xuXG5PYmplY3Qua2V5cyhfbmVtKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfbmVtW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX25lbVtrZXldO1xufSk7XG5cbnZhciBfcmlwcGxlID0gcmVxdWlyZShcIi4vbmV0d29ya3MvcmlwcGxlXCIpO1xuXG5PYmplY3Qua2V5cyhfcmlwcGxlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfcmlwcGxlW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3JpcHBsZVtrZXldO1xufSk7XG5cbnZhciBfc3RlbGxhciA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL3N0ZWxsYXJcIik7XG5cbk9iamVjdC5rZXlzKF9zdGVsbGFyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfc3RlbGxhcltrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9zdGVsbGFyW2tleV07XG59KTtcblxudmFyIF90ZXpvcyA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL3Rlem9zXCIpO1xuXG5PYmplY3Qua2V5cyhfdGV6b3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90ZXpvc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF90ZXpvc1trZXldO1xufSk7XG5cbnZhciBfYmxvY2tjaGFpbiA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvYmxvY2tjaGFpblwiKTtcblxuT2JqZWN0LmtleXMoX2Jsb2NrY2hhaW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9ibG9ja2NoYWluW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2Jsb2NrY2hhaW5ba2V5XTtcbn0pO1xuXG52YXIgX3RyYW5zYWN0aW9ucyA9IHJlcXVpcmUoXCIuL2JhY2tlbmQvdHJhbnNhY3Rpb25zXCIpO1xuXG5PYmplY3Qua2V5cyhfdHJhbnNhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHJhbnNhY3Rpb25zW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3RyYW5zYWN0aW9uc1trZXldO1xufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNBUkRBTk8gPSBleHBvcnRzLlVJID0gZXhwb3J0cy5UUkFOU1BPUlQgPSBleHBvcnRzLlBPUFVQID0gZXhwb3J0cy5ORVRXT1JLID0gZXhwb3J0cy5JRlJBTUUgPSBleHBvcnRzLkVSUk9SUyA9IGV4cG9ydHMuREVWSUNFID0gZXhwb3J0cy5CTE9DS0NIQUlOID0gZXhwb3J0cy5CTE9DS0NIQUlOX0VWRU5UID0gZXhwb3J0cy5SRVNQT05TRV9FVkVOVCA9IGV4cG9ydHMuVFJBTlNQT1JUX0VWRU5UID0gZXhwb3J0cy5ERVZJQ0VfRVZFTlQgPSBleHBvcnRzLlVJX0VWRU5UID0gZXhwb3J0cy5DT1JFX0VWRU5UID0gdm9pZCAwO1xuXG52YXIgQkxPQ0tDSEFJTiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2Jsb2NrY2hhaW5cIikpO1xuXG5leHBvcnRzLkJMT0NLQ0hBSU4gPSBCTE9DS0NIQUlOO1xuXG52YXIgREVWSUNFID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZGV2aWNlXCIpKTtcblxuZXhwb3J0cy5ERVZJQ0UgPSBERVZJQ0U7XG5cbnZhciBFUlJPUlMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9lcnJvcnNcIikpO1xuXG5leHBvcnRzLkVSUk9SUyA9IEVSUk9SUztcblxudmFyIElGUkFNRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2lmcmFtZVwiKSk7XG5cbmV4cG9ydHMuSUZSQU1FID0gSUZSQU1FO1xuXG52YXIgTkVUV09SSyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtcIikpO1xuXG5leHBvcnRzLk5FVFdPUksgPSBORVRXT1JLO1xuXG52YXIgUE9QVVAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wb3B1cFwiKSk7XG5cbmV4cG9ydHMuUE9QVVAgPSBQT1BVUDtcblxudmFyIFRSQU5TUE9SVCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKSk7XG5cbmV4cG9ydHMuVFJBTlNQT1JUID0gVFJBTlNQT1JUO1xuXG52YXIgVUkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91aVwiKSk7XG5cbmV4cG9ydHMuVUkgPSBVSTtcblxudmFyIENBUkRBTk8gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jYXJkYW5vXCIpKTtcblxuZXhwb3J0cy5DQVJEQU5PID0gQ0FSREFOTztcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIENPUkVfRVZFTlQgPSAnQ09SRV9FVkVOVCc7XG5leHBvcnRzLkNPUkVfRVZFTlQgPSBDT1JFX0VWRU5UO1xudmFyIFVJX0VWRU5UID0gJ1VJX0VWRU5UJztcbmV4cG9ydHMuVUlfRVZFTlQgPSBVSV9FVkVOVDtcbnZhciBERVZJQ0VfRVZFTlQgPSAnREVWSUNFX0VWRU5UJztcbmV4cG9ydHMuREVWSUNFX0VWRU5UID0gREVWSUNFX0VWRU5UO1xudmFyIFRSQU5TUE9SVF9FVkVOVCA9ICdUUkFOU1BPUlRfRVZFTlQnO1xuZXhwb3J0cy5UUkFOU1BPUlRfRVZFTlQgPSBUUkFOU1BPUlRfRVZFTlQ7XG52YXIgUkVTUE9OU0VfRVZFTlQgPSAnUkVTUE9OU0VfRVZFTlQnO1xuZXhwb3J0cy5SRVNQT05TRV9FVkVOVCA9IFJFU1BPTlNFX0VWRU5UO1xudmFyIEJMT0NLQ0hBSU5fRVZFTlQgPSAnQkxPQ0tDSEFJTl9FVkVOVCc7XG5leHBvcnRzLkJMT0NLQ0hBSU5fRVZFTlQgPSBCTE9DS0NIQUlOX0VWRU5UOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGlzYWJsZVdlYlVTQiA9IGV4cG9ydHMucmVxdWVzdExvZ2luID0gZXhwb3J0cy5jdXN0b21NZXNzYWdlID0gZXhwb3J0cy5nZXRTZXR0aW5ncyA9IGV4cG9ydHMucmVuZGVyV2ViVVNCQnV0dG9uID0gZXhwb3J0cy51aVJlc3BvbnNlID0gZXhwb3J0cy5jYWxsID0gZXhwb3J0cy5pbml0ID0gZXhwb3J0cy5jYW5jZWwgPSBleHBvcnRzLmRpc3Bvc2UgPSBleHBvcnRzLm1hbmlmZXN0ID0gZXhwb3J0cy5ldmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2V2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImV2ZW50c1wiKSk7XG5cbnZhciBfUG9wdXBNYW5hZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vcG9wdXAvUG9wdXBNYW5hZ2VyXCIpKTtcblxudmFyIGlmcmFtZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi8uLi9pZnJhbWUvYnVpbGRlclwiKSk7XG5cbnZhciBfYnV0dG9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vd2VidXNiL2J1dHRvblwiKSk7XG5cbnZhciBfbWVzc2FnZSA9IHJlcXVpcmUoXCIuLi8uLi9tZXNzYWdlXCIpO1xuXG52YXIgX2J1aWxkZXIyID0gcmVxdWlyZShcIi4uLy4uL21lc3NhZ2UvYnVpbGRlclwiKTtcblxudmFyIF9Db25uZWN0U2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9Db25uZWN0U2V0dGluZ3NcIik7XG5cbnZhciBfZGVidWcgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZGVidWdcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcblxudmFyICRUID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIGV2ZW50RW1pdHRlciA9IG5ldyBfZXZlbnRzW1wiZGVmYXVsdFwiXSgpO1xuZXhwb3J0cy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG5cbnZhciBfbG9nID0gKDAsIF9kZWJ1Zy5pbml0TG9nKSgnW3RyZXpvci1jb25uZWN0LmpzXScpO1xuXG52YXIgX3NldHRpbmdzO1xuXG52YXIgX3BvcHVwTWFuYWdlcjtcblxudmFyIGluaXRQb3B1cE1hbmFnZXIgPSBmdW5jdGlvbiBpbml0UG9wdXBNYW5hZ2VyKCkge1xuICB2YXIgcG0gPSBuZXcgX1BvcHVwTWFuYWdlcltcImRlZmF1bHRcIl0oX3NldHRpbmdzKTtcbiAgcG0ub24oX2NvbnN0YW50cy5QT1BVUC5DTE9TRUQsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBfY29uc3RhbnRzLlBPUFVQLkNMT1NFRCxcbiAgICAgIHBheWxvYWQ6IGVycm9yID8ge1xuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH0gOiBudWxsXG4gICAgfSwgZmFsc2UpO1xuICB9KTtcbiAgcmV0dXJuIHBtO1xufTtcblxudmFyIG1hbmlmZXN0ID0gZnVuY3Rpb24gbWFuaWZlc3QoZGF0YSkge1xuICBfc2V0dGluZ3MgPSAoMCwgX0Nvbm5lY3RTZXR0aW5ncy5wYXJzZSkoe1xuICAgIG1hbmlmZXN0OiBkYXRhXG4gIH0pO1xufTtcblxuZXhwb3J0cy5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuXG52YXIgZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gIGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWZyYW1lLmRpc3Bvc2UoKTtcblxuICBpZiAoX3BvcHVwTWFuYWdlcikge1xuICAgIF9wb3B1cE1hbmFnZXIuY2xvc2UoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcblxudmFyIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbChlcnJvcikge1xuICBpZiAoX3BvcHVwTWFuYWdlcikge1xuICAgIF9wb3B1cE1hbmFnZXIuZW1pdChfY29uc3RhbnRzLlBPUFVQLkNMT1NFRCwgZXJyb3IpO1xuICB9XG59OyAvLyBoYW5kbGUgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGlmcmFtZVxuXG5cbmV4cG9ydHMuY2FuY2VsID0gY2FuY2VsO1xuXG52YXIgaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZUV2ZW50KSB7XG4gIC8vIGlnbm9yZSBtZXNzYWdlcyBmcm9tIGRvbWFpbiBvdGhlciB0aGVuIGlmcmFtZSBvcmlnaW5cbiAgaWYgKG1lc3NhZ2VFdmVudC5vcmlnaW4gIT09IGlmcmFtZS5vcmlnaW4pIHJldHVybjtcbiAgdmFyIG1lc3NhZ2UgPSAoMCwgX21lc3NhZ2UucGFyc2VNZXNzYWdlKShtZXNzYWdlRXZlbnQuZGF0YSk7XG4gIHZhciBldmVudCA9IG1lc3NhZ2UuZXZlbnQsXG4gICAgICB0eXBlID0gbWVzc2FnZS50eXBlLFxuICAgICAgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgdmFyIGlkID0gbWVzc2FnZS5pZCB8fCAwO1xuXG4gIF9sb2cubG9nKCdoYW5kbGVNZXNzYWdlJywgbWVzc2FnZSk7XG5cbiAgc3dpdGNoIChldmVudCkge1xuICAgIGNhc2UgX2NvbnN0YW50cy5SRVNQT05TRV9FVkVOVDpcbiAgICAgIGlmIChpZnJhbWUubWVzc2FnZVByb21pc2VzW2lkXSkge1xuICAgICAgICAvLyByZXNvbHZlIG1lc3NhZ2UgcHJvbWlzZSAoc2VuZCByZXN1bHQgb2YgY2FsbCBtZXRob2QpXG4gICAgICAgIGlmcmFtZS5tZXNzYWdlUHJvbWlzZXNbaWRdLnJlc29sdmUoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBzdWNjZXNzOiBtZXNzYWdlLnN1Y2Nlc3MsXG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGlmcmFtZS5tZXNzYWdlUHJvbWlzZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2xvZy53YXJuKFwiVW5rbm93biBtZXNzYWdlIGlkIFwiICsgaWQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX2NvbnN0YW50cy5ERVZJQ0VfRVZFTlQ6XG4gICAgICAvLyBwYXNzIERFVklDRSBldmVudCB1cCB0byBodG1sXG4gICAgICBldmVudEVtaXR0ZXIuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdCh0eXBlLCBwYXlsb2FkKTsgLy8gREVWSUNFX0VWRU5UIGFsc28gZW1pdCBzaW5nbGUgZXZlbnRzIChjb25uZWN0L2Rpc2Nvbm5lY3QuLi4pXG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBfY29uc3RhbnRzLlRSQU5TUE9SVF9FVkVOVDpcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50LCBtZXNzYWdlKTtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIF9jb25zdGFudHMuQkxPQ0tDSEFJTl9FVkVOVDpcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50LCBtZXNzYWdlKTtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIF9jb25zdGFudHMuVUlfRVZFTlQ6XG4gICAgICBpZiAodHlwZSA9PT0gX2NvbnN0YW50cy5JRlJBTUUuQk9PVFNUUkFQKSB7XG4gICAgICAgIGlmcmFtZS5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBfY29uc3RhbnRzLklGUkFNRS5MT0FERUQpIHtcbiAgICAgICAgaWZyYW1lLmluaXRQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IF9jb25zdGFudHMuSUZSQU1FLkVSUk9SKSB7XG4gICAgICAgIGlmcmFtZS5pbml0UHJvbWlzZS5yZWplY3QocGF5bG9hZC5lcnJvcik7XG4gICAgICB9IC8vIHBhc3MgVUkgZXZlbnQgdXBcblxuXG4gICAgICBldmVudEVtaXR0ZXIuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdCh0eXBlLCBwYXlsb2FkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIF9sb2cubG9nKCdVbmRlZmluZWQgbWVzc2FnZScsIGV2ZW50LCBtZXNzYWdlRXZlbnQpO1xuXG4gIH1cbn07XG5cbnZhciBpbml0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShzZXR0aW5ncykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzZXR0aW5ncyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlmcmFtZS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfQWxyZWFkeUluaXRpYWxpemVkJyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAoIV9zZXR0aW5ncykge1xuICAgICAgICAgICAgICBfc2V0dGluZ3MgPSAoMCwgX0Nvbm5lY3RTZXR0aW5ncy5wYXJzZSkoc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3NldHRpbmdzLm1hbmlmZXN0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9NYW5pZmVzdE1pc3NpbmcnKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlmICghX3NldHRpbmdzLmxhenlMb2FkKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVzZXQgXCJsYXp5TG9hZFwiIGFmdGVyIGZpcnN0IHVzZVxuICAgICAgICAgICAgX3NldHRpbmdzLmxhenlMb2FkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgaWYgKCFfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIgPSBpbml0UG9wdXBNYW5hZ2VyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9sb2cuZW5hYmxlZCA9ICEhX3NldHRpbmdzLmRlYnVnO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBkaXNwb3NlKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWUuaW5pdChfc2V0dGluZ3MpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gaW5pdChfeCkge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5cbnZhciBjYWxsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcmFtcykge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKCFpZnJhbWUuaW5zdGFuY2UgJiYgIWlmcmFtZS50aW1lb3V0KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5pdCBwb3B1cCB3aXRoIGxhenkgbG9hZGluZyBiZWZvcmUgaWZyYW1lIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBfc2V0dGluZ3MgPSAoMCwgX0Nvbm5lY3RTZXR0aW5ncy5wYXJzZSkoX3NldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKF9zZXR0aW5ncy5tYW5pZmVzdCkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdJbml0X01hbmlmZXN0TWlzc2luZycpKSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoIV9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlciA9IGluaXRQb3B1cE1hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3BvcHVwTWFuYWdlci5yZXF1ZXN0KHRydWUpOyAvLyBhdXRvIGluaXQgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG5cblxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA2O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIGluaXQoX3NldHRpbmdzKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDExO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oNik7XG5cbiAgICAgICAgICAgIGlmIChfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIC8vIENhdGNoIGZhdGFsIGlmcmFtZSBlcnJvcnMgKG5vdCBsb2FkaW5nKVxuICAgICAgICAgICAgICBpZiAoWydJbml0X0lmcmFtZUJsb2NrZWQnLCAnSW5pdF9JZnJhbWVUaW1lb3V0J10uaW5jbHVkZXMoX2NvbnRleHQyLnQwLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci5wb3N0TWVzc2FnZSgoMCwgX2J1aWxkZXIyLlVpTWVzc2FnZSkoX2NvbnN0YW50cy5VSS5JRlJBTUVfRkFJTFVSRSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29udGV4dDIudDApKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBpZiAoIWlmcmFtZS50aW1lb3V0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdJbml0X01hbmlmZXN0TWlzc2luZycpKSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgaWYgKCFpZnJhbWUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKGlmcmFtZS5lcnJvcikpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgcG9wdXAgd2luZG93IGl0IG1pZ2h0IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgaWYgKF9zZXR0aW5ncy5wb3B1cCAmJiBfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIucmVxdWVzdCgpO1xuICAgICAgICAgICAgfSAvLyBwb3N0IG1lc3NhZ2UgdG8gaWZyYW1lXG5cblxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjM7XG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5JRlJBTUUuQ0FMTCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGFyYW1zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UucGF5bG9hZC5jb2RlICE9PSAnRGV2aWNlX0NhbGxJblByb2dyZXNzJyAmJiBfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIudW5sb2NrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICBpZiAoX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLnVubG9jaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdNZXRob2RfTm9SZXNwb25zZScpKSk7XG5cbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzMTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0MltcImNhdGNoXCJdKDIwKTtcblxuICAgICAgICAgICAgX2xvZy5lcnJvcignX19jYWxsIGVycm9yJywgX2NvbnRleHQyLnQxKTtcblxuICAgICAgICAgICAgaWYgKF9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29udGV4dDIudDEpKTtcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1s2LCAxMV0sIFsyMCwgMzFdXSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FsbChfeDIpIHtcbiAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5jYWxsID0gY2FsbDtcblxudmFyIGN1c3RvbU1lc3NhZ2VSZXNwb25zZSA9IGZ1bmN0aW9uIGN1c3RvbU1lc3NhZ2VSZXNwb25zZShwYXlsb2FkKSB7XG4gIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgdHlwZTogX2NvbnN0YW50cy5VSS5DVVNUT01fTUVTU0FHRV9SRVNQT05TRSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH0pO1xufTtcblxudmFyIHVpUmVzcG9uc2UgPSBmdW5jdGlvbiB1aVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHZhciB0eXBlID0gcmVzcG9uc2UudHlwZSxcbiAgICAgIHBheWxvYWQgPSByZXNwb25zZS5wYXlsb2FkO1xuICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9KTtcbn07XG5cbmV4cG9ydHMudWlSZXNwb25zZSA9IHVpUmVzcG9uc2U7XG5cbnZhciByZW5kZXJXZWJVU0JCdXR0b24gPSBmdW5jdGlvbiByZW5kZXJXZWJVU0JCdXR0b24oY2xhc3NOYW1lKSB7XG4gICgwLCBfYnV0dG9uW1wiZGVmYXVsdFwiXSkoY2xhc3NOYW1lLCBfc2V0dGluZ3Mud2VidXNiU3JjLCBpZnJhbWUub3JpZ2luKTtcbn07XG5cbmV4cG9ydHMucmVuZGVyV2ViVVNCQnV0dG9uID0gcmVuZGVyV2ViVVNCQnV0dG9uO1xuXG52YXIgZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRTZXR0aW5ncygpIHtcbiAgaWYgKCFpZnJhbWUuaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfTm90SW5pdGlhbGl6ZWQnKSkpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwoe1xuICAgIG1ldGhvZDogJ2dldFNldHRpbmdzJ1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZ2V0U2V0dGluZ3MgPSBnZXRTZXR0aW5ncztcblxudmFyIGN1c3RvbU1lc3NhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocGFyYW1zKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBjdXN0b21NZXNzYWdlTGlzdGVuZXIsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHBhcmFtcy5jYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignTWV0aG9kX0N1c3RvbU1lc3NhZ2VfQ2FsbGJhY2snKSkpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gVE9ETzogc2V0IG1lc3NhZ2UgbGlzdGVuZXIgb25seSBpZiBpZnJhbWUgaXMgbG9hZGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIGN1c3RvbU1lc3NhZ2VMaXN0ZW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhLCBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS50eXBlID09PSBfY29uc3RhbnRzLlVJLkNVU1RPTV9NRVNTQUdFX1JFUVVFU1QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhLnBheWxvYWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21NZXNzYWdlUmVzcG9uc2UocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21NZXNzYWdlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdyZWxlYXNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjdXN0b21NZXNzYWdlTGlzdGVuZXIoX3g0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY3VzdG9tTWVzc2FnZUxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gY2FsbChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICBtZXRob2Q6ICdjdXN0b21NZXNzYWdlJ1xuICAgICAgICAgICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGN1c3RvbU1lc3NhZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGN1c3RvbU1lc3NhZ2UoX3gzKSB7XG4gICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuY3VzdG9tTWVzc2FnZSA9IGN1c3RvbU1lc3NhZ2U7XG5cbnZhciByZXF1ZXN0TG9naW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYocGFyYW1zKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBsb2dpbkNoYWxsZW5nZUxpc3RlbmVyLCByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBwYXJhbXMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrOyAvLyBUT0RPOiBzZXQgbWVzc2FnZSBsaXN0ZW5lciBvbmx5IGlmIGlmcmFtZSBpcyBsb2FkZWQgY29ycmVjdGx5XG5cbiAgICAgICAgICAgIGxvZ2luQ2hhbGxlbmdlTGlzdGVuZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSwgcGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEudHlwZSA9PT0gX2NvbnN0YW50cy5VSS5MT0dJTl9DSEFMTEVOR0VfUkVRVUVTVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuVUkuTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuVUkuTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBfY29udGV4dDUudDAubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTUsIG51bGwsIFtbMiwgOV1dKTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2dpbkNoYWxsZW5nZUxpc3RlbmVyKF94Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxvZ2luQ2hhbGxlbmdlTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBjYWxsKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ3JlcXVlc3RMb2dpbidcbiAgICAgICAgICAgIH0sIHBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgIGFzeW5jQ2hhbGxlbmdlOiB0cnVlLFxuICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbG9naW5DaGFsbGVuZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBjYWxsKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICBtZXRob2Q6ICdyZXF1ZXN0TG9naW4nXG4gICAgICAgICAgICB9LCBwYXJhbXMpKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTYpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RMb2dpbihfeDUpIHtcbiAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5yZXF1ZXN0TG9naW4gPSByZXF1ZXN0TG9naW47XG5cbnZhciBkaXNhYmxlV2ViVVNCID0gZnVuY3Rpb24gZGlzYWJsZVdlYlVTQigpIHtcbiAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICB0eXBlOiBfY29uc3RhbnRzLlRSQU5TUE9SVC5ESVNBQkxFX1dFQlVTQlxuICB9KTtcbn07XG5cbmV4cG9ydHMuZGlzYWJsZVdlYlVTQiA9IGRpc2FibGVXZWJVU0I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5jb25jYXRTaWcgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGVyc29uYWwtc2lnblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbi10eXBlZC1kYXRhXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNyeXB0aW9uXCIpLCBleHBvcnRzKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRTaWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY29uY2F0U2lnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLm5vcm1hbGl6ZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IG9ic19zdG9yZV8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9vYnMtc3RvcmVcIik7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgYWx3YXlzUmVxdWlyZWRGaWVsZHMgPSBbJ2Zyb21Eb21haW4nXTtcbmNvbnN0IGNvbXB1dGVTdGF0ZSA9IChzdG9yYWdlS2V5LCBpbml0aWFsUmVzb3VyY2VzKSA9PiB7XG4gICAgcmV0dXJuIHsgW3N0b3JhZ2VLZXldOiBpbml0aWFsUmVzb3VyY2VzIH07XG59O1xuY29uc3QgZ2V0VW5hdXRob3JpemVkTWVzc2FnZSA9IChpZCkgPT4gYE5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyByZXNvdXJjZSB3aXRoIGlkIFwiJHtpZH1cIi5gO1xuLyoqXG4gKiBBIGNsYXNzIGludGVuZGVkIHRvIGRlc2NyaWJlIGEgcGFydGljdWxhciByZXNvdXJjZSB0aGF0IGlzIG1hbmFnZWQgYnkgc25hcHMuXG4gKiBFeGFtcGxlIHJlc291cmNlcyBhcmUgYXNzZXRzLlxuICpcbiAqIFRoZXNlIGFyZSB0aGluZ3MgdGhhdCBNZXRhTWFzayB0cmVhdHMgYXMgZmlyc3QtY2xhc3Mgb2JqZWN0cyB3aXRoIGRpc3RpbmN0IHByb3BlcnRpZXMgd2l0aGluIGl0cyBvd24gVUkuXG4gKi9cbmNsYXNzIEV4dGVybmFsUmVzb3VyY2VDb250cm9sbGVyIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoeyBzdG9yYWdlS2V5LCByZXF1aXJlZEZpZWxkcywgaW5pdGlhbFJlc291cmNlcywgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlcXVpcmVkRmllbGRzID0gcmVxdWlyZWRGaWVsZHM7XG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBuZXcgb2JzX3N0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlKGNvbXB1dGVTdGF0ZShzdG9yYWdlS2V5LCBpbml0aWFsUmVzb3VyY2VzKSk7XG4gICAgfVxuICAgIGdldFJlc291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVt0aGlzLnN0b3JhZ2VLZXldKTtcbiAgICB9XG4gICAgc2V0UmVzb3VyY2VzKHJlc291cmNlcykge1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICAgIFt0aGlzLnN0b3JhZ2VLZXldOiByZXNvdXJjZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhclJlc291cmNlcygpIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZXMoe30pO1xuICAgIH1cbiAgICBkZWxldGVSZXNvdXJjZXNGb3IoZnJvbURvbWFpbikge1xuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmdldFJlc291cmNlcygpO1xuICAgICAgICBjb25zdCBuZXdSZXNvdXJjZXMgPSBPYmplY3QuZW50cmllcyhyZXNvdXJjZXMpLnJlZHVjZSgoYWNjLCBbaWQsIHJlc291cmNlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmZyb21Eb21haW4gIT09IGZyb21Eb21haW4pIHtcbiAgICAgICAgICAgICAgICBhY2NbaWRdID0gcmVzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuc2V0UmVzb3VyY2VzKG5ld1Jlc291cmNlcyk7XG4gICAgfVxuICAgIGdldChmcm9tRG9tYWluLCBpZCkge1xuICAgICAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuZ2V0UmVzb3VyY2VzKClbaWRdO1xuICAgICAgICBpZiAocmVzb3VyY2UgJiYgcmVzb3VyY2UuZnJvbURvbWFpbiAhPT0gZnJvbURvbWFpbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBnZXRVbmF1dGhvcml6ZWRNZXNzYWdlKGlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvdXJjZSA/IE9iamVjdC5hc3NpZ24oe30sIHJlc291cmNlKSA6IG51bGw7XG4gICAgfVxuICAgIGdldEFsbFJlc291cmNlcyhmcm9tRG9tYWluKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZ2V0UmVzb3VyY2VzKCkpLmZpbHRlcigocmVzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZS5mcm9tRG9tYWluID09PSBmcm9tRG9tYWluO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkKGZyb21Eb21haW4sIHJlc291cmNlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Jlc291cmNlID0gdGhpcy5wcm9jZXNzTmV3UmVzb3VyY2UoZnJvbURvbWFpbiwgcmVzb3VyY2UpO1xuICAgICAgICBjb25zdCB7IGlkIH0gPSBuZXdSZXNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgaWYgKHJlc291cmNlc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZXNbaWRdID0gbmV3UmVzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLnNldFJlc291cmNlcyhyZXNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdSZXNvdXJjZS5pZDtcbiAgICB9XG4gICAgdXBkYXRlKGZyb21Eb21haW4sIHJlc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHJlc291cmNlO1xuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmdldFJlc291cmNlcygpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1Jlc291cmNlID0gcmVzb3VyY2VzW2lkXTtcbiAgICAgICAgaWYgKCFleGlzdGluZ1Jlc291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMucmVzb3VyY2VOb3RGb3VuZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlc291cmNlIHdpdGggaWQgXCIke2lkfVwiIG5vdCBmb3VuZC5gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdSZXNvdXJjZS5mcm9tRG9tYWluICE9PSBmcm9tRG9tYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGdldFVuYXV0aG9yaXplZE1lc3NhZ2UoaWQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb3VyY2VzW2lkXSA9IHRoaXMucHJvY2Vzc05ld1Jlc291cmNlKGZyb21Eb21haW4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzb3VyY2VzW2lkXSksIHJlc291cmNlKSk7XG4gICAgICAgIHRoaXMuc2V0UmVzb3VyY2VzKHJlc291cmNlcyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgcHJvY2Vzc05ld1Jlc291cmNlKGZyb21Eb21haW4sIHJlc291cmNlKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZWRGaWVsZHMuZm9yRWFjaCgocmVxdWlyZWRGaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEocmVxdWlyZWRGaWVsZCBpbiByZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgUmVzb3VyY2UgZnJvbSBcIiR7ZnJvbURvbWFpbn1cIiBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAke3JlcXVpcmVkRmllbGR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNvdXJjZSksIHsgZnJvbURvbWFpbiwgaWQ6IHJlc291cmNlLmlkIHx8IG5hbm9pZF8xLm5hbm9pZCgpIH0pO1xuICAgIH1cbiAgICBkZWxldGUoZnJvbURvbWFpbiwgaWQpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvdXJjZSA9IHJlc291cmNlc1tpZF07XG4gICAgICAgIGlmICghZXhpc3RpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXNvdXJjZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nUmVzb3VyY2UuZnJvbURvbWFpbiAhPT0gZnJvbURvbWFpbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBnZXRVbmF1dGhvcml6ZWRNZXNzYWdlKGlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZXNvdXJjZXNbaWRdO1xuICAgICAgICB0aGlzLnNldFJlc291cmNlcyhyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlUnBjUmVxdWVzdChmcm9tRG9tYWluLCBtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoIWZyb21Eb21haW4gfHwgdHlwZW9mIGZyb21Eb21haW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJvbURvbWFpbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoZnJvbURvbWFpbiwgYXJnKTtcbiAgICAgICAgICAgIGNhc2UgJ2dldEFsbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsUmVzb3VyY2VzKGZyb21Eb21haW4pO1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoZnJvbURvbWFpbiwgYXJnKTtcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGZyb21Eb21haW4sIGFyZyk7XG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShmcm9tRG9tYWluLCBhcmcpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTm90IGFuIGFzc2V0IG1ldGhvZDogJHttZXRob2R9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXIgPSBFeHRlcm5hbFJlc291cmNlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dGVybmFsUmVzb3VyY2VDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyJztcbmNvbnN0IHN0YXRlTWV0YWRhdGEgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7fSxcbn07XG4vKipcbiAqIEEgY29udHJvbGxlciBmb3Igc3RvcmluZyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggcGVybWlzc2lvbiBzdWJqZWN0cy4gTW9yZVxuICogb3IgbGVzcywgYSBjYWNoZS5cbiAqL1xuY2xhc3MgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlciBleHRlbmRzIGNvbnRyb2xsZXJzXzEuQmFzZUNvbnRyb2xsZXJWMiB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIHN1YmplY3RDYWNoZUxpbWl0LCBzdGF0ZSA9IHt9LCB9KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdWJqZWN0Q2FjaGVMaW1pdCkgfHwgc3ViamVjdENhY2hlTGltaXQgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1YmplY3RDYWNoZUxpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke3N1YmplY3RDYWNoZUxpbWl0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUGVybWlzc2lvbnMgPSAob3JpZ2luKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2VuZ2VyLmNhbGwoJ1Blcm1pc3Npb25Db250cm9sbGVyOmhhc1Blcm1pc3Npb25zJywgb3JpZ2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbGxlck5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogc3RhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKHt9LCBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ViamVjdEhhc1Blcm1pc3Npb25zID0gaGFzUGVybWlzc2lvbnM7XG4gICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQgPSBzdWJqZWN0Q2FjaGVMaW1pdDtcbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhpcyBjb250cm9sbGVyLiBBbHNvIHJlc2V0cyB0aGUgY2FjaGUgb2Ygc3ViamVjdHNcbiAgICAgKiBlbmNvdW50ZXJlZCBzaW5jZSBzdGFydHVwLCBzbyBhcyB0byBub3QgcHJlbWF0dXJlbHkgcmVhY2ggdGhlIGNhY2hlIGxpbWl0LlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKChfZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgZG9tYWluIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW4gb3JpZ2luIChzdWJqZWN0KS4gRGVsZXRlcyBtZXRhZGF0YSBmb3JcbiAgICAgKiBzdWJqZWN0cyB3aXRob3V0IHBlcm1pc3Npb25zIGluIGEgRklGTyBtYW5uZXIgb25jZSBtb3JlIHRoYW5cbiAgICAgKiB7QGxpbmsgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0Q2FjaGVMaW1pdH0gZGlzdGluY3Qgb3JpZ2lucyBoYXZlXG4gICAgICogYmVlbiBhZGRlZCBzaW5jZSBib290LlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gcHJldmVudCBhIGRlZ3JhZGVkIHVzZXIgZXhwZXJpZW5jZSxcbiAgICAgKiBtZXRhZGF0YSBpcyBuZXZlciBkZWxldGVkIGZvciBzdWJqZWN0cyB3aXRoIHBlcm1pc3Npb25zLCBzaW5jZSBtZXRhZGF0YVxuICAgICAqIGNhbm5vdCB5ZXQgYmUgcmVxdWVzdGVkIG9uIGRlbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBzdWJqZWN0IG1ldGFkYXRhIHRvIHN0b3JlLlxuICAgICAqL1xuICAgIGFkZFN1YmplY3RNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSksIHsgZXh0ZW5zaW9uSWQ6IG1ldGFkYXRhLmV4dGVuc2lvbklkIHx8IG51bGwsIGljb25Vcmw6IG1ldGFkYXRhLmljb25VcmwgfHwgbnVsbCwgbmFtZTogbWV0YWRhdGEubmFtZSB8fCBudWxsIH0pO1xuICAgICAgICBsZXQgb3JpZ2luVG9Gb3JnZXQgPSBudWxsO1xuICAgICAgICAvLyBXZSBvbmx5IGRlbGV0ZSB0aGUgb2xkZXN0IGVuY291bnRlcmVkIHN1YmplY3QgZnJvbSB0aGUgY2FjaGUsIGFnYWluIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB1c2VyJ3MgZXhwZXJpZW5jZSBpc24ndCBkZWdyYWRlZCBieSBtaXNzaW5nIGljb25zIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLnNpemUgPj1cbiAgICAgICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZE9yaWdpbiA9IHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwXG4gICAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgICAgLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmRlbGV0ZShjYWNoZWRPcmlnaW4pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyhjYWNoZWRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luVG9Gb3JnZXQgPSBjYWNoZWRPcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAuYWRkKG9yaWdpbik7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpbl0gPSBuZXdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luVG9Gb3JnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpblRvRm9yZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHN1YmplY3RzIHdpdGhvdXQgcGVybWlzc2lvbnMgZnJvbSB0aGUgY29udHJvbGxlcidzIHN0YXRlLlxuICAgICAqL1xuICAgIHRyaW1NZXRhZGF0YVN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuZ2V0VHJpbW1lZFN0YXRlKFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLCB0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHN0YXRlIG9iamVjdCB0aGF0IG9ubHkgaW5jbHVkZXMgc3ViamVjdHMgd2l0aCBwZXJtaXNzaW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzdGF0aWMgYmVjYXVzZSB3ZSB3YW50IHRvIGNhbGwgaXQgaW4gdGhlIGNvbnN0cnVjdG9yLCBiZWZvcmVcbiAgICAgKiB0aGUgY29udHJvbGxlcidzIHN0YXRlIGlzIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIG9iamVjdCB0byB0cmltLlxuICAgICAqIEBwYXJhbSBoYXNQZXJtaXNzaW9ucyAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nXG4gICAgICogd2hldGhlciBhIHBhcnRpY3VsYXIgc3ViamVjdCAoaWRlbnRpZmllZCBieSBpdHMgb3JpZ2luKSBoYXMgYW55XG4gICAgICogcGVybWlzc2lvbnMuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzdGF0ZSBvYmplY3QuIElmIHRoZSBzcGVjaWZpZWQgYHN0YXRlYCBvYmplY3QgaGFzIG5vXG4gICAgICogc3ViamVjdCBtZXRhZGF0YSwgdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGRlZmF1bHRcbiAgICAgKiBzdGF0ZSBvZiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdWJqZWN0TWV0YWRhdGEgPSB7fSB9ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJqZWN0TWV0YWRhdGE6IE9iamVjdC5rZXlzKHN1YmplY3RNZXRhZGF0YSkucmVkdWNlKChuZXdTdWJqZWN0TWV0YWRhdGEsIG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQZXJtaXNzaW9ucyhvcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3RNZXRhZGF0YVtvcmlnaW5dID0gc3ViamVjdE1ldGFkYXRhW29yaWdpbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdWJqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICB9LCB7fSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGhvZE5hbWVzID0gdm9pZCAwO1xudmFyIE1ldGhvZE5hbWVzO1xuKGZ1bmN0aW9uIChNZXRob2ROYW1lcykge1xuICAgIE1ldGhvZE5hbWVzW1wicmVxdWVzdFBlcm1pc3Npb25zXCJdID0gXCJ3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zXCI7XG4gICAgTWV0aG9kTmFtZXNbXCJnZXRQZXJtaXNzaW9uc1wiXSA9IFwid2FsbGV0X2dldFBlcm1pc3Npb25zXCI7XG59KShNZXRob2ROYW1lcyA9IGV4cG9ydHMuTWV0aG9kTmFtZXMgfHwgKGV4cG9ydHMuTWV0aG9kTmFtZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc1NwZWNpZmljYXRpb25UeXBlID0gZXhwb3J0cy5QZXJtaXNzaW9uVHlwZSA9IGV4cG9ydHMuZmluZENhdmVhdCA9IGV4cG9ydHMuY29uc3RydWN0UGVybWlzc2lvbiA9IHZvaWQgMDtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgcGVybWlzc2lvbiBmYWN0b3J5IGZ1bmN0aW9uLiBOYWl2ZWx5IGNvbnN0cnVjdHMgYSBwZXJtaXNzaW9uIGZyb21cbiAqIHRoZSBpbnB1dHMuIFNldHMgYSBkZWZhdWx0LCByYW5kb20gYGlkYCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb259IEZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHRlbXBsYXRlIFRhcmdldFBlcm1pc3Npb24gLSBUaGUge0BsaW5rIFBlcm1pc3Npb259IHRoYXQgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwZXJtaXNzaW9uLlxuICogQHJldHVybnMgVGhlIG5ldyBwZXJtaXNzaW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0UGVybWlzc2lvbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjYXZlYXRzID0gbnVsbCwgaW52b2tlciwgdGFyZ2V0IH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgcGFyZW50Q2FwYWJpbGl0eTogdGFyZ2V0LFxuICAgICAgICBpbnZva2VyLFxuICAgICAgICBjYXZlYXRzLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb25zdHJ1Y3RQZXJtaXNzaW9uID0gY29uc3RydWN0UGVybWlzc2lvbjtcbi8qKlxuICogR2V0cyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBiZWxvbmdpbmcgdG8gdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxuICpcbiAqIEBwYXJhbSBwZXJtaXNzaW9uIFRoZSBwZXJtaXNzaW9uIHdob3NlIGNhdmVhdCB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSBjYXZlYXRUeXBlIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJucyBUaGUgY2F2ZWF0LCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCBjYXZlYXQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBmaW5kQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHBlcm1pc3Npb24uY2F2ZWF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKGNhdmVhdCkgPT4gY2F2ZWF0LnR5cGUgPT09IGNhdmVhdFR5cGUpO1xufVxuZXhwb3J0cy5maW5kQ2F2ZWF0ID0gZmluZENhdmVhdDtcbi8qKlxuICogVGhlIGRpZmZlcmVudCBwb3NzaWJsZSB0eXBlcyBvZiBwZXJtaXNzaW9ucy5cbiAqL1xudmFyIFBlcm1pc3Npb25UeXBlO1xuKGZ1bmN0aW9uIChQZXJtaXNzaW9uVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgcmVzdHJpY3RlZCBKU09OLVJQQyBtZXRob2QuIEEgc3ViamVjdCBtdXN0IGhhdmUgdGhlIHJlcXVpc2l0ZSBwZXJtaXNzaW9uXG4gICAgICogdG8gY2FsbCBhIHJlc3RyaWN0ZWQgSlNPTi1SUEMgbWV0aG9kLlxuICAgICAqL1xuICAgIFBlcm1pc3Npb25UeXBlW1wiUmVzdHJpY3RlZE1ldGhvZFwiXSA9IFwiUmVzdHJpY3RlZE1ldGhvZFwiO1xuICAgIC8qKlxuICAgICAqIEFuIFwiZW5kb3dtZW50XCIgZ3JhbnRlZCB0byBzdWJqZWN0cyB0aGF0IHBvc3Nlc3MgdGhlIHJlcXVpc2l0ZSBwZXJtaXNzaW9uLFxuICAgICAqIHN1Y2ggYXMgYSBnbG9iYWwgZW52aXJvbm1lbnQgdmFyaWFibGUgZXhwb3NpbmcgYSByZXN0cmljdGVkIEFQSSwgZXRjLlxuICAgICAqL1xuICAgIFBlcm1pc3Npb25UeXBlW1wiRW5kb3dtZW50XCJdID0gXCJFbmRvd21lbnRcIjtcbn0pKFBlcm1pc3Npb25UeXBlID0gZXhwb3J0cy5QZXJtaXNzaW9uVHlwZSB8fCAoZXhwb3J0cy5QZXJtaXNzaW9uVHlwZSA9IHt9KSk7XG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBzcGVjaWZpY2F0aW9uIGhhcyB0aGUgZXhwZWN0ZWQgcGVybWlzc2lvbiB0eXBlLlxuICpcbiAqIEBwYXJhbSBzcGVjaWZpY2F0aW9uIC0gVGhlIHNwZWNpZmljYXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gZXhwZWN0ZWRUeXBlIC0gVGhlIGV4cGVjdGVkIHBlcm1pc3Npb24gdHlwZS5cbiAqIEB0ZW1wbGF0ZSBTcGVjaWZpY2F0aW9uIC0gVGhlIHNwZWNpZmljYXRpb24gdG8gY2hlY2suXG4gKiBAdGVtcGxhdGUgVHlwZSAtIFRoZSBleHBlY3RlZCBwZXJtaXNzaW9uIHR5cGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc3BlY2lmaWNhdGlvbiBpcyBvZiB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaGFzU3BlY2lmaWNhdGlvblR5cGUoc3BlY2lmaWNhdGlvbiwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgcmV0dXJuIHNwZWNpZmljYXRpb24ucGVybWlzc2lvblR5cGUgPT09IGV4cGVjdGVkVHlwZTtcbn1cbmV4cG9ydHMuaGFzU3BlY2lmaWNhdGlvblR5cGUgPSBoYXNTcGVjaWZpY2F0aW9uVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcm1pc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuZG93bWVudFBlcm1pc3Npb25CdWlsZGVycyA9IHZvaWQgMDtcbmNvbnN0IG5ldHdvcmtfYWNjZXNzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLWFjY2Vzc1wiKTtcbmV4cG9ydHMuZW5kb3dtZW50UGVybWlzc2lvbkJ1aWxkZXJzID0ge1xuICAgIFtuZXR3b3JrX2FjY2Vzc18xLm5ldHdvcmtBY2Nlc3NFbmRvd21lbnRCdWlsZGVyLnRhcmdldEtleV06IG5ldHdvcmtfYWNjZXNzXzEubmV0d29ya0FjY2Vzc0VuZG93bWVudEJ1aWxkZXIsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25Db250cm9sbGVyID0gZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuY29uc3QgZGVlcF9mcmVlemVfc3RyaWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlZXAtZnJlZXplLXN0cmljdFwiKSk7XG5jb25zdCBpbW1lcl8xID0gcmVxdWlyZShcImltbWVyXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IENhdmVhdF8xID0gcmVxdWlyZShcIi4vQ2F2ZWF0XCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBQZXJtaXNzaW9uXzEgPSByZXF1aXJlKFwiLi9QZXJtaXNzaW9uXCIpO1xuY29uc3QgcGVybWlzc2lvbl9taWRkbGV3YXJlXzEgPSByZXF1aXJlKFwiLi9wZXJtaXNzaW9uLW1pZGRsZXdhcmVcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXJ9LlxuICovXG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdQZXJtaXNzaW9uQ29udHJvbGxlcic7XG4vKipcbiAqIEdldCB0aGUgc3RhdGUgbWV0YWRhdGEgb2YgdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uXG4gKlxuICogQHRlbXBsYXRlIFBlcm1pc3Npb24gLSBUaGUgY29udHJvbGxlcidzIHBlcm1pc3Npb24gdHlwZSB1bmlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4geyBzdWJqZWN0czogeyBhbm9ueW1vdXM6IHRydWUsIHBlcnNpc3Q6IHRydWUgfSB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uXG4gKlxuICogQHRlbXBsYXRlIFBlcm1pc3Npb24gLSBUaGUgY29udHJvbGxlcidzIHBlcm1pc3Npb24gdHlwZSB1bmlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0YXRlKCkge1xuICAgIHJldHVybiB7IHN1YmplY3RzOiB7fSB9O1xufVxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHBvc3NpYmxlIHJlc3VsdHMgb2YgYSB7QGxpbmsgQ2F2ZWF0TXV0YXRvcn0gZnVuY3Rpb24uXG4gKi9cbnZhciBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChDYXZlYXRNdXRhdG9yT3BlcmF0aW9uKSB7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wibm9vcFwiXSA9IDBdID0gXCJub29wXCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1widXBkYXRlVmFsdWVcIl0gPSAxXSA9IFwidXBkYXRlVmFsdWVcIjtcbiAgICBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW0NhdmVhdE11dGF0b3JPcGVyYXRpb25bXCJkZWxldGVDYXZlYXRcIl0gPSAyXSA9IFwiZGVsZXRlQ2F2ZWF0XCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wicmV2b2tlUGVybWlzc2lvblwiXSA9IDNdID0gXCJyZXZva2VQZXJtaXNzaW9uXCI7XG59KShDYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0gZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uIHx8IChleHBvcnRzLkNhdmVhdE11dGF0b3JPcGVyYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgcGVybWlzc2lvbiBjb250cm9sbGVyLiBTZWUgdGhlIFJFQURNRSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBc3N1bWVzIHRoZSBleGlzdGVuY2Ugb2YgYW4ge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gcmVhY2hhYmxlIHZpYSB0aGVcbiAqIHtAbGluayBDb250cm9sbGVyTWVzc2VuZ2VyfS5cbiAqXG4gKiBAdGVtcGxhdGUgQ29udHJvbGxlclBlcm1pc3Npb25TcGVjaWZpY2F0aW9uIC0gQSB1bmlvbiBvZiB0aGUgdHlwZXMgb2YgYWxsXG4gKiBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlci4gQW55IHJlZmVyZW5jZWQgY2F2ZWF0c1xuICogbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgY29udHJvbGxlcidzIGNhdmVhdCBzcGVjaWZpY2F0aW9ucy5cbiAqIEB0ZW1wbGF0ZSBDb250cm9sbGVyQ2F2ZWF0U3BlY2lmaWNhdGlvbiAtIEEgdW5pb24gb2YgdGhlIHR5cGVzIG9mIGFsbFxuICogY2F2ZWF0IHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlci5cbiAqL1xuY2xhc3MgUGVybWlzc2lvbkNvbnRyb2xsZXIgZXh0ZW5kcyBjb250cm9sbGVyc18xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUGVybWlzc2lvbiBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2F2ZWF0U3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsIGNhdmVhdHNcbiAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuIFNlZSB7QGxpbmsgQ2F2ZWF0U3BlY2lmaWNhdGlvbk1hcH0gYW5kIHRoZVxuICAgICAqIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsXG4gICAgICogcGVybWlzc2lvbnMgYXZhaWxhYmxlIHRvIHRoZSBjb250cm9sbGVyLiBTZWVcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvblNwZWNpZmljYXRpb25NYXB9IGFuZCB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudW5yZXN0cmljdGVkTWV0aG9kcyAtIFRoZSBjYWxsYWJsZSBuYW1lcyBvZiBhbGwgSlNPTi1SUENcbiAgICAgKiBtZXRob2RzIGlnbm9yZWQgYnkgdGhlIG5ldyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3Nlbmdlci4gU2VlXG4gICAgICoge0BsaW5rIEJhc2VDb250cm9sbGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEV4aXN0aW5nIHN0YXRlIHRvIGh5ZHJhdGUgdGhlIGNvbnRyb2xsZXIgd2l0aCBhdFxuICAgICAqIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYXZlYXRTcGVjaWZpY2F0aW9ucywgcGVybWlzc2lvblNwZWNpZmljYXRpb25zLCB1bnJlc3RyaWN0ZWRNZXRob2RzLCBtZXNzZW5nZXIsIHN0YXRlID0ge30sIH0gPSBvcHRpb25zO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBnZXRTdGF0ZU1ldGFkYXRhKCksXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzdHJpY3RlZE1ldGhvZHMgPSBuZXcgU2V0KHVucmVzdHJpY3RlZE1ldGhvZHMpO1xuICAgICAgICB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9ucyA9IGRlZXBfZnJlZXplX3N0cmljdF8xLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7fSwgY2F2ZWF0U3BlY2lmaWNhdGlvbnMpKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyhwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zKTtcbiAgICAgICAgdGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zID0gZGVlcF9mcmVlemVfc3RyaWN0XzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMpKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlID0gcGVybWlzc2lvbl9taWRkbGV3YXJlXzEuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5KHtcbiAgICAgICAgICAgIGV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kOiB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0UmVzdHJpY3RlZE1ldGhvZDogdGhpcy5nZXRSZXN0cmljdGVkTWV0aG9kLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpc1VucmVzdHJpY3RlZE1ldGhvZDogdGhpcy51bnJlc3RyaWN0ZWRNZXRob2RzLmhhcy5iaW5kKHRoaXMudW5yZXN0cmljdGVkTWV0aG9kcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZXMgb2YgYWxsIEpTT04tUlBDIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgZ2V0IHVucmVzdHJpY3RlZE1ldGhvZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnJlc3RyaWN0ZWRNZXRob2RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEtleSAtIFRoZSB0YXJnZXQga2V5IG9mIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHRhcmdldCBrZXkuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnNbdGFyZ2V0S2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNhdmVhdCBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRDYXZlYXRTcGVjaWZpY2F0aW9uKGNhdmVhdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zW2NhdmVhdFR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHZhbGlkYXRpbmcgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucy4gVGhpcyBpc1xuICAgICAqIGludGVuZGVkIHRvIHByZXZlbnQgdGhlIHVzZSBvZiBpbnZhbGlkIHRhcmdldCBrZXlzIHdoaWNoLCB3aGlsZSBpbXBvc3NpYmxlXG4gICAgICogdG8gYWRkIGluIFR5cGVTY3JpcHQsIGNvdWxkIHJhdGhlciBlYXNpbHkgb2NjdXIgaW4gcGxhaW4gSmF2YVNjcmlwdC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyAtIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIHBhc3NlZCB0b1xuICAgICAqIHRoaXMgY29udHJvbGxlcidzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBjYXZlYXRTcGVjaWZpY2F0aW9ucyAtIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbnMgcGFzc2VkIHRvIHRoaXNcbiAgICAgKiBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGVybWlzc2lvblNwZWNpZmljYXRpb25zKHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgY2F2ZWF0U3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvblNwZWNpZmljYXRpb25zKS5mb3JFYWNoKChbdGFyZ2V0S2V5LCB7IHBlcm1pc3Npb25UeXBlLCB0YXJnZXRLZXk6IGlubmVyVGFyZ2V0S2V5LCBhbGxvd2VkQ2F2ZWF0cyB9LF0pID0+IHtcbiAgICAgICAgICAgIGlmICghcGVybWlzc2lvblR5cGUgfHwgIXV0aWxzXzEuaGFzUHJvcGVydHkoUGVybWlzc2lvbl8xLlBlcm1pc3Npb25UeXBlLCBwZXJtaXNzaW9uVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVybWlzc2lvbiB0eXBlOiBcIiR7cGVybWlzc2lvblR5cGV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0YXJnZXQga2V5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIGVuZHMgd2l0aCBcIl9cIiwgb3IgZW5kc1xuICAgICAgICAgICAgLy8gd2l0aCBcIipcIiBidXQgbm90IFwiXypcIlxuICAgICAgICAgICAgaWYgKCF0YXJnZXRLZXkgfHwgL18kL3UudGVzdCh0YXJnZXRLZXkpIHx8IC9bXl9dXFwqJC91LnRlc3QodGFyZ2V0S2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZXJtaXNzaW9uIHRhcmdldCBrZXk6IFwiJHt0YXJnZXRLZXl9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRLZXkgIT09IGlubmVyVGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbjoga2V5IFwiJHt0YXJnZXRLZXl9XCIgbXVzdCBtYXRjaCBzcGVjaWZpY2F0aW9uLnRhcmdldCB2YWx1ZSBcIiR7aW5uZXJUYXJnZXRLZXl9XCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dlZENhdmVhdHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2F2ZWF0cy5mb3JFYWNoKChjYXZlYXRUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbHNfMS5oYXNQcm9wZXJ0eShjYXZlYXRTcGVjaWZpY2F0aW9ucywgY2F2ZWF0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGhlbHBlciBmb3IgcmVnaXN0ZXJpbmcgdGhlIGNvbnRyb2xsZXIncyBtZXNzYWdpbmcgc3lzdGVtXG4gICAgICogYWN0aW9ucy5cbiAgICAgKi9cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpjbGVhclBlcm1pc3Npb25zYCwgKCkgPT4gdGhpcy5jbGVhclN0YXRlKCkpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmdldEVuZG93bWVudHNgLCAob3JpZ2luLCB0YXJnZXROYW1lLCByZXF1ZXN0RGF0YSkgPT4gdGhpcy5nZXRFbmRvd21lbnRzKG9yaWdpbiwgdGFyZ2V0TmFtZSwgcmVxdWVzdERhdGEpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpnZXRTdWJqZWN0TmFtZXNgLCAoKSA9PiB0aGlzLmdldFN1YmplY3ROYW1lcygpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpnZXRQZXJtaXNzaW9uc2AsIChvcmlnaW4pID0+IHRoaXMuZ2V0UGVybWlzc2lvbnMob3JpZ2luKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUGVybWlzc2lvbmAsIChvcmlnaW4sIHRhcmdldE5hbWUpID0+IHRoaXMuaGFzUGVybWlzc2lvbihvcmlnaW4sIHRhcmdldE5hbWUpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpoYXNQZXJtaXNzaW9uc2AsIChvcmlnaW4pID0+IHRoaXMuaGFzUGVybWlzc2lvbnMob3JpZ2luKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06cmV2b2tlQWxsUGVybWlzc2lvbnNgLCAob3JpZ2luKSA9PiB0aGlzLnJldm9rZUFsbFBlcm1pc3Npb25zKG9yaWdpbikpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OnJlcXVlc3RQZXJtaXNzaW9uc2AsIChzdWJqZWN0LCBwZXJtaXNzaW9ucykgPT4gdGhpcy5yZXF1ZXN0UGVybWlzc2lvbnMoc3ViamVjdCwgcGVybWlzc2lvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzdGF0ZSBvZiB0aGUgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjbGVhclN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoX2RyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcGVybWlzc2lvblxuICAgICAqIHR5cGUgYW5kIHRhcmdldCBuYW1lLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRhcmdldCBuYW1lIGRvZXMgbm90XG4gICAgICogY29ycmVzcG9uZCB0byBhIHBlcm1pc3Npb24sIG9yIGlmIHRoZSBzcGVjaWZpY2F0aW9uIGlzIG5vdCBvZiB0aGVcbiAgICAgKiBnaXZlbiBwZXJtaXNzaW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gd2hvc2Ugc3BlY2lmaWNhdGlvbiB0byBnZXQuXG4gICAgICogQHBhcmFtIHJlcXVlc3RpbmdPcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSByZXF1ZXN0aW5nIHN1YmplY3QsIGlmIGFueS5cbiAgICAgKiBXaWxsIGJlIGFkZGVkIHRvIGFueSB0aHJvd24gZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIFRoZSBzcGVjaWZpY2F0aW9uIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB0eXBlIGFuZFxuICAgICAqIHRhcmdldCBuYW1lLlxuICAgICAqL1xuICAgIGdldFR5cGVkUGVybWlzc2lvblNwZWNpZmljYXRpb24ocGVybWlzc2lvblR5cGUsIHRhcmdldE5hbWUsIHJlcXVlc3RpbmdPcmlnaW4pIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZUVycm9yID0gcGVybWlzc2lvblR5cGUgPT09IFBlcm1pc3Npb25fMS5QZXJtaXNzaW9uVHlwZS5SZXN0cmljdGVkTWV0aG9kXG4gICAgICAgICAgICA/IGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKHRhcmdldE5hbWUsIHJlcXVlc3RpbmdPcmlnaW4gPyB7IG9yaWdpbjogcmVxdWVzdGluZ09yaWdpbiB9IDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgOiBuZXcgZXJyb3JzXzEuRW5kb3dtZW50UGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKHRhcmdldE5hbWUsIHJlcXVlc3RpbmdPcmlnaW4pO1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLmdldFRhcmdldEtleSh0YXJnZXROYW1lKTtcbiAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWx1cmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpO1xuICAgICAgICBpZiAoIVBlcm1pc3Npb25fMS5oYXNTcGVjaWZpY2F0aW9uVHlwZShzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWx1cmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlY2lmaWNhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEEgSlNPTi1SUEMgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0gYW5kXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlfSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QgZm9yIHRoZSByZXN0cmljdGVkXG4gICAgICogbWV0aG9kLCBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGdldFJlc3RyaWN0ZWRNZXRob2QobWV0aG9kLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbihQZXJtaXNzaW9uXzEuUGVybWlzc2lvblR5cGUuUmVzdHJpY3RlZE1ldGhvZCwgbWV0aG9kLCBvcmlnaW4pLm1ldGhvZEltcGxlbWVudGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgb3JpZ2lucyAoaS5lLiBJRHMpIG9mIGFsbCBzdWJqZWN0cy5cbiAgICAgKi9cbiAgICBnZXRTdWJqZWN0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnN1YmplY3RzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGVybWlzc2lvbiBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgb2YgdGhlIHN1YmplY3QgY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgb3JpZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbWV0aG9kIG5hbWUgYXMgaW52b2tlZCBieSBhIHRoaXJkIHBhcnR5IChpLmUuLCBub3RcbiAgICAgKiBhIG1ldGhvZCBrZXkpLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9uIGlmIGl0IGV4aXN0cywgb3IgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0YXRlLnN1YmplY3RzW29yaWdpbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJtaXNzaW9uc1t0YXJnZXROYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgcGVybWlzc2lvbnMgZm9yIHRoZSBzcGVjaWZpZWQgc3ViamVjdCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIHBlcm1pc3Npb25zIG9mIHRoZSBzdWJqZWN0LCBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3RhdGUuc3ViamVjdHNbb3JpZ2luXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcm1pc3Npb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhcyB0aGUgc3BlY2lmaWVkXG4gICAgICogcGVybWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3ViamVjdCBoYXMgdGhlIHBlcm1pc3Npb24uXG4gICAgICovXG4gICAgaGFzUGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHN1YmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG9yaWdpbiBoYXMgYW55IHBlcm1pc3Npb25zLlxuICAgICAqIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzdWJqZWN0IFwiZXhpc3RzXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBhbnkgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgaGFzUGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3RhdGUuc3ViamVjdHNbb3JpZ2luXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYWxsIHBlcm1pc3Npb25zIGZyb20gdGhlIHNwZWNpZmllZCBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3Igb2YgdGhlIG9yaWdpbiBoYXMgbm8gcGVybWlzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB3aG9zZSBwZXJtaXNzaW9ucyB0byByZXZva2UuXG4gICAgICovXG4gICAgcmV2b2tlQWxsUGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3Iob3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbiBmcm9tIHRoZSBzdWJqZWN0IHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3ViamVjdCBvciB0aGUgcGVybWlzc2lvbiBkb2VzIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IHdob3NlIHBlcm1pc3Npb24gdG8gcmV2b2tlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gcmV2b2tlLlxuICAgICAqL1xuICAgIHJldm9rZVBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5yZXZva2VQZXJtaXNzaW9ucyh7IFtvcmlnaW5dOiBbdGFyZ2V0XSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb25zIGZyb20gdGhlIHNwZWNpZmllZCBzdWJqZWN0cy5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIHN1YmplY3RzIG9yIHBlcm1pc3Npb25zIGRvIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJqZWN0c0FuZFBlcm1pc3Npb25zIC0gQW4gb2JqZWN0IG1hcHBpbmcgc3ViamVjdCBvcmlnaW5zXG4gICAgICogdG8gYXJyYXlzIG9mIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWVzIHRvIHJldm9rZS5cbiAgICAgKi9cbiAgICByZXZva2VQZXJtaXNzaW9ucyhzdWJqZWN0c0FuZFBlcm1pc3Npb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdWJqZWN0c0FuZFBlcm1pc3Npb25zKS5mb3JFYWNoKChvcmlnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkoZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YmplY3RzQW5kUGVybWlzc2lvbnNbb3JpZ2luXS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkocGVybWlzc2lvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlUGVybWlzc2lvbihkcmFmdFN0YXRlLnN1YmplY3RzLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYWxsIHBlcm1pc3Npb25zIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQgZm9yIGFsbCBzdWJqZWN0cy5cbiAgICAgKiBEb2VzIG5vdGhpbmcgaWYgbm8gc3ViamVjdHMgb3Igbm8gc3VjaCBwZXJtaXNzaW9uIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IHRvIHJldm9rZSBhbGwgcGVybWlzc2lvbnMgZm9yLlxuICAgICAqL1xuICAgIHJldm9rZVBlcm1pc3Npb25Gb3JBbGxTdWJqZWN0cyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3ViamVjdE5hbWVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRyYWZ0U3RhdGUuc3ViamVjdHMpLmZvckVhY2goKFtvcmlnaW4sIHN1YmplY3RdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gc3ViamVjdDtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eShwZXJtaXNzaW9ucywgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgcGVybWlzc2lvbiBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBvcmlnaW4gYW5kIHRhcmdldC4gSWYgdGhlXG4gICAgICogcGVybWlzc2lvbiBpcyB0aGUgc2luZ2xlIHJlbWFpbmluZyBwZXJtaXNzaW9uIG9mIGl0cyBzdWJqZWN0LCB0aGUgc3ViamVjdFxuICAgICAqIGlzIGFsc28gZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJqZWN0cyAtIFRoZSBkcmFmdCBwZXJtaXNzaW9uIGNvbnRyb2xsZXIgc3ViamVjdHMuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBwZXJtaXNzaW9uXG4gICAgICogdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGRlbGV0ZVBlcm1pc3Npb24oc3ViamVjdHMsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHN1YmplY3RzW29yaWdpbl07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwZXJtaXNzaW9ucykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3ViamVjdHNbb3JpZ2luXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcGVybWlzc2lvbiBvZiB0aGUgc3ViamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICAgICAqIG9yaWdpbiBoYXMgYSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYSBwZXJtaXNzaW9uIHdpdGggdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldCBuYW1lLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwZXJtaXNzaW9uIGhhcyB0aGUgc3BlY2lmaWVkIGNhdmVhdC5cbiAgICAgKi9cbiAgICBoYXNDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgaWYgYW55LCBmb3IgdGhlIHBlcm1pc3Npb24gb2ZcbiAgICAgKiB0aGUgc3ViamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSBhIHBlcm1pc3Npb24gd2l0aCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgdGFyZ2V0IG5hbWUuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXZlYXQsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggY2F2ZWF0IGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpIHtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IHRoaXMuZ2V0UGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIGlmICghcGVybWlzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25fMS5maW5kQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGNhdmVhdCB2YWx1ZSwgdG9cbiAgICAgKiB0aGUgcGVybWlzc2lvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgcGVybWlzc2lvblxuICAgICAqIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEZvciBtb2RpZnlpbmcgZXhpc3RpbmcgY2F2ZWF0cywgdXNlXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdH0uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBwZXJtaXNzaW9uIGV4aXN0cywgb3IgaWYgdGhlIGNhdmVhdCBhbHJlYWR5XG4gICAgICogZXhpc3RzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGNhdmVhdCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlLCBjYXZlYXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0QWxyZWFkeUV4aXN0c0Vycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBiZWxvbmdpbmcgdG8gdGhlXG4gICAgICogcGVybWlzc2lvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgcGVybWlzc2lvblxuICAgICAqIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEZvciBhZGRpbmcgbmV3IGNhdmVhdHMsIHVzZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hZGRDYXZlYXR9LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggcGVybWlzc2lvbiBvciBjYXZlYXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VmFsdWUgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjYXZlYXQuXG4gICAgICovXG4gICAgdXBkYXRlQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlLCBjYXZlYXRWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzcGVjaWZpZWQgY2F2ZWF0IG9uIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbi4gT3ZlcndyaXRlcyBleGlzdGluZ1xuICAgICAqIGNhdmVhdHMgb2YgdGhlIHNhbWUgdHlwZSBpbi1wbGFjZSAocHJlc2VydmluZyBhcnJheSBvcmRlciksIGFuZCBhZGRzIHRoZVxuICAgICAqIGNhdmVhdCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgZXhpc3Qgb3IgZmFpbHMgdG8gdmFsaWRhdGUgYWZ0ZXJcbiAgICAgKiBpdHMgY2F2ZWF0cyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hZGRDYXZlYXR9XG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlQ2F2ZWF0fVxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBzZXQuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBjYXZlYXQgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl07XG4gICAgICAgICAgICAvLyBVbnJlYWNoYWJsZSBiZWNhdXNlIGBoYXNDYXZlYXRgIGlzIGFsd2F5cyBjYWxsZWQgYmVmb3JlIHRoaXMsIGFuZCBpdFxuICAgICAgICAgICAgLy8gdGhyb3dzIGlmIHBlcm1pc3Npb25zIGFyZSBtaXNzaW5nLiBUeXBlU2NyaXB0IG5lZWRzIHRoaXMsIGhvd2V2ZXIuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3Iob3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBzdWJqZWN0LnBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHByYWN0aWNhbGx5IGltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IHdhbnRzIGl0ICovXG4gICAgICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhdmVhdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBjYXZlYXRUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjYXZlYXRWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2F2ZWF0KGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24uY2F2ZWF0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdmVhdEluZGV4ID0gcGVybWlzc2lvbi5jYXZlYXRzLmZpbmRJbmRleCgoZXhpc3RpbmdDYXZlYXQpID0+IGV4aXN0aW5nQ2F2ZWF0LnR5cGUgPT09IGNhdmVhdC50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2F2ZWF0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cy5wdXNoKGNhdmVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMuc3BsaWNlKGNhdmVhdEluZGV4LCAxLCBjYXZlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBBdCB0aGlzIHBvaW50LCB3ZSBkb24ndCBrbm93IGlmIHRoZSBzcGVjaWZpYyBwZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gaXMgYWxsb3dlZCB0byBoYXZlIGNhdmVhdHMsIGJ1dCBpdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBjYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtZXRob2QgZm9yIGEgcGVybWlzc2lvbiB0aGF0IG1heSBub3QgaGF2ZSBhbnkgY2F2ZWF0cy5cbiAgICAgICAgICAgICAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdGhlIHBlcm1pc3Npb24gdmFsaWRhdG9yIGlzIGFsc28gY2FsbGVkLlxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cyA9IFtjYXZlYXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFsbCBjYXZlYXRzIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlIGZvciBhbGwgc3ViamVjdHMgYW5kXG4gICAgICogcGVybWlzc2lvbnMgYnkgYXBwbHlpbmcgdGhlIHNwZWNpZmllZCBtdXRhdG9yIGZ1bmN0aW9uIHRvIHRoZW0uXG4gICAgICpcbiAgICAgKiAqKkFUVE46KiogUGVybWlzc2lvbnMgY2FuIGJlIHJldm9rZWQgZW50aXJlbHkgYnkgdGhlIGFjdGlvbiBvZiB0aGlzIG1ldGhvZCxcbiAgICAgKiByZWFkIG9uIGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQ2F2ZWF0IG11dGF0b3JzIGFyZSBmdW5jdGlvbnMgdGhhdCByZWNlaXZlIGEgY2F2ZWF0IHZhbHVlIGFuZCByZXR1cm4gYVxuICAgICAqIHR1cGxlIGNvbnNpc3Rpbmcgb2YgYSB7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbn0gYW5kLCBvcHRpb25hbGx5LCBhIG5ld1xuICAgICAqIHZhbHVlIHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY2F2ZWF0IHdpdGguXG4gICAgICpcbiAgICAgKiBGb3IgZWFjaCBjYXZlYXQsIGRlcGVuZGluZyBvbiB0aGUgbXV0YXRvciByZXN1bHQsIHRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogLSBEbyBub3RoaW5nICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5ub29wfSlcbiAgICAgKiAtIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIGNhdmVhdCAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24udXBkYXRlVmFsdWV9KVxuICAgICAqICAgLSBUaGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gdmFsaWRhdG9yLCBpZiBhbnksIHdpbGwgYmUgY2FsbGVkIGFmdGVyXG4gICAgICogICAgIHVwZGF0aW5nIHRoZSB2YWx1ZS5cbiAgICAgKiAtIERlbGV0ZSB0aGUgY2F2ZWF0ICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5kZWxldGVDYXZlYXR9KVxuICAgICAqICAgLSBUaGUgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uIHZhbGlkYXRvciwgaWYgYW55LCB3aWxsIGJlIGNhbGxlZCBhZnRlclxuICAgICAqICAgICBkZWxldGluZyB0aGUgY2F2ZWF0LlxuICAgICAqIC0gUmV2b2tlIHRoZSBwYXJlbnQgcGVybWlzc2lvbiAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24ucmV2b2tlUGVybWlzc2lvbn0pXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB0aHJvd3MgaWYgdGhlIHZhbGlkYXRpb24gb2YgYW55IGNhdmVhdCBvciBwZXJtaXNzaW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldENhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0cyB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIG11dGF0b3IgLSBUaGUgbXV0YXRvciBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGNhdmVhdFxuICAgICAqIHZhbHVlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVQZXJtaXNzaW9uc0J5Q2F2ZWF0KHRhcmdldENhdmVhdFR5cGUsIG11dGF0b3IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3ViamVjdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGRyYWZ0U3RhdGUuc3ViamVjdHMpLmZvckVhY2goKHN1YmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHN1YmplY3QucGVybWlzc2lvbnMpLmZvckVhY2goKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDYXZlYXQgPSBjYXZlYXRzID09PSBudWxsIHx8IGNhdmVhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdmVhdHMuZmluZCgoeyB0eXBlIH0pID0+IHR5cGUgPT09IHRhcmdldENhdmVhdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldENhdmVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtdXRhdG9yIG1heSBtb2RpZnkgdGhlIGNhdmVhdCB2YWx1ZSBpbiBwbGFjZSwgYW5kIG11c3QgYWx3YXlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBhIHZhbGlkIG11dGF0aW9uIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRvclJlc3VsdCA9IG11dGF0b3IodGFyZ2V0Q2F2ZWF0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtdXRhdG9yUmVzdWx0Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLm5vb3A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24udXBkYXRlVmFsdWU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IGBNdXRhYmxlYCBpcyB1c2VkIGhlcmUgdG8gYXNzaWduIHRvIGEgcmVhZG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eS4gYHRhcmdldENvbnN0cmFpbnRgIHNob3VsZCBhbHJlYWR5IGJlIG11dGFibGUgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcGFydCBvZiBhIGRyYWZ0LCBidXQgZm9yIHNvbWUgcmVhc29uIGl0J3Mgbm90LiBXZSBjYW4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbW9yZS1jb3JyZWN0IGBEcmFmdGAgdHlwZSBoZXJlIGVpdGhlciBiZWNhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDYXZlYXQudmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdG9yUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYXZlYXQodGFyZ2V0Q2F2ZWF0LCBzdWJqZWN0Lm9yaWdpbiwgcGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5kZWxldGVDYXZlYXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVDYXZlYXQocGVybWlzc2lvbiwgdGFyZ2V0Q2F2ZWF0VHlwZSwgc3ViamVjdC5vcmlnaW4sIHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24ucmV2b2tlUGVybWlzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgc3ViamVjdC5vcmlnaW4sIHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlIGNoZWNrIGVuc3VyZXMgdGhhdCB0aGUgc3dpdGNoIHN0YXRlbWVudCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aGF1c3RpdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG11dGF0b3JSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbXV0YXRpb24gcmVzdWx0OiBcIiR7X2V4aGF1c3RpdmVDaGVjay5vcGVyYXRpb259XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGZyb20gdGhlIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgdGFyZ2V0IG5hbWUuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBwZXJtaXNzaW9uIG9yIGNhdmVhdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZUNhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IChfYSA9IGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGVybWlzc2lvbi5jYXZlYXRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBjYXZlYXQgZnJvbSB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uIElmIG5vIGNhdmVhdHNcbiAgICAgKiByZW1haW4gYWZ0ZXIgZGVsZXRpb24sIHRoZSBwZXJtaXNzaW9uJ3MgY2F2ZWF0IHByb3BlcnR5IGlzIHNldCB0byBgbnVsbGAuXG4gICAgICogVGhlIHBlcm1pc3Npb24gaXMgdmFsaWRhdGVkIGFmdGVyIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGhhdmUgYSBjYXZlYXQgd2l0aCB0aGUgc3BlY2lmaWVkXG4gICAgICogdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gVGhlIHBlcm1pc3Npb24gd2hvc2UgY2F2ZWF0IHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoZSBwZXJtaXNzaW9uIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKi9cbiAgICBkZWxldGVDYXZlYXQocGVybWlzc2lvbiwgY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBub3QgcG9zc2libGUgaW4gb3VyIHVzYWdlICovXG4gICAgICAgIGlmICghcGVybWlzc2lvbi5jYXZlYXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhdmVhdEluZGV4ID0gcGVybWlzc2lvbi5jYXZlYXRzLmZpbmRJbmRleCgoZXhpc3RpbmdDYXZlYXQpID0+IGV4aXN0aW5nQ2F2ZWF0LnR5cGUgPT09IGNhdmVhdFR5cGUpO1xuICAgICAgICBpZiAoY2F2ZWF0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLmNhdmVhdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVybWlzc2lvbi5jYXZlYXRzLnNwbGljZShjYXZlYXRJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIG1vZGlmaWVkIHBlcm1pc3Npb24uIFNob3VsZCAqKmFsd2F5cyoqIGJlIGludm9rZWRcbiAgICAgKiBvbiBhIHBlcm1pc3Npb24gYWZ0ZXIgaXRzIGNhdmVhdHMgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogSnVzdCBsaWtlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZVBlcm1pc3Npb259LCBleGNlcHQgdGhhdCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHRhcmdldCBrZXkgYW5kIHNwZWNpZmljYXRpb24gYXJlIHJldHJpZXZlZCBmaXJzdCwgYW5kIGFuXG4gICAgICogZXJyb3IgaXMgdGhyb3duIGlmIHRoZSB0YXJnZXQga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgbW9kaWZpZWQgcGVybWlzc2lvbiB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgdGFyZ2V0IG5hbWUgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkocGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIHNob3VsZCBiZSBpbXBvc3NpYmxlICovXG4gICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhdGFsOiBFeGlzdGluZyBwZXJtaXNzaW9uIHRhcmdldCBrZXkgXCIke3RhcmdldEtleX1cIiBoYXMgbm8gc3BlY2lmaWNhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbih0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSksIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleSBmb3IgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gc3VwcG9ydCBvdXIgbmFtZXNwYWNlZCBwZXJtaXNzaW9uIHRhcmdldCBmZWF0dXJlLCB3aGljaCBpcyB1c2VkXG4gICAgICogdG8gaW1wbGVtZW50IG5hbWVzcGFjZWQgcmVzdHJpY3RlZCBKU09OLVJQQyBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICogQHJldHVybnMgVGhlIGludGVybmFsIGtleSBvZiB0aGUgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICovXG4gICAgZ2V0VGFyZ2V0S2V5KHRhcmdldCkge1xuICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eSh0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZXNwYWNlZFRhcmdldHNXaXRob3V0V2lsZGNhcmQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRLZXkgb2YgT2JqZWN0LmtleXModGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zKSkge1xuICAgICAgICAgICAgY29uc3Qgd2lsZENhcmRNYXRjaCA9IHRhcmdldEtleS5tYXRjaCgvKC4rKVxcKiQvdSk7XG4gICAgICAgICAgICBpZiAod2lsZENhcmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkW3dpbGRDYXJkTWF0Y2hbMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgcG90ZW50aWFsbHkgbmVzdGVkIG5hbWVzcGFjZXM6XG4gICAgICAgIC8vIEV4OiB3aWxkem9uZV9cbiAgICAgICAgLy8gRXg6IGV0aF9wbHVnaW5fXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGFyZ2V0LnNwbGl0KCdfJyk7XG4gICAgICAgIGxldCB0YXJnZXRLZXkgPSAnJztcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICF1dGlsc18xLmhhc1Byb3BlcnR5KHRoaXMuX3Blcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgdGFyZ2V0S2V5KSAmJlxuICAgICAgICAgICAgIW5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkW3RhcmdldEtleV0pIHtcbiAgICAgICAgICAgIHRhcmdldEtleSArPSBgJHtzZWdtZW50cy5zaGlmdCgpfV9gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2VkVGFyZ2V0c1dpdGhvdXRXaWxkY2FyZFt0YXJnZXRLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGFyZ2V0S2V5fSpgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBfYXBwcm92ZWRfIHBlcm1pc3Npb25zIHRvIHRoZSBzcGVjaWZpZWQgc3ViamVjdC4gRXZlcnkgcGVybWlzc2lvbiBhbmRcbiAgICAgKiBjYXZlYXQgaXMgc3RyaW5nZW50bHkgdmFsaWRhdGVkIOKAkyBpbmNsdWRpbmcgYnkgY2FsbGluZyBldmVyeSBzcGVjaWZpY2F0aW9uXG4gICAgICogdmFsaWRhdG9yIOKAkyBhbmQgYW4gZXJyb3IgaXMgdGhyb3duIGlmIGFueSB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogKipBVFROOioqIFRoaXMgbWV0aG9kIGRvZXMgKipub3QqKiBwcm9tcHQgdGhlIHVzZXIgZm9yIGFwcHJvdmFsLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zfSBGb3IgaW5pdGlhdGluZyBhXG4gICAgICogcGVybWlzc2lvbnMgcmVxdWVzdCByZXF1aXJpbmcgdXNlciBhcHByb3ZhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFwcHJvdmVkUGVybWlzc2lvbnMgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGFwcHJvdmVkIGJ5XG4gICAgICogdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVxdWVzdERhdGEgLSBQZXJtaXNzaW9uIHJlcXVlc3QgZGF0YS4gUGFzc2VkIHRvIHBlcm1pc3Npb25cbiAgICAgKiBmYWN0b3J5IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgLSBXaGV0aGVyIHRvIHByZXNlcnZlIHRoZVxuICAgICAqIHN1YmplY3QncyBleGlzdGluZyBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWJqZWN0IC0gVGhlIHN1YmplY3QgdG8gZ3JhbnQgcGVybWlzc2lvbnMgdG8uXG4gICAgICogQHJldHVybnMgVGhlIGdyYW50ZWQgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgZ3JhbnRQZXJtaXNzaW9ucyh7IGFwcHJvdmVkUGVybWlzc2lvbnMsIHJlcXVlc3REYXRhLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlLCBzdWJqZWN0LCB9KSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBzdWJqZWN0O1xuICAgICAgICBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSAocHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0UGVybWlzc2lvbnMob3JpZ2luKSkgOiB7fSk7XG4gICAgICAgIGZvciAoY29uc3QgW3JlcXVlc3RlZFRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhhcHByb3ZlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkocmVxdWVzdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEubWV0aG9kTm90Rm91bmQocmVxdWVzdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHByb3ZlZFBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkVGFyZ2V0ICE9PSBhcHByb3ZlZFBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3Iob3JpZ2luLCByZXF1ZXN0ZWRUYXJnZXQsIGFwcHJvdmVkUGVybWlzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIHRhcmdldCBtdXN0IGJlIGEgdmFsaWQgdGFyZ2V0IG5hbWUgaWYgd2UgZm91bmQgaXRzIGtleS5cbiAgICAgICAgICAgIC8vIFdlIHJlYXNzaWduIGl0IHRvIGNoYW5nZSBpdHMgdHlwZS5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSByZXF1ZXN0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpO1xuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBjYXZlYXRzIGFyZSB2YWxpZGF0ZWQgaGVyZS5cbiAgICAgICAgICAgIGNvbnN0IGNhdmVhdHMgPSB0aGlzLmNvbnN0cnVjdENhdmVhdHMob3JpZ2luLCB0YXJnZXROYW1lLCBhcHByb3ZlZFBlcm1pc3Npb24uY2F2ZWF0cyk7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjYXZlYXRzLFxuICAgICAgICAgICAgICAgIGludm9rZXI6IG9yaWdpbixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBlcm1pc3Npb247XG4gICAgICAgICAgICBpZiAoc3BlY2lmaWNhdGlvbi5mYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbiA9IHNwZWNpZmljYXRpb24uZmFjdG9yeShwZXJtaXNzaW9uT3B0aW9ucywgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEZ1bGwgY2F2ZWF0IGFuZCBwZXJtaXNzaW9uIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkIGhlcmUgc2luY2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmFjdG9yeSBmdW5jdGlvbiBjYW4gYXJiaXRyYXJpbHkgbW9kaWZ5IHRoZSBlbnRpcmUgcGVybWlzc2lvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkaW5nIGl0cyBjYXZlYXRzLlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uKHNwZWNpZmljYXRpb24sIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uID0gUGVybWlzc2lvbl8xLmNvbnN0cnVjdFBlcm1pc3Npb24ocGVybWlzc2lvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIHZhbGlkYXRlIGNhdmVhdHMgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZSBwbGFpblxuICAgICAgICAgICAgICAgIC8vIHBlcm1pc3Npb24gY29uc3RydWN0b3IgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSBjYXZlYXRzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdlcmUgYWxyZWFkeSB2YWxpZGF0ZWQgYnkgYGNvbnN0cnVjdENhdmVhdHNgIGFib3ZlLlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uKHNwZWNpZmljYXRpb24sIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJtaXNzaW9uc1t0YXJnZXROYW1lXSA9IHBlcm1pc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRWYWxpZGF0ZWRQZXJtaXNzaW9ucyhvcmlnaW4sIHBlcm1pc3Npb25zKTtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uIGJ5OlxuICAgICAqIC0gRW5zdXJpbmcgdGhhdCBpdHMgYGNhdmVhdHNgIHByb3BlcnR5IGlzIGVpdGhlciBgbnVsbGAgb3IgYSBub24tZW1wdHlcbiAgICAgKiAgIGFycmF5LlxuICAgICAqIC0gRW5zdXJpbmcgdGhhdCBpdCBvbmx5IGluY2x1ZGVzIGNhdmVhdHMgYWxsb3dlZCBieSBpdHMgc3BlY2lmaWNhdGlvbi5cbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXQgaW5jbHVkZXMgbm8gZHVwbGljYXRlIGNhdmVhdHMgKGJ5IGNhdmVhdCB0eXBlKS5cbiAgICAgKiAtIFZhbGlkYXRpbmcgZWFjaCBjYXZlYXQgb2JqZWN0LCBpZiBgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb25gIGlzIGB0cnVlYC5cbiAgICAgKiAtIENhbGxpbmcgdGhlIHZhbGlkYXRvciBvZiBpdHMgc3BlY2lmaWNhdGlvbiwgaWYgb25lIGV4aXN0cyBhbmRcbiAgICAgKiAgIGBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGVjaWZpY2F0aW9uIC0gVGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgcGVybWlzc2lvbiB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHZhbGlkYXRpb25PcHRpb25zIC0gVmFsaWRhdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB2YWxpZGF0aW9uT3B0aW9ucy5pbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yIC0gV2hldGhlciB0byBpbnZva2UgdGhlXG4gICAgICogcGVybWlzc2lvbidzIGNvbnN1bWVyLXNwZWNpZmllZCB2YWxpZGF0b3IgZnVuY3Rpb24sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0gdmFsaWRhdGlvbk9wdGlvbnMucGVyZm9ybUNhdmVhdFZhbGlkYXRpb24gLSBXaGV0aGVyIHRvIGludm9rZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZUNhdmVhdH0gb24gZWFjaCBvZiB0aGUgcGVybWlzc2lvbidzXG4gICAgICogY2F2ZWF0cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBlcm1pc3Npb24oc3BlY2lmaWNhdGlvbiwgcGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lLCB7IGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3IsIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uIH0gPSB7XG4gICAgICAgIGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3I6IHRydWUsXG4gICAgICAgIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uOiB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkQ2F2ZWF0cywgdmFsaWRhdG9yIH0gPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eShwZXJtaXNzaW9uLCAnY2F2ZWF0cycpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgICAgICAgICBpZiAoY2F2ZWF0cyAhPT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkoY2F2ZWF0cykgJiYgY2F2ZWF0cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3Iob3JpZ2luLCB0YXJnZXROYW1lLCBjYXZlYXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZW5DYXZlYXRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGNhdmVhdHMgPT09IG51bGwgfHwgY2F2ZWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F2ZWF0cy5mb3JFYWNoKChjYXZlYXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVyZm9ybUNhdmVhdFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGFsbG93ZWRDYXZlYXRzID09PSBudWxsIHx8IGFsbG93ZWRDYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ2F2ZWF0cy5pbmNsdWRlcyhjYXZlYXQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Gb3JiaWRkZW5DYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5DYXZlYXRUeXBlcy5oYXMoY2F2ZWF0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5EdXBsaWNhdGVDYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VlbkNhdmVhdFR5cGVzLmFkZChjYXZlYXQudHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2tlUGVybWlzc2lvblZhbGlkYXRvciAmJiB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9ucyB0byB0aGUgc3ViamVjdCB3aXRoIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICogT3ZlcndyaXRlcyBhbGwgZXhpc3RpbmcgcGVybWlzc2lvbnMsIGFuZCBjcmVhdGVzIGEgc3ViamVjdCBlbnRyeSBpZiBpdFxuICAgICAqIGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKlxuICAgICAqICoqQVRUTjoqKiBBc3N1bWVzIHRoYXQgdGhlIG5ldyBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gdmFsaWRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGdyYW50ZWUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnMgLSBUaGUgbmV3IHBlcm1pc3Npb25zIGZvciB0aGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqL1xuICAgIHNldFZhbGlkYXRlZFBlcm1pc3Npb25zKG9yaWdpbiwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSB7XG4gICAgICAgICAgICAgICAgZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dID0geyBvcmlnaW4sIHBlcm1pc3Npb25zOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dLnBlcm1pc3Npb25zID0gaW1tZXJfMS5jYXN0RHJhZnQocGVybWlzc2lvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSByZXF1ZXN0ZWQgY2F2ZWF0cyBmb3IgdGhlIHBlcm1pc3Npb24gb2YgdGhlIHNwZWNpZmllZFxuICAgICAqIHN1YmplY3Qgb3JpZ2luIGFuZCB0YXJnZXQgbmFtZSBhbmQgcmV0dXJucyB0aGUgdmFsaWRhdGVkIGNhdmVhdCBhcnJheS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHBlcm1pc3Npb24gc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZENhdmVhdHMgLSBUaGUgcmVxdWVzdGVkIGNhdmVhdHMgdG8gY29uc3RydWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBjYXZlYXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdENhdmVhdHMob3JpZ2luLCB0YXJnZXQsIHJlcXVlc3RlZENhdmVhdHMpIHtcbiAgICAgICAgY29uc3QgY2F2ZWF0QXJyYXkgPSByZXF1ZXN0ZWRDYXZlYXRzID09PSBudWxsIHx8IHJlcXVlc3RlZENhdmVhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RlZENhdmVhdHMubWFwKChyZXF1ZXN0ZWRDYXZlYXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYXZlYXQocmVxdWVzdGVkQ2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbiBzbyB0aGF0IHdlIGhhdmUgYSBmcmVzaCBvYmplY3QuXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSByZXF1ZXN0ZWRDYXZlYXQ7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlLCB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhdmVhdEFycmF5ICYmIHV0aWxzXzEuaXNOb25FbXB0eUFycmF5KGNhdmVhdEFycmF5KVxuICAgICAgICAgICAgPyBjYXZlYXRBcnJheVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kcyB2YWxpZGF0ZXMgdGhhdCB0aGUgc3BlY2lmaWVkIGNhdmVhdCBpcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBleHBlY3RlZCBwcm9wZXJ0aWVzIGFuZCB0eXBlcy4gSXQgYWxzbyBlbnN1cmVzIHRoYXQgYSBjYXZlYXQgc3BlY2lmaWNhdGlvblxuICAgICAqIGV4aXN0cyBmb3IgdGhlIHJlcXVlc3RlZCBjYXZlYXQgdHlwZSwgYW5kIGNhbGxzIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAgICogdmFsaWRhdG9yLCBpZiBpdCBleGlzdHMsIG9uIHRoZSBjYXZlYXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2F2ZWF0IC0gVGhlIGNhdmVhdCBvYmplY3QgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJqZWN0IG9mIHRoZSBwYXJlbnRcbiAgICAgKiBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXJlbnQgcGVybWlzc2lvbi5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF1dGlsc18xLmlzUGxhaW5PYmplY3QoY2F2ZWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDYXZlYXRFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2F2ZWF0KS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYXZlYXQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSB0aGlzLmdldENhdmVhdFNwZWNpZmljYXRpb24oY2F2ZWF0LnR5cGUpO1xuICAgICAgICBpZiAoIXNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0LnR5cGUsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkoY2F2ZWF0LCAndmFsdWUnKSB8fCBjYXZlYXQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdE1pc3NpbmdWYWx1ZUVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1ZhbGlkSnNvbihjYXZlYXQudmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0SW52YWxpZEpzb25FcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlY2FzdDogVHlwZVNjcmlwdCBzdGlsbCBiZWxpZXZlcyB0aGF0IHRoZSBjYXZlYXQgaXMgYSBQbGFpbk9iamVjdC5cbiAgICAgICAgKF9hID0gc3BlY2lmaWNhdGlvbi52YWxpZGF0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNwZWNpZmljYXRpb24sIGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBwZXJtaXNzaW9uIHJlcXVlc3QgdGhhdCByZXF1aXJlcyB1c2VyIGFwcHJvdmFsLiBUaGlzIHNob3VsZFxuICAgICAqIGFsd2F5cyBiZSB1c2VkIHRvIGdyYW50IGFkZGl0aW9uYWwgcGVybWlzc2lvbnMgdG8gYSBzdWJqZWN0LCB1bmxlc3MgdXNlclxuICAgICAqIGFwcHJvdmFsIGhhcyBiZWVuIG9idGFpbmVkIHRocm91Z2ggc29tZSBvdGhlciBtZWFucy5cbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb25zIGFyZSB2YWxpZGF0ZWQgYXQgZXZlcnkgc3RlcCBvZiB0aGUgYXBwcm92YWwgcHJvY2VzcywgYW5kIHRoaXNcbiAgICAgKiBtZXRob2Qgd2lsbCByZWplY3QgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gRm9yIHRoZSB1c2VyIGFwcHJvdmFsIGxvZ2ljLlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdH0gRm9yIHRoZSBtZXRob2RcbiAgICAgKiB0aGF0IF9hY2NlcHRzXyB0aGUgcmVxdWVzdCBhbmQgcmVzb2x2ZXMgdGhlIHVzZXIgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3R9IEZvciB0aGUgbWV0aG9kXG4gICAgICogdGhhdCBfcmVqZWN0c18gdGhlIHJlcXVlc3QgYW5kIHRoZSB1c2VyIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICogQHBhcmFtIHN1YmplY3QgLSBUaGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRQZXJtaXNzaW9ucyAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWQgLSBUaGUgaWQgb2YgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3QuIERlZmF1bHRzIHRvIGEgdW5pcXVlXG4gICAgICogaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zIC0gV2hldGhlciB0byBwcmVzZXJ2ZSB0aGVcbiAgICAgKiBzdWJqZWN0J3MgZXhpc3RpbmcgcGVybWlzc2lvbnMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ3JhbnRlZCBwZXJtaXNzaW9ucyBhbmQgcmVxdWVzdCBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0UGVybWlzc2lvbnMoc3ViamVjdCwgcmVxdWVzdGVkUGVybWlzc2lvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgY29uc3QgeyBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlcXVlc3RlZFBlcm1pc3Npb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYSA9IGF3YWl0IHRoaXMucmVxdWVzdFVzZXJBcHByb3ZhbChwZXJtaXNzaW9uc1JlcXVlc3QpLCB7IHBlcm1pc3Npb25zOiBhcHByb3ZlZFBlcm1pc3Npb25zIH0gPSBfYSwgcmVxdWVzdERhdGEgPSBfX3Jlc3QoX2EsIFtcInBlcm1pc3Npb25zXCJdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuZ3JhbnRQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlRXhpc3RpbmdQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuIFRocm93cyBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgYXJlIGEgcHJvcGVybHlcbiAgICAgKiBmb3JtYXR0ZWQge0BsaW5rIFJlcXVlc3RlZFBlcm1pc3Npb25zfSBvYmplY3QsIGFuZCBwZXJmb3JtcyB0aGUgc2FtZVxuICAgICAqIHZhbGlkYXRpb24gYXMge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmdyYW50UGVybWlzc2lvbnN9LCBleGNlcHQgdGhhdFxuICAgICAqIGNvbnN1bWVyLXNwZWNpZmllZCBwZXJtaXNzaW9uIHZhbGlkYXRvciBmdW5jdGlvbnMgYXJlIG5vdCBjYWxsZWQsIHNpbmNlXG4gICAgICogdGhleSBhcmUgb25seSBjYWxsZWQgb24gZnVsbHkgY29uc3RydWN0ZWQsIGFwcHJvdmVkIHBlcm1pc3Npb25zIHRoYXQgYXJlXG4gICAgICogb3RoZXJ3aXNlIGNvbXBsZXRlbHkgdmFsaWQuXG4gICAgICpcbiAgICAgKiBVbnJlY29nbnppZWQgcHJvcGVydGllcyBvbiByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRQZXJtaXNzaW9ucyAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgdmFsaWRhdGVSZXF1ZXN0ZWRQZXJtaXNzaW9ucyhvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHJlcXVlc3RlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlcXVlc3RlZCBwZXJtaXNzaW9ucyBmb3Igb3JpZ2luIFwiJHtvcmlnaW59XCIgaXMgbm90IGEgcGxhaW4gb2JqZWN0LmAsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdGVkUGVybWlzc2lvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGNvbnRhaW5zIG5vIHBlcm1pc3Npb25zLmAsXG4gICAgICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXROYW1lIG9mIE9iamVjdC5rZXlzKHJlcXVlc3RlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IHJlcXVlc3RlZFBlcm1pc3Npb25zW3RhcmdldE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkodGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKHRhcmdldE5hbWUsIHsgb3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHBlcm1pc3Npb24pIHx8XG4gICAgICAgICAgICAgICAgKHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5hbWUgIT09IHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGNvbnRhaW5zIGludmFsaWQgcmVxdWVzdGVkIHBlcm1pc3Npb24ocykuYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIZXJlIHdlIHZhbGlkYXRlIHRoZSBwZXJtaXNzaW9uIHdpdGhvdXQgaW52b2tpbmcgaXRzIHZhbGlkYXRvciwgaWYgYW55LlxuICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gYXBwcm92ZWQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbih0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSksIFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IFRoZSBwZXJtaXNzaW9uIGlzIHN0aWxsIGEgXCJQbGFpbk9iamVjdFwiIGhlcmUuXG4gICAgICAgICAgICBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHsgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogZmFsc2UsIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZXF1ZXN0IHRvIHRoZSB7QGxpbmsgQXBwcm92YWxDb250cm9sbGVyfSB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgQWRkQXBwcm92YWxSZXF1ZXN0fSBhY3Rpb24uIEFsc28gdmFsaWRhdGVzIHRoZSByZXN1bHRpbmcgYXBwcm92ZWRcbiAgICAgKiBwZXJtaXNzaW9ucyByZXF1ZXN0LCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnNSZXF1ZXN0IC0gVGhlIHBlcm1pc3Npb25zIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0VXNlckFwcHJvdmFsKHBlcm1pc3Npb25zUmVxdWVzdCkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiwgaWQgfSA9IHBlcm1pc3Npb25zUmVxdWVzdC5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgYXBwcm92ZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOmFkZFJlcXVlc3QnLCB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBwZXJtaXNzaW9uc1JlcXVlc3QsXG4gICAgICAgICAgICB0eXBlOiB1dGlsc18yLk1ldGhvZE5hbWVzLnJlcXVlc3RQZXJtaXNzaW9ucyxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVBcHByb3ZlZFBlcm1pc3Npb25zKGFwcHJvdmVkUmVxdWVzdCwgeyBpZCwgb3JpZ2luIH0pO1xuICAgICAgICByZXR1cm4gYXBwcm92ZWRSZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYW4gYXBwcm92ZWQge0BsaW5rIFBlcm1pc3Npb25zUmVxdWVzdH0gb2JqZWN0LiBUaGUgYXBwcm92ZWRcbiAgICAgKiByZXF1ZXN0IG11c3QgaGF2ZSB0aGUgcmVxdWlyZWQgYG1ldGFkYXRhYCBhbmQgYHBlcm1pc3Npb25zYCBwcm9wZXJ0aWVzLFxuICAgICAqIHRoZSBgaWRgIGFuZCBgb3JpZ2luYCBvZiB0aGUgYG1ldGFkYXRhYCBtdXN0IG1hdGNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0XG4gICAgICogbWV0YWRhdGEsIGFuZCB0aGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIG11c3QgYmUgdmFsaWQgcGVyXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnN9LiBBbnkgZXh0cmFcbiAgICAgKiBtZXRhZGF0YSBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWRSZXF1ZXN0IC0gVGhlIGFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbE1ldGFkYXRhIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QgbWV0YWRhdGEuXG4gICAgICovXG4gICAgdmFsaWRhdGVBcHByb3ZlZFBlcm1pc3Npb25zKGFwcHJvdmVkUmVxdWVzdCwgb3JpZ2luYWxNZXRhZGF0YSkge1xuICAgICAgICBjb25zdCB7IGlkLCBvcmlnaW4gfSA9IG9yaWdpbmFsTWV0YWRhdGE7XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KGFwcHJvdmVkUmVxdWVzdCkgfHxcbiAgICAgICAgICAgICF1dGlsc18xLmlzUGxhaW5PYmplY3QoYXBwcm92ZWRSZXF1ZXN0Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgQXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBmb3Igc3ViamVjdCBcIiR7b3JpZ2lufVwiIGlzIGludmFsaWQuYCwgeyBkYXRhOiB7IGFwcHJvdmVkUmVxdWVzdCB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGE6IHsgaWQ6IG5ld0lkLCBvcmlnaW46IG5ld09yaWdpbiB9LCBwZXJtaXNzaW9ucywgfSA9IGFwcHJvdmVkUmVxdWVzdDtcbiAgICAgICAgaWYgKG5ld0lkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgQXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBmb3Igc3ViamVjdCBcIiR7b3JpZ2lufVwiIG11dGF0ZWQgaXRzIGlkLmAsIHsgb3JpZ2luYWxJZDogaWQsIG11dGF0ZWRJZDogbmV3SWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKGBBcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBzdWJqZWN0IFwiJHtvcmlnaW59XCIgbXV0YXRlZCBpdHMgb3JpZ2luLmAsIHsgb3JpZ2luYWxPcmlnaW46IG9yaWdpbiwgbXV0YXRlZE9yaWdpbjogbmV3T3JpZ2luIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZS10aHJvdyBhcyBhbiBpbnRlcm5hbCBlcnJvcjsgd2Ugc2hvdWxkIG5ldmVyIHJlY2VpdmUgaW52YWxpZCBhcHByb3ZlZFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKGBJbnZhbGlkIGFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3Q6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvci5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgcGVybWlzc2lvbnMgcmVxdWVzdCBjcmVhdGVkIGJ5XG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHJlcXVlc3QubWV0YWRhdGE7XG4gICAgICAgIGlmICghdGhpcy5oYXNBcHByb3ZhbFJlcXVlc3QoeyBpZCB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0LnBlcm1pc3Npb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgcmVxdWVzdCBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbi4nLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdBcHByb3ZhbENvbnRyb2xsZXI6YWNjZXB0UmVxdWVzdCcsIGlkLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIGFjY2VwdGluZyB1bmV4cGVjdGVkbHkgZmFpbHMsIHJlamVjdCB0aGUgcmVxdWVzdCBhbmQgcmUtdGhyb3cgdGhlXG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGEgcGVybWlzc2lvbnMgcmVxdWVzdCBjcmVhdGVkIGJ5XG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHJlcXVlc3QgdG8gYmUgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBcHByb3ZhbFJlcXVlc3QoeyBpZCB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3JzXzEudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHtAbGluayBBcHByb3ZhbENvbnRyb2xsZXJ9IGhhcyBhIHBhcnRpY3VsYXIgcGVybWlzc2lvbnNcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0fSBhbmRcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0fSBmb3IgdXNhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUge0BsaW5rIEhhc0FwcHJvdmFsUmVxdWVzdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdCB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHJlcXVlc3QgZXhpc3RzLlxuICAgICAqL1xuICAgIGhhc0FwcHJvdmFsUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdBcHByb3ZhbENvbnRyb2xsZXI6aGFzUmVxdWVzdCcsIFxuICAgICAgICAvLyBUeXBlY2FzdDogRm9yIHNvbWUgcmVhc29uLCB0aGUgdHlwZSBoZXJlIGV4cGVjdHMgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAvLyBIYXNBcHByb3ZhbFJlcXVlc3Qgb3B0aW9ucyB0byBiZSBzcGVjaWZpZWQsIHdoZW4gdGhleSdyZSBhY3R1YWxseSBhbGxcbiAgICAgICAgLy8gb3B0aW9uYWwuIFBhc3NpbmcganVzdCB0aGUgaWQgaXMgZGVmaW5pdGVseSB2YWxpZCwgc28gd2UganVzdCBjYXN0IGl0LlxuICAgICAgICBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyB0aGUgcGVybWlzc2lvbnMgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgaWQsIHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIGVycm9yIGFzIHRoZSByZWFzb24uIFRoaXMgbWV0aG9kIGlzIGVmZmVjdGl2ZWx5IGEgd3JhcHBlciBhcm91bmQgYVxuICAgICAqIG1lc3NlbmdlciBjYWxsIGZvciB0aGUgYEFwcHJvdmFsQ29udHJvbGxlcjpyZWplY3RSZXF1ZXN0YCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3R9IGZvciB1c2FnZS5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHJlcXVlc3QgdG8gcmVqZWN0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlamVjdGlvbi5cbiAgICAgKi9cbiAgICBfcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOnJlamVjdFJlcXVlc3QnLCBpZCwgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdWJqZWN0J3MgZW5kb3dtZW50cyBwZXIgdGhlIHNwZWNpZmllZCBlbmRvd21lbnQgcGVybWlzc2lvbi5cbiAgICAgKiBUaHJvd3MgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbiBvciBpZiB0aGVcbiAgICAgKiBwZXJtaXNzaW9uIGlzIG5vdCBhbiBlbmRvd21lbnQgcGVybWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IHdob3NlIGVuZG93bWVudHMgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW5kb3dtZW50IHBlcm1pc3Npb24uIFRoaXMgbXVzdCBiZSBhXG4gICAgICogdmFsaWQgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LCBpZiBhbnkuXG4gICAgICogRm9yd2FyZGVkIHRvIHRoZSBlbmRvd21lbnQgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgZW5kb3dtZW50cywgaWYgYW55LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEVuZG93bWVudHMob3JpZ2luLCB0YXJnZXROYW1lLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzUGVybWlzc2lvbihvcmlnaW4sIHRhcmdldE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS51bmF1dGhvcml6ZWQoeyBkYXRhOiB7IG9yaWdpbiwgdGFyZ2V0TmFtZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUGVybWlzc2lvblNwZWNpZmljYXRpb24oUGVybWlzc2lvbl8xLlBlcm1pc3Npb25UeXBlLkVuZG93bWVudCwgdGFyZ2V0TmFtZSwgb3JpZ2luKS5lbmRvd21lbnRHZXR0ZXIoeyBvcmlnaW4sIHJlcXVlc3REYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHJlc3RyaWN0ZWQgbWV0aG9kIGFzIHRoZSBzdWJqZWN0IHdpdGggdGhlIGdpdmVuIG9yaWdpbi5cbiAgICAgKiBUaGUgc3BlY2lmaWVkIHBhcmFtcywgaWYgYW55LCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogKipBVFROOioqIEdyZWF0IGNhdXRpb24gc2hvdWxkIGJlIGV4ZXJjaXNlZCBpbiB0aGUgdXNlIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqIE1ldGhvZHMgdGhhdCBjYXVzZSBzaWRlIGVmZmVjdHMgb3IgYWZmZWN0IGFwcGxpY2F0aW9uIHN0YXRlIHNob3VsZFxuICAgICAqIGJlIGF2b2lkZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIHJlcXVlc3RlZCByZXN0cmljdGVkIG1ldGhvZFxuICAgICAqIGltcGxlbWVudGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2VzIG5vdCBleGlzdC4gVGhlIG1ldGhvZCB3aWxsIHRoZW4gYmVcbiAgICAgKiBpbnZva2VkIGFzIHRob3VnaCB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhZCBpbnZva2VkIGl0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuIFRoaXMgbWVhbnMgdGhhdCBhbnkgZXhpc3RpbmcgY2F2ZWF0cyB3aWxsIGJlXG4gICAgICogYXBwbGllZCB0byB0aGUgcmVzdHJpY3RlZCBtZXRob2QsIGFuZCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZVxuICAgICAqIHJlc3RyaWN0ZWQgbWV0aG9kIG9yIGl0cyBjYXZlYXQgZGVjb3JhdG9ycyB0aHJvdy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYVxuICAgICAqIHBlcm1pc3Npb24gZm9yIHRoZSBzcGVjaWZpZWQgcmVzdHJpY3RlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB0byBleGVjdXRlIHRoZSBtZXRob2Qgb24gYmVoYWxmXG4gICAgICogb2YuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGV4ZWN1dGUuIFRoaXMgbXVzdCBiZSBhIHZhbGlkXG4gICAgICogcGVybWlzc2lvbiB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGV4ZWN1dGVkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZChvcmlnaW4sIHRhcmdldE5hbWUsIHBhcmFtcykge1xuICAgICAgICAvLyBUaHJvd3MgaWYgdGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBjb25zdCBtZXRob2RJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZ2V0UmVzdHJpY3RlZE1ldGhvZCh0YXJnZXROYW1lLCBvcmlnaW4pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZChtZXRob2RJbXBsZW1lbnRhdGlvbiwgeyBvcmlnaW4gfSwgdGFyZ2V0TmFtZSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIHJlcXVlc3QgZm9yIG1ldGhvZCBcIiR7dGFyZ2V0TmFtZX1cIiBhcyBvcmlnaW4gXCIke29yaWdpbn1cIiByZXR1cm5lZCBubyByZXN1bHQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgbWV0aG9kIHVzZWQgaW4gdGhlIGNvbnRyb2xsZXIncyBganNvbi1ycGMtZW5naW5lYCBtaWRkbGV3YXJlXG4gICAgICogYW5kIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0uIENhbGxzIHRoZVxuICAgICAqIHNwZWNpZmllZCByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBhZnRlciBkZWNvcmF0aW5nIGl0IHdpdGggdGhlXG4gICAgICogY2F2ZWF0cyBvZiBpdHMgcGVybWlzc2lvbi4gVGhyb3dzIGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgdGhlXG4gICAgICogcmVxdWlzaXRlIHBlcm1pc3Npb24uXG4gICAgICpcbiAgICAgKiAqKkFUVE46KiogUGFyYW1ldGVyIHZhbGlkYXRpb24gaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIsIG9yXG4gICAgICogdGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uIGluIHRoZSBjYXNlIG9mIGBwYXJhbXNgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZX0gZm9yIHVzYWdlLlxuICAgICAqIEBwYXJhbSBtZXRob2RJbXBsZW1lbnRhdGlvbiAtIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIHN1YmplY3QgLSBNZXRhZGF0YSBhYm91dCB0aGUgc3ViamVjdCB0aGF0IG1hZGUgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBfZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QobWV0aG9kSW1wbGVtZW50YXRpb24sIHN1YmplY3QsIG1ldGhvZCwgcGFyYW1zID0gW10pIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IHN1YmplY3Q7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSB0aGlzLmdldFBlcm1pc3Npb24ob3JpZ2luLCBtZXRob2QpO1xuICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLnVuYXV0aG9yaXplZCh7IGRhdGE6IHsgb3JpZ2luLCBtZXRob2QgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2F2ZWF0XzEuZGVjb3JhdGVXaXRoQ2F2ZWF0cyhtZXRob2RJbXBsZW1lbnRhdGlvbiwgcGVybWlzc2lvbiwgdGhpcy5fY2F2ZWF0U3BlY2lmaWNhdGlvbnMpKHsgbWV0aG9kLCBwYXJhbXMsIGNvbnRleHQ6IHsgb3JpZ2luIH0gfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uQ29udHJvbGxlciA9IFBlcm1pc3Npb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVybWlzc2lvbkNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29yYXRlV2l0aENhdmVhdHMgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogRGVjb3JhdGUgYSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiB3aXRoIGl0cyBjYXZlYXRzLlxuICpcbiAqIE5vdGUgdGhhdCBhbGwgY2F2ZWF0IGZ1bmN0aW9ucyAoaS5lLiB0aGUgYXJndW1lbnQgYW5kIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAqIGRlY29yYXRvcikgbXVzdCBiZSBhd2FpdGVkLlxuICovXG5mdW5jdGlvbiBkZWNvcmF0ZVdpdGhDYXZlYXRzKG1ldGhvZEltcGxlbWVudGF0aW9uLCBwZXJtaXNzaW9uLCAvLyBib3VuZCB0byB0aGUgcmVxdWVzdGluZyBvcmlnaW5cbmNhdmVhdFNwZWNpZmljYXRpb25zKSB7XG4gICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgIGlmICghY2F2ZWF0cykge1xuICAgICAgICByZXR1cm4gbWV0aG9kSW1wbGVtZW50YXRpb247XG4gICAgfVxuICAgIGxldCBkZWNvcmF0ZWQgPSBhc3luYyAoYXJncykgPT4gbWV0aG9kSW1wbGVtZW50YXRpb24oYXJncyk7XG4gICAgZm9yIChjb25zdCBjYXZlYXQgb2YgY2F2ZWF0cykge1xuICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gY2F2ZWF0U3BlY2lmaWNhdGlvbnNbY2F2ZWF0LnR5cGVdO1xuICAgICAgICBpZiAoIXNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0LnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZCA9IHNwZWNpZmljYXRpb24uZGVjb3JhdG9yKGRlY29yYXRlZCwgY2F2ZWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRlZDtcbn1cbmV4cG9ydHMuZGVjb3JhdGVXaXRoQ2F2ZWF0cyA9IGRlY29yYXRlV2l0aENhdmVhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXZlYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhbmRsZXJzID0gdm9pZCAwO1xuY29uc3QgcmVxdWVzdFBlcm1pc3Npb25zXzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0UGVybWlzc2lvbnNcIik7XG5jb25zdCBnZXRQZXJtaXNzaW9uc18xID0gcmVxdWlyZShcIi4vZ2V0UGVybWlzc2lvbnNcIik7XG5leHBvcnRzLmhhbmRsZXJzID0gW3JlcXVlc3RQZXJtaXNzaW9uc18xLnJlcXVlc3RQZXJtaXNzaW9uc0hhbmRsZXIsIGdldFBlcm1pc3Npb25zXzEuZ2V0UGVybWlzc2lvbnNIYW5kbGVyXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbmFwQ29udHJvbGxlciA9IGV4cG9ydHMuU25hcFN0YXR1c0V2ZW50ID0gZXhwb3J0cy5TbmFwU3RhdHVzID0gZXhwb3J0cy5TTkFQX1BSRUZJWF9SRUdFWCA9IGV4cG9ydHMuU05BUF9QUkVGSVggPSBleHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgdmFsaWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2VtdmVyL2Z1bmN0aW9ucy92YWxpZFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QganNvbl9zY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9qc29uLXNjaGVtYXNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NuYXBDb250cm9sbGVyJztcbmV4cG9ydHMuU05BUF9QUkVGSVggPSAnd2FsbGV0X3NuYXBfJztcbmV4cG9ydHMuU05BUF9QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGBeJHtleHBvcnRzLlNOQVBfUFJFRklYfWAsICd1Jyk7XG5jb25zdCBUUlVOQ0FURURfU05BUF9QUk9QRVJUSUVTID0gbmV3IFNldChbXG4gICAgJ2luaXRpYWxQZXJtaXNzaW9ucycsXG4gICAgJ2lkJyxcbiAgICAncGVybWlzc2lvbk5hbWUnLFxuICAgICd2ZXJzaW9uJyxcbl0pO1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIHNuYXBFcnJvcnM6IHt9LFxuICAgIHNuYXBzOiB7fSxcbiAgICBzbmFwU3RhdGVzOiB7fSxcbn07XG52YXIgU25hcFN0YXR1cztcbihmdW5jdGlvbiAoU25hcFN0YXR1cykge1xuICAgIFNuYXBTdGF0dXNbXCJpbnN0YWxsaW5nXCJdID0gXCJpbnN0YWxsaW5nXCI7XG4gICAgU25hcFN0YXR1c1tcInJ1bm5pbmdcIl0gPSBcInJ1bm5pbmdcIjtcbiAgICBTbmFwU3RhdHVzW1wic3RvcHBlZFwiXSA9IFwic3RvcHBlZFwiO1xuICAgIFNuYXBTdGF0dXNbXCJjcmFzaGVkXCJdID0gXCJjcmFzaGVkXCI7XG59KShTbmFwU3RhdHVzID0gZXhwb3J0cy5TbmFwU3RhdHVzIHx8IChleHBvcnRzLlNuYXBTdGF0dXMgPSB7fSkpO1xudmFyIFNuYXBTdGF0dXNFdmVudDtcbihmdW5jdGlvbiAoU25hcFN0YXR1c0V2ZW50KSB7XG4gICAgU25hcFN0YXR1c0V2ZW50W1wic3RhcnRcIl0gPSBcInN0YXJ0XCI7XG4gICAgU25hcFN0YXR1c0V2ZW50W1wic3RvcFwiXSA9IFwic3RvcFwiO1xuICAgIFNuYXBTdGF0dXNFdmVudFtcImNyYXNoXCJdID0gXCJjcmFzaFwiO1xufSkoU25hcFN0YXR1c0V2ZW50ID0gZXhwb3J0cy5TbmFwU3RhdHVzRXZlbnQgfHwgKGV4cG9ydHMuU25hcFN0YXR1c0V2ZW50ID0ge30pKTtcbi8qKlxuICogR3VhcmQgdHJhbnNpdGlvbmluZyB3aGVuIHRoZSBzbmFwIGlzIGRpc2FibGVkLlxuICovXG5jb25zdCBkaXNhYmxlZEd1YXJkID0gKHNlcmlhbGl6ZWRTbmFwKSA9PiB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRTbmFwLmVuYWJsZWQ7XG59O1xuLyoqXG4gKiBUaGUgc3RhdGUgbWFjaGluZSBjb25maWd1cmF0aW9uIGZvciBhIHNuYXBzIGBzdGF0dXNgIHN0YXRlLlxuICogVXNpbmcgYSBzdGF0ZSBtYWNoaW5lIGZvciBhIHNuYXBzIGBzdGF0dXNgIGVuc3VyZXMgdGhhdCB0aGUgc25hcCB0cmFuc2l0aW9ucyB0byBhIHZhbGlkIG5leHQgbGlmZWN5Y2xlIHN0YXRlLlxuICogU3VwcG9ydHMgYSB2ZXJ5IG1pbmltYWwgc3Vic2V0IG9mIFhTdGF0ZSBjb252ZW50aW9ucyBvdXRsaW5lZCBpbiBgX3RyYW5zaXRpb25TbmFwU3RhdGVgLlxuICovXG5jb25zdCBzbmFwU3RhdHVzU3RhdGVNYWNoaW5lQ29uZmlnID0ge1xuICAgIGluaXRpYWw6IFNuYXBTdGF0dXMuaW5zdGFsbGluZyxcbiAgICBzdGF0ZXM6IHtcbiAgICAgICAgW1NuYXBTdGF0dXMuaW5zdGFsbGluZ106IHtcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgW1NuYXBTdGF0dXNFdmVudC5zdGFydF06IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBTbmFwU3RhdHVzLnJ1bm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmQ6IGRpc2FibGVkR3VhcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtTbmFwU3RhdHVzLnJ1bm5pbmddOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RvcF06IFNuYXBTdGF0dXMuc3RvcHBlZCxcbiAgICAgICAgICAgICAgICBbU25hcFN0YXR1c0V2ZW50LmNyYXNoXTogU25hcFN0YXR1cy5jcmFzaGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1NuYXBTdGF0dXMuc3RvcHBlZF06IHtcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgW1NuYXBTdGF0dXNFdmVudC5zdGFydF06IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBTbmFwU3RhdHVzLnJ1bm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmQ6IGRpc2FibGVkR3VhcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtTbmFwU3RhdHVzLmNyYXNoZWRdOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RhcnRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogU25hcFN0YXR1cy5ydW5uaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb25kOiBkaXNhYmxlZEd1YXJkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuY29uc3QgbmFtZSA9ICdTbmFwQ29udHJvbGxlcic7XG4vKlxuICogQSBzbmFwIGlzIGluaXRpYWxpemVkIGluIHRocmVlIHBoYXNlczpcbiAqIC0gQWRkOiBMb2FkcyB0aGUgc25hcCBmcm9tIGEgcmVtb3RlIHNvdXJjZSBhbmQgcGFyc2VzIGl0LlxuICogLSBBdXRob3JpemU6IFJlcXVlc3RzIHRoZSBzbmFwJ3MgcmVxdWlyZWQgcGVybWlzc2lvbnMgZnJvbSB0aGUgdXNlci5cbiAqIC0gU3RhcnQ6IEluaXRpYWxpemVzIHRoZSBzbmFwIGluIGl0cyBTRVMgcmVhbG0gd2l0aCB0aGUgYXV0aG9yaXplZCBwZXJtaXNzaW9ucy5cbiAqL1xuY2xhc3MgU25hcENvbnRyb2xsZXIgZXh0ZW5kcyBjb250cm9sbGVyc18xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIGNvbnN0cnVjdG9yKHsgY2xvc2VBbGxDb25uZWN0aW9ucywgZXhlY3V0ZVNuYXAsIGdldFJwY01lc3NhZ2VIYW5kbGVyLCBtZXNzZW5nZXIsIHN0YXRlLCB0ZXJtaW5hdGVBbGxTbmFwcywgdGVybWluYXRlU25hcCwgZW5kb3dtZW50UGVybWlzc2lvbk5hbWVzID0gW10sIG5wbVJlZ2lzdHJ5VXJsLCBpZGxlVGltZUNoZWNrSW50ZXJ2YWwgPSA1MDAwLCBtYXhJZGxlVGltZSA9IDMwMDAwLCBtYXhSZXF1ZXN0VGltZSA9IDYwMDAwLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgc25hcEVycm9yczoge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNuYXBTdGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNuYXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3Q6IChzbmFwcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc25hcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc25hcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXApLCB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgdGltZSBzdGF0ZSBpcyByZWh5ZHJhdGVkLCBubyBzbmFwIHdpbGwgYmUgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBTbmFwU3RhdHVzLnN0b3BwZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKG1lbW8sIHNuYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vW3NuYXAuaWRdID0gc25hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jbG9zZUFsbENvbm5lY3Rpb25zID0gY2xvc2VBbGxDb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5fZW5kb3dtZW50UGVybWlzc2lvbk5hbWVzID0gZW5kb3dtZW50UGVybWlzc2lvbk5hbWVzO1xuICAgICAgICB0aGlzLl9leGVjdXRlU25hcCA9IGV4ZWN1dGVTbmFwO1xuICAgICAgICB0aGlzLl9nZXRScGNNZXNzYWdlSGFuZGxlciA9IGdldFJwY01lc3NhZ2VIYW5kbGVyO1xuICAgICAgICB0aGlzLl9vblVuaGFuZGxlZFNuYXBFcnJvciA9IHRoaXMuX29uVW5oYW5kbGVkU25hcEVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uVW5yZXNwb25zaXZlU25hcCA9IHRoaXMuX29uVW5yZXNwb25zaXZlU25hcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGVTbmFwID0gdGVybWluYXRlU25hcDtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlQWxsU25hcHMgPSB0ZXJtaW5hdGVBbGxTbmFwcztcbiAgICAgICAgdGhpcy5faWRsZVRpbWVDaGVja0ludGVydmFsID0gaWRsZVRpbWVDaGVja0ludGVydmFsO1xuICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbWF4SWRsZVRpbWUgPSBtYXhJZGxlVGltZTtcbiAgICAgICAgdGhpcy5fbWF4UmVxdWVzdFRpbWUgPSBtYXhSZXF1ZXN0VGltZTtcbiAgICAgICAgdGhpcy5fcG9sbEZvckxhc3RSZXF1ZXN0U3RhdHVzKCk7XG4gICAgICAgIHRoaXMuX3JwY0hhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NuYXBzQmVpbmdBZGRlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbnBtUmVnaXN0cnlVcmwgPSBucG1SZWdpc3RyeVVybDtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uc3Vic2NyaWJlKCdFeGVjdXRpb25TZXJ2aWNlOnVuaGFuZGxlZEVycm9yJywgdGhpcy5fb25VbmhhbmRsZWRTbmFwRXJyb3IpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5zdWJzY3JpYmUoJ0V4ZWN1dGlvblNlcnZpY2U6dW5yZXNwb25zaXZlJywgdGhpcy5fb25VbnJlc3BvbnNpdmVTbmFwKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHJlZ2lzdGVyaW5nIHRoZSBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtleHBvcnRzLmNvbnRyb2xsZXJOYW1lfTphZGRgLCAoLi4uYXJncykgPT4gdGhpcy5hZGQoLi4uYXJncykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7ZXhwb3J0cy5jb250cm9sbGVyTmFtZX06Z2V0YCwgKC4uLmFyZ3MpID0+IHRoaXMuZ2V0KC4uLmFyZ3MpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2V4cG9ydHMuY29udHJvbGxlck5hbWV9OmdldFJwY01lc3NhZ2VIYW5kbGVyYCwgKC4uLmFyZ3MpID0+IHRoaXMuZ2V0UnBjTWVzc2FnZUhhbmRsZXIoLi4uYXJncykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7ZXhwb3J0cy5jb250cm9sbGVyTmFtZX06Z2V0U25hcFN0YXRlYCwgKC4uLmFyZ3MpID0+IHRoaXMuZ2V0U25hcFN0YXRlKC4uLmFyZ3MpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2V4cG9ydHMuY29udHJvbGxlck5hbWV9Omhhc2AsICguLi5hcmdzKSA9PiB0aGlzLmhhcyguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtleHBvcnRzLmNvbnRyb2xsZXJOYW1lfTp1cGRhdGVTbmFwU3RhdGVgLCAoLi4uYXJncykgPT4gdGhpcy51cGRhdGVTbmFwU3RhdGUoLi4uYXJncykpO1xuICAgIH1cbiAgICBfcG9sbEZvckxhc3RSZXF1ZXN0U3RhdHVzKCkge1xuICAgICAgICB0aGlzLl90aW1lb3V0Rm9yTGFzdFJlcXVlc3RTdGF0dXMgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BTbmFwc0xhc3RSZXF1ZXN0UGFzdE1heCgpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbEZvckxhc3RSZXF1ZXN0U3RhdHVzKCk7XG4gICAgICAgIH0sIHRoaXMuX2lkbGVUaW1lQ2hlY2tJbnRlcnZhbCk7XG4gICAgfVxuICAgIF9zdG9wU25hcHNMYXN0UmVxdWVzdFBhc3RNYXgoKSB7XG4gICAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0TWFwLmZvckVhY2goYXN5bmMgKHRpbWVzdGFtcCwgc25hcElkKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF4SWRsZVRpbWUgJiYgdXRpbHNfMS50aW1lU2luY2UodGltZXN0YW1wKSA+IHRoaXMuX21heElkbGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wU25hcChzbmFwSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uVW5yZXNwb25zaXZlU25hcChzbmFwSWQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblNuYXBTdGF0ZShzbmFwSWQsIFNuYXBTdGF0dXNFdmVudC5jcmFzaCk7XG4gICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBJZCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZFNuYXBFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAtMzIwMDEsXG4gICAgICAgICAgICBtZXNzYWdlOiAnU25hcCBVbnJlc3BvbnNpdmUnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNuYXBJZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25VbmhhbmRsZWRTbmFwRXJyb3Ioc25hcElkLCBlcnJvcikge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBJZCwgU25hcFN0YXR1c0V2ZW50LmNyYXNoKTtcbiAgICAgICAgdGhpcy5fc3RvcFNuYXAoc25hcElkLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYWRkU25hcEVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbnMgYmV0d2VlbiBzdGF0ZXMgdXNpbmcgYHNuYXBTdGF0dXNTdGF0ZU1hY2hpbmVDb25maWdgIGFzIHRoZSB0ZW1wbGF0ZSB0byBmaWd1cmUgb3V0IHRoZSBuZXh0IHN0YXRlLlxuICAgICAqIFRoaXMgdHJhbnNpdGlvbiBmdW5jdGlvbiB1c2VzIGEgdmVyeSBtaW5pbWFsIHN1YnNldCBvZiBYU3RhdGUgY29udmVudGlvbnM6XG4gICAgICogLSBzdXBwb3J0cyBpbml0aWFsIHN0YXRlXG4gICAgICogLSAub24gc3VwcG9ydHMgcmF3IGV2ZW50IHRhcmdldCBzdHJpbmdcbiAgICAgKiAtIC5vbiBzdXBwb3J0cyB7dGFyZ2V0LCBjb25kfSBvYmplY3RcbiAgICAgKiAtIHRoZSBhcmd1bWVudHMgZm9yIGBjb25kYCBpcyB0aGUgYFNlcmlhbGl6ZWRTbmFwYCBpbnN0ZWFkIG9mIFhzdGF0ZSBjb252ZW50aW9uIG9mIGAoZXZlbnQsIGNvbnRleHQpID0+IGJvb2xlYW5gXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcElkIC0gVGhlIGlkIG9mIHRoZSBzbmFwIHRvIHRyYW5zaXRpb25cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgZW51bSB0byB1c2UgdG8gdHJhbnNpdGlvblxuICAgICAqL1xuICAgIF90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBJZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzbmFwU3RhdHVzID0gdGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdLnN0YXR1cztcbiAgICAgICAgbGV0IG5leHRTdGF0dXMgPSAoX2EgPSBzbmFwU3RhdHVzU3RhdGVNYWNoaW5lQ29uZmlnLnN0YXRlc1tzbmFwU3RhdHVzXS5vbltldmVudF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNuYXBTdGF0dXM7XG4gICAgICAgIGlmIChuZXh0U3RhdHVzLmNvbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBuZXh0U3RhdHVzLmNvbmQodGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdKTtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZGl0aW9uIGZhaWxlZCBmb3Igc3RhdGUgdHJhbnNpdGlvbiBcIiR7c25hcElkfVwiIHdpdGggZXZlbnQgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0U3RhdHVzLnRhcmdldCkge1xuICAgICAgICAgICAgbmV4dFN0YXR1cyA9IG5leHRTdGF0dXMudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0U3RhdHVzID09PSBzbmFwU3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwc1tzbmFwSWRdLnN0YXR1cyA9IG5leHRTdGF0dXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGdpdmVuIHNuYXAuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHNuYXAgZXhpc3RzXG4gICAgICogb3IgaWYgaXQgaXMgYWxyZWFkeSBydW5uaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB0byBzdGFydC5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFydFNuYXAoc25hcElkKSB7XG4gICAgICAgIGNvbnN0IHNuYXAgPSB0aGlzLmdldChzbmFwSWQpO1xuICAgICAgICBpZiAoIXNuYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcElkfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBJZH1cIiBpcyBkaXNhYmxlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFNuYXAoe1xuICAgICAgICAgICAgc25hcElkLFxuICAgICAgICAgICAgc291cmNlQ29kZTogc25hcC5zb3VyY2VDb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgZ2l2ZW4gc25hcC4gQSBzbmFwIGNhbiBvbmx5IGJlIHN0YXJ0ZWQgaWYgaXQgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwSWQgLSBUaGUgaWQgb2YgdGhlIFNuYXAgdG8gZW5hYmxlLlxuICAgICAqL1xuICAgIGVuYWJsZVNuYXAoc25hcElkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcHNbc25hcElkXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBnaXZlbiBzbmFwLiBBIHNuYXAgY2FuIG9ubHkgYmUgc3RhcnRlZCBpZiBpdCBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB0byBkaXNhYmxlLlxuICAgICAqL1xuICAgIGRpc2FibGVTbmFwKHNuYXBJZCkge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoc25hcElkKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wU25hcChzbmFwSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcHNbc25hcElkXS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgZ2l2ZW4gc25hcC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggc25hcCBleGlzdHNcbiAgICAgKiBvciBpZiBpdCBpcyBhbHJlYWR5IHN0b3BwZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcElkIC0gVGhlIGlkIG9mIHRoZSBTbmFwIHRvIHN0b3AuXG4gICAgICovXG4gICAgc3RvcFNuYXAoc25hcElkKSB7XG4gICAgICAgIGNvbnN0IHNuYXAgPSB0aGlzLmdldChzbmFwSWQpO1xuICAgICAgICBpZiAoIXNuYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcElkfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKHNuYXBJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcElkfVwiIGFscmVhZHkgc3RvcHBlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwSWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU25hcCBcIiR7c25hcElkfVwiIHN0b3BwZWQuYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBnaXZlbiBzbmFwLCByZW1vdmVzIGFsbCBob29rcywgY2xvc2VzIGFsbCBjb25uZWN0aW9ucywgYW5kXG4gICAgICogdGVybWluYXRlcyBpdHMgd29ya2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB0byBzdG9wLlxuICAgICAqIEBwYXJhbSBzZXROb3RSdW5uaW5nIC0gV2hldGhlciB0byBtYXJrIHRoZSBzbmFwIGFzIG5vdCBydW5uaW5nLlxuICAgICAqIFNob3VsZCBvbmx5IGJlIHNldCB0byBmYWxzZSBpZiB0aGUgc25hcCBpcyBhYm91dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIF9zdG9wU25hcChzbmFwSWQsIHNldE5vdFJ1bm5pbmcgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0TWFwLmRlbGV0ZShzbmFwSWQpO1xuICAgICAgICB0aGlzLl9jbG9zZUFsbENvbm5lY3Rpb25zKHNuYXBJZCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVNuYXAoc25hcElkKTtcbiAgICAgICAgaWYgKHNldE5vdFJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TbmFwU3RhdGUoc25hcElkLCBTbmFwU3RhdHVzRXZlbnQuc3RvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzbmFwIGlzIHJ1bm5pbmcuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzbmFwIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcElkIC0gVGhlIGlkIG9mIHRoZSBTbmFwIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIGlzUnVubmluZyhzbmFwSWQpIHtcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0KHNuYXBJZCk7XG4gICAgICAgIGlmICghc25hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwSWR9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbmFwLnN0YXR1cyA9PT0gU25hcFN0YXR1cy5ydW5uaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHNuYXAgaGFzIGJlZW4gYWRkZWQgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcElkIC0gVGhlIGlkIG9mIHRoZSBTbmFwIHRvIGNoZWNrIGZvci5cbiAgICAgKi9cbiAgICBoYXMoc25hcElkKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0KHNuYXBJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzbmFwIHdpdGggdGhlIGdpdmVuIGlkIGlmIGl0IGV4aXN0cywgaW5jbHVkaW5nIGFsbCBkYXRhLlxuICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIGlmIHRoZSBzbmFwIGlzIHRvIGJlIHNlcmlhbGl6YWJsZSwgYXMgZS5nLlxuICAgICAqIHRoZSBzbmFwIHNvdXJjZUNvZGUgbWF5IGJlIHF1aXRlIGxhcmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB0byBnZXQuXG4gICAgICovXG4gICAgZ2V0KHNuYXBJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzbmFwIHdpdGggdGhlIGdpdmVuIGlkIGlmIGl0IGV4aXN0cywgZXhjbHVkaW5nIGFueVxuICAgICAqIG5vbi1zZXJpYWxpemFibGUgb3IgZXhwZW5zaXZlLXRvLXNlcmlhbGl6ZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB0byBnZXQuXG4gICAgICovXG4gICAgZ2V0VHJ1bmNhdGVkKHNuYXBJZCkge1xuICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXQoc25hcElkKTtcbiAgICAgICAgcmV0dXJuIHNuYXBcbiAgICAgICAgICAgID8gT2JqZWN0LmtleXMoc25hcCkucmVkdWNlKChzZXJpYWxpemVkLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoVFJVTkNBVEVEX1NOQVBfUFJPUEVSVElFUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBzbmFwW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG93biBzdGF0ZSBvZiB0aGUgc25hcCB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICAgKiBUaGlzIGlzIGRpc3RpbmN0IGZyb20gdGhlIHN0YXRlIE1ldGFNYXNrIHVzZXMgdG8gbWFuYWdlIHNuYXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB3aG9zZSBzdGF0ZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0gbmV3U25hcFN0YXRlIC0gVGhlIG5ldyBzdGF0ZSBvZiB0aGUgc25hcC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTbmFwU3RhdGUoc25hcElkLCBuZXdTbmFwU3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwU3RhdGVzW3NuYXBJZF0gPSBuZXdTbmFwU3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGVycm9yIGZyb20gYSBzbmFwIHRvIHRoZSBTbmFwQ29udHJvbGxlcnMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcEVycm9yIC0gVGhlIGVycm9yIHRvIHN0b3JlIG9uIHRoZSBTbmFwQ29udHJvbGxlclxuICAgICAqL1xuICAgIGFzeW5jIGFkZFNuYXBFcnJvcihzbmFwRXJyb3IpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpO1xuICAgICAgICAgICAgc3RhdGUuc25hcEVycm9yc1tpZF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXBFcnJvciksIHsgaW50ZXJuYWxJRDogaWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGVycm9yIGJ5IGludGVybmFsSUQgZnJvbSBhIHRoZSBTbmFwQ29udHJvbGxlcnMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxJRCAtIFRoZSBpbnRlcm5hbCBlcnJvciBJRCB0byByZW1vdmUgb24gdGhlIFNuYXBDb250cm9sbGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlU25hcEVycm9yKGludGVybmFsSUQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuc25hcEVycm9yc1tpbnRlcm5hbElEXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZXJyb3JzIGZyb20gdGhlIFNuYXBDb250cm9sbGVycyBzdGF0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyU25hcEVycm9ycygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwRXJyb3JzID0ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvd24gc3RhdGUgb2YgdGhlIHNuYXAgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICogVGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBzdGF0ZSBNZXRhTWFzayB1c2VzIHRvIG1hbmFnZSBzbmFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwSWQgLSBUaGUgaWQgb2YgdGhlIFNuYXAgd2hvc2Ugc3RhdGUgdG8gZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNuYXBTdGF0ZShzbmFwSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdGF0ZS5zbmFwU3RhdGVzW3NuYXBJZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlbHkgY2xlYXIgdGhlIGNvbnRyb2xsZXIncyBzdGF0ZTogZGVsZXRlIGFsbCBhc3NvY2lhdGVkIGRhdGEsXG4gICAgICogaGFuZGxlcnMsIGV2ZW50IGxpc3RlbmVycywgYW5kIHBlcm1pc3Npb25zOyB0ZWFyIGRvd24gYWxsIHNuYXAgcHJvdmlkZXJzLlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNuYXBJZHMgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnNuYXBzKTtcbiAgICAgICAgc25hcElkcy5mb3JFYWNoKChzbmFwSWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQWxsQ29ubmVjdGlvbnMoc25hcElkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZUFsbFNuYXBzKCk7XG4gICAgICAgIHNuYXBJZHMuZm9yRWFjaCgoc25hcElkKSA9PiB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdQZXJtaXNzaW9uQ29udHJvbGxlcjpyZXZva2VBbGxQZXJtaXNzaW9ucycsIHNuYXBJZCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBzID0ge307XG4gICAgICAgICAgICBzdGF0ZS5zbmFwU3RhdGVzID0ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzbmFwIGZyb20gc3RhdGUsIGFuZCBjbGVhcnMgYWxsIGFzc29jaWF0ZWQgaGFuZGxlcnNcbiAgICAgKiBhbmQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcC5cbiAgICAgKi9cbiAgICByZW1vdmVTbmFwKHNuYXBJZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNuYXBzKFtzbmFwSWRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGdpdmVuIHNuYXBzLCByZW1vdmVzIHRoZW0gZnJvbSBzdGF0ZSwgYW5kIGNsZWFycyBhbGwgYXNzb2NpYXRlZFxuICAgICAqIHBlcm1pc3Npb25zLCBoYW5kbGVycywgYW5kIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwSWRzIC0gVGhlIGlkcyBvZiB0aGUgU25hcHMuXG4gICAgICovXG4gICAgcmVtb3ZlU25hcHMoc25hcElkcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc25hcElkcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYXJyYXkgb2Ygc25hcCBpZHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzbmFwSWRzLmZvckVhY2goKHNuYXBJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBJZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JwY0hhbmRsZXJNYXAuZGVsZXRlKHNuYXBJZCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnNuYXBzW3NuYXBJZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnNuYXBTdGF0ZXNbc25hcElkXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5wdWJsaXNoKGBTbmFwQ29udHJvbGxlcjpzbmFwUmVtb3ZlZGAsIHNuYXBJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNuYXBJZHMuZm9yRWFjaCgoc25hcElkKSA9PiB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdQZXJtaXNzaW9uQ29udHJvbGxlcjpyZXZva2VBbGxQZXJtaXNzaW9ucycsIHNuYXBJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXJpYWxpemVkIHBlcm1pdHRlZCBzbmFwcyBvZiB0aGUgZ2l2ZW4gb3JpZ2luLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgcGVybWl0dGVkIHNuYXBzIHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldFBlcm1pdHRlZFNuYXBzKG9yaWdpbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKChfYSA9IHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ1Blcm1pc3Npb25Db250cm9sbGVyOmdldFBlcm1pc3Npb25zJywgb3JpZ2luKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLnJlZHVjZSgocGVybWl0dGVkU25hcHMsIHBlcm0pID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJtLnBhcmVudENhcGFiaWxpdHkuc3RhcnRzV2l0aChleHBvcnRzLlNOQVBfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBJZCA9IHBlcm0ucGFyZW50Q2FwYWJpbGl0eS5yZXBsYWNlKGV4cG9ydHMuU05BUF9QUkVGSVhfUkVHRVgsICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXRUcnVuY2F0ZWQoc25hcElkKTtcbiAgICAgICAgICAgICAgICBwZXJtaXR0ZWRTbmFwc1tzbmFwSWRdID0gc25hcCB8fCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBldGhfcnBjX2Vycm9yc18xLnNlcmlhbGl6ZUVycm9yKG5ldyBFcnJvcignU25hcCBwZXJtaXR0ZWQgYnV0IG5vdCBpbnN0YWxsZWQuJykpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGVybWl0dGVkU25hcHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFsbHMgdGhlIHNuYXBzIHJlcXVlc3RlZCBieSB0aGUgZ2l2ZW4gb3JpZ2luLCByZXR1cm5pbmcgdGhlIHNuYXBcbiAgICAgKiBvYmplY3QgaWYgdGhlIG9yaWdpbiBpcyBwZXJtaXR0ZWQgdG8gaW5zdGFsbCBpdCwgYW5kIGFuIGF1dGhvcml6YXRpb24gZXJyb3JcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0aGF0IHJlcXVlc3RlZCB0byBpbnN0YWxsIHRoZSBzbmFwcy5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdGVkU25hcHMgLSBUaGUgc25hcHMgdG8gaW5zdGFsbC5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgb2Ygc25hcCBpZHMgYW5kIHNuYXAgb2JqZWN0cywgb3IgZXJyb3JzIGlmIGFcbiAgICAgKiBzbmFwIGNvdWxkbid0IGJlIGluc3RhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnN0YWxsU25hcHMob3JpZ2luLCByZXF1ZXN0ZWRTbmFwcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMocmVxdWVzdGVkU25hcHMpLm1hcChhc3luYyAoW3NuYXBJZCwgeyB2ZXJzaW9uID0gJ2xhdGVzdCcgfV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25OYW1lID0gZXhwb3J0cy5TTkFQX1BSRUZJWCArIHNuYXBJZDtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFNuYXBWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3NuYXBJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgVGhlIFwidmVyc2lvblwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBTZW1WZXIgdmVyc2lvbiBvciB0aGUgc3RyaW5nIFwibGF0ZXN0XCIgaWYgc3BlY2lmaWVkLiBSZWNlaXZlZDogXCIke3ZlcnNpb259XCIuYCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnUGVybWlzc2lvbkNvbnRyb2xsZXI6aGFzUGVybWlzc2lvbicsIG9yaWdpbiwgcGVybWlzc2lvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBpbnN0YWxsIGFuZCBydW4gdGhlIHNuYXAsIHN0b3JpbmcgYW55IGVycm9ycyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gb2NjdXIgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtzbmFwSWRdID0gT2JqZWN0LmFzc2lnbih7fSwgKGF3YWl0IHRoaXMucHJvY2Vzc1JlcXVlc3RlZFNuYXAoc25hcElkLCB2ZXJzaW9uKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyB0aGUgaW5zdGFsbGF0aW9uIG9mIHBlcm1pdHRlZCBzbmFwc1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzbmFwSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKGBOb3QgYXV0aG9yaXplZCB0byBpbnN0YWxsIHNuYXAgXCIke3NuYXBJZH1cIi4gUmVxdWVzdCB0aGUgcGVybWlzc2lvbiBmb3IgdGhlIHNuYXAgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW5zdGFsbCBpdC5gKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMsIGF1dGhvcml6ZXMsIGFuZCBydW5zIHRoZSBnaXZlbiBzbmFwIHdpdGggYSBzbmFwIHByb3ZpZGVyLlxuICAgICAqIFJlc3VsdHMgZnJvbSB0aGlzIG1ldGhvZCBzaG91bGQgYmUgZWZmaWNpZW50bHkgc2VyaWFsaXphYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgc25hcC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBzbmFwIHRvIGluc3RhbGwuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBzbmFwIG9iamVjdCwgb3IgYW4gZXJyb3IgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1JlcXVlc3RlZFNuYXAoc25hcElkLCB2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcCA9IHRoaXMuZ2V0VHJ1bmNhdGVkKHNuYXBJZCk7XG4gICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1NuYXA7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlQ29kZSB9ID0gYXdhaXQgdGhpcy5hZGQoe1xuICAgICAgICAgICAgICAgIGlkOiBzbmFwSWQsXG4gICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRob3JpemUoc25hcElkKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0U25hcCh7XG4gICAgICAgICAgICAgICAgc25hcElkLFxuICAgICAgICAgICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnB1Ymxpc2goYFNuYXBDb250cm9sbGVyOnNuYXBJbnN0YWxsZWRgLCBzbmFwSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJ1bmNhdGVkKHNuYXBJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBhZGRpbmcgc25hcC5gLCBlcnIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKHNuYXBJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNuYXAoc25hcElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBldGhfcnBjX2Vycm9yc18xLnNlcmlhbGl6ZUVycm9yKGVycikgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIGNvbXBsZXRlIGluc3RhbGxhdGlvbiBvZiB0aGUgcmVxdWVzdGVkIHNuYXAuXG4gICAgICogSWYgdGhlIHNuYXAgaXMgYWxyZWFkeSBiZWluZyBpbnN0YWxsZWQsIHRoZSBwcmV2aW91c2x5IHBlbmRpbmcgcHJvbWlzZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIE9iamVjdCBjb250YWluaW5nIGVpdGhlciB0aGUgVVJMIG9mIHRoZSBzbmFwJ3MgbWFuaWZlc3QsXG4gICAgICogb3IgdGhlIHNuYXAncyBtYW5pZmVzdCBhbmQgc291cmNlIGNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBzbmFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBhZGQoYXJncykge1xuICAgICAgICBjb25zdCB7IGlkOiBfc25hcElkIH0gPSBhcmdzO1xuICAgICAgICB0aGlzLnZhbGlkYXRlU25hcElkKF9zbmFwSWQpO1xuICAgICAgICBjb25zdCBzbmFwSWQgPSBfc25hcElkO1xuICAgICAgICBpZiAoIWFyZ3MgfHxcbiAgICAgICAgICAgICEoJ2lkJyBpbiBhcmdzKSB8fFxuICAgICAgICAgICAgKCEoJ21hbmlmZXN0JyBpbiBhcmdzKSAmJiAnc291cmNlQ29kZScgaW4gYXJncykgfHxcbiAgICAgICAgICAgICgnbWFuaWZlc3QnIGluIGFyZ3MgJiYgISgnc291cmNlQ29kZScgaW4gYXJncykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWRkIHNuYXAgYXJncyBmb3Igc25hcCBcIiR7c25hcElkfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fc25hcHNCZWluZ0FkZGVkLmhhcyhzbmFwSWQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIHNuYXA6ICR7c25hcElkfWApO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNCZWluZ0FkZGVkLnNldChzbmFwSWQsIHRoaXMuX2FkZChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzQmVpbmdBZGRlZC5nZXQoc25hcElkKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTbmFwSWQoc25hcElkKSB7XG4gICAgICAgIGlmICghc25hcElkIHx8IHR5cGVvZiBzbmFwSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc25hcCBpZDogTm90IGEgc3RyaW5nLiBSZWNlaXZlZCBcIiR7c25hcElkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgT2JqZWN0LnZhbHVlcyh1dGlsc18yLlNuYXBJZFByZWZpeGVzKSkge1xuICAgICAgICAgICAgaWYgKHNuYXBJZC5zdGFydHNXaXRoKHByZWZpeCkgJiYgc25hcElkLnJlcGxhY2UocHJlZml4LCAnJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc25hcCBpZC4gUmVjZWl2ZWQ6IFwiJHtzbmFwSWR9XCJgKTtcbiAgICB9XG4gICAgYXN5bmMgX3N0YXJ0U25hcChzbmFwRGF0YSkge1xuICAgICAgICBjb25zdCB7IHNuYXBJZCB9ID0gc25hcERhdGE7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZyhzbmFwSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBJZH1cIiBpcyBhbHJlYWR5IHN0YXJ0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZXhlY3V0ZVNuYXAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbmFwRGF0YSksIHsgZW5kb3dtZW50czogYXdhaXQgdGhpcy5fZ2V0RW5kb3dtZW50cyhzbmFwSWQpIH0pKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblNuYXBTdGF0ZShzbmFwSWQsIFNuYXBTdGF0dXNFdmVudC5zdGFydCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWVzIG9mIGFsbCBlbmRvd21lbnRzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgU25hcCdzXG4gICAgICogQ29tcGFydG1lbnQgd2hlbiBpdCBleGVjdXRlcy4gVGhlc2Ugc2hvdWxkIGJlIHRoZSBuYW1lcyBvZiBnbG9iYWxcbiAgICAgKiBKYXZhU2NyaXB0IEFQSXMgYWNjZXNzaWJsZSBpbiB0aGUgcm9vdCByZWFsbSBvZiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBlbmRvd21lbnQgZ2V0dGVyIGZvciBhIHBlcm1pc3Npb24gcmV0dXJucyBhIHRydXRoeVxuICAgICAqIHZhbHVlIHRoYXQgaXMgbm90IGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcElkIC0gVGhlIGlkIG9mIHRoZSBzbmFwIHdob3NlIFNFUyBlbmRvd21lbnRzIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgdGhlIGVuZG93bWVudHMsIGlmIGFueS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0RW5kb3dtZW50cyhzbmFwSWQpIHtcbiAgICAgICAgbGV0IGFsbEVuZG93bWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwZXJtaXNzaW9uTmFtZSBvZiB0aGlzLl9lbmRvd21lbnRQZXJtaXNzaW9uTmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdQZXJtaXNzaW9uQ29udHJvbGxlcjpoYXNQZXJtaXNzaW9uJywgc25hcElkLCBwZXJtaXNzaW9uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRvd21lbnRzID0gYXdhaXQgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnUGVybWlzc2lvbkNvbnRyb2xsZXI6Z2V0RW5kb3dtZW50cycsIHNuYXBJZCwgcGVybWlzc2lvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRvd21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IGd1YXJhbnRlZXMgYWJvdXQgdGhlIHR5cGUgb2YgdGhlIGVuZG93bWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUsIHNvIHdlIGhhdmUgdG8gZ3VhcmQgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVuZG93bWVudHMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRvd21lbnRzLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSBvZiBzdHJpbmcgZW5kb3dtZW50IG5hbWVzLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFsbEVuZG93bWVudHMgPSBhbGxFbmRvd21lbnRzLmNvbmNhdChlbmRvd21lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbEVuZG93bWVudHMubGVuZ3RoID4gMCA/IGFsbEVuZG93bWVudHMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZC4gU2VlIHRoZSBcImFkZFwiIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwSWQgLSBUaGUgaWQgb2YgdGhlIFNuYXAuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYWRkIHNuYXAgYXJncy5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIHNuYXAgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIF9hZGQoYXJncykge1xuICAgICAgICBjb25zdCB7IGlkOiBzbmFwSWQsIHZlcnNpb24gfSA9IGFyZ3M7XG4gICAgICAgIGxldCBtYW5pZmVzdCwgc291cmNlQ29kZSwgc3ZnSWNvbjtcbiAgICAgICAgaWYgKCdtYW5pZmVzdCcgaW4gYXJncykge1xuICAgICAgICAgICAgbWFuaWZlc3QgPSBhcmdzLm1hbmlmZXN0O1xuICAgICAgICAgICAgc291cmNlQ29kZSA9IGFyZ3Muc291cmNlQ29kZTtcbiAgICAgICAgICAgIGpzb25fc2NoZW1hc18xLnZhbGlkYXRlU25hcEpzb25GaWxlKHV0aWxzXzIuTnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdCwgbWFuaWZlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgbWFuaWZlc3QsIHNvdXJjZUNvZGUsIHN2Z0ljb24gfSA9IGF3YWl0IHRoaXMuX2ZldGNoU25hcChzbmFwSWQsIHZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUNvZGUgIT09ICdzdHJpbmcnIHx8IHNvdXJjZUNvZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc291cmNlIGNvZGUgZm9yIHNuYXAgXCIke3NuYXBJZH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUGVybWlzc2lvbnMgPSBtYW5pZmVzdCA9PT0gbnVsbCB8fCBtYW5pZmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFuaWZlc3QuaW5pdGlhbFBlcm1pc3Npb25zO1xuICAgICAgICBpZiAoIWluaXRpYWxQZXJtaXNzaW9ucyB8fFxuICAgICAgICAgICAgdHlwZW9mIGluaXRpYWxQZXJtaXNzaW9ucyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoaW5pdGlhbFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluaXRpYWwgcGVybWlzc2lvbnMgZm9yIHNuYXAgXCIke3NuYXBJZH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc25hcCA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc25hcElkLFxuICAgICAgICAgICAgaW5pdGlhbFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgICBwZXJtaXNzaW9uTmFtZTogZXhwb3J0cy5TTkFQX1BSRUZJWCArIHNuYXBJZCxcbiAgICAgICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgICAgICBzdGF0dXM6IHNuYXBTdGF0dXNTdGF0ZU1hY2hpbmVDb25maWcuaW5pdGlhbCxcbiAgICAgICAgICAgIHZlcnNpb246IG1hbmlmZXN0LnZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNuYXBzU3RhdGUgPSB0aGlzLnN0YXRlLnNuYXBzO1xuICAgICAgICAvLyByZXN0b3JlIHJlbGV2YW50IHNuYXAgc3RhdGUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmIChzbmFwc1N0YXRlW3NuYXBJZF0pIHtcbiAgICAgICAgICAgIHNuYXAgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXBzU3RhdGVbc25hcElkXSksIHNuYXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRoZSBzbmFwIGJhY2sgaW4gc3RhdGVcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwc1tzbmFwSWRdID0gc25hcDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnB1Ymxpc2goYFNuYXBDb250cm9sbGVyOnNuYXBBZGRlZGAsIHNuYXBJZCwgc25hcCwgc3ZnSWNvbik7XG4gICAgICAgIHJldHVybiBzbmFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBtYW5pZmVzdCBhbmQgc291cmNlIGNvZGUgb2YgYSBzbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBTbmFwIHRvIGZldGNoLlxuICAgICAqIEByZXR1cm5zIEEgdHVwbGUgb2YgdGhlIFNuYXAgbWFuaWZlc3Qgb2JqZWN0IGFuZCB0aGUgU25hcCBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBhc3luYyBfZmV0Y2hTbmFwKHNuYXBJZCwgdmVyc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNuYXBJZC5zdGFydHNXaXRoKHV0aWxzXzIuU25hcElkUHJlZml4ZXMubG9jYWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTG9jYWxTbmFwKHNuYXBJZC5yZXBsYWNlKHV0aWxzXzIuU25hcElkUHJlZml4ZXMubG9jYWwsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzbmFwSWQuc3RhcnRzV2l0aCh1dGlsc18yLlNuYXBJZFByZWZpeGVzLm5wbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hOcG1TbmFwKHNuYXBJZC5yZXBsYWNlKHV0aWxzXzIuU25hcElkUHJlZml4ZXMubnBtLCAnJyksIHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgU25hcCBpZDogXCIke3NuYXBJZH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggU25hcCBcIiR7c25hcElkfVwiOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2ZldGNoTnBtU25hcChwYWNrYWdlTmFtZSwgdmVyc2lvbikge1xuICAgICAgICBpZiAoIWlzVmFsaWRTbmFwVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBpbnZhbGlkIFNuYXAgdmVyc2lvbjogXCIke3ZlcnNpb259XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtYW5pZmVzdCwgc291cmNlQ29kZSwgc3ZnSWNvbiB9ID0gYXdhaXQgdXRpbHNfMi5mZXRjaE5wbVNuYXAocGFja2FnZU5hbWUsIHZlcnNpb24sIHRoaXMuX25wbVJlZ2lzdHJ5VXJsKTtcbiAgICAgICAgcmV0dXJuIHsgbWFuaWZlc3QsIHNvdXJjZUNvZGUsIHN2Z0ljb24gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbWFuaWZlc3QgYW5kIHNvdXJjZSBjb2RlIG9mIGEgbG9jYWwgc25hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGhvc3RVcmwgLSBUaGUgbG9jYWxob3N0IFVSTCB0byBkb3dubG9hZCBmcm9tLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0ZWQgbWFuaWZlc3QgYW5kIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBhc3luYyBfZmV0Y2hMb2NhbFNuYXAobG9jYWxob3N0VXJsKSB7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0VXJsID0gbmV3IFVSTCh1dGlsc18yLk5wbVNuYXBGaWxlTmFtZXMuTWFuaWZlc3QsIGxvY2FsaG9zdFVybCk7XG4gICAgICAgIGlmICghdXRpbHNfMi5MT0NBTEhPU1RfSE9TVE5BTUVTLmhhcyhtYW5pZmVzdFVybC5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6IExvY2FsbHkgaG9zdGVkIFNuYXBzIG11c3QgYmUgaG9zdGVkIG9uIGxvY2FsaG9zdC4gUmVjZWl2ZWQgVVJMOiBcIiR7bWFuaWZlc3RVcmwudG9TdHJpbmcoKX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9tYW5pZmVzdCA9IGF3YWl0IHV0aWxzXzIuZmV0Y2hDb250ZW50KG1hbmlmZXN0VXJsLCAnanNvbicpO1xuICAgICAgICBqc29uX3NjaGVtYXNfMS52YWxpZGF0ZVNuYXBKc29uRmlsZSh1dGlsc18yLk5wbVNuYXBGaWxlTmFtZXMuTWFuaWZlc3QsIF9tYW5pZmVzdCk7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gX21hbmlmZXN0O1xuICAgICAgICBjb25zdCB7IHNvdXJjZTogeyBsb2NhdGlvbjogeyBucG06IHsgZmlsZVBhdGgsIGljb25QYXRoIH0sIH0sIH0sIH0gPSBtYW5pZmVzdDtcbiAgICAgICAgY29uc3QgW3NvdXJjZUNvZGUsIHN2Z0ljb25dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdXRpbHNfMi5mZXRjaENvbnRlbnQobmV3IFVSTChmaWxlUGF0aCwgbG9jYWxob3N0VXJsKSwgJ3RleHQnKSxcbiAgICAgICAgICAgIGljb25QYXRoXG4gICAgICAgICAgICAgICAgPyB1dGlsc18yLmZldGNoQ29udGVudChuZXcgVVJMKGljb25QYXRoLCBsb2NhbGhvc3RVcmwpLCAndGV4dCcpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIF0pO1xuICAgICAgICB1dGlsc18yLnZhbGlkYXRlU25hcFNoYXN1bShtYW5pZmVzdCwgc291cmNlQ29kZSk7XG4gICAgICAgIHJldHVybiB7IG1hbmlmZXN0LCBzb3VyY2VDb2RlLCBzdmdJY29uIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIHJlcXVlc3QgZm9yIHRoZSBnaXZlbiBzbmFwJ3MgaW5pdGlhbCBwZXJtaXNzaW9ucy5cbiAgICAgKiBNdXN0IGJlIGNhbGxlZCBpbiBvcmRlci4gU2VlIHByb2Nlc3NSZXF1ZXN0ZWRTbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc25hcCdzIGFwcHJvdmVkUGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgYXN5bmMgYXV0aG9yaXplKHNuYXBJZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQXV0aG9yaXppbmcgc25hcDogJHtzbmFwSWR9YCk7XG4gICAgICAgIGNvbnN0IHNuYXBzU3RhdGUgPSB0aGlzLnN0YXRlLnNuYXBzO1xuICAgICAgICBjb25zdCBzbmFwID0gc25hcHNTdGF0ZVtzbmFwSWRdO1xuICAgICAgICBjb25zdCB7IGluaXRpYWxQZXJtaXNzaW9ucyB9ID0gc25hcDtcbiAgICAgICAgLy8gRG9uJ3QgcHJvbXB0IGlmIHRoZXJlIGFyZSBubyBwZXJtaXNzaW9ucyByZXF1ZXN0ZWQ6XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpbml0aWFsUGVybWlzc2lvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsUGVybWlzc2lvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW2FwcHJvdmVkUGVybWlzc2lvbnNdID0gYXdhaXQgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnUGVybWlzc2lvbkNvbnRyb2xsZXI6cmVxdWVzdFBlcm1pc3Npb25zJywgeyBvcmlnaW46IHNuYXBJZCB9LCBpbml0aWFsUGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYXBwcm92ZWRQZXJtaXNzaW9ucykubWFwKChwZXJtKSA9PiBwZXJtLnBhcmVudENhcGFiaWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNCZWluZ0FkZGVkLmRlbGV0ZShzbmFwSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXRGb3JMYXN0UmVxdWVzdFN0YXR1cykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRGb3JMYXN0UmVxdWVzdFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0udW5zdWJzY3JpYmUoJ0V4ZWN1dGlvblNlcnZpY2U6dW5oYW5kbGVkRXJyb3InLCB0aGlzLl9vblVuaGFuZGxlZFNuYXBFcnJvcik7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnVuc3Vic2NyaWJlKCdFeGVjdXRpb25TZXJ2aWNlOnVucmVzcG9uc2l2ZScsIHRoaXMuX29uVW5yZXNwb25zaXZlU25hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJQQyBtZXNzYWdlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBzbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB3aG9zZSBtZXNzYWdlIGhhbmRsZXIgdG8gZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBJZCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0hhbmRsZXIgPSB0aGlzLl9ycGNIYW5kbGVyTWFwLmdldChzbmFwSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmdIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdIYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJwY0hhbmRsZXIgPSBhc3luYyAob3JpZ2luLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IGF3YWl0IHRoaXMuX2dldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBJZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwSWR9XCIgaXMgZGlzYWJsZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zbmFwc1tzbmFwSWRdLnN0YXR1cyA9PT0gU25hcFN0YXR1cy5pbnN0YWxsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwSWR9XCIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyICYmIHRoaXMuaXNSdW5uaW5nKHNuYXBJZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sZCBzdGFydFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhcnRTbmFwKHNuYXBJZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGF3YWl0IHRoaXMuX2dldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgZXhlY3V0aW9uIHNlcnZpY2UgcmV0dXJuZWQgbm8gUlBDIGhhbmRsZXIgZm9yIHJ1bm5pbmcgc25hcCBcIiR7c25hcElkfVwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVjb3JkU25hcFJwY1JlcXVlc3Qoc25hcElkKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtYXggcmVxdWVzdCB0aW1lXG4gICAgICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IHRpbWVkIG91dC4nKSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5fbWF4UmVxdWVzdFRpbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIGdldCB0aGUgcmVzdWx0IG9yIHJlamVjdCBkdWUgdG8gdGhlIHRpbWVvdXQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIGhhbmRsZXIob3JpZ2luLCByZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcnBjSGFuZGxlck1hcC5zZXQoc25hcElkLCBycGNIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHJwY0hhbmRsZXI7XG4gICAgfVxuICAgIF9yZWNvcmRTbmFwUnBjUmVxdWVzdChzbmFwSWQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RNYXAuc2V0KHNuYXBJZCwgRGF0ZS5ub3coKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TbmFwQ29udHJvbGxlciA9IFNuYXBDb250cm9sbGVyO1xuZnVuY3Rpb24gaXNWYWxpZFNuYXBWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKHZlcnNpb24gPT09ICdsYXRlc3QnIHx8IHZhbGlkXzEuZGVmYXVsdCh2ZXJzaW9uKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U25hcENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlU25hcEpzb25GaWxlID0gdm9pZCAwO1xuY29uc3QgdmFsaWRhdGVOcG1TbmFwUGFja2FnZUpzb25fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZU5wbVNuYXBQYWNrYWdlSnNvbi5qc1wiKSk7XG5jb25zdCB2YWxpZGF0ZVNuYXBNYW5pZmVzdF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlU25hcE1hbmlmZXN0LmpzXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNuYXAgSlNPTiBmaWxlLiBUaHJvd3MgYSBodW1hbi1yZWFkYWJsZSBsaXN0IG9mIGVycm9ycyBpZlxuICogdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gZmlsZU5hbWUgLSBUaGUgbmFtZSBvZiBTbmFwIEpTT04gZmlsZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNuYXBKc29uRmlsZShmaWxlTmFtZSwgY29udGVudCkge1xuICAgIGxldCBlcnJvcnM7XG4gICAgc3dpdGNoIChmaWxlTmFtZSkge1xuICAgICAgICBjYXNlIHV0aWxzXzEuTnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdDpcbiAgICAgICAgICAgIGlmIChjb250ZW50ICYmIHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnJlcG9zaXRvcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIGFsbG93IGNvbnN1bWVycyB0byBvbWl0IHRoaXMgZmllbGQuIFdlIGNhbm5vdCBvbWl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGludGVybmFsbHkgZHVlIHRvIFRTQDw0LjQgbGltaXRhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucmVwb3NpdG9yeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVTbmFwTWFuaWZlc3RfanNfMS5kZWZhdWx0KGNvbnRlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdXRpbHNfMS5OcG1TbmFwRmlsZU5hbWVzLlBhY2thZ2VKc29uOlxuICAgICAgICAgICAgZXJyb3JzID0gdmFsaWRhdGVOcG1TbmFwUGFja2FnZUpzb25fanNfMS5kZWZhdWx0KGNvbnRlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBmaWxlIG5hbWUgXCIke2ZpbGVOYW1lfVwiLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9ycy5yZWR1Y2UoKGFsbEVycm9ycywgZXJyb3JPYmplY3QgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbnN0YW5jZVBhdGgsIG1lc3NhZ2UgPSAndW5rbm93biBlcnJvcicgfSA9IGVycm9yT2JqZWN0O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0cmluZyA9IGluc3RhbmNlUGF0aFxuICAgICAgICAgICAgICAgID8gYFxcdCR7aW5zdGFuY2VQYXRofVxcblxcdCR7bWVzc2FnZX1cXG5cXG5gXG4gICAgICAgICAgICAgICAgOiBgXFx0JHttZXNzYWdlfVxcblxcbmA7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWxsRXJyb3JzfSR7Y3VycmVudFN0cmluZ31gO1xuICAgICAgICB9LCAnJykucmVwbGFjZSgvXFxuJC91LCAnJyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNuYXBKc29uRmlsZSA9IHZhbGlkYXRlU25hcEpzb25GaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlU25hcFNoYXN1bSA9IGV4cG9ydHMudmFsaWRhdGVOcG1TbmFwTWFuaWZlc3QgPSBleHBvcnRzLnZhbGlkYXRlTnBtU25hcCA9IGV4cG9ydHMuUHJvZ3JhbW1hdGljYWxseUZpeGFibGVTbmFwRXJyb3IgPSBleHBvcnRzLlNuYXBWYWxpZGF0aW9uRmFpbHVyZVJlYXNvbiA9IGV4cG9ydHMuZmV0Y2hOcG1TbmFwID0gZXhwb3J0cy5nZXRTbmFwU291cmNlU2hhc3VtID0gZXhwb3J0cy5mZXRjaENvbnRlbnQgPSBleHBvcnRzLlBST1BPU0VEX05BTUVfUkVHRVggPSBleHBvcnRzLkRFRkFVTFRfTlBNX1JFR0lTVFJZID0gZXhwb3J0cy5MT0NBTEhPU1RfSE9TVE5BTUVTID0gZXhwb3J0cy5OcG1TbmFwRmlsZU5hbWVzID0gZXhwb3J0cy5TbmFwSWRQcmVmaXhlcyA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGNvbmNhdF9zdHJlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY29uY2F0LXN0cmVhbVwiKSk7XG5jb25zdCBmYXN0X2RlZXBfZXF1YWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpKTtcbmNvbnN0IGd1bnppcF9tYXliZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJndW56aXAtbWF5YmVcIikpO1xuY29uc3QgcHVtcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwdW1wXCIpKTtcbmNvbnN0IHJlYWRhYmxlX3dlYl90b19ub2RlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXdlYi10by1ub2RlLXN0cmVhbVwiKTtcbmNvbnN0IHRhcl9zdHJlYW1fMSA9IHJlcXVpcmUoXCJ0YXItc3RyZWFtXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hc18xID0gcmVxdWlyZShcIi4vanNvbi1zY2hlbWFzXCIpO1xudmFyIFNuYXBJZFByZWZpeGVzO1xuKGZ1bmN0aW9uIChTbmFwSWRQcmVmaXhlcykge1xuICAgIFNuYXBJZFByZWZpeGVzW1wibnBtXCJdID0gXCJucG06XCI7XG4gICAgU25hcElkUHJlZml4ZXNbXCJsb2NhbFwiXSA9IFwibG9jYWw6XCI7XG59KShTbmFwSWRQcmVmaXhlcyA9IGV4cG9ydHMuU25hcElkUHJlZml4ZXMgfHwgKGV4cG9ydHMuU25hcElkUHJlZml4ZXMgPSB7fSkpO1xudmFyIE5wbVNuYXBGaWxlTmFtZXM7XG4oZnVuY3Rpb24gKE5wbVNuYXBGaWxlTmFtZXMpIHtcbiAgICBOcG1TbmFwRmlsZU5hbWVzW1wiUGFja2FnZUpzb25cIl0gPSBcInBhY2thZ2UuanNvblwiO1xuICAgIE5wbVNuYXBGaWxlTmFtZXNbXCJNYW5pZmVzdFwiXSA9IFwic25hcC5tYW5pZmVzdC5qc29uXCI7XG59KShOcG1TbmFwRmlsZU5hbWVzID0gZXhwb3J0cy5OcG1TbmFwRmlsZU5hbWVzIHx8IChleHBvcnRzLk5wbVNuYXBGaWxlTmFtZXMgPSB7fSkpO1xuZXhwb3J0cy5MT0NBTEhPU1RfSE9TVE5BTUVTID0gbmV3IFNldChbJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnXSk7XG5leHBvcnRzLkRFRkFVTFRfTlBNX1JFR0lTVFJZID0gJ2h0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnJztcbmNvbnN0IFNWR19NQVhfQllURV9TSVpFID0gMTAwMDAwO1xuY29uc3QgU1ZHX01BWF9CWVRFX1NJWkVfVEVYVCA9IGAke01hdGguZmxvb3IoU1ZHX01BWF9CWVRFX1NJWkUgLyAxMDAwKX1rYmA7XG4vLyBUaGlzIFJlZ0V4IG1hdGNoZXMgdmFsaWQgbnBtIHBhY2thZ2UgbmFtZXMgKHdpdGggc29tZSBleGNlcHRpb25zKSBhbmQgc3BhY2UtXG4vLyBzZXBhcmF0ZWQgYWxwaGFudW1lcmljYWwgd29yZHMsIG9wdGlvbmFsbHkgd2l0aCBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzLlxuLy8gVGhlIFJlZ0V4IGNvbnNpc3RzIG9mIHR3byBwYXJ0cy4gVGhlIGZpcnN0IHBhcnQgbWF0Y2hlcyBzcGFjZS1zZXBhcmF0ZWRcbi8vIHdvcmRzLiBJdCBpcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIFN0YWNrb3ZlcmZsb3cgYW5zd2VyOlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0OTc0OTgyXG4vLyBUaGUgc2Vjb25kIHBhcnQsIGFmdGVyIHRoZSBwaXBlIG9wZXJhdG9yLCBpcyB0aGUgc2FtZSBSZWdFeCB1c2VkIGZvciB0aGVcbi8vIGBuYW1lYCBmaWVsZCBvZiB0aGUgb2ZmaWNpYWwgcGFja2FnZS5qc29uIEpTT04gU2NoZW1hLCBleGNlcHQgdGhhdCB3ZSBhbGxvd1xuLy8gbWl4ZWQtY2FzZSBsZXR0ZXJzLiBJdCB3YXMgb3JpZ2luYWxseSBjb3BpZWQgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9TY2hlbWFTdG9yZS9zY2hlbWFzdG9yZS9ibG9iLzgxYTE2ODk3YzFkYWJmZDk4YzcyMjQyYTVmZDYyZWIwODBmZjc2ZDgvc3JjL3NjaGVtYXMvanNvbi9wYWNrYWdlLmpzb24jTDEzMi1MMTM4XG5leHBvcnRzLlBST1BPU0VEX05BTUVfUkVHRVggPSAvXig/OltBLVphLXowLTktX10rKCBbQS1aYS16MC05LV9dKykqKXwoPzooPzpAW0EtWmEtejAtOS0qfl1bQS1aYS16MC05LSouX35dKlxcLyk/W0EtWmEtejAtOS1+XVtBLVphLXowLTktLl9+XSopJC91O1xuLyoqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBmZXRjaC5cbiAqIEBwYXJhbSBjb250ZW50VHlwZSAtIFRoZSBjb250ZW50IHR5cGUgb2YgdGhlIHJlc3BvbnNlIGJvZHkuXG4gKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgYm9keSBhcyB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgdHlwZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb250ZW50KHVybCwgY29udGVudFR5cGUsIGZldGNoRnVuY3Rpb24gPSBmZXRjaCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hGdW5jdGlvbih0eXBlb2YgdXJsID09PSAnc3RyaW5nJyA/IHVybCA6IHVybC50b1N0cmluZygpKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2VbY29udGVudFR5cGVdKCk7XG59XG5leHBvcnRzLmZldGNoQ29udGVudCA9IGZldGNoQ29udGVudDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgQmFzZTY0LWVjb25kZWQgU0hBLTI1NiBkaWdlc3Qgb2YgYSBTbmFwIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc291cmNlQ29kZSAtIFRoZSBVVEYtOCBzdHJpbmcgc291cmNlIGNvZGUgb2YgYSBTbmFwLlxuICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIFNIQS0yNTYgZGlnZXN0IG9mIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U25hcFNvdXJjZVNoYXN1bShzb3VyY2VDb2RlKSB7XG4gICAgcmV0dXJuIGNyeXB0b18xLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnYmFzZTY0Jyk7XG59XG5leHBvcnRzLmdldFNuYXBTb3VyY2VTaGFzdW0gPSBnZXRTbmFwU291cmNlU2hhc3VtO1xuLy8gbnBtIGZldGNoIHN0dWZmXG5jb25zdCBFeHBlY3RlZFNuYXBGaWxlcyA9IFsnbWFuaWZlc3QnLCAncGFja2FnZUpzb24nLCAnc291cmNlQ29kZSddO1xuY29uc3QgU25hcEZpbGVOYW1lRnJvbUtleSA9IHtcbiAgICBtYW5pZmVzdDogTnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdCxcbiAgICBwYWNrYWdlSnNvbjogTnBtU25hcEZpbGVOYW1lcy5QYWNrYWdlSnNvbixcbiAgICBzb3VyY2VDb2RlOiAnc291cmNlIGNvZGUgYnVuZGxlJyxcbn07XG4vKipcbiAqIEZldGNoZXMgYSBTbmFwIGZyb20gdGhlIHB1YmxpYyBucG0gcmVnaXN0cnkuXG4gKlxuICogQHBhcmFtIHBhY2thZ2VOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2Ugd2hvc2UgdGFyYmFsbCB0byBmZXRjaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHBhY2thZ2UgdG8gZmV0Y2gsIG9yIHRoZSBzdHJpbmcgYGxhdGVzdGBcbiAqIHRvIGZldGNoIHRoZSBsYXRlc3QgdmVyc2lvbi5cbiAqIEBwYXJhbSBmZXRjaEZ1bmN0aW9uIC0gVGhlIGZldGNoIGZ1bmN0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICoge0BsaW5rIGZldGNofS4gVXNlZnVsIGZvciBOb2RlLmpzIGNvbXBhdGliaWxpdHkuXG4gKiBAcmV0dXJucyBBIHR1cGxlIG9mIHRoZSBTbmFwIG1hbmlmZXN0IG9iamVjdCBhbmQgdGhlIFNuYXAgc291cmNlIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoTnBtU25hcChwYWNrYWdlTmFtZSwgdmVyc2lvbiwgcmVnaXN0cnlVcmwgPSBleHBvcnRzLkRFRkFVTFRfTlBNX1JFR0lTVFJZLCBmZXRjaEZ1bmN0aW9uID0gZmV0Y2gpIHtcbiAgICBjb25zdCBbdGFyYmFsbFJlc3BvbnNlLCBhY3R1YWxWZXJzaW9uXSA9IGF3YWl0IGZldGNoTnBtVGFyYmFsbChwYWNrYWdlTmFtZSwgdmVyc2lvbiwgcmVnaXN0cnlVcmwsIGZldGNoRnVuY3Rpb24pO1xuICAgIC8vIEV4dHJhY3QgdGhlIHRhcmJhbGwgYW5kIGdldCB0aGUgbmVjZXNzYXJ5IGZpbGVzIGZyb20gaXQuXG4gICAgY29uc3Qgc25hcEZpbGVzID0ge307XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBwdW1wXzEuZGVmYXVsdChnZXRSZXNwb25zZUJvZHlTdHJlYW0odGFyYmFsbFJlc3BvbnNlKSwgXG4gICAgICAgIC8vIFRoZSBcImd6XCIgaW4gXCJ0Z3pcIiBzdGFuZHMgZm9yIFwiZ3ppcFwiLiBUaGUgdGFyYmFsbCBuZWVkcyB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgICAgLy8gYmVmb3JlIHdlIGNhbiBhY3R1YWxseSBncmFiIGFueSBmaWxlcyBmcm9tIGl0LlxuICAgICAgICBndW56aXBfbWF5YmVfMS5kZWZhdWx0KCksIGNyZWF0ZVRhcmJhbGxFeHRyYWN0aW9uU3RyZWFtKHNuYXBGaWxlcyksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgbmVjZXNzYXJ5IGZpbGVzIHdpbGwgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzbmFwRmlsZXNcbiAgICAvLyBvYmplY3QgaWYgdGhleSBleGlzdC5cbiAgICByZXR1cm4gdmFsaWRhdGVOcG1TbmFwKHNuYXBGaWxlcywgYG5wbSBTbmFwIFwiJHtwYWNrYWdlTmFtZX1AJHthY3R1YWxWZXJzaW9ufVwiIHZhbGlkYXRpb24gZXJyb3I6IGApO1xufVxuZXhwb3J0cy5mZXRjaE5wbVNuYXAgPSBmZXRjaE5wbVNuYXA7XG4vKipcbiAqIFNuYXAgdmFsaWRhdGlvbiBmYWlsdXJlIHJlYXNvbiBjb2RlcyB0aGF0IGFyZSBwcm9ncmFtbWF0aWNhbGx5IGZpeGFibGVcbiAqIGlmIHZhbGlkYXRpb24gb2NjdXJzIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqL1xudmFyIFNuYXBWYWxpZGF0aW9uRmFpbHVyZVJlYXNvbjtcbihmdW5jdGlvbiAoU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uKSB7XG4gICAgU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uW1wiTmFtZU1pc21hdGNoXCJdID0gXCJcXFwibmFtZVxcXCIgZmllbGQgbWlzbWF0Y2hcIjtcbiAgICBTbmFwVmFsaWRhdGlvbkZhaWx1cmVSZWFzb25bXCJWZXJzaW9uTWlzbWF0Y2hcIl0gPSBcIlxcXCJ2ZXJzaW9uXFxcIiBmaWVsZCBtaXNtYXRjaFwiO1xuICAgIFNuYXBWYWxpZGF0aW9uRmFpbHVyZVJlYXNvbltcIlJlcG9zaXRvcnlNaXNtYXRjaFwiXSA9IFwiXFxcInJlcG9zaXRvcnlcXFwiIGZpZWxkIG1pc21hdGNoXCI7XG4gICAgU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uW1wiU2hhc3VtTWlzbWF0Y2hcIl0gPSBcIlxcXCJzaGFzdW1cXFwiIGZpZWxkIG1pc21hdGNoXCI7XG59KShTbmFwVmFsaWRhdGlvbkZhaWx1cmVSZWFzb24gPSBleHBvcnRzLlNuYXBWYWxpZGF0aW9uRmFpbHVyZVJlYXNvbiB8fCAoZXhwb3J0cy5TbmFwVmFsaWRhdGlvbkZhaWx1cmVSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBpbmRpY2F0aW5nIHRoYXQgYSBTbmFwIHZhbGlkYXRpb24gZmFpbHVyZSBpcyBwcm9ncmFtbWF0aWNhbGx5XG4gKiBmaXhhYmxlIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqL1xuY2xhc3MgUHJvZ3JhbW1hdGljYWxseUZpeGFibGVTbmFwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVhc29uKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyYW1tYXRpY2FsbHlGaXhhYmxlU25hcEVycm9yID0gUHJvZ3JhbW1hdGljYWxseUZpeGFibGVTbmFwRXJyb3I7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZmlsZXMgZXh0cmFjdGVkIGZyb20gYW4gbnBtIFNuYXAgcGFja2FnZSB0YXJiYWxsIGJ5IGVuc3VyaW5nXG4gKiB0aGF0IHRoZXkncmUgbm9uLWVtcHR5IGFuZCB0aGF0IHRoZSBKc29uIGZpbGVzIG1hdGNoIHRoZWlyIHJlc3BlY3RpdmUgc2NoZW1hc1xuICogYW5kIHRoZSBTbmFwcyBwdWJsaXNoaW5nIHNwZWNpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHNuYXBGaWxlcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgZXhwZWN0ZWQgU25hcCBmaWxlIGNvbnRlbnRzLFxuICogaWYgYW55LlxuICogQHBhcmFtIHBhY2thZ2VOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2Ugd2hvc2UgdGFyYmFsbCB0byBmZXRjaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHBhY2thZ2UgdG8gZmV0Y2gsIG9yIHRoZSBzdHJpbmcgYGxhdGVzdGAuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBUaGUgcHJlZml4IG9mIHRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgQSB0dXBsZSBvZiB0aGUgU25hcCBtYW5pZmVzdCBvYmplY3QgYW5kIHRoZSBTbmFwIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5wbVNuYXAoc25hcEZpbGVzLCBlcnJvclByZWZpeCkge1xuICAgIEV4cGVjdGVkU25hcEZpbGVzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXNuYXBGaWxlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JQcmVmaXh9TWlzc2luZyBmaWxlIFwiJHtTbmFwRmlsZU5hbWVGcm9tS2V5W2tleV19XCIuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUeXBlY2FzdDogV2UgYXJlIGFzc3VyZWQgdGhhdCB0aGUgcmVxdWlyZWQgZmlsZXMgZXhpc3QgaWYgd2UgZ2V0IGhlcmUuXG4gICAgY29uc3QgeyBtYW5pZmVzdCwgcGFja2FnZUpzb24sIHNvdXJjZUNvZGUsIHN2Z0ljb24gfSA9IHNuYXBGaWxlcztcbiAgICB0cnkge1xuICAgICAgICBqc29uX3NjaGVtYXNfMS52YWxpZGF0ZVNuYXBKc29uRmlsZShOcG1TbmFwRmlsZU5hbWVzLk1hbmlmZXN0LCBtYW5pZmVzdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JQcmVmaXh9XCIke05wbVNuYXBGaWxlTmFtZXMuTWFuaWZlc3R9XCIgaXMgaW52YWxpZDpcXG4ke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlZE1hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgY29uc3QgeyBpY29uUGF0aCB9ID0gdmFsaWRhdGVkTWFuaWZlc3Quc291cmNlLmxvY2F0aW9uLm5wbTtcbiAgICBpZiAoaWNvblBhdGggJiYgIXN2Z0ljb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yUHJlZml4fU1pc3NpbmcgZmlsZSBcIiR7aWNvblBhdGh9XCIuYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGpzb25fc2NoZW1hc18xLnZhbGlkYXRlU25hcEpzb25GaWxlKE5wbVNuYXBGaWxlTmFtZXMuUGFja2FnZUpzb24sIHBhY2thZ2VKc29uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvclByZWZpeH1cIiR7TnBtU25hcEZpbGVOYW1lcy5QYWNrYWdlSnNvbn1cIiBpcyBpbnZhbGlkOlxcbiR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVkUGFja2FnZUpzb24gPSBwYWNrYWdlSnNvbjtcbiAgICB2YWxpZGF0ZU5wbVNuYXBNYW5pZmVzdCh7XG4gICAgICAgIG1hbmlmZXN0OiB2YWxpZGF0ZWRNYW5pZmVzdCxcbiAgICAgICAgcGFja2FnZUpzb246IHZhbGlkYXRlZFBhY2thZ2VKc29uLFxuICAgICAgICBzb3VyY2VDb2RlLFxuICAgIH0sIGVycm9yUHJlZml4KTtcbiAgICBpZiAoc3ZnSWNvbikge1xuICAgICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgoc3ZnSWNvbiwgJ3V0ZjgnKSA+IFNWR19NQVhfQllURV9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JQcmVmaXh9VGhlIHNwZWNpZmllZCBTVkcgaWNvbiBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgb2YgJHtTVkdfTUFYX0JZVEVfU0laRV9URVhUfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5pZmVzdDogdmFsaWRhdGVkTWFuaWZlc3QsXG4gICAgICAgIHBhY2thZ2VKc29uOiB2YWxpZGF0ZWRQYWNrYWdlSnNvbixcbiAgICAgICAgc291cmNlQ29kZSxcbiAgICAgICAgc3ZnSWNvbixcbiAgICB9O1xufVxuZXhwb3J0cy52YWxpZGF0ZU5wbVNuYXAgPSB2YWxpZGF0ZU5wbVNuYXA7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgZmllbGRzIG9mIGFuIG5wbSBTbmFwIG1hbmlmZXN0IHRoYXQgaGFzIGFscmVhZHkgcGFzc2VkIEpTT05cbiAqIFNjaGVtYSB2YWxpZGF0aW9uLlxuICpcbiAqIEBwYXJhbSBtYW5pZmVzdCAtIFRoZSBucG0gU25hcCBtYW5pZmVzdCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBwYWNrYWdlSnNvbiAtIFRoZSBucG0gU25hcCdzIGBwYWNrYWdlLmpzb25gLlxuICogQHBhcmFtIHNvdXJjZUNvZGUgLSBUaGUgU25hcCdzIHNvdXJjZSBjb2RlLlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gVGhlIHByZWZpeCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTnBtU25hcE1hbmlmZXN0KHsgbWFuaWZlc3QsIHBhY2thZ2VKc29uLCBzb3VyY2VDb2RlIH0sIGVycm9yUHJlZml4KSB7XG4gICAgY29uc3QgcGFja2FnZUpzb25OYW1lID0gcGFja2FnZUpzb24ubmFtZTtcbiAgICBjb25zdCBwYWNrYWdlSnNvblZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uO1xuICAgIGNvbnN0IHBhY2thZ2VKc29uUmVwb3NpdG9yeSA9IHBhY2thZ2VKc29uLnJlcG9zaXRvcnk7XG4gICAgY29uc3QgbWFuaWZlc3RQYWNrYWdlTmFtZSA9IG1hbmlmZXN0LnNvdXJjZS5sb2NhdGlvbi5ucG0ucGFja2FnZU5hbWU7XG4gICAgY29uc3QgbWFuaWZlc3RQYWNrYWdlVmVyc2lvbiA9IG1hbmlmZXN0LnZlcnNpb247XG4gICAgY29uc3QgbWFuaWZlc3RSZXBvc2l0b3J5ID0gbWFuaWZlc3QucmVwb3NpdG9yeTtcbiAgICBpZiAocGFja2FnZUpzb25OYW1lICE9PSBtYW5pZmVzdFBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9ncmFtbWF0aWNhbGx5Rml4YWJsZVNuYXBFcnJvcihgJHtlcnJvclByZWZpeH1cIiR7TnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdH1cIiBucG0gcGFja2FnZSBuYW1lIChcIiR7bWFuaWZlc3RQYWNrYWdlTmFtZX1cIikgZG9lcyBub3QgbWF0Y2ggdGhlIFwiJHtOcG1TbmFwRmlsZU5hbWVzLlBhY2thZ2VKc29ufVwiIFwibmFtZVwiIGZpZWxkIChcIiR7cGFja2FnZUpzb25OYW1lfVwiKS5gLCBTbmFwVmFsaWRhdGlvbkZhaWx1cmVSZWFzb24uTmFtZU1pc21hdGNoKTtcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uVmVyc2lvbiAhPT0gbWFuaWZlc3RQYWNrYWdlVmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgUHJvZ3JhbW1hdGljYWxseUZpeGFibGVTbmFwRXJyb3IoYCR7ZXJyb3JQcmVmaXh9XCIke05wbVNuYXBGaWxlTmFtZXMuTWFuaWZlc3R9XCIgbnBtIHBhY2thZ2UgdmVyc2lvbiAoXCIke21hbmlmZXN0UGFja2FnZVZlcnNpb259XCIpIGRvZXMgbm90IG1hdGNoIHRoZSBcIiR7TnBtU25hcEZpbGVOYW1lcy5QYWNrYWdlSnNvbn1cIiBcInZlcnNpb25cIiBmaWVsZCAoXCIke3BhY2thZ2VKc29uVmVyc2lvbn1cIikuYCwgU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uLlZlcnNpb25NaXNtYXRjaCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAvLyBUaGUgcmVwb3NpdG9yeSBtYXkgYmUgYHVuZGVmaW5lZGAgaW4gcGFja2FnZS5qc29uIGJ1dCBjYW4gb25seSBiZSBkZWZpbmVkXG4gICAgLy8gb3IgYG51bGxgIGluIHRoZSBTbmFwIG1hbmlmZXN0IGR1ZSB0byBUU0A8NC40IGlzc3Vlcy5cbiAgICAocGFja2FnZUpzb25SZXBvc2l0b3J5IHx8IG1hbmlmZXN0UmVwb3NpdG9yeSkgJiZcbiAgICAgICAgIWZhc3RfZGVlcF9lcXVhbF8xLmRlZmF1bHQocGFja2FnZUpzb25SZXBvc2l0b3J5LCBtYW5pZmVzdFJlcG9zaXRvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9ncmFtbWF0aWNhbGx5Rml4YWJsZVNuYXBFcnJvcihgJHtlcnJvclByZWZpeH1cIiR7TnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdH1cIiBcInJlcG9zaXRvcnlcIiBmaWVsZCBkb2VzIG5vdCBtYXRjaCB0aGUgXCIke05wbVNuYXBGaWxlTmFtZXMuUGFja2FnZUpzb259XCIgXCJyZXBvc2l0b3J5XCIgZmllbGQuYCwgU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uLlJlcG9zaXRvcnlNaXNtYXRjaCk7XG4gICAgfVxuICAgIHZhbGlkYXRlU25hcFNoYXN1bShtYW5pZmVzdCwgc291cmNlQ29kZSwgYCR7ZXJyb3JQcmVmaXh9XCIke05wbVNuYXBGaWxlTmFtZXMuTWFuaWZlc3R9XCIgXCJzaGFzdW1cIiBmaWVsZCBkb2VzIG5vdCBtYXRjaCBjb21wdXRlZCBzaGFzdW0uYCk7XG4gICAgcmV0dXJuIFttYW5pZmVzdCwgc291cmNlQ29kZSwgcGFja2FnZUpzb25dO1xufVxuZXhwb3J0cy52YWxpZGF0ZU5wbVNuYXBNYW5pZmVzdCA9IHZhbGlkYXRlTnBtU25hcE1hbmlmZXN0O1xuLyoqXG4gKiBGZXRjaGVzIHRoZSB0YXJiYWxsIChgLnRnemAgZmlsZSkgb2YgdGhlIHNwZWNpZmllZCBwYWNrYWdlIGFuZCB2ZXJzaW9uIGZyb21cbiAqIHRoZSBwdWJsaWMgbnBtIHJlZ2lzdHJ5LiBUaHJvd3MgYW4gZXJyb3IgaWYgZmV0Y2hpbmcgZmFpbHMuXG4gKlxuICogQHBhcmFtIHBhY2thZ2VOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2Ugd2hvc2UgdGFyYmFsbCB0byBmZXRjaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHBhY2thZ2UgdG8gZmV0Y2gsIG9yIHRoZSBzdHJpbmcgYGxhdGVzdGBcbiAqIHRvIGZldGNoIHRoZSBsYXRlc3QgdmVyc2lvbi5cbiAqIEBwYXJhbSBmZXRjaEZ1bmN0aW9uIC0gVGhlIGZldGNoIGZ1bmN0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICoge0BsaW5rIGZldGNofS4gVXNlZnVsIGZvciBOb2RlLmpzIGNvbXBhdGliaWxpdHkuXG4gKiBAcmV0dXJucyBBIHR1cGxlIG9mIHRoZSB7QGxpbmsgUmVzcG9uc2V9IGZvciB0aGUgcGFja2FnZSB0YXJiYWxsIGFuZCB0aGVcbiAqIGFjdHVhbCB2ZXJzaW9uIG9mIHRoZSBwYWNrYWdlLlxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaE5wbVRhcmJhbGwocGFja2FnZU5hbWUsIHZlcnNpb24sIHJlZ2lzdHJ5VXJsID0gZXhwb3J0cy5ERUZBVUxUX05QTV9SRUdJU1RSWSwgZmV0Y2hGdW5jdGlvbiA9IGZldGNoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IGF3YWl0IGZldGNoQ29udGVudChuZXcgVVJMKHBhY2thZ2VOYW1lLCByZWdpc3RyeVVybCksICdqc29uJywgZmV0Y2hGdW5jdGlvbik7XG4gICAgaWYgKCF1dGlsc18xLmlzUGxhaW5PYmplY3QocGFja2FnZU1ldGFkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwYWNrYWdlIFwiJHtwYWNrYWdlTmFtZX1cIiBtZXRhZGF0YSBmcm9tIG5wbS5gKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0VmVyc2lvbiA9IHZlcnNpb24gPT09ICdsYXRlc3QnXG4gICAgICAgID8gKF9hID0gcGFja2FnZU1ldGFkYXRhWydkaXN0LXRhZ3MnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhdGVzdFxuICAgICAgICA6IHZlcnNpb247XG4gICAgY29uc3QgdGFyYmFsbFVybFN0cmluZyA9IChfZCA9IChfYyA9IChfYiA9IHBhY2thZ2VNZXRhZGF0YS52ZXJzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3RhcmdldFZlcnNpb25dKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRhcmJhbGw7XG4gICAgaWYgKCFpc1ZhbGlkVXJsKHRhcmJhbGxVcmxTdHJpbmcpIHx8ICF0YXJiYWxsVXJsU3RyaW5nLmVuZHNXaXRoKCcudGd6JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCB2YWxpZCB0YXJiYWxsIFVSTCBpbiBucG0gbWV0YWRhdGEgZm9yIHBhY2thZ2UgXCIke3BhY2thZ2VOYW1lfVwiLmApO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB0aGUgdGFyYmFsbCBob3N0bmFtZS9wcm90b2NvbCB3aXRoIHJlZ2lzdHJ5VXJsIGhvc3RuYW1lL3Byb3RvY29sXG4gICAgY29uc3QgbmV3UmVnaXN0cnlVcmwgPSBuZXcgVVJMKHJlZ2lzdHJ5VXJsKTtcbiAgICBjb25zdCBuZXdUYXJiYWxsVXJsID0gbmV3IFVSTCh0YXJiYWxsVXJsU3RyaW5nKTtcbiAgICBuZXdUYXJiYWxsVXJsLmhvc3RuYW1lID0gbmV3UmVnaXN0cnlVcmwuaG9zdG5hbWU7XG4gICAgbmV3VGFyYmFsbFVybC5wcm90b2NvbCA9IG5ld1JlZ2lzdHJ5VXJsLnByb3RvY29sO1xuICAgIC8vIFBlcmZvcm0gYSByYXcgZmV0Y2ggYmVjYXVzZSB3ZSB3YW50IHRoZSBSZXNwb25zZSBvYmplY3QgaXRzZWxmLlxuICAgIGNvbnN0IHRhcmJhbGxSZXNwb25zZSA9IGF3YWl0IGZldGNoRnVuY3Rpb24obmV3VGFyYmFsbFVybC50b1N0cmluZygpKTtcbiAgICBpZiAoIXRhcmJhbGxSZXNwb25zZS5vayB8fCAhdGFyYmFsbFJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdGFyYmFsbCBmb3IgcGFja2FnZSBcIiR7cGFja2FnZU5hbWV9XCIuYCk7XG4gICAgfVxuICAgIHJldHVybiBbdGFyYmFsbFJlc3BvbnNlLCB0YXJnZXRWZXJzaW9uXTtcbn1cbi8vIFRoZSBwYXRocyBvZiBmaWxlcyB3aXRoaW4gbnBtIHRhcmJhbGxzIGFwcGVhciB0byBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aFxuLy8gXCJwYWNrYWdlL1wiLlxuY29uc3QgTlBNX1RBUkJBTExfUEFUSF9QUkVGSVggPSAvXnBhY2thZ2VcXC8vdTtcbi8qKlxuICogQ3JlYXRlcyBhIGB0YXItc3RyZWFtYCB0aGF0IHdpbGwgZ2V0IHRoZSBuZWNlc3NhcnkgZmlsZXMgZnJvbSBhbiBucG0gU25hcFxuICogcGFja2FnZSB0YXJiYWxsIChgLnRnemAgZmlsZSkuXG4gKlxuICogQHBhcmFtIHNuYXBGaWxlcyAtIEFuIG9iamVjdCB0byB3cml0ZSB0YXJnZXQgZmlsZSBjb250ZW50cyB0by5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgV3JpdGFibGV9IHRhcmJhbGwgZXh0cmFjdGlvbiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRhcmJhbGxFeHRyYWN0aW9uU3RyZWFtKHNuYXBGaWxlcykge1xuICAgIC8vIGB0YXItc3RyZWFtYCBpcyBwcmV0dHkgb2xkLXNjaG9vbCwgc28gd2UgY3JlYXRlIGl0IGZpcnN0IGFuZCB0aGVuXG4gICAgLy8gaW5zdHJ1bWVudCBpdCBieSBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzLlxuICAgIGNvbnN0IGV4dHJhY3RTdHJlYW0gPSB0YXJfc3RyZWFtXzEuZXh0cmFjdCgpO1xuICAgIC8vIGB0YXItc3RyZWFtYCByZWFkcyBldmVyeSBmaWxlIGluIHRoZSB0YXJiYWxsIHNlcmlhbGx5LiBXZSBhbHJlYWR5IGtub3dcbiAgICAvLyB3aGVyZSB0byBsb29rIGZvciBwYWNrYWdlLmpzb24gYW5kIHRoZSBTbmFwIG1hbmlmZXN0LCBidXQgd2UgZG9uJ3Qga25vd1xuICAgIC8vIHdoZXJlIHRoZSBzb3VyY2UgY29kZSBpcy4gVGhlcmVmb3JlLCB3ZSBjYWNoZSB0aGUgY29udGVudHMgb2YgZWFjaCAuanNcbiAgICAvLyBmaWxlIGluIHRoZSB0YXJiYWxsIGFuZCBwaWNrIG91dCB0aGUgY29ycmVjdCBvbmUgd2hlbiB0aGUgc3RyZWFtIGhhcyBlbmRlZC5cbiAgICBjb25zdCBqc0ZpbGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAvLyBcImVudHJ5XCIgaXMgZmlyZWQgZm9yIGV2ZXJ5IGRpc2NyZWV0IGVudGl0eSBpbiB0aGUgdGFyYmFsbC4gVGhpcyBpbmNsdWRlc1xuICAgIC8vIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgIGV4dHJhY3RTdHJlYW0ub24oJ2VudHJ5JywgKGhlYWRlciwgZW50cnlTdHJlYW0sIG5leHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBoZWFkZXJOYW1lLCB0eXBlOiBoZWFkZXJUeXBlIH0gPSBoZWFkZXI7XG4gICAgICAgIGlmIChoZWFkZXJUeXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuYW1lIGlzIGEgcGF0aCBpZiB0aGUgaGVhZGVyIHR5cGUgaXMgXCJmaWxlXCIuXG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGhlYWRlck5hbWUucmVwbGFjZShOUE1fVEFSQkFMTF9QQVRIX1BSRUZJWCwgJycpO1xuICAgICAgICAgICAgLy8gTm90ZSB0aGUgdXNlIG9mIGBjb25jYXQtc3RyZWFtYCBzaW5jZSB0aGUgZGF0YSBmb3IgZWFjaCBmaWxlIG1heSBiZVxuICAgICAgICAgICAgLy8gY2h1bmtlZC5cbiAgICAgICAgICAgIGlmIChmaWxlUGF0aCA9PT0gTnBtU25hcEZpbGVOYW1lcy5QYWNrYWdlSnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeVN0cmVhbS5waXBlKGNvbmNhdF9zdHJlYW1fMS5kZWZhdWx0KChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwRmlsZXMucGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RTdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBcIiR7TnBtU25hcEZpbGVOYW1lcy5QYWNrYWdlSnNvbn1cIi5gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWxlUGF0aCA9PT0gTnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeVN0cmVhbS5waXBlKGNvbmNhdF9zdHJlYW1fMS5kZWZhdWx0KChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwRmlsZXMubWFuaWZlc3QgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RTdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBcIiR7TnBtU25hcEZpbGVOYW1lcy5NYW5pZmVzdH1cIi5gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXFx3K1xcLig/OmpzfHN2ZykkL3UudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnlTdHJlYW0ucGlwZShjb25jYXRfc3RyZWFtXzEuZGVmYXVsdCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBqc0ZpbGVDYWNoZS5zZXQoZmlsZVBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIGVudHJ5IGlzIG5vdCBhIGZpbGUsIGFuZCB3ZSB3YW50IHRvIGlnbm9yZS4gVGhlIGVudHJ5XG4gICAgICAgIC8vIHN0cmVhbSBtdXN0IGJlIGRyYWluZWQsIG9yIHRoZSBleHRyYWN0U3RyZWFtIHdpbGwgc3RvcCByZWFkaW5nLiBUaGlzIGlzXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IGEgbm8tb3AgZm9yIHRoZSBjdXJyZW50IGVudHJ5LlxuICAgICAgICBlbnRyeVN0cmVhbS5vbignZW5kJywgKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5U3RyZWFtLnJlc3VtZSgpO1xuICAgIH0pO1xuICAgIC8vIFdoZW4gd2UndmUgcmVhZCB0aGUgZW50aXJlIHRhcmJhbGwsIGF0dGVtcHQgdG8gZ3JhYiB0aGUgYnVuZGxlIGZpbGVcbiAgICAvLyBjb250ZW50cyBmcm9tIHRoZSAuanMgZmlsZSBjYWNoZS5cbiAgICBleHRyYWN0U3RyZWFtLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGlmICh1dGlsc18xLmlzUGxhaW5PYmplY3Qoc25hcEZpbGVzLm1hbmlmZXN0KSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG9wdGlvbmFsIGNoYWluaW5nICovXG4gICAgICAgICAgICBjb25zdCB7IGZpbGVQYXRoOiBidW5kbGVQYXRoLCBpY29uUGF0aCB9ID0gKF9jID0gKF9iID0gKF9hID0gc25hcEZpbGVzLm1hbmlmZXN0LnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubnBtKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fTtcbiAgICAgICAgICAgIGlmIChidW5kbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgc25hcEZpbGVzLnNvdXJjZUNvZGUgPSAoX2QgPSBqc0ZpbGVDYWNoZS5nZXQoYnVuZGxlUGF0aCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uUGF0aCA9PT0gJ3N0cmluZycgJiYgaWNvblBhdGguZW5kc1dpdGgoJy5zdmcnKSkge1xuICAgICAgICAgICAgICAgIHNuYXBGaWxlcy5zdmdJY29uID0gKF9lID0ganNGaWxlQ2FjaGUuZ2V0KGljb25QYXRoKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAganNGaWxlQ2FjaGUuY2xlYXIoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXh0cmFjdFN0cmVhbTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNvdXJjZS5zaGFzdW0gcHJvcGVydHkgb2YgdGhlIHNwZWNpZmllZCBTbmFwIG1hbmlmZXN0XG4gKiBtYXRjaGVzIHRoZSBzaGFzdW0gb2YgdGhlIHNwZWNpZmllZCBzbmFwIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gbWFuaWZlc3QgLSBUaGUgbWFuaWZlc3Qgd2hvc2Ugc2hhc3VtIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHNvdXJjZUNvZGUgLSBUaGUgc291cmNlIGNvZGUgb2YgdGhlIHNuYXAuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU25hcFNoYXN1bShtYW5pZmVzdCwgc291cmNlQ29kZSwgZXJyb3JNZXNzYWdlID0gJ0ludmFsaWQgU25hcCBtYW5pZmVzdDogbWFuaWZlc3Qgc2hhc3VtIGRvZXMgbm90IG1hdGNoIGNvbXB1dGVkIHNoYXN1bS4nKSB7XG4gICAgaWYgKG1hbmlmZXN0LnNvdXJjZS5zaGFzdW0gIT09IGdldFNuYXBTb3VyY2VTaGFzdW0oc291cmNlQ29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb2dyYW1tYXRpY2FsbHlGaXhhYmxlU25hcEVycm9yKGVycm9yTWVzc2FnZSwgU25hcFZhbGlkYXRpb25GYWlsdXJlUmVhc29uLlNoYXN1bU1pc21hdGNoKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU25hcFNoYXN1bSA9IHZhbGlkYXRlU25hcFNoYXN1bTtcbi8qKlxuICogR2V0cyB0aGUgYm9keSBvZiBhIHtAbGluayBmZXRjaH0gcmVzcG9uc2UgYXMgYSBOb2RlLmpzIHtAbGluayBSZWFkYWJsZX1cbiAqIHN0cmVhbS4gUmV0dXJucyB0aGUgc3RyZWFtIGRpcmVjdGx5IGlmIGl0IGlzIGFscmVhZHkgYSBOb2RlLmpzIHN0cmVhbS5cbiAqIFdlIGNhbid0IHVzZSB0aGUgbmF0aXZlIFdlYiB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGRpcmVjdGx5IGJlY2F1c2UgdGhlXG4gKiBvdGhlciBzdHJlYW0gbGlicmFyaWVzIHdlIHVzZSBleHBlY3QgTm9kZS5qcyBzdHJlYW1zLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSByZXNwb25zZSB3aG9zZSBib2R5IHN0cmVhbSB0byBnZXQuXG4gKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgYm9keSBzdHJlYW0sIGFzIGEgTm9kZS5qcyBSZWFkYWJsZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3BvbnNlQm9keVN0cmVhbShyZXNwb25zZSkge1xuICAgIGNvbnN0IHsgYm9keSB9ID0gcmVzcG9uc2U7XG4gICAgaWYgKHR5cGVvZiBib2R5LmdldFJlYWRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyByZWFkYWJsZV93ZWJfdG9fbm9kZV9zdHJlYW1fMS5SZWFkYWJsZVdlYlRvTm9kZVN0cmVhbShyZXNwb25zZS5ib2R5KTtcbn1cbi8qKlxuICogQHBhcmFtIG1heWJlVXJsIC0gVGhlIHN0cmluZyB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBzdHJpbmcgaXMgYSB2YWxpZCBVUkwuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRVcmwobWF5YmVVcmwpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihuZXcgVVJMKG1heWJlVXJsKSk7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXhlY3V0aW9uU2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXBNdWx0aXBsZXggPSBleHBvcnRzLkFic3RyYWN0RXhlY3V0aW9uU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IG9iamVjdF9tdWx0aXBsZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL29iamVjdC1tdWx0aXBsZXhcIikpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgcHVtcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwdW1wXCIpKTtcbmNsYXNzIEFic3RyYWN0RXhlY3V0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoeyBzZXR1cFNuYXBQcm92aWRlciwgbWVzc2VuZ2VyLCB1bnJlc3BvbnNpdmVQb2xsaW5nSW50ZXJ2YWwgPSA1MDAwLCB1bnJlc3BvbnNpdmVUaW1lb3V0ID0gMzAwMDAsIH0pIHtcbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmpvYnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2V0dXBTbmFwUHJvdmlkZXIgPSBzZXR1cFNuYXBQcm92aWRlcjtcbiAgICAgICAgdGhpcy5zbmFwVG9Kb2JNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuam9iVG9TbmFwTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tZXNzZW5nZXIgPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuX3VucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCA9IHVucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fdW5yZXNwb25zaXZlVGltZW91dCA9IHVucmVzcG9uc2l2ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRGb3JVbnJlc3BvbnNpdmVNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHRlcm1pbmF0ZVNuYXAoc25hcElkKSB7XG4gICAgICAgIGNvbnN0IGpvYklkID0gdGhpcy5zbmFwVG9Kb2JNYXAuZ2V0KHNuYXBJZCk7XG4gICAgICAgIGlmICgham9iSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSm9iIG5vdCBmb3VuZCBmb3Igc25hcCB3aXRoIGlkIFwiJHtzbmFwSWR9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXJtaW5hdGUoam9iSWQpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGVBbGxTbmFwcygpIHtcbiAgICAgICAgZm9yIChjb25zdCB3b3JrZXJJZCBvZiB0aGlzLmpvYnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh3b3JrZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJQQyBtZXNzYWdlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBzbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBJZCAtIFRoZSBpZCBvZiB0aGUgU25hcCB3aG9zZSBtZXNzYWdlIGhhbmRsZXIgdG8gZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc25hcFJwY0hvb2tzLmdldChzbmFwSWQpO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlU25hcChzbmFwRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zbmFwVG9Kb2JNYXAuaGFzKHNuYXBEYXRhLnNuYXBJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcERhdGEuc25hcElkfVwiIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5faW5pdEpvYigpO1xuICAgICAgICB0aGlzLl9tYXBTbmFwQW5kSm9iKHNuYXBEYXRhLnNuYXBJZCwgam9iLmlkKTtcbiAgICAgICAgdGhpcy5zZXR1cFNuYXBQcm92aWRlcihzbmFwRGF0YS5zbmFwSWQsIGpvYi5zdHJlYW1zLnJwYyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NvbW1hbmQoam9iLmlkLCB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ2V4ZWN1dGVTbmFwJyxcbiAgICAgICAgICAgIHBhcmFtczogc25hcERhdGEsXG4gICAgICAgICAgICBpZDogbmFub2lkXzEubmFub2lkKCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXQgdXAgcG9sbC9waW5nIGZvciBzdGF0dXMgdG8gc2VlIGlmIGl0cyB1cCwgaWYgaXRzIG5vdCB0aGVuIGVtaXQgZXZlbnQgdGhhdCBpdCBjYW50IGJlIHJlYWNoZWRcbiAgICAgICAgdGhpcy5fcG9sbEZvckpvYlN0YXR1cyhzbmFwRGF0YS5zbmFwSWQpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTbmFwSG9va3Moc25hcERhdGEuc25hcElkLCBqb2IuaWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfY29tbWFuZChqb2JJZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc2VuZCBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLmdldChqb2JJZCk7XG4gICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEpvYiB3aXRoIGlkIFwiJHtqb2JJZH1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ1BhcmVudDogU2VuZGluZyBDb21tYW5kJywgbWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgam9iLnJwY0VuZ2luZS5oYW5kbGUobWVzc2FnZSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxuICAgIF9yZW1vdmVTbmFwSG9va3Moc25hcElkKSB7XG4gICAgICAgIHRoaXMuX3NuYXBScGNIb29rcy5kZWxldGUoc25hcElkKTtcbiAgICB9XG4gICAgX2NyZWF0ZVNuYXBIb29rcyhzbmFwSWQsIHdvcmtlcklkKSB7XG4gICAgICAgIGNvbnN0IHJwY0hvb2sgPSBhc3luYyAob3JpZ2luLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY29tbWFuZCh3b3JrZXJJZCwge1xuICAgICAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdzbmFwUnBjJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNuYXBJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NuYXBScGNIb29rcy5zZXQoc25hcElkLCBycGNIb29rKTtcbiAgICB9XG4gICAgX3BvbGxGb3JKb2JTdGF0dXMoc25hcElkKSB7XG4gICAgICAgIGNvbnN0IGpvYklkID0gdGhpcy5zbmFwVG9Kb2JNYXAuZ2V0KHNuYXBJZCk7XG4gICAgICAgIGlmICgham9iSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gam9iIGlkIGZvdW5kIGZvciBzbmFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Sm9iU3RhdHVzKGpvYklkKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsRm9ySm9iU3RhdHVzKHNuYXBJZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVzc2VuZ2VyLnB1Ymxpc2goJ0V4ZWN1dGlvblNlcnZpY2U6dW5yZXNwb25zaXZlJywgc25hcElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLl91bnJlc3BvbnNpdmVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl90aW1lb3V0Rm9yVW5yZXNwb25zaXZlTWFwLnNldChzbmFwSWQsIHRpbWVvdXQpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0Sm9iU3RhdHVzKGpvYklkKSB7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3BpbmcgcmVxdWVzdCB0aW1lZCBvdXQnKSk7XG4gICAgICAgIH0sIHRoaXMuX3VucmVzcG9uc2l2ZVRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmQoam9iSWQsIHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBzbmFwJ3Mgam9iLlxuICAgICAqL1xuICAgIF9nZXRKb2JGb3JTbmFwKHNuYXBJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwVG9Kb2JNYXAuZ2V0KHNuYXBJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBJRCBqb2JzJ3Mgc25hcC5cbiAgICAgKi9cbiAgICBfZ2V0U25hcEZvckpvYihqb2JJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2JUb1NuYXBNYXAuZ2V0KGpvYklkKTtcbiAgICB9XG4gICAgX21hcFNuYXBBbmRKb2Ioc25hcElkLCBqb2JJZCkge1xuICAgICAgICB0aGlzLnNuYXBUb0pvYk1hcC5zZXQoc25hcElkLCBqb2JJZCk7XG4gICAgICAgIHRoaXMuam9iVG9TbmFwTWFwLnNldChqb2JJZCwgc25hcElkKTtcbiAgICB9XG4gICAgX3JlbW92ZVNuYXBBbmRKb2JNYXBwaW5nKGpvYklkKSB7XG4gICAgICAgIGNvbnN0IHNuYXBJZCA9IHRoaXMuam9iVG9TbmFwTWFwLmdldChqb2JJZCk7XG4gICAgICAgIGlmICghc25hcElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvYjogXCIke2pvYklkfVwiIGhhcyBubyBtYXBwZWQgc25hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmpvYlRvU25hcE1hcC5kZWxldGUoam9iSWQpO1xuICAgICAgICB0aGlzLnNuYXBUb0pvYk1hcC5kZWxldGUoc25hcElkKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU25hcEhvb2tzKHNuYXBJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdEV4ZWN1dGlvblNlcnZpY2UgPSBBYnN0cmFjdEV4ZWN1dGlvblNlcnZpY2U7XG4vKipcbiAqIFNldHMgdXAgc3RyZWFtIG11bHRpcGxleGluZyBmb3IgdGhlIGdpdmVuIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvblN0cmVhbSAtIHRoZSBzdHJlYW0gdG8gbXV4XG4gKiBAcGFyYW0gc3RyZWFtTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBzdHJlYW0sIGZvciBpZGVudGlmaWNhdGlvbiBpbiBlcnJvcnNcbiAqIEByZXR1cm4ge3N0cmVhbS5TdHJlYW19IHRoZSBtdWx0aXBsZXhlZCBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSwgc3RyZWFtTmFtZSkge1xuICAgIGNvbnN0IG11eCA9IG5ldyBvYmplY3RfbXVsdGlwbGV4XzEuZGVmYXVsdCgpO1xuICAgIHB1bXBfMS5kZWZhdWx0KGNvbm5lY3Rpb25TdHJlYW0sIFxuICAgIC8vIFR5cGVjYXN0OiBzdHJlYW0gdHlwZSBtaXNtYXRjaFxuICAgIG11eCwgY29ubmVjdGlvblN0cmVhbSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzdHJlYW1OYW1lXG4gICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKGBcIiR7c3RyZWFtTmFtZX1cIiBzdHJlYW0gZmFpbHVyZS5gLCBlcnIpXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbXV4O1xufVxuZXhwb3J0cy5zZXR1cE11bHRpcGxleCA9IHNldHVwTXVsdGlwbGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RFeGVjdXRpb25TZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJXb3JrZXJFeGVjdXRpb25TZXJ2aWNlID0gdm9pZCAwO1xuY29uc3Qgb2JzX3N0b3JlXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL29icy1zdG9yZVwiKTtcbmNvbnN0IHBvc3RfbWVzc2FnZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbVwiKTtcbmNvbnN0IHNuYXBfd29ya2Vyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zbmFwLXdvcmtlcnNcIik7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBqc29uX3JwY19taWRkbGV3YXJlX3N0cmVhbV8xID0gcmVxdWlyZShcImpzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgcHVtcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwdW1wXCIpKTtcbmNvbnN0IEFic3RyYWN0RXhlY3V0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RFeGVjdXRpb25TZXJ2aWNlXCIpO1xuY2xhc3MgV2ViV29ya2VyRXhlY3V0aW9uU2VydmljZSBleHRlbmRzIEFic3RyYWN0RXhlY3V0aW9uU2VydmljZV8xLkFic3RyYWN0RXhlY3V0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoeyBzZXR1cFNuYXBQcm92aWRlciwgd29ya2VyVXJsLCBtZXNzZW5nZXIsIHVucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCA9IDUwMDAsIHVucmVzcG9uc2l2ZVRpbWVvdXQgPSAzMDAwMCwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzZXR1cFNuYXBQcm92aWRlcixcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHVucmVzcG9uc2l2ZVBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgICAgIHVucmVzcG9uc2l2ZVRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlclVybCA9IHdvcmtlclVybDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBvYnNfc3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUoeyB3b3JrZXJzOiB7fSB9KTtcbiAgICB9XG4gICAgX3NldFdvcmtlcih3b3JrZXJJZCwgd29ya2VyV3JhcHBlcikge1xuICAgICAgICB0aGlzLmpvYnMuc2V0KHdvcmtlcklkLCB3b3JrZXJXcmFwcGVyKTtcbiAgICAgICAgY29uc3QgbmV3V29ya2VyU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS53b3JrZXJzKSwgeyBbd29ya2VySWRdOiB3b3JrZXJXcmFwcGVyIH0pO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgd29ya2VyczogbmV3V29ya2VyU3RhdGUgfSk7XG4gICAgfVxuICAgIF9kZWxldGVXb3JrZXIod29ya2VySWQpIHtcbiAgICAgICAgdGhpcy5qb2JzLmRlbGV0ZSh3b3JrZXJJZCk7XG4gICAgICAgIGNvbnN0IG5ld1dvcmtlclN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLndvcmtlcnMpO1xuICAgICAgICBkZWxldGUgbmV3V29ya2VyU3RhdGVbd29ya2VySWRdO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgd29ya2VyczogbmV3V29ya2VyU3RhdGUgfSk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSh3b3JrZXJJZCkge1xuICAgICAgICBjb25zdCB3b3JrZXJXcmFwcGVyID0gdGhpcy5qb2JzLmdldCh3b3JrZXJJZCk7XG4gICAgICAgIGlmICghd29ya2VyV3JhcHBlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3JrZXIgd2l0aCBpZCBcIiR7d29ya2VySWR9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBJZCA9IHRoaXMuX2dldFNuYXBGb3JKb2Iod29ya2VySWQpO1xuICAgICAgICBpZiAoIXNuYXBJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhIHNuYXAgZm9yIHdvcmtlciB3aXRoIGlkIFwiJHt3b3JrZXJJZH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QudmFsdWVzKHdvcmtlcldyYXBwZXIuc3RyZWFtcykuZm9yRWFjaCgoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICFzdHJlYW0uZGVzdHJveWVkICYmIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciB3aGlsZSBkZXN0cm95aW5nIHN0cmVhbScsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJXcmFwcGVyLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU25hcEFuZEpvYk1hcHBpbmcod29ya2VySWQpO1xuICAgICAgICB0aGlzLl9kZWxldGVXb3JrZXIod29ya2VySWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEZvclVucmVzcG9uc2l2ZU1hcC5nZXQod29ya2VySWQpKTtcbiAgICAgICAgdGhpcy5fdGltZW91dEZvclVucmVzcG9uc2l2ZU1hcC5kZWxldGUod29ya2VySWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgd29ya2VyOiR7d29ya2VySWR9IHRlcm1pbmF0ZWRgKTtcbiAgICB9XG4gICAgYXN5bmMgX2luaXRKb2IoKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcklkID0gbmFub2lkXzEubmFub2lkKCk7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJVcmwsIHtcbiAgICAgICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSGFuZGxlIG91dC1vZi1iYW5kIGVycm9ycywgaS5lLiBlcnJvcnMgdGhyb3duIGZyb20gdGhlIHNuYXAgb3V0c2lkZSBvZiB0aGUgcmVxL3JlcyBjeWNsZS5cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWVzc2VuZ2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcElkID0gdGhpcy5qb2JUb1NuYXBNYXAuZ2V0KHdvcmtlcklkKTtcbiAgICAgICAgICAgICAgICBpZiAoc25hcElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3Nlbmdlci5wdWJsaXNoKCdFeGVjdXRpb25TZXJ2aWNlOnVuaGFuZGxlZEVycm9yJywgc25hcElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBldi5lcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXYuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGV2LmVycm9yLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHN0cmVhbXMgPSB0aGlzLl9pbml0V29ya2VyU3RyZWFtcyh3b3JrZXIsIHdvcmtlcklkKTtcbiAgICAgICAgY29uc3QgcnBjRW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICAgICAgY29uc3QganNvblJwY0Nvbm5lY3Rpb24gPSBqc29uX3JwY19taWRkbGV3YXJlX3N0cmVhbV8xLmNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKTtcbiAgICAgICAgcHVtcF8xLmRlZmF1bHQoanNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLCBzdHJlYW1zLmNvbW1hbmQsIGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSk7XG4gICAgICAgIHJwY0VuZ2luZS5wdXNoKGpzb25ScGNDb25uZWN0aW9uLm1pZGRsZXdhcmUpO1xuICAgICAgICBjb25zdCB3b3JrZXJXcmFwcGVyID0ge1xuICAgICAgICAgICAgaWQ6IHdvcmtlcklkLFxuICAgICAgICAgICAgc3RyZWFtcyxcbiAgICAgICAgICAgIHJwY0VuZ2luZSxcbiAgICAgICAgICAgIHdvcmtlcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0V29ya2VyKHdvcmtlcklkLCB3b3JrZXJXcmFwcGVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29tbWFuZCh3b3JrZXJJZCwge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdwaW5nJyxcbiAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3b3JrZXJXcmFwcGVyO1xuICAgIH1cbiAgICBfaW5pdFdvcmtlclN0cmVhbXMod29ya2VyLCB3b3JrZXJJZCkge1xuICAgICAgICBjb25zdCB3b3JrZXJTdHJlYW0gPSBuZXcgcG9zdF9tZXNzYWdlX3N0cmVhbV8xLldvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtKHsgd29ya2VyIH0pO1xuICAgICAgICAvLyBUeXBlY2FzdCBqdXN0aWZpY2F0aW9uOiBzdHJlYW0gdHlwZSBtaXNtYXRjaFxuICAgICAgICBjb25zdCBtdXggPSBBYnN0cmFjdEV4ZWN1dGlvblNlcnZpY2VfMS5zZXR1cE11bHRpcGxleCh3b3JrZXJTdHJlYW0sIGBXb3JrZXI6JHt3b3JrZXJJZH1gKTtcbiAgICAgICAgY29uc3QgY29tbWFuZFN0cmVhbSA9IG11eC5jcmVhdGVTdHJlYW0oc25hcF93b3JrZXJzXzEuU05BUF9TVFJFQU1fTkFNRVMuQ09NTUFORCk7XG4gICAgICAgIGNvbnN0IHJwY1N0cmVhbSA9IG11eC5jcmVhdGVTdHJlYW0oc25hcF93b3JrZXJzXzEuU05BUF9TVFJFQU1fTkFNRVMuSlNPTl9SUEMpO1xuICAgICAgICAvLyBUeXBlY2FzdDogc3RyZWFtIHR5cGUgbWlzbWF0Y2hcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRTdHJlYW0sXG4gICAgICAgICAgICBycGM6IHJwY1N0cmVhbSxcbiAgICAgICAgICAgIF9jb25uZWN0aW9uOiB3b3JrZXJTdHJlYW0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5XZWJXb3JrZXJFeGVjdXRpb25TZXJ2aWNlID0gV2ViV29ya2VyRXhlY3V0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYldvcmtlckV4ZWN1dGlvblNlcnZpY2UuanMubWFwIiwiaW1wb3J0IGFkZEV0aGVyZXVtQ2hhaW4gZnJvbSAnLi9hZGQtZXRoZXJldW0tY2hhaW4nO1xuaW1wb3J0IGV0aEFjY291bnRzIGZyb20gJy4vZXRoLWFjY291bnRzJztcbmltcG9ydCBnZXRQcm92aWRlclN0YXRlIGZyb20gJy4vZ2V0LXByb3ZpZGVyLXN0YXRlJztcbmltcG9ydCBsb2dXZWIzU2hpbVVzYWdlIGZyb20gJy4vbG9nLXdlYjMtc2hpbS11c2FnZSc7XG5pbXBvcnQgcmVxdWVzdEFjY291bnRzIGZyb20gJy4vcmVxdWVzdC1hY2NvdW50cyc7XG5pbXBvcnQgc2VuZE1ldGFkYXRhIGZyb20gJy4vc2VuZC1tZXRhZGF0YSc7XG5pbXBvcnQgc3dpdGNoRXRoZXJldW1DaGFpbiBmcm9tICcuL3N3aXRjaC1ldGhlcmV1bS1jaGFpbic7XG5pbXBvcnQgd2F0Y2hBc3NldCBmcm9tICcuL3dhdGNoLWFzc2V0JztcblxuY29uc3QgaGFuZGxlcnMgPSBbXG4gIGFkZEV0aGVyZXVtQ2hhaW4sXG4gIGV0aEFjY291bnRzLFxuICBnZXRQcm92aWRlclN0YXRlLFxuICBsb2dXZWIzU2hpbVVzYWdlLFxuICByZXF1ZXN0QWNjb3VudHMsXG4gIHNlbmRNZXRhZGF0YSxcbiAgc3dpdGNoRXRoZXJldW1DaGFpbixcbiAgd2F0Y2hBc3NldCxcbl07XG5leHBvcnQgZGVmYXVsdCBoYW5kbGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWxlY3RIb29rcyA9IGV4cG9ydHMucmVzdHJpY3RlZE1ldGhvZFBlcm1pc3Npb25CdWlsZGVycyA9IGV4cG9ydHMucGVybWl0dGVkTWV0aG9kcyA9IHZvaWQgMDtcbnZhciBwZXJtaXR0ZWRfMSA9IHJlcXVpcmUoXCIuL3Blcm1pdHRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBlcm1pdHRlZE1ldGhvZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcm1pdHRlZF8xLmhhbmRsZXJzOyB9IH0pO1xudmFyIHJlc3RyaWN0ZWRfMSA9IHJlcXVpcmUoXCIuL3Jlc3RyaWN0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXN0cmljdGVkTWV0aG9kUGVybWlzc2lvbkJ1aWxkZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXN0cmljdGVkXzEuYnVpbGRlcnM7IH0gfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0SG9va3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuc2VsZWN0SG9va3M7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzU3RyZWFtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db21wb3NlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NZXJnZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYy11ci1yZWdpc3RyeS1ldGguY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmFzZS1ldGgta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBmb3JtYXRUeE1ldGFGb3JScGNSZXN1bHQgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdOb25jZU1pZGRsZXdhcmUoeyBnZXRQZW5kaW5nTm9uY2UgfSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IHJlcTtcbiAgICBpZiAobWV0aG9kICE9PSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJhbSwgYmxvY2tSZWZdID0gcGFyYW1zO1xuICAgIGlmIChibG9ja1JlZiAhPT0gJ3BlbmRpbmcnKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRQZW5kaW5nTm9uY2UocGFyYW0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdUeE1pZGRsZXdhcmUoeyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25CeUhhc2ggfSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IHJlcTtcbiAgICBpZiAobWV0aG9kICE9PSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJykge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbaGFzaF0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHhNZXRhID0gZ2V0UGVuZGluZ1RyYW5zYWN0aW9uQnlIYXNoKGhhc2gpO1xuICAgIGlmICghdHhNZXRhKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcy5yZXN1bHQgPSBmb3JtYXRUeE1ldGFGb3JScGNSZXN1bHQodHhNZXRhKTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9nZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIEtleVZhbHVlU3RvcmUgPSByZXF1aXJlKCcuL2tleVZhbHVlU3RvcmUnKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pbmRleCcpO1xuXG52YXIgRU5DX0JMT0NLX1NJWkUgPSAyNDtcblxudmFyIFByaXZhdGVTdG9yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0tleVZhbHVlU3RvcmUpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShQcml2YXRlU3RvcmUsIF9LZXlWYWx1ZVN0b3JlKTtcblxuICBmdW5jdGlvbiBQcml2YXRlU3RvcmUob3JiaXRkYiwgbmFtZSwgZW5zdXJlQ29ubmVjdGVkLCBfM2lkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQcml2YXRlU3RvcmUpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlKS5jYWxsKHRoaXMsIG9yYml0ZGIsIG5hbWUsIGVuc3VyZUNvbm5lY3RlZCwgXzNpZCkpO1xuICAgIF90aGlzLmtleXJpbmcgPSBfM2lkLmdldEtleXJpbmdCeVNwYWNlTmFtZShuYW1lKTtcbiAgICBfdGhpcy5fc2FsdCA9IF90aGlzLmtleXJpbmcuZ2V0REJTYWx0KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQcml2YXRlU3RvcmUsIFt7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShrZXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2dldDNbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZS5wcm90b3R5cGUpLCBcImdldFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuX2dlbkRiS2V5KGtleSksIG9wdHMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBlbnRyeSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX29iamVjdFNwcmVhZCh7fSwgZW50cnksIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9kZWNyeXB0RW50cnkoZW50cnkudmFsdWUpXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RlY3J5cHRFbnRyeShlbnRyeSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94KSB7XG4gICAgICAgIHJldHVybiBfZ2V0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldE1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0TWV0YWRhdGEgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfZ2V0M1tcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLnByb3RvdHlwZSksIFwiZ2V0TWV0YWRhdGFcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLl9nZW5EYktleShrZXkpKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKF94Mikge1xuICAgICAgICByZXR1cm4gX2dldE1ldGFkYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRNZXRhZGF0YTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2VuY3J5cHRFbnRyeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5fZ2VuRGJLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCAoMCwgX2dldDNbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0KF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TXVsdGlwbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRNdWx0aXBsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRiS2V5cywgZW5jcnlwdGVkVmFsdWVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1dGlscy50aHJvd0lmTm90RXF1YWxMZW5BcnJheXMoa2V5cywgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICBkYktleXMgPSBrZXlzLm1hcCh0aGlzLl9nZW5EYktleSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZW5jcnlwdGVkVmFsdWVzID0gdmFsdWVzLm1hcCh0aGlzLl9lbmNyeXB0RW50cnksIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfZ2V0M1tcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLnByb3RvdHlwZSksIFwic2V0TXVsdGlwbGVcIiwgdGhpcykuY2FsbCh0aGlzLCBkYktleXMsIGVuY3J5cHRlZFZhbHVlcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDUsIF94Nikge1xuICAgICAgICByZXR1cm4gX3NldE11bHRpcGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRNdWx0aXBsZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuX2dlbkRiS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9nZXQzW1wiZGVmYXVsdFwiXSkoKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcml2YXRlU3RvcmUucHJvdG90eXBlKSwgXCJyZW1vdmVcIiwgdGhpcykuY2FsbCh0aGlzLCBrZXkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlKF94Nykge1xuICAgICAgICByZXR1cm4gX3JlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgdW5kZXJseWluZyBsb2cgZW50cmllcy4gSW4gbGluZWFyaXplZCBvcmRlciBhY2NvcmRpbmcgdG8gdGhlaXIgTGFtcG9ydCBjbG9ja3MuXG4gICAgICogVXNlZnVsIGZvciBnZW5lcmF0aW5nIGEgY29tcGxldGUgaGlzdG9yeSBvZiBhbGwgb3BlcmF0aW9ucyBvbiBzdG9yZS4gS2V5IGlzIGhhc2hlZCwgc28ga2V5IGlzXG4gICAgICogbm90IGF2YWlsYWJsZSBmcm9tIHRoZSBwcml2YXRlIHN0b3JlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlXG4gICAgICogIGNvbnN0IGxvZyA9IHN0b3JlLmxvZ1xuICAgICAqICBjb25zdCBlbnRyeSA9IGxvZ1swXVxuICAgICAqICBjb25zb2xlLmxvZyhlbnRyeSlcbiAgICAgKiAgLy8geyBvcDogJ1BVVCcsIGtleTogLi4uLiwgdmFsdWU6ICdCb3Rib3QnLCB0aW1lU3RhbXA6ICcxNTM4NTc1NDE2MDY4JyB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3Q+fSAgICAgQXJyYXkgb2Ygb3JkZXJlZCBsb2cgZW50cnkgb2JqZWN0c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbkRiS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5EYktleShrZXkpIHtcbiAgICAgIHV0aWxzLnRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG4gICAgICByZXR1cm4gdXRpbHMuc2hhMjU2TXVsdGloYXNoKHRoaXMuX3NhbHQgKyBrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5jcnlwdEVudHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmNyeXB0RW50cnkoZW50cnkpIHtcbiAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ0VudHJ5IHRvIGVuY3J5cHQgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIHRoaXMua2V5cmluZy5zeW1FbmNyeXB0KHRoaXMuX3BhZChKU09OLnN0cmluZ2lmeShlbnRyeSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY3J5cHRFbnRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjcnlwdEVudHJ5KF9yZWYpIHtcbiAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gX3JlZi5jaXBoZXJ0ZXh0LFxuICAgICAgICAgIG5vbmNlID0gX3JlZi5ub25jZTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuX3VucGFkKHRoaXMua2V5cmluZy5zeW1EZWNyeXB0KGNpcGhlcnRleHQsIG5vbmNlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcGFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWQodmFsKSB7XG4gICAgICB2YXIgYmxvY2tTaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBFTkNfQkxPQ0tfU0laRTtcbiAgICAgIHZhciBibG9ja0RpZmYgPSAoYmxvY2tTaXplIC0gdmFsLmxlbmd0aCAlIGJsb2NrU2l6ZSkgJSBibG9ja1NpemU7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsKS5jb25jYXQoJ1xcMCcucmVwZWF0KGJsb2NrRGlmZikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFkKHBhZGRlZCkge1xuICAgICAgcmV0dXJuIHBhZGRlZC5yZXBsYWNlKC9cXDArJC8sICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuICgwLCBfZ2V0M1tcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLnByb3RvdHlwZSksIFwibG9nXCIsIHRoaXMpLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwge1xuICAgICAgICAgIHZhbHVlOiBvYmoudmFsdWUgPyBfdGhpczIuX2RlY3J5cHRFbnRyeShvYmoudmFsdWUpIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUHJpdmF0ZVN0b3JlO1xufShLZXlWYWx1ZVN0b3JlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcml2YXRlU3RvcmU7IiwidmFyIGVuZ2luZSA9IHJlcXVpcmUoJy4uL3NyYy9zdG9yZS1lbmdpbmUnKVxuXG52YXIgc3RvcmFnZXMgPSByZXF1aXJlKCcuLi9zdG9yYWdlcy9hbGwnKVxudmFyIHBsdWdpbnMgPSBbcmVxdWlyZSgnLi4vcGx1Z2lucy9qc29uMicpXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZS5jcmVhdGVTdG9yZShzdG9yYWdlcywgcGx1Z2lucylcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBncmFwaFFMUmVxdWVzdCA9IHJlcXVpcmUoJ2dyYXBocWwtcmVxdWVzdCcpLnJlcXVlc3Q7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXgnKTtcblxudmFyIHZlcmlmaWVyID0gcmVxdWlyZSgnLi91dGlscy92ZXJpZmllcicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2lkJyksXG4gICAgaXNNdXBvcnRESUQgPSBfcmVxdWlyZS5pc011cG9ydERJRDtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLmpzJyk7XG5cbnZhciBHUkFQSFFMX1NFUlZFUl9VUkwgPSBjb25maWcuZ3JhcGhxbF9zZXJ2ZXJfdXJsO1xudmFyIFBST0ZJTEVfU0VSVkVSX1VSTCA9IGNvbmZpZy5wcm9maWxlX3NlcnZlcl91cmw7XG52YXIgQUREUkVTU19TRVJWRVJfVVJMID0gY29uZmlnLmFkZHJlc3Nfc2VydmVyX3VybDtcblxuZnVuY3Rpb24gZ2V0Um9vdFN0b3JlQWRkcmVzcyhfeCkge1xuICByZXR1cm4gX2dldFJvb3RTdG9yZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJvb3RTdG9yZUFkZHJlc3MoKSB7XG4gIF9nZXRSb290U3RvcmVBZGRyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGlkZW50aWZpZXIpIHtcbiAgICB2YXIgc2VydmVyVXJsLFxuICAgICAgICByZXMsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IEFERFJFU1NfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihzZXJ2ZXJVcmwgKyAnL29kYkFkZHJlc3MvJyArIGlkZW50aWZpZXIpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLmRhdGEucm9vdFN0b3JlQWRkcmVzcyk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Um9vdFN0b3JlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsaXN0U3BhY2VzKF94Mikge1xuICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xpc3RTcGFjZXMoKSB7XG4gIF9saXN0U3BhY2VzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhZGRyZXNzKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgc2VydmVyVXJsID0gX2FyZ3MyLmxlbmd0aCA+IDEgJiYgX2FyZ3MyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMV0gOiBQUk9GSUxFX1NFUlZFUl9VUkw7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE7XG5cbiAgICAgICAgICAgIGlmICghaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihzZXJ2ZXJVcmwgKyAnL2xpc3Qtc3BhY2VzP2RpZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuZmV0Y2hKc29uKHNlcnZlclVybCArICcvbGlzdC1zcGFjZXM/YWRkcmVzcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1sxLCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhY2UoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9nZXRTcGFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSAvLyBUT0RPIGNvbnN1bWVzIGFkZHJlc3Mgbm93LCBjb3VsZCBhbHNvIGdpdmUgcm9vdCBESUQgdG8gZ2V0IHNwYWNlIERJRFxuXG5cbmZ1bmN0aW9uIF9nZXRTcGFjZSgpIHtcbiAgX2dldFNwYWNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhZGRyZXNzLCBuYW1lKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX3JlZixcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGJsb2NrbGlzdCxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczMgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHNlcnZlclVybCA9IF9hcmdzMy5sZW5ndGggPiAyICYmIF9hcmdzM1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzJdIDogUFJPRklMRV9TRVJWRVJfVVJMO1xuICAgICAgICAgICAgX3JlZiA9IF9hcmdzMy5sZW5ndGggPiAzICYmIF9hcmdzM1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzNdIDoge30sIG1ldGFkYXRhID0gX3JlZi5tZXRhZGF0YSwgYmxvY2tsaXN0ID0gX3JlZi5ibG9ja2xpc3Q7XG5cbiAgICAgICAgICAgIGlmICghKGJsb2NrbGlzdCAmJiBibG9ja2xpc3QoYWRkcmVzcykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZXIgd2l0aCBcIi5jb25jYXQoYWRkcmVzcywgXCIgaXMgYmxvY2tlZFwiKSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3NwYWNlXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA1O1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFyYW1ldGVyOiBhZGRyZXNzIG9yIGRpZFxuICAgICAgICAgICAgaWYgKGlzTXVwb3J0RElEKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/ZGlkPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0gLy8gQWRkIG5hbWU6XG5cblxuICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQodXJsLCBcIiZuYW1lPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpKTsgLy8gQWRkIG1ldGFkYXRhOlxuXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQodXJsLCBcIiZtZXRhZGF0YT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfSAvLyBRdWVyeTpcbiAgICAgICAgICAgIC8vIHdlIGF3YWl0IGV4cGxpY2l0bHkgdG8gbWFrZSBzdXJlIHRoZSBlcnJvciBpcyBjYXRjaCdkIGluIHRoZSBjb3JyZWN0IHNjb3BlXG5cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5mZXRjaEpzb24odXJsKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDUpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzUsIDE0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U3BhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhY2VESUQoX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9nZXRTcGFjZURJRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3BhY2VESUQoKSB7XG4gIF9nZXRTcGFjZURJRCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWRkcmVzcywgc3BhY2UpIHtcbiAgICB2YXIgb3B0cyxcbiAgICAgICAgY29uZixcbiAgICAgICAgX2FyZ3M0ID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzNC5sZW5ndGggPiAyICYmIF9hcmdzNFsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M0WzJdIDoge307XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnKGFkZHJlc3MsIG9wdHMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY29uZiA9IF9jb250ZXh0NC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoISghY29uZi5zcGFjZXNbc3BhY2VdIHx8ICFjb25mLnNwYWNlc1tzcGFjZV0uRElEKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhcHByb3ByaWF0ZSBESUQgZm9yIGFkZHJlc3MgXCIuY29uY2F0KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGNvbmYuc3BhY2VzW3NwYWNlXS5ESUQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U3BhY2VESUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhyZWFkKF94NywgX3g4LCBfeDksIF94MTApIHtcbiAgcmV0dXJuIF9nZXRUaHJlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFRocmVhZCgpIHtcbiAgX2dldFRocmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoc3BhY2UsIG5hbWUsIGZpcnN0TW9kZXJhdG9yLCBtZW1iZXJzKSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHNlcnZlclVybCxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczUgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRzID0gX2FyZ3M1Lmxlbmd0aCA+IDQgJiYgX2FyZ3M1WzRdICE9PSB1bmRlZmluZWQgPyBfYXJnczVbNF0gOiB7fTtcbiAgICAgICAgICAgIHNlcnZlclVybCA9IG9wdHMucHJvZmlsZVNlcnZlciB8fCBQUk9GSUxFX1NFUlZFUl9VUkw7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3RNb2RlcmF0b3Iuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3BhY2VESUQoZmlyc3RNb2RlcmF0b3IsIHNwYWNlLCBvcHRzKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGZpcnN0TW9kZXJhdG9yID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDY7XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3RocmVhZD9zcGFjZT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzcGFjZSksIFwiJm5hbWU9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQobmFtZSkpO1xuICAgICAgICAgICAgdXJsICs9IFwiJm1vZD1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGZpcnN0TW9kZXJhdG9yKSwgXCImbWVtYmVycz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChtZW1iZXJzKSk7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih1cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDE0O1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oNik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgbnVsbCwgW1s2LCAxNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRUaHJlYWRCeUFkZHJlc3MoX3gxMSkge1xuICByZXR1cm4gX2dldFRocmVhZEJ5QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VGhyZWFkQnlBZGRyZXNzKCkge1xuICBfZ2V0VGhyZWFkQnlBZGRyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihhZGRyZXNzKSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHNlcnZlclVybCxcbiAgICAgICAgX2FyZ3M2ID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzNi5sZW5ndGggPiAxICYmIF9hcmdzNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzFdIDoge307XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBvcHRzLnByb2ZpbGVTZXJ2ZXIgfHwgUFJPRklMRV9TRVJWRVJfVVJMO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3RocmVhZD9hZGRyZXNzPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfY29udGV4dDYudDApO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCBudWxsLCBbWzIsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUaHJlYWRCeUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnKF94MTIpIHtcbiAgcmV0dXJuIF9nZXRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldENvbmZpZygpIHtcbiAgX2dldENvbmZpZyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoYWRkcmVzcykge1xuICAgIHZhciBvcHRzLFxuICAgICAgICBzZXJ2ZXJVcmwsXG4gICAgICAgIF9hcmdzNyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG9wdHMgPSBfYXJnczcubGVuZ3RoID4gMSAmJiBfYXJnczdbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzN1sxXSA6IHt9O1xuICAgICAgICAgICAgc2VydmVyVXJsID0gb3B0cy5wcm9maWxlU2VydmVyIHx8IFBST0ZJTEVfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5mZXRjaEpzb24oXCJcIi5jb25jYXQoc2VydmVyVXJsLCBcIi9jb25maWc/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKSkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQ3LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgbnVsbCwgW1syLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Q29uZmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2ZpbGUoX3gxMykge1xuICByZXR1cm4gX2dldFByb2ZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb2ZpbGUoKSB7XG4gIF9nZXRQcm9maWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChhZGRyZXNzKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX3JlZjIsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBibG9ja2xpc3QsXG4gICAgICAgIHVybCxcbiAgICAgICAgX2FyZ3M4ID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBfYXJnczgubGVuZ3RoID4gMSAmJiBfYXJnczhbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFsxXSA6IFBST0ZJTEVfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9yZWYyID0gX2FyZ3M4Lmxlbmd0aCA+IDIgJiYgX2FyZ3M4WzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczhbMl0gOiB7fSwgbWV0YWRhdGEgPSBfcmVmMi5tZXRhZGF0YSwgYmxvY2tsaXN0ID0gX3JlZjIuYmxvY2tsaXN0O1xuXG4gICAgICAgICAgICBpZiAoIShibG9ja2xpc3QgJiYgYmxvY2tsaXN0KGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VyIHdpdGggXCIuY29uY2F0KGFkZHJlc3MsIFwiIGlzIGJsb2NrZWRcIikpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQoc2VydmVyVXJsLCBcIi9wcm9maWxlXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSA1O1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFyYW1ldGVyOiBhZGRyZXNzIG9yIGRpZFxuICAgICAgICAgICAgaWYgKGlzTXVwb3J0RElEKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/ZGlkPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0gLy8gQWRkIG1ldGFkYXRhOlxuXG5cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdCh1cmwsIFwiJm1ldGFkYXRhPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9IC8vIFF1ZXJ5OlxuICAgICAgICAgICAgLy8gd2UgYXdhaXQgZXhwbGljaXRseSB0byBtYWtlIHN1cmUgdGhlIGVycm9yIGlzIGNhdGNoJ2QgaW4gdGhlIGNvcnJlY3Qgc2NvcGVcblxuXG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih1cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oNSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIG51bGwsIFtbNSwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm9maWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2ZpbGVzKF94MTQpIHtcbiAgcmV0dXJuIF9nZXRQcm9maWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvZmlsZXMoKSB7XG4gIF9nZXRQcm9maWxlcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoYWRkcmVzc0FycmF5KSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHJlcSxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczkgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRzID0gX2FyZ3M5Lmxlbmd0aCA+IDEgJiYgX2FyZ3M5WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczlbMV0gOiB7fTtcbiAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgcHJvZmlsZVNlcnZlcjogUFJPRklMRV9TRVJWRVJfVVJMXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgICAgYWRkcmVzc0xpc3Q6IFtdLFxuICAgICAgICAgICAgICBkaWRMaXN0OiBbXSAvLyBTcGxpdCBhZGRyZXNzZXMgb24gZXRoZXJldW0gLyBkaWRzXG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRyZXNzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICBpZiAoaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXEuZGlkTGlzdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcS5hZGRyZXNzTGlzdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KG9wdHMucHJvZmlsZVNlcnZlciwgXCIvcHJvZmlsZUxpc3RcIik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCB1dGlscy5mZXRjaEpzb24odXJsLCByZXEpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU5KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb2ZpbGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHByb2ZpbGVHcmFwaFFMKF94MTUpIHtcbiAgcmV0dXJuIF9wcm9maWxlR3JhcGhRTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcHJvZmlsZUdyYXBoUUwoKSB7XG4gIF9wcm9maWxlR3JhcGhRTCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHF1ZXJ5KSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIF9hcmdzMTAgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzMTAubGVuZ3RoID4gMSAmJiBfYXJnczEwWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczEwWzFdIDoge307XG4gICAgICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGdyYXBocWxTZXJ2ZXI6IEdSQVBIUUxfU0VSVkVSX1VSTFxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgZ3JhcGhRTFJlcXVlc3Qob3B0cy5ncmFwaHFsU2VydmVyLCBxdWVyeSkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wcm9maWxlR3JhcGhRTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJpZmllZEFjY291bnRzKF94MTYpIHtcbiAgcmV0dXJuIF9nZXRWZXJpZmllZEFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRWZXJpZmllZEFjY291bnRzKCkge1xuICBfZ2V0VmVyaWZpZWRBY2NvdW50cyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHByb2ZpbGUpIHtcbiAgICB2YXIgdmVyaWZzLCBkaWQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdmVyaWZzID0ge307XG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlESUQocHJvZmlsZS5wcm9vZl9kaWQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGlkID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgdmVyaWZzLmRpZCA9IGRpZDtcblxuICAgICAgICAgICAgaWYgKCFwcm9maWxlLnByb29mX2dpdGh1Yikge1xuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlHaXRodWIoZGlkLCBwcm9maWxlLnByb29mX2dpdGh1Yik7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgdmVyaWZzLmdpdGh1YiA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDExLnQwID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDcpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGlmICghcHJvZmlsZS5wcm9vZl90d2l0dGVyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxOTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlUd2l0dGVyKGRpZCwgcHJvZmlsZS5wcm9vZl90d2l0dGVyKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICB2ZXJpZnMudHdpdHRlciA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMjI7XG4gICAgICAgICAgICBfY29udGV4dDExLnQxID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDE2KTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBpZiAoIXByb2ZpbGUuZXRoZXJldW1fcHJvb2YpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAyNTtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI4O1xuICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVyLnZlcmlmeUV0aGVyZXVtKHByb2ZpbGUuZXRoZXJldW1fcHJvb2YsIGRpZCk7XG5cbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgdmVyaWZzLmV0aGVyZXVtID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMzM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAzMTtcbiAgICAgICAgICAgIF9jb250ZXh0MTEudDIgPSBfY29udGV4dDExW1wiY2F0Y2hcIl0oMjUpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMzU7XG4gICAgICAgICAgICBfY29udGV4dDExLnQzID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB2ZXJpZnMpO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTEsIG51bGwsIFtbMSwgMzVdLCBbNywgMTNdLCBbMTYsIDIyXSwgWzI1LCAzMV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFZlcmlmaWVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByb2ZpbGVHcmFwaFFMOiBwcm9maWxlR3JhcGhRTCxcbiAgZ2V0UHJvZmlsZTogZ2V0UHJvZmlsZSxcbiAgZ2V0U3BhY2U6IGdldFNwYWNlLFxuICBsaXN0U3BhY2VzOiBsaXN0U3BhY2VzLFxuICBnZXRUaHJlYWQ6IGdldFRocmVhZCxcbiAgZ2V0VGhyZWFkQnlBZGRyZXNzOiBnZXRUaHJlYWRCeUFkZHJlc3MsXG4gIGdldENvbmZpZzogZ2V0Q29uZmlnLFxuICBnZXRSb290U3RvcmVBZGRyZXNzOiBnZXRSb290U3RvcmVBZGRyZXNzLFxuICBnZXRQcm9maWxlczogZ2V0UHJvZmlsZXMsXG4gIGdldFZlcmlmaWVkQWNjb3VudHM6IGdldFZlcmlmaWVkQWNjb3VudHMsXG4gIGdldFNwYWNlRElEOiBnZXRTcGFjZURJRFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIEtleVZhbHVlU3RvcmUgPSByZXF1aXJlKCcuL2tleVZhbHVlU3RvcmUnKTtcblxudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4vdGhyZWFkJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICBzaGEyNTZNdWx0aWhhc2ggPSBfcmVxdWlyZS5zaGEyNTZNdWx0aWhhc2gsXG4gICAgdGhyb3dJZlVuZGVmaW5lZCA9IF9yZXF1aXJlLnRocm93SWZVbmRlZmluZWQsXG4gICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzID0gX3JlcXVpcmUudGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzO1xuXG52YXIgT3JiaXREQkFkZHJlc3MgPSByZXF1aXJlKCdvcmJpdC1kYi9zcmMvb3JiaXQtZGItYWRkcmVzcycpO1xuXG52YXIgRU5DX0JMT0NLX1NJWkUgPSAyNDtcblxudmFyIG5hbWVUb1NwYWNlTmFtZSA9IGZ1bmN0aW9uIG5hbWVUb1NwYWNlTmFtZShuYW1lKSB7XG4gIHJldHVybiBcIjNib3guc3BhY2UuXCIuY29uY2F0KG5hbWUsIFwiLmtleXZhbHVlXCIpO1xufTtcblxudmFyIG5hbWVzVG90aHJlYWROYW1lID0gZnVuY3Rpb24gbmFtZXNUb3RocmVhZE5hbWUoc3BhY2VOYW1lLCB0aHJlYWROYW1lKSB7XG4gIHJldHVybiBcIjNib3gudGhyZWFkLlwiLmNvbmNhdChzcGFjZU5hbWUsIFwiLlwiKS5jb25jYXQodGhyZWFkTmFtZSk7XG59O1xuXG52YXIgU3BhY2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUGxlYXNlIHVzZSAqKmJveC5vcGVuU3BhY2UqKiB0byBnZXQgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIFNwYWNlKG5hbWUsIHRocmVlSWQsIG9yYml0ZGIsIHJvb3RTdG9yZSwgZW5zdXJlQ29ubmVjdGVkKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTcGFjZSk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fM2lkID0gdGhyZWVJZDtcbiAgICB0aGlzLl9lbnN1cmVDb25uZWN0ZWQgPSBlbnN1cmVDb25uZWN0ZWQ7XG4gICAgdGhpcy5fc3RvcmUgPSBuZXcgS2V5VmFsdWVTdG9yZShvcmJpdGRiLCBuYW1lVG9TcGFjZU5hbWUodGhpcy5fbmFtZSksIHRoaXMuX2Vuc3VyZUNvbm5lY3RlZCwgdGhpcy5fM2lkKTtcbiAgICB0aGlzLl9vcmJpdGRiID0gb3JiaXRkYjtcbiAgICB0aGlzLl9hY3RpdmVUaHJlYWRzID0ge307XG4gICAgdGhpcy5fcm9vdFN0b3JlID0gcm9vdFN0b3JlO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7S2V5VmFsdWVTdG9yZX0gcHVibGljICAgICAgICAgYWNjZXNzIHRoZSBwcm9maWxlIHN0b3JlIG9mIHRoZSBzcGFjZVxuICAgICAqL1xuXG4gICAgdGhpc1tcInB1YmxpY1wiXSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtLZXlWYWx1ZVN0b3JlfSBwcml2YXRlICAgICAgICBhY2Nlc3MgdGhlIHByaXZhdGUgc3RvcmUgb2YgdGhlIHNwYWNlXG4gICAgICovXG5cbiAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBESUQgICAgICAgIHRoZSBkaWQgb2YgdGhlIHVzZXIgaW4gdGhpcyBzcGFjZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU3BhY2UsIFt7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgY29uc2VudE5lZWRlZCxcbiAgICAgICAgICAgIHNwYWNlQWRkcmVzcyxcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIGhhc051bUVudHJpZXMsXG4gICAgICAgICAgICBudW1FbnRyaWVzLFxuICAgICAgICAgICAgc3luY1NwYWNlLFxuICAgICAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyLmxlbmd0aCA+IDAgJiYgX2FyZ3MyWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9yZS5fZGIpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5pbml0S2V5cmluZ0J5TmFtZSh0aGlzLl9uYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY29uc2VudE5lZWRlZCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNvbnNlbnRDYWxsYmFjaykgb3B0cy5jb25zZW50Q2FsbGJhY2soY29uc2VudE5lZWRlZCwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5fbG9hZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzcGFjZUFkZHJlc3MgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgZW50cmllcyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnBheWxvYWQudmFsdWUub2RiQWRkcmVzcyAmJiBlbnRyeS5wYXlsb2FkLnZhbHVlLm9kYkFkZHJlc3MuaW5kZXhPZihuYW1lVG9TcGFjZU5hbWUoX3RoaXMuX25hbWUpKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgICBESUQ6IHRoaXMuRElELFxuICAgICAgICAgICAgICAgICAgb2RiQWRkcmVzczogc3BhY2VBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnBheWxvYWQudmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5kZWwoZW50cnkuaGFzaCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgICBESUQ6IHRoaXMuRElELFxuICAgICAgICAgICAgICAgICAgb2RiQWRkcmVzczogc3BhY2VBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICBoYXNOdW1FbnRyaWVzID0gb3B0cy5udW1FbnRyaWVzTWVzc2FnZXMgJiYgb3B0cy5udW1FbnRyaWVzTWVzc2FnZXNbc3BhY2VBZGRyZXNzXTtcbiAgICAgICAgICAgICAgICBudW1FbnRyaWVzID0gaGFzTnVtRW50cmllcyA/IG9wdHMubnVtRW50cmllc01lc3NhZ2VzW3NwYWNlQWRkcmVzc10ubnVtRW50cmllcyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHN5bmNTcGFjZSA9XG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zdG9yZS5fc3luYyhudW1FbnRyaWVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMub25TeW5jRG9uZSkgb3B0cy5vblN5bmNEb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3luY1NwYWNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zeW5jU3BhY2VQcm9taXNlID0gc3luY1NwYWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpc1tcInB1YmxpY1wiXSA9IHB1YmxpY1N0b3JlUmVkdWNlcih0aGlzLl9zdG9yZSk7XG4gICAgICAgICAgICAgICAgdGhpc1tcInByaXZhdGVcIl0gPSBwcml2YXRlU3RvcmVSZWR1Y2VyKHRoaXMuX3N0b3JlLCB0aGlzLl8zaWQuZ2V0S2V5cmluZ0J5U3BhY2VOYW1lKG5hbWVUb1NwYWNlTmFtZSh0aGlzLl9uYW1lKSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIF9vcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcGVuO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEpvaW4gYSB0aHJlYWQuIFVzZSB0aGlzIHRvIHN0YXJ0IHJlY2VpdmluZyB1cGRhdGVzIGZyb20sIGFuZCB0byBwb3N0IGluIHRocmVhZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgbmFtZSAgICAgICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRocmVhZFxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5maXJzdE1vZGVyYXRvciAgICAgRElEIG9mIGZpcnN0IG1vZGVyYXRvciBvZiBhIHRocmVhZCwgYnkgZGVmYXVsdCwgdXNlciBpcyBmaXJzdCBtb2RlcmF0b3JcbiAgICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubWVtYmVycyAgICAgICAgICAgIGpvaW4gYSBtZW1iZXJzIG9ubHkgdGhyZWFkLCB3aGljaCBvbmx5IG1lbWJlcnMgY2FuIHBvc3QgaW4sIGRlZmF1bHRzIHRvIG9wZW4gdGhyZWFkXG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLm5vQXV0b1N1YiAgICAgICAgICBEaXNhYmxlIGF1dG8gc3Vic2NyaXB0aW9uIHRvIHRoZSB0aHJlYWQgd2hlbiBwb3N0aW5nIHRvIGl0IChkZWZhdWx0IGZhbHNlKVxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7VGhyZWFkfSAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgdGhyZWFkIGNsYXNzIGZvciB0aGUgam9pbmVkIHRocmVhZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2pvaW5UaHJlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIHN1YnNjcmliZUZuLFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMy5sZW5ndGggPiAxICYmIF9hcmdzM1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzFdIDoge307XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlRm4gPSBvcHRzLm5vQXV0b1N1YiA/IGZ1bmN0aW9uICgpIHt9IDogdGhpcy5zdWJzY3JpYmVUaHJlYWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMuZmlyc3RNb2RlcmF0b3IpIG9wdHMuZmlyc3RNb2RlcmF0b3IgPSB0aGlzLl8zaWQuZ2V0U3ViRElEKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIHRocmVhZCA9IG5ldyBUaHJlYWQodGhpcy5fb3JiaXRkYiwgbmFtZXNUb3RocmVhZE5hbWUodGhpcy5fbmFtZSwgbmFtZSksIHRoaXMuXzNpZCwgb3B0cy5tZW1iZXJzLCBvcHRzLmZpcnN0TW9kZXJhdG9yLCBzdWJzY3JpYmVGbiwgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocmVhZC5fZ2V0VGhyZWFkQWRkcmVzcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10pO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJlYWQuX2xvYWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10gPSB0aHJlYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhyZWFkKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGpvaW5UaHJlYWQoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9qb2luVGhyZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqb2luVGhyZWFkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEpvaW4gYSB0aHJlYWQgYnkgZnVsbCB0aHJlYWQgYWRkcmVzcy4gVXNlIHRoaXMgdG8gc3RhcnQgcmVjZWl2aW5nIHVwZGF0ZXMgZnJvbSwgYW5kIHRvIHBvc3QgaW4gdGhyZWFkc1xuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgZnVsbCBhZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubm9BdXRvU3ViICAgICAgICAgIERpc2FibGUgYXV0byBzdWJzY3JpcHRpb24gdG8gdGhlIHRocmVhZCB3aGVuIHBvc3RpbmcgdG8gaXQgKGRlZmF1bHQgZmFsc2UpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtUaHJlYWR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSB0aHJlYWQgY2xhc3MgZm9yIHRoZSBqb2luZWQgdGhyZWFkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJqb2luVGhyZWFkQnlBZGRyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfam9pblRocmVhZEJ5QWRkcmVzcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgdGhyZWFkU3BhY2UsXG4gICAgICAgICAgICB0aHJlYWROYW1lLFxuICAgICAgICAgICAgc3Vic2NyaWJlRm4sXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBfYXJnczQgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczQubGVuZ3RoID4gMSAmJiBfYXJnczRbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNFsxXSA6IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKE9yYml0REJBZGRyZXNzLmlzVmFsaWQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pblRocmVhZEJ5QWRkcmVzczogdmFsaWQgb3JiaXRkYiBhZGRyZXNzIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRocmVhZFNwYWNlID0gYWRkcmVzcy5zcGxpdCgnLicpWzJdO1xuICAgICAgICAgICAgICAgIHRocmVhZE5hbWUgPSBhZGRyZXNzLnNwbGl0KCcuJylbM107XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aHJlYWRTcGFjZSAhPT0gdGhpcy5fbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pblRocmVhZEJ5QWRkcmVzczogYXR0ZW1wdGluZyB0byBvcGVuIHRocmVhZCBmcm9tIGRpZmZlcmVudCBzcGFjZSwgbXVzdCBvcGVuIHdpdGhpbiBzYW1lIHNwYWNlJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlVGhyZWFkc1thZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWN0aXZlVGhyZWFkc1thZGRyZXNzXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHN1YnNjcmliZUZuID0gb3B0cy5ub0F1dG9TdWIgPyBmdW5jdGlvbiAoKSB7fSA6IHRoaXMuc3Vic2NyaWJlVGhyZWFkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhyZWFkID0gbmV3IFRocmVhZCh0aGlzLl9vcmJpdGRiLCBuYW1lc1RvdGhyZWFkTmFtZSh0aGlzLl9uYW1lLCB0aHJlYWROYW1lKSwgdGhpcy5fM2lkLCBvcHRzLm1lbWJlcnMsIG9wdHMuZmlyc3RNb2RlcmF0b3IsIHN1YnNjcmliZUZuLCB0aGlzLl9lbnN1cmVDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocmVhZC5fbG9hZChhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10gPSB0aHJlYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhyZWFkKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGpvaW5UaHJlYWRCeUFkZHJlc3MoX3gyKSB7XG4gICAgICAgIHJldHVybiBfam9pblRocmVhZEJ5QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gam9pblRocmVhZEJ5QWRkcmVzcztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGdpdmVuIHRocmVhZCwgaWYgbm90IGFscmVhZHkgc3Vic2NyaWJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgIFRoZSBhZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIGNvbmZpZyAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uIGFuZCB0aHJlYWQgbWV0YSBkYXRhXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLm5hbWUgICAgICAgICAgICAgTmFtZSBvZiB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZmlyc3RNb2RlcmF0b3IgICBESUQgb2YgdGhlIGZpcnN0IG1vZGVyYXRvclxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZW1iZXJzICAgICAgICAgIEJvb2xlYW4gc3RyaW5nLCB0cnVlIGlmIGEgbWVtYmVycyBvbmx5IHRocmVhZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlVGhyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3Vic2NyaWJlVGhyZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGNvbmZpZyxcbiAgICAgICAgICAgIHRocmVhZEtleSxcbiAgICAgICAgICAgIF9hcmdzNSA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uZmlnID0gX2FyZ3M1Lmxlbmd0aCA+IDEgJiYgX2FyZ3M1WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczVbMV0gOiB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChPcmJpdERCQWRkcmVzcy5pc1ZhbGlkKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZVRocmVhZDogbXVzdCBzdWJzY3JpYmUgdG8gdmFsaWQgdGhyZWFkL29yYml0ZGIgYWRkcmVzcycpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aHJlYWRLZXkgPSBcInRocmVhZC1cIi5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zeW5jU3BhY2VQcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uZ2V0KHRocmVhZEtleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDUuc2VudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uc2V0KHRocmVhZEtleSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlVGhyZWFkKF94Mykge1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZVRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaWJlVGhyZWFkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIHRocmVhZCwgaWYgc3Vic2NyaWJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICBUaGUgYWRkcmVzcyBvZiB0aGUgdGhyZWFkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnN1YnNjcmliZVRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Vuc3Vic2NyaWJlVGhyZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIHRocmVhZEtleTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyZWFkS2V5ID0gXCJ0aHJlYWQtXCIuY29uY2F0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tcInB1YmxpY1wiXS5nZXQodGhyZWFkS2V5KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dDYuc2VudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1wicHVibGljXCJdLnJlbW92ZSh0aHJlYWRLZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZVRocmVhZChfeDQpIHtcbiAgICAgICAgcmV0dXJuIF91bnN1YnNjcmliZVRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmVUaHJlYWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIHRocmVhZHMgc3Vic2NyaWJlZCB0byBpbiB0aGlzIHNwYWNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3RzPn0gICAgQSBsaXN0IG9mIHRocmVhZCBvYmplY3RzIGFzIHsgYWRkcmVzcywgZmlyc3RNb2RlcmF0b3IsIG1lbWJlcnMsIG5hbWV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVkVGhyZWFkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N1YnNjcmliZWRUaHJlYWRzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KCkge1xuICAgICAgICB2YXIgYWxsRW50cmllcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1wicHVibGljXCJdLmFsbCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhbGxFbnRyaWVzID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmtleXMoYWxsRW50cmllcykucmVkdWNlKGZ1bmN0aW9uICh0aHJlYWRzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgndGhyZWFkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlcyBleHBlcmltZW50YWwgdGhyZWFkcyAodjEpXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzID0ga2V5LnNwbGl0KCd0aHJlYWQtJylbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9yYml0REJBZGRyZXNzLmlzVmFsaWQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRzLnB1c2goYWxsRW50cmllc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhyZWFkcztcbiAgICAgICAgICAgICAgICB9LCBbXSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmVkVGhyZWFkcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmVkVGhyZWFkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaWJlZFRocmVhZHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiRElEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fM2lkLmdldFN1YkRJRCh0aGlzLl9uYW1lKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNwYWNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlO1xuXG52YXIgcHVibGljU3RvcmVSZWR1Y2VyID0gZnVuY3Rpb24gcHVibGljU3RvcmVSZWR1Y2VyKHN0b3JlKSB7XG4gIHZhciBQUkVGSVggPSAncHViXyc7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChrZXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczgubGVuZ3RoID4gMSAmJiBfYXJnczhbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFsxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLmdldChQUkVGSVggKyBrZXksIG9wdHMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94NSkge1xuICAgICAgICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0O1xuICAgIH0oKSxcbiAgICBnZXRNZXRhZGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRNZXRhZGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuZ2V0TWV0YWRhdGEoUFJFRklYICsga2V5KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKF94Nikge1xuICAgICAgICByZXR1cm4gX2dldE1ldGFkYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRNZXRhZGF0YTtcbiAgICB9KCksXG4gICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZlVuZGVmaW5lZChrZXksICdrZXknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuc2V0KFBSRUZJWCArIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTApO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXQoX3g3LCBfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9KCksXG4gICAgc2V0TXVsdGlwbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0TXVsdGlwbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgcHJlZml4ZWRLZXlzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcHJlZml4ZWRLZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFBSRUZJWCArIGtleTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuc2V0TXVsdGlwbGUocHJlZml4ZWRLZXlzLCB2YWx1ZXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDksIF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9zZXRNdWx0aXBsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0TXVsdGlwbGU7XG4gICAgfSgpLFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZlVuZGVmaW5lZChrZXksICdrZXknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUucmVtb3ZlKFBSRUZJWCArIGtleSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZShfeDExKSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfSgpLFxuXG4gICAgZ2V0IGxvZygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5sb2cucmVkdWNlKGZ1bmN0aW9uIChuZXdMb2csIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgZW50cnkua2V5ID0gZW50cnkua2V5LnNsaWNlKDQpO1xuICAgICAgICAgIG5ld0xvZy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdMb2c7XG4gICAgICB9LCBbXSk7XG4gICAgfSxcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hbGwgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKG9wdHMpIHtcbiAgICAgICAgdmFyIGVudHJpZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5hbGwob3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDEzLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5rZXlzKGVudHJpZXMpLnJlZHVjZShmdW5jdGlvbiAobmV3QWxsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FsbFtrZXkuc2xpY2UoNCldID0gZW50cmllc1trZXldO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3QWxsO1xuICAgICAgICAgICAgICAgIH0sIHt9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWxsKF94MTIpIHtcbiAgICAgICAgcmV0dXJuIF9hbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9KClcbiAgfTtcbn07XG5cbnZhciBwcml2YXRlU3RvcmVSZWR1Y2VyID0gZnVuY3Rpb24gcHJpdmF0ZVN0b3JlUmVkdWNlcihzdG9yZSwga2V5cmluZykge1xuICB2YXIgUFJFRklYID0gJ3ByaXZfJztcbiAgdmFyIFNBTFQgPSBrZXlyaW5nLmdldERCU2FsdCgpO1xuXG4gIHZhciBkYktleSA9IGZ1bmN0aW9uIGRiS2V5KGtleSkge1xuICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG4gICAgcmV0dXJuIFBSRUZJWCArIHNoYTI1Nk11bHRpaGFzaChTQUxUICsga2V5KTtcbiAgfTtcblxuICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKHZhbCkge1xuICAgIHZhciBibG9ja1NpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEVOQ19CTE9DS19TSVpFO1xuICAgIHZhciBibG9ja0RpZmYgPSAoYmxvY2tTaXplIC0gdmFsLmxlbmd0aCAlIGJsb2NrU2l6ZSkgJSBibG9ja1NpemU7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbCkuY29uY2F0KCdcXDAnLnJlcGVhdChibG9ja0RpZmYpKTtcbiAgfTtcblxuICB2YXIgdW5wYWQgPSBmdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgICByZXR1cm4gcGFkZGVkLnJlcGxhY2UoL1xcMCskLywgJycpO1xuICB9O1xuXG4gIHZhciBlbmNyeXB0RW50cnkgPSBmdW5jdGlvbiBlbmNyeXB0RW50cnkoZW50cnkpIHtcbiAgICByZXR1cm4ga2V5cmluZy5zeW1FbmNyeXB0KHBhZChKU09OLnN0cmluZ2lmeShlbnRyeSkpKTtcbiAgfTtcblxuICB2YXIgZGVjcnlwdEVudHJ5ID0gZnVuY3Rpb24gZGVjcnlwdEVudHJ5KF9yZWYyKSB7XG4gICAgdmFyIGNpcGhlcnRleHQgPSBfcmVmMi5jaXBoZXJ0ZXh0LFxuICAgICAgICBub25jZSA9IF9yZWYyLm5vbmNlO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHVucGFkKGtleXJpbmcuc3ltRGVjcnlwdChjaXBoZXJ0ZXh0LCBub25jZSkpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChrZXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIF9hcmdzMTQgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE0JChfY29udGV4dDE0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxNC5sZW5ndGggPiAxICYmIF9hcmdzMTRbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTRbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5nZXQoZGJLZXkoa2V5KSwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVudHJ5ID0gX2NvbnRleHQxNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgX29iamVjdFNwcmVhZCh7fSwgZW50cnksIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNyeXB0RW50cnkoZW50cnkudmFsdWUpLnZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGVjcnlwdEVudHJ5KGVudHJ5KS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE0KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSgpLFxuICAgIGdldE1ldGFkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1ldGFkYXRhMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNS5wcmV2ID0gX2NvbnRleHQxNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuZ2V0TWV0YWRhdGEoZGJLZXkoa2V5KSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKF94MTQpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRNZXRhZGF0YTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldE1ldGFkYXRhO1xuICAgIH0oKSxcbiAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLnNldChkYktleShrZXkpLCBlbmNyeXB0RW50cnkoe1xuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldChfeDE1LCBfeDE2KSB7XG4gICAgICAgIHJldHVybiBfc2V0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0oKSxcbiAgICBzZXRNdWx0aXBsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRNdWx0aXBsZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE3KGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGJLZXlzLCBlbmNyeXB0ZWRFbnRyaWVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZGJLZXlzID0ga2V5cy5tYXAoZGJLZXkpO1xuICAgICAgICAgICAgICAgIGVuY3J5cHRlZEVudHJpZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0RW50cnkoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCBzdG9yZS5zZXRNdWx0aXBsZShkYktleXMsIGVuY3J5cHRlZEVudHJpZXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTcpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDE3LCBfeDE4KSB7XG4gICAgICAgIHJldHVybiBfc2V0TXVsdGlwbGUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRNdWx0aXBsZTtcbiAgICB9KCksXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbW92ZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE4KGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLnJlbW92ZShkYktleShrZXkpKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE4KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlKF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfSgpLFxuXG4gICAgZ2V0IGxvZygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5sb2cucmVkdWNlKGZ1bmN0aW9uIChuZXdMb2csIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgdmFyIGRlY0VudHJ5ID0gZGVjcnlwdEVudHJ5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICBlbnRyeS5rZXkgPSBkZWNFbnRyeS5rZXk7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSBkZWNFbnRyeS52YWx1ZTtcbiAgICAgICAgICBuZXdMb2cucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3TG9nO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWxsMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkoKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIF9hcmdzMTkgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE5JChfY29udGV4dDE5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOS5wcmV2ID0gX2NvbnRleHQxOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxOS5sZW5ndGggPiAwICYmIF9hcmdzMTlbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTlbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5hbGwob3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDE5LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5rZXlzKGVudHJpZXMpLnJlZHVjZShmdW5jdGlvbiAobmV3QWxsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNFbnRyeSA9IGRlY3J5cHRFbnRyeShlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3QWxsW2RlY0VudHJ5LmtleV0gPSBfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlY0VudHJ5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWNFbnRyeSA9IGRlY3J5cHRFbnRyeShlbnRyeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBuZXdBbGxbX2RlY0VudHJ5LmtleV0gPSBfZGVjRW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FsbDtcbiAgICAgICAgICAgICAgICB9LCB7fSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGwyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSgpXG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBmZXRjaCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmZldGNoIDogcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuXG52YXIgTXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKTtcblxudmFyIHNoYTI1NiA9IHJlcXVpcmUoJ2pzLXNoYTI1NicpLnNoYTI1NjtcblxudmFyIGV0aGVycyA9IHJlcXVpcmUoJ2V0aGVycycpO1xuXG52YXIgSFRUUEVycm9yID0gZnVuY3Rpb24gSFRUUEVycm9yKHN0YXR1cywgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZS5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICByZXR1cm4gZTtcbn07XG5cbnZhciBnZXRNZXNzYWdlQ29uc2VudCA9IGZ1bmN0aW9uIGdldE1lc3NhZ2VDb25zZW50KGRpZCwgdGltZXN0YW1wKSB7XG4gIHZhciBtc2cgPSAnQ3JlYXRlIGEgbmV3IDNCb3ggcHJvZmlsZScgKyAnXFxuXFxuJyArICctIFxcbicgKyAnWW91ciB1bmlxdWUgcHJvZmlsZSBJRCBpcyAnICsgZGlkO1xuICBpZiAodGltZXN0YW1wKSBtc2cgKz0gJyBcXG4nICsgJ1RpbWVzdGFtcDogJyArIHRpbWVzdGFtcDtcbiAgcmV0dXJuIG1zZztcbn07XG5cbnZhciBzYWZlRXRoU2VuZCA9IGZ1bmN0aW9uIHNhZmVFdGhTZW5kKGV0aGVyZXVtLCBkYXRhLCBjYWxsYmFjaykge1xuICB2YXIgc2VuZCA9IChCb29sZWFuKGV0aGVyZXVtLnNlbmRBc3luYykgPyBldGhlcmV1bS5zZW5kQXN5bmMgOiBldGhlcmV1bS5zZW5kKS5iaW5kKGV0aGVyZXVtKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZW5kKGRhdGEsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LmVycm9yKTtcbiAgICAgIHJlc29sdmUocmVzdWx0LnJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE1lc3NhZ2VDb25zZW50OiBnZXRNZXNzYWdlQ29uc2VudCxcbiAgcmVjb3ZlclBlcnNvbmFsU2lnbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVjb3ZlclBlcnNvbmFsU2lnbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobXNnLCBwZXJzb25hbFNpZykge1xuICAgICAgdmFyIG1zZ1BhcmFtcztcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKCFtc2cgfHwgIXBlcnNvbmFsU2lnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyUGVyc29uYWxTaWduOiBtaXNzaW5nIGFyZ3VtZW50cywgbXNnIGFuZC9vciBwZXJzb25hbFNpZycpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtc2csXG4gICAgICAgICAgICAgICAgc2lnOiBwZXJzb25hbFNpZ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGV0aGVycy51dGlscy52ZXJpZnlNZXNzYWdlKG1zZywgcGVyc29uYWxTaWcpKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcmVjb3ZlclBlcnNvbmFsU2lnbihfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3JlY292ZXJQZXJzb25hbFNpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3ZlclBlcnNvbmFsU2lnbjtcbiAgfSgpLFxuICBvcGVuQm94Q29uc2VudDogZnVuY3Rpb24gb3BlbkJveENvbnNlbnQoZnJvbUFkZHJlc3MsIGV0aGVyZXVtKSB7XG4gICAgdmFyIHRleHQgPSAnVGhpcyBhcHAgd2FudHMgdG8gdmlldyBhbmQgdXBkYXRlIHlvdXIgM0JveCBwcm9maWxlLic7XG4gICAgdmFyIG1zZyA9ICcweCcgKyBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgcGFyYW1zID0gW21zZywgZnJvbUFkZHJlc3NdO1xuICAgIHZhciBtZXRob2QgPSAncGVyc29uYWxfc2lnbic7XG4gICAgcmV0dXJuIHNhZmVFdGhTZW5kKGV0aGVyZXVtLCB7XG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIGlkOiAwLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGZyb21BZGRyZXNzOiBmcm9tQWRkcmVzc1xuICAgIH0pO1xuICB9LFxuICBvcGVuU3BhY2VDb25zZW50OiBmdW5jdGlvbiBvcGVuU3BhY2VDb25zZW50KGZyb21BZGRyZXNzLCBldGhlcmV1bSwgbmFtZSkge1xuICAgIHZhciB0ZXh0ID0gXCJBbGxvdyB0aGlzIGFwcCB0byBvcGVuIHlvdXIgXCIuY29uY2F0KG5hbWUsIFwiIHNwYWNlLlwiKTtcbiAgICB2YXIgbXNnID0gJzB4JyArIEJ1ZmZlci5mcm9tKHRleHQsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciBwYXJhbXMgPSBbbXNnLCBmcm9tQWRkcmVzc107XG4gICAgdmFyIG1ldGhvZCA9ICdwZXJzb25hbF9zaWduJztcbiAgICByZXR1cm4gc2FmZUV0aFNlbmQoZXRoZXJldW0sIHtcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgaWQ6IDAsXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgZnJvbUFkZHJlc3M6IGZyb21BZGRyZXNzXG4gICAgfSk7XG4gIH0sXG4gIGdldExpbmtDb25zZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nZXRMaW5rQ29uc2VudCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGZyb21BZGRyZXNzLCB0b0RJRCwgZXRoZXJldW0pIHtcbiAgICAgIHZhciB0aW1lc3RhbXAsIHRleHQsIG1zZywgcGFyYW1zLCBtZXRob2QsIHNpZztcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIHRleHQgPSBnZXRNZXNzYWdlQ29uc2VudCh0b0RJRCwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgbXNnID0gJzB4JyArIEJ1ZmZlci5mcm9tKHRleHQsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICBwYXJhbXMgPSBbbXNnLCBmcm9tQWRkcmVzc107XG4gICAgICAgICAgICAgIG1ldGhvZCA9ICdwZXJzb25hbF9zaWduJztcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gc2FmZUV0aFNlbmQoZXRoZXJldW0sIHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBmcm9tQWRkcmVzczogZnJvbUFkZHJlc3NcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgc2lnID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBtc2c6IHRleHQsXG4gICAgICAgICAgICAgICAgc2lnOiBzaWcsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMik7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TGlua0NvbnNlbnQoX3gzLCBfeDQsIF94NSkge1xuICAgICAgcmV0dXJuIF9nZXRMaW5rQ29uc2VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRMaW5rQ29uc2VudDtcbiAgfSgpLFxuICBmZXRjaEpzb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2ZldGNoSnNvbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHVybCwgYm9keSkge1xuICAgICAgdmFyIG9wdHMsIHI7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdHMpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHIgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoIXIub2spIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCByLmpzb24oKSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgdGhyb3cgSFRUUEVycm9yKHIuc3RhdHVzLCBcIkludmFsaWQgcmVzcG9uc2UgKFwiLmNvbmNhdChyLnN0YXR1cywgXCIpIGZvciBxdWVyeSBhdCBcIikuY29uY2F0KHVybCkpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoSnNvbihfeDYsIF94Nykge1xuICAgICAgcmV0dXJuIF9mZXRjaEpzb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2hKc29uO1xuICB9KCksXG4gIGZldGNoVGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZmV0Y2hUZXh0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQodXJsLCBvcHRzKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdHMpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHIgPSBfY29udGV4dDQuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoIXIub2spIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByLnRleHQoKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgdGhyb3cgSFRUUEVycm9yKHIuc3RhdHVzLCBcIkludmFsaWQgcmVzcG9uc2UgKFwiLmNvbmNhdChyLnN0YXR1cywgXCIpIGZvciBxdWVyeSBhdCBcIikuY29uY2F0KHVybCkpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTQpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoVGV4dChfeDgsIF94OSkge1xuICAgICAgcmV0dXJuIF9mZXRjaFRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2hUZXh0O1xuICB9KCksXG4gIHRocm93SWZVbmRlZmluZWQ6IGZ1bmN0aW9uIHRocm93SWZVbmRlZmluZWQoYXJnLCBuYW1lKSB7XG4gICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG5hbWUsIFwiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnRcIikpO1xuICAgIH1cbiAgfSxcbiAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzOiBmdW5jdGlvbiB0aHJvd0lmTm90RXF1YWxMZW5BcnJheXMoYXJyMSwgYXJyMikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIxKSB8fCAhQXJyYXkuaXNBcnJheShhcnIyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb3IgbW9yZSBhcmd1bWVudHMgYXJlIG5vdCBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuICB9LFxuICBzaGEyNTZNdWx0aWhhc2g6IGZ1bmN0aW9uIHNoYTI1Nk11bHRpaGFzaChzdHIpIHtcbiAgICB2YXIgZGlnZXN0ID0gQnVmZmVyLmZyb20oc2hhMjU2LmRpZ2VzdChzdHIpKTtcbiAgICByZXR1cm4gTXVsdGloYXNoLmVuY29kZShkaWdlc3QsICdzaGEyLTI1NicpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcbiAgc2hhMjU2OiBzaGEyNTZcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9pcGZzLXB1YnN1YicpXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIExvZyA9IHJlcXVpcmUoJ2lwZnMtbG9nJyk7XG5cbnZhciBJRlJBTUVfU1RPUkVfVkVSU0lPTiA9ICcwLjAuMyc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkcmVzc19zZXJ2ZXJfdXJsOiBwcm9jZXNzLmVudi5BRERSRVNTX1NFUlZFUl9VUkwgfHwgJ2h0dHBzOi8vYmV0YS4zYm94LmlvL2FkZHJlc3Mtc2VydmVyJyxcbiAgcGlubmluZ19ub2RlOiBwcm9jZXNzLmVudi5QSU5OSU5HX05PREUgfHwgJy9kbnNhZGRyL2lwZnMuM2JveC5pby90Y3AvNDQzL3dzcy9pcGZzL1FtWnZ4RXBpVk5qbU5iRUt5UUd2RnpBWTFCd21HdXV2ZFVUbWNUc3RRUGh5VkMnLFxuICBwaW5uaW5nX3Jvb206IHByb2Nlc3MuZW52LlBJTk5JTkdfUk9PTSB8fCAnM2JveC1waW5uaW5nJyxcbiAgaWZyYW1lX3N0b3JlX3ZlcnNpb246IHByb2Nlc3MuZW52LklGUkFNRV9TVE9SRV9WRVJTSU9OIHx8IElGUkFNRV9TVE9SRV9WRVJTSU9OLFxuICBpZnJhbWVfc3RvcmVfdXJsOiBwcm9jZXNzLmVudi5JRlJBTUVfU1RPUkVfVVJMIHx8IFwiaHR0cHM6Ly9pZnJhbWUuM2JveC5pby9cIi5jb25jYXQoSUZSQU1FX1NUT1JFX1ZFUlNJT04sIFwiL2lmcmFtZS5odG1sXCIpLFxuICBpcGZzX29wdGlvbnM6IHtcbiAgICBFWFBFUklNRU5UQUw6IHtcbiAgICAgIHB1YnN1YjogdHJ1ZVxuICAgIH0sXG4gICAgcHJlbG9hZDoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9LFxuICAgIGNvbmZpZzoge1xuICAgICAgQm9vdHN0cmFwOiBbXVxuICAgIH1cbiAgfSxcbiAgb3JiaXRkYl9vcHRpb25zOiB7XG4gICAgc3luY0xvY2FsOiB0cnVlLFxuICAgIHNvcnRGbjogTG9nLlNvcnRpbmcuU29ydEJ5RW50cnlIYXNoIC8vIHRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIG5vdyBidXQgd2lsbCBsaWtlbHkgbm90IGJlIGluIHRoZSBmdXR1cmUuXG5cbiAgfSxcbiAgZ3JhcGhxbF9zZXJ2ZXJfdXJsOiBwcm9jZXNzLmVudi5HUkFQSFFMX1NFUlZFUl9VUkwgfHwgJ2h0dHBzOi8vYXBpLjNib3guaW8vZ3JhcGgvJyxcbiAgcHJvZmlsZV9zZXJ2ZXJfdXJsOiBwcm9jZXNzLmVudi5QUk9GSUxFX1NFUlZFUl9VUkwgfHwgJ2h0dHBzOi8vaXBmcy4zYm94LmlvJyxcbiAgbXVwb3J0X2lwZnNfaG9zdDogcHJvY2Vzcy5lbnYuTVVQT1JUX0lQRlNfSE9TVCB8fCAnaXBmcy5pbmZ1cmEuaW8nLFxuICBtdXBvcnRfaXBmc19wb3J0OiBwcm9jZXNzLmVudi5NVVBPUlRfSVBGU19QT1JUIHx8IDUwMDEsXG4gIG11cG9ydF9pcGZzX3Byb3RvY29sOiBwcm9jZXNzLmVudi5NVVBPUlRfSVBGU19QUk9UT0NPTCB8fCAnaHR0cHMnXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBIRE5vZGUgPSByZXF1aXJlKCdldGhlcnMnKS51dGlscy5IRE5vZGU7XG5cbnZhciBkaWRKV1QgPSByZXF1aXJlKCdkaWQtand0Jyk7XG5cbnZhciBEaWREb2N1bWVudCA9IHJlcXVpcmUoJ2lwZnMtZGlkLWRvY3VtZW50Jyk7XG5cbnZhciBJcGZzTWluaSA9IHJlcXVpcmUoJ2lwZnMtbWluaScpO1xuXG52YXIgbG9jYWxzdG9yYWdlID0gcmVxdWlyZSgnc3RvcmUnKTtcblxudmFyIElkZW50aXRpZXMgPSByZXF1aXJlKCdvcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlcicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCczYm94LW9yYml0ZGItcGx1Z2lucycpLFxuICAgIE9kYklkZW50aXR5UHJvdmlkZXIgPSBfcmVxdWlyZS5PZGJJZGVudGl0eVByb3ZpZGVyO1xuXG5JZGVudGl0aWVzLmFkZElkZW50aXR5UHJvdmlkZXIoT2RiSWRlbnRpdHlQcm92aWRlcik7XG5cbnZhciByZWdpc3RlclJlc29sdmVyID0gcmVxdWlyZSgnM2lkLXJlc29sdmVyJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBLZXlyaW5nID0gcmVxdWlyZSgnLi9rZXlyaW5nJyk7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcuanMnKTtcblxudmFyIERJRF9NRVRIT0RfTkFNRSA9ICczJztcbnZhciBTVE9SQUdFX0tFWSA9ICdzZXJpYWxpemVkM2lkXyc7XG52YXIgTVVQT1JUX0lQRlMgPSB7XG4gIGhvc3Q6IGNvbmZpZy5tdXBvcnRfaXBmc19ob3N0LFxuICBwb3J0OiBjb25maWcubXVwb3J0X2lwZnNfcG9ydCxcbiAgcHJvdG9jb2w6IGNvbmZpZy5tdXBvcnRfaXBmc19wcm90b2NvbFxufTtcblxudmFyIFRocmVlSWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaHJlZUlkKHNlcmlhbGl6ZVN0YXRlLCBldGhlcmV1bSwgaXBmcywgb3B0cykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVGhyZWVJZCk7XG4gICAgdGhpcy5fZXRoZXJldW0gPSBldGhlcmV1bTtcbiAgICB0aGlzLl9pcGZzID0gaXBmcztcbiAgICB0aGlzLl9rZXlyaW5ncyA9IHt9O1xuXG4gICAgdGhpcy5faW5pdEtleXMoc2VyaWFsaXplU3RhdGUsIG9wdHMpO1xuXG4gICAgcmVnaXN0ZXJSZXNvbHZlcihpcGZzKTtcbiAgICBsb2NhbHN0b3JhZ2Uuc2V0KFNUT1JBR0VfS0VZICsgdGhpcy5tYW5hZ2VtZW50QWRkcmVzcywgdGhpcy5zZXJpYWxpemVTdGF0ZSgpKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVGhyZWVJZCwgW3tcbiAgICBrZXk6IFwic2lnbkpXVFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NpZ25KV1QgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfcmVmLFxuICAgICAgICAgICAgdXNlM0lELFxuICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICBleHBpcmVzSW4sXG4gICAgICAgICAgICBrZXlyaW5nLFxuICAgICAgICAgICAgaXNzdWVyLFxuICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9yZWYgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IHt9LCB1c2UzSUQgPSBfcmVmLnVzZTNJRCwgc3BhY2UgPSBfcmVmLnNwYWNlLCBleHBpcmVzSW4gPSBfcmVmLmV4cGlyZXNJbjtcbiAgICAgICAgICAgICAgICBrZXlyaW5nID0gc3BhY2UgPyB0aGlzLl9rZXlyaW5nc1tzcGFjZV0gOiB0aGlzLl9tYWluS2V5cmluZztcbiAgICAgICAgICAgICAgICBpc3N1ZXIgPSB0aGlzLm11cG9ydERJRDtcblxuICAgICAgICAgICAgICAgIGlmICh1c2UzSUQpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlciA9IHRoaXMuRElEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlciA9IHRoaXMuX3N1YkRJRHNbc3BhY2VdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgc2lnbmVyOiBrZXlyaW5nLmdldEpXVFNpZ25lcigpLFxuICAgICAgICAgICAgICAgICAgaXNzdWVyOiBpc3N1ZXIsXG4gICAgICAgICAgICAgICAgICBleHBpcmVzSW46IGV4cGlyZXNJblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBkaWRKV1QuY3JlYXRlSldUKHBheWxvYWQsIHNldHRpbmdzKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzaWduSldUKF94KSB7XG4gICAgICAgIHJldHVybiBfc2lnbkpXVC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2lnbkpXVDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRTdWJESURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3ViRElEKHNwYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ViRElEc1tzcGFjZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9kYklkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0T2RiSWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgSWRlbnRpdGllcy5jcmVhdGVJZGVudGl0eSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnM0lEJyxcbiAgICAgICAgICAgICAgICAgIHRocmVlSWQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICBzcGFjZTogc3BhY2VcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE9kYklkKF94Mikge1xuICAgICAgICByZXR1cm4gX2dldE9kYklkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRPZGJJZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGF0ZU9iaiA9IHtcbiAgICAgICAgbWFuYWdlbWVudEFkZHJlc3M6IHRoaXMubWFuYWdlbWVudEFkZHJlc3MsXG4gICAgICAgIHNlZWQ6IHRoaXMuX21haW5LZXlyaW5nLnNlcmlhbGl6ZSgpLFxuICAgICAgICBzcGFjZVNlZWRzOiB7fVxuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2tleXJpbmdzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgc3RhdGVPYmouc3BhY2VTZWVkc1tuYW1lXSA9IF90aGlzLl9rZXlyaW5nc1tuYW1lXS5zZXJpYWxpemUoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRlT2JqKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0S2V5cyhzZXJpYWxpemVTdGF0ZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGF0ZSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplU3RhdGUpOyAvLyBUT0RPIHJlbW92ZSB0b0xvd2VyQ2FzZSgpIGluIGZ1dHVyZSwgc2hvdWxkIGJlIHNhbml0aXplZCBlbHNld2hlcmVcbiAgICAgIC8vICAgICAgdGhpcyBmb3JjZXMgZXhpc3Rpbmcgc3RhdGUgdG8gY29ycmVjdCBzdGF0ZSBzbyB0aGF0IGFkZHJlc3MgPC0+XG4gICAgICAvLyAgICAgIHJvb3RzdG9yZSByZWxhdGlvbiBob2xkc1xuXG4gICAgICB0aGlzLm1hbmFnZW1lbnRBZGRyZXNzID0gc3RhdGUubWFuYWdlbWVudEFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuX21haW5LZXlyaW5nID0gbmV3IEtleXJpbmcoc3RhdGUuc2VlZCk7XG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZS5zcGFjZVNlZWRzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX3RoaXMyLl9rZXlyaW5nc1tuYW1lXSA9IG5ldyBLZXlyaW5nKHN0YXRlLnNwYWNlU2VlZHNbbmFtZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0RElEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaW5pdERJRDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobXVwb3J0SXBmcykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgbXVwb3J0UHJvbWlzZSwgc3BhY2VzLCBzdWJESURzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtdXBvcnRQcm9taXNlID0gdGhpcy5faW5pdE11cG9ydChtdXBvcnRJcGZzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQzSUQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdERJRCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIHNwYWNlcyA9IE9iamVjdC5rZXlzKHRoaXMuX2tleXJpbmdzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHNwYWNlcy5tYXAoZnVuY3Rpb24gKHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9pbml0M0lEKHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHN1YkRJRHMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJESURzID0ge307XG4gICAgICAgICAgICAgICAgc3BhY2VzLm1hcChmdW5jdGlvbiAoc3BhY2UsIGkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5fc3ViRElEc1tzcGFjZV0gPSBzdWJESURzW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11cG9ydFByb21pc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaW5pdERJRChfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9pbml0RElEMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2luaXRESUQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXQzSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pbml0M0lEMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChzcGFjZU5hbWUpIHtcbiAgICAgICAgdmFyIGRvYywgcHVia2V5cywgX3B1YmtleXMsIHBheWxvYWQsIHNpZ25hdHVyZTtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkb2MgPSBuZXcgRGlkRG9jdW1lbnQodGhpcy5faXBmcywgRElEX01FVEhPRF9OQU1FKTtcblxuICAgICAgICAgICAgICAgIGlmIChzcGFjZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHB1YmtleXMgPSB0aGlzLl9tYWluS2V5cmluZy5nZXRQdWJsaWNLZXlzKHRydWUpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRQdWJsaWNLZXkoJ3NpZ25pbmdLZXknLCAnU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOCcsICdwdWJsaWNLZXlIZXgnLCBwdWJrZXlzLnNpZ25pbmdLZXkpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRQdWJsaWNLZXkoJ2VuY3J5cHRpb25LZXknLCAnQ3VydmUyNTUxOUVuY3J5cHRpb25QdWJsaWNLZXknLCAncHVibGljS2V5QmFzZTY0JywgcHVia2V5cy5hc3ltRW5jcnlwdGlvbktleSk7XG4gICAgICAgICAgICAgICAgZG9jLmFkZFB1YmxpY0tleSgnbWFuYWdlbWVudEtleScsICdTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE4JywgJ2V0aGVyZXVtQWRkcmVzcycsIHRoaXMubWFuYWdlbWVudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRBdXRoZW50aWNhdGlvbignU2VjcDI1NmsxU2lnbmF0dXJlQXV0aGVudGljYXRpb24yMDE4JywgJ3NpZ25pbmdLZXknKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfcHVia2V5cyA9IHRoaXMuX2tleXJpbmdzW3NwYWNlTmFtZV0uZ2V0UHVibGljS2V5cyh0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkUHVibGljS2V5KCdzdWJTaWduaW5nS2V5JywgJ1NlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTgnLCAncHVibGljS2V5SGV4JywgX3B1YmtleXMuc2lnbmluZ0tleSk7XG4gICAgICAgICAgICAgICAgZG9jLmFkZFB1YmxpY0tleSgnc3ViRW5jcnlwdGlvbktleScsICdDdXJ2ZTI1NTE5RW5jcnlwdGlvblB1YmxpY0tleScsICdwdWJsaWNLZXlCYXNlNjQnLCBfcHVia2V5cy5hc3ltRW5jcnlwdGlvbktleSk7XG4gICAgICAgICAgICAgICAgZG9jLmFkZEF1dGhlbnRpY2F0aW9uKCdTZWNwMjU2azFTaWduYXR1cmVBdXRoZW50aWNhdGlvbjIwMTgnLCAnc3ViU2lnbmluZ0tleScpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRDdXN0b21Qcm9wZXJ0eSgnc3BhY2UnLCBzcGFjZU5hbWUpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRDdXN0b21Qcm9wZXJ0eSgncm9vdCcsIHRoaXMuRElEKTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgc3ViU2lnbmluZ0tleTogX3B1YmtleXMuc2lnbmluZ0tleSxcbiAgICAgICAgICAgICAgICAgIHN1YkVuY3J5cHRpb25LZXk6IF9wdWJrZXlzLmFzeW1FbmNyeXB0aW9uS2V5LFxuICAgICAgICAgICAgICAgICAgc3BhY2U6IHNwYWNlTmFtZSxcbiAgICAgICAgICAgICAgICAgIGlhdDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduSldUKHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgIHVzZTNJRDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gX2NvbnRleHQ0LnNlbnQuc3BsaXQoJy4nKVsyXTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkQ3VzdG9tUHJvcGVydHkoJ3Byb29mJywge1xuICAgICAgICAgICAgICAgICAgYWxnOiAnRVMyNTZLJyxcbiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2MuY29tbWl0KHtcbiAgICAgICAgICAgICAgICAgIG5vVGltZXN0YW1wOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBkb2MuRElEKTtcblxuICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9pbml0M0lEKF94NCkge1xuICAgICAgICByZXR1cm4gX2luaXQzSUQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfaW5pdDNJRDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfaW5pdE11cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2luaXRNdXBvcnQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KG11cG9ydElwZnMpIHtcbiAgICAgICAgdmFyIGtleXMsIGRvYywgZG9jSGFzaCwgcHVibGlzaFRvSW5mdXJhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBrZXlzID0gdGhpcy5fbWFpbktleXJpbmcuZ2V0UHVibGljS2V5cygpO1xuICAgICAgICAgICAgICAgIGRvYyA9IGNyZWF0ZU11cG9ydERvY3VtZW50KGtleXMuc2lnbmluZ0tleSwgdGhpcy5tYW5hZ2VtZW50QWRkcmVzcywga2V5cy5hc3ltRW5jcnlwdGlvbktleSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pcGZzLmFkZChCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkb2MpKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGRvY0hhc2ggPSBfY29udGV4dDYuc2VudFswXS5oYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX211cG9ydERJRCA9ICdkaWQ6bXVwb3J0OicgKyBkb2NIYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMubXVwb3J0RmluZ2VycHJpbnQgPSB1dGlscy5zaGEyNTZNdWx0aWhhc2godGhpcy5tdXBvcnRESUQpO1xuXG4gICAgICAgICAgICAgICAgcHVibGlzaFRvSW5mdXJhID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXBmc01pbmk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwZnNNaW5pID0gbmV3IElwZnNNaW5pKG11cG9ydElwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwZnNNaW5pLmFkZEpTT04oZG9jLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU1KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2hUb0luZnVyYSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIHB1Ymxpc2hUb0luZnVyYSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaW5pdE11cG9ydChfeDUpIHtcbiAgICAgICAgcmV0dXJuIF9pbml0TXVwb3J0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2luaXRNdXBvcnQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0S2V5cmluZ0J5U3BhY2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEtleXJpbmdCeVNwYWNlTmFtZShuYW1lKSB7XG4gICAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgIGlmIChzcGxpdFswXSA9PT0gdGhpcy5tdXBvcnRGaW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbktleXJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5cmluZ3Nbc3BsaXRbMl1dO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0S2V5cmluZ0J5TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2luaXRLZXlyaW5nQnlOYW1lID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KG5hbWUpIHtcbiAgICAgICAgdmFyIHNpZywgZW50cm9weSwgc2VlZDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleXJpbmdzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5vcGVuU3BhY2VDb25zZW50KHRoaXMubWFuYWdlbWVudEFkZHJlc3MsIHRoaXMuX2V0aGVyZXVtLCBuYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc2lnID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgZW50cm9weSA9ICcweCcgKyB1dGlscy5zaGEyNTYoc2lnLnNsaWNlKDIpKTtcbiAgICAgICAgICAgICAgICBzZWVkID0gSEROb2RlLm1uZW1vbmljVG9TZWVkKEhETm9kZS5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cmluZ3NbbmFtZV0gPSBuZXcgS2V5cmluZyhzZWVkKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQzSUQobmFtZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YkRJRHNbbmFtZV0gPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgICAgICBsb2NhbHN0b3JhZ2Uuc2V0KFNUT1JBR0VfS0VZICsgdGhpcy5tYW5hZ2VtZW50QWRkcmVzcywgdGhpcy5zZXJpYWxpemVTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRLZXlyaW5nQnlOYW1lKF94Nikge1xuICAgICAgICByZXR1cm4gX2luaXRLZXlyaW5nQnlOYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0S2V5cmluZ0J5TmFtZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJsb2dvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgICAgbG9jYWxzdG9yYWdlLnJlbW92ZShTVE9SQUdFX0tFWSArIHRoaXMubWFuYWdlbWVudEFkZHJlc3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJESURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290RElEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdXBvcnRESURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdXBvcnRESUQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNMb2dnZWRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xvZ2dlZEluKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGxvY2Fsc3RvcmFnZS5nZXQoU1RPUkFHRV9LRVkgKyBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SWRGcm9tRXRoQWRkcmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldElkRnJvbUV0aEFkZHJlc3MgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoYWRkcmVzcywgZXRoZXJldW0sIGlwZnMpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBub3JtYWxpemVkQWRkcmVzcyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQzaWQsXG4gICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICBlbnRyb3B5LFxuICAgICAgICAgICAgbW5lbW9uaWMsXG4gICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgXzNpZCxcbiAgICAgICAgICAgIF9hcmdzOCA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3M4Lmxlbmd0aCA+IDMgJiYgX2FyZ3M4WzNdICE9PSB1bmRlZmluZWQgPyBfYXJnczhbM10gOiB7fTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkM2lkID0gbG9jYWxzdG9yYWdlLmdldChTVE9SQUdFX0tFWSArIG5vcm1hbGl6ZWRBZGRyZXNzKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2VyaWFsaXplZDNpZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuY29uc2VudENhbGxiYWNrKSBvcHRzLmNvbnNlbnRDYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLmNvbnRlbnRTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzaWcgPSBvcHRzLmNvbnRlbnRTaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm9wZW5Cb3hDb25zZW50KG5vcm1hbGl6ZWRBZGRyZXNzLCBldGhlcmV1bSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBzaWcgPSBfY29udGV4dDguc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNvbnNlbnRDYWxsYmFjaykgb3B0cy5jb25zZW50Q2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZW50cm9weSA9ICcweCcgKyB1dGlscy5zaGEyNTYoc2lnLnNsaWNlKDIpKTtcbiAgICAgICAgICAgICAgICBtbmVtb25pYyA9IEhETm9kZS5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5KTtcbiAgICAgICAgICAgICAgICBzZWVkID0gSEROb2RlLm1uZW1vbmljVG9TZWVkKG1uZW1vbmljKTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkM2lkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgbWFuYWdlbWVudEFkZHJlc3M6IG5vcm1hbGl6ZWRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgc2VlZDogc2VlZCxcbiAgICAgICAgICAgICAgICAgIHNwYWNlU2VlZHM6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBfM2lkID0gbmV3IFRocmVlSWQoc2VyaWFsaXplZDNpZCwgZXRoZXJldW0sIGlwZnMsIG9wdHMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8zaWQuX2luaXRESUQob3B0cy5tdXBvcnRJcGZzIHx8IE1VUE9SVF9JUEZTKTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIF8zaWQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SWRGcm9tRXRoQWRkcmVzcyhfeDcsIF94OCwgX3g5KSB7XG4gICAgICAgIHJldHVybiBfZ2V0SWRGcm9tRXRoQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0SWRGcm9tRXRoQWRkcmVzcztcbiAgICB9KClcbiAgfV0pO1xuICByZXR1cm4gVGhyZWVJZDtcbn0oKTtcblxudmFyIGNyZWF0ZU11cG9ydERvY3VtZW50ID0gZnVuY3Rpb24gY3JlYXRlTXVwb3J0RG9jdW1lbnQoc2lnbmluZ0tleSwgbWFuYWdlbWVudEtleSwgYXN5bUVuY3J5cHRpb25LZXkpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHNpZ25pbmdLZXk6IHNpZ25pbmdLZXksXG4gICAgbWFuYWdlbWVudEtleTogbWFuYWdlbWVudEtleSxcbiAgICBhc3ltRW5jcnlwdGlvbktleTogYXN5bUVuY3J5cHRpb25LZXlcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGhyZWVJZDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgdmVyaWZpZXIgPSByZXF1aXJlKCcuL3V0aWxzL3ZlcmlmaWVyJyk7XG5cbnZhciBWZXJpZmllZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBQbGVhc2UgdXNlICoqYm94LnZlcmlmaWVkKiogdG8gZ2V0IHRoZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBWZXJpZmllZChib3gpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFZlcmlmaWVkKTtcbiAgICB0aGlzLl9ib3ggPSBib3g7XG4gICAgdGhpcy5fZGlkID0gYm94Ll8zaWQubXVwb3J0RElEO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShWZXJpZmllZCwgW3tcbiAgICBrZXk6IFwiX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShrZXksIHByb29mLCB2ZXJpZmljYXRpb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgYWNjb3VudDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVyaWZpY2F0aW9uRnVuY3Rpb24odGhpcy5fZGlkLCBwcm9vZik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3hbXCJwdWJsaWNcIl0uc2V0KCdwcm9vZl8nICsga2V5LCBwcm9vZik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfYWRkVmVyaWZpZWRQdWJsaWNBY2NvdW50KF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9hZGRWZXJpZmllZFB1YmxpY0FjY291bnQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZlcmlmaWVkUHVibGljQWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFZlcmlmaWVkUHVibGljQWNjb3VudDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoa2V5LCB2ZXJpZmljYXRpb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgcHJvb2Y7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm94W1wicHVibGljXCJdLmdldCgncHJvb2ZfJyArIGtleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHByb29mID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdmVyaWZpY2F0aW9uRnVuY3Rpb24odGhpcy5fZGlkLCBwcm9vZikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZ2V0VmVyaWZpZWRQdWJsaWNBY2NvdW50KF94NCwgX3g1KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VmVyaWZpZWRQdWJsaWNBY2NvdW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldFZlcmlmaWVkUHVibGljQWNjb3VudDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfYWRkVmVyaWZpZWRQcml2YXRlQWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FkZFZlcmlmaWVkUHJpdmF0ZUFjY291bnQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGtleSwgcHJvb2YsIHZlcmlmaWNhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBhY2NvdW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWNhdGlvbkZ1bmN0aW9uKHRoaXMuX2RpZCwgcHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3hbXCJwcml2YXRlXCJdLnNldCgncHJvb2ZfJyArIGtleSwgcHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBhY2NvdW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2FkZFZlcmlmaWVkUHJpdmF0ZUFjY291bnQoX3g2LCBfeDcsIF94OCkge1xuICAgICAgICByZXR1cm4gX2FkZFZlcmlmaWVkUHJpdmF0ZUFjY291bnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYWRkVmVyaWZpZWRQcml2YXRlQWNjb3VudDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmVyaWZpZWRQcml2YXRlQWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFZlcmlmaWVkUHJpdmF0ZUFjY291bnQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGtleSwgdmVyaWZpY2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb29mO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JveFtcInByaXZhdGVcIl0uZ2V0KCdwcm9vZl8nICsga2V5KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcHJvb2YgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB2ZXJpZmljYXRpb25GdW5jdGlvbih0aGlzLl9kaWQsIHByb29mKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9nZXRWZXJpZmllZFByaXZhdGVBY2NvdW50KF94OSwgX3gxMCkge1xuICAgICAgICByZXR1cm4gX2dldFZlcmlmaWVkUHJpdmF0ZUFjY291bnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0VmVyaWZpZWRQcml2YXRlQWNjb3VudDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJpZmllZCBESUQgb2YgdGhlIHVzZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gICAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIERJRCBvZiB0aGUgdXNlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiRElEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfRElEID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kaWQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBESUQoKSB7XG4gICAgICAgIHJldHVybiBfRElELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBESUQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBoYXMgYSB2YWxpZCBnaXRodWIgYWNjb3VudFxuICAgICAqIFRocm93cyBhbiBlcnJvciBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHVzZXJuYW1lLCBhbmQgcHJvb2ZcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdpdGh1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dpdGh1YiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZ2V0VmVyaWZpZWRQdWJsaWNBY2NvdW50KCdnaXRodWInLCB2ZXJpZmllci52ZXJpZnlHaXRodWIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2l0aHViKCkge1xuICAgICAgICByZXR1cm4gX2dpdGh1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2l0aHViO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBnaXRodWIgdmVyaWZpY2F0aW9uIHRvIHRoZSB1c2VycyBwcm9maWxlXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2ZXJpZmljYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgZ2lzdFVybCAgICAgICAgIFVSTCBvZiB0aGUgcHJvb2ZcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHVzZXJuYW1lLCBhbmQgcHJvb2ZcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEdpdGh1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FkZEdpdGh1YiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhnaXN0VXJsKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudCgnZ2l0aHViJywgZ2lzdFVybCwgdmVyaWZpZXIudmVyaWZ5R2l0aHViKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEdpdGh1YihfeDExKSB7XG4gICAgICAgIHJldHVybiBfYWRkR2l0aHViLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRHaXRodWI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBoYXMgYSB2YWxpZCB0d2l0dGVyIGFjY291bnRcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90d2l0dGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9nZXRWZXJpZmllZFB1YmxpY0FjY291bnQoJ3R3aXR0ZXInLCB2ZXJpZmllci52ZXJpZnlUd2l0dGVyKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHR3aXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfdHdpdHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHdpdHRlcjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdHdpdHRlciB2ZXJpZmljYXRpb24gdG8gdGhlIHVzZXJzIHByb2ZpbGVcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHZlcmlmaWNhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBjbGFpbSAgICAgICAgICAgQSBkaWQtSldUIGNsYWltIG93bmVyc2hpcCBvZiBhIHR3aXR0ZXIgdXNlcm5hbWVcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHVzZXJuYW1lLCBwcm9vZiwgYW5kIHRoZSB2ZXJpZmllclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVHdpdHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FkZFR3aXR0ZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoY2xhaW0pIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWRkVmVyaWZpZWRQdWJsaWNBY2NvdW50KCd0d2l0dGVyJywgY2xhaW0sIHZlcmlmaWVyLnZlcmlmeVR3aXR0ZXIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWRkVHdpdHRlcihfeDEyKSB7XG4gICAgICAgIHJldHVybiBfYWRkVHdpdHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkVHdpdHRlcjtcbiAgICB9KClcbiAgICAvKipcbiAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIHVzZXIgaGFzIGEgdmVyaWZpZWQgZW1haWwgYWNjb3VudFxuICAgICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZS5cbiAgICAqXG4gICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHVzZXJuYW1lLCBwcm9vZiwgYW5kIHRoZSB2ZXJpZmllclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2VtYWlsID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCB0aGlzLl9nZXRWZXJpZmllZFByaXZhdGVBY2NvdW50KCdlbWFpbCcsIHZlcmlmaWVyLnZlcmlmeUVtYWlsKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZW1haWwoKSB7XG4gICAgICAgIHJldHVybiBfZW1haWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVtYWlsO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW1haWwgdmVyaWZpY2F0aW9uIHRvIHRoZSB1c2VycyBwcm9maWxlXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2ZXJpZmljYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgY2xhaW0gICAgICAgICAgIEEgZGlkLUpXVCBjbGFpbSBvd25lcnNoaXAgb2YgYW4gZW1haWwgdXNlcm5hbWVcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHVzZXJuYW1lLCBwcm9vZiwgYW5kIHRoZSB2ZXJpZmllclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRW1haWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRFbWFpbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoY2xhaW0pIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB0aGlzLl9hZGRWZXJpZmllZFByaXZhdGVBY2NvdW50KCdlbWFpbCcsIGNsYWltLCB2ZXJpZmllci52ZXJpZnlFbWFpbCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVtYWlsKF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRFbWFpbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkRW1haWw7XG4gICAgfSgpXG4gIH1dKTtcbiAgcmV0dXJuIFZlcmlmaWVkO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcmlmaWVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbi8qKlxuICogQSBtb2R1bGUgdG8gdmVyaWZ5ICYgdmFsaWRhdGUgY2xhaW1zXG4gKlxuICogQG5hbWUgaWRVdGlsc1xuICogQG1lbWJlcm9mIEJveFxuICovXG52YXIgZGlkSldUID0gcmVxdWlyZSgnZGlkLWp3dCcpO1xuXG52YXIgRElEX01VUE9SVF9QUkVGSVggPSAnZGlkOm11cG9ydDonO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIGEgbXVwb3J0IGRpZCBvciBub3RcbiAgICpcbiAgICogQG1lbWJlck9mIEJveC5pZFV0aWxzXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICBhZGRyZXNzICBBIHN0cmluZyBjb250YWluaW5nIGEgdXNlciBwcm9maWxlIGFkZHJlc3NcbiAgICogQHJldHVybiAgeyp8Ym9vbGVhbn0gICAgICAgICAgIFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgYSBtdXBvcnQgZGlkIG9yIG5vdFxuICAgKi9cbiAgaXNNdXBvcnRESUQ6IGZ1bmN0aW9uIGlzTXVwb3J0RElEKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gYWRkcmVzcy5zdGFydHNXaXRoKERJRF9NVVBPUlRfUFJFRklYKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBhIHZhbGlkIGNsYWltIG9yIG5vdFxuICAgKlxuICAgKiBAbWVtYmVyT2YgQm94LmlkVXRpbHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICBjbGFpbVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgIG9wdHMgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgb3B0cy5hdWRpZW5jZSAgIFRoZSBESUQgb2YgdGhlIGF1ZGllbmNlIG9mIHRoZSBKV1RcbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gICAgICAgICAgICAgICAgICAgd2hldGhlciB0aGUgcGFyYW1ldGVyIGlzIGFuIGFjdHVhbCBjbGFpbVxuICAgKi9cbiAgaXNDbGFpbTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaXNDbGFpbSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoY2xhaW0pIHtcbiAgICAgIHZhciBvcHRzLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDoge307XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZEpXVC5kZWNvZGVKV1QoY2xhaW0sIG9wdHMpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDddXSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gaXNDbGFpbShfeCkge1xuICAgICAgcmV0dXJuIF9pc0NsYWltLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQ2xhaW07XG4gIH0oKSxcblxuICAvKipcbiAgICogVmVyaWZ5IGEgY2xhaW0gYW5kIHJldHVybiBpdHMgY29udGVudC5cbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91cG9ydC1wcm9qZWN0L2RpZC1qd3QvIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBCb3guaWRVdGlsc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgIGNsYWltXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgb3B0cyAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBvcHRzLmF1ZGllbmNlICAgVGhlIERJRCBvZiB0aGUgSldUJ3MgYXVkaWVuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZhbGlkYXRlZCBjbGFpbVxuICAgKi9cbiAgdmVyaWZ5Q2xhaW06IGRpZEpXVC52ZXJpZnlKV1Rcbn07IiwiY29uc3QgQWNjZXNzQ29udHJvbGxlcnMgPSByZXF1aXJlKCcuL3NyYy9hY2Nlc3MtY29udHJvbGxlcnMnKVxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NDb250cm9sbGVyc1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIEtleVZhbHVlU3RvcmUgPSByZXF1aXJlKCcuL2tleVZhbHVlU3RvcmUnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9pbmRleCcpLFxuICAgIHRocm93SWZVbmRlZmluZWQgPSBfcmVxdWlyZS50aHJvd0lmVW5kZWZpbmVkLFxuICAgIHRocm93SWZOb3RFcXVhbExlbkFycmF5cyA9IF9yZXF1aXJlLnRocm93SWZOb3RFcXVhbExlbkFycmF5cztcblxudmFyIFByb2ZpbGVTdG9yZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0tleVZhbHVlU3RvcmUpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShQcm9maWxlU3RvcmUsIF9LZXlWYWx1ZVN0b3JlKTtcblxuICBmdW5jdGlvbiBQcm9maWxlU3RvcmUob3JiaXRkYiwgbmFtZSwgbGlua1Byb2ZpbGUsIGVuc3VyZUNvbm5lY3RlZCwgXzNpZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUHJvZmlsZVN0b3JlKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByb2ZpbGVTdG9yZSkuY2FsbCh0aGlzLCBvcmJpdGRiLCBuYW1lLCBlbnN1cmVDb25uZWN0ZWQsIF8zaWQpKTtcbiAgICBfdGhpcy5fbGlua1Byb2ZpbGUgPSBsaW5rUHJvZmlsZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFByb2ZpbGVTdG9yZSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJncy5sZW5ndGggPiAyICYmIF9hcmdzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnc1syXSA6IHt9O1xuICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7IC8vIGlmIHRoaXMgaXMgdGhlIG5vTGluayBjYWxsIHdlIHNob3VsZG4ndCBjYWxsIF9saW5rUHJvZmlsZS5cblxuICAgICAgICAgICAgICAgIGlmIChvcHRzLm5vTGluaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua1Byb2ZpbGUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCAoMCwgX2dldDJbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByb2ZpbGVTdG9yZS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldChfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TXVsdGlwbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRNdWx0aXBsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rUHJvZmlsZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX2dldDJbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByb2ZpbGVTdG9yZS5wcm90b3R5cGUpLCBcInNldE11bHRpcGxlXCIsIHRoaXMpLmNhbGwodGhpcywga2V5cywgdmFsdWVzKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldE11bHRpcGxlKF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfc2V0TXVsdGlwbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldE11bHRpcGxlO1xuICAgIH0oKVxuICB9XSk7XG4gIHJldHVybiBQcm9maWxlU3RvcmU7XG59KEtleVZhbHVlU3RvcmUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVTdG9yZTsiLCJjb25zdCBPZGJJZGVudGl0eVByb3ZpZGVyID0gcmVxdWlyZSgnLi9vZGJJZGVudGl0eVByb3ZpZGVyJylcbmNvbnN0IE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL21vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXInKVxuY29uc3QgVGhyZWFkQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vdGhyZWFkQWNjZXNzQ29udHJvbGxlcicpXG5jb25zdCBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2xlZ2FjeUlwZnMzYm94QWNjZXNzQ29udHJvbGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0geyBPZGJJZGVudGl0eVByb3ZpZGVyLCBNb2RlcmF0b3JBY2Nlc3NDb250cm9sbGVyLCBUaHJlYWRBY2Nlc3NDb250cm9sbGVyLCBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIgIH1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBFdmVudFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItZXZlbnRzdG9yZScpXG5jb25zdCBGZWVkU3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1mZWVkc3RvcmUnKVxuY29uc3QgS2V5VmFsdWVTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWt2c3RvcmUnKVxuY29uc3QgQ291bnRlclN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItY291bnRlcnN0b3JlJylcbmNvbnN0IERvY3VtZW50U3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1kb2NzdG9yZScpXG5jb25zdCBQdWJzdWIgPSByZXF1aXJlKCdvcmJpdC1kYi1wdWJzdWInKVxuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCdvcmJpdC1kYi1jYWNoZScpXG5jb25zdCBLZXlzdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWtleXN0b3JlJylcbmNvbnN0IElkZW50aXRpZXMgPSByZXF1aXJlKCdvcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlcicpXG5sZXQgQWNjZXNzQ29udHJvbGxlcnMgPSByZXF1aXJlKCdvcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMnKVxuY29uc3QgT3JiaXREQkFkZHJlc3MgPSByZXF1aXJlKCcuL29yYml0LWRiLWFkZHJlc3MnKVxuY29uc3QgY3JlYXRlREJNYW5pZmVzdCA9IHJlcXVpcmUoJy4vZGItbWFuaWZlc3QnKVxuY29uc3QgZXhjaGFuZ2VIZWFkcyA9IHJlcXVpcmUoJy4vZXhjaGFuZ2UtaGVhZHMnKVxuY29uc3QgeyBpc0RlZmluZWQsIGlvIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcblxuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnbG9ncGxlYXNlJylcbmNvbnN0IGxvZ2dlciA9IExvZ2dlci5jcmVhdGUoXCJvcmJpdC1kYlwiKVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbi8vIE1hcHBpbmcgZm9yICdkYXRhYmFzZSB0eXBlJyAtPiBDbGFzc1xubGV0IGRhdGFiYXNlVHlwZXMgPSB7XG4gICdjb3VudGVyJzogQ291bnRlclN0b3JlLFxuICAnZXZlbnRsb2cnOiBFdmVudFN0b3JlLFxuICAnZmVlZCc6IEZlZWRTdG9yZSxcbiAgJ2RvY3N0b3JlJzogRG9jdW1lbnRTdG9yZSxcbiAgJ2tleXZhbHVlJzogS2V5VmFsdWVTdG9yZSxcbn1cblxuICBjbGFzcyBPcmJpdERCIHtcbiAgY29uc3RydWN0b3IoaXBmcywgaWRlbnRpdHksIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNEZWZpbmVkKGlwZnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJUEZTIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3JiaXRkYi9vcmJpdC1kYi9ibG9iL21hc3Rlci9BUEkubWQjY3JlYXRlaW5zdGFuY2UnKVxuXG4gICAgaWYgKCFpc0RlZmluZWQoaWRlbnRpdHkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZGVudGl0eSBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29yYml0ZGIvb3JiaXQtZGIvYmxvYi9tYXN0ZXIvQVBJLm1kI2NyZWF0ZWluc3RhbmNlJylcblxuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5XG4gICAgdGhpcy5pZCA9IG9wdGlvbnMucGVlcklkXG4gICAgdGhpcy5fcHVic3ViID0gb3B0aW9ucyAmJiBvcHRpb25zLmJyb2tlclxuICAgICAgPyBuZXcgb3B0aW9ucy5icm9rZXIodGhpcy5faXBmcylcbiAgICAgIDogbmV3IFB1YnN1Yih0aGlzLl9pcGZzLCB0aGlzLmlkKVxuICAgIHRoaXMuZGlyZWN0b3J5ID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICB0aGlzLmtleXN0b3JlID0gb3B0aW9ucy5rZXlzdG9yZVxuICAgIHRoaXMuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IENhY2hlXG4gICAgdGhpcy5zdG9yZXMgPSB7fVxuICAgIHRoaXMuX2RpcmVjdENvbm5lY3Rpb25zID0ge31cbiAgICAvLyBBY2Nlc3NDb250cm9sbGVycyBtb2R1bGUgY2FuIGJlIHBhc3NlZCBpbiB0byBlbmFibGVcbiAgICAvLyB0ZXN0aW5nIHdpdGggb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJcbiAgICBBY2Nlc3NDb250cm9sbGVycyA9IG9wdGlvbnMuQWNjZXNzQ29udHJvbGxlcnMgfHwgQWNjZXNzQ29udHJvbGxlcnNcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVJbnN0YW5jZSAoaXBmcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lQRlMgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmJpdGRiL29yYml0LWRiL2Jsb2IvbWFzdGVyL0FQSS5tZCNjcmVhdGVpbnN0YW5jZScpXG5cbiAgICBjb25zdCB7IGlkIH0gPSBhd2FpdCBpcGZzLmlkKClcbiAgICBjb25zdCBkaXJlY3RvcnkgPSBvcHRpb25zLmRpcmVjdG9yeSB8fCAnLi9vcmJpdGRiJ1xuICAgIGNvbnN0IGtleXN0b3JlID0gb3B0aW9ucy5rZXlzdG9yZSB8fCBLZXlzdG9yZS5jcmVhdGUocGF0aC5qb2luKGRpcmVjdG9yeSwgaWQsICcva2V5c3RvcmUnKSlcblxuICAgIGNvbnN0IGlkZW50aXR5ID0gb3B0aW9ucy5pZGVudGl0eSB8fCBhd2FpdCBJZGVudGl0aWVzLmNyZWF0ZUlkZW50aXR5KHtcbiAgICAgIGlkOiBvcHRpb25zLmlkIHx8IGlkLFxuICAgICAga2V5c3RvcmU6IGtleXN0b3JlLFxuICAgIH0pXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHBlZXJJZDogaWQgLFxuICAgICAgZGlyZWN0b3J5OiBkaXJlY3RvcnksXG4gICAgICBrZXlzdG9yZToga2V5c3RvcmVcbiAgICB9KVxuICAgIGNvbnN0IG9yYml0ZGIgPSBuZXcgT3JiaXREQihpcGZzLCBpZGVudGl0eSwgb3B0aW9ucylcbiAgICByZXR1cm4gb3JiaXRkYlxuICB9XG5cbiAgLyogRGF0YWJhc2VzICovXG4gIGFzeW5jIGZlZWQgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY3JlYXRlOiB0cnVlLCB0eXBlOiAnZmVlZCcgfSwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpcy5vcGVuKGFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBsb2cgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY3JlYXRlOiB0cnVlLCB0eXBlOiAnZXZlbnRsb2cnIH0sIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMub3BlbihhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgZXZlbnRsb2cgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvZyhhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMga2V5dmFsdWUgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY3JlYXRlOiB0cnVlLCB0eXBlOiAna2V5dmFsdWUnIH0sIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMub3BlbihhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMga3ZzdG9yZSAoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5dmFsdWUoYWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGNvdW50ZXIgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY3JlYXRlOiB0cnVlLCB0eXBlOiAnY291bnRlcicgfSwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpcy5vcGVuKGFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBkb2NzIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNyZWF0ZTogdHJ1ZSwgdHlwZTogJ2RvY3N0b3JlJyB9LCBvcHRpb25zKVxuICAgIHJldHVybiB0aGlzLm9wZW4oYWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGRvY3N0b3JlIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kb2NzKGFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0ICgpIHtcbiAgICAvL2Nsb3NlIEtleXN0b3JlXG4gICAgaWYgKHRoaXMua2V5c3RvcmUuY2xvc2UpXG4gICAgICBhd2FpdCB0aGlzLmtleXN0b3JlLmNsb3NlKClcblxuICAgIC8vIENsb3NlIGFsbCBvcGVuIGRhdGFiYXNlc1xuICAgIGNvbnN0IGRhdGFiYXNlcyA9IE9iamVjdC52YWx1ZXModGhpcy5zdG9yZXMpXG4gICAgZm9yIChsZXQgZGIgb2YgZGF0YWJhc2VzKSB7XG4gICAgICBhd2FpdCBkYi5jbG9zZSgpXG4gICAgICBkZWxldGUgdGhpcy5zdG9yZXNbZGIuYWRkcmVzcy50b1N0cmluZygpXVxuICAgIH1cblxuICAgIC8vIENsb3NlIGEgZGlyZWN0IGNvbm5lY3Rpb24gYW5kIHJlbW92ZSBpdCBmcm9tIGludGVybmFsIHN0YXRlXG4gICAgY29uc3QgcmVtb3ZlRGlyZWN0Q29ubmVjdCA9IGUgPT4ge1xuICAgICAgdGhpcy5fZGlyZWN0Q29ubmVjdGlvbnNbZV0uY2xvc2UoKVxuICAgICAgZGVsZXRlIHRoaXMuX2RpcmVjdENvbm5lY3Rpb25zW2VdXG4gICAgfVxuXG4gICAgLy8gQ2xvc2UgYWxsIGRpcmVjdCBjb25uZWN0aW9ucyB0byBwZWVyc1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2RpcmVjdENvbm5lY3Rpb25zKS5mb3JFYWNoKHJlbW92ZURpcmVjdENvbm5lY3QpXG5cbiAgICAvLyBEaXNjb25uZWN0IGZyb20gcHVic3ViXG4gICAgaWYgKHRoaXMuX3B1YnN1Yikge1xuICAgICAgYXdhaXQgdGhpcy5fcHVic3ViLmRpc2Nvbm5lY3QoKVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgZGF0YWJhc2VzIGZyb20gdGhlIHN0YXRlXG4gICAgdGhpcy5zdG9yZXMgPSB7fVxuICB9XG5cbiAgLy8gQWxpYXMgZm9yIGRpc2Nvbm5lY3QoKVxuICBhc3luYyBzdG9wICgpIHtcbiAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgLyogUHJpdmF0ZSBtZXRob2RzICovXG4gIGFzeW5jIF9jcmVhdGVTdG9yZSAodHlwZSwgYWRkcmVzcywgb3B0aW9ucykge1xuICAgIC8vIEdldCB0aGUgdHlwZSAtPiBjbGFzcyBtYXBwaW5nXG4gICAgY29uc3QgU3RvcmUgPSBkYXRhYmFzZVR5cGVzW3R5cGVdXG5cbiAgICBpZiAoIVN0b3JlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFiYXNlIHR5cGUgJyR7dHlwZX0nYClcblxuICAgIGxldCBhY2Nlc3NDb250cm9sbGVyXG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzQ29udHJvbGxlckFkZHJlc3MpIHtcbiAgICAgIGFjY2Vzc0NvbnRyb2xsZXIgPSBhd2FpdCBBY2Nlc3NDb250cm9sbGVycy5yZXNvbHZlKHRoaXMsIG9wdGlvbnMuYWNjZXNzQ29udHJvbGxlckFkZHJlc3MsIG9wdGlvbnMuYWNjZXNzQ29udHJvbGxlcilcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHRoaXMuX2xvYWRDYWNoZSh0aGlzLmRpcmVjdG9yeSwgYWRkcmVzcylcblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgcmVwbGljYXRlOiB0cnVlIH0sIG9wdGlvbnMsIHtcbiAgICAgIGFjY2Vzc0NvbnRyb2xsZXI6IGFjY2Vzc0NvbnRyb2xsZXIsXG4gICAgICBrZXlzdG9yZTogdGhpcy5rZXlzdG9yZSxcbiAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgIG9uQ2xvc2U6IHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSxcbiAgICB9KVxuICAgIGNvbnN0IGlkZW50aXR5ID0gb3B0aW9ucy5pZGVudGl0eSB8fCB0aGlzLmlkZW50aXR5XG5cbiAgICBjb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh0aGlzLl9pcGZzLCBpZGVudGl0eSwgYWRkcmVzcywgb3B0cylcbiAgICBzdG9yZS5ldmVudHMub24oJ3dyaXRlJywgdGhpcy5fb25Xcml0ZS5iaW5kKHRoaXMpKVxuICAgIC8vIElEIG9mIHRoZSBzdG9yZSBpcyB0aGUgYWRkcmVzcyBhcyBhIHN0cmluZ1xuICAgIGNvbnN0IGFkZHIgPSBhZGRyZXNzLnRvU3RyaW5nKClcbiAgICB0aGlzLnN0b3Jlc1thZGRyXSA9IHN0b3JlXG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcHVic3ViIHRvIGdldCB1cGRhdGVzIGZyb20gcGVlcnMsXG4gICAgLy8gdGhpcyBpcyB3aGF0IGhvb2tzIHVzIGludG8gdGhlIG1lc3NhZ2UgcHJvcGFnYXRpb24gbGF5ZXJcbiAgICAvLyBhbmQgdGhlIHAycCBuZXR3b3JrXG4gICAgaWYob3B0cy5yZXBsaWNhdGUgJiYgdGhpcy5fcHVic3ViKVxuICAgICAgdGhpcy5fcHVic3ViLnN1YnNjcmliZShhZGRyLCB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKSwgdGhpcy5fb25QZWVyQ29ubmVjdGVkLmJpbmQodGhpcykpXG5cbiAgICByZXR1cm4gc3RvcmVcbiAgfVxuXG4gIC8vIENhbGxiYWNrIGZvciBsb2NhbCB3cml0ZXMgdG8gdGhlIGRhdGFiYXNlLiBXZSB0aGUgdXBkYXRlIHRvIHB1YnN1Yi5cbiAgX29uV3JpdGUgKGFkZHJlc3MsIGVudHJ5LCBoZWFkcykge1xuICAgIGlmKCFoZWFkcykgdGhyb3cgbmV3IEVycm9yKFwiJ2hlYWRzJyBub3QgZGVmaW5lZFwiKVxuICAgIGlmKHRoaXMuX3B1YnN1YikgdGhpcy5fcHVic3ViLnB1Ymxpc2goYWRkcmVzcywgaGVhZHMpXG4gIH1cblxuICAvLyBDYWxsYmFjayBmb3IgcmVjZWl2aW5nIGEgbWVzc2FnZSBmcm9tIHRoZSBuZXR3b3JrXG4gIGFzeW5jIF9vbk1lc3NhZ2UgKGFkZHJlc3MsIGhlYWRzKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3Jlc1thZGRyZXNzXVxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoYFJlY2VpdmVkICR7aGVhZHMubGVuZ3RofSBoZWFkcyBmb3IgJyR7YWRkcmVzc30nOlxcbmAsIEpTT04uc3RyaW5naWZ5KGhlYWRzLm1hcChlID0+IGUuaGFzaCksIG51bGwsIDIpKVxuICAgICAgaWYgKHN0b3JlICYmIGhlYWRzICYmIGhlYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXdhaXQgc3RvcmUuc3luYyhoZWFkcylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZSlcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsYmFjayBmb3Igd2hlbiBhIHBlZXIgY29ubmVjdGVkIHRvIGEgZGF0YWJhc2VcbiAgYXN5bmMgX29uUGVlckNvbm5lY3RlZCAoYWRkcmVzcywgcGVlcikge1xuICAgIGxvZ2dlci5kZWJ1ZyhgTmV3IHBlZXIgJyR7cGVlcn0nIGNvbm5lY3RlZCB0byAnJHthZGRyZXNzfSdgKVxuXG4gICAgY29uc3QgZ2V0U3RvcmUgPSBhZGRyZXNzID0+IHRoaXMuc3RvcmVzW2FkZHJlc3NdXG4gICAgY29uc3QgZ2V0RGlyZWN0Q29ubmVjdGlvbiA9IHBlZXIgPT4gdGhpcy5fZGlyZWN0Q29ubmVjdGlvbnNbcGVlcl1cbiAgICBjb25zdCBvbkNoYW5uZWxDcmVhdGVkID0gY2hhbm5lbCA9PiB0aGlzLl9kaXJlY3RDb25uZWN0aW9uc1tjaGFubmVsLl9yZWNlaXZlcklEXSA9IGNoYW5uZWxcbiAgICBjb25zdCBvbk1lc3NhZ2UgPSAoYWRkcmVzcywgaGVhZHMpID0+IHRoaXMuX29uTWVzc2FnZShhZGRyZXNzLCBoZWFkcylcblxuICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCBleGNoYW5nZUhlYWRzKFxuICAgICAgdGhpcy5faXBmcyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBwZWVyLFxuICAgICAgZ2V0U3RvcmUsXG4gICAgICBnZXREaXJlY3RDb25uZWN0aW9uLFxuICAgICAgb25NZXNzYWdlLFxuICAgICAgb25DaGFubmVsQ3JlYXRlZFxuICAgIClcblxuICAgIGlmIChnZXRTdG9yZShhZGRyZXNzKSlcbiAgICAgIGdldFN0b3JlKGFkZHJlc3MpLmV2ZW50cy5lbWl0KCdwZWVyJywgcGVlcilcbiAgfVxuXG4gIC8vIENhbGxiYWNrIHdoZW4gZGF0YWJhc2Ugd2FzIGNsb3NlZFxuICBhc3luYyBfb25DbG9zZSAoYWRkcmVzcykge1xuICAgIGxvZ2dlci5kZWJ1ZyhgQ2xvc2UgJHthZGRyZXNzfWApXG5cbiAgICAvLyBVbnN1YnNjcmliZSBmcm9tIHB1YnN1YlxuICAgIGlmICh0aGlzLl9wdWJzdWIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3B1YnN1Yi51bnN1YnNjcmliZShhZGRyZXNzKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLnN0b3Jlc1thZGRyZXNzXVxuICB9XG5cbiAgYXN5bmMgX2RldGVybWluZUFkZHJlc3MobmFtZSwgdHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFPcmJpdERCLmlzVmFsaWRUeXBlKHR5cGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFiYXNlIHR5cGUgJyR7dHlwZX0nYClcblxuICAgIGlmIChPcmJpdERCQWRkcmVzcy5pc1ZhbGlkKG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBkYXRhYmFzZSBuYW1lIGlzIGFuIGFkZHJlc3MuIFBsZWFzZSBnaXZlIG9ubHkgdGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIWApXG5cbiAgICAvLyBDcmVhdGUgYW4gQWNjZXNzQ29udHJvbGxlciwgdXNlIElQRlMgQUMgYXMgdGhlIGRlZmF1bHRcbiAgICBvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXIgPSBPYmplY3QuYXNzaWduKHt9LCB7IG5hbWU6IG5hbWUgLCB0eXBlOiAnaXBmcycgfSwgb3B0aW9ucy5hY2Nlc3NDb250cm9sbGVyKVxuICAgIGNvbnN0IGFjY2Vzc0NvbnRyb2xsZXJBZGRyZXNzID0gYXdhaXQgQWNjZXNzQ29udHJvbGxlcnMuY3JlYXRlKHRoaXMsIG9wdGlvbnMuYWNjZXNzQ29udHJvbGxlci50eXBlLCBvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXIgIHx8IHt9KVxuXG4gICAgLy8gU2F2ZSB0aGUgbWFuaWZlc3QgdG8gSVBGU1xuICAgIGNvbnN0IG1hbmlmZXN0SGFzaCA9IGF3YWl0IGNyZWF0ZURCTWFuaWZlc3QodGhpcy5faXBmcywgbmFtZSwgdHlwZSwgYWNjZXNzQ29udHJvbGxlckFkZHJlc3MsIG9wdGlvbnMpXG5cbiAgICAvLyBDcmVhdGUgdGhlIGRhdGFiYXNlIGFkZHJlc3NcbiAgICByZXR1cm4gT3JiaXREQkFkZHJlc3MucGFyc2UocGF0aC5qb2luKCcvb3JiaXRkYicsIG1hbmlmZXN0SGFzaCwgbmFtZSkpXG4gIH1cblxuICAvKiBDcmVhdGUgYW5kIE9wZW4gZGF0YWJhc2VzICovXG5cbiAgLypcbiAgICBvcHRpb25zID0ge1xuICAgICAgYWNjZXNzQ29udHJvbGxlcjogeyB3cml0ZTogW10gfSAvLyBhcnJheSBvZiBrZXlzIHRoYXQgY2FuIHdyaXRlIHRvIHRoaXMgZGF0YWJhc2VcbiAgICAgIGRpcmVjdG9yeTogJy4vb3JiaXRkYicsIC8vIGRpcmVjdG9yeSBpbiB3aGljaCB0byBwbGFjZSB0aGUgZGF0YWJhc2UgZmlsZXNcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsIC8vIHdoZXRoZXIgd2Ugc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YWJhc2UgaWYgaXQgZXhpc3RzXG4gICAgfVxuICAqL1xuICBhc3luYyBjcmVhdGUgKG5hbWUsIHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgY3JlYXRlKClgKVxuXG4gICAgLy8gVGhlIGRpcmVjdG9yeSB0byBsb29rIGRhdGFiYXNlcyBmcm9tIGNhbiBiZSBwYXNzZWQgaW4gYXMgYW4gb3B0aW9uXG4gICAgY29uc3QgZGlyZWN0b3J5ID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgdGhpcy5kaXJlY3RvcnlcbiAgICBsb2dnZXIuZGVidWcoYENyZWF0aW5nIGRhdGFiYXNlICcke25hbWV9JyBhcyAke3R5cGV9IGluICcke2RpcmVjdG9yeX0nYClcblxuICAgIC8vIENyZWF0ZSB0aGUgZGF0YWJhc2UgYWRkcmVzc1xuICAgIGNvbnN0IGRiQWRkcmVzcyA9IGF3YWl0IHRoaXMuX2RldGVybWluZUFkZHJlc3MobmFtZSwgdHlwZSwgb3B0aW9ucylcblxuICAgIC8vIExvYWQgdGhlIGxvY2FsbHkgc2F2ZWQgZGF0YWJhc2UgaW5mb3JtYXRpb25cbiAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHRoaXMuX2xvYWRDYWNoZShkaXJlY3RvcnksIGRiQWRkcmVzcylcblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIGRhdGFiYXNlIGxvY2FsbHlcbiAgICBjb25zdCBoYXZlREIgPSBhd2FpdCB0aGlzLl9oYXZlTG9jYWxEYXRhKGNhY2hlLCBkYkFkZHJlc3MpXG5cbiAgICBpZiAoaGF2ZURCICYmICFvcHRpb25zLm92ZXJ3cml0ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJyR7ZGJBZGRyZXNzfScgYWxyZWFkeSBleGlzdHMhYClcblxuICAgIC8vIFNhdmUgdGhlIGRhdGFiYXNlIGxvY2FsbHlcbiAgICBhd2FpdCB0aGlzLl9hZGRNYW5pZmVzdFRvQ2FjaGUoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG5cbiAgICBsb2dnZXIuZGVidWcoYENyZWF0ZWQgZGF0YWJhc2UgJyR7ZGJBZGRyZXNzfSdgKVxuXG4gICAgLy8gT3BlbiB0aGUgZGF0YWJhc2VcbiAgICByZXR1cm4gdGhpcy5vcGVuKGRiQWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGRldGVybWluZUFkZHJlc3MobmFtZSwgdHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHsgb25seUhhc2g6IHRydWUgfSwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpcy5fZGV0ZXJtaW5lQWRkcmVzcyhuYW1lLCB0eXBlLCBvcHRzKVxuICB9XG5cbiAgLypcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsT25seTogZmFsc2UgLy8gaWYgc2V0IHRvIHRydWUsIHRocm93cyBhbiBlcnJvciBpZiBkYXRhYmFzZSBjYW4ndCBiZSBmb3VuZCBsb2NhbGx5XG4gICAgICAgIGNyZWF0ZTogZmFsc2UgLy8gd2hldGhlciB0byBjcmVhdGUgdGhlIGRhdGFiYXNlXG4gICAgICAgIHR5cGU6IFRPRE9cbiAgICAgICAgb3ZlcndyaXRlOiBUT0RPXG5cbiAgICAgIH1cbiAgICovXG4gIGFzeW5jIG9wZW4gKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxvZ2dlci5kZWJ1Zyhgb3BlbigpYClcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgbG9jYWxPbmx5OiBmYWxzZSwgY3JlYXRlOiBmYWxzZSB9LCBvcHRpb25zKVxuICAgIGxvZ2dlci5kZWJ1ZyhgT3BlbiBkYXRhYmFzZSAnJHthZGRyZXNzfSdgKVxuXG4gICAgLy8gVGhlIGRpcmVjdG9yeSB0byBsb29rIGRhdGFiYXNlcyBmcm9tIGNhbiBiZSBwYXNzZWQgaW4gYXMgYW4gb3B0aW9uXG4gICAgY29uc3QgZGlyZWN0b3J5ID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgdGhpcy5kaXJlY3RvcnlcbiAgICBsb2dnZXIuZGVidWcoYExvb2sgZnJvbSAnJHtkaXJlY3Rvcnl9J2ApXG5cbiAgICAvLyBJZiBhZGRyZXNzIGlzIGp1c3QgdGhlIG5hbWUgb2YgZGF0YWJhc2UsIGNoZWNrIHRoZSBvcHRpb25zIHRvIGNyYXRlIHRoZSBkYXRhYmFzZVxuICAgIGlmICghT3JiaXREQkFkZHJlc3MuaXNWYWxpZChhZGRyZXNzKSkge1xuICAgICAgaWYgKCFvcHRpb25zLmNyZWF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCdvcHRpb25zLmNyZWF0ZScgc2V0IHRvICdmYWxzZScuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGRhdGFiYXNlLCBzZXQgJ29wdGlvbnMuY3JlYXRlJyB0byAndHJ1ZScuYClcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jcmVhdGUgJiYgIW9wdGlvbnMudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlIHR5cGUgbm90IHByb3ZpZGVkISBQcm92aWRlIGEgdHlwZSB3aXRoICdvcHRpb25zLnR5cGUnICgke09yYml0REIuZGF0YWJhc2VUeXBlcy5qb2luKCd8Jyl9KWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgTm90IGEgdmFsaWQgT3JiaXREQiBhZGRyZXNzICcke2FkZHJlc3N9JywgY3JlYXRpbmcgdGhlIGRhdGFiYXNlYClcbiAgICAgICAgb3B0aW9ucy5vdmVyd3JpdGUgPSBvcHRpb25zLm92ZXJ3cml0ZSA/IG9wdGlvbnMub3ZlcndyaXRlIDogdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoYWRkcmVzcywgb3B0aW9ucy50eXBlLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSBkYXRhYmFzZSBhZGRyZXNzXG4gICAgY29uc3QgZGJBZGRyZXNzID0gT3JiaXREQkFkZHJlc3MucGFyc2UoYWRkcmVzcylcblxuICAgIC8vIExvYWQgdGhlIGxvY2FsbHkgc2F2ZWQgZGIgaW5mb3JtYXRpb25cbiAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHRoaXMuX2xvYWRDYWNoZShkaXJlY3RvcnksIGRiQWRkcmVzcylcblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIGRhdGFiYXNlXG4gICAgY29uc3QgaGF2ZURCID0gYXdhaXQgdGhpcy5faGF2ZUxvY2FsRGF0YShjYWNoZSwgZGJBZGRyZXNzKVxuXG4gICAgbG9nZ2VyLmRlYnVnKChoYXZlREIgPyAnRm91bmQnIDogJ0RpZG5cXCd0IGZpbmQnKSArIGAgZGF0YWJhc2UgJyR7ZGJBZGRyZXNzfSdgKVxuXG4gICAgLy8gSWYgd2Ugd2FudCB0byB0cnkgYW5kIG9wZW4gdGhlIGRhdGFiYXNlIGxvY2FsLW9ubHksIHRocm93IGFuIGVycm9yXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgZGF0YWJhc2UgbG9jYWxseVxuICAgIGlmIChvcHRpb25zLmxvY2FsT25seSAmJiAhaGF2ZURCKSB7XG4gICAgICBsb2dnZXIud2FybihgRGF0YWJhc2UgJyR7ZGJBZGRyZXNzfScgZG9lc24ndCBleGlzdCFgKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSAnJHtkYkFkZHJlc3N9JyBkb2Vzbid0IGV4aXN0IWApXG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKGBMb2FkaW5nIE1hbmlmZXN0IGZvciAnJHtkYkFkZHJlc3N9J2ApXG5cbiAgICAvLyBHZXQgdGhlIGRhdGFiYXNlIG1hbmlmZXN0IGZyb20gSVBGU1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgaW8ucmVhZCh0aGlzLl9pcGZzLCBkYkFkZHJlc3Mucm9vdClcbiAgICBsb2dnZXIuZGVidWcoYE1hbmlmZXN0IGZvciAnJHtkYkFkZHJlc3N9JzpcXG4ke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LCBudWxsLCAyKX1gKVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0eXBlIGZyb20gdGhlIG1hbmlmZXN0IG1hdGNoZXMgdGhlIHR5cGUgdGhhdCB3YXMgZ2l2ZW4gYXMgYW4gb3B0aW9uXG4gICAgaWYgKG9wdGlvbnMudHlwZSAmJiBtYW5pZmVzdC50eXBlICE9PSBvcHRpb25zLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlICcke2RiQWRkcmVzc30nIGlzIHR5cGUgJyR7bWFuaWZlc3QudHlwZX0nIGJ1dCB3YXMgb3BlbmVkIGFzICcke29wdGlvbnMudHlwZX0nYClcblxuICAgIC8vIFNhdmUgdGhlIGRhdGFiYXNlIGxvY2FsbHlcbiAgICBhd2FpdCB0aGlzLl9hZGRNYW5pZmVzdFRvQ2FjaGUoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG5cbiAgICAvLyBPcGVuIHRoZSB0aGUgZGF0YWJhc2VcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBhY2Nlc3NDb250cm9sbGVyQWRkcmVzczogbWFuaWZlc3QuYWNjZXNzQ29udHJvbGxlciB9KVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTdG9yZShtYW5pZmVzdC50eXBlLCBkYkFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBTYXZlIHRoZSBkYXRhYmFzZSBsb2NhbGx5XG4gIGFzeW5jIF9hZGRNYW5pZmVzdFRvQ2FjaGUgKGRpcmVjdG9yeSwgZGJBZGRyZXNzKSB7XG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCB0aGlzLl9sb2FkQ2FjaGUoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG4gICAgYXdhaXQgY2FjaGUuc2V0KHBhdGguam9pbihkYkFkZHJlc3MudG9TdHJpbmcoKSwgJ19tYW5pZmVzdCcpLCBkYkFkZHJlc3Mucm9vdClcbiAgICBsb2dnZXIuZGVidWcoYFNhdmVkIG1hbmlmZXN0IHRvIElQRlMgYXMgJyR7ZGJBZGRyZXNzLnJvb3R9J2ApXG4gIH1cblxuICBhc3luYyBfbG9hZENhY2hlIChkaXJlY3RvcnksIGRiQWRkcmVzcykge1xuICAgIGxldCBjYWNoZVxuICAgIHRyeSB7XG4gICAgICBjYWNoZSA9IGF3YWl0IHRoaXMuY2FjaGUubG9hZChkaXJlY3RvcnksIGRiQWRkcmVzcylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgbG9nZ2VyLmVycm9yKFwiQ291bGRuJ3QgbG9hZCBDYWNoZTpcIiwgZSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSBoYXZlIHRoZSBkYXRhYmFzZSwgb3IgcGFydCBvZiBpdCwgc2F2ZWQgbG9jYWxseVxuICAgKiBAcGFyYW0gIHtbQ2FjaGVdfSBjYWNoZSBbVGhlIE9yYml0REJDYWNoZSBpbnN0YW5jZSBjb250YWluaW5nIHRoZSBsb2NhbCBkYXRhXVxuICAgKiBAcGFyYW0gIHtbT3JiaXREQkFkZHJlc3NdfSBkYkFkZHJlc3MgW0FkZHJlc3Mgb2YgdGhlIGRhdGFiYXNlIHRvIGNoZWNrXVxuICAgKiBAcmV0dXJuIHtbQm9vbGVhbl19IFtSZXR1cm5zIHRydWUgaWYgd2UgaGF2ZSBjYWNoZWQgdGhlIGRiIGxvY2FsbHksIGZhbHNlIGlmIG5vdF1cbiAgICovXG4gIGFzeW5jIF9oYXZlTG9jYWxEYXRhIChjYWNoZSwgZGJBZGRyZXNzKSB7XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjYWNoZS5nZXQocGF0aC5qb2luKGRiQWRkcmVzcy50b1N0cmluZygpLCAnX21hbmlmZXN0JykpXG4gICAgcmV0dXJuIGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdXBwb3J0ZWQgZGF0YWJhc2UgdHlwZXMgYXMgYW4gQXJyYXkgb2Ygc3RyaW5nc1xuICAgKiBFZy4gWyAnY291bnRlcicsICdldmVudGxvZycsICdmZWVkJywgJ2RvY3N0b3JlJywgJ2tleXZhbHVlJ11cbiAgICogQHJldHVybiB7W0FycmF5XX0gW1N1cHBvcnRlZCBkYXRhYmFzZSB0eXBlc11cbiAgICovXG4gIHN0YXRpYyBnZXQgZGF0YWJhc2VUeXBlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGFiYXNlVHlwZXMpXG4gIH1cblxuICBzdGF0aWMgaXNWYWxpZFR5cGUgKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YWJhc2VUeXBlcykuaW5jbHVkZXModHlwZSlcbiAgfVxuXG4gIHN0YXRpYyBhZGREYXRhYmFzZVR5cGUgKHR5cGUsIHN0b3JlKSB7XG4gICAgaWYgKGRhdGFiYXNlVHlwZXNbdHlwZV0pIHRocm93IG5ldyBFcnJvcihgVHlwZSBhbHJlYWR5IGV4aXN0czogJHt0eXBlfWApXG4gICAgZGF0YWJhc2VUeXBlc1t0eXBlXSA9IHN0b3JlXG4gIH1cblxuICBzdGF0aWMgZ2V0RGF0YWJhc2VUeXBlcyAoKSB7XG4gICAgcmV0dXJuIGRhdGFiYXNlVHlwZXNcbiAgfVxuXG4gIHN0YXRpYyBpc1ZhbGlkQWRkcmVzcyAoYWRkcmVzcykge1xuICAgIHJldHVybiBPcmJpdERCQWRkcmVzcy5pc1ZhbGlkKGFkZHJlc3MpXG4gIH1cblxuICBzdGF0aWMgcGFyc2VBZGRyZXNzIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIE9yYml0REJBZGRyZXNzLnBhcnNlKGFkZHJlc3MpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPcmJpdERCXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmxvY2tTZXJ2aWNlID0gcmVxdWlyZSgnaXBmcy1ibG9jay1zZXJ2aWNlJylcbmNvbnN0IElwbGQgPSByZXF1aXJlKCdpcGxkJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgUGVlckluZm8gPSByZXF1aXJlKCdwZWVyLWluZm8nKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBpc0lQRlMgPSByZXF1aXJlKCdpcy1pcGZzJylcbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBtdWx0aWhhc2ggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBQZWVyQm9vayA9IHJlcXVpcmUoJ3BlZXItYm9vaycpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgbXVsdGloYXNoaW5nID0gcmVxdWlyZSgnbXVsdGloYXNoaW5nLWFzeW5jJylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBtZXJnZU9wdGlvbnMgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcbmNvbnN0IGJvb3QgPSByZXF1aXJlKCcuL2Jvb3QnKVxuY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cycpXG5cbi8vIHJlcGxhY2VkIGJ5IHJlcG8tYnJvd3NlciB3aGVuIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXJcbmNvbnN0IGRlZmF1bHRSZXBvID0gcmVxdWlyZSgnLi9ydW50aW1lL3JlcG8tbm9kZWpzJylcbmNvbnN0IHByZWxvYWQgPSByZXF1aXJlKCcuL3ByZWxvYWQnKVxuY29uc3QgbWZzUHJlbG9hZCA9IHJlcXVpcmUoJy4vbWZzLXByZWxvYWQnKVxuY29uc3QgaXBsZE9wdGlvbnMgPSByZXF1aXJlKCcuL3J1bnRpbWUvaXBsZC1ub2RlanMnKVxuXG5jbGFzcyBJUEZTIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGluaXQ6IHRydWUsXG4gICAgICBzdGFydDogdHJ1ZSxcbiAgICAgIEVYUEVSSU1FTlRBTDoge30sXG4gICAgICBwcmVsb2FkOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGFkZHJlc3NlczogW1xuICAgICAgICAgICcvZG5zYWRkci9ub2RlMC5wcmVsb2FkLmlwZnMuaW8vaHR0cHMnLFxuICAgICAgICAgICcvZG5zYWRkci9ub2RlMS5wcmVsb2FkLmlwZnMuaW8vaHR0cHMnXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gY29uZmlnLnZhbGlkYXRlKG9wdGlvbnMgfHwge30pXG5cbiAgICB0aGlzLl9vcHRpb25zID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRzLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuaW5pdCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucy5zdGFydCA9PT0gZmFsc2UpKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnN0YXJ0ID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXBvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBvcHRpb25zLnJlcG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmVwbyA9IGRlZmF1bHRSZXBvKG9wdGlvbnMucmVwbylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVwbyA9IG9wdGlvbnMucmVwb1xuICAgIH1cblxuICAgIC8vIElQRlMgdXRpbHNcbiAgICB0aGlzLmxvZyA9IGRlYnVnKCdpcGZzJylcbiAgICB0aGlzLmxvZy5lcnIgPSBkZWJ1ZygnaXBmczplcnInKVxuXG4gICAgLy8gSVBGUyBDb3JlIEludGVybmFsc1xuICAgIC8vIHRoaXMuX3JlcG8gLSBhc3NpZ25lZCBhYm92ZVxuICAgIHRoaXMuX3BlZXJJbmZvQm9vayA9IG5ldyBQZWVyQm9vaygpXG4gICAgdGhpcy5fcGVlckluZm8gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9iaXRzd2FwID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYmxvY2tTZXJ2aWNlID0gbmV3IEJsb2NrU2VydmljZSh0aGlzLl9yZXBvKVxuICAgIHRoaXMuX2lwbGQgPSBuZXcgSXBsZChpcGxkT3B0aW9ucyh0aGlzLl9ibG9ja1NlcnZpY2UsIHRoaXMuX29wdGlvbnMuaXBsZCwgdGhpcy5sb2cpKVxuICAgIHRoaXMuX3ByZWxvYWQgPSBwcmVsb2FkKHRoaXMpXG4gICAgdGhpcy5fbWZzUHJlbG9hZCA9IG1mc1ByZWxvYWQodGhpcylcbiAgICB0aGlzLl9pcG5zID0gdW5kZWZpbmVkXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICB0aGlzLl9wcmludCA9IHRoaXMuX29wdGlvbnMuc2lsZW50ID8gdGhpcy5sb2cgOiBjb25zb2xlLmxvZ1xuXG4gICAgLy8gSVBGUyBDb3JlIGV4cG9zZWQgY29tcG9uZW50c1xuICAgIC8vICAgLSBmb3IgYm9vdGluZyB1cCBhIG5vZGVcbiAgICB0aGlzLmluaXQgPSBjb21wb25lbnRzLmluaXQodGhpcylcbiAgICB0aGlzLnByZVN0YXJ0ID0gY29tcG9uZW50cy5wcmVTdGFydCh0aGlzKVxuICAgIHRoaXMuc3RhcnQgPSBjb21wb25lbnRzLnN0YXJ0KHRoaXMpXG4gICAgdGhpcy5zdG9wID0gY29tcG9uZW50cy5zdG9wKHRoaXMpXG4gICAgdGhpcy5zaHV0ZG93biA9IHRoaXMuc3RvcFxuICAgIHRoaXMuaXNPbmxpbmUgPSBjb21wb25lbnRzLmlzT25saW5lKHRoaXMpXG4gICAgLy8gICAtIGludGVyZmFjZS1pcGZzLWNvcmUgZGVmaW5lZCBBUElcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbXBvbmVudHMuZmlsZXNSZWd1bGFyKHRoaXMpKVxuICAgIHRoaXMudmVyc2lvbiA9IGNvbXBvbmVudHMudmVyc2lvbih0aGlzKVxuICAgIHRoaXMuaWQgPSBjb21wb25lbnRzLmlkKHRoaXMpXG4gICAgdGhpcy5yZXBvID0gY29tcG9uZW50cy5yZXBvKHRoaXMpXG4gICAgdGhpcy5ib290c3RyYXAgPSBjb21wb25lbnRzLmJvb3RzdHJhcCh0aGlzKVxuICAgIHRoaXMuY29uZmlnID0gY29tcG9uZW50cy5jb25maWcodGhpcylcbiAgICB0aGlzLmJsb2NrID0gY29tcG9uZW50cy5ibG9jayh0aGlzKVxuICAgIHRoaXMub2JqZWN0ID0gY29tcG9uZW50cy5vYmplY3QodGhpcylcbiAgICB0aGlzLmRhZyA9IGNvbXBvbmVudHMuZGFnKHRoaXMpXG4gICAgdGhpcy5maWxlcyA9IGNvbXBvbmVudHMuZmlsZXNNRlModGhpcylcbiAgICB0aGlzLmxpYnAycCA9IG51bGwgLy8gYXNzaWduZWQgb24gc3RhcnRcbiAgICB0aGlzLnN3YXJtID0gY29tcG9uZW50cy5zd2FybSh0aGlzKVxuICAgIHRoaXMubmFtZSA9IGNvbXBvbmVudHMubmFtZSh0aGlzKVxuICAgIHRoaXMuYml0c3dhcCA9IGNvbXBvbmVudHMuYml0c3dhcCh0aGlzKVxuICAgIHRoaXMucGluID0gY29tcG9uZW50cy5waW4odGhpcylcbiAgICB0aGlzLnBpbmcgPSBjb21wb25lbnRzLnBpbmcodGhpcylcbiAgICB0aGlzLnBpbmdQdWxsU3RyZWFtID0gY29tcG9uZW50cy5waW5nUHVsbFN0cmVhbSh0aGlzKVxuICAgIHRoaXMucGluZ1JlYWRhYmxlU3RyZWFtID0gY29tcG9uZW50cy5waW5nUmVhZGFibGVTdHJlYW0odGhpcylcbiAgICB0aGlzLnB1YnN1YiA9IGNvbXBvbmVudHMucHVic3ViKHRoaXMpXG4gICAgdGhpcy5kaHQgPSBjb21wb25lbnRzLmRodCh0aGlzKVxuICAgIHRoaXMuZG5zID0gY29tcG9uZW50cy5kbnModGhpcylcbiAgICB0aGlzLmtleSA9IGNvbXBvbmVudHMua2V5KHRoaXMpXG4gICAgdGhpcy5zdGF0cyA9IGNvbXBvbmVudHMuc3RhdHModGhpcylcbiAgICB0aGlzLnJlc29sdmUgPSBjb21wb25lbnRzLnJlc29sdmUodGhpcylcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5wdWJzdWIpIHtcbiAgICAgIHRoaXMubG9nKCdFWFBFUklNRU5UQUwgcHVic3ViIGlzIGVuYWJsZWQnKVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5FWFBFUklNRU5UQUwuaXBuc1B1YnN1Yikge1xuICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5wdWJzdWIpIHtcbiAgICAgICAgdGhpcy5sb2coJ0VYUEVSSU1FTlRBTCBwdWJzdWIgaXMgZW5hYmxlZCB0byB1c2UgSVBOUyBwdWJzdWInKVxuICAgICAgICB0aGlzLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5wdWJzdWIgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKCdFWFBFUklNRU5UQUwgSVBOUyBwdWJzdWIgaXMgZW5hYmxlZCcpXG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLkVYUEVSSU1FTlRBTC5zaGFyZGluZykge1xuICAgICAgdGhpcy5sb2coJ0VYUEVSSU1FTlRBTCBzaGFyZGluZyBpcyBlbmFibGVkJylcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpKHRoaXMpXG5cbiAgICBib290KHRoaXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJUEZTXG5cbi8vIE5vdGU6IFdlIG5lZWQgdG8gZG8gdGhpcyB0byBmb3JjZSBicm93c2VyaWZ5IHRvIGxvYWQgdGhlIEJ1ZmZlciBtb2R1bGVcbmNvbnN0IEJ1ZmZlckltcGwgPSBCdWZmZXJcbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHsgY3J5cHRvLCBpc0lQRlMsIEJ1ZmZlcjogQnVmZmVySW1wbCwgQ0lELCBtdWx0aWFkZHIsIG11bHRpYmFzZSwgbXVsdGloYXNoLCBtdWx0aWhhc2hpbmcsIG11bHRpY29kZWMsIFBlZXJJZCwgUGVlckluZm8gfSlcblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlTm9kZSA9IChvcHRpb25zKSA9PiB7XG4gIHJldHVybiBuZXcgSVBGUyhvcHRpb25zKVxufVxuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNyBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc093blByb3BlcnR5XCIsIHsgdmFsdWU6IGhhc093blByb3BlcnR5IH0pO1xuZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZXhwb3J0cy5fb2JqZWN0S2V5cyA9IF9vYmplY3RLZXlzO1xuO1xuLyoqXG4qIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxuKiBAcGFyYW0gIHthbnl9IG9iaiB2YWx1ZSB0byBjbG9uZVxuKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiovXG5mdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3RoaXMgaXMgaG93IEpTT04uc3RyaW5naWZ5IGJlaGF2ZXMgZm9yIGFycmF5IGl0ZW1zXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xuICAgIH1cbn1cbmV4cG9ydHMuX2RlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XG4vLzN4IGZhc3RlciB0aGFuIGNhY2hlZCAvXlxcZCskLy50ZXN0KHN0cilcbmZ1bmN0aW9uIGlzSW50ZWdlcihzdHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuLyoqXG4qIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuKiBAcGFyYW0gcGF0aCBUaGUgcmF3IHBvaW50ZXJcbiogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXG4qL1xuZnVuY3Rpb24gZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLycpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoJ34nKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gZXNjYXBlUGF0aENvbXBvbmVudDtcbi8qKlxuICogVW5lc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHVuZXNjYXBlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufVxuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQ7XG5mdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdFtrZXldLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nICsgZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmV4cG9ydHMuX2dldFBhdGhSZWN1cnNpdmUgPSBfZ2V0UGF0aFJlY3Vyc2l2ZTtcbmZ1bmN0aW9uIGdldFBhdGgocm9vdCwgb2JqKSB7XG4gICAgaWYgKHJvb3QgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBub3QgZm91bmQgaW4gcm9vdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuICcvJyArIHBhdGg7XG59XG5leHBvcnRzLmdldFBhdGggPSBnZXRQYXRoO1xuLyoqXG4qIFJlY3Vyc2l2ZWx5IGNoZWNrcyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYW55IHVuZGVmaW5lZCB2YWx1ZXMgaW5zaWRlLlxuKi9cbmZ1bmN0aW9uIGhhc1VuZGVmaW5lZChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgICAgICAgICAgdmFyIG9iaktleXNMZW5ndGggPSBvYmpLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmhhc1VuZGVmaW5lZCA9IGhhc1VuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICB2YXIgbWVzc2FnZVBhcnRzID0gW21lc3NhZ2VdO1xuICAgIGZvciAodmFyIGtleSBpbiBhcmdzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKSA6IGFyZ3Nba2V5XTsgLy8gcHJldHR5IHByaW50XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChrZXkgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VQYXJ0cy5qb2luKCdcXG4nKTtcbn1cbnZhciBQYXRjaEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXRjaEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhdGNoRXJyb3IobWVzc2FnZSwgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIF90aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgX3RoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpOyAvLyByZXN0b3JlIHByb3RvdHlwZSBjaGFpbiwgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODM0MjM1OVxuICAgICAgICBfdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lOiBuYW1lLCBpbmRleDogaW5kZXgsIG9wZXJhdGlvbjogb3BlcmF0aW9uLCB0cmVlOiB0cmVlIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXRjaEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5QYXRjaEVycm9yID0gUGF0Y2hFcnJvcjtcbiIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcmVFcXVhbHMgPSByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMS5QYXRjaEVycm9yO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xudmFyIG9iak9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICAvKiBpbiBjYXNlIG1vdmUgdGFyZ2V0IG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgIHJldHVybiB0aGUgcmVtb3ZlZCB2YWx1ZSwgdGhpcyBjYW4gYmUgdGF4aW5nIHBlcmZvcm1hbmNlLXdpc2UsXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLnBhdGgpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IGhlbHBlcnNfMS5fZGVlcENsb25lKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHRoaXMuZnJvbSB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogb3JpZ2luYWxWYWx1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XG4gICAgfSxcbiAgICBjb3B5OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUodmFsdWVUb0NvcHkpIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBhcmVFcXVhbHMob2JqW2tleV0sIHRoaXMudmFsdWUpIH07XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfVxufTtcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXG52YXIgYXJyT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoaSkpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMCwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGFycmF5IHByb3BzXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHVzaW5nICctJyBpbiBhbiBhcnJheVxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZExpc3RbMF0gfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gYXJyW2ldO1xuICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IG9iak9wcy5tb3ZlLFxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxuICAgIHRlc3Q6IG9iak9wcy50ZXN0LFxuICAgIF9nZXQ6IG9iak9wcy5fZ2V0XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuZXhwb3J0cy5nZXRWYWx1ZUJ5UG9pbnRlciA9IGdldFZhbHVlQnlQb2ludGVyO1xuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMsIGluZGV4KSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uID09PSB2b2lkIDApIHsgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZTsgfVxuICAgIGlmIChtdXRhdGVEb2N1bWVudCA9PT0gdm9pZCAwKSB7IG11dGF0ZURvY3VtZW50ID0gdHJ1ZTsgfVxuICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID09PSB2b2lkIDApIHsgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWU7IH1cbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDsgLy9kb2N1bWVudCB3ZSByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHsgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnKSB7IC8vIHJlcG9ydCByZW1vdmVkIGl0ZW1cbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBhcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7IC8vIGEgcmVtb3ZlIG9uIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8qIGJhZCBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IGhlbHBlcnNfMS5fZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgIHZhciB2YWxpZGF0ZUZ1bmN0aW9uID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyAmJiBrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2AgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgIWhlbHBlcnNfMS5pc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVscGVyc18xLmlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgJiYga2V5LmluZGV4T2YoJ34nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBoZWxwZXJzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXBwbHlPcGVyYXRpb24gPSBhcHBseU9wZXJhdGlvbjtcbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMpIHtcbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cbiAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9PT0gdm9pZCAwKSB7IGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlOyB9XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5JywgJ1NFUVVFTkNFX05PVF9BTl9BUlJBWScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBhdGNoLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbXV0YXRlRG9jdW1lbnQgYXJndW1lbnQgYmVjYXVzZSBpZiBpdCB3YXMgdHJ1ZSwgd2UgYWxyZWFkeSBkZWVwIGNsb25lZCB0aGUgb2JqZWN0LCB3ZSdsbCBqdXN0IHBhc3MgYHRydWVgXG4gICAgICAgIHJlc3VsdHNbaV0gPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgcGF0Y2hbaV0sIHZhbGlkYXRlT3BlcmF0aW9uLCB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpKTtcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXG4gICAgfVxuICAgIHJlc3VsdHMubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uLCBpbmRleCkge1xuICAgIHZhciBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7IC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGFwcGx5UmVkdWNlcjtcbi8qKlxuICogVmFsaWRhdGVzIGEgc2luZ2xlIG9wZXJhdGlvbi4gQ2FsbGVkIGZyb20gYGpzb25wYXRjaC52YWxpZGF0ZWAuIFRocm93cyBgSnNvblBhdGNoRXJyb3JgIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG9iamVjdCAocGF0Y2gpXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBvcGVyYXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gW2RvY3VtZW50XSAtIG9iamVjdCB3aGVyZSB0aGUgb3BlcmF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhpc3RpbmdQYXRoRnJhZ21lbnRdIC0gY29tZXMgYWxvbmcgd2l0aCBgZG9jdW1lbnRgXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gJ29iamVjdCcgfHwgb3BlcmF0aW9uID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3QnLCAnT1BFUkFUSU9OX05PVF9BTl9PQkpFQ1QnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBvcGAgcHJvcGVydHkgaXMgbm90IG9uZSBvZiBvcGVyYXRpb25zIGRlZmluZWQgaW4gUkZDLTY5MDInLCAnT1BFUkFUSU9OX09QX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcGVyYXRpb24ucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhdGhzIHRoYXQgYXJlbid0IGVtcHR5IHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCBcIi9cIlxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSAmJiB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYGZyb21gIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBtb3ZlYCBhbmQgYGNvcHlgIG9wZXJhdGlvbnMpJywgJ09QRVJBVElPTl9GUk9NX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgb3BlcmF0aW9uLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfUkVRVUlSRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdhZGQnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSAmJiBoZWxwZXJzXzEuaGFzVW5kZWZpbmVkKG9wZXJhdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudCkge1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGVuID0gb3BlcmF0aW9uLnBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1BhdGhMZW4gPSBleGlzdGluZ1BhdGhGcmFnbWVudC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbiArIDEgJiYgcGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoJywgJ09QRVJBVElPTl9QQVRIX0NBTk5PVF9BREQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAncmVtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoICE9PSBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGF0IGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5Jykge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogb3BlcmF0aW9uLmZyb20sIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHZhbGlkYXRlKFtleGlzdGluZ1ZhbHVlXSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09ICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fRlJPTV9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoc2VxdWVuY2UsIGRvY3VtZW50LCBleHRlcm5hbFZhbGlkYXRvcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5JywgJ1NFUVVFTkNFX05PVF9BTl9BUlJBWScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKGhlbHBlcnNfMS5fZGVlcENsb25lKGRvY3VtZW50KSwgaGVscGVyc18xLl9kZWVwQ2xvbmUoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yKHNlcXVlbmNlW2ldLCBpLCBkb2N1bWVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGV4cG9ydHMuSnNvblBhdGNoRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIEpzb25QYXRjaEVycm9yOiBleHBvcnRzLkpzb25QYXRjaEVycm9yLFxuICAgIGRlZXBDbG9uZTogZXhwb3J0cy5kZWVwQ2xvbmUsXG4gICAgZ2V0VmFsdWVCeVBvaW50ZXI6IGdldFZhbHVlQnlQb2ludGVyLFxuICAgIGFwcGx5T3BlcmF0aW9uOiBhcHBseU9wZXJhdGlvbixcbiAgICBhcHBseVBhdGNoOiBhcHBseVBhdGNoLFxuICAgIGFwcGx5UmVkdWNlcjogYXBwbHlSZWR1Y2VyLFxuICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yLFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5jb25zdCBDSURVdGlsID0gcmVxdWlyZSgnLi9jaWQtdXRpbCcpXG5jb25zdCB1aW50OEFycmF5Q29uY2F0ID0gcmVxdWlyZSgndWludDhhcnJheXMvY29uY2F0JylcbmNvbnN0IHVpbnQ4QXJyYXlUb1N0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5jb25zdCB1aW50OEFycmF5RXF1YWxzID0gcmVxdWlyZSgndWludDhhcnJheXMvZXF1YWxzJylcblxuY29uc3QgY29kZWNzID0gbXVsdGljb2RlYy5uYW1lVG9Db2RlXG5jb25zdCBjb2RlY0ludHMgPSAvKiogQHR5cGUge0NvZGVjTmFtZVtdfSAqLyhPYmplY3Qua2V5cyhjb2RlY3MpKS5yZWR1Y2UoKHAsIG5hbWUpID0+IHtcbiAgcFtjb2RlY3NbbmFtZV1dID0gbmFtZVxuICByZXR1cm4gcFxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8Q29kZWNDb2RlLCBDb2RlY05hbWU+fSAqLyh7fSkpXG5cbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BpcGxkL2pzLWNpZC9DSUQnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6ZWRDSURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gaGFzaFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHswfDF9IENJRFZlcnNpb25cbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCdtdWx0aWJhc2UnKS5CYXNlTmFtZU9yQ29kZX0gQmFzZU5hbWVPckNvZGVcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCdtdWx0aWNvZGVjJykuQ29kZWNOYW1lfSBDb2RlY05hbWVcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCdtdWx0aWNvZGVjJykuQ29kZWNDb2RlfSBDb2RlY0NvZGVcbiAqL1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIENJRCBgPG1iYXNlPjx2ZXJzaW9uPjxtY29kZWM+PG1oYXNoPmBcbiAqICwgYXMgZGVmaW5lZCBpbiBbaXBsZC9jaWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvY2lkKS5cbiAqXG4gKiBAY2xhc3MgQ0lEXG4gKi9cbmNsYXNzIENJRCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQ0lELlxuICAgKlxuICAgKiBUaGUgYWxnb3JpdGhtIGZvciBhcmd1bWVudCBpbnB1dCBpcyByb3VnaGx5OlxuICAgKiBgYGBcbiAgICogaWYgKGNpZClcbiAgICogICAtPiBjcmVhdGUgYSBjb3B5XG4gICAqIGVsc2UgaWYgKHN0cilcbiAgICogICBpZiAoMXN0IGNoYXIgaXMgb24gbXVsdGliYXNlIHRhYmxlKSAtPiBDSUQgU3RyaW5nXG4gICAqICAgZWxzZSAtPiBiczU4IGVuY29kZWQgbXVsdGloYXNoXG4gICAqIGVsc2UgaWYgKFVpbnQ4QXJyYXkpXG4gICAqICAgaWYgKDFzdCBieXRlIGlzIDAgb3IgMSkgLT4gQ0lEXG4gICAqICAgZWxzZSAtPiBtdWx0aWhhc2hcbiAgICogZWxzZSBpZiAoTnVtYmVyKVxuICAgKiAgIC0+IGNvbnN0cnVjdCBDSUQgYnkgcGFydHNcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEVmVyc2lvbiB8IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBDSUR9IHZlcnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbY29kZWNdXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gW211bHRpaGFzaF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttdWx0aWJhc2VOYW1lXVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQ0lEKDx2ZXJzaW9uPiwgPGNvZGVjPiwgPG11bHRpaGFzaD4sIDxtdWx0aWJhc2VOYW1lPilcbiAgICogbmV3IENJRCg8Y2lkU3RyPilcbiAgICogbmV3IENJRCg8Y2lkLmJ5dGVzPilcbiAgICogbmV3IENJRCg8bXVsdGloYXNoPilcbiAgICogbmV3IENJRCg8YnM1OCBlbmNvZGVkIG11bHRpaGFzaD4pXG4gICAqIG5ldyBDSUQoPGNpZD4pXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgY29kZWMsIG11bHRpaGFzaCwgbXVsdGliYXNlTmFtZSkge1xuICAgIC8vIFdlIGhhdmUgYmVsb3cgdGhyZWUgYmxhbmsgZmllbGQgYWNjZXNzb3JzIG9ubHkgYmVjYXVzZVxuICAgIC8vIG90aGVyd2lzZSBUUyB3aWxsIG5vdCBwaWNrIHRoZW0gdXAgaWYgZG9uZSBhZnRlciBhc3NpZ25lbW50c1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIENJRC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtDSURWZXJzaW9ufVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICB0aGlzLnZlcnNpb25cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlYyBvZiB0aGUgQ0lELlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSB7Q29kZWNOYW1lfVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICB0aGlzLmNvZGVjXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGloYXNoIG9mIHRoZSBDSUQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGhpcy5tdWx0aWhhc2hcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSlcbiAgICBpZiAoQ0lELmlzQ0lEKHZlcnNpb24pKSB7XG4gICAgICAvLyB2ZXJzaW9uIGlzIGFuIGV4aXNpbmcgQ0lEIGluc3RhbmNlXG4gICAgICBjb25zdCBjaWQgPSAvKiogQHR5cGUge0NJRH0gKi8odmVyc2lvbilcbiAgICAgIHRoaXMudmVyc2lvbiA9IGNpZC52ZXJzaW9uXG4gICAgICB0aGlzLmNvZGVjID0gY2lkLmNvZGVjXG4gICAgICB0aGlzLm11bHRpaGFzaCA9IGNpZC5tdWx0aWhhc2hcbiAgICAgIC8vIERlZmF1bHQgZ3VhcmQgZm9yIHdoZW4gYSBDSUQgPCAwLjcgaXMgcGFzc2VkIHdpdGggbm8gbXVsdGliYXNlTmFtZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gY2lkLm11bHRpYmFzZU5hbWUgfHwgKGNpZC52ZXJzaW9uID09PSAwID8gJ2Jhc2U1OGJ0YycgOiAnYmFzZTMyJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGUuZy4gJ2Jhc2UzMicgb3IgZmFsc2VcbiAgICAgIGNvbnN0IGJhc2VOYW1lID0gbXVsdGliYXNlLmlzRW5jb2RlZCh2ZXJzaW9uKVxuICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgIC8vIHZlcnNpb24gaXMgYSBDSUQgU3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UsIHNvIHYxXG4gICAgICAgIGNvbnN0IGNpZCA9IG11bHRpYmFzZS5kZWNvZGUodmVyc2lvbilcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gLyoqIEB0eXBlIHtDSURWZXJzaW9ufSAqLyhwYXJzZUludChjaWRbMF0udG9TdHJpbmcoKSwgMTYpKVxuICAgICAgICB0aGlzLmNvZGVjID0gbXVsdGljb2RlYy5nZXRDb2RlYyhjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGljb2RlYy5ybVByZWZpeChjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IGJhc2VOYW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgYmFzZTU4YnRjIHN0cmluZyBtdWx0aWhhc2gsIHNvIHYwXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDBcbiAgICAgICAgdGhpcy5jb2RlYyA9ICdkYWctcGInXG4gICAgICAgIHRoaXMubXVsdGloYXNoID0gbWguZnJvbUI1OFN0cmluZyh2ZXJzaW9uKVxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSAnYmFzZTU4YnRjJ1xuICAgICAgfVxuICAgICAgQ0lELnZhbGlkYXRlQ0lEKHRoaXMpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0cmluZycsIHsgdmFsdWU6IHZlcnNpb24gfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgdiA9IHBhcnNlSW50KHZlcnNpb25bMF0udG9TdHJpbmcoKSwgMTYpXG4gICAgICBpZiAodiA9PT0gMSkge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgQ0lEIFVpbnQ4QXJyYXlcbiAgICAgICAgY29uc3QgY2lkID0gdmVyc2lvblxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2XG4gICAgICAgIHRoaXMuY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVjKGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWNvZGVjLnJtUHJlZml4KGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2UzMidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZlcnNpb24gaXMgYSByYXcgbXVsdGloYXNoIFVpbnQ4QXJyYXksIHNvIHYwXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDBcbiAgICAgICAgdGhpcy5jb2RlYyA9ICdkYWctcGInXG4gICAgICAgIHRoaXMubXVsdGloYXNoID0gdmVyc2lvblxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSAnYmFzZTU4YnRjJ1xuICAgICAgfVxuICAgICAgQ0lELnZhbGlkYXRlQ0lEKHRoaXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIGFzc2VtYmxlIHRoZSBDSUQgZnJvbSB0aGUgcGFyYW1ldGVyc1xuXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvblxuXG4gICAgaWYgKHR5cGVvZiBjb2RlYyA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvZGVjID0gY29kZWNJbnRzW2NvZGVjXVxuICAgIH1cblxuICAgIHRoaXMuY29kZWMgPSAvKiogQHR5cGUge0NvZGVjTmFtZX0gKi8gKGNvZGVjKVxuXG4gICAgdGhpcy5tdWx0aWhhc2ggPSAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIChtdWx0aWhhc2gpXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aWJhc2UgbmFtZSBhcyBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gbXVsdGliYXNlTmFtZSB8fCAodmVyc2lvbiA9PT0gMCA/ICdiYXNlNThidGMnIDogJ2Jhc2UzMicpXG5cbiAgICBDSUQudmFsaWRhdGVDSUQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ0lEIGFzIGEgYFVpbnQ4QXJyYXlgXG4gICAqXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKlxuICAgKi9cbiAgZ2V0IGJ5dGVzICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGJ5dGVzID0gdGhpcy5fYnl0ZXNcblxuICAgIGlmICghYnl0ZXMpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcbiAgICAgICAgYnl0ZXMgPSB0aGlzLm11bHRpaGFzaFxuICAgICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgY29uc3QgY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVWYXJpbnQodGhpcy5jb2RlYylcbiAgICAgICAgYnl0ZXMgPSB1aW50OEFycmF5Q29uY2F0KFtcbiAgICAgICAgICBbMV0sIGNvZGVjLCB0aGlzLm11bHRpaGFzaFxuICAgICAgICBdLCAxICsgY29kZWMuYnl0ZUxlbmd0aCArIHRoaXMubXVsdGloYXNoLmJ5dGVMZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHZlcnNpb24nKVxuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSB0aGlzIFVpbnQ4QXJyYXkgc28gaXQgZG9lc24ndCBoYXZlIHRvIGJlIHJlY3JlYXRlZFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfYnl0ZXMnLCB7IHZhbHVlOiBieXRlcyB9KVxuICAgIH1cblxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwcmVmaXggb2YgdGhlIENJRC5cbiAgICpcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBnZXQgcHJlZml4ICgpIHtcbiAgICBjb25zdCBjb2RlYyA9IG11bHRpY29kZWMuZ2V0Q29kZVZhcmludCh0aGlzLmNvZGVjKVxuICAgIGNvbnN0IG11bHRpaGFzaCA9IG1oLnByZWZpeCh0aGlzLm11bHRpaGFzaClcbiAgICBjb25zdCBwcmVmaXggPSB1aW50OEFycmF5Q29uY2F0KFtcbiAgICAgIFt0aGlzLnZlcnNpb25dLCBjb2RlYywgbXVsdGloYXNoXG4gICAgXSwgMSArIGNvZGVjLmJ5dGVMZW5ndGggKyBtdWx0aWhhc2guYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29kZWMgb2YgdGhlIENJRCBpbiBpdHMgbnVtYmVyIGZvcm0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb2RlY0NvZGV9XG4gICAqL1xuICBnZXQgY29kZSAoKSB7XG4gICAgcmV0dXJuIGNvZGVjc1t0aGlzLmNvZGVjXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBDSUQgb2YgdmVyc2lvbiBgMGAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDSUR9XG4gICAqL1xuICB0b1YwICgpIHtcbiAgICBpZiAodGhpcy5jb2RlYyAhPT0gJ2RhZy1wYicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgY29uc3QgeyBuYW1lLCBsZW5ndGggfSA9IG1oLmRlY29kZSh0aGlzLm11bHRpaGFzaClcblxuICAgIGlmIChuYW1lICE9PSAnc2hhMi0yNTYnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG5vbiBzaGEyLTI1NiBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJylcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gMzIgYnl0ZSBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENJRCgwLCB0aGlzLmNvZGVjLCB0aGlzLm11bHRpaGFzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgQ0lEIG9mIHZlcnNpb24gYDFgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q0lEfVxuICAgKi9cbiAgdG9WMSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDSUQoMSwgdGhpcy5jb2RlYywgdGhpcy5tdWx0aWhhc2gsIHRoaXMubXVsdGliYXNlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIENJRCBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBbYmFzZT10aGlzLm11bHRpYmFzZU5hbWVdIC0gQmFzZSBlbmNvZGluZyB0byB1c2UuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Jhc2VFbmNvZGVkU3RyaW5nIChiYXNlID0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBub24gZW51bWVyYWJsZSBjYWNoZSBwcm9wZXJ0eVxuICAgIGlmICh0aGlzLnN0cmluZyAmJiB0aGlzLnN0cmluZy5sZW5ndGggIT09IDAgJiYgYmFzZSA9PT0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgICAvLyBAdHMtaWdub3JlIG5vbiBlbnVtZXJhYmxlIGNhY2hlIHByb3BlcnR5XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdcbiAgICB9XG4gICAgbGV0IHN0clxuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChiYXNlICE9PSAnYmFzZTU4YnRjJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgd2l0aCBDSUR2MCwgdG8gc3VwcG9ydCBkaWZmZXJlbnQgYmFzZXMsIHBsZWFzZSBtaWdyYXRlIHRoZSBpbnN0YW5jZSBkbyBDSUR2MSwgeW91IGNhbiBkbyB0aGF0IHRocm91Z2ggY2lkLnRvVjEoKScpXG4gICAgICB9XG4gICAgICBzdHIgPSBtaC50b0I1OFN0cmluZyh0aGlzLm11bHRpaGFzaClcbiAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgc3RyID0gdWludDhBcnJheVRvU3RyaW5nKG11bHRpYmFzZS5lbmNvZGUoYmFzZSwgdGhpcy5ieXRlcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdmVyc2lvbicpXG4gICAgfVxuICAgIGlmIChiYXNlID09PSB0aGlzLm11bHRpYmFzZU5hbWUpIHtcbiAgICAgIC8vIGNhY2hlIHRoZSBzdHJpbmcgdmFsdWVcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RyaW5nJywgeyB2YWx1ZTogc3RyIH0pXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBDSUQoUW1kZlRiQnFCUFE3Vk54WkVZRWoxNFZtUnVaQmtxRmJpd1Jlb2dKZ1MxelIxbilcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSAoKSB7XG4gICAgcmV0dXJuICdDSUQoJyArIHRoaXMudG9TdHJpbmcoKSArICcpJ1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSB0aGUgQ0lEIGludG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IFtiYXNlPXRoaXMubXVsdGliYXNlTmFtZV0gLSBCYXNlIGVuY29kaW5nIHRvIHVzZS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChiYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlRW5jb2RlZFN0cmluZyhiYXNlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0byBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge1NlcmlhbGl6ZWRDSUR9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlYzogdGhpcy5jb2RlYyxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgZXF1YWxpdHkgd2l0aCBhbm90aGVyIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvZGVjID09PSBvdGhlci5jb2RlYyAmJlxuICAgICAgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmXG4gICAgICB1aW50OEFycmF5RXF1YWxzKHRoaXMubXVsdGloYXNoLCBvdGhlci5tdWx0aWhhc2gpXG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSB2YWxpZCBDSUQgb2JqZWN0LlxuICAgKiBUaHJvd3MgaWYgaXQgaXMgbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb3RoZXIgLSBUaGUgb3RoZXIgQ0lELlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZUNJRCAob3RoZXIpIHtcbiAgICBjb25zdCBlcnJvck1zZyA9IENJRFV0aWwuY2hlY2tDSURDb21wb25lbnRzKG90aGVyKVxuICAgIGlmIChlcnJvck1zZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmplY3QgaXMgYSBDSUQgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEByZXR1cm5zIHt2YWx1ZSBpcyBDSUR9XG4gICAqL1xuICBzdGF0aWMgaXNDSUQgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ0lEIHx8IEJvb2xlYW4odmFsdWUgJiYgdmFsdWVbc3ltYm9sXSlcbiAgfVxufVxuXG5DSUQuY29kZWNzID0gY29kZWNzXG5cbm1vZHVsZS5leHBvcnRzID0gQ0lEXG4iLCIvKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5hbWVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdpZGVudGl0eSc6IDB4MDAsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnbXVybXVyMy0xMjgnOiAweDIyLFxuICAnbXVybXVyMy0zMic6IDB4MjMsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3NtMy0yNTYnOiAweDUzNGQsXG4gICdibGFrZTJiLTgnOiAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6IDB4YjIwMyxcbiAgJ2JsYWtlMmItMzInOiAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogMHhiMjA1LFxuICAnYmxha2UyYi00OCc6IDB4YjIwNixcbiAgJ2JsYWtlMmItNTYnOiAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogMHhiMjA4LFxuICAnYmxha2UyYi03Mic6IDB4YjIwOSxcbiAgJ2JsYWtlMmItODAnOiAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogMHhiMjBiLFxuICAnYmxha2UyYi05Nic6IDB4YjIwYyxcbiAgJ2JsYWtlMmItMTA0JzogMHhiMjBkLFxuICAnYmxha2UyYi0xMTInOiAweGIyMGUsXG4gICdibGFrZTJiLTEyMCc6IDB4YjIwZixcbiAgJ2JsYWtlMmItMTI4JzogMHhiMjEwLFxuICAnYmxha2UyYi0xMzYnOiAweGIyMTEsXG4gICdibGFrZTJiLTE0NCc6IDB4YjIxMixcbiAgJ2JsYWtlMmItMTUyJzogMHhiMjEzLFxuICAnYmxha2UyYi0xNjAnOiAweGIyMTQsXG4gICdibGFrZTJiLTE2OCc6IDB4YjIxNSxcbiAgJ2JsYWtlMmItMTc2JzogMHhiMjE2LFxuICAnYmxha2UyYi0xODQnOiAweGIyMTcsXG4gICdibGFrZTJiLTE5Mic6IDB4YjIxOCxcbiAgJ2JsYWtlMmItMjAwJzogMHhiMjE5LFxuICAnYmxha2UyYi0yMDgnOiAweGIyMWEsXG4gICdibGFrZTJiLTIxNic6IDB4YjIxYixcbiAgJ2JsYWtlMmItMjI0JzogMHhiMjFjLFxuICAnYmxha2UyYi0yMzInOiAweGIyMWQsXG4gICdibGFrZTJiLTI0MCc6IDB4YjIxZSxcbiAgJ2JsYWtlMmItMjQ4JzogMHhiMjFmLFxuICAnYmxha2UyYi0yNTYnOiAweGIyMjAsXG4gICdibGFrZTJiLTI2NCc6IDB4YjIyMSxcbiAgJ2JsYWtlMmItMjcyJzogMHhiMjIyLFxuICAnYmxha2UyYi0yODAnOiAweGIyMjMsXG4gICdibGFrZTJiLTI4OCc6IDB4YjIyNCxcbiAgJ2JsYWtlMmItMjk2JzogMHhiMjI1LFxuICAnYmxha2UyYi0zMDQnOiAweGIyMjYsXG4gICdibGFrZTJiLTMxMic6IDB4YjIyNyxcbiAgJ2JsYWtlMmItMzIwJzogMHhiMjI4LFxuICAnYmxha2UyYi0zMjgnOiAweGIyMjksXG4gICdibGFrZTJiLTMzNic6IDB4YjIyYSxcbiAgJ2JsYWtlMmItMzQ0JzogMHhiMjJiLFxuICAnYmxha2UyYi0zNTInOiAweGIyMmMsXG4gICdibGFrZTJiLTM2MCc6IDB4YjIyZCxcbiAgJ2JsYWtlMmItMzY4JzogMHhiMjJlLFxuICAnYmxha2UyYi0zNzYnOiAweGIyMmYsXG4gICdibGFrZTJiLTM4NCc6IDB4YjIzMCxcbiAgJ2JsYWtlMmItMzkyJzogMHhiMjMxLFxuICAnYmxha2UyYi00MDAnOiAweGIyMzIsXG4gICdibGFrZTJiLTQwOCc6IDB4YjIzMyxcbiAgJ2JsYWtlMmItNDE2JzogMHhiMjM0LFxuICAnYmxha2UyYi00MjQnOiAweGIyMzUsXG4gICdibGFrZTJiLTQzMic6IDB4YjIzNixcbiAgJ2JsYWtlMmItNDQwJzogMHhiMjM3LFxuICAnYmxha2UyYi00NDgnOiAweGIyMzgsXG4gICdibGFrZTJiLTQ1Nic6IDB4YjIzOSxcbiAgJ2JsYWtlMmItNDY0JzogMHhiMjNhLFxuICAnYmxha2UyYi00NzInOiAweGIyM2IsXG4gICdibGFrZTJiLTQ4MCc6IDB4YjIzYyxcbiAgJ2JsYWtlMmItNDg4JzogMHhiMjNkLFxuICAnYmxha2UyYi00OTYnOiAweGIyM2UsXG4gICdibGFrZTJiLTUwNCc6IDB4YjIzZixcbiAgJ2JsYWtlMmItNTEyJzogMHhiMjQwLFxuICAnYmxha2Uycy04JzogMHhiMjQxLFxuICAnYmxha2Uycy0xNic6IDB4YjI0MixcbiAgJ2JsYWtlMnMtMjQnOiAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6IDB4YjI0NSxcbiAgJ2JsYWtlMnMtNDgnOiAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6IDB4YjI0OCxcbiAgJ2JsYWtlMnMtNzInOiAweGIyNDksXG4gICdibGFrZTJzLTgwJzogMHhiMjRhLFxuICAnYmxha2Uycy04OCc6IDB4YjI0YixcbiAgJ2JsYWtlMnMtOTYnOiAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnc2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ3NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnc2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdza2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ3NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnc2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdza2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ3NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnc2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdza2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ3NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnc2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdza2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdza2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdza2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdza2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdza2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdza2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdza2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdza2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdza2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdza2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdza2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdza2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdza2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdza2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdza2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdza2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdza2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdza2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdza2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdza2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdza2VpbjUxMi04JzogMHhiMzIxLFxuICAnc2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdza2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ3NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnc2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdza2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ3NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnc2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdza2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ3NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnc2tlaW41MTItODgnOiAweGIzMmIsXG4gICdza2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ3NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ3NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ3NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ3NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ3NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ3NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ3NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ3NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ3NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ3NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ3NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ3NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ3NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ3NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ3NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ3NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ3NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ3NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ3NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ3NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ3NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ3NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ3NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ3NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ3NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ3NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ3NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ3NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ3NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ3NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ3NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ3NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ3NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ3NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ3NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ3NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ3NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ3NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ3NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ3NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ3NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ3NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ3NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ3NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ3NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ3NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ3NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ3NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ3NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ3NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ3NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ3NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ3NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnc2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnc2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnc2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnc2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnc2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnc2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnc2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnc2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnc2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnc2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnc2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnc2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ3NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdza2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnc2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ3NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdza2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnc2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ3NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdza2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnc2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ3NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdza2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnc2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ3NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdza2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnc2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ3NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdza2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnc2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ3NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdza2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnc2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ3NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdza2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnc2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ3NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdza2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnc2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ3NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdza2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnc2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ3NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdza2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnc2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ3NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdza2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnc2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ3NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdza2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnc2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ3NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdza2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnc2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ3NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdza2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnc2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ3NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdza2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnc2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ3NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdza2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnc2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ3NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdza2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnc2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ3NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdza2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnc2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ3NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdza2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnc2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ3NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdza2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnc2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ3NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdza2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnc2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ3NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdza2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnc2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ3NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdza2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnc2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ3NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdza2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnc2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ3NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdza2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnc2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ3NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdza2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnc2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ3NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdza2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnc2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ3NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdza2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnc2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ3NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdza2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnc2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ3NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdza2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnc2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ3NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdza2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnc2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ3NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdza2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnc2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ3NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdza2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnc2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ3NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdza2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnc2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ3NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdza2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnc2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ3NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdza2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnc2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ3NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnc2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdza2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ3NrZWluMTAyNC0xMDI0JzogMHhiM2UwLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMSc6IDB4YjQwMSxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEtc2MnOiAweGI0MDJcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBuYW1lcyB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IHJlcXVpcmUoJy4vZW5jb2RlLmpzJylcbiAgLCBkZWNvZGU6IHJlcXVpcmUoJy4vZGVjb2RlLmpzJylcbiAgLCBlbmNvZGluZ0xlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGguanMnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZXhwb3J0cy5UZXh0RW5jb2RlciA9XG4gIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIiA/IFRleHRFbmNvZGVyIDogcmVxdWlyZShcInV0aWxcIikuVGV4dEVuY29kZXJcblxuZXhwb3J0cy5UZXh0RGVjb2RlciA9XG4gIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIiA/IFRleHREZWNvZGVyIDogcmVxdWlyZShcInV0aWxcIikuVGV4dERlY29kZXJcbiIsIi8vIEB0cy1jaGVja1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW211bHRpYmFzZV0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWJhc2UpIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBNdWx0aWJhc2VcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBhc0J1ZmZlciB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi9iYXNlXCIpfSBCYXNlICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBtdWx0aWJhc2UgdmFyaW50K2NvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBwcmVmaXhlZCB3aXRoIG11bHRpYmFzZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBtdWx0aWJhc2UgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBpZiAoIWJ1Zikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYW4gZW5jb2RlZCBidWZmZXInKVxuICB9XG4gIGNvbnN0IHsgbmFtZSwgY29kZUJ1ZiB9ID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcbiAgdmFsaWRFbmNvZGUobmFtZSwgYnVmKVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhjb2RlQnVmLmxlbmd0aCArIGJ1Zi5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoY29kZUJ1ZiwgMClcbiAgYnVmZmVyLnNldChidWYsIGNvZGVCdWYubGVuZ3RoKVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBhbmQgYWRkIHRoZSBtdWx0aWJhc2UgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jLmNvZGVCdWYsIEJ1ZmZlci5mcm9tKGVuYy5lbmNvZGUoYnVmKSldKVxufVxuXG4vKipcbiAqIFRha2VzIGEgVWludDhBcnJheSBvciBzdHJpbmcgZW5jb2RlZCB3aXRoIG11bHRpYmFzZSBoZWFkZXIsIGRlY29kZXMgaXQgYW5kXG4gKiByZXR1cm5zIHRoZSBkZWNvZGVkIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGFbMF1cblxuICAvLyBNYWtlIGFsbCBlbmNvZGluZ3MgY2FzZS1pbnNlbnNpdGl2ZSBleGNlcHQgdGhlIG9uZXMgdGhhdCBpbmNsdWRlIHVwcGVyIGFuZCBsb3dlciBjaGFycyBpbiB0aGUgYWxwaGFiZXRcbiAgaWYgKFsnZicsICdGJywgJ3YnLCAnVicsICd0JywgJ1QnLCAnYicsICdCJywgJ2MnLCAnQycsICdoJywgJ2snLCAnSyddLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgY29uc3QgZW5jID0gZW5jb2RpbmcoZGF0YVswXSlcbiAgcmV0dXJuIGFzQnVmZmVyKGVuYy5kZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSkpKVxufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBkYXRhIG11bHRpYmFzZSBlbmNvZGVkP1xuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtmYWxzZXxzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGlzRW5jb2RlZCAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgLy8gRW5zdXJlIGJ1Zk9yU3RyaW5nIGlzIGEgc3RyaW5nXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nKGRhdGFbMF0pXG4gICAgcmV0dXJuIGVuYy5uYW1lXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkRW5jb2RlIChuYW1lLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZSlcbiAgZW5jLmRlY29kZShkZWNvZGVUZXh0KGJ1ZikpXG59XG5cbi8qKlxuICogR2V0IHRoZSBlbmNvZGluZyBieSBuYW1lIG9yIGNvZGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGVcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmcgKG5hbWVPckNvZGUpIHtcbiAgaWYgKGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXSkge1xuICAgIHJldHVybiBjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIGlmIChjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV0pIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZzogJHtuYW1lT3JDb2RlfWApXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZW5jb2RpbmcgZnJvbSBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZ0Zyb21EYXRhIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICByZXR1cm4gZW5jb2RpbmcoZGF0YVswXSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbXVsdGliYXNlXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuaXNFbmNvZGVkID0gaXNFbmNvZGVkXG5leHBvcnRzLmVuY29kaW5nID0gZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RpbmdGcm9tRGF0YSA9IGVuY29kaW5nRnJvbURhdGFcbmV4cG9ydHMubmFtZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5uYW1lcylcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5jb2RlcylcbiIsIlxuXG4vL1xuLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEISBETyBOT1QgRURJVCBCWSBIQU5EIVxuLy9cbjsoZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgICAgICAvLyBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTE5XG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIHZlcnNpb24gZm9yIG5vQ29uZmxpY3QoKVxuICAgICAgICAgICAgY29uc3QgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgICAgICBjb25zdCBnQmFzZTY0ID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgZ0Jhc2U2NC5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdsb2JhbC5CYXNlNjQgPSBfQmFzZTY0O1xuICAgICAgICAgICAgICAgIHJldHVybiBnQmFzZTY0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuTWV0ZW9yKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICAgICAgICAgIEJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gZ0Jhc2U2NDtcbiAgICAgICAgfSkoKTtcbn0oKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG4gICAgICAgIDogdGhpc1xuKSwgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqICBiYXNlNjQudHNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqXG4gKiBAYXV0aG9yIERhbiBLb2dhaSAoaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpKVxuICovXG5jb25zdCB2ZXJzaW9uID0gJzMuNi4xJztcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGxvd2VyY2FzZSBgdmVyc2lvbmAuXG4gKi9cbmNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuY29uc3QgX2hhc2F0b2IgPSB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9oYXNidG9hID0gdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfaGFzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IF9URCA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogdW5kZWZpbmVkO1xuY29uc3QgX1RFID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG5jb25zdCBiNjRjaCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5jb25zdCBiNjRjaHMgPSBbLi4uYjY0Y2hdO1xuY29uc3QgYjY0dGFiID0gKChhKSA9PiB7XG4gICAgbGV0IHRhYiA9IHt9O1xuICAgIGEuZm9yRWFjaCgoYywgaSkgPT4gdGFiW2NdID0gaSk7XG4gICAgcmV0dXJuIHRhYjtcbn0pKGI2NGNocyk7XG5jb25zdCBiNjRyZSA9IC9eKD86W0EtWmEtelxcZCtcXC9dezR9KSo/KD86W0EtWmEtelxcZCtcXC9dezJ9KD86PT0pP3xbQS1aYS16XFxkK1xcL117M309Pyk/JC87XG5jb25zdCBfZnJvbUNDID0gU3RyaW5nLmZyb21DaGFyQ29kZS5iaW5kKFN0cmluZyk7XG5jb25zdCBfVThBZnJvbSA9IHR5cGVvZiBVaW50OEFycmF5LmZyb20gPT09ICdmdW5jdGlvbidcbiAgICA/IFVpbnQ4QXJyYXkuZnJvbS5iaW5kKFVpbnQ4QXJyYXkpXG4gICAgOiAoaXQsIGZuID0gKHgpID0+IHgpID0+IG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGl0LCAwKS5tYXAoZm4pKTtcbmNvbnN0IF9ta1VyaVNhZmUgPSAoc3JjKSA9PiBzcmNcbiAgICAucmVwbGFjZSgvWytcXC9dL2csIChtMCkgPT4gbTAgPT0gJysnID8gJy0nIDogJ18nKVxuICAgIC5yZXBsYWNlKC89KyQvbSwgJycpO1xuY29uc3QgX3RpZHlCNjQgPSAocykgPT4gcy5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpO1xuLyoqXG4gKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBidG9hYFxuICovXG5jb25zdCBidG9hUG9seWZpbGwgPSAoYmluKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICBsZXQgdTMyLCBjMCwgYzEsIGMyLCBhc2MgPSAnJztcbiAgICBjb25zdCBwYWQgPSBiaW4ubGVuZ3RoICUgMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7KSB7XG4gICAgICAgIGlmICgoYzAgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSB8fFxuICAgICAgICAgICAgKGMxID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgIChjMiA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQnKTtcbiAgICAgICAgdTMyID0gKGMwIDw8IDE2KSB8IChjMSA8PCA4KSB8IGMyO1xuICAgICAgICBhc2MgKz0gYjY0Y2hzW3UzMiA+PiAxOCAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDEyICYgNjNdXG4gICAgICAgICAgICArIGI2NGNoc1t1MzIgPj4gNiAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyICYgNjNdO1xuICAgIH1cbiAgICByZXR1cm4gcGFkID8gYXNjLnNsaWNlKDAsIHBhZCAtIDMpICsgXCI9PT1cIi5zdWJzdHJpbmcocGFkKSA6IGFzYztcbn07XG4vKipcbiAqIGRvZXMgd2hhdCBgd2luZG93LmJ0b2FgIG9mIHdlYiBicm93c2VycyBkby5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiaW4gYmluYXJ5IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKi9cbmNvbnN0IF9idG9hID0gX2hhc2J0b2EgPyAoYmluKSA9PiBidG9hKGJpbilcbiAgICA6IF9oYXNCdWZmZXIgPyAoYmluKSA9PiBCdWZmZXIuZnJvbShiaW4sICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgOiBidG9hUG9seWZpbGw7XG5jb25zdCBfZnJvbVVpbnQ4QXJyYXkgPSBfaGFzQnVmZmVyXG4gICAgPyAodThhKSA9PiBCdWZmZXIuZnJvbSh1OGEpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIDogKHU4YSkgPT4ge1xuICAgICAgICAvLyBjZi4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI3MTAwMDEvaG93LXRvLWNvbnZlcnQtdWludDgtYXJyYXktdG8tYmFzZTY0LWVuY29kZWQtc3RyaW5nLzEyNzEzMzI2IzEyNzEzMzI2XG4gICAgICAgIGNvbnN0IG1heGFyZ3MgPSAweDEwMDA7XG4gICAgICAgIGxldCBzdHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdThhLmxlbmd0aDsgaSA8IGw7IGkgKz0gbWF4YXJncykge1xuICAgICAgICAgICAgc3Rycy5wdXNoKF9mcm9tQ0MuYXBwbHkobnVsbCwgdThhLnN1YmFycmF5KGksIGkgKyBtYXhhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYnRvYShzdHJzLmpvaW4oJycpKTtcbiAgICB9O1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBbdXJsc2FmZV0gVVJMLWFuZC1maWxlbmFtZS1zYWZlIGEgbGEgUkZDNDY0OCDCpzVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZnJvbVVpbnQ4QXJyYXkgPSAodThhLCB1cmxzYWZlID0gZmFsc2UpID0+IHVybHNhZmUgPyBfbWtVcmlTYWZlKF9mcm9tVWludDhBcnJheSh1OGEpKSA6IF9mcm9tVWludDhBcnJheSh1OGEpO1xuLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4vLyBjb25zdCB1dG9iID0gKHNyYzogc3RyaW5nKSA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3JjKSk7XG4vLyByZXZlcnRpbmcgZ29vZCBvbGQgZmF0aW9uZWQgcmVnZXhwXG5jb25zdCBjYl91dG9iID0gKGMpID0+IHtcbiAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChfZnJvbUNDKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgIDogKF9mcm9tQ0MoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgcmV0dXJuIChfZnJvbUNDKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgfVxufTtcbmNvbnN0IHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbi8qKlxuICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTggc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtMTYgc3RyaW5nXG4gKi9cbmNvbnN0IHV0b2IgPSAodSkgPT4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpO1xuLy9cbmNvbnN0IF9lbmNvZGUgPSBfaGFzQnVmZmVyXG4gICAgPyAocykgPT4gQnVmZmVyLmZyb20ocywgJ3V0ZjgnKS50b1N0cmluZygnYmFzZTY0JylcbiAgICA6IF9URVxuICAgICAgICA/IChzKSA9PiBfZnJvbVVpbnQ4QXJyYXkoX1RFLmVuY29kZShzKSlcbiAgICAgICAgOiAocykgPT4gX2J0b2EodXRvYihzKSk7XG4vKipcbiAqIGNvbnZlcnRzIGEgVVRGLTgtZW5jb2RlZCBzdHJpbmcgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBbdXJsc2FmZV0gaWYgYHRydWVgIG1ha2UgdGhlIHJlc3VsdCBVUkwtc2FmZVxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICovXG5jb25zdCBlbmNvZGUgPSAoc3JjLCB1cmxzYWZlID0gZmFsc2UpID0+IHVybHNhZmVcbiAgICA/IF9ta1VyaVNhZmUoX2VuY29kZShzcmMpKVxuICAgIDogX2VuY29kZShzcmMpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIFVSTC1zYWZlIEJhc2U2NCBSRkM0NjQ4IMKnNS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlVVJJID0gKHNyYykgPT4gZW5jb2RlKHNyYywgdHJ1ZSk7XG4vLyBUaGlzIHRyaWNrIGlzIGZvdW5kIGJyb2tlbiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMzBcbi8vIGNvbnN0IGJ0b3UgPSAoc3JjOiBzdHJpbmcpID0+IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3JjKSk7XG4vLyByZXZlcnRpbmcgZ29vZCBvbGQgZmF0aW9uZWQgcmVnZXhwXG5jb25zdCByZV9idG91ID0gL1tcXHhDMC1cXHhERl1bXFx4ODAtXFx4QkZdfFtcXHhFMC1cXHhFRl1bXFx4ODAtXFx4QkZdezJ9fFtcXHhGMC1cXHhGN11bXFx4ODAtXFx4QkZdezN9L2c7XG5jb25zdCBjYl9idG91ID0gKGNjY2MpID0+IHtcbiAgICBzd2l0Y2ggKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMykpLCBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKF9mcm9tQ0MoKG9mZnNldCA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgwZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF9mcm9tQ0MoKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBVVEYtMTYgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtOCBzdHJpbmdcbiAqL1xuY29uc3QgYnRvdSA9IChiKSA9PiBiLnJlcGxhY2UocmVfYnRvdSwgY2JfYnRvdSk7XG4vKipcbiAqIHBvbHlmaWxsIHZlcnNpb24gb2YgYGF0b2JgXG4gKi9cbmNvbnN0IGF0b2JQb2x5ZmlsbCA9IChhc2MpID0+IHtcbiAgICAvLyBjb25zb2xlLmxvZygncG9seWZpbGxlZCcpO1xuICAgIGFzYyA9IGFzYy5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICBpZiAoIWI2NHJlLnRlc3QoYXNjKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGJhc2U2NC4nKTtcbiAgICBhc2MgKz0gJz09Jy5zbGljZSgyIC0gKGFzYy5sZW5ndGggJiAzKSk7XG4gICAgbGV0IHUyNCwgYmluID0gJycsIHIxLCByMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzYy5sZW5ndGg7KSB7XG4gICAgICAgIHUyNCA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldIDw8IDE4XG4gICAgICAgICAgICB8IGI2NHRhYlthc2MuY2hhckF0KGkrKyldIDw8IDEyXG4gICAgICAgICAgICB8IChyMSA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldKSA8PCA2XG4gICAgICAgICAgICB8IChyMiA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldKTtcbiAgICAgICAgYmluICs9IHIxID09PSA2NCA/IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1KVxuICAgICAgICAgICAgOiByMiA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSwgdTI0ID4+IDggJiAyNTUpXG4gICAgICAgICAgICAgICAgOiBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSwgdTI0ID4+IDggJiAyNTUsIHUyNCAmIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBiaW47XG59O1xuLyoqXG4gKiBkb2VzIHdoYXQgYHdpbmRvdy5hdG9iYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gYXNjIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gYmluYXJ5IHN0cmluZ1xuICovXG5jb25zdCBfYXRvYiA9IF9oYXNhdG9iID8gKGFzYykgPT4gYXRvYihfdGlkeUI2NChhc2MpKVxuICAgIDogX2hhc0J1ZmZlciA/IChhc2MpID0+IEJ1ZmZlci5mcm9tKGFzYywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKVxuICAgICAgICA6IGF0b2JQb2x5ZmlsbDtcbi8vXG5jb25zdCBfdG9VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgID8gKGEpID0+IF9VOEFmcm9tKEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKSlcbiAgICA6IChhKSA9PiBfVThBZnJvbShfYXRvYihhKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICovXG5jb25zdCB0b1VpbnQ4QXJyYXkgPSAoYSkgPT4gX3RvVWludDhBcnJheShfdW5VUkkoYSkpO1xuLy9cbmNvbnN0IF9kZWNvZGUgPSBfaGFzQnVmZmVyXG4gICAgPyAoYSkgPT4gQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGY4JylcbiAgICA6IF9URFxuICAgICAgICA/IChhKSA9PiBfVEQuZGVjb2RlKF90b1VpbnQ4QXJyYXkoYSkpXG4gICAgICAgIDogKGEpID0+IGJ0b3UoX2F0b2IoYSkpO1xuY29uc3QgX3VuVVJJID0gKGEpID0+IF90aWR5QjY0KGEucmVwbGFjZSgvWy1fXS9nLCAobTApID0+IG0wID09ICctJyA/ICcrJyA6ICcvJykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIEJhc2U2NCBzdHJpbmcuICBCb3RoIG5vcm1hbCBhbmQgVVJMLXNhZmUgYXJlIHN1cHBvcnRlZFxuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGRlY29kZSA9IChzcmMpID0+IF9kZWNvZGUoX3VuVVJJKHNyYykpO1xuLyoqXG4gKiBjaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBhIHZhbHVlIHRvIGNoZWNrXG4gICovXG5jb25zdCBpc1ZhbGlkID0gKHNyYykgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHMgPSBzcmMucmVwbGFjZSgvXFxzKy9nLCAnJykucmVwbGFjZSgvPSskLywgJycpO1xuICAgIHJldHVybiAhL1teXFxzMC05YS16QS1aXFwrL10vLnRlc3QocykgfHwgIS9bXlxcczAtOWEtekEtWlxcLV9dLy50ZXN0KHMpO1xufTtcbi8vXG5jb25zdCBfbm9FbnVtID0gKHYpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xufTtcbi8qKlxuICogZXh0ZW5kIFN0cmluZy5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYWRkID0gKG5hbWUsIGJvZHkpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCBuYW1lLCBfbm9FbnVtKGJvZHkpKTtcbiAgICBfYWRkKCdmcm9tQmFzZTY0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlKHRoaXMpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NCcsIGZ1bmN0aW9uICh1cmxzYWZlKSB7IHJldHVybiBlbmNvZGUodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9VaW50OEFycmF5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBVaW50OEFycmF5LnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAqL1xuY29uc3QgZXh0ZW5kVWludDhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfYWRkID0gKG5hbWUsIGJvZHkpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVaW50OEFycmF5LnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvQmFzZTY0VVJMJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xufTtcbi8qKlxuICogZXh0ZW5kIEJ1aWx0aW4gcHJvdG90eXBlcyB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAqL1xuY29uc3QgZXh0ZW5kQnVpbHRpbnMgPSAoKSA9PiB7XG4gICAgZXh0ZW5kU3RyaW5nKCk7XG4gICAgZXh0ZW5kVWludDhBcnJheSgpO1xufTtcbmNvbnN0IGdCYXNlNjQgPSB7XG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIGF0b2I6IF9hdG9iLFxuICAgIGF0b2JQb2x5ZmlsbDogYXRvYlBvbHlmaWxsLFxuICAgIGJ0b2E6IF9idG9hLFxuICAgIGJ0b2FQb2x5ZmlsbDogYnRvYVBvbHlmaWxsLFxuICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgIGVuY29kZVVSTDogZW5jb2RlVVJJLFxuICAgIHV0b2I6IHV0b2IsXG4gICAgYnRvdTogYnRvdSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICB0b1VpbnQ4QXJyYXk6IHRvVWludDhBcnJheSxcbiAgICBleHRlbmRTdHJpbmc6IGV4dGVuZFN0cmluZyxcbiAgICBleHRlbmRVaW50OEFycmF5OiBleHRlbmRVaW50OEFycmF5LFxuICAgIGV4dGVuZEJ1aWx0aW5zOiBleHRlbmRCdWlsdGlucyxcbn07XG5cbiAgICAvL1xuICAgIC8vIGV4cG9ydCBCYXNlNjQgdG8gdGhlIG5hbWVzcGFjZVxuICAgIC8vXG4gICAgLy8gRVM1IGlzIHlldCB0byBoYXZlIE9iamVjdC5hc3NpZ24oKSB0aGF0IG1heSBtYWtlIHRyYW5zcGlsZXJzIHVuaGFwcHkuXG4gICAgLy8gZ0Jhc2U2NC5CYXNlNjQgPSBPYmplY3QuYXNzaWduKHt9LCBnQmFzZTY0KTtcbiAgICBnQmFzZTY0LkJhc2U2NCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGdCYXNlNjQpLmZvckVhY2goayA9PiBnQmFzZTY0LkJhc2U2NFtrXSA9IGdCYXNlNjRba10pO1xuICAgIHJldHVybiBnQmFzZTY0O1xufSkpO1xuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OdW1iZXJOYW1lTWFwfSBOdW1iZXJOYW1lTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCB0YWJsZUJ5Q29kZSA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oe30pXG5cbmZvciAoY29uc3QgW25hbWUsIGNvZGVdIG9mIE9iamVjdC5lbnRyaWVzKGJhc2VUYWJsZSkpIHtcbiAgaWYgKHRhYmxlQnlDb2RlW2NvZGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0YWJsZUJ5Q29kZVtjb2RlXSA9IC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqKi8obmFtZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oT2JqZWN0LmZyZWV6ZSh0YWJsZUJ5Q29kZSkpXG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVVaW50OEFycmF5TWFwfSBOYW1lVWludDhBcnJheU1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcbmNvbnN0IHZhcmludEVuY29kZSA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhcmludEVuY29kZVxuXG5jb25zdCB2YXJpbnRUYWJsZSA9IC8qKiBAdHlwZSB7TmFtZVVpbnQ4QXJyYXlNYXB9ICovICh7fSlcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICB2YXJpbnRUYWJsZVtlbmNvZGluZ05hbWVdID0gdmFyaW50RW5jb2RlKGNvZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh2YXJpbnRUYWJsZSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29uc3RhbnROdW1iZXJNYXB9IENvbnN0YW50TnVtYmVyTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCBjb25zdGFudHMgPSAvKiogQHR5cGUge0NvbnN0YW50TnVtYmVyTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBjb25zdCBjb25zdGFudCA9IG5hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJylcbiAgY29uc3RhbnRzW2NvbnN0YW50XSA9IGNvZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cylcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY051bWJlcn0gQ29kZWNOdW1iZXIgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbi8qKlxuICogQHR5cGUge01hcDxDb2RlY051bWJlcixDb2RlY05hbWU+fVxuICovXG5jb25zdCBuYW1lVGFibGUgPSBuZXcgTWFwKClcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICBuYW1lVGFibGUuc2V0KGNvZGUsIC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqLyhlbmNvZGluZ05hbWUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUobmFtZVRhYmxlKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9VaW50OEFycmF5LFxuICB1aW50OEFycmF5VG9OdW1iZXIsXG4gIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUsXG4gIHZhcmludEVuY29kZVxufVxuXG5mdW5jdGlvbiB1aW50OEFycmF5VG9OdW1iZXIgKGJ1Zikge1xuICByZXR1cm4gcGFyc2VJbnQodWludDhBcnJheVRvU3RyaW5nKGJ1ZiwgJ2Jhc2UxNicpLCAxNilcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9VaW50OEFycmF5IChudW0pIHtcbiAgbGV0IGhleFN0cmluZyA9IG51bS50b1N0cmluZygxNilcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhleFN0cmluZywgJ2Jhc2UxNicpXG59XG5cbmZ1bmN0aW9uIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZSh1aW50OEFycmF5VG9OdW1iZXIoaW5wdXQpKSlcbn1cblxuZnVuY3Rpb24gdmFyaW50RW5jb2RlIChudW0pIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKG51bSkpXG59XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIGNoYXJlbmMgPSB7XG4gIC8vIFVURi04IGVuY29kaW5nXG4gIHV0Zjg6IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIGNoYXJlbmMuYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY2hhcmVuYy5iaW4uYnl0ZXNUb1N0cmluZyhieXRlcykpKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQmluYXJ5IGVuY29kaW5nXG4gIGJpbjoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBzdHIgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkpO1xuICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcmVuYztcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGJhc2U2NG1hcFxuICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG5cbiAgY3J5cHQgPSB7XG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gbGVmdFxuICAgIHJvdGw6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCBiKSB8IChuID4+PiAoMzIgLSBiKSk7XG4gICAgfSxcblxuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIHJpZ2h0XG4gICAgcm90cjogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8ICgzMiAtIGIpKSB8IChuID4+PiBiKTtcbiAgICB9LFxuXG4gICAgLy8gU3dhcCBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYW5kIHZpY2UgdmVyc2FcbiAgICBlbmRpYW46IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIElmIG51bWJlciBnaXZlbiwgc3dhcCBlbmRpYW5cbiAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gY3J5cHQucm90bChuLCA4KSAmIDB4MDBGRjAwRkYgfCBjcnlwdC5yb3RsKG4sIDI0KSAmIDB4RkYwMEZGMDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UsIGFzc3VtZSBhcnJheSBhbmQgc3dhcCBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgICAgbltpXSA9IGNyeXB0LmVuZGlhbihuW2ldKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiBhbnkgbGVuZ3RoIG9mIHJhbmRvbSBieXRlc1xuICAgIHJhbmRvbUJ5dGVzOiBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdOyBuID4gMDsgbi0tKVxuICAgICAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBiaWctZW5kaWFuIDMyLWJpdCB3b3Jkc1xuICAgIGJ5dGVzVG9Xb3JkczogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHdvcmRzID0gW10sIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpXG4gICAgICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYmlnLWVuZGlhbiAzMi1iaXQgd29yZHMgdG8gYSBieXRlIGFycmF5XG4gICAgd29yZHNUb0J5dGVzOiBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KVxuICAgICAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gICAgYnl0ZXNUb0hleDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgaGV4VG9CeXRlczogZnVuY3Rpb24oaGV4KSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKGMsIDIpLCAxNikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2UtNjQgc3RyaW5nXG4gICAgYnl0ZXNUb0Jhc2U2NDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGJhc2U2NCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgIGlmIChpICogOCArIGogKiA2IDw9IGJ5dGVzLmxlbmd0aCAqIDgpXG4gICAgICAgICAgICBiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiA2ICogKDMgLSBqKSkgJiAweDNGKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goJz0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjQuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBiYXNlLTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBiYXNlNjRUb0J5dGVzOiBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICAgIC8vIFJlbW92ZSBub24tYmFzZS02NCBjaGFyYWN0ZXJzXG4gICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9pZywgJycpO1xuXG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMCwgaW1vZDQgPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDtcbiAgICAgICAgICBpbW9kNCA9ICsraSAlIDQpIHtcbiAgICAgICAgaWYgKGltb2Q0ID09IDApIGNvbnRpbnVlO1xuICAgICAgICBieXRlcy5wdXNoKCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAmIChNYXRoLnBvdygyLCAtMiAqIGltb2Q0ICsgOCkgLSAxKSkgPDwgKGltb2Q0ICogMikpXG4gICAgICAgICAgICB8IChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKSA+Pj4gKDYgLSBpbW9kNCAqIDIpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY3J5cHQ7XG59KSgpO1xuIiwiLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzogcmV0dXJuICdkYXRlJztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzogcmV0dXJuICdhcnJheSc7XG4gICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOiByZXR1cm4gJ2Vycm9yJztcbiAgfVxuXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsICE9PSB2YWwpIHJldHVybiAnbmFuJztcbiAgaWYgKHZhbCAmJiB2YWwubm9kZVR5cGUgPT09IDEpIHJldHVybiAnZWxlbWVudCc7XG5cbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcblxuICB2YWwgPSB2YWwudmFsdWVPZlxuICAgID8gdmFsLnZhbHVlT2YoKVxuICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbCk7XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWw7XG59O1xuXG4vLyBjb2RlIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIlxuLyoqXG4gKiBKb2luIGBhcnJgIHdpdGggdGhlIHRyYWlsaW5nIGBzdHJgIGRlZmF1bHRpbmcgdG8gXCJhbmRcIixcbiAqIGFuZCBgc2VwYCBzdHJpbmcgZGVmYXVsdGluZyB0byBcIiwgXCIuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBzdHIsIHNlcCl7XG4gIHN0ciA9IHN0ciB8fCAnYW5kJztcbiAgc2VwID0gc2VwIHx8ICcsICc7XG5cbiAgaWYgKGFyci5sZW5ndGggPCAyKSByZXR1cm4gYXJyWzBdIHx8ICcnO1xuXG4gIHZhciBveGZvcmQgPSBzdHIuc2xpY2UoMCwgMikgPT09IHNlcDtcblxuICBpZiAoIW94Zm9yZCkge1xuICAgIHN0ciA9ICcgJyArIHN0cjtcbiAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09IDIpIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYXJyLnNsaWNlKDAsIC0xKS5qb2luKHNlcCkgKyBzdHIgKyAnICcgKyBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNOZXR3b3JrRXJyb3IgPSBpc05ldHdvcmtFcnJvcjtcbmV4cG9ydHMuaXNSZXRyeWFibGVFcnJvciA9IGlzUmV0cnlhYmxlRXJyb3I7XG5leHBvcnRzLmlzU2FmZVJlcXVlc3RFcnJvciA9IGlzU2FmZVJlcXVlc3RFcnJvcjtcbmV4cG9ydHMuaXNJZGVtcG90ZW50UmVxdWVzdEVycm9yID0gaXNJZGVtcG90ZW50UmVxdWVzdEVycm9yO1xuZXhwb3J0cy5pc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3IgPSBpc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3I7XG5leHBvcnRzLmV4cG9uZW50aWFsRGVsYXkgPSBleHBvbmVudGlhbERlbGF5O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3NSZXRyeTtcblxudmFyIF9pc1JldHJ5QWxsb3dlZCA9IHJlcXVpcmUoJ2lzLXJldHJ5LWFsbG93ZWQnKTtcblxudmFyIF9pc1JldHJ5QWxsb3dlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1JldHJ5QWxsb3dlZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBuYW1lc3BhY2UgPSAnYXhpb3MtcmV0cnknO1xuXG4vKipcbiAqIEBwYXJhbSAge0Vycm9yfSAgZXJyb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTmV0d29ya0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiAhZXJyb3IucmVzcG9uc2UgJiYgQm9vbGVhbihlcnJvci5jb2RlKSAmJiAvLyBQcmV2ZW50cyByZXRyeWluZyBjYW5jZWxsZWQgcmVxdWVzdHNcbiAgZXJyb3IuY29kZSAhPT0gJ0VDT05OQUJPUlRFRCcgJiYgLy8gUHJldmVudHMgcmV0cnlpbmcgdGltZWQgb3V0IHJlcXVlc3RzXG4gICgwLCBfaXNSZXRyeUFsbG93ZWQyLmRlZmF1bHQpKGVycm9yKTsgLy8gUHJldmVudHMgcmV0cnlpbmcgdW5zYWZlIGVycm9yc1xufVxuXG52YXIgU0FGRV9IVFRQX01FVEhPRFMgPSBbJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXTtcbnZhciBJREVNUE9URU5UX0hUVFBfTUVUSE9EUyA9IFNBRkVfSFRUUF9NRVRIT0RTLmNvbmNhdChbJ3B1dCcsICdkZWxldGUnXSk7XG5cbi8qKlxuICogQHBhcmFtICB7RXJyb3J9ICBlcnJvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZXRyeWFibGVFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IuY29kZSAhPT0gJ0VDT05OQUJPUlRFRCcgJiYgKCFlcnJvci5yZXNwb25zZSB8fCBlcnJvci5yZXNwb25zZS5zdGF0dXMgPj0gNTAwICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA8PSA1OTkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge0Vycm9yfSAgZXJyb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2FmZVJlcXVlc3RFcnJvcihlcnJvcikge1xuICBpZiAoIWVycm9yLmNvbmZpZykge1xuICAgIC8vIENhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHJldHJpZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNSZXRyeWFibGVFcnJvcihlcnJvcikgJiYgU0FGRV9IVFRQX01FVEhPRFMuaW5kZXhPZihlcnJvci5jb25maWcubWV0aG9kKSAhPT0gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtICB7RXJyb3J9ICBlcnJvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJZGVtcG90ZW50UmVxdWVzdEVycm9yKGVycm9yKSB7XG4gIGlmICghZXJyb3IuY29uZmlnKSB7XG4gICAgLy8gQ2Fubm90IGRldGVybWluZSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgcmV0cmllZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1JldHJ5YWJsZUVycm9yKGVycm9yKSAmJiBJREVNUE9URU5UX0hUVFBfTUVUSE9EUy5pbmRleE9mKGVycm9yLmNvbmZpZy5tZXRob2QpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtFcnJvcn0gIGVycm9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGlzTmV0d29ya0Vycm9yKGVycm9yKSB8fCBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gLSBkZWxheSBpbiBtaWxsaXNlY29uZHMsIGFsd2F5cyAwXG4gKi9cbmZ1bmN0aW9uIG5vRGVsYXkoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gW3JldHJ5TnVtYmVyPTBdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIGV4cG9uZW50aWFsRGVsYXkoKSB7XG4gIHZhciByZXRyeU51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICB2YXIgZGVsYXkgPSBNYXRoLnBvdygyLCByZXRyeU51bWJlcikgKiAxMDA7XG4gIHZhciByYW5kb21TdW0gPSBkZWxheSAqIDAuMiAqIE1hdGgucmFuZG9tKCk7IC8vIDAtMjAlIG9mIHRoZSBkZWxheVxuICByZXR1cm4gZGVsYXkgKyByYW5kb21TdW07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIHJldHJ5IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdC9jb25maWdcbiAqIEBwYXJhbSAge0F4aW9zUmVxdWVzdENvbmZpZ30gY29uZmlnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGF0ZShjb25maWcpIHtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGNvbmZpZ1tuYW1lc3BhY2VdIHx8IHt9O1xuICBjdXJyZW50U3RhdGUucmV0cnlDb3VudCA9IGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50IHx8IDA7XG4gIGNvbmZpZ1tuYW1lc3BhY2VdID0gY3VycmVudFN0YXRlO1xuICByZXR1cm4gY3VycmVudFN0YXRlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGF4aW9zLXJldHJ5IG9wdGlvbnMgZm9yIHRoZSBjdXJyZW50IHJlcXVlc3RcbiAqIEBwYXJhbSAge0F4aW9zUmVxdWVzdENvbmZpZ30gY29uZmlnXG4gKiBAcGFyYW0gIHtBeGlvc1JldHJ5Q29uZmlnfSBkZWZhdWx0T3B0aW9uc1xuICogQHJldHVybiB7QXhpb3NSZXRyeUNvbmZpZ31cbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWVzdE9wdGlvbnMoY29uZmlnLCBkZWZhdWx0T3B0aW9ucykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIGNvbmZpZ1tuYW1lc3BhY2VdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtBeGlvc30gYXhpb3NcbiAqIEBwYXJhbSAge0F4aW9zUmVxdWVzdENvbmZpZ30gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGZpeENvbmZpZyhheGlvcywgY29uZmlnKSB7XG4gIGlmIChheGlvcy5kZWZhdWx0cy5hZ2VudCA9PT0gY29uZmlnLmFnZW50KSB7XG4gICAgZGVsZXRlIGNvbmZpZy5hZ2VudDtcbiAgfVxuICBpZiAoYXhpb3MuZGVmYXVsdHMuaHR0cEFnZW50ID09PSBjb25maWcuaHR0cEFnZW50KSB7XG4gICAgZGVsZXRlIGNvbmZpZy5odHRwQWdlbnQ7XG4gIH1cbiAgaWYgKGF4aW9zLmRlZmF1bHRzLmh0dHBzQWdlbnQgPT09IGNvbmZpZy5odHRwc0FnZW50KSB7XG4gICAgZGVsZXRlIGNvbmZpZy5odHRwc0FnZW50O1xuICB9XG59XG5cbi8qKlxuICogQWRkcyByZXNwb25zZSBpbnRlcmNlcHRvcnMgdG8gYW4gYXhpb3MgaW5zdGFuY2UgdG8gcmV0cnkgcmVxdWVzdHMgZmFpbGVkIGR1ZSB0byBuZXR3b3JrIGlzc3Vlc1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbiAqXG4gKiBheGlvc1JldHJ5KGF4aW9zLCB7IHJldHJpZXM6IDMgfSk7XG4gKlxuICogYXhpb3MuZ2V0KCdodHRwOi8vZXhhbXBsZS5jb20vdGVzdCcpIC8vIFRoZSBmaXJzdCByZXF1ZXN0IGZhaWxzIGFuZCB0aGUgc2Vjb25kIHJldHVybnMgJ29rJ1xuICogICAudGhlbihyZXN1bHQgPT4ge1xuICogICAgIHJlc3VsdC5kYXRhOyAvLyAnb2snXG4gKiAgIH0pO1xuICpcbiAqIC8vIEV4cG9uZW50aWFsIGJhY2stb2ZmIHJldHJ5IGRlbGF5IGJldHdlZW4gcmVxdWVzdHNcbiAqIGF4aW9zUmV0cnkoYXhpb3MsIHsgcmV0cnlEZWxheSA6IGF4aW9zUmV0cnkuZXhwb25lbnRpYWxEZWxheX0pO1xuICpcbiAqIC8vIEN1c3RvbSByZXRyeSBkZWxheVxuICogYXhpb3NSZXRyeShheGlvcywgeyByZXRyeURlbGF5IDogKHJldHJ5Q291bnQpID0+IHtcbiAqICAgcmV0dXJuIHJldHJ5Q291bnQgKiAxMDAwO1xuICogfX0pO1xuICpcbiAqIC8vIEFsc28gd29ya3Mgd2l0aCBjdXN0b20gYXhpb3MgaW5zdGFuY2VzXG4gKiBjb25zdCBjbGllbnQgPSBheGlvcy5jcmVhdGUoeyBiYXNlVVJMOiAnaHR0cDovL2V4YW1wbGUuY29tJyB9KTtcbiAqIGF4aW9zUmV0cnkoY2xpZW50LCB7IHJldHJpZXM6IDMgfSk7XG4gKlxuICogY2xpZW50LmdldCgnL3Rlc3QnKSAvLyBUaGUgZmlyc3QgcmVxdWVzdCBmYWlscyBhbmQgdGhlIHNlY29uZCByZXR1cm5zICdvaydcbiAqICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAqICAgICByZXN1bHQuZGF0YTsgLy8gJ29rJ1xuICogICB9KTtcbiAqXG4gKiAvLyBBbGxvd3MgcmVxdWVzdC1zcGVjaWZpYyBjb25maWd1cmF0aW9uXG4gKiBjbGllbnRcbiAqICAgLmdldCgnL3Rlc3QnLCB7XG4gKiAgICAgJ2F4aW9zLXJldHJ5Jzoge1xuICogICAgICAgcmV0cmllczogMFxuICogICAgIH1cbiAqICAgfSlcbiAqICAgLmNhdGNoKGVycm9yID0+IHsgLy8gVGhlIGZpcnN0IHJlcXVlc3QgZmFpbHNcbiAqICAgICBlcnJvciAhPT0gdW5kZWZpbmVkXG4gKiAgIH0pO1xuICpcbiAqIEBwYXJhbSB7QXhpb3N9IGF4aW9zIEFuIGF4aW9zIGluc3RhbmNlICh0aGUgYXhpb3Mgb2JqZWN0IG9yIG9uZSBjcmVhdGVkIGZyb20gYXhpb3MuY3JlYXRlKVxuICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0T3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdE9wdGlvbnMucmV0cmllcz0zXSBOdW1iZXIgb2YgcmV0cmllc1xuICogQHBhcmFtIHtib29sZWFufSBbZGVmYXVsdE9wdGlvbnMuc2hvdWxkUmVzZXRUaW1lb3V0PWZhbHNlXVxuICogICAgICAgIERlZmluZXMgaWYgdGhlIHRpbWVvdXQgc2hvdWxkIGJlIHJlc2V0IGJldHdlZW4gcmV0cmllc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2RlZmF1bHRPcHRpb25zLnJldHJ5Q29uZGl0aW9uPWlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcl1cbiAqICAgICAgICBBIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IgY2FuIGJlIHJldHJpZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtkZWZhdWx0T3B0aW9ucy5yZXRyeURlbGF5PW5vRGVsYXldXG4gKiAgICAgICAgQSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIGRlbGF5IGJldHdlZW4gcmV0cnkgcmVxdWVzdHNcbiAqL1xuZnVuY3Rpb24gYXhpb3NSZXRyeShheGlvcywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgYXhpb3MuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gZ2V0Q3VycmVudFN0YXRlKGNvbmZpZyk7XG4gICAgY3VycmVudFN0YXRlLmxhc3RSZXF1ZXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSk7XG5cbiAgYXhpb3MuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgY29uZmlnID0gZXJyb3IuY29uZmlnO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBubyBpbmZvcm1hdGlvbiB0byByZXRyeSB0aGUgcmVxdWVzdFxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBfZ2V0UmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9ucyhjb25maWcsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgICAgX2dldFJlcXVlc3RPcHRpb25zJHJlID0gX2dldFJlcXVlc3RPcHRpb25zLnJldHJpZXMsXG4gICAgICAgIHJldHJpZXMgPSBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUgPT09IHVuZGVmaW5lZCA/IDMgOiBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUsXG4gICAgICAgIF9nZXRSZXF1ZXN0T3B0aW9ucyRyZTIgPSBfZ2V0UmVxdWVzdE9wdGlvbnMucmV0cnlDb25kaXRpb24sXG4gICAgICAgIHJldHJ5Q29uZGl0aW9uID0gX2dldFJlcXVlc3RPcHRpb25zJHJlMiA9PT0gdW5kZWZpbmVkID8gaXNOZXR3b3JrT3JJZGVtcG90ZW50UmVxdWVzdEVycm9yIDogX2dldFJlcXVlc3RPcHRpb25zJHJlMixcbiAgICAgICAgX2dldFJlcXVlc3RPcHRpb25zJHJlMyA9IF9nZXRSZXF1ZXN0T3B0aW9ucy5yZXRyeURlbGF5LFxuICAgICAgICByZXRyeURlbGF5ID0gX2dldFJlcXVlc3RPcHRpb25zJHJlMyA9PT0gdW5kZWZpbmVkID8gbm9EZWxheSA6IF9nZXRSZXF1ZXN0T3B0aW9ucyRyZTMsXG4gICAgICAgIF9nZXRSZXF1ZXN0T3B0aW9ucyRzaCA9IF9nZXRSZXF1ZXN0T3B0aW9ucy5zaG91bGRSZXNldFRpbWVvdXQsXG4gICAgICAgIHNob3VsZFJlc2V0VGltZW91dCA9IF9nZXRSZXF1ZXN0T3B0aW9ucyRzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfZ2V0UmVxdWVzdE9wdGlvbnMkc2g7XG5cbiAgICB2YXIgY3VycmVudFN0YXRlID0gZ2V0Q3VycmVudFN0YXRlKGNvbmZpZyk7XG5cbiAgICB2YXIgc2hvdWxkUmV0cnkgPSByZXRyeUNvbmRpdGlvbihlcnJvcikgJiYgY3VycmVudFN0YXRlLnJldHJ5Q291bnQgPCByZXRyaWVzO1xuXG4gICAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgICBjdXJyZW50U3RhdGUucmV0cnlDb3VudCArPSAxO1xuICAgICAgdmFyIGRlbGF5ID0gcmV0cnlEZWxheShjdXJyZW50U3RhdGUucmV0cnlDb3VudCwgZXJyb3IpO1xuXG4gICAgICAvLyBBeGlvcyBmYWlscyBtZXJnaW5nIHRoaXMgY29uZmlndXJhdGlvbiB0byB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGJlY2F1c2UgaXQgaGFzIGFuIGlzc3VlXG4gICAgICAvLyB3aXRoIGNpcmN1bGFyIHN0cnVjdHVyZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL2F4aW9zL2lzc3Vlcy8zNzBcbiAgICAgIGZpeENvbmZpZyhheGlvcywgY29uZmlnKTtcblxuICAgICAgaWYgKCFzaG91bGRSZXNldFRpbWVvdXQgJiYgY29uZmlnLnRpbWVvdXQgJiYgY3VycmVudFN0YXRlLmxhc3RSZXF1ZXN0VGltZSkge1xuICAgICAgICB2YXIgbGFzdFJlcXVlc3REdXJhdGlvbiA9IERhdGUubm93KCkgLSBjdXJyZW50U3RhdGUubGFzdFJlcXVlc3RUaW1lO1xuICAgICAgICAvLyBNaW5pbXVtIDFtcyB0aW1lb3V0IChwYXNzaW5nIDAgb3IgbGVzcyB0byBYSFIgbWVhbnMgbm8gdGltZW91dClcbiAgICAgICAgY29uZmlnLnRpbWVvdXQgPSBNYXRoLm1heChjb25maWcudGltZW91dCAtIGxhc3RSZXF1ZXN0RHVyYXRpb24gLSBkZWxheSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0ID0gW2Z1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfV07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXhpb3MoY29uZmlnKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pO1xufVxuXG4vLyBDb21wYXRpYmlsaXR5IHdpdGggQ29tbW9uSlNcbmF4aW9zUmV0cnkuaXNOZXR3b3JrRXJyb3IgPSBpc05ldHdvcmtFcnJvcjtcbmF4aW9zUmV0cnkuaXNTYWZlUmVxdWVzdEVycm9yID0gaXNTYWZlUmVxdWVzdEVycm9yO1xuYXhpb3NSZXRyeS5pc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IgPSBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3I7XG5heGlvc1JldHJ5LmlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvciA9IGlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcjtcbmF4aW9zUmV0cnkuZXhwb25lbnRpYWxEZWxheSA9IGV4cG9uZW50aWFsRGVsYXk7XG5heGlvc1JldHJ5LmlzUmV0cnlhYmxlRXJyb3IgPSBpc1JldHJ5YWJsZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhheGlvcy5kZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0F4aW9zRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gZXhwb3J0cy5UV09fUE9XMjU2ID0gZXhwb3J0cy5NQVhfSU5URUdFUiA9IHZvaWQgMDtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogVGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIDJeMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBybHAgPSByZXF1aXJlKFwicmxwXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICAgIHNlbGYucmF3ID0gW107XG4gICAgc2VsZi5fZmllbGRzID0gW107XG4gICAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gdm9pZCAwKSB7IGxhYmVsID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqXzEgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIG9ial8xW2ZpZWxkXSA9IFwiMHhcIiArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9ial8xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlc18xLmJhVG9KU09OKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICAgICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgICAgICAgdiA9IGJ5dGVzXzEudG9CdWZmZXIodik7XG4gICAgICAgICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHYgPSBieXRlc18xLnN0cmlwWmVyb3Modik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgXCJUaGUgZmllbGQgXCIgKyBmaWVsZC5uYW1lICsgXCIgbXVzdCBub3QgaGF2ZSBtb3JlIFwiICsgZmllbGQubGVuZ3RoICsgXCIgYnl0ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiBcIiArIGZpZWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgICAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGJ5dGVzXzEudG9CdWZmZXIoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBrZXlzXzEgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzID0gdm9pZCAwO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWFkYXB0ZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbi8qKlxuICogUmV0dXJucyBhIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIHZhciBhZGRyID0gYnl0ZXNfMS56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgICByZXR1cm4gYnl0ZXNfMS5idWZmZXJUb0hleChhZGRyKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b28uXG4gKi9cbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHJldHVybiAvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIHplcm9BZGRyID0gZXhwb3J0cy56ZXJvQWRkcmVzcygpO1xuICAgIHJldHVybiB6ZXJvQWRkciA9PT0gYnl0ZXNfMS5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBJZiBhIGVpcDExOTFDaGFpbklkIGlzIHByb3ZpZGVkLCB0aGUgY2hhaW5JZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjaGVja3N1bSBjYWxjdWxhdGlvbi4gVGhpc1xuICogaGFzIHRoZSBlZmZlY3Qgb2YgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIGZvciBvbmUgY2hhaW4gaGF2aW5nIGludmFsaWQgY2hlY2tzdW1zIGZvciBvdGhlcnMuXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBjb25zdWx0IEVJUC0xMTkxLlxuICpcbiAqIFdBUk5JTkc6IENoZWNrc3VtcyB3aXRoIGFuZCB3aXRob3V0IHRoZSBjaGFpbklkIHdpbGwgZGlmZmVyLiBBcyBvZiAyMDE5LTA2LTI2LCB0aGUgbW9zdCBjb21tb25seVxuICogdXNlZCB2YXJpYXRpb24gaW4gRXRoZXJldW0gd2FzIHdpdGhvdXQgdGhlIGNoYWluSWQuIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgYWRkcmVzcyA9IGV0aGpzVXRpbC5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBwcmVmaXggPSBlaXAxMTkxQ2hhaW5JZCAhPT0gdW5kZWZpbmVkID8gZWlwMTE5MUNoYWluSWQudG9TdHJpbmcoKSArICcweCcgOiAnJztcbiAgICB2YXIgaGFzaCA9IGhhc2hfMS5rZWNjYWsocHJlZml4ICsgYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciByZXQgPSAnMHgnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBTZWUgdG9DaGVja3N1bUFkZHJlc3MnIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMgYWJvdXQgdGhlIGVpcDExOTFDaGFpbklkIHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkgPT09IGFkZHJlc3M7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3QuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICBmcm9tID0gYnl0ZXNfMS50b0J1ZmZlcihmcm9tKTtcbiAgICB2YXIgbm9uY2VCTiA9IG5ldyBCTihub25jZSk7XG4gICAgaWYgKG5vbmNlQk4uaXNaZXJvKCkpIHtcbiAgICAgICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgICAgICAvLyByZWFkIHRoZSBSTFAgZG9jdW1lbnRhdGlvbiBmb3IgYW4gYW5zd2VyIGlmIHlvdSBkYXJlXG4gICAgICAgIHJldHVybiBoYXNoXzEucmxwaGFzaChbZnJvbSwgbnVsbF0pLnNsaWNlKC0yMCk7XG4gICAgfVxuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiBoYXNoXzEucmxwaGFzaChbZnJvbSwgQnVmZmVyLmZyb20obm9uY2VCTi50b0FycmF5KCkpXSkuc2xpY2UoLTIwKTtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBzYWx0IEEgc2FsdFxuICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgdmFyIGZyb21CdWYgPSBieXRlc18xLnRvQnVmZmVyKGZyb20pO1xuICAgIHZhciBzYWx0QnVmID0gYnl0ZXNfMS50b0J1ZmZlcihzYWx0KTtcbiAgICB2YXIgaW5pdENvZGVCdWYgPSBieXRlc18xLnRvQnVmZmVyKGluaXRDb2RlKTtcbiAgICBhc3NlcnQoZnJvbUJ1Zi5sZW5ndGggPT09IDIwKTtcbiAgICBhc3NlcnQoc2FsdEJ1Zi5sZW5ndGggPT09IDMyKTtcbiAgICB2YXIgYWRkcmVzcyA9IGhhc2hfMS5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJ2ZmJywgJ2hleCcpLCBmcm9tQnVmLCBzYWx0QnVmLCBoYXNoXzEua2VjY2FrMjU2KGluaXRDb2RlQnVmKV0pKTtcbiAgICByZXR1cm4gYWRkcmVzcy5zbGljZSgtMjApO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pLlxuICovXG5leHBvcnRzLmlzUHJlY29tcGlsZWQgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciBhID0gYnl0ZXNfMS51bnBhZChhZGRyZXNzKTtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICovXG5leHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICAgIGlmIChzYW5pdGl6ZSA9PT0gdm9pZCAwKSB7IHNhbml0aXplID0gZmFsc2U7IH1cbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICAgIH1cbiAgICBpZiAoIXNhbml0aXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgICBpZiAoc2FuaXRpemUgPT09IHZvaWQgMCkgeyBzYW5pdGl6ZSA9IGZhbHNlOyB9XG4gICAgcHViS2V5ID0gYnl0ZXNfMS50b0J1ZmZlcihwdWJLZXkpO1xuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgICB9XG4gICAgYXNzZXJ0KHB1YktleS5sZW5ndGggPT09IDY0KTtcbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gaGFzaF8xLmtlY2NhayhwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MoZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHByaXZhdGVLZXkgPSBieXRlc18xLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAgIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxuICovXG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBwdWJsaWNLZXkgPSBieXRlc18xLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljS2V5O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWFkYXB0ZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgRUNEU0Egc2lnbmF0dXJlIG9mIGEgbWVzc2FnZSBoYXNoLlxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5LCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIHZhciByZWNvdmVyeSA9IHNpZy5yZWNvdmVyeTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICByOiBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpLFxuICAgICAgICB2OiBjaGFpbklkID8gcmVjb3ZlcnkgKyAoY2hhaW5JZCAqIDIgKyAzNSkgOiByZWNvdmVyeSArIDI3LFxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbn07XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBSZWNvdmVyZWQgcHVibGljIGtleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2J5dGVzXzEuc2V0TGVuZ3RoKHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICB2YXIgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gICAgcmV0dXJuIGJ5dGVzXzEuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgYnl0ZXNfMS50b0J1ZmZlcih2KV0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBidWYgPSBieXRlc18xLnRvQnVmZmVyKHNpZyk7XG4gICAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICBpZiAoYnVmLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgdmFyIHYgPSBidWZbNjRdO1xuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiArPSAyNztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgcjogYnVmLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogYnVmLnNsaWNlKDMyLCA2NCksXG4gICAgfTtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyLCBjaGFpbklkKSB7XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgPT09IHZvaWQgMCkgeyBob21lc3RlYWRPckxhdGVyID0gdHJ1ZTsgfVxuICAgIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgckJOID0gbmV3IEJOKHIpO1xuICAgIHZhciBzQk4gPSBuZXcgQk4ocyk7XG4gICAgaWYgKHJCTi5pc1plcm8oKSB8fCByQk4uZ3QoU0VDUDI1NksxX04pIHx8IHNCTi5pc1plcm8oKSB8fCBzQk4uZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JOLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHZhciBwcmVmaXggPSBCdWZmZXIuZnJvbShcIlxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIiArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCksICd1dGYtOCcpO1xuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgcmV0dXJuIGNoYWluSWQgPyB2IC0gKDIgKiBjaGFpbklkICsgMzUpIDogdiAtIDI3O1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgcmV0dXJuIHJlY292ZXJ5ID09PSAwIHx8IHJlY292ZXJ5ID09PSAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYVRvSlNPTiA9IGV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZXhwb3J0cy50b1Vuc2lnbmVkID0gZXhwb3J0cy5mcm9tU2lnbmVkID0gZXhwb3J0cy5idWZmZXJUb0hleCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBleHBvcnRzLnNldExlbmd0aCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuemVyb3MgPSB2b2lkIDA7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqL1xuZXhwb3J0cy56ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXJ8QXJyYXkpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSByaWdodCB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiAoQnVmZmVyfEFycmF5KVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSBmYWxzZTsgfVxuICAgIHZhciBidWYgPSBleHBvcnRzLnplcm9zKGxlbmd0aCk7XG4gICAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICAgIGlmIChyaWdodCkge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0TGVuZ3RoID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0O1xuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyfEFycmF5KVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXkpXG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YC5cbiAqIEBwYXJhbSBhIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqL1xuZXhwb3J0cy51bnBhZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgYSA9IGV0aGpzVXRpbC5zdHJpcEhleFByZWZpeChhKTtcbiAgICB2YXIgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbmV4cG9ydHMuc3RyaXBaZXJvcyA9IGV4cG9ydHMudW5wYWQ7XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChldGhqc1V0aWwuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20oZXRoanNVdGlsLnBhZFRvRXZlbihldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gYnVmZmVyLiB0b0J1ZmZlciBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGFuZCB0aGlzIHN0cmluZyB3YXMgZ2l2ZW46IFwiICsgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2ID0gZXRoanNVdGlsLmludFRvQnVmZmVyKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgICAgICAgIHYgPSB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtXG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XG59O1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gZXRoanNVdGlsLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTi5cbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxuICogQHJldHVybiAoQXJyYXl8U3RyaW5nfG51bGwpXG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgICAgICByZXR1cm4gXCIweFwiICsgYmEudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKGV4cG9ydHMuYmFUb0pTT04oYmFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ybHBoYXNoID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5rZWNjYWsgPSB2b2lkIDA7XG52YXIgX2EgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyksIGtlY2NhazIyNCA9IF9hLmtlY2NhazIyNCwga2VjY2FrMzg0ID0gX2Eua2VjY2FrMzg0LCBrMjU2ID0gX2Eua2VjY2FrMjU2LCBrZWNjYWs1MTIgPSBfYS5rZWNjYWs1MTI7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIHJscCA9IHJlcXVpcmUoXCJybHBcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKSBJZiB0aGUgc3RyaW5nIGlzIGEgMHgtcHJlZml4ZWQgaGV4IHZhbHVlXG4gKiBpdCdzIGludGVycHJldGVkIGFzIGhleGFkZWNpbWFsLCBvdGhlcndpc2UgYXMgdXRmOC5cbiAqIEBwYXJhbSBiaXRzIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgIWV0aGpzVXRpbC5pc0hleFN0cmluZyhhKSkge1xuICAgICAgICBhID0gQnVmZmVyLmZyb20oYSwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIH1cbiAgICBpZiAoIWJpdHMpXG4gICAgICAgIGJpdHMgPSAyNTY7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMjI0OiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjI0KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU2OiB7XG4gICAgICAgICAgICByZXR1cm4gazI1NihhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM4NDoge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazM4NChhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDUxMjoge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazUxMihhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWtcIiArIGJpdHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NikuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGEpXG4gICAgICAgIC5kaWdlc3QoKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJylcbiAgICAgICAgLnVwZGF0ZShhKVxuICAgICAgICAuZGlnZXN0KCk7XG4gICAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYnl0ZXNfMS5zZXRMZW5ndGgoaGFzaCwgMzIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhXG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGV4cG9ydHMuZWNkaCA9IGV4cG9ydHMucmVjb3ZlciA9IGV4cG9ydHMudmVyaWZ5ID0gZXhwb3J0cy5zaWduID0gZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBleHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZXhwb3J0cy5zaWduYXR1cmVOb3JtYWxpemUgPSBleHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBleHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBleHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG52YXIgc2VjcDI1NmsxdjMgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtbGliL2RlcicpO1xuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcbiAgICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLnByaXZhdGVLZXlNb2RJbnZlcnNlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgYSBwcml2YXRlS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlDcmVhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2VhayB2YWx1ZVxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHB1YmxpY0tleXMuZm9yRWFjaChmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKGtleXMsIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gICAgfVxuICAgIHZhciBzaWduT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBzaWduT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICAgICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgICAgIHJlY292ZXJ5OiBzaWcucmVjaWQsXG4gICAgfTtcbn07XG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJlY292ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVjZGggPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAgIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azF2My1hZGFwdGVyLmpzLm1hcCIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3dhcHBhYmxlUHJveHkgKGluaXRpYWxUYXJnZXQpIHtcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXRcblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgIGdldDogKF8sIG5hbWUpID0+IHtcbiAgICAgIC8vIG92ZXJyaWRlIGBzZXRUYXJnZXRgIGFjY2Vzc1xuICAgICAgaWYgKG5hbWUgPT09ICdzZXRUYXJnZXQnKSByZXR1cm4gc2V0VGFyZ2V0XG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdXG4gICAgfSxcbiAgICBzZXQ6IChfLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gYWxsb3cgYHNldFRhcmdldGAgb3ZlcnJpZGVzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHtcbiAgICAgICAgc2V0VGFyZ2V0ID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIHByb3h5XG5cbiAgZnVuY3Rpb24gc2V0VGFyZ2V0KG5ld1RhcmdldCkge1xuICAgIHRhcmdldCA9IG5ld1RhcmdldFxuICB9XG59XG4iLCJjb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZVxuY29uc3QgaW50ZXJuYWxFdmVudHMgPSBbJ25ld0xpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ11cbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSAobmFtZSkgPT4gIWludGVybmFsRXZlbnRzLmluY2x1ZGVzKG5hbWUpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgKGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBsZXQgZXZlbnRGaWx0ZXIgPSBvcHRzLmV2ZW50RmlsdGVyIHx8IGZpbHRlck5vb3BcbiAgaWYgKGV2ZW50RmlsdGVyID09PSAnc2tpcEludGVybmFsJykgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyXG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgLSBJbnZhbGlkIGV2ZW50RmlsdGVyJylcblxuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldFxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHJldHVybiBzZXRUYXJnZXRcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveHlcblxuICBmdW5jdGlvbiBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0XG4gICAgLy8gbWlncmF0ZSBsaXN0ZW5lcnNcbiAgICBvbGRUYXJnZXQuZXZlbnROYW1lcygpLmZpbHRlcihldmVudEZpbHRlcikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgZ2V0UmF3TGlzdGVuZXJzKG9sZFRhcmdldCwgbmFtZSkuZm9yRWFjaChoYW5kbGVyID0+IG5ld1RhcmdldC5vbihuYW1lLCBoYW5kbGVyKSlcbiAgICB9KVxuICAgIC8vIHJlbW92ZSBvbGRcbiAgICBvbGRUYXJnZXQucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYXdMaXN0ZW5lcnMoZXZlbnRFbWl0dGVyLCBuYW1lKSB7XG4gIC8vIHByZWZlciBuYXRpdmVcbiAgaWYgKGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMpIHJldHVybiBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpXG4gIC8vIGZhbGxiYWNrIHRvIGxvb2t1cCBhZ2FpbnN0IGludGVybmFsIG9iamVjdFxuICBsZXQgZXZlbnRzID0gZXZlbnRFbWl0dGVyLl9ldmVudHNbbmFtZV0gfHwgW11cbiAgLy8gZW5zdXJlIGFycmF5XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKSBldmVudHMgPSBbZXZlbnRzXVxuICAvLyByZXR1cm4gY29weVxuICByZXR1cm4gZXZlbnRzLnNsaWNlKClcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmFzZUJsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUG9sbGluZ0Jsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU3Vic2NyaWJlQmxvY2tUcmFja2VyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIEJhc2U1OCBlbmNvZGluZy9kZWNvZGluZ1xuLy8gT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuLy8gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuLy8gTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcblxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG52YXIgQUxQSEFCRVRfTUFQID0ge31cbmZvcih2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICBBTFBIQUJFVF9NQVBbQUxQSEFCRVQuY2hhckF0KGkpXSA9IGlcbn1cbnZhciBCQVNFID0gNThcblxuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG5cbiAgdmFyIGksIGosIGRpZ2l0cyA9IFswXVxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7IGorKykgZGlnaXRzW2pdIDw8PSA4XG5cbiAgICBkaWdpdHNbMF0gKz0gYnVmZmVyW2ldXG5cbiAgICB2YXIgY2FycnkgPSAwXG4gICAgZm9yIChqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgZGlnaXRzW2pdICs9IGNhcnJ5XG5cbiAgICAgIGNhcnJ5ID0gKGRpZ2l0c1tqXSAvIEJBU0UpIHwgMFxuICAgICAgZGlnaXRzW2pdICU9IEJBU0VcbiAgICB9XG5cbiAgICB3aGlsZSAoY2FycnkpIHtcbiAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgQkFTRSlcblxuICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSB8IDBcbiAgICB9XG4gIH1cblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IgKGkgPSAwOyBidWZmZXJbaV0gPT09IDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIGRpZ2l0cy5wdXNoKDApXG5cbiAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgdmFyIHN0cmluZ091dHB1dCA9IFwiXCJcbiAgZm9yICh2YXIgaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0cmluZ091dHB1dCA9IHN0cmluZ091dHB1dCArIEFMUEhBQkVUW2RpZ2l0c1tpXV1cbiAgfVxuICByZXR1cm4gc3RyaW5nT3V0cHV0XG59XG5cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBbXVxuXG4gIHZhciBpLCBqLCBieXRlcyA9IFswXVxuICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHJpbmdbaV1cbiAgICBpZiAoIShjIGluIEFMUEhBQkVUX01BUCkpIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2U1OCBjaGFyYWN0ZXInKVxuXG4gICAgZm9yIChqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgaisrKSBieXRlc1tqXSAqPSBCQVNFXG4gICAgYnl0ZXNbMF0gKz0gQUxQSEFCRVRfTUFQW2NdXG5cbiAgICB2YXIgY2FycnkgPSAwXG4gICAgZm9yIChqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBieXRlc1tqXSArPSBjYXJyeVxuXG4gICAgICBjYXJyeSA9IGJ5dGVzW2pdID4+IDhcbiAgICAgIGJ5dGVzW2pdICY9IDB4ZmZcbiAgICB9XG5cbiAgICB3aGlsZSAoY2FycnkpIHtcbiAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKVxuXG4gICAgICBjYXJyeSA+Pj0gOFxuICAgIH1cbiAgfVxuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvciAoaSA9IDA7IHN0cmluZ1tpXSA9PT0gJzEnICYmIGkgPCBzdHJpbmcubGVuZ3RoIC0gMTsgaSsrKSBieXRlcy5wdXNoKDApXG5cbiAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG5cbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4uL21lc3NhZ2VzLmpzb24nKVxuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG52YXIgZWNwYXJhbXMgPSBlYy5jdXJ2ZVxuXG5mdW5jdGlvbiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhCdWZmZXIpIHtcbiAgdmFyIHggPSBuZXcgQk4oeEJ1ZmZlcilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGNvbXB1dGUgY29ycmVzcG9uZGluZyBZXG4gIHZhciB5ID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpLnJlZElBZGQoZWNwYXJhbXMuYikucmVkU3FydCgpXG4gIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpIHkgPSB5LnJlZE5lZygpXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4QnVmZmVyLCB5QnVmZmVyKSB7XG4gIHZhciB4ID0gbmV3IEJOKHhCdWZmZXIpXG4gIHZhciB5ID0gbmV3IEJOKHlCdWZmZXIpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDAgfHwgeS5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcblxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG4gIHkgPSB5LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBpcyBvZGQgZmxhZ1xuICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpIHJldHVybiBudWxsXG5cbiAgLy8geCp4KnggKyBiID0geSp5XG4gIHZhciB4MyA9IHgucmVkU3FyKCkucmVkSU11bCh4KVxuICBpZiAoIXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjcGFyYW1zLmIpKS5pc1plcm8oKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleSAocHVibGljS2V5KSB7XG4gIHZhciBmaXJzdCA9IHB1YmxpY0tleVswXVxuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweDAyOlxuICAgIGNhc2UgMHgwMzpcbiAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVibGljS2V5LnNsaWNlKDEsIDMzKSlcbiAgICBjYXNlIDB4MDQ6XG4gICAgY2FzZSAweDA2OlxuICAgIGNhc2UgMHgwNzpcbiAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJsaWNLZXkuc2xpY2UoMSwgMzMpLCBwdWJsaWNLZXkuc2xpY2UoMzMsIDY1KSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgcmV0dXJuIGJuLmNtcChlY3BhcmFtcy5uKSA8IDAgJiYgIWJuLmlzWmVybygpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9FWFBPUlRfREVSX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi5pc1plcm8oKSA/IEJ1ZmZlci5hbGxvYygzMikgOiBlY3BhcmFtcy5uLnN1YihibikudW1vZChlY3BhcmFtcy5uKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1JBTkdFX0lOVkFMSUQpXG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICBibi5pYWRkKG5ldyBCTihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibi5pc3ViKGVjcGFyYW1zLm4pXG4gIGlmIChibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHJldHVybiBibi50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICB2YXIgYm4gPSBuZXcgQk4odHdlYWspXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RXRUFLX01VTF9GQUlMKVxuXG4gIGJuLmltdWwobmV3IEJOKHByaXZhdGVLZXkpKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pKSBibiA9IGJuLnVtb2QoZWNwYXJhbXMubilcblxuICByZXR1cm4gYm4udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9DUkVBVEVfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKGNvbXByZXNzZWQsIHRydWUpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiAocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwYWlyLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHJldHVybiBsb2FkUHVibGljS2V5KHB1YmxpY0tleSkgIT09IG51bGxcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHZhciBwb2ludCA9IGVjcGFyYW1zLmcubXVsKHR3ZWFrKS5hZGQocGFpci5wdWIpXG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHR3ZWFrLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19NVUxfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5wdWIubXVsKHR3ZWFrKS5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlycyA9IG5ldyBBcnJheShwdWJsaWNLZXlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleXNbaV0pXG4gICAgaWYgKHBhaXJzW2ldID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuICB9XG5cbiAgdmFyIHBvaW50ID0gcGFpcnNbMF0ucHViXG4gIGZvciAodmFyIGogPSAxOyBqIDwgcGFpcnMubGVuZ3RoOyArK2opIHBvaW50ID0gcG9pbnQuYWRkKHBhaXJzW2pdLnB1YilcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfQ09NQklORV9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKVxuICB2YXIgcyA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSlcbiAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgcy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUpXG4gIGlmIChzLmNtcChlYy5uaCkgPT09IDEpIGVjcGFyYW1zLm4uc3ViKHMpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocmVzdWx0LCAzMilcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IHNpZ25hdHVyZS5zbGljZSgwLCAzMilcbiAgdmFyIHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KVxuICBpZiAobmV3IEJOKHIpLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IG5ldyBCTihzKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpXG4gIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByID0gbmV3IEJOKDApXG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpXG4gIGlmIChzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBzID0gbmV3IEJOKDApXG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgIHIudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksXG4gICAgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICBdKVxufVxuXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgbm9uY2VmbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG5vbmNlZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZ2V0Tm9uY2UgPSBub25jZWZuXG4gICAgbm9uY2VmbiA9IGZ1bmN0aW9uIChjb3VudGVyKSB7XG4gICAgICB2YXIgbm9uY2UgPSBnZXROb25jZShtZXNzYWdlLCBwcml2YXRlS2V5LCBudWxsLCBkYXRhLCBjb3VudGVyKVxuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobm9uY2UpIHx8IG5vbmNlLmxlbmd0aCAhPT0gMzIpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgICAgIHJldHVybiBuZXcgQk4obm9uY2UpXG4gICAgfVxuICB9XG5cbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05fRkFJTClcblxuICB2YXIgcmVzdWx0ID0gZWMuc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCB7IGNhbm9uaWNhbDogdHJ1ZSwgazogbm9uY2VmbiwgcGVyczogZGF0YSB9KVxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmNvbmNhdChbXG4gICAgICByZXN1bHQuci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSxcbiAgICAgIHJlc3VsdC5zLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG4gICAgXSksXG4gICAgcmVjb3Zlcnk6IHJlc3VsdC5yZWNvdmVyeVBhcmFtXG4gIH1cbn1cblxuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgdmFyIHNpZ09iaiA9IHsgcjogc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSwgczogc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkgfVxuXG4gIHZhciBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICB2YXIgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuICBpZiAoc2lncy5jbXAoZWMubmgpID09PSAxIHx8IHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgcmV0dXJuIGVjLnZlcmlmeShtZXNzYWdlLCBzaWdPYmosIHsgeDogcGFpci5wdWIueCwgeTogcGFpci5wdWIueSB9KVxufVxuXG5leHBvcnRzLnJlY292ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNvdmVyeSwgY29tcHJlc3NlZCkge1xuICB2YXIgc2lnT2JqID0geyByOiBzaWduYXR1cmUuc2xpY2UoMCwgMzIpLCBzOiBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSB9XG5cbiAgdmFyIHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gIHZhciBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUwpXG5cbiAgdHJ5IHtcbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IoKVxuXG4gICAgdmFyIHBvaW50ID0gZWMucmVjb3ZlclB1YktleShtZXNzYWdlLCBzaWdPYmosIHJlY292ZXJ5KVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9SRUNPVkVSX0ZBSUwpXG4gIH1cbn1cblxuZXhwb3J0cy5lY2RoID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICB2YXIgc2hhcmVkID0gZXhwb3J0cy5lY2RoVW5zYWZlKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgdHJ1ZSlcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzaGFyZWQpLmRpZ2VzdCgpXG59XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgdmFyIHNjYWxhciA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoc2NhbGFyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDREhfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5wdWIubXVsKHNjYWxhcikuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKVxudmFyIGRlciA9IHJlcXVpcmUoJy4vZGVyJylcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMuanNvbicpXG5cbmZ1bmN0aW9uIGluaXRDb21wcmVzc2VkVmFsdWUgKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBkZWZhdWx0VmFsdWVcblxuICBhc3NlcnQuaXNCb29sZWFuKHZhbHVlLCBtZXNzYWdlcy5DT01QUkVTU0VEX1RZUEVfSU5WQUxJRClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlY3AyNTZrMSkge1xuICByZXR1cm4ge1xuICAgIHByaXZhdGVLZXlWZXJpZnk6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgcmV0dXJuIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5RXhwb3J0OiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG4gICAgICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZClcblxuICAgICAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZClcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleUltcG9ydDogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG5cbiAgICAgIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KVxuICAgICAgaWYgKHByaXZhdGVLZXkgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSByZXR1cm4gcHJpdmF0ZUtleVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfSU1QT1JUX0RFUl9GQUlMKVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlOiBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TW9kSW52ZXJzZTogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlNb2RJbnZlcnNlKHByaXZhdGVLZXkpXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha0FkZDogZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQocHJpdmF0ZUtleSwgdHdlYWspXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bDogZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwocHJpdmF0ZUtleSwgdHdlYWspXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZTogZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb252ZXJ0OiBmdW5jdGlvbiAocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeTogZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkOiBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIodHdlYWssIG1lc3NhZ2VzLlRXRUFLX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aCh0d2VhaywgMzIsIG1lc3NhZ2VzLlRXRUFLX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrTXVsOiBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIodHdlYWssIG1lc3NhZ2VzLlRXRUFLX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aCh0d2VhaywgMzIsIG1lc3NhZ2VzLlRXRUFLX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbWJpbmU6IGZ1bmN0aW9uIChwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNBcnJheShwdWJsaWNLZXlzLCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZU19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNMZW5ndGhHVFplcm8ocHVibGljS2V5cywgbWVzc2FnZXMuRUNfUFVCTElDX0tFWVNfTEVOR1RIX0lOVkFMSUQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB1YmxpY0tleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleXNbaV0sIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleXNbaV0sIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcbiAgICAgIH1cblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZTogZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSlcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0OiBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgdmFyIHNpZ09iaiA9IHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoc2lnbmF0dXJlKVxuICAgICAgcmV0dXJuIGRlci5zaWduYXR1cmVFeHBvcnQoc2lnT2JqKVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVJbXBvcnQ6IGZ1bmN0aW9uIChzaWcpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihzaWcsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNMZW5ndGhHVFplcm8oc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0KHNpZylcbiAgICAgIGlmIChzaWdPYmopIHJldHVybiBzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KHNpZ09iailcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9ERVJfRkFJTClcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0TGF4OiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWcpXG4gICAgICBpZiAoc2lnT2JqKSByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWdPYmopXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUwpXG4gICAgfSxcblxuICAgIHNpZ246IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBkYXRhID0gbnVsbFxuICAgICAgdmFyIG5vbmNlZm4gPSBudWxsXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydC5pc09iamVjdChvcHRpb25zLCBtZXNzYWdlcy5PUFRJT05TX1RZUEVfSU5WQUxJRClcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhc3NlcnQuaXNCdWZmZXIob3B0aW9ucy5kYXRhLCBtZXNzYWdlcy5PUFRJT05TX0RBVEFfVFlQRV9JTlZBTElEKVxuICAgICAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChvcHRpb25zLmRhdGEsIDMyLCBtZXNzYWdlcy5PUFRJT05TX0RBVEFfTEVOR1RIX0lOVkFMSUQpXG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2VmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0LmlzRnVuY3Rpb24ob3B0aW9ucy5ub25jZWZuLCBtZXNzYWdlcy5PUFRJT05TX05PTkNFRk5fVFlQRV9JTlZBTElEKVxuICAgICAgICAgIG5vbmNlZm4gPSBvcHRpb25zLm5vbmNlZm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgbm9uY2VmbiwgZGF0YSlcbiAgICB9LFxuXG4gICAgdmVyaWZ5OiBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihtZXNzYWdlLCBtZXNzYWdlcy5NU0czMl9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgobWVzc2FnZSwgMzIsIG1lc3NhZ2VzLk1TRzMyX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSlcbiAgICB9LFxuXG4gICAgcmVjb3ZlcjogZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihtZXNzYWdlLCBtZXNzYWdlcy5NU0czMl9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgobWVzc2FnZSwgMzIsIG1lc3NhZ2VzLk1TRzMyX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzTnVtYmVyKHJlY292ZXJ5LCBtZXNzYWdlcy5SRUNPVkVSWV9JRF9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNOdW1iZXJJbkludGVydmFsKHJlY292ZXJ5LCAtMSwgNCwgbWVzc2FnZXMuUkVDT1ZFUllfSURfVkFMVUVfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5yZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIGVjZGg6IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuZWNkaChwdWJsaWNLZXksIHByaXZhdGVLZXkpXG4gICAgfSxcblxuICAgIGVjZGhVbnNhZmU6IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9hcGknKShyZXF1aXJlKCcuL2xpYi9rZWNjYWsnKSlcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoJ2tlY2NhaycpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsnICsgYml0cykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleC5qcycpXHJcbiIsInZhciBjb3JlID0gcmVxdWlyZShcIi4vY29tbW9uanMvY29yZS5qc1wiKTtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgY29yZSk7XG5cbnZhciBkdXBsZXggPSByZXF1aXJlKFwiLi9jb21tb25qcy9kdXBsZXguanNcIik7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIGR1cGxleCk7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vY29tbW9uanMvaGVscGVycy5qc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzLlBhdGNoRXJyb3I7XG5leHBvcnRzLmRlZXBDbG9uZSA9IGhlbHBlcnMuX2RlZXBDbG9uZTtcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnMuZXNjYXBlUGF0aENvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gaGVscGVycy51bmVzY2FwZVBhdGhDb21wb25lbnQ7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnByb21pc2lmeUNiID0gZXhwb3J0cy5leGlzdHNJbiA9IGV4cG9ydHMuaXNBc2NpaVN0ciA9IGV4cG9ydHMuYnVpbGRTaWduZXJQYXRoQnVmID0gZXhwb3J0cy5nZXRQMjU2S2V5UGFpckZyb21QdWIgPSBleHBvcnRzLmdldFAyNTZLZXlQYWlyID0gZXhwb3J0cy5wYXJzZURFUiA9IGV4cG9ydHMuYWVzMjU2X2RlY3J5cHQgPSBleHBvcnRzLmFlczI1Nl9lbmNyeXB0ID0gZXhwb3J0cy5maXhMZW4gPSBleHBvcnRzLmVuc3VyZUhleEJ1ZmZlciA9IGV4cG9ydHMuc3BsaXRGcmFtZXMgPSBleHBvcnRzLmlzVmFsaWRBc3NldFBhdGggPSBleHBvcnRzLnRvUGFkZGVkREVSID0gZXhwb3J0cy5jaGVja3N1bSA9IGV4cG9ydHMucGFyc2VMYXR0aWNlMVJlc3BvbnNlID0gdm9pZCAwO1xuLy8gU3RhdGljIHV0aWxpdHkgZnVuY3Rpb25zXG52YXIgYWVzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFlcy1qc1wiKSk7XG52YXIgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbnZhciBjcmNfMzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3JjLTMyXCIpKTtcbnZhciBlbGxpcHRpY18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbGxpcHRpY1wiKSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgQ09JTlMgPSBjb25zdGFudHNfMS5CSVBfQ09OU1RBTlRTLkNPSU5TLCBQVVJQT1NFUyA9IGNvbnN0YW50c18xLkJJUF9DT05TVEFOVFMuUFVSUE9TRVM7XG52YXIgRUMgPSBlbGxpcHRpY18xLmRlZmF1bHQuZWM7XG52YXIgZWMgPSBuZXcgRUMoJ3AyNTYnKTtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExBVFRJQ0UgVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlIGEgcmVzcG9uc2UgZnJvbSB0aGUgTGF0dGljZTFcbnZhciBwYXJzZUxhdHRpY2UxUmVzcG9uc2UgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgIGVycjogbnVsbCxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICB9O1xuICAgIHZhciBiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20ociwgJ2hleCcpO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIC8vIEdldCBwcm90b2NvbCB2ZXJzaW9uXG4gICAgdmFyIHByb3RvVmVyID0gYi5yZWFkVUludDgob2ZmKTtcbiAgICBvZmYrKztcbiAgICBpZiAocHJvdG9WZXIgIT09IGNvbnN0YW50c18xLlZFUlNJT05fQllURSkge1xuICAgICAgICBwYXJzZWQuZXJyID0gJ0luY29ycmVjdCBwcm90b2NvbCB2ZXJzaW9uLiBQbGVhc2UgdXBkYXRlIHlvdXIgU0RLJztcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSB0eXBlIG9mIHJlc3BvbnNlXG4gICAgLy8gU2hvdWxkIGFsd2F5cyBiZSAweDAwXG4gICAgdmFyIG1zZ1R5cGUgPSBiLnJlYWRVSW50OChvZmYpO1xuICAgIG9mZisrO1xuICAgIGlmIChtc2dUeXBlICE9PSAweDAwKSB7XG4gICAgICAgIHBhcnNlZC5lcnIgPSAnSW5jb3JyZWN0IHJlc3BvbnNlIGZyb20gTGF0dGljZTEnO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHBheWxvYWRcbiAgICBiLnJlYWRVSW50MzJCRShvZmYpO1xuICAgIG9mZiArPSA0OyAvLyBGaXJzdCA0IGJ5dGVzIGlzIHRoZSBpZCwgYnV0IHdlIGRvbid0IG5lZWQgdGhhdCBhbnltb3JlXG4gICAgdmFyIGxlbiA9IGIucmVhZFVJbnQxNkJFKG9mZik7XG4gICAgb2ZmICs9IDI7XG4gICAgdmFyIHBheWxvYWQgPSBiLnNsaWNlKG9mZiwgb2ZmICsgbGVuKTtcbiAgICBvZmYgKz0gbGVuO1xuICAgIC8vIEdldCByZXNwb25zZSBjb2RlXG4gICAgdmFyIHJlc3BvbnNlQ29kZSA9IHBheWxvYWQucmVhZFVJbnQ4KDApO1xuICAgIGlmIChyZXNwb25zZUNvZGUgIT09IGNvbnN0YW50c18xLnJlc3BvbnNlQ29kZXMuUkVTUF9TVUNDRVNTKSB7XG4gICAgICAgIHBhcnNlZC5lcnIgPSBcIlwiLmNvbmNhdChjb25zdGFudHNfMS5yZXNwb25zZU1zZ3NbcmVzcG9uc2VDb2RlXSA/IGNvbnN0YW50c18xLnJlc3BvbnNlTXNnc1tyZXNwb25zZUNvZGVdIDogJ1Vua25vd24gRXJyb3InLCBcIiAoTGF0dGljZSlcIik7XG4gICAgICAgIHBhcnNlZC5yZXNwb25zZUNvZGUgPSByZXNwb25zZUNvZGU7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWQuZGF0YSA9IHBheWxvYWQuc2xpY2UoMSwgcGF5bG9hZC5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBWZXJpZnkgY2hlY2tzdW1cbiAgICB2YXIgY3MgPSBiLnJlYWRVSW50MzJCRShvZmYpO1xuICAgIHZhciBleHBlY3RlZENzID0gKDAsIGV4cG9ydHMuY2hlY2tzdW0pKGIuc2xpY2UoMCwgYi5sZW5ndGggLSA0KSk7XG4gICAgaWYgKGNzICE9PSBleHBlY3RlZENzKSB7XG4gICAgICAgIHBhcnNlZC5lcnIgPSAnSW52YWxpZCBjaGVja3N1bSBmcm9tIGRldmljZSByZXNwb25zZSc7XG4gICAgICAgIHBhcnNlZC5kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5leHBvcnRzLnBhcnNlTGF0dGljZTFSZXNwb25zZSA9IHBhcnNlTGF0dGljZTFSZXNwb25zZTtcbnZhciBjaGVja3N1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgLy8gY3JjMzIgcmV0dXJucyBhIHNpZ25lZCBpbnRlZ2VyIC0gbmVlZCB0byBjYXN0IGl0IHRvIHVuc2lnbmVkXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCAweGVkYjg4MzIwIHBvbHlub21pYWxcbiAgICByZXR1cm4gY3JjXzMyXzEuZGVmYXVsdC5idWYoeCkgPj4+IDA7IC8vIE5lZWQgdGhpcyB0byBiZSBhIHVpbnQsIGhlbmNlIHRoZSBiaXQgc2hpZnRcbn07XG5leHBvcnRzLmNoZWNrc3VtID0gY2hlY2tzdW07XG4vLyBHZXQgYSA3NC1ieXRlIHBhZGRlZCBERVItZW5jb2RlZCBzaWduYXR1cmUgYnVmZmVyXG4vLyBgc2lnYCBtdXN0IGJlIHRoZSBzaWduYXR1cmUgb3V0cHV0IGZyb20gZWxsaXB0aWMuanNcbnZhciB0b1BhZGRlZERFUiA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICAvLyBXZSB1c2UgNzQgYXMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIGEgREVSIHNpZ25hdHVyZS4gQWxsIHNpZ3MgbXVzdFxuICAgIC8vIGJlIHJpZ2h0LXBhZGRlZCB3aXRoIHplcm9zIHNvIHRoYXQgdGhpcyBjYW4gYmUgYSBmaXhlZCBzaXplIGZpZWxkXG4gICAgdmFyIGIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNzQpO1xuICAgIHZhciBkcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNpZy50b0RFUigpKTtcbiAgICBkcy5jb3B5KGIpO1xuICAgIHJldHVybiBiO1xufTtcbmV4cG9ydHMudG9QYWRkZWRERVIgPSB0b1BhZGRlZERFUjtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRSQU5TQUNUSU9OIFVUSUxTXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgaXNWYWxpZEFzc2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBmd0NvbnN0YW50cykge1xuICAgIHZhciBhbGxvd2VkUHVycG9zZXMgPSBbXG4gICAgICAgIFBVUlBPU0VTLkVUSCxcbiAgICAgICAgUFVSUE9TRVMuQlRDX0xFR0FDWSxcbiAgICAgICAgUFVSUE9TRVMuQlRDX1dSQVBQRURfU0VHV0lULFxuICAgICAgICBQVVJQT1NFUy5CVENfU0VHV0lULFxuICAgIF07XG4gICAgdmFyIGFsbG93ZWRDb2lucyA9IFtDT0lOUy5FVEgsIENPSU5TLkJUQywgQ09JTlMuQlRDX1RFU1RORVRdO1xuICAgIC8vIFRoZXNlIGNvaW4gdHlwZXMgd2VyZSBnaXZlbiB0byB1cyBieSBNeUNyeXB0by4gVGhleSBzaG91bGQgYmUgYWxsb3dlZCwgYnV0IHdlIGV4cGVjdFxuICAgIC8vIGFuIEV0aGVyZXVtLXR5cGUgYWRkcmVzcyB3aXRoIHRoZXNlIGNvaW4gdHlwZXMuXG4gICAgLy8gVGhlc2UgYWxsIHVzZSBTTElQNDQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iL21hc3Rlci9zbGlwLTAwNDQubWRcbiAgICB2YXIgYWxsb3dlZE15Q3J5cHRvQ29pbnMgPSBbXG4gICAgICAgIDYwLCA2MSwgOTY2LCA3MDAsIDkwMDYsIDkwMDAsIDEwMDcsIDU1MywgMTc4LCAxMzcsIDM3MzEwLCAxMDgsIDQwLCA4ODksXG4gICAgICAgIDE5ODcsIDgyMCwgNjA2MCwgMTYyMCwgMTMxMzExNCwgNzYsIDI0NjUyOSwgMjQ2Nzg1LCAxMDAxLCAyMjcsIDkxNiwgNDY0LFxuICAgICAgICAyMjIxLCAzNDQsIDczNzk5LCAyNDYsXG4gICAgXTtcbiAgICAvLyBNYWtlIHN1cmUgZmlybXdhcmUgc3VwcG9ydHMgdGhpcyBCaXRjb2luIHBhdGhcbiAgICB2YXIgaXNCaXRjb2luID0gcGF0aFsxXSA9PT0gQ09JTlMuQlRDIHx8IHBhdGhbMV0gPT09IENPSU5TLkJUQ19URVNUTkVUO1xuICAgIHZhciBpc0JpdGNvaW5Ob25XcmFwcGVkU2Vnd2l0ID0gaXNCaXRjb2luICYmIHBhdGhbMF0gIT09IFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVDtcbiAgICBpZiAoaXNCaXRjb2luTm9uV3JhcHBlZFNlZ3dpdCAmJiAhZndDb25zdGFudHMuYWxsb3dCdGNMZWdhY3lBbmRTZWd3aXRBZGRycylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBhdGggaXMgb3RoZXJ3aXNlIHZhbGlkXG4gICAgcmV0dXJuIChhbGxvd2VkUHVycG9zZXMuaW5kZXhPZihwYXRoWzBdKSA+PSAwICYmXG4gICAgICAgIChhbGxvd2VkQ29pbnMuaW5kZXhPZihwYXRoWzFdKSA+PSAwIHx8XG4gICAgICAgICAgICBhbGxvd2VkTXlDcnlwdG9Db2lucy5pbmRleE9mKHBhdGhbMV0gLSBjb25zdGFudHNfMS5IQVJERU5FRF9PRkZTRVQpID4gMCkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZEFzc2V0UGF0aCA9IGlzVmFsaWRBc3NldFBhdGg7XG52YXIgc3BsaXRGcmFtZXMgPSBmdW5jdGlvbiAoZGF0YSwgZnJhbWVTeikge1xuICAgIHZhciBmcmFtZXMgPSBbXTtcbiAgICB2YXIgbiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGZyYW1lU3opO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZyYW1lcy5wdXNoKGRhdGEuc2xpY2Uob2ZmLCBvZmYgKyBmcmFtZVN6KSk7XG4gICAgICAgIG9mZiArPSBmcmFtZVN6O1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVzO1xufTtcbmV4cG9ydHMuc3BsaXRGcmFtZXMgPSBzcGxpdEZyYW1lcztcbmZ1bmN0aW9uIGlzQmFzZTEwTnVtU3RyKHgpIHtcbiAgICB2YXIgYm4gPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh4KS50b1N0cmluZygpLnNwbGl0KCcuJykuam9pbignJyk7XG4gICAgdmFyIHMgPSBuZXcgU3RyaW5nKHgpO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgSlMgbmF0aXZlIGBTdHJpbmcoKWAgbG9zZXMgcHJlY2lzaW9uIGZvciBsYXJnZSBudW1iZXJzLCBidXQgd2Ugb25seVxuICAgIC8vIHdhbnQgdG8gdmFsaWRhdGUgdGhlIGJhc2Ugb2YgdGhlIG51bWJlciBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IGZhciBvdXQgcHJlY2lzaW9uLlxuICAgIHJldHVybiBibi5zbGljZSgwLCA4KSA9PT0gcy5zbGljZSgwLCA4KTtcbn1cbi8vIEVuc3VyZSBhIHBhcmFtIGlzIHJlcHJlc2VudGVkIGJ5IGEgYnVmZmVyXG52YXIgZW5zdXJlSGV4QnVmZmVyID0gZnVuY3Rpb24gKHgsIHplcm9Jc051bGwpIHtcbiAgICBpZiAoemVyb0lzTnVsbCA9PT0gdm9pZCAwKSB7IHplcm9Jc051bGwgPSB0cnVlOyB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRm9yIG51bGwgdmFsdWVzLCByZXR1cm4gYSAwLXNpemVkIGJ1ZmZlci4gRm9yIG1vc3Qgc2l0dWF0aW9ucyB3ZSBhc3N1bWVcbiAgICAgICAgLy8gMCBzaG91bGQgYmUgcmVwcmVzZW50ZWQgd2l0aCBhIHplcm8tbGVuZ3RoIGJ1ZmZlciAoZS5nLiBmb3IgUkxQLWJ1aWxkaW5nXG4gICAgICAgIC8vIHR4cyksIGJ1dCBpdCBjYW4gYWxzbyBiZSB0cmVhdGVkIGFzIGEgMS1ieXRlIGJ1ZmZlciAoYDAwYCkgaWYgbmVlZGVkXG4gICAgICAgIGlmICh4ID09PSBudWxsIHx8ICh4ID09PSAwICYmIHplcm9Jc051bGwgPT09IHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgdmFyIGlzTnVtYmVyID0gdHlwZW9mIHggPT09ICdudW1iZXInIHx8IGlzQmFzZTEwTnVtU3RyKHgpO1xuICAgICAgICAvLyBPdGhlcndpc2UgdHJ5IHRvIGdldCB0aGlzIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmdcbiAgICAgICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbnVtYmVyIG9yIGEgYmFzZS0xMCBudW1iZXIgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGhleFxuICAgICAgICAgICAgeCA9IFwiXCIuY29uY2F0KG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHgpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIHguc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHggPSB4LnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHgudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lmxlbmd0aCAlIDIgPiAwKVxuICAgICAgICAgICAgeCA9IFwiMFwiLmNvbmNhdCh4KTtcbiAgICAgICAgaWYgKHggPT09ICcwMCcgJiYgIWlzTnVtYmVyKVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHgsICdoZXgnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBcIi5jb25jYXQoeC50b1N0cmluZygpLCBcIiB0byBoZXggYnVmZmVyIChcIikuY29uY2F0KGVyci50b1N0cmluZygpLCBcIilcIikpO1xuICAgIH1cbn07XG5leHBvcnRzLmVuc3VyZUhleEJ1ZmZlciA9IGVuc3VyZUhleEJ1ZmZlcjtcbnZhciBmaXhMZW4gPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICB2YXIgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbn07XG5leHBvcnRzLmZpeExlbiA9IGZpeExlbjtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENSWVBUTyBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGFlczI1Nl9lbmNyeXB0ID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgIHZhciBpdiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGNvbnN0YW50c18xLkFFU19JVik7XG4gICAgdmFyIGFlc0NiYyA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG4gICAgdmFyIHBhZGRlZERhdGEgPSBkYXRhLmxlbmd0aCAlIDE2ID09PSAwID8gZGF0YSA6IGFlc19qc18xLmRlZmF1bHQucGFkZGluZy5wa2NzNy5wYWQoZGF0YSk7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGFlc0NiYy5lbmNyeXB0KHBhZGRlZERhdGEpKTtcbn07XG5leHBvcnRzLmFlczI1Nl9lbmNyeXB0ID0gYWVzMjU2X2VuY3J5cHQ7XG52YXIgYWVzMjU2X2RlY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgdmFyIGl2ID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oY29uc3RhbnRzXzEuQUVTX0lWKTtcbiAgICB2YXIgYWVzQ2JjID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcbiAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oYWVzQ2JjLmRlY3J5cHQoZGF0YSkpO1xufTtcbmV4cG9ydHMuYWVzMjU2X2RlY3J5cHQgPSBhZXMyNTZfZGVjcnlwdDtcbi8vIERlY29kZSBhIERFUiBzaWduYXR1cmUuIFJldHVybnMgc2lnbmF0dXJlIG9iamVjdCB7ciwgcyB9IG9yIG51bGwgaWYgdGhlcmUgaXMgYW4gZXJyb3JcbnZhciBwYXJzZURFUiA9IGZ1bmN0aW9uIChzaWdCdWYpIHtcbiAgICBpZiAoc2lnQnVmWzBdICE9PSAweDMwIHx8IHNpZ0J1ZlsyXSAhPT0gMHgwMilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIG9mZiA9IDM7XG4gICAgdmFyIHNpZyA9IHsgcjogbnVsbCwgczogbnVsbCB9O1xuICAgIHZhciByTGVuID0gc2lnQnVmW29mZl07XG4gICAgb2ZmKys7XG4gICAgc2lnLnIgPSBzaWdCdWYuc2xpY2Uob2ZmLCBvZmYgKyByTGVuKTtcbiAgICBvZmYgKz0gckxlbjtcbiAgICBpZiAoc2lnQnVmW29mZl0gIT09IDB4MDIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIG9mZisrO1xuICAgIHZhciBzTGVuID0gc2lnQnVmW29mZl07XG4gICAgb2ZmKys7XG4gICAgc2lnLnMgPSBzaWdCdWYuc2xpY2Uob2ZmLCBvZmYgKyBzTGVuKTtcbiAgICByZXR1cm4gc2lnO1xufTtcbmV4cG9ydHMucGFyc2VERVIgPSBwYXJzZURFUjtcbnZhciBnZXRQMjU2S2V5UGFpciA9IGZ1bmN0aW9uIChwcml2KSB7XG4gICAgcmV0dXJuIGVjLmtleUZyb21Qcml2YXRlKHByaXYsICdoZXgnKTtcbn07XG5leHBvcnRzLmdldFAyNTZLZXlQYWlyID0gZ2V0UDI1NktleVBhaXI7XG52YXIgZ2V0UDI1NktleVBhaXJGcm9tUHViID0gZnVuY3Rpb24gKHB1Yikge1xuICAgIHJldHVybiBlYy5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xufTtcbmV4cG9ydHMuZ2V0UDI1NktleVBhaXJGcm9tUHViID0gZ2V0UDI1NktleVBhaXJGcm9tUHViO1xudmFyIGJ1aWxkU2lnbmVyUGF0aEJ1ZiA9IGZ1bmN0aW9uIChzaWduZXJQYXRoLCB2YXJBZGRyUGF0aFN6QWxsb3dlZCkge1xuICAgIHZhciBidWYgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMjQpO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmICh2YXJBZGRyUGF0aFN6QWxsb3dlZCAmJiBzaWduZXJQYXRoLmxlbmd0aCA+IDUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVyIHBhdGggbXVzdCBiZSA8PTUgaW5kaWNlcy4nKTtcbiAgICBpZiAoIXZhckFkZHJQYXRoU3pBbGxvd2VkICYmIHNpZ25lclBhdGgubGVuZ3RoICE9PSA1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgTGF0dGljZSBmaXJtd2FyZSBvbmx5IHN1cHBvcnRzIDUtaW5kZXggZGVyaXZhdGlvbiBwYXRocy4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gICAgYnVmLndyaXRlVUludDMyTEUoc2lnbmVyUGF0aC5sZW5ndGgsIG9mZik7XG4gICAgb2ZmICs9IDQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBzaWduZXJQYXRoLmxlbmd0aClcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKHNpZ25lclBhdGhbaV0sIG9mZik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKDAsIG9mZik7XG4gICAgICAgIG9mZiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydHMuYnVpbGRTaWduZXJQYXRoQnVmID0gYnVpbGRTaWduZXJQYXRoQnVmO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT1RIRVIgVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBpc0FzY2lpU3RyID0gZnVuY3Rpb24gKHN0ciwgYWxsb3dGb3JtYXRDaGFycykge1xuICAgIGlmIChhbGxvd0Zvcm1hdENoYXJzID09PSB2b2lkIDApIHsgYWxsb3dGb3JtYXRDaGFycyA9IGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV4dHJhQ2hhcnMgPSBhbGxvd0Zvcm1hdENoYXJzID9cbiAgICAgICAgW1xuICAgICAgICAgICAgMHgwMDIwLFxuICAgICAgICAgICAgMHgwMDBhLCAvLyBOZXcgbGluZVxuICAgICAgICBdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGV4dHJhQ2hhcnMuaW5kZXhPZihjKSA8IDAgJiYgKGMgPCAweDAwMjAgfHwgYyA+IDB4MDA3ZikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzQXNjaWlTdHIgPSBpc0FzY2lpU3RyO1xuLy8gQ2hlY2sgaWYgYSB2YWx1ZSBleGlzdHMgaW4gYW4gb2JqZWN0LiBPbmx5IGNoZWNrcyBmaXJzdCBsZXZlbCBvZiBrZXlzLlxudmFyIGV4aXN0c0luID0gZnVuY3Rpb24gKHZhbCwgb2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XSA9PT0gdmFsOyB9KTtcbn07XG5leHBvcnRzLmV4aXN0c0luID0gZXhpc3RzSW47XG4vKipcbiAqIGBwcm9taXNpZnlDYmAgYWNjZXB0cyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZyb20gYSBgUHJvbWlzZWAgYW5kIGFuIG9wdGlvbmFsIGNhbGxiYWNrLlxuICogSXQgcmV0dXJucyB0aGF0IGNhbGxiYWNrIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGl0IHJlc29sdmVzIG9yIHJlamVjdHMgYXMgYSBgUHJvbWlzZWBcbiAqL1xudmFyIHByb21pc2lmeUNiID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBjYi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2Vycl0sIHBhcmFtcywgZmFsc2UpKTtcbiAgICAgICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgIH07XG59O1xuZXhwb3J0cy5wcm9taXNpZnlDYiA9IHByb21pc2lmeUNiO1xuLy8gQ3JlYXRlIGEgYnVmZmVyIG9mIHNpemUgYG5gIGFuZCBmaWxsIGl0IHdpdGggcmFuZG9tIGRhdGFcbnZhciByYW5kb21CeXRlcyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBidWZbaV0gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hYmlQYXJzZXJzID0gZXhwb3J0cy51bnBhY2tBYmlEZWYgPSBleHBvcnRzLmdldEZ1bmNTaWcgPSBleHBvcnRzLmJ1aWxkQWRkQWJpUGF5bG9hZCA9IGV4cG9ydHMuQUJJX0RFRl9TWiA9IGV4cG9ydHMuTUFYX0FCSV9ERUZTID0gdm9pZCAwO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG52YXIganNfc2hhM18xID0gcmVxdWlyZShcImpzLXNoYTNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgTkFNRV9NQVhfU1ogPSAxMDA7XG52YXIgSEVBREVSX1NaID0gNSArIE5BTUVfTUFYX1NaOyAvLyA0IGJ5dGUgc2lnICsgbmFtZSArIDEgYnl0ZSBwYXJhbSBjb3VudFxudmFyIENBVEVHT1JZX1NaID0gMzI7XG52YXIgUEFSQU1fTkFNRV9TWiA9IDIwO1xudmFyIFBBUkFNX1NaID0gMjY7IC8vIDIwIGJ5dGUgbmFtZSArIDYgYnl0ZSBkZWZcbnZhciBNQVhfUEFSQU1TID0gMTg7XG5leHBvcnRzLk1BWF9BQklfREVGUyA9IDI7XG5leHBvcnRzLkFCSV9ERUZfU1ogPSAoSEVBREVSX1NaICsgQ0FURUdPUllfU1ogKyAoUEFSQU1fU1ogKiBNQVhfUEFSQU1TKSk7XG4vLyBCdWlsZCBhIHJlcXVlc3QgdG8gYWRkIEFCSSBkYXRhXG52YXIgYnVpbGRBZGRBYmlQYXlsb2FkID0gZnVuY3Rpb24gKGRlZnMpIHtcbiAgICBpZiAoIWRlZnMgfHwgIUFycmF5LmlzQXJyYXkoZGVmcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkZWZpbml0aW9ucy4nKTtcbiAgICBpZiAoZGVmcy5sZW5ndGggPiBleHBvcnRzLk1BWF9BQklfREVGUylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBvbmx5IGFkZCBcIi5jb25jYXQoZXhwb3J0cy5NQVhfQUJJX0RFRlMsIFwiIEFCSSBkZWZpbml0aW9ucyBwZXIgcmVxdWVzdC5cIikpO1xuICAgIHZhciBiID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDEgKyAoZXhwb3J0cy5NQVhfQUJJX0RFRlMgKiBleHBvcnRzLkFCSV9ERUZfU1opKTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBiLndyaXRlVUludDgoZGVmcy5sZW5ndGgsIG9mZik7XG4gICAgb2ZmKys7XG4gICAgZGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgaWYgKCFkZWYuc2lnIHx8ICFkZWYubmFtZSB8fCAhZGVmLnBhcmFtcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmFtZSwgc2lnLCBhbmQgcGFyYW1zIG11c3QgYmUgcHJlc2VudCBmb3IgZXZlcnkgQUJJIGRlZmluaXRpb24uJyk7XG4gICAgICAgIC8vIC0tIEhlYWRlciBkYXRhIC0tXG4gICAgICAgIHZhciBzaWcgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShkZWYuc2lnLCAnaGV4Jyk7XG4gICAgICAgIGlmIChzaWcubGVuZ3RoICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBzaWduYXR1cmVzIG11c3QgYWx3YXlzIGJlIGZvdXIgYnl0ZXMuJyk7XG4gICAgICAgIHNpZy5jb3B5KGIsIG9mZik7XG4gICAgICAgIG9mZiArPSBzaWcubGVuZ3RoO1xuICAgICAgICB2YXIgbmFtZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGRlZi5uYW1lKTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gTkFNRV9NQVhfU1ogLSAxKVxuICAgICAgICAgICAgLy8gVGhlIC0xIGFjY291bnRzIGZvciB0aGUgbnVsbCB0ZXJtaW5hdG9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IGZ1bmN0aW9uIG5hbWVzIHNob3J0ZXIgdGhhbiBcIi5jb25jYXQoTkFNRV9NQVhfU1ogLSAxLCBcIiBjaGFyYWN0ZXJzIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oZGVmLm5hbWUpLnNsaWNlKDAsIE5BTUVfTUFYX1NaKS5jb3B5KGIsIG9mZik7XG4gICAgICAgIG9mZiArPSBOQU1FX01BWF9TWjtcbiAgICAgICAgLy8gTnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIG51bVBhcmFtcyA9IEFycmF5LmlzQXJyYXkoZGVmLnBhcmFtcykgPyBkZWYucGFyYW1zLmxlbmd0aCA6IDA7XG4gICAgICAgIGIud3JpdGVVSW50OChudW1QYXJhbXMsIG9mZik7XG4gICAgICAgIG9mZisrO1xuICAgICAgICAvLyAtLSAob3B0aW9uYWwpIENhdGVnb3J5IG5hbWUgLS1cbiAgICAgICAgaWYgKGRlZi5jYXRlZ29yeSAmJiB0eXBlb2YgZGVmLmNhdGVnb3J5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZGVmLmNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeS5sZW5ndGggPiBDQVRFR09SWV9TWiAtIDEpXG4gICAgICAgICAgICAgICAgLy8gLTEgYWNjb3VudHMgZm9yIG51bGwgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGVnb3J5IG5hbWUgbXVzdCBiZSBzaG9ydGVyIHRoYW4gXCIuY29uY2F0KENBVEVHT1JZX1NaIC0gMSwgXCIuIEdvdCBcIikuY29uY2F0KGNhdGVnb3J5Lmxlbmd0aCkpO1xuICAgICAgICAgICAgY2F0ZWdvcnkuY29weShiLCBvZmYpO1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSBDQVRFR09SWV9TWjtcbiAgICAgICAgLy8gLS0gUGFyYW0gZGF0YSAtLVxuICAgICAgICBpZiAobnVtUGFyYW1zID4gTUFYX1BBUkFNUylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgQUJJIGRlZmludGlvbnMgd2l0aCA8PTEwIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgaWYgKG51bVBhcmFtcyA+IDApIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvcHkgcGFyYW0gbmFtZXNcbiAgICAgICAgICAgIGRlZi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ubmFtZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmxhdHRpY2VUeXBlSWR4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uaXNBcnJheSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLmFycmF5U3ogPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lLCBsYXR0aWNlVHlwZUlkeCwgaXNBcnJheSwgYW5kIGFycmF5U3ogbXVzdCBiZSBkZWZpbmVkIGZvciBhbGwgQUJJIHBhcmFtcy4nKTtcbiAgICAgICAgICAgICAgICBidWZmZXJfMS5CdWZmZXIuZnJvbShwYXJhbS5uYW1lKS5zbGljZSgwLCBQQVJBTV9OQU1FX1NaKS5jb3B5KGIsIG9mZik7XG4gICAgICAgICAgICAgICAgb2ZmICs9IFBBUkFNX05BTUVfU1o7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEJ1bXAgb2Zmc2V0IHRvIGFjY291bnQgZm9yIGJsYW5rIHBhcmFtIHNsb3RzXG4gICAgICAgICAgICBvZmYgKz0gUEFSQU1fTkFNRV9TWiAqIChNQVhfUEFSQU1TIC0gbnVtUGFyYW1zKTtcbiAgICAgICAgICAgIC8vIE5leHQgY29weSB0aGUgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIGRlZi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVUludDgocGFyYW0ubGF0dGljZVR5cGVJZHgsIG9mZik7XG4gICAgICAgICAgICAgICAgb2ZmKys7XG4gICAgICAgICAgICAgICAgYi53cml0ZVVJbnQ4KHBhcmFtLmlzQXJyYXkgPyAxIDogMCwgb2ZmKTtcbiAgICAgICAgICAgICAgICBvZmYrKztcbiAgICAgICAgICAgICAgICBiLndyaXRlVUludDMyTEUocGFyYW0uYXJyYXlTeiwgb2ZmKTtcbiAgICAgICAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQnVtcCBvZmZzZXQgYWdhaW5cbiAgICAgICAgICAgIG9mZiArPSA2ICogKE1BWF9QQVJBTVMgLSBudW1QYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFtcywganVzdCBidW1wIHRoZSBvZmZzZXRcbiAgICAgICAgICAgIG9mZiArPSBQQVJBTV9TWiAqIE1BWF9QQVJBTVM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYjtcbn07XG5leHBvcnRzLmJ1aWxkQWRkQWJpUGF5bG9hZCA9IGJ1aWxkQWRkQWJpUGF5bG9hZDtcbi8vIEdldCB0aGUgNC1ieXRlIGZ1bmN0aW9uIGlkZW50aWZpZXIgYmFzZWQgb24gdGhlIGNhbm9uaWNhbCBuYW1lXG52YXIgZ2V0RnVuY1NpZyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgLy8gQ2Fub25pY2FsIG5hbWUgaXM6XG4gICAgLy8gZnVuY05hbWUocGFyYW1UeXBlMCwgLi4uLCBwYXJhbVR5cGVOKVxuICAgIHZhciBjYW5vbmljYWxOYW1lID0gXCJcIi5jb25jYXQoZi5uYW1lLCBcIihcIik7XG4gICAgZi5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUuaW5kZXhPZigndHVwbGUnKSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgYXJyU3VmZml4ID0gaW5wdXQudHlwZS5zbGljZShpbnB1dC50eXBlLmluZGV4T2YoJ3R1cGxlJykgKyA1KTtcbiAgICAgICAgICAgIGNhbm9uaWNhbE5hbWUgKz0gJygnO1xuICAgICAgICAgICAgaW5wdXQuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICAgICAgY2Fub25pY2FsTmFtZSArPSBcIlwiLmNvbmNhdChjLnR5cGUpLmNvbmNhdChpID09PSBpbnB1dC5jb21wb25lbnRzLmxlbmd0aCAtIDEgPyAnJyA6ICcsJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbm9uaWNhbE5hbWUgKz0gXCIpXCIuY29uY2F0KGFyclN1ZmZpeCwgXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2Fub25pY2FsTmFtZSArPSBcIlwiLmNvbmNhdChpbnB1dC50eXBlLCBcIixcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZi5pbnB1dHMubGVuZ3RoID4gMClcbiAgICAgICAgY2Fub25pY2FsTmFtZSA9IGNhbm9uaWNhbE5hbWUuc2xpY2UoMCwgY2Fub25pY2FsTmFtZS5sZW5ndGggLSAxKTtcbiAgICBjYW5vbmljYWxOYW1lICs9ICcpJztcbiAgICByZXR1cm4gKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGNhbm9uaWNhbE5hbWUpLnNsaWNlKDAsIDgpO1xufTtcbmV4cG9ydHMuZ2V0RnVuY1NpZyA9IGdldEZ1bmNTaWc7XG52YXIgdW5wYWNrQWJpRGVmID0gZnVuY3Rpb24gKF9kZWYpIHtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgZGVmID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHNpZzogJycsXG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIG51bVBhcmFtOiAwLFxuICAgICAgICB9LFxuICAgICAgICBjYXRlZ29yeTogJycsXG4gICAgICAgIHBhcmFtczogW11cbiAgICB9O1xuICAgIGRlZi5oZWFkZXIuc2lnID0gJzB4JyArIF9kZWYuc2xpY2Uob2ZmLCBvZmYgKyA0KS50b1N0cmluZygnaGV4Jyk7XG4gICAgb2ZmICs9IDQ7XG4gICAgZGVmLmhlYWRlci5uYW1lID0gX2RlZi5zbGljZShvZmYsIG9mZiArIE5BTUVfTUFYX1NaKS50b1N0cmluZygpLnNwbGl0KCdcXHgwMCcpWzBdO1xuICAgIG9mZiArPSBOQU1FX01BWF9TWjtcbiAgICBkZWYuaGVhZGVyLm51bVBhcmFtID0gX2RlZi5yZWFkVUludDgob2ZmKTtcbiAgICBvZmYgKz0gMTtcbiAgICBkZWYuY2F0ZWdvcnkgPSBfZGVmLnNsaWNlKG9mZiwgb2ZmICsgQ0FURUdPUllfU1opLnRvU3RyaW5nKCkuc3BsaXQoJ1xceDAwJylbMF07XG4gICAgb2ZmICs9IENBVEVHT1JZX1NaO1xuICAgIC8vIEdldCBwYXJhbSBuYW1lc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTUFYX1BBUkFNUzsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgZGVmLmhlYWRlci5udW1QYXJhbSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6IDAsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIGlzQXJyYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFycmF5U3o6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFyYW0ubmFtZSA9IF9kZWYuc2xpY2Uob2ZmLCBvZmYgKyBQQVJBTV9OQU1FX1NaKS50b1N0cmluZygpLnNwbGl0KCdcXHgwMCcpWzBdO1xuICAgICAgICAgICAgZGVmLnBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gUEFSQU1fTkFNRV9TWjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV2ZXJzZUZ3VHlwZU1hcCh0eXBlSWR4KSB7XG4gICAgICAgIHZhciB0eXBlTmFtZSA9IG51bGw7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbnN0YW50c18xLkVUSF9BQklfTEFUVElDRV9GV19UWVBFX01BUCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRzXzEuRVRIX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQW2tleV0gPT09IHR5cGVJZHgpIHtcbiAgICAgICAgICAgICAgICB0eXBlTmFtZSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlTmFtZTtcbiAgICB9XG4gICAgLy8gR2V0IHBhcmFtIGluZm9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1BWF9QQVJBTVM7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGRlZi5oZWFkZXIubnVtUGFyYW0pIHtcbiAgICAgICAgICAgIGRlZi5wYXJhbXNbaV0udHlwZSA9IF9kZWYucmVhZFVJbnQ4KG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgICAgIGRlZi5wYXJhbXNbaV0udHlwZU5hbWUgPSByZXZlcnNlRndUeXBlTWFwKGRlZi5wYXJhbXNbaV0udHlwZSk7XG4gICAgICAgICAgICBkZWYucGFyYW1zW2ldLmlzQXJyYXkgPSBfZGVmLnJlYWRVSW50OChvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICBkZWYucGFyYW1zW2ldLmFycmF5U3ogPSBfZGVmLnJlYWRVSW50MzJMRShvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn07XG5leHBvcnRzLnVucGFja0FiaURlZiA9IHVucGFja0FiaURlZjtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBBUlNFUlNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHBhcnNlRXRoZXJzY2FuQWJpRGVmcyhfZGVmcywgc2tpcEVycm9ycykge1xuICAgIGlmIChza2lwRXJyb3JzID09PSB2b2lkIDApIHsgc2tpcEVycm9ycyA9IGZhbHNlOyB9XG4gICAgLy8gYF9kZWZzYCBhcmUgYHJlc3VsdGAgb2YgdGhlIHBhcnNlZCByZXNwb25zZVxuICAgIHZhciBkZWZzID0gW107XG4gICAgX2RlZnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAoZC5uYW1lICYmXG4gICAgICAgICAgICBkLmlucHV0cyAmJlxuICAgICAgICAgICAgZC50eXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBkLnN0YXRlTXV0YWJpbGl0eSAhPT0gJ3ZpZXcnICYmXG4gICAgICAgICAgICBkLmNvbnN0YW50ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBzaWcgPSAoMCwgZXhwb3J0cy5nZXRGdW5jU2lnKShkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gcGFyc2VFdGhlcnNjYW5BYmlJbnB1dHMoZC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgIGRlZnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2lnOiBzaWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChza2lwRXJyb3JzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBkZWY6JywgZC5uYW1lLCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZzO1xufVxuZXhwb3J0cy5hYmlQYXJzZXJzID0ge1xuICAgIGV0aGVyc2NhbjogcGFyc2VFdGhlcnNjYW5BYmlEZWZzLFxufTtcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhFTFBFUlNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlIHRoZSBBQkkgcGFyYW0gZGF0YSBpbnRvIHN0cnVjdHMgTGF0dGljZSBmaXJtd2FyZSB3aWxsIHJlY29nbml6ZS5cbmZ1bmN0aW9uIHBhcnNlRXRoZXJzY2FuQWJpSW5wdXRzKGlucHV0cywgZGF0YSwgaXNOZXN0ZWRUdXBsZSkge1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IFtdOyB9XG4gICAgaWYgKGlzTmVzdGVkVHVwbGUgPT09IHZvaWQgMCkgeyBpc05lc3RlZFR1cGxlID0gZmFsc2U7IH1cbiAgICB2YXIgdHVwbGVQYXJhbXMgPSBbXTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gaW5wdXQudHlwZTtcbiAgICAgICAgdmFyIGQgPSB7IGlzQXJyYXk6IGZhbHNlLCBhcnJheVN6OiAwLCBuYW1lOiBpbnB1dC5uYW1lIH07XG4gICAgICAgIHZhciBvcGVuQnJhY2tldElkeCA9IHR5cGVOYW1lLmluZGV4T2YoJ1snKTtcbiAgICAgICAgdmFyIGNsb3NlQnJhY2tldElkeCA9IHR5cGVOYW1lLmluZGV4T2YoJ10nKTtcbiAgICAgICAgdmFyIGlzTXVsdGlEaW0gPSB0eXBlTmFtZS5zcGxpdCgnWycpLmxlbmd0aCA+IDI7XG4gICAgICAgIGlmIChpc011bHRpRGltKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXBwaW5nIGZ1bmN0aW9uIHdpdGggdW5zdXBwb3J0ZWQgbXVsdGlkaW1lbnNpb25hbCBhcnJheSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob3BlbkJyYWNrZXRJZHggPiAtMSAmJiBjbG9zZUJyYWNrZXRJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuQnJhY2tldElkeCA+PSBjbG9zZUJyYWNrZXRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgdmFsaWQgcGFyYW0gLS0gc2tpcCBpdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVuQnJhY2tldElkeCArIDEgPT09IGNsb3NlQnJhY2tldElkeCkge1xuICAgICAgICAgICAgICAgICAgICBkLmlzQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGFycmF5IHNpemUgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQodHlwZU5hbWUuc2xpY2Uob3BlbkJyYWNrZXRJZHggKyAxLCBjbG9zZUJyYWNrZXRJZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQuaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGQuYXJyYXlTeiA9IG51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2luZ3VsYXJUeXBlTmFtZSA9IG9wZW5CcmFja2V0SWR4ID4gLTEgPyB0eXBlTmFtZS5zbGljZSgwLCBvcGVuQnJhY2tldElkeCkgOiB0eXBlTmFtZTtcbiAgICAgICAgICAgIGlmIChzaW5ndWxhclR5cGVOYW1lID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmVzdGVkVHVwbGUgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGVkIHR1cGxlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHNpbmd1bGFyVHlwZU5hbWUgPSBcInR1cGxlXCIuY29uY2F0KGlucHV0LmNvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0dXBsZVBhcmFtcyA9IHBhcnNlRXRoZXJzY2FuQWJpSW5wdXRzKGlucHV0LmNvbXBvbmVudHMsIHR1cGxlUGFyYW1zLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQubGF0dGljZVR5cGVJZHggPSBnZXRUeXBlSWR4TGF0dGljZUZ3KHNpbmd1bGFyVHlwZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFkLmxhdHRpY2VUeXBlSWR4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGU6IFwiLmNvbmNhdCh0eXBlTmFtZSkpO1xuICAgICAgICAgICAgZGF0YS5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHBhcmFtcyA9IGRhdGEuY29uY2F0KHR1cGxlUGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDE4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGhhcyB0b28gbWFueSBwYXJhbWV0ZXJzIGZvciBMYXR0aWNlIGZpcm13YXJlICgxOCBtYXgpJyk7XG4gICAgcmV0dXJuIGRhdGEuY29uY2F0KHR1cGxlUGFyYW1zKTtcbn1cbi8vIEVudW0gdmFsdWVzIGZyb20gaW5zaWRlIExhdHRpY2UgZmlybXdhcmVcbmZ1bmN0aW9uIGdldFR5cGVJZHhMYXR0aWNlRncodHlwZSkge1xuICAgIHJldHVybiBjb25zdGFudHNfMS5FVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVBbdHlwZV07XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgTUFYX0FCSV9ERUZTOiBleHBvcnRzLk1BWF9BQklfREVGUyxcbiAgICBidWlsZEFkZEFiaVBheWxvYWQ6IGV4cG9ydHMuYnVpbGRBZGRBYmlQYXlsb2FkLFxuICAgIGdldEZ1bmNTaWc6IGV4cG9ydHMuZ2V0RnVuY1NpZyxcbiAgICBhYmlQYXJzZXJzOiBleHBvcnRzLmFiaVBhcnNlcnMsXG59O1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG52YXIgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG52YXIgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgZm9yKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgdmFyIG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGVyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhID0gUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhpcyB0aHJvd3MsIGJlY2F1c2UgaXQgY2FuJ3Qgc2VuZC9yZWNlaXZlIGRhdGEgYXMgZXhwZWN0ZWRcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKCl7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIGlmICg0ICE9IHJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoIXN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQgfHwgc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJyk7XG4gICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICghdGhpcy5fZm9ybURhdGEgJiYgJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQWdlbnQoKTtcbn07XG5cbltcIkdFVFwiLCBcIlBPU1RcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQVVRcIiwgXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW5jb2RlZFBheWxvYWQgPSBleHBvcnRzLnBhcnNlR2VuZXJpY1NpZ25pbmdSZXNwb25zZSA9IGV4cG9ydHMuYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QgPSB2b2lkIDA7XG4vKipcbkdlbmVyaWMgc2lnbmluZyBtb2R1bGUuIEFueSBwYXlsb2FkIGNhbiBiZSBzZW50IHRvIHRoZSBMYXR0aWNlIGFuZFxud2lsbCBiZSBkaXNwbGF5ZWQgaW4gZnVsbCAobm90ZSB0aGF0IFxcbiBhbmQgXFx0IGNoYXJhY3RlcnMgd2lsbCBiZVxuZGlzcGxheWVkIGFzIGxpbmUgYnJlYWtzIGFuZCB0YWJzIG9uIHRoZSBzY3JlZW4pLlxuXG5UaGlzIHBheWxvYWQgc2hvdWxkIGJlIGNvdXBsZWQgd2l0aDpcbiogU2lnbmVyJ3MgQklQNDQgcGF0aFxuKiBDdXJ2ZSBvbiB3aGljaCB0byBkZXJpdmUgdGhlIHNpZ25pbmcga2V5XG4qIEhhc2ggZnVuY3Rpb24gdG8gdXNlIG9uIHRoZSBtZXNzYWdlXG4qL1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG52YXIganNfc2hhM18xID0gcmVxdWlyZShcImpzLXNoYTNcIik7XG52YXIgc2hhXzEgPSByZXF1aXJlKFwiaGFzaC5qcy9saWIvaGFzaC9zaGFcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYnVpbGRHZW5lcmljU2lnbmluZ01zZ1JlcXVlc3QgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgdmFyIHNpZ25lclBhdGggPSByZXEuc2lnbmVyUGF0aCwgY3VydmVUeXBlID0gcmVxLmN1cnZlVHlwZSwgaGFzaFR5cGUgPSByZXEuaGFzaFR5cGUsIF9hID0gcmVxLmVuY29kaW5nVHlwZSwgZW5jb2RpbmdUeXBlID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYSwgX2IgPSByZXEub21pdFB1YmtleSwgb21pdFB1YmtleSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBmd0NvbnN0YW50cyA9IHJlcS5md0NvbnN0YW50cztcbiAgICB2YXIgZXh0cmFEYXRhRnJhbWVTeiA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YUZyYW1lU3osIGV4dHJhRGF0YU1heEZyYW1lcyA9IGZ3Q29uc3RhbnRzLmV4dHJhRGF0YU1heEZyYW1lcywgcHJlaGFzaEFsbG93ZWQgPSBmd0NvbnN0YW50cy5wcmVoYXNoQWxsb3dlZCwgZ2VuZXJpY1NpZ25pbmcgPSBmd0NvbnN0YW50cy5nZW5lcmljU2lnbmluZywgdmFyQWRkclBhdGhTekFsbG93ZWQgPSBmd0NvbnN0YW50cy52YXJBZGRyUGF0aFN6QWxsb3dlZDtcbiAgICB2YXIgY3VydmVUeXBlcyA9IGdlbmVyaWNTaWduaW5nLmN1cnZlVHlwZXMsIGVuY29kaW5nVHlwZXMgPSBnZW5lcmljU2lnbmluZy5lbmNvZGluZ1R5cGVzLCBoYXNoVHlwZXMgPSBnZW5lcmljU2lnbmluZy5oYXNoVHlwZXMsIGJhc2VEYXRhU3ogPSBnZW5lcmljU2lnbmluZy5iYXNlRGF0YVN6LCBiYXNlUmVxU3ogPSBnZW5lcmljU2lnbmluZy5iYXNlUmVxU3o7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIF9jID0gKDAsIGV4cG9ydHMuZ2V0RW5jb2RlZFBheWxvYWQpKHJlcS5wYXlsb2FkLCBlbmNvZGluZ1R5cGUsIGVuY29kaW5nVHlwZXMpLCBlbmNvZGluZyA9IF9jLmVuY29kaW5nLCBwYXlsb2FkQnVmID0gX2MucGF5bG9hZEJ1ZjtcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAocGF5bG9hZEJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bG9hZCBjb3VsZCBub3QgYmUgaGFuZGxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZ2VuZXJpY1NpZ25pbmcgfHwgIWV4dHJhRGF0YUZyYW1lU3ogfHwgIWV4dHJhRGF0YU1heEZyYW1lcyB8fCAhcHJlaGFzaEFsbG93ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgeW91ciBMYXR0aWNlIGZpcm13YXJlLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoMCwgdXRpbF8xLmV4aXN0c0luKShjdXJ2ZVR5cGUsIGN1cnZlVHlwZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGN1cnZlIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoISgwLCB1dGlsXzEuZXhpc3RzSW4pKGhhc2hUeXBlLCBoYXNoVHlwZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGhhc2ggdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFZDI1NTE5IHNwZWNpZmljIHNhbml0eSBjaGVja3NcbiAgICAgICAgaWYgKGN1cnZlVHlwZSA9PT0gY3VydmVUeXBlcy5FRDI1NTE5KSB7XG4gICAgICAgICAgICBpZiAoaGFzaFR5cGUgIT09IGhhc2hUeXBlcy5OT05FKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduaW5nIG9uIGVkMjU1MTkgcmVxdWlyZXMgdW5oYXNoZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmVyUGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWR4IDwgY29uc3RhbnRzXzEuSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmluZyBvbiBlZDI1NTE5IHJlcXVpcmVzIGFsbCBzaWduZXIgcGF0aCBpbmRpY2VzIGJlIGhhcmRlbmVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSByZXF1ZXN0IGJ1ZmZlciB3aXRoIG1ldGFkYXRhIGFuZCB0aGVuIHRoZSBwYXlsb2FkIHRvIHNpZ24uXG4gICAgICAgIHZhciBidWYgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoYmFzZVJlcVN6KTtcbiAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKGVuY29kaW5nLCBvZmYpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgYnVmLndyaXRlVUludDgoaGFzaFR5cGUsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICBidWYud3JpdGVVSW50OChjdXJ2ZVR5cGUsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICB2YXIgc2lnbmVyUGF0aEJ1ZiA9ICgwLCB1dGlsXzEuYnVpbGRTaWduZXJQYXRoQnVmKShzaWduZXJQYXRoLCB2YXJBZGRyUGF0aFN6QWxsb3dlZCk7XG4gICAgICAgIHNpZ25lclBhdGhCdWYuY29weShidWYsIG9mZik7XG4gICAgICAgIG9mZiArPSBzaWduZXJQYXRoQnVmLmxlbmd0aDtcbiAgICAgICAgYnVmLndyaXRlVUludDgob21pdFB1YmtleSA/IDEgOiAwLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgYnVmLndyaXRlVUludDE2TEUocGF5bG9hZEJ1Zi5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICAvLyBTaXplIG9mIGRhdGEgcGF5bG9hZCB0aGF0IGNhbiBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QvYmFzZSByZXF1ZXN0XG4gICAgICAgIHZhciBtYXhFeHBhbmRlZFN6ID0gYmFzZURhdGFTeiArIChleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgLy8gRmxvdyBkYXRhIGludG8gZXh0cmFEYXRhIHJlcXVlc3RzIGlmIGFwcGxpY2FibGVcbiAgICAgICAgdmFyIGV4dHJhRGF0YVBheWxvYWRzXzEgPSBbXTtcbiAgICAgICAgdmFyIHByZWhhc2ggPSBudWxsO1xuICAgICAgICBpZiAocGF5bG9hZEJ1Zi5sZW5ndGggPiBiYXNlRGF0YVN6KSB7XG4gICAgICAgICAgICBpZiAocHJlaGFzaEFsbG93ZWQgJiYgcGF5bG9hZEJ1Zi5sZW5ndGggPiBtYXhFeHBhbmRlZFN6KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgICAgICAgICBpZiAoaGFzaFR5cGUgPT09IGhhc2hUeXBlcy5OT05FKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIGRvbmUgZm9yIEVEMjU1MTkgc2lnbmluZywgd2hpY2ggbXVzdCBzaWduIHRoZSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSB0byBzZW5kIGFuZCBjb3VsZCBub3QgYmUgcHJlaGFzaGVkIChoYXNoVHlwZT1OT05FKS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzaFR5cGUgPT09IGhhc2hUeXBlcy5LRUNDQUsyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlaGFzaCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShwYXlsb2FkQnVmKSwgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNoVHlwZSA9PT0gaGFzaFR5cGVzLlNIQTI1Nikge1xuICAgICAgICAgICAgICAgICAgICBwcmVoYXNoID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIHNoYV8xLnNoYTI1NikoKS51cGRhdGUocGF5bG9hZEJ1ZikuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBoYXNoIHR5cGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgb3ZlcmZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSBmcmFtZXNcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzEgPSAoMCwgdXRpbF8xLnNwbGl0RnJhbWVzKShwYXlsb2FkQnVmLnNsaWNlKGJhc2VEYXRhU3opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgICAgICAgICBmcmFtZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3pMRSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgICAgICAgICAgc3pMRS53cml0ZVVJbnQzMkxFKGZyYW1lLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzXzEucHVzaChidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgbWVzc2FnZSBoYWQgdG8gYmUgcHJlaGFzaGVkLCB3ZSB3aWxsIG9ubHkgY29weSB0aGUgaGFzaCBkYXRhIGludG8gdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vIE90aGVyd2lzZSBjb3B5IGFzIG1hbnkgcGF5bG9hZCBieXRlcyBpbnRvIHRoZSByZXF1ZXN0IGFzIHBvc3NpYmxlLiBGb2xsb3cgdXAgZGF0YVxuICAgICAgICAvLyBmcm9tIGBmcmFtZXNgIHdpbGwgY29tZSBpbiBmb2xsb3cgdXAgcmVxdWVzdHMuXG4gICAgICAgIHZhciB0b0NvcHkgPSBwcmVoYXNoID8gcHJlaGFzaCA6IHBheWxvYWRCdWY7XG4gICAgICAgIHRvQ29weS5jb3B5KGJ1Ziwgb2ZmKTtcbiAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgbmVjZXNzYXJ5IGRhdGFcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGJ1ZixcbiAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzOiBleHRyYURhdGFQYXlsb2Fkc18xLFxuICAgICAgICAgICAgc2NoZW1hOiBjb25zdGFudHNfMS5zaWduaW5nU2NoZW1hLkdFTkVSQUxfU0lHTklORyxcbiAgICAgICAgICAgIGN1cnZlVHlwZTogY3VydmVUeXBlLFxuICAgICAgICAgICAgb21pdFB1YmtleTogb21pdFB1YmtleVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7IGVycjogZXJyLm1lc3NhZ2UgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5idWlsZEdlbmVyaWNTaWduaW5nTXNnUmVxdWVzdCA9IGJ1aWxkR2VuZXJpY1NpZ25pbmdNc2dSZXF1ZXN0O1xudmFyIHBhcnNlR2VuZXJpY1NpZ25pbmdSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXMsIG9mZiwgY3VydmVUeXBlLCBvbWl0UHVia2V5KSB7XG4gICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgICAgcHVia2V5OiBudWxsLFxuICAgICAgICBzaWc6IG51bGwsXG4gICAgfTtcbiAgICAvLyBQYXJzZSBCSVA0NCBwYXRoXG4gICAgLy8gUGFyc2UgcHVia2V5IGFuZCB0aGVuIHNpZ1xuICAgIGlmIChjdXJ2ZVR5cGUgPT09IGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuQ1VSVkVTLlNFQ1AyNTZLMSkge1xuICAgICAgICAvLyBIYW5kbGUgYEdwRWNjUHVia2V5MjU2X3RgXG4gICAgICAgIGlmICghb21pdFB1YmtleSkge1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcmVzLnJlYWRVaW50OChvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDE7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IDB4MDIgfHwgY29tcHJlc3Npb24gPT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wcmVzc2VkIGtleSAtIG9ubHkgY29weSB4XG4gICAgICAgICAgICAgICAgcGFyc2VkLnB1YmtleSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzMyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnB1YmtleS53cml0ZVVJbnQ4KGNvbXByZXNzaW9uLCAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2xpY2Uob2ZmLCBvZmYgKyAzMikuY29weShwYXJzZWQucHVia2V5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXByZXNzaW9uID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5jb21wcmVzc2VkIGtleVxuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNjUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wdWJrZXkud3JpdGVVSW50OChjb21wcmVzc2lvbiwgMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNsaWNlKG9mZikuY29weShwYXJzZWQucHVia2V5LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGNvbXByZXNzaW9uIGJ5dGUgaW4gc2lnbmluZyByZXNwb25zZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSA2NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNraXAgcHVia2V5IHNlY3Rpb25cbiAgICAgICAgICAgIG9mZiArPSA2NTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYEdwRUNEU0FTaWdfdGBcbiAgICAgICAgcGFyc2VkLnNpZyA9ICgwLCB1dGlsXzEucGFyc2VERVIpKHJlcy5zbGljZShvZmYsIG9mZiArIDIgKyByZXNbb2ZmICsgMV0pKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBsZWFkaW5nIHplcm9zIGluIHNpZ25hdHVyZSBjb21wb25lbnRzIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgcmVzdWx0IGlzIGEgNjQgYnl0ZSBzaWdcbiAgICAgICAgcGFyc2VkLnNpZy5yID0gKDAsIHV0aWxfMS5maXhMZW4pKHBhcnNlZC5zaWcuciwgMzIpO1xuICAgICAgICBwYXJzZWQuc2lnLnMgPSAoMCwgdXRpbF8xLmZpeExlbikocGFyc2VkLnNpZy5zLCAzMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnZlVHlwZSA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5DVVJWRVMuRUQyNTUxOSkge1xuICAgICAgICBpZiAoIW9taXRQdWJrZXkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBgR3BFZERTQVB1YmtleV90YFxuICAgICAgICAgICAgcGFyc2VkLnB1YmtleSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzMik7XG4gICAgICAgICAgICByZXMuc2xpY2Uob2ZmLCBvZmYgKyAzMikuY29weShwYXJzZWQucHVia2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMzI7XG4gICAgICAgIC8vIEhhbmRsZSBgR3BFZERTQVNpZ190YFxuICAgICAgICBwYXJzZWQuc2lnID0ge1xuICAgICAgICAgICAgcjogcmVzLnNsaWNlKG9mZiwgb2ZmICsgMzIpLFxuICAgICAgICAgICAgczogcmVzLnNsaWNlKG9mZiArIDMyLCBvZmYgKyA2NCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGN1cnZlLicpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufTtcbmV4cG9ydHMucGFyc2VHZW5lcmljU2lnbmluZ1Jlc3BvbnNlID0gcGFyc2VHZW5lcmljU2lnbmluZ1Jlc3BvbnNlO1xudmFyIGdldEVuY29kZWRQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQsIGVuY29kaW5nVHlwZSwgYWxsb3dlZEVuY29kaW5ncykge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kaW5nVHlwZTtcbiAgICBpZiAoZW5jb2RpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgbm8gZW5jb2RpbmcgdHlwZSB3YXMgcGFzc2VkLCB3ZSB3aWxsIGRpc3BsYXkgdGhlIHBheWxvYWQgYXMgZWl0aGVyXG4gICAgICAgIC8vIEFTQ0lJIG9yIGEgaGV4IHN0cmluZy4gRGV0ZXJtaW5lIHdoaWNoIG9uZSBvZiB0aGUgZGVmYXVsdCBlbmNvZGluZ3MgdG8gdXNlLlxuICAgICAgICAvLyBJZiB0aGUgYnVmZmVyIHBhc3NlZCBpbiBpcyBhIHN0cmluZyBhbmQgaXMgbm90IHByZWZpeGVkIHdpdGggMHgsIHRyZWF0IGFzIHV0ZjguXG4gICAgICAgIC8vIE90aGVyd2lzZSB0cmVhdCBpdCBhcyBhIGhleCBidWZmZXIuXG4gICAgICAgIHZhciBpc0hleCA9IGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJyAmJiBwYXlsb2FkLnNsaWNlKDAsIDIpID09PSAnMHgnKTtcbiAgICAgICAgaWYgKCFpc0hleCAmJiAhKDAsIHV0aWxfMS5pc0FzY2lpU3RyKShwYXlsb2FkLCB0cnVlKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgJzB4JyBwcmVmaXhlZCBidXQgaXMgbm90IHZhbGlkIEFTQ0lJLCBjb252ZXJ0IHRvIGhleCBwYXlsb2FkXG4gICAgICAgICAgICBpc0hleCA9IHRydWU7XG4gICAgICAgICAgICBwYXlsb2FkID0gXCIweFwiLmNvbmNhdChidWZmZXJfMS5CdWZmZXIuZnJvbShwYXlsb2FkKS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBlbmNvZGluZ1R5cGUgdG8gcmVhbCB2YWx1ZVxuICAgICAgICBlbmNvZGluZyA9IGlzSGV4ID9cbiAgICAgICAgICAgIGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuRU5DT0RJTkdTLkhFWCA6XG4gICAgICAgICAgICBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkVOQ09ESU5HUy5BU0NJSTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBlbmNvZGluZyB0eXBlIHNwZWNpZmllZCBpcyBzdXBwb3J0ZWQgYnkgZmlybXdhcmVcbiAgICBpZiAoISgwLCB1dGlsXzEuZXhpc3RzSW4pKGVuY29kaW5nLCBhbGxvd2VkRW5jb2RpbmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIHR5cGUgbm90IHN1cHBvcnRlZCBieSBMYXR0aWNlIGZpcm13YXJlLicpO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmcgdHlwZVxuICAgIGlmIChlbmNvZGluZyA9PT0gaW5kZXhfMS5Db25zdGFudHMuU0lHTklORy5FTkNPRElOR1MuSEVYIHx8XG4gICAgICAgIGVuY29kaW5nID09PSBpbmRleF8xLkNvbnN0YW50cy5TSUdOSU5HLkVOQ09ESU5HUy5TT0xBTkEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWRCdWY6ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShwYXlsb2FkKSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09IGluZGV4XzEuQ29uc3RhbnRzLlNJR05JTkcuRU5DT0RJTkdTLkFTQ0lJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXlsb2FkQnVmOiBidWZmZXJfMS5CdWZmZXIuZnJvbShwYXlsb2FkKSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIGVuY29kaW5nIHR5cGUuJyk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0RW5jb2RlZFBheWxvYWQgPSBnZXRFbmNvZGVkUGF5bG9hZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLm5pYmJsZSA9IGV4cG9ydHMuaW50ZWdlciA9IGV4cG9ydHMuYnl0ZSA9IGV4cG9ydHMuYnVmZmVyID0gZXhwb3J0cy5iaXRzID0gdm9pZCAwO1xudmFyIGJpdHNfMSA9IHJlcXVpcmUoXCIuL2JpdHNcIik7XG5leHBvcnRzLmJpdHMgPSBiaXRzXzEuZGVmYXVsdDtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2J1ZmZlclwiKTtcbmV4cG9ydHMuYnVmZmVyID0gYnVmZmVyXzEuZGVmYXVsdDtcbnZhciBieXRlXzEgPSByZXF1aXJlKFwiLi9ieXRlXCIpO1xuZXhwb3J0cy5ieXRlID0gYnl0ZV8xLmRlZmF1bHQ7XG52YXIgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmV4cG9ydHMuaW50ZWdlciA9IGludGVnZXJfMS5kZWZhdWx0O1xudmFyIG5pYmJsZV8xID0gcmVxdWlyZShcIi4vbmliYmxlXCIpO1xuZXhwb3J0cy5uaWJibGUgPSBuaWJibGVfMS5kZWZhdWx0O1xudmFyIHN0cmluZ18xID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmdfMS5kZWZhdWx0O1xudmFyIGJpdHdpc2UgPSB7IGJpdHM6IGJpdHNfMS5kZWZhdWx0LCBidWZmZXI6IGJ1ZmZlcl8xLmRlZmF1bHQsIGJ5dGU6IGJ5dGVfMS5kZWZhdWx0LCBpbnRlZ2VyOiBpbnRlZ2VyXzEuZGVmYXVsdCwgbmliYmxlOiBuaWJibGVfMS5kZWZhdWx0LCBzdHJpbmc6IHN0cmluZ18xLmRlZmF1bHQgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJpdHdpc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFV0aWxzIGZvciBFdGhlcmV1bSB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgZWZmZWNpdHZlbHkgYSBzaGltIG9mIGV0aGVyZXVtanMtdXRpbCwgd2hpY2hcbi8vIGRvZXMgbm90IGhhdmUgYnJvd3NlciAob3IsIGJ5IHByb3h5LCBSZWFjdC1OYXRpdmUpIHN1cHBvcnQuXG52YXIgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG52YXIgYm9yY18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJib3JjXCIpKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLy9AdHMtZXhwZWN0LWVycm9yIC0gVGhpcyB0aGlyZC1wYXJ0eSBwYWNrYWdlIGlzIG5vdCB0eXBlZCBwcm9wZXJseVxudmFyIGV0aF9laXA3MTJfdXRpbF9icm93c2VyXzEgPSByZXF1aXJlKFwiZXRoLWVpcDcxMi11dGlsLWJyb3dzZXJcIik7XG52YXIganNfc2hhM18xID0gcmVxdWlyZShcImpzLXNoYTNcIik7XG52YXIgcmxwX2Jyb3dzZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmxwLWJyb3dzZXJcIikpO1xudmFyIHNlY3AyNTZrMV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LnBheWxvYWQgfHwgIWlucHV0LnByb3RvY29sIHx8ICFpbnB1dC5zaWduZXJQYXRoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYHBheWxvYWRgLCBgc2lnbmVyUGF0aGAsIGFuZCBgcHJvdG9jb2xgIGFyZ3VtZW50cyBpbiB0aGUgbWVzc3NhZ2UgcmVxdWVzdCcpO1xuICAgIGlmIChpbnB1dC5zaWduZXJQYXRoLmxlbmd0aCA+IDUgfHwgaW5wdXQuc2lnbmVyUGF0aC5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgc2lnbmVyIHBhdGggd2l0aCAyLTUgaW5kaWNlcycpO1xuICAgIHZhciByZXEgPSB7XG4gICAgICAgIHNjaGVtYTogY29uc3RhbnRzXzEuc2lnbmluZ1NjaGVtYS5FVEhfTVNHLFxuICAgICAgICBwYXlsb2FkOiBudWxsLFxuICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgIG1zZzogbnVsbCwgLy8gU2F2ZSB0aGUgYnVmZmVyZWQgbWVzc2FnZSBmb3IgbGF0ZXJcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NpZ25QZXJzb25hbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUGVyc29uYWxTaWduUmVxdWVzdChyZXEsIGlucHV0KTtcbiAgICAgICAgICAgIGNhc2UgJ2VpcDcxMic6XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5md0NvbnN0YW50cy5laXA3MTJTdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQNzEyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBMYXR0aWNlIGZpcm13YXJlIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZEVJUDcxMlJlcXVlc3QocmVxLCBpbnB1dCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7IGVycjogZXJyLnRvU3RyaW5nKCkgfTtcbiAgICB9XG59O1xudmFyIHZhbGlkYXRlRXRoZXJldW1Nc2dSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXMsIHJlcSkge1xuICAgIHZhciBzaWduZXIgPSByZXMuc2lnbmVyLCBzaWcgPSByZXMuc2lnO1xuICAgIHZhciBpbnB1dCA9IHJlcS5pbnB1dCwgbXNnID0gcmVxLm1zZywgX2EgPSByZXEucHJlaGFzaCwgcHJlaGFzaCA9IF9hID09PSB2b2lkIDAgPyBudWxsIDogX2E7XG4gICAgaWYgKGlucHV0LnByb3RvY29sID09PSAnc2lnblBlcnNvbmFsJykge1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgY3VycmVudGx5IGhhcmRjb2RpbmcgbmV0d29ya0lEPTEgYW5kIHVzZUVJUDE1NT1mYWxzZSBidXQgdGhlc2VcbiAgICAgICAgLy8gICAgICAgbWF5IGJlIGNvbmZpZ3VyYWJsZSBpbiBmdXR1cmUgdmVyc2lvbnNcbiAgICAgICAgdmFyIGhhc2hfMSA9IHByZWhhc2hcbiAgICAgICAgICAgID8gcHJlaGFzaFxuICAgICAgICAgICAgOiBidWZmZXJfMS5CdWZmZXIuZnJvbSgoMCwganNfc2hhM18xLmtlY2NhazI1NikoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbZ2V0X3BlcnNvbmFsX3NpZ25fcHJlZml4KG1zZy5sZW5ndGgpLCBtc2ddKSksICdoZXgnKTtcbiAgICAgICAgLy8gR2V0IHJlY292ZXJ5IHBhcmFtIHdpdGggYSBgdmAgdmFsdWUgb2YgWzI3LDI4XSBieSBzZXR0aW5nIGB1c2VFSVAxNTU9ZmFsc2VgXG4gICAgICAgIHJldHVybiBhZGRSZWNvdmVyeVBhcmFtKGhhc2hfMSwgc2lnLCBzaWduZXIsIHtcbiAgICAgICAgICAgIGNoYWluSWQ6IDEsXG4gICAgICAgICAgICB1c2VFSVAxNTU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQucHJvdG9jb2wgPT09ICdlaXA3MTInKSB7XG4gICAgICAgIHZhciBlbmNvZGVkID0gZXRoX2VpcDcxMl91dGlsX2Jyb3dzZXJfMS5UeXBlZERhdGFVdGlscy5oYXNoKHJlcS5pbnB1dC5wYXlsb2FkKTtcbiAgICAgICAgdmFyIGRpZ2VzdCA9IHByZWhhc2ggPyBwcmVoYXNoIDogZW5jb2RlZDtcbiAgICAgICAgLy8gR2V0IHJlY292ZXJ5IHBhcmFtIHdpdGggYSBgdmAgdmFsdWUgb2YgWzI3LDI4XSBieSBzZXR0aW5nIGB1c2VFSVAxNTU9ZmFsc2VgXG4gICAgICAgIHJldHVybiBhZGRSZWNvdmVyeVBhcmFtKGRpZ2VzdCwgc2lnLCBzaWduZXIsIHsgdXNlRUlQMTU1OiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wnKTtcbiAgICB9XG59O1xudmFyIGJ1aWxkRXRoZXJldW1UeFJlcXVlc3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBfYSA9IGRhdGEuY2hhaW5JZCwgY2hhaW5JZCA9IF9hID09PSB2b2lkIDAgPyAxIDogX2E7XG4gICAgICAgIHZhciBzaWduZXJQYXRoID0gZGF0YS5zaWduZXJQYXRoLCBfYiA9IGRhdGEuZWlwMTU1LCBlaXAxNTUgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLCBmd0NvbnN0YW50cyA9IGRhdGEuZndDb25zdGFudHMsIF9jID0gZGF0YS50eXBlLCB0eXBlID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYztcbiAgICAgICAgdmFyIGNvbnRyYWN0RGVwbG95S2V5ID0gZndDb25zdGFudHMuY29udHJhY3REZXBsb3lLZXksIGV4dHJhRGF0YUZyYW1lU3ogPSBmd0NvbnN0YW50cy5leHRyYURhdGFGcmFtZVN6LCBleHRyYURhdGFNYXhGcmFtZXMgPSBmd0NvbnN0YW50cy5leHRyYURhdGFNYXhGcmFtZXMsIHByZWhhc2hBbGxvd2VkID0gZndDb25zdGFudHMucHJlaGFzaEFsbG93ZWQ7XG4gICAgICAgIHZhciBFWFRSQV9EQVRBX0FMTE9XRUQgPSBleHRyYURhdGFGcmFtZVN6ID4gMCAmJiBleHRyYURhdGFNYXhGcmFtZXMgPiAwO1xuICAgICAgICB2YXIgTUFYX0JBU0VfREFUQV9TWiA9IGZ3Q29uc3RhbnRzLmV0aE1heERhdGFTejtcbiAgICAgICAgdmFyIFZBUl9QQVRIX1NaID0gZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQ7XG4gICAgICAgIC8vIFNhbml0eSBjaGVja3M6XG4gICAgICAgIC8vIFRoZXJlIGFyZSBhIGhhbmRmdWwgb2YgbmFtZWQgY2hhaW5zIHdlIGFsbG93IHRoZSB1c2VyIHRvIHJlZmVyZW5jZSAoYGNoYWluSWRzYClcbiAgICAgICAgLy8gQ3VzdG9tIGNoYWluSURzIHNob3VsZCBiZSBlaXRoZXIgbnVtZXJpY2FsIG9yIGhleCBzdHJpbmdzXG4gICAgICAgIGlmICh0eXBlb2YgY2hhaW5JZCAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIGlzVmFsaWRDaGFpbklkSGV4TnVtU3RyKGNoYWluSWQpID09PSBmYWxzZSlcbiAgICAgICAgICAgIGNoYWluSWQgPSBjaGFpbklkc1tjaGFpbklkXTtcbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgbm90IGEgY3VzdG9tIGNoYWluSUQgYW5kIHdlIGNhbm5vdCBmaW5kIHRoZSBuYW1lIG9mIGl0LCBleGl0XG4gICAgICAgIGlmICghY2hhaW5JZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2hhaW4gSUQgb3IgbmFtZScpO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgb24gc2lnbmVQYXRoXG4gICAgICAgIGlmICghc2lnbmVyUGF0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYHNpZ25lclBhdGhgIG5vdCBwcm92aWRlZCcpO1xuICAgICAgICAvLyBJcyB0aGlzIGEgY29udHJhY3QgZGVwbG95bWVudD9cbiAgICAgICAgaWYgKGRhdGEudG8gPT09IG51bGwgJiYgIWNvbnRyYWN0RGVwbG95S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGRlcGxveW1lbnQgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB5b3VyIExhdHRpY2UgZmlybXdhcmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRGVwbG95bWVudCA9IGRhdGEudG8gPT09IG51bGwgJiYgY29udHJhY3REZXBsb3lLZXk7XG4gICAgICAgIC8vIFdlIHN1cHBvcnQgZWlwMTU1OSBhbmQgZWlwMjkzMCB0eXBlcyAoYXMgd2VsbCBhcyBsZWdhY3kpXG4gICAgICAgIHZhciBlaXAxNTU5SXNBbGxvd2VkID0gZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMgJiZcbiAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzLmluZGV4T2YoMikgPiAtMTtcbiAgICAgICAgdmFyIGVpcDI5MzBJc0FsbG93ZWQgPSBmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcyAmJlxuICAgICAgICAgICAgZndDb25zdGFudHMuYWxsb3dlZEV0aFR4VHlwZXMuaW5kZXhPZigxKSA+IC0xO1xuICAgICAgICB2YXIgaXNFaXAxNTU5ID0gZWlwMTU1OUlzQWxsb3dlZCAmJiAodHlwZSA9PT0gMiB8fCB0eXBlID09PSAnZWlwMTU1OScpO1xuICAgICAgICB2YXIgaXNFaXAyOTMwID0gZWlwMjkzMElzQWxsb3dlZCAmJiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSAnZWlwMjkzMCcpO1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiAhaXNFaXAxNTU5ICYmICFpc0VpcDI5MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEV0aGVyZXVtIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgRUlQMTU1IGdpdmVuIHRoZSBjaGFpbklELlxuICAgICAgICAvLyBJZiB3ZSBhcmUgZXhwbGljaXRseSB0b2xkIHRvIHVzZSBlaXAxNTUsIHdlIHdpbGwgdXNlIGl0LiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHdlIHdpbGwgbG9vayB1cCBpZiB0aGUgc3BlY2lmaWVkIGNoYWluSWQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgY2hhaW5cbiAgICAgICAgLy8gdGhhdCBkb2VzIG5vdCB1c2UgRUlQMTU1IGJ5IGRlZmF1bHQuIE5vdGUgdGhhdCBtb3N0IGRvIHVzZSBFSVAxNTUuXG4gICAgICAgIHZhciB1c2VFSVAxNTUgPSBjaGFpblVzZXNFSVAxNTUoY2hhaW5JZCk7XG4gICAgICAgIGlmIChlaXAxNTUgIT09IG51bGwgJiYgdHlwZW9mIGVpcDE1NSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB1c2VFSVAxNTUgPSBlaXAxNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFaXAxNTU5IHx8IGlzRWlwMjkzMCkge1xuICAgICAgICAgICAgLy8gTmV3ZXIgdHJhbnNhY3Rpb24gdHlwZXMgZG8gbm90IHVzZSBFSVAxNTUgc2luY2UgdGhlIGNoYWluSWQgaXMgc2VyaWFsaXplZFxuICAgICAgICAgICAgdXNlRUlQMTU1ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayBmb3IgbWV0YW1hc2ssIHdoaWNoIHNlbmRzIHZhbHVlPW51bGwgZm9yIDAgRVRIIHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAoIWRhdGEudmFsdWUpXG4gICAgICAgICAgICBkYXRhLnZhbHVlID0gMDtcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAxLiBCVUlMRCBUSEUgUkFXIFRYIEZPUiBGVVRVUkUgUkxQIEVOQ09ESU5HXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRW5zdXJlIGFsbCBmaWVsZHMgYXJlIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzXG4gICAgICAgIHZhciByYXdUeCA9IFtdO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb24gYnVmZmVyIGFycmF5XG4gICAgICAgIHZhciBjaGFpbklkQnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoY2hhaW5JZCk7XG4gICAgICAgIHZhciBub25jZUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEubm9uY2UpO1xuICAgICAgICB2YXIgZ2FzUHJpY2VCeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGdhc0xpbWl0Qnl0ZXMgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS5nYXNMaW1pdCk7XG4gICAgICAgIC8vIEhhbmRsZSBjb250cmFjdCBkZXBsb3ltZW50IChpbmRpY2F0ZWQgYnkgYHRvYCBiZWluZyBgbnVsbGApXG4gICAgICAgIC8vIEZvciBjb250cmFjdCBkZXBsb3ltZW50IHdlIHdyaXRlIGEgMjAtYnl0ZSBrZXkgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gYnVmZmVyLCB3aGljaCBnZXRzIHN3YXBwZWQgZm9yIGFuIGVtcHR5IGJ1ZmZlciBpbiBmaXJtd2FyZS5cbiAgICAgICAgdmFyIHRvUmxwRWxlbSA9IHZvaWQgMCwgdG9CeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzRGVwbG95bWVudCkge1xuICAgICAgICAgICAgdG9SbHBFbGVtID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgdG9CeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShjb250cmFjdERlcGxveUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JscEVsZW0gPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YS50byk7XG4gICAgICAgICAgICB0b0J5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEudmFsdWUpO1xuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGRhdGEuZGF0YSk7XG4gICAgICAgIGlmIChpc0VpcDE1NTkgfHwgaXNFaXAyOTMwKSB7XG4gICAgICAgICAgICAvLyBFSVAxNTU5IGFuZCBFSVAyOTMwIHRyYW5zYWN0aW9ucyBoYXZlIGEgY2hhaW5JRCBmaWVsZFxuICAgICAgICAgICAgcmF3VHgucHVzaChjaGFpbklkQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJhd1R4LnB1c2gobm9uY2VCeXRlcyk7XG4gICAgICAgIHZhciBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzID0gdm9pZCAwLCBtYXhGZWVQZXJHYXNCeXRlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlzRWlwMTU1OSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQMTU1OSB0cmFuc2FjdGlvbnMgbXVzdCBpbmNsdWRlIGBtYXhQcmlvcml0eUZlZVBlckdhc2AnKTtcbiAgICAgICAgICAgIGlmICghZGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUDE1NTkgdHJhbnNhY3Rpb25zIG11c3QgaW5jbHVkZSBgbWF4RmVlUGVyR2FzYCcpO1xuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIHJhd1R4LnB1c2gobWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyk7XG4gICAgICAgICAgICBtYXhGZWVQZXJHYXNCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLm1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICByYXdUeC5wdXNoKG1heEZlZVBlckdhc0J5dGVzKTtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgcmVuYW1lZCBcImdhc1ByaWNlXCIgdG8gXCJtYXhGZWVQZXJHYXNcIiwgYnV0IGZpcm13YXJlIHN0aWxsXG4gICAgICAgICAgICAvLyB1c2VzIGBnYXNQcmljZWAgaW4gdGhlIHN0cnVjdCwgc28gdXBkYXRlIHRoYXQgdmFsdWUgaGVyZS5cbiAgICAgICAgICAgIGdhc1ByaWNlQnl0ZXMgPSBtYXhGZWVQZXJHYXNCeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVJUDE1NTkgdHJhbnNhY3Rpb25zIGRvIG5vdCBoYXZlIHRoZSBnYXNQcmljZSBmaWVsZFxuICAgICAgICAgICAgZ2FzUHJpY2VCeXRlcyA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhLmdhc1ByaWNlKTtcbiAgICAgICAgICAgIHJhd1R4LnB1c2goZ2FzUHJpY2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmF3VHgucHVzaChnYXNMaW1pdEJ5dGVzKTtcbiAgICAgICAgcmF3VHgucHVzaCh0b1JscEVsZW0pO1xuICAgICAgICByYXdUeC5wdXNoKHZhbHVlQnl0ZXMpO1xuICAgICAgICByYXdUeC5wdXNoKGRhdGFCeXRlcyk7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NMaXN0IGluIGZpcm13YXJlIHNvIHdlIG5lZWQgdG8gcHJlaGFzaCBpZlxuICAgICAgICAvLyB0aGUgbGlzdCBpcyBub24tbnVsbFxuICAgICAgICB2YXIgUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUXzEgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzRWlwMTU1OSB8fCBpc0VpcDI5MzApIHtcbiAgICAgICAgICAgIHZhciBhY2Nlc3NMaXN0XzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuYWNjZXNzTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmFjY2Vzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0uc3RvcmFnZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzTGlzdF8xLnB1c2goWygwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShsaXN0SXRlbS5hZGRyZXNzKSwga2V5c10pO1xuICAgICAgICAgICAgICAgICAgICBQUkVIQVNIX0ZST01fQUNDRVNTX0xJU1RfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYXdUeC5wdXNoKGFjY2Vzc0xpc3RfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXNlRUlQMTU1ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBBZGQgZW1wdHkgdixyLHMgdmFsdWVzIGZvciBFSVAxNTUgbGVnYWN5IHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgcmF3VHgucHVzaChjaGFpbklkQnl0ZXMpOyAvLyB2ICh3aGljaCBpcyB0aGUgc2FtZSBhcyBjaGFpbklkIGluIEVJUDE1NSB0eHMpXG4gICAgICAgICAgICByYXdUeC5wdXNoKCgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShudWxsKSk7IC8vIHJcbiAgICAgICAgICAgIHJhd1R4LnB1c2goKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKG51bGwpKTsgLy8gc1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gMi4gQlVJTEQgVEhFIExBVFRJQ0UgUkVRVUVTVCBQQVlMT0FEXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdmFyIEVUSF9UWF9OT05fREFUQV9TWiA9IDEyMjsgLy8gQWNjb3VudHMgZm9yIG1ldGFkYXRhIGFuZCBub24tZGF0YSBwYXJhbXNcbiAgICAgICAgdmFyIEVUSF9UWF9FWFRSQV9GSUVMRFNfU1ogPSAwOyAvLyBBY2NvdW50cyBmb3IgbmV3ZXIgRVRIIHR4IHR5cGVzIChlLmcuIGVpcDE1NTkpXG4gICAgICAgIGlmIChmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlc1ZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGVpcDE1NTkgYW5kIGVpcDI5MzBcbiAgICAgICAgICAgIC8vIEFkZCBleHRyYSBwYXJhbXMgYW5kIHNocmluayB0aGUgZGF0YSByZWdpb24gKGV4dHJhRGF0YSBibG9ja3MgYXJlIHVuYWZmZWN0ZWQpXG4gICAgICAgICAgICBFVEhfVFhfRVhUUkFfRklFTERTX1NaID0gZndDb25zdGFudHMudG90YWxFeHRyYUV0aFR4RGF0YVN6O1xuICAgICAgICAgICAgTUFYX0JBU0VfREFUQV9TWiAtPSBFVEhfVFhfRVhUUkFfRklFTERTX1NaO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eFJlcVBheWxvYWQgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoTUFYX0JBU0VfREFUQV9TWiArIEVUSF9UWF9OT05fREFUQV9TWik7XG4gICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAvLyAxLiBFSVAxNTUgc3dpdGNoIGFuZCBjaGFpbklEXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KE51bWJlcih1c2VFSVAxNTUpLCBvZmYpO1xuICAgICAgICBvZmYrKztcbiAgICAgICAgLy8gTk9URTogT3JpZ2luYWxseSB3ZSBkZXNpZ25lZCBmb3IgYSAxLWJ5dGUgY2hhaW5JRCwgYnV0IG1vZGVybiByb2xsdXAgY2hhaW5zIHVzZSBtdWNoIGxhcmdlclxuICAgICAgICAvLyBjaGFpbklEIHZhbHVlcy4gVG8gYWNjb3VudCBmb3IgdGhlc2UsIHdlIHdpbGwgcHV0IHRoZSBjaGFpbklEIGludG8gdGhlIGBkYXRhYCBidWZmZXIgaWYgaXRcbiAgICAgICAgLy8gaXMgPj0yNTUuIFZhbHVlcyB1cCB0byBVSU5UNjRfTUFYIHdpbGwgYmUgYWxsb3dlZC5cbiAgICAgICAgdmFyIGNoYWluSWRCdWYgPSB2b2lkIDA7XG4gICAgICAgIHZhciBjaGFpbklkQnVmU3ogPSAwO1xuICAgICAgICBpZiAodXNlQ2hhaW5JZEJ1ZmZlcihjaGFpbklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2hhaW5JZEJ1ZiA9IGdldENoYWluSWRCdWYoY2hhaW5JZCk7XG4gICAgICAgICAgICBjaGFpbklkQnVmU3ogPSBjaGFpbklkQnVmLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjaGFpbklkQnVmU3ogPiBjb25zdGFudHNfMS5NQVhfQ0hBSU5fSURfQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbklEIHByb3ZpZGVkIGlzIHRvbyBsYXJnZS4nKTtcbiAgICAgICAgICAgIC8vIFNpZ25hbCB0byBMYXR0aWNlIGZpcm13YXJlIHRoYXQgaXQgbmVlZHMgdG8gcmVhZCB0aGUgY2hhaW5JZCBmcm9tIHRoZSB0eC5kYXRhIGJ1ZmZlclxuICAgICAgICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoY29uc3RhbnRzXzEuSEFORExFX0xBUkdFUl9DSEFJTl9JRCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGNoYWluSURzIDwyNTUsIHdyaXRlIGl0IHRvIHRoZSBjaGFpbklkIHU4IHNsb3QgaW4gdGhlIG1haW4gdHggYnVmZmVyXG4gICAgICAgICAgICBjaGFpbklkQnVmID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKGNoYWluSWRCdWYubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBjaGFpbklEJyk7XG4gICAgICAgICAgICBjaGFpbklkQnVmLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IGNoYWluSWRCdWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIDIuIFNpZ25lciBQYXRoXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBzaWduZXJQYXRoQnVmID0gKDAsIHV0aWxfMS5idWlsZFNpZ25lclBhdGhCdWYpKHNpZ25lclBhdGgsIFZBUl9QQVRIX1NaKTtcbiAgICAgICAgc2lnbmVyUGF0aEJ1Zi5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuICAgICAgICAvLyAzLiBFVEggVFggcmVxdWVzdCBkYXRhXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGlmIChub25jZUJ5dGVzLmxlbmd0aCA+IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmNlIHRvbyBsYXJnZScpO1xuICAgICAgICBub25jZUJ5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYgKyAoNCAtIG5vbmNlQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgIG9mZiArPSA0O1xuICAgICAgICBpZiAoZ2FzUHJpY2VCeXRlcy5sZW5ndGggPiA4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYXMgcHJpY2UgdG9vIGxhcmdlJyk7XG4gICAgICAgIGdhc1ByaWNlQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZiArICg4IC0gZ2FzUHJpY2VCeXRlcy5sZW5ndGgpKTtcbiAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIGlmIChnYXNMaW1pdEJ5dGVzLmxlbmd0aCA+IDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhcyBsaW1pdCB0b28gbGFyZ2UnKTtcbiAgICAgICAgZ2FzTGltaXRCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDQgLSBnYXNMaW1pdEJ5dGVzLmxlbmd0aCkpO1xuICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgaWYgKHRvQnl0ZXMubGVuZ3RoICE9PSAyMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgdG9gIGFkZHJlc3MnKTtcbiAgICAgICAgdG9CeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDIwO1xuICAgICAgICBpZiAodmFsdWVCeXRlcy5sZW5ndGggPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdG9vIGxhcmdlJyk7XG4gICAgICAgIHZhbHVlQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZiArICgzMiAtIHZhbHVlQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgIG9mZiArPSAzMjtcbiAgICAgICAgLy8gRXh0cmEgVHggZGF0YSBjb21lcyBiZWZvcmUgYGRhdGFgIGluIHRoZSBzdHJ1Y3RcbiAgICAgICAgdmFyIFBSRUhBU0hfVU5TVVBQT1JURUQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGV4dHJhRXRoVHhEYXRhU3ogPSBmd0NvbnN0YW50cy50b3RhbEV4dHJhRXRoVHhEYXRhU3ogfHwgMDtcbiAgICAgICAgICAgIC8vIFNvbWUgdHlwZXMgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgYnkgZmlybXdhcmUsIHNvIHdlIHdpbGwgbmVlZCB0byBwcmVoYXNoXG4gICAgICAgICAgICBpZiAoUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUXzEpIHtcbiAgICAgICAgICAgICAgICBQUkVIQVNIX1VOU1VQUE9SVEVEID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KFBSRUhBU0hfVU5TVVBQT1JURUQgPyAxIDogMCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICAgICAgLy8gRUlQMTU1OSAmIEVJUDI5MzAgc3RydWN0IHZlcnNpb25cbiAgICAgICAgICAgIGlmIChpc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OCgyLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxOyAvLyBFaXAxNTU5IHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmxlbmd0aCA+IDgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYgKyAoOCAtIG1heFByaW9yaXR5RmVlUGVyR2FzQnl0ZXMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VpcDI5MzApIHtcbiAgICAgICAgICAgICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OCgxLCBvZmYpO1xuICAgICAgICAgICAgICAgIG9mZiArPSAxOyAvLyBFaXAyOTMwIHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICAgICAgICAgIG9mZiArPSBleHRyYUV0aFR4RGF0YVN6IC0gMjsgLy8gU2tpcCBFSVAxNTU5IHBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2ZmICs9IGV4dHJhRXRoVHhEYXRhU3ogLSAxOyAvLyBTa2lwIEVJUDE1NTkgYW5kIEVJUDI5MzAgcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxvdyBkYXRhIGludG8gZXh0cmFEYXRhIHJlcXVlc3RzLCB3aGljaCB3aWxsIGZvbGxvdy11cCB0cmFuc2FjdGlvbiByZXF1ZXN0cywgaWYgc3VwcG9ydGVkL2FwcGxpY2FibGVcbiAgICAgICAgdmFyIGV4dHJhRGF0YVBheWxvYWRzXzEgPSBbXTtcbiAgICAgICAgdmFyIHByZWhhc2ggPSBudWxsO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGJ1ZmZlciwgcHJlZml4IHdpdGggY2hhaW5JZCAoaWYgbmVlZGVkKSBhbmQgYWRkIGRhdGEgc2xpY2VcbiAgICAgICAgdmFyIGRhdGFTeiA9IGRhdGFCeXRlcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdmFyIGNoYWluSWRFeHRyYVN6ID0gY2hhaW5JZEJ1ZlN6ID4gMCA/IGNoYWluSWRCdWZTeiArIDEgOiAwO1xuICAgICAgICB2YXIgZGF0YVRvQ29weSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhkYXRhU3ogKyBjaGFpbklkRXh0cmFTeik7XG4gICAgICAgIGlmIChjaGFpbklkRXh0cmFTeiA+IDApIHtcbiAgICAgICAgICAgIGRhdGFUb0NvcHkud3JpdGVVSW50OChjaGFpbklkQnVmU3osIDApO1xuICAgICAgICAgICAgY2hhaW5JZEJ1Zi5jb3B5KGRhdGFUb0NvcHksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFCeXRlcy5jb3B5KGRhdGFUb0NvcHksIGNoYWluSWRFeHRyYVN6KTtcbiAgICAgICAgaWYgKGRhdGFTeiA+IE1BWF9CQVNFX0RBVEFfU1opIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBzaXplcyBhbmQgcnVuIHRocm91Z2ggc2FuaXR5IGNoZWNrc1xuICAgICAgICAgICAgdmFyIHRvdGFsU3ogPSBkYXRhU3ogKyBjaGFpbklkRXh0cmFTejtcbiAgICAgICAgICAgIHZhciBtYXhTekFsbG93ZWQgPSBNQVhfQkFTRV9EQVRBX1NaICsgZXh0cmFEYXRhTWF4RnJhbWVzICogZXh0cmFEYXRhRnJhbWVTejtcbiAgICAgICAgICAgIGlmIChwcmVoYXNoQWxsb3dlZCAmJiB0b3RhbFN6ID4gbWF4U3pBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgICAgICAgICBwcmVoYXNoID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZShyYXdUeCwgdHlwZSkpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIUVYVFJBX0RBVEFfQUxMT1dFRCB8fFxuICAgICAgICAgICAgICAgICAgICAoRVhUUkFfREFUQV9BTExPV0VEICYmIHRvdGFsU3ogPiBtYXhTekFsbG93ZWQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGZpZWxkIHRvbyBsYXJnZSAoZ290IFwiLmNvbmNhdChkYXRhQnl0ZXMubGVuZ3RoLCBcIjsgbXVzdCBiZSA8PVwiKS5jb25jYXQobWF4U3pBbGxvd2VkIC0gY2hhaW5JZEV4dHJhU3osIFwiIGJ5dGVzKVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgb3ZlcmZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSBmcmFtZXNcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzEgPSAoMCwgdXRpbF8xLnNwbGl0RnJhbWVzKShkYXRhVG9Db3B5LnNsaWNlKE1BWF9CQVNFX0RBVEFfU1opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICAgICAgICAgICAgICBmcmFtZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3pMRSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgICAgICAgICAgc3pMRS53cml0ZVVJbnQzMkxFKGZyYW1lLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzXzEucHVzaChidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQUkVIQVNIX1VOU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5zdXBwb3J0ZWQgaW4gZmlybXdhcmUgYnV0IHdlIHdhbnQgdG8gYWxsb3cgc3VjaCB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAvLyB3ZSBwcmVoYXNoIHRoZSBtZXNzYWdlIGhlcmUuXG4gICAgICAgICAgICBwcmVoYXNoID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZShyYXdUeCwgdHlwZSkpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdGhlIGRhdGEgc2l6ZSAoZG9lcyAqTk9UKiBpbmNsdWRlIHRoZSBjaGFpbklkIGJ1ZmZlciwgaWYgdGhhdCBleGlzdHMpXG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQxNkJFKGRhdGFCeXRlcy5sZW5ndGgsIG9mZik7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICAvLyBDb3B5IGluIHRoZSBjaGFpbklkIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGNoYWluSWRCdWZTeiA+IDApIHtcbiAgICAgICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVJbnQ4KGNoYWluSWRCdWZTeiwgb2ZmKTtcbiAgICAgICAgICAgIG9mZisrO1xuICAgICAgICAgICAgY2hhaW5JZEJ1Zi5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSBjaGFpbklkQnVmU3o7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29weSB0aGUgZmlyc3Qgc2xpY2Ugb2YgdGhlIGRhdGEgaXRzZWxmLiBJZiB0aGlzIHBheWxvYWQgaGFzIGJlZW4gcHJlLWhhc2hlZCwgaW5jbHVkZSBpdFxuICAgICAgICAvLyBpbiB0aGUgYGRhdGFgIGZpZWxkLiBUaGlzIHdpbGwgcmVzdWx0IGluIGEgZGlmZmVyZW50IExhdHRpY2Ugc2NyZWVuIGJlaW5nIGRyYXduLlxuICAgICAgICBpZiAocHJlaGFzaCkge1xuICAgICAgICAgICAgcHJlaGFzaC5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSBNQVhfQkFTRV9EQVRBX1NaO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YUJ5dGVzLnNsaWNlKDAsIE1BWF9CQVNFX0RBVEFfU1opLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IE1BWF9CQVNFX0RBVEFfU1o7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd1R4OiByYXdUeCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiB0eFJlcVBheWxvYWQuc2xpY2UoMCwgb2ZmKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzOiBleHRyYURhdGFQYXlsb2Fkc18xLFxuICAgICAgICAgICAgc2NoZW1hOiBjb25zdGFudHNfMS5zaWduaW5nU2NoZW1hLkVUSF9UUkFOU0ZFUixcbiAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICB1c2VFSVAxNTU6IHVzZUVJUDE1NSxcbiAgICAgICAgICAgIHNpZ25lclBhdGg6IHNpZ25lclBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbn07XG4vLyBGcm9tIGV0aGVyZXVtanMtdXRpbFxuZnVuY3Rpb24gc3RyaXBaZXJvcyhhKSB7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbi8vIEdpdmVuIGEgNjQtYnl0ZSBzaWduYXR1cmUgW3Isc10gd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSB2IHZhbHVlXG4vLyBhbmQgYXR0YWggdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uIHBheWxvYWRcbnZhciBidWlsZEV0aFJhd1R4ID0gZnVuY3Rpb24gKHR4LCBzaWcsIGFkZHJlc3MpIHtcbiAgICAvLyBSTFAtZW5jb2RlIHRoZSBkYXRhIHdlIHNlbnQgdG8gdGhlIGxhdHRpY2VcbiAgICB2YXIgaGFzaCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UodHgucmF3VHgsIHR4LnR5cGUpKSwgJ2hleCcpO1xuICAgIHZhciBuZXdTaWcgPSBhZGRSZWNvdmVyeVBhcmFtKGhhc2gsIHNpZywgYWRkcmVzcywgdHgpO1xuICAgIC8vIFVzZSB0aGUgc2lnbmF0dXJlIHRvIGdlbmVyYXRlIGEgbmV3IHJhdyB0cmFuc2FjdGlvbiBwYXlsb2FkXG4gICAgLy8gU3RyaXAgdGhlIGxhc3QgMyBpdGVtcyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggc2lnbmF0dXJlIGNvbXBvbmVudHNcbiAgICB2YXIgbmV3UmF3VHggPSB0eC51c2VFSVAxNTUgPyB0eC5yYXdUeC5zbGljZSgwLCAtMykgOiB0eC5yYXdUeDtcbiAgICBuZXdSYXdUeC5wdXNoKG5ld1NpZy52KTtcbiAgICAvLyBQZXIgYGV0aGVyZXVtanMtdHhgLCBSTFAgZW5jb2Rpbmcgc2hvdWxkIGluY2x1ZGUgc2lnbmF0dXJlIGNvbXBvbmVudHMgdy8gc3RyaXBwZWQgemVyb3NcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL2V0aGVyZXVtanMtdHgvYmxvYi9tYXN0ZXIvc3JjL3RyYW5zYWN0aW9uLnRzI0wxODdcbiAgICBuZXdSYXdUeC5wdXNoKHN0cmlwWmVyb3MobmV3U2lnLnIpKTtcbiAgICBuZXdSYXdUeC5wdXNoKHN0cmlwWmVyb3MobmV3U2lnLnMpKTtcbiAgICB2YXIgcmxwRW5jb2RlZFdpdGhTaWcgPSBybHBfYnJvd3Nlcl8xLmRlZmF1bHQuZW5jb2RlKG5ld1Jhd1R4KTtcbiAgICBpZiAodHgudHlwZSkge1xuICAgICAgICBybHBFbmNvZGVkV2l0aFNpZyA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oW3R4LnR5cGVdKSxcbiAgICAgICAgICAgIHJscEVuY29kZWRXaXRoU2lnLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmF3VHg6IHJscEVuY29kZWRXaXRoU2lnLnRvU3RyaW5nKCdoZXgnKSwgc2lnV2l0aFY6IG5ld1NpZyB9O1xufTtcbi8vIEF0dGFjaCBhIHJlY292ZXJ5IHBhcmFtZXRlciB0byBhIHNpZ25hdHVyZSBieSBicnV0ZS1mb3JjaW5nIEVDUmVjb3ZlclxuZnVuY3Rpb24gYWRkUmVjb3ZlcnlQYXJhbShoYXNoQnVmLCBzaWcsIGFkZHJlc3MsIHR4RGF0YSkge1xuICAgIGlmICh0eERhdGEgPT09IHZvaWQgMCkgeyB0eERhdGEgPSB7fTsgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIFJlYnVpbGQgdGhlIGtlY2NhazI1NiBoYXNoIGhlcmUgc28gd2UgY2FuIGBlY3JlY292ZXJgXG4gICAgICAgIHZhciBoYXNoXzIgPSBuZXcgVWludDhBcnJheShoYXNoQnVmKTtcbiAgICAgICAgdmFyIHYgPSAwO1xuICAgICAgICAvLyBGaXggc2lnbmF0dXJlIGNvbXBvbmVuZXQgbGVuZ3RocyB0byAzMiBieXRlcyBlYWNoXG4gICAgICAgIHZhciByID0gKDAsIHV0aWxfMS5maXhMZW4pKHNpZy5yLCAzMik7XG4gICAgICAgIHNpZy5yID0gcjtcbiAgICAgICAgdmFyIHMgPSAoMCwgdXRpbF8xLmZpeExlbikoc2lnLnMsIDMyKTtcbiAgICAgICAgc2lnLnMgPSBzO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlY292ZXJ5IHBhcmFtXG4gICAgICAgIHZhciBycyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3IsIHNdKSk7XG4gICAgICAgIHZhciBwdWJrZXkgPSBzZWNwMjU2azFfMS5kZWZhdWx0LmVjZHNhUmVjb3ZlcihycywgdiwgaGFzaF8yLCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBgdmAgdmFsdWUgaXMgYSBtYXRjaCwgcmV0dXJuIHRoZSBzaWchXG4gICAgICAgIGlmIChwdWJUb0FkZHJTdHIocHVia2V5KSA9PT0gYWRkcmVzcy50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgICAgIHNpZy52ID0gZ2V0UmVjb3ZlcnlQYXJhbSh2LCB0eERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRyeSB0aGUgb3RoZXIgYHZgIHZhbHVlXG4gICAgICAgIHYgPSAxO1xuICAgICAgICBwdWJrZXkgPSBzZWNwMjU2azFfMS5kZWZhdWx0LmVjZHNhUmVjb3ZlcihycywgdiwgaGFzaF8yLCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwdWJUb0FkZHJTdHIocHVia2V5KSA9PT0gYWRkcmVzcy50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgICAgIHNpZy52ID0gZ2V0UmVjb3ZlcnlQYXJhbSh2LCB0eERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5laXRoZXIgaXMgYSBtYXRjaCwgd2Ugc2hvdWxkIHJldHVybiBhbiBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEV0aGVyZXVtIHNpZ25hdHVyZSByZXR1cm5lZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgIH1cbn1cbi8vIENvbnZlcnQgYW4gUkxQLXNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gKHBsdXMgc2lnbmF0dXJlKSBpbnRvIGEgdHJhbnNhY3Rpb24gaGFzaFxudmFyIGhhc2hUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChzZXJpYWxpemVkVHgpIHtcbiAgICByZXR1cm4gKDAsIGpzX3NoYTNfMS5rZWNjYWsyNTYpKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWRUeCwgJ2hleCcpKTtcbn07XG4vLyBSZXR1cm5zIGFkZHJlc3Mgc3RyaW5nIGdpdmVuIHB1YmxpYyBrZXkgYnVmZmVyXG5mdW5jdGlvbiBwdWJUb0FkZHJTdHIocHViKSB7XG4gICAgcmV0dXJuICgwLCBqc19zaGEzXzEua2VjY2FrMjU2KShwdWIpLnNsaWNlKC00MCk7XG59XG4vLyBDb252ZXJ0IGEgMC8xIGB2YCBpbnRvIGEgcmVjb3ZlcnkgcGFyYW06XG4vLyAqIEZvciBub24tRUlQMTU1IHRyYW5zYWN0aW9ucywgcmV0dXJuIGAyNyArIHZgXG4vLyAqIEZvciBFSVAxNTUgdHJhbnNhY3Rpb25zLCByZXR1cm4gYChDSEFJTl9JRCoyKSArIDM1ICsgdmBcbmZ1bmN0aW9uIGdldFJlY292ZXJ5UGFyYW0odiwgdHhEYXRhKSB7XG4gICAgaWYgKHR4RGF0YSA9PT0gdm9pZCAwKSB7IHR4RGF0YSA9IHt9OyB9XG4gICAgdmFyIGNoYWluSWQgPSB0eERhdGEuY2hhaW5JZCwgdXNlRUlQMTU1ID0gdHhEYXRhLnVzZUVJUDE1NSwgdHlwZSA9IHR4RGF0YS50eXBlO1xuICAgIC8vIEZvciBFSVAxNTU5IGFuZCBFSVAyOTMwIHRyYW5zYWN0aW9ucywgd2Ugd2FudCB0aGUgcmVjb3ZlcnlQYXJhbSAoMCBvciAxKVxuICAgIC8vIHJhdGhlciB0aGFuIHRoZSBgdmAgdmFsdWUgYmVjYXVzZSB0aGUgYGNoYWluSWRgIGlzIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gcGF5bG9hZC5cbiAgICBpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSAyKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikodiwgdHJ1ZSk7IC8vIDAgb3IgMSwgd2l0aCAwIGV4cGVjdGVkIGFzIGFuIGVtcHR5IGJ1ZmZlclxuICAgIH1cbiAgICBlbHNlIGlmIChmYWxzZSA9PT0gdXNlRUlQMTU1IHx8IGNoYWluSWQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRm9yIEVUSCBtZXNzYWdlcyBhbmQgbm9uLUVJUDE1NSBjaGFpbnMgdGhlIHNldCBzaG91bGQgYmUgWzI3LCAyOF0gZm9yIGB2YFxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20obmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQodikucGx1cygyNykudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gICAgfVxuICAgIC8vIFdlIHdpbGwgdXNlIEVJUDE1NSBpbiBtb3N0IGNhc2VzLiBDb252ZXJ0IHYgdG8gYSBiaWdudW0gYW5kIG9wZXJhdGUgb24gaXQuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBwcm90b2NvbCBjYWxscyBmb3IgdiA9IChDSEFJTl9JRCoyKSArIDM1LzM2LCB3aGVyZSAzNSBvciAzNlxuICAgIC8vIGlzIGRlY2lkZWQgb24gYmFzZWQgb24gdGhlIGVjcmVjb3ZlciByZXN1bHQuIGB2YCBpcyBwYXNzZWQgaW4gYXMgZWl0aGVyIDAgb3IgMVxuICAgIC8vIHNvIHdlIGFkZCAzNSB0byB0aGF0LlxuICAgIHZhciBjaGFpbklkQnVmID0gZ2V0Q2hhaW5JZEJ1ZihjaGFpbklkKTtcbiAgICB2YXIgY2hhaW5JZEJOID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoY2hhaW5JZEJ1Zi50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKFwiMHhcIi5jb25jYXQoY2hhaW5JZEJOLnRpbWVzKDIpLnBsdXMoMzUpLnBsdXModikudG9TdHJpbmcoMTYpKSk7XG59XG52YXIgY2hhaW5JZHMgPSB7XG4gICAgbWFpbm5ldDogMSxcbiAgICByb3B0c3RlbjogMyxcbiAgICByaW5rZWJ5OiA0LFxuICAgIGtvdmFuOiA0MixcbiAgICBnb2VybGk6IDUsXG59O1xuLy8gR2V0IGEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGNoYWluSWQgdmFsdWUuXG4vLyBSZXR1cm5zIGEgMSwgMiwgNCwgb3IgOCBieXRlIGJ1ZmZlciB3aXRoIHRoZSBjaGFpbklkIGVuY29kZWQgaW4gYmlnIGVuZGlhblxuZnVuY3Rpb24gZ2V0Q2hhaW5JZEJ1ZihjaGFpbklkKSB7XG4gICAgdmFyIGI7XG4gICAgLy8gSWYgb3VyIGNoYWluSUQgaXMgYSBoZXggc3RyaW5nLCB3ZSBjYW4gY29udmVydCBpdCB0byBhIGhleFxuICAgIC8vIGJ1ZmZlciBkaXJlY3RseVxuICAgIGlmICh0cnVlID09PSBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihjaGFpbklkKSlcbiAgICAgICAgYiA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShjaGFpbklkKTtcbiAgICAvLyBJZiBvdXIgY2hhaW5JRCBpcyBhIGJhc2UtMTAgbnVtYmVyLCBwYXJzZSB3aXRoIGJpZ251bWJlci5qcyBhbmQgY29udmVydCB0byBoZXggYnVmZmVyXG4gICAgZWxzZVxuICAgICAgICBiID0gKDAsIHV0aWxfMS5lbnN1cmVIZXhCdWZmZXIpKFwiMHhcIi5jb25jYXQobmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoY2hhaW5JZCkudG9TdHJpbmcoMTYpKSk7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBidWZmZXIgaXMgYW4gYWxsb3dlZCBzaXplXG4gICAgaWYgKGIubGVuZ3RoID4gOClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbklEIHByb3ZpZGVkIGlzIHRvbyBsYXJnZS4nKTtcbiAgICAvLyBJZiB0aGlzIG1hdGNoZXMgYSB1MTYsIHUzMiwgb3IgdTY0IHNpemUsIHJldHVybiBpdCBub3dcbiAgICBpZiAoYi5sZW5ndGggPD0gMiB8fCBiLmxlbmd0aCA9PT0gNCB8fCBiLmxlbmd0aCA9PT0gOClcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgLy8gRm9yIG90aGVyIHNpemUgYnVmZmVycywgd2UgbmVlZCB0byBwYWNrIGludG8gdTMyIG9yIHU2NCBiZWZvcmUgcmV0dXJuaW5nO1xuICAgIHZhciBidWY7XG4gICAgaWYgKGIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoY2hhaW5JZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIubGVuZ3RoIDw9IDgpIHtcbiAgICAgICAgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICBiLmNvcHkoYnVmLCA4IC0gYi5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuLy8gRGV0ZXJtaW5lIGlmIHRoZSBjaGFpbiB1c2VzIEVJUDE1NSBieSBkZWZhdWx0LCBiYXNlZCBvbiB0aGUgY2hhaW5JRFxuZnVuY3Rpb24gY2hhaW5Vc2VzRUlQMTU1KGNoYWluSUQpIHtcbiAgICBzd2l0Y2ggKGNoYWluSUQpIHtcbiAgICAgICAgY2FzZSAzOiAvLyByb3BzdGVuXG4gICAgICAgIGNhc2UgNDogLy8gcmlua2VieVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIDE6IC8vIG1haW5uZXRcbiAgICAgICAgY2FzZSA0MjogLy8ga292YW5cbiAgICAgICAgY2FzZSA1OiAvLyBnb2VybGlcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGFsbCBvdGhlcnMgc2hvdWxkIHVzZSBlaXAxNTVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIERldGVybWluZSBpZiBhIHZhbGlkIG51bWJlciB3YXMgcGFzc2VkIGluIGFzIGEgaGV4IHN0cmluZ1xuZnVuY3Rpb24gaXNWYWxpZENoYWluSWRIZXhOdW1TdHIocykge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocy5zbGljZSgwLCAyKSAhPT0gJzB4JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBiID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQocywgMTYpO1xuICAgICAgICByZXR1cm4gYi5pc05hTigpID09PSBmYWxzZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8gSWYgdGhpcyBpcyBhIG51Ym1lciB0aGF0IGZpdHMgaW4gb25lIGJ5dGUsIHdlIGRvbid0IG5lZWQgdG8gYWRkIGl0XG4vLyB0byB0aGUgYGRhdGFgIGJ1ZmZlciBvZiB0aGUgbWFpbiB0cmFuc2FjdGlvbi5cbi8vIE5vdGUgdGhlIG9uZSBlZGdlIGNhc2U6IHdlIHN0aWxsIG5lZWQgdG8gdXNlIHRoZSBgZGF0YWAgZmllbGQgZm9yIGNoYWluSUQ9MjU1LlxuZnVuY3Rpb24gdXNlQ2hhaW5JZEJ1ZmZlcihpZCkge1xuICAgIHZhciBidWYgPSBnZXRDaGFpbklkQnVmKGlkKTtcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDgoMCkgPT09IDI1NTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGVyc29uYWxTaWduUmVxdWVzdChyZXEsIGlucHV0KSB7XG4gICAgdmFyIE1BWF9CQVNFX01TR19TWiA9IGlucHV0LmZ3Q29uc3RhbnRzLmV0aE1heE1zZ1N6O1xuICAgIHZhciBWQVJfUEFUSF9TWiA9IGlucHV0LmZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkO1xuICAgIHZhciBMID0gMjQgKyBNQVhfQkFTRV9NU0dfU1ogKyA0O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHJlcS5wYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKEwpO1xuICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDgoY29uc3RhbnRzXzEuZXRoTXNnUHJvdG9jb2wuU0lHTl9QRVJTT05BTCwgMCk7XG4gICAgb2ZmICs9IDE7XG4gICAgLy8gV3JpdGUgdGhlIHNpZ25lciBwYXRoIGludG8gdGhlIGJ1ZmZlclxuICAgIHZhciBzaWduZXJQYXRoQnVmID0gKDAsIHV0aWxfMS5idWlsZFNpZ25lclBhdGhCdWYpKGlucHV0LnNpZ25lclBhdGgsIFZBUl9QQVRIX1NaKTtcbiAgICBzaWduZXJQYXRoQnVmLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuICAgIC8vIFdyaXRlIHRoZSBwYXlsb2FkIGJ1ZmZlci4gVGhlIHBheWxvYWQgY2FuIGNvbWUgaW4gZWl0aGVyIGFzIGEgYnVmZmVyIG9yIGFzIGEgc3RyaW5nXG4gICAgdmFyIHBheWxvYWQgPSBpbnB1dC5wYXlsb2FkO1xuICAgIC8vIERldGVybWluZSBpZiB0aGlzIGlzIGEgaGV4IHN0cmluZ1xuICAgIHZhciBkaXNwbGF5SGV4ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5wYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaW5wdXQucGF5bG9hZC5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcGF5bG9hZCA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShpbnB1dC5wYXlsb2FkKTtcbiAgICAgICAgICAgIGRpc3BsYXlIZXggPVxuICAgICAgICAgICAgICAgIGZhbHNlID09PVxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5BU0NJSV9SRUdFWC50ZXN0KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGlucHV0LnBheWxvYWQuc2xpY2UoMiksICdoZXgnKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gKDAsIHV0aWxfMS5pc0FzY2lpU3RyKShpbnB1dC5wYXlsb2FkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnRseSwgdGhlIExhdHRpY2UgY2FuIG9ubHkgZGlzcGxheSBBU0NJSSBzdHJpbmdzLicpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGlucHV0LnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5kaXNwbGF5SGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGJ1ZmZlciBhbmQgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCB3aGV0aGVyIG9yIG5vdCB0aGlzXG4gICAgICAgIC8vIGlzIGEgaGV4IGJ1ZmZlciB3aXRoIHRoZSBvcHRpb25hbCBhcmd1bWVudCwgd3JpdGUgdGhhdFxuICAgICAgICBkaXNwbGF5SGV4ID0gaW5wdXQuZGlzcGxheUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgZGV0ZXJtaW5lIGlmIHRoaXMgYnVmZmVyIGlzIGFuIEFTQ0lJIHN0cmluZy4gSWYgaXQgaXMsIHNldCBgZGlzcGxheUhleGAgYWNjb3JkaW5nbHkuXG4gICAgICAgIC8vIE5PVEU6IFRISVMgTUVBTlMgVEhBVCBOT04tQVNDSUkgU1RSSU5HUyBXSUxMIERJU1BMQVkgQVMgSEVYIFNJTkNFIFdFIENBTk5PVCBLTk9XIElGIFRIRSBSRVFVRVNURVJcbiAgICAgICAgLy8gICAgICAgIEVYUEVDVEVEIE5PTi1BU0NJSSBDSEFSQUNURVJTIFRPIERJU1BMQVkgSU4gQSBTVFJJTkdcbiAgICAgICAgLy8gVE9ETzogRGV2ZWxvcCBhIG1vcmUgZWxlZ2FudCBzb2x1dGlvbiBmb3IgdGhpc1xuICAgICAgICBpZiAoIWlucHV0LnBheWxvYWQudG9TdHJpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IGRhdGEgdHlwZScpO1xuICAgICAgICBkaXNwbGF5SGV4ID0gZmFsc2UgPT09IGNvbnN0YW50c18xLkFTQ0lJX1JFR0VYLnRlc3QoaW5wdXQucGF5bG9hZC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdmFyIGZ3Q29uc3QgPSBpbnB1dC5md0NvbnN0YW50cztcbiAgICB2YXIgbWF4U3pBbGxvd2VkID0gTUFYX0JBU0VfTVNHX1NaICsgZndDb25zdC5leHRyYURhdGFNYXhGcmFtZXMgKiBmd0NvbnN0LmV4dHJhRGF0YUZyYW1lU3o7XG4gICAgaWYgKGZ3Q29uc3QucGVyc29uYWxTaWduSGVhZGVyU3opIHtcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlIHBlcnNvbmFsX3NpZ24gaGVhZGVyIHN0cmluZ1xuICAgICAgICBtYXhTekFsbG93ZWQgLT0gZndDb25zdC5wZXJzb25hbFNpZ25IZWFkZXJTejtcbiAgICB9XG4gICAgaWYgKGZ3Q29uc3QuZXRoTXNnUHJlSGFzaEFsbG93ZWQgJiYgcGF5bG9hZC5sZW5ndGggPiBtYXhTekFsbG93ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBtZXNzYWdlIHdpbGwgbm90IGZpdCBhbmQgcHJlLWhhc2hpbmcgaXMgYWxsb3dlZCwgZG8gdGhhdFxuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KGRpc3BsYXlIZXgsIG9mZik7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgdmFyIHByZWhhc2ggPSBidWZmZXJfMS5CdWZmZXIuZnJvbSgoMCwganNfc2hhM18xLmtlY2NhazI1NikoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbZ2V0X3BlcnNvbmFsX3NpZ25fcHJlZml4KHBheWxvYWQubGVuZ3RoKSwgcGF5bG9hZF0pKSwgJ2hleCcpO1xuICAgICAgICBwcmVoYXNoLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgICAgIHJlcS5wcmVoYXNoID0gcHJlaGFzaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gZml0IHRoZSBwYXlsb2FkLlxuICAgICAgICAvLyBGbG93IGRhdGEgaW50byBleHRyYURhdGEgcmVxdWVzdHMsIHdoaWNoIHdpbGwgZm9sbG93LXVwIHRyYW5zYWN0aW9uIHJlcXVlc3RzLCBpZiBzdXBwb3J0ZWQvYXBwbGljYWJsZVxuICAgICAgICB2YXIgZXh0cmFEYXRhUGF5bG9hZHMgPSBnZXRFeHRyYURhdGEocGF5bG9hZCwgaW5wdXQpO1xuICAgICAgICAvLyBXcml0ZSB0aGUgcGF5bG9hZCBhbmQgbWV0YWRhdGEgaW50byBvdXIgYnVmZmVyXG4gICAgICAgIHJlcS5leHRyYURhdGFQYXlsb2FkcyA9IGV4dHJhRGF0YVBheWxvYWRzO1xuICAgICAgICByZXEubXNnID0gcGF5bG9hZDtcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50OChkaXNwbGF5SGV4LCBvZmYpO1xuICAgICAgICBvZmYgKz0gMTtcbiAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIHBheWxvYWQuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRUlQNzEyUmVxdWVzdChyZXEsIGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIF9hID0gaW5wdXQuZndDb25zdGFudHMsIGV0aE1heE1zZ1N6ID0gX2EuZXRoTWF4TXNnU3osIHZhckFkZHJQYXRoU3pBbGxvd2VkID0gX2EudmFyQWRkclBhdGhTekFsbG93ZWQsIGVpcDcxMk1heFR5cGVQYXJhbXNfMSA9IF9hLmVpcDcxMk1heFR5cGVQYXJhbXM7XG4gICAgICAgIHZhciBUWVBFRF9EQVRBID0gY29uc3RhbnRzXzEuZXRoTXNnUHJvdG9jb2wuVFlQRURfREFUQTtcbiAgICAgICAgdmFyIEwgPSAyNCArIGV0aE1heE1zZ1N6ICsgNDtcbiAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgIHJlcS5wYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKEwpO1xuICAgICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KFRZUEVEX0RBVEEuZW51bUlkeCwgMCk7XG4gICAgICAgIG9mZiArPSAxO1xuICAgICAgICAvLyBXcml0ZSB0aGUgc2lnbmVyIHBhdGhcbiAgICAgICAgdmFyIHNpZ25lclBhdGhCdWYgPSAoMCwgdXRpbF8xLmJ1aWxkU2lnbmVyUGF0aEJ1ZikoaW5wdXQuc2lnbmVyUGF0aCwgdmFyQWRkclBhdGhTekFsbG93ZWQpO1xuICAgICAgICBzaWduZXJQYXRoQnVmLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgICAgIG9mZiArPSBzaWduZXJQYXRoQnVmLmxlbmd0aDtcbiAgICAgICAgLy8gUGFyc2UvY2xlYW4gdGhlIEVJUDcxMiBwYXlsb2FkLCBzZXJpYWxpemUgd2l0aCBDQk9SLCBhbmQgd3JpdGUgdG8gdGhlIHBheWxvYWRcbiAgICAgICAgdmFyIGRhdGFfMSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQucGF5bG9hZCkpO1xuICAgICAgICBpZiAoIWRhdGFfMS5wcmltYXJ5VHlwZSB8fCAhZGF0YV8xLnR5cGVzW2RhdGFfMS5wcmltYXJ5VHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaW1hcnlUeXBlIG11c3QgYmUgc3BlY2lmaWVkIGFuZCB0aGUgdHlwZSBtdXN0IGJlIGluY2x1ZGVkLicpO1xuICAgICAgICBpZiAoIWRhdGFfMS5tZXNzYWdlIHx8ICFkYXRhXzEuZG9tYWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIGFuZCBkb21haW4gbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGlmICgwID4gT2JqZWN0LmtleXMoZGF0YV8xLnR5cGVzKS5pbmRleE9mKCdFSVA3MTJEb21haW4nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQNzEyRG9tYWluIHR5cGUgbXVzdCBiZSBkZWZpbmVkLicpO1xuICAgICAgICAvLyBQYXJzZSB0aGUgcGF5bG9hZCB0byBlbnN1cmUgd2UgaGF2ZSB2YWxpZCBFSVA3MTIgZGF0YSB0eXBlcyBhbmQgdGhhdFxuICAgICAgICAvLyB0aGV5IGFyZSBlbmNvZGVkIHN1Y2ggdGhhdCBMYXR0aWNlIGZpcm13YXJlIGNhbiBwYXJzZSB0aGVtLlxuICAgICAgICAvLyBXZSBuZWVkIHR3byBkaWZmZXJlbnQgZW5jb2RpbmdzOiBvbmUgdG8gc2VuZCB0byB0aGUgTGF0dGljZSBpbiBhIGZvcm1hdCB0aGF0IHBsYXlzXG4gICAgICAgIC8vIG5pY2VseSB3aXRoIG91ciBmaXJtd2FyZSBDQk9SIGRlY29kZXIuIFRoZSBvdGhlciBpcyBmb3JtYXR0ZWQgdG8gYmUgY29uc3VtYWJsZSBieVxuICAgICAgICAvLyBvdXIgRUlQNzEyIHZhbGlkYXRpb24gbW9kdWxlLlxuICAgICAgICBpbnB1dC5wYXlsb2FkLm1lc3NhZ2UgPSBwYXJzZUVJUDcxMk1zZyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGFfMS5tZXNzYWdlKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YV8xLnByaW1hcnlUeXBlKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YV8xLnR5cGVzKSksIHRydWUpO1xuICAgICAgICBpbnB1dC5wYXlsb2FkLmRvbWFpbiA9IHBhcnNlRUlQNzEyTXNnKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YV8xLmRvbWFpbikpLCAnRUlQNzEyRG9tYWluJywgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhXzEudHlwZXMpKSwgdHJ1ZSk7XG4gICAgICAgIGRhdGFfMS5kb21haW4gPSBwYXJzZUVJUDcxMk1zZyhkYXRhXzEuZG9tYWluLCAnRUlQNzEyRG9tYWluJywgZGF0YV8xLnR5cGVzLCBmYWxzZSk7XG4gICAgICAgIGRhdGFfMS5tZXNzYWdlID0gcGFyc2VFSVA3MTJNc2coZGF0YV8xLm1lc3NhZ2UsIGRhdGFfMS5wcmltYXJ5VHlwZSwgZGF0YV8xLnR5cGVzLCBmYWxzZSk7XG4gICAgICAgIC8vIE5vdyBidWlsZCB0aGUgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBMYXR0aWNlXG4gICAgICAgIHZhciBwYXlsb2FkID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oYm9yY18xLmRlZmF1bHQuZW5jb2RlKGRhdGFfMSkpO1xuICAgICAgICB2YXIgZndDb25zdCA9IGlucHV0LmZ3Q29uc3RhbnRzO1xuICAgICAgICB2YXIgbWF4U3pBbGxvd2VkID0gZXRoTWF4TXNnU3ogKyBmd0NvbnN0LmV4dHJhRGF0YU1heEZyYW1lcyAqIGZ3Q29uc3QuZXh0cmFEYXRhRnJhbWVTejtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlaGFzaFxuICAgICAgICB2YXIgc2hvdWxkUHJlaGFzaF8xID0gcGF5bG9hZC5sZW5ndGggPiBtYXhTekFsbG93ZWQ7XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGFfMS50eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGRhdGFfMS50eXBlc1trXS5sZW5ndGggPiBlaXA3MTJNYXhUeXBlUGFyYW1zXzEpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRQcmVoYXNoXzEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZ3Q29uc3QuZXRoTXNnUHJlSGFzaEFsbG93ZWQgJiYgc2hvdWxkUHJlaGFzaF8xKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBheWxvYWQgaXMgdG9vIGxhcmdlIHRvIHNlbmQsIGJ1dCB0aGUgTGF0dGljZSBhbGxvd3MgYSBwcmVoYXNoZWQgbWVzc2FnZSwgZG8gdGhhdFxuICAgICAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAyO1xuICAgICAgICAgICAgdmFyIHByZWhhc2ggPSBldGhfZWlwNzEyX3V0aWxfYnJvd3Nlcl8xLlR5cGVkRGF0YVV0aWxzLmhhc2gocmVxLmlucHV0LnBheWxvYWQpO1xuICAgICAgICAgICAgcHJlaGFzaC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgcmVxLnByZWhhc2ggPSBwcmVoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dHJhRGF0YVBheWxvYWRzID0gZ2V0RXh0cmFEYXRhKHBheWxvYWQsIGlucHV0KTtcbiAgICAgICAgICAgIHJlcS5leHRyYURhdGFQYXlsb2FkcyA9IGV4dHJhRGF0YVBheWxvYWRzO1xuICAgICAgICAgICAgcmVxLnBheWxvYWQud3JpdGVVSW50MTZMRShwYXlsb2FkLmxlbmd0aCwgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSAyO1xuICAgICAgICAgICAgcGF5bG9hZC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IHBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gU2xpY2Ugb3V0IHRoZSBwYXJ0IG9mIHRoZSBidWZmZXIgdGhhdCB3ZSBkaWRuJ3QgdXNlLlxuICAgICAgICAgICAgcmVxLnBheWxvYWQgPSByZXEucGF5bG9hZC5zbGljZSgwLCBvZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBcIkZhaWxlZCB0byBidWlsZCBFSVA3MTIgcmVxdWVzdDogXCIuY29uY2F0KGVyci5tZXNzYWdlKSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEV4dHJhRGF0YShwYXlsb2FkLCBpbnB1dCkge1xuICAgIHZhciBfYSA9IGlucHV0LmZ3Q29uc3RhbnRzLCBldGhNYXhNc2dTeiA9IF9hLmV0aE1heE1zZ1N6LCBleHRyYURhdGFGcmFtZVN6ID0gX2EuZXh0cmFEYXRhRnJhbWVTeiwgZXh0cmFEYXRhTWF4RnJhbWVzID0gX2EuZXh0cmFEYXRhTWF4RnJhbWVzO1xuICAgIHZhciBNQVhfQkFTRV9NU0dfU1ogPSBldGhNYXhNc2dTejtcbiAgICB2YXIgRVhUUkFfREFUQV9BTExPV0VEID0gZXh0cmFEYXRhRnJhbWVTeiA+IDAgJiYgZXh0cmFEYXRhTWF4RnJhbWVzID4gMDtcbiAgICB2YXIgZXh0cmFEYXRhUGF5bG9hZHMgPSBbXTtcbiAgICBpZiAocGF5bG9hZC5sZW5ndGggPiBNQVhfQkFTRV9NU0dfU1opIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpemVzIGFuZCBydW4gdGhyb3VnaCBzYW5pdHkgY2hlY2tzXG4gICAgICAgIHZhciBtYXhTekFsbG93ZWQgPSBNQVhfQkFTRV9NU0dfU1ogKyBleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6O1xuICAgICAgICBpZiAoIUVYVFJBX0RBVEFfQUxMT1dFRClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgbWVzc2FnZSBpcyBcIi5jb25jYXQocGF5bG9hZC5sZW5ndGgsIFwiIGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mIFwiKS5jb25jYXQoTUFYX0JBU0VfTVNHX1NaKSk7XG4gICAgICAgIGVsc2UgaWYgKEVYVFJBX0RBVEFfQUxMT1dFRCAmJiBwYXlsb2FkLmxlbmd0aCA+IG1heFN6QWxsb3dlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgbWVzc2FnZSBpcyBcIi5jb25jYXQocGF5bG9hZC5sZW5ndGgsIFwiIGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mIFwiKS5jb25jYXQobWF4U3pBbGxvd2VkKSk7XG4gICAgICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgICAgIHZhciBmcmFtZXNfMiA9ICgwLCB1dGlsXzEuc3BsaXRGcmFtZXMpKHBheWxvYWQuc2xpY2UoTUFYX0JBU0VfTVNHX1NaKSwgZXh0cmFEYXRhRnJhbWVTeik7XG4gICAgICAgIGZyYW1lc18yLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3pMRSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICAgIHN6TEUud3JpdGVVSW50MzJMRShmcmFtZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgZXh0cmFEYXRhUGF5bG9hZHMucHVzaChidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtzekxFLCBmcmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBleHRyYURhdGFQYXlsb2Fkcztcbn1cbmZ1bmN0aW9uIHBhcnNlRUlQNzEyTXNnKG1zZywgdHlwZU5hbWUsIHR5cGVzLCBmb3JKU1BhcnNlcikge1xuICAgIGlmIChmb3JKU1BhcnNlciA9PT0gdm9pZCAwKSB7IGZvckpTUGFyc2VyID0gZmFsc2U7IH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICAgICAgdHlwZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaXNBcnJheVR5cGUgPSBpdGVtLnR5cGUuaW5kZXhPZignWycpID4gLTE7XG4gICAgICAgICAgICB2YXIgc2luZ3VsYXJUeXBlID0gaXNBcnJheVR5cGVcbiAgICAgICAgICAgICAgICA/IGl0ZW0udHlwZS5zbGljZSgwLCBpdGVtLnR5cGUuaW5kZXhPZignWycpKVxuICAgICAgICAgICAgICAgIDogaXRlbS50eXBlO1xuICAgICAgICAgICAgdmFyIGlzQ3VzdG9tVHlwZSA9IE9iamVjdC5rZXlzKHR5cGVzKS5pbmRleE9mKHNpbmd1bGFyVHlwZSkgPiAtMTtcbiAgICAgICAgICAgIGlmIChpc0N1c3RvbVR5cGUgJiYgQXJyYXkuaXNBcnJheShtc2cpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGN1c3RvbSB0eXBlcyB3ZSBuZWVkIHRvIGp1bXAgaW50byB0aGUgYG1zZ2AgdXNpbmcgdGhlIGtleSAobmFtZSBvZiB0eXBlKSBhbmRcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGF0IGVudGlyZSBzdWItc3RydWN0IGFzIGlmIGl0IHdlcmUgYSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmVjdXJzZSBpbnRvIHN1Yi1zdHJ1Y3RzIHVudGlsIHdlIHJlYWNoIGEgbGV2ZWwgd2hlcmUgZXZlcnkgaXRlbSBpcyBhblxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRhcnkgKGkuZS4gbm9uLWN1c3RvbSkgdHlwZS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgYXJyYXlzLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBlYWNoIG1lc3NhZ2UgaXRlbS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtc2dbaV1baXRlbS5uYW1lXSA9IHBhcnNlRUlQNzEyTXNnKG1zZ1tpXVtpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIHR5cGVzLCBmb3JKU1BhcnNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDdXN0b21UeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGFuIGFycmF5IG1lYW5zIHdlIGNhbiBqdW1wIGRpcmVjdGx5IGludG8gdGhlIHN1Yi1zdHJ1Y3QgdG8gY29udmVydFxuICAgICAgICAgICAgICAgIG1zZ1tpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJNc2cobXNnW2l0ZW0ubmFtZV0sIHNpbmd1bGFyVHlwZSwgdHlwZXMsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYXJyYXkgZm9yIHRoaXMgcGFydGljdWxhciB0eXBlIGFuZCB0aGUgdHlwZSB3ZSBhcmUgcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIGlzICpub3QqIGEgY3VzdG9tIHR5cGUsIGxvb3AgdGhyb3VnaCB0aGUgYXJyYXkgZWxlbWVudHMgYW5kIGNvbnZlcnQgdGhlIHR5cGVzLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB0eXBlIGlzIGl0c2VsZiBhbiBhcnJheSwgbG9vcCB0aHJvdWdoIHRob3NlIGVsZW1lbnRzIGFuZCBwYXJzZSBpbmRpdmlkdWFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgbm90IHJlYWNoYWJsZSBmb3IgY3VzdG9tIHR5cGVzIHNvIHdlIGFzc3VtZSB0aGVzZSBhcmUgYXJyYXlzIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50YXJ5IHR5cGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtc2dbaV1baXRlbS5uYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tpXVtpdGVtLm5hbWVdW2pdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpXVtpdGVtLm5hbWVdW2pdLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1hcnJheXMgcGFyc2UgKyByZXBsYWNlIG9uZSB2YWx1ZSBmb3IgdGhlIGVsZW1lbnRhcnkgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ldW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2ldW2l0ZW0ubmFtZV0sIHNpbmd1bGFyVHlwZSwgZm9ySlNQYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGVsZW1lbnRhcnkgYXJyYXkgdHlwZSBhbmQgYSBub24tYXJyYXkgbWVzc2FnZSBsZXZlbCxcbiAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCB0aGUgYXJyYXkgYW5kIHBhcnNlICsgcmVwbGFjZSAgZWFjaCBpdGVtIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZ1tpdGVtLm5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ1tpdGVtLm5hbWVdW2ldID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpdGVtLm5hbWVdW2ldLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc2luZ3VsYXIgZWxlbWVudGFyeSB0eXBlLCBzaW1wbHkgcGFyc2UgKyByZXBsYWNlLlxuICAgICAgICAgICAgICAgIG1zZ1tpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIGZvckpTUGFyc2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIHBhcnNlRUlQNzEySXRlbShkYXRhLCB0eXBlLCBmb3JKU1BhcnNlcikge1xuICAgIGlmIChmb3JKU1BhcnNlciA9PT0gdm9pZCAwKSB7IGZvckpTUGFyc2VyID0gZmFsc2U7IH1cbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAvLyBWYXJpYWJsZSBzaXplZCBieXRlcyBuZWVkIHRvIGJlIGJ1ZmZlciB0eXBlXG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgICAgICBkYXRhID0gXCIweFwiLmNvbmNhdChkYXRhLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zbGljZSgwLCA1KSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAvLyBGaXhlZCBzaXplcyBieXRlcyBuZWVkIHRvIGJlIGJ1ZmZlciB0eXBlLiBXZSBhbHNvIGFkZCBzb21lIHNhbml0eSBjaGVja3MuXG4gICAgICAgIHZhciBuQnl0ZXMgPSBwYXJzZUludCh0eXBlLnNsaWNlKDUpKTtcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyKShkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBuQnl0ZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQodHlwZSwgXCIgdHlwZSwgYnV0IGdvdCBcIikuY29uY2F0KGRhdGEubGVuZ3RoLCBcIiBieXRlc1wiKSk7XG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgICAgICBkYXRhID0gXCIweFwiLmNvbmNhdChkYXRhLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIC8vIEFkZHJlc3MgbXVzdCBiZSBhIDIwIGJ5dGUgYnVmZmVyXG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSB0byBoYW5kbGUgdGhlIDAtYWRkcmVzc1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMjApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMjApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIHR5cGUgbXVzdCBiZSAyMCBieXRlcywgYnV0IGdvdCBcIi5jb25jYXQoZGF0YS5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcbiAgICAgICAgLy8gRm9yIEVJUDcxMiBlbmNvZGluZyBtb2R1bGUgaXQncyBlYXNpZXIgdG8gZW5jb2RlIGhleCBzdHJpbmdzXG4gICAgICAgIGlmIChmb3JKU1BhcnNlcikge1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoZGF0YS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnN0YW50c18xLmV0aE1zZ1Byb3RvY29sLlRZUEVEX0RBVEEudHlwZUNvZGVzW3R5cGVdICYmXG4gICAgICAgICh0eXBlLmluZGV4T2YoJ3VpbnQnKSA+IC0xIHx8IHR5cGUuaW5kZXhPZignaW50JykgPiAtMSkpIHtcbiAgICAgICAgdmFyIGIgPSAoMCwgdXRpbF8xLmVuc3VyZUhleEJ1ZmZlcikoZGF0YSk7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSB0byBoYW5kbGUgMC12YWx1ZSBiaWdudW1zXG4gICAgICAgIGlmIChiLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVaW50MjU2cyBzaG91bGQgYmUgZW5jb2RlZCBhcyBiaWdudW1zLlxuICAgICAgICBpZiAoZm9ySlNQYXJzZXIpIHtcbiAgICAgICAgICAgIC8vIEZvciBFSVA3MTIgZW5jb2RpbmcgaW4gdGhpcyBtb2R1bGUgd2UgbmVlZCBzdHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyc1xuICAgICAgICAgICAgZGF0YSA9IFwiMHhcIi5jb25jYXQoYi50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYGJpZ251bWJlci5qc2AgaXMgbmVlZGVkIGZvciBgY2JvcmAgZW5jb2RpbmcsIHdoaWNoIGdldHMgc2VudCB0byB0aGUgTGF0dGljZSBhbmQgcGxheXNcbiAgICAgICAgICAgIC8vIG5pY2VseSB3aXRoIGl0cyBmaXJtd2FyZSBjYm9yIGxpYi5cbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHdlIGluc3RhbnRpYXRlIGEgYGJpZ251bWJlci5qc2Agb2JqZWN0LCBpdCB3aWxsIG5vdCBtYXRjaCB3aGF0IGBib3JjYCBjcmVhdGVzXG4gICAgICAgICAgICAvLyB3aGVuIHJ1biBpbnNpZGUgb2YgdGhlIGJyb3dzZXIgKGkuZS4gTWV0YU1hc2spLiBUaHVzIHdlIGludHJvZHVjZSB0aGlzIGhhY2sgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgICAvLyB3ZSBhcmUgY3JlYXRpbmcgYSBjb21wYXRpYmxlIHR5cGUuXG4gICAgICAgICAgICAvLyBUT0RPOiBGaW5kIGFub3RoZXIgY2JvciBsaWIgdGhhdCBpcyBjb21wYXRhaWJsZSB3aXRoIHRoZSBmaXJtd2FyZSdzIGxpYiBpbiBhIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaXMgc3VycHJpc2luZ2x5IGRpZmZpY3VsdCAtIEkgdHJpZWQgc2V2ZXJhbCBsaWJzIGFuZCBvbmx5IGNib3IvYm9yYyBoYXZlXG4gICAgICAgICAgICAvLyB3b3JrZWQgKGJvcmMgaXMgYSBzdXBwb3NlZGx5IFwiYnJvd3NlciBjb21wYXRpYmxlXCIgdmVyc2lvbiBvZiBjYm9yKVxuICAgICAgICAgICAgZGF0YSA9IG5ldyBib3JjXzEuZGVmYXVsdC5FbmNvZGVyKCkuc2VtYW50aWNUeXBlc1sxXVswXShiLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAvLyBCb29sZWFucyBuZWVkIHRvIGJlIGNhc3QgdG8gYSB1OFxuICAgICAgICBkYXRhID0gZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgIH1cbiAgICAvLyBPdGhlciB0eXBlcyBkb24ndCBuZWVkIHRvIGJlIG1vZGlmaWVkXG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBnZXRfcGVyc29uYWxfc2lnbl9wcmVmaXgoTCkge1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShcIlxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIi5jb25jYXQoTC50b1N0cmluZygpKSwgJ3V0Zi04Jyk7XG59XG5mdW5jdGlvbiBnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UocmF3VHgsIHR4VHlwZSkge1xuICAgIGlmICh0eFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2J1ZmZlcl8xLkJ1ZmZlci5mcm9tKFt0eFR5cGVdKSwgcmxwX2Jyb3dzZXJfMS5kZWZhdWx0LmVuY29kZShyYXdUeCldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBybHBfYnJvd3Nlcl8xLmRlZmF1bHQuZW5jb2RlKHJhd1R4KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3Q6IGJ1aWxkRXRoZXJldW1Nc2dSZXF1ZXN0LFxuICAgIHZhbGlkYXRlRXRoZXJldW1Nc2dSZXNwb25zZTogdmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlLFxuICAgIGJ1aWxkRXRoZXJldW1UeFJlcXVlc3Q6IGJ1aWxkRXRoZXJldW1UeFJlcXVlc3QsXG4gICAgYnVpbGRFdGhSYXdUeDogYnVpbGRFdGhSYXdUeCxcbiAgICBoYXNoVHJhbnNhY3Rpb246IGhhc2hUcmFuc2FjdGlvbixcbiAgICBjaGFpbklkczogY2hhaW5JZHMsXG4gICAgZW5zdXJlSGV4QnVmZmVyOiB1dGlsXzEuZW5zdXJlSGV4QnVmZmVyLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gVXRpbCBmb3IgQml0Y29pbi1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG52YXIgYmVjaDMyXzEgPSByZXF1aXJlKFwiYmVjaDMyXCIpO1xudmFyIGJzNThjaGVja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiczU4Y2hlY2tcIikpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG52YXIgcmlwZW1kXzEgPSByZXF1aXJlKFwiaGFzaC5qcy9saWIvaGFzaC9yaXBlbWRcIik7XG52YXIgc2hhXzEgPSByZXF1aXJlKFwiaGFzaC5qcy9saWIvaGFzaC9zaGFcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgREVGQVVMVF9TRVFVRU5DRSA9IDB4ZmZmZmZmZmY7XG52YXIgREVGQVVMVF9TSUdIQVNIX0JVRkZFUiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCcwMScsICdoZXgnKTsgLy8gU0lHSEFTSF9BTEwgPSAweDAxXG52YXIgUFVSUE9TRVMgPSBjb25zdGFudHNfMS5CSVBfQ09OU1RBTlRTLlBVUlBPU0VTLCBDT0lOUyA9IGNvbnN0YW50c18xLkJJUF9DT05TVEFOVFMuQ09JTlM7XG52YXIgT1AgPSB7XG4gICAgWkVSTzogMHgwMCxcbiAgICBIQVNIMTYwOiAweGE5LFxuICAgIERVUDogMHg3NixcbiAgICBFUVVBTDogMHg4NyxcbiAgICBFUVVBTFZFUklGWTogMHg4OCxcbiAgICBDSEVDS1NJRzogMHhhYyxcbn07XG52YXIgU0VHV0lUX1YwID0gMHgwMDtcbnZhciBTRUdXSVRfTkFUSVZFX1YwX1BSRUZJWCA9ICdiYyc7XG52YXIgU0VHV0lUX05BVElWRV9WMF9URVNUTkVUX1BSRUZJWCA9ICd0Yic7XG52YXIgRk1UX1NFR1dJVF9OQVRJVkVfVjAgPSAweGQwO1xudmFyIEZNVF9TRUdXSVRfTkFUSVZFX1YwX1RFU1RORVQgPSAweGYwO1xudmFyIEZNVF9TRUdXSVRfV1JBUFBFRCA9IDB4MDU7XG52YXIgRk1UX1NFR1dJVF9XUkFQUEVEX1RFU1RORVQgPSAweGM0O1xudmFyIEZNVF9MRUdBQ1kgPSAweDAwO1xudmFyIEZNVF9MRUdBQ1lfVEVTVE5FVCA9IDB4NmY7XG52YXIgQlRDX1NDUklQVF9UWVBFX1AyUEtIID0gMHgwMTtcbnZhciBCVENfU0NSSVBUX1RZUEVfUDJTSF9QMldQS0ggPSAweDAzO1xudmFyIEJUQ19TQ1JJUFRfVFlQRV9QMldQS0hfVjAgPSAweDA0O1xuLy8gV2UgbmVlZCB0byBidWlsZCB0d28gZGlmZmVyZW50IG9iamVjdHMgaGVyZTpcbi8vIDEuIGJpdGNvaW5qcy1saWIgVHJhbnNhY3Rpb25CdWlsZGVyIG9iamVjdCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uXG4vLyAgICB3aXRoIHRoZSByZXR1cm5lZCBzaWduYXR1cmVzIHRvIGJ1aWxkIGFuZCBzZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGJlZm9yZVxuLy8gICAgYnJvYWRjYXN0aW5nIGl0LiBXZSB3aWxsIHJlcGxhY2UgYGJpdGNvaW5qcy1saWJgJ3Mgc2lnbmF0dXJlcyB3aXRoIHRoZSBvbmVzXG4vLyAgICB3ZSBnZXQgZnJvbSB0aGUgTGF0dGljZVxuLy8gMi4gVGhlIHNlcmlhbGl6ZWQgTGF0dGljZSByZXF1ZXN0LCB3aGljaCBpbmNsdWRlcyBkYXRhIChvdXRsaW5lZCBpbiB0aGUgc3BlY2lmaWNhdGlvbilcbi8vICAgIHRoYXQgaXMgbmVlZGVkIHRvIHNpZ24gYWxsIG9mIHRoZSBpbnB1dHMgYW5kIGJ1aWxkIGEgY2hhbmdlIG91dHB1dC5cbi8vIEBpbnB1dHMgKGNvbnRhaW5lZCBpbiBgZGF0YWApXG4vLyBgcHJldk91dHNgOiBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy8gICAgICAgICAgIGEuIHR4SGFzaFxuLy8gICAgICAgICAgIGIuIHZhbHVlXG4vLyAgICAgICAgICAgYy4gaW5kZXggICAgICAgICAgLS0gdGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaW4gdGhlIHRyYW5zYWN0aW9uXG4vLyAgICAgICAgICAgZC4gc2lnbmVyUGF0aCAtLSB0aGUgcGF0aCBvZiB0aGUgYWRkcmVzcyBpbiBvdXIgd2FsbGV0IHRoYXQgaXMgc2lnbmluZyB0aGlzIGlucHV0XG4vLyBgcmVjaXBpZW50YDogUmVjZWl2aW5nIGFkZHJlc3MsIHdoaWNoIG11c3QgYmUgY29udmVydGVkIHRvIGEgcHVia2V5aGFzaFxuLy8gYHZhbHVlYDogICAgIE51bWJlciBvZiBzYXRvc2hpcyB0byBzZW5kIHRoZSByZWNpcGllbnRcbi8vIGBmZWVgOiAgICAgICBOdW1iZXIgb2Ygc2F0b3NoaXMgdG8gdXNlIGZvciBhIHRyYW5zYWN0aW9uIGZlZSAoc2hvdWxkIGhhdmUgYmVlbiBjYWxjdWxhdGVkKVxuLy8gICAgICAgICAgICAgIGFscmVhZHkgYmFzZWQgb24gdGhlIG51bWJlciBvZiBpbnB1dHMgcGx1cyB0d28gb3V0cHV0c1xuLy8gYHZlcnNpb25gOiAgIFRyYW5zYWN0aW9uIHZlcnNpb24gb2YgdGhlIGlucHV0cy4gQWxsIGlucHV0cyBtdXN0IGJlIG9mIHRoZSBzYW1lIHZlcnNpb24hXG4vLyBgaXNTZWd3aXRgOiBhIGJvb2xlYW4gd2hpY2ggZGV0ZXJtaW5lcyBob3cgd2Ugc2VyaWFsaXplIHRoZSBkYXRhIGFuZCBwYXJhbWV0ZXJpemUgdHhiXG52YXIgYnVpbGRCaXRjb2luVHhSZXF1ZXN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcHJldk91dHMgPSBkYXRhLnByZXZPdXRzLCByZWNpcGllbnQgPSBkYXRhLnJlY2lwaWVudCwgdmFsdWUgPSBkYXRhLnZhbHVlLCBjaGFuZ2VQYXRoID0gZGF0YS5jaGFuZ2VQYXRoLCBmZWUgPSBkYXRhLmZlZTtcbiAgICAgICAgaWYgKCFjaGFuZ2VQYXRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFuZ2VQYXRoIHByb3ZpZGVkLicpO1xuICAgICAgICBpZiAoY2hhbmdlUGF0aC5sZW5ndGggIT09IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgZnVsbCBjaGFuZ2UgcGF0aC4nKTtcbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSByZXF1ZXN0XG4gICAgICAgIHZhciBwYXlsb2FkXzEgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNTkgKyA2OSAqIHByZXZPdXRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBvZmZfMSA9IDA7XG4gICAgICAgIC8vIENoYW5nZSB2ZXJzaW9uIGJ5dGUgKGEuay5hLiBhZGRyZXNzIGZvcm1hdCBieXRlKVxuICAgICAgICB2YXIgY2hhbmdlRm10ID0gZ2V0QWRkcmVzc0Zvcm1hdChjaGFuZ2VQYXRoKTtcbiAgICAgICAgcGF5bG9hZF8xLndyaXRlVUludDgoY2hhbmdlRm10LCAwKTtcbiAgICAgICAgb2ZmXzErKztcbiAgICAgICAgLy8gQnVpbGQgdGhlIGNoYW5nZSBkYXRhXG4gICAgICAgIHBheWxvYWRfMS53cml0ZVVJbnQzMkxFKGNoYW5nZVBhdGgubGVuZ3RoLCBvZmZfMSk7XG4gICAgICAgIG9mZl8xICs9IDQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF5bG9hZF8xLndyaXRlVUludDMyTEUoY2hhbmdlUGF0aFtpXSwgb2ZmXzEpO1xuICAgICAgICAgICAgb2ZmXzEgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZWUgaXMgYSBwYXJhbVxuICAgICAgICBwYXlsb2FkXzEud3JpdGVVSW50MzJMRShmZWUsIG9mZl8xKTtcbiAgICAgICAgb2ZmXzEgKz0gNDtcbiAgICAgICAgdmFyIGRlYyA9IGRlY29kZUFkZHJlc3MocmVjaXBpZW50KTtcbiAgICAgICAgLy8gUGFyYW1ldGVyaXplIHRoZSByZWNpcGllbnQgb3V0cHV0XG4gICAgICAgIHBheWxvYWRfMS53cml0ZVVJbnQ4KGRlYy52ZXJzaW9uQnl0ZSwgb2ZmXzEpO1xuICAgICAgICBvZmZfMSsrO1xuICAgICAgICBkZWMucGtoLmNvcHkocGF5bG9hZF8xLCBvZmZfMSk7XG4gICAgICAgIG9mZl8xICs9IGRlYy5wa2gubGVuZ3RoO1xuICAgICAgICB3cml0ZVVJbnQ2NExFKHZhbHVlLCBwYXlsb2FkXzEsIG9mZl8xKTtcbiAgICAgICAgb2ZmXzEgKz0gODtcbiAgICAgICAgLy8gQnVpbGQgdGhlIGlucHV0cyBmcm9tIHRoZSBwcmV2aW91cyBvdXRwdXRzXG4gICAgICAgIHBheWxvYWRfMS53cml0ZVVJbnQ4KHByZXZPdXRzLmxlbmd0aCwgb2ZmXzEpO1xuICAgICAgICBvZmZfMSsrO1xuICAgICAgICB2YXIgaW5wdXRTdW1fMSA9IDA7XG4gICAgICAgIHByZXZPdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnNpZ25lclBhdGggfHwgaW5wdXQuc2lnbmVyUGF0aC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bGwgcmVjaXBpZW50IHBhdGggbm90IHNwZWNpZmllZCAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBheWxvYWRfMS53cml0ZVVJbnQzMkxFKGlucHV0LnNpZ25lclBhdGgubGVuZ3RoLCBvZmZfMSk7XG4gICAgICAgICAgICBvZmZfMSArPSA0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5zaWduZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZF8xLndyaXRlVUludDMyTEUoaW5wdXQuc2lnbmVyUGF0aFtpXSwgb2ZmXzEpO1xuICAgICAgICAgICAgICAgIG9mZl8xICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkXzEud3JpdGVVSW50MzJMRShpbnB1dC5pbmRleCwgb2ZmXzEpO1xuICAgICAgICAgICAgb2ZmXzEgKz0gNDtcbiAgICAgICAgICAgIHdyaXRlVUludDY0TEUoaW5wdXQudmFsdWUsIHBheWxvYWRfMSwgb2ZmXzEpO1xuICAgICAgICAgICAgb2ZmXzEgKz0gODtcbiAgICAgICAgICAgIGlucHV0U3VtXzEgKz0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB2YXIgc2NyaXB0VHlwZSA9IGdldFNjcmlwdFR5cGUoaW5wdXQpO1xuICAgICAgICAgICAgcGF5bG9hZF8xLndyaXRlVUludDgoc2NyaXB0VHlwZSwgb2ZmXzEpO1xuICAgICAgICAgICAgb2ZmXzErKztcbiAgICAgICAgICAgIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKGlucHV0LnR4SGFzaCkpXG4gICAgICAgICAgICAgICAgaW5wdXQudHhIYXNoID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oaW5wdXQudHhIYXNoLCAnaGV4Jyk7XG4gICAgICAgICAgICBpbnB1dC50eEhhc2guY29weShwYXlsb2FkXzEsIG9mZl8xKTtcbiAgICAgICAgICAgIG9mZl8xICs9IGlucHV0LnR4SGFzaC5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZW5kIHRoZW0gYmFjayFcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRfMSxcbiAgICAgICAgICAgIHNjaGVtYTogY29uc3RhbnRzXzEuc2lnbmluZ1NjaGVtYS5CVENfVFJBTlNGRVIsXG4gICAgICAgICAgICBvcmlnRGF0YTogZGF0YSxcbiAgICAgICAgICAgIGNoYW5nZURhdGE6IHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGRhdGEgaGVscHMgZmlsbCBpbiB0aGUgY2hhbmdlIG91dHB1dFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFN1bV8xIC0gKHZhbHVlICsgZmVlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlcnIgfTtcbiAgICB9XG59O1xuLy8gU2VyaWFsaXplIGEgdHJhbnNhY3Rpb24gY29uc2lzdGluZyBvZiBpbnB1dHMsIG91dHB1dHMsIGFuZCBzb21lXG4vLyBtZXRhZGF0YVxuLy8gLS0gaW5wdXRzICA9IHsgaGFzaCwgaW5kZXgsIHNpZywgcHVia2V5IH1cbi8vIC0tIG91dHB1dHMgPSB7IHZhbHVlLCByZWNpcGllbnQgfSAgLy8gZXhwZWN0cyBhbiBhZGRyZXNzIHN0cmluZyBmb3IgYHJlY2lwaWVudGBcbi8vIC0tIGlzU2Vnd2l0U3BlbmQgPSB0cnVlIGlmIHRoZSBpbnB1dHMgYXJlIGJlaW5nIHNwZW50IHVzaW5nIHNlZ3dpdFxuLy8gICAgICAgICAgICAgICAgICAgIChOT1RFOiBlaXRoZXIgQUxMIGFyZSBiZWluZyBzcGVudCwgb3Igbm9uZSBhcmUpXG4vLyAtLSBsb2NrVGltZSA9IFdpbGwgcHJvYmFibHkgYWx3YXlzIGJlIDBcbnZhciBzZXJpYWxpemVUeCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGlucHV0cyA9IGRhdGEuaW5wdXRzLCBvdXRwdXRzID0gZGF0YS5vdXRwdXRzLCBfYSA9IGRhdGEubG9ja1RpbWUsIGxvY2tUaW1lID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYTtcbiAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICB2YXIgb2ZmID0gMDtcbiAgICAvLyBBbHdheXMgdXNlIHZlcnNpb24gMlxuICAgIHZhciB2ZXJzaW9uID0gMjtcbiAgICB2YXIgdXNlV2l0bmVzcyA9IG5lZWRzV2l0bmVzcyhpbnB1dHMpO1xuICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSh2ZXJzaW9uLCBvZmYpO1xuICAgIG9mZiArPSA0O1xuICAgIGlmICh1c2VXaXRuZXNzKSB7XG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgYnVmZmVyXzEuQnVmZmVyLmZyb20oJzAwJywgJ2hleCcpKTsgLy8gbWFya2VyID0gMHgwMFxuICAgICAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCcwMScsICdoZXgnKSk7IC8vIGZsYWcgPSAweDAxXG4gICAgfVxuICAgIC8vIFNlcmlhbGl6ZSBzaWduZWQgaW5wdXRzXG4gICAgdmFyIG51bUlucHV0cyA9IGdldFZhckludChpbnB1dHMubGVuZ3RoKTtcbiAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIG51bUlucHV0cyk7XG4gICAgb2ZmICs9IG51bUlucHV0cy5sZW5ndGg7XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgaW5wdXQuaGFzaC5yZXZlcnNlKCkpO1xuICAgICAgICBvZmYgKz0gaW5wdXQuaGFzaC5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCA9IGdldFUzMkxFKGlucHV0LmluZGV4KTtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBpbmRleCk7XG4gICAgICAgIG9mZiArPSBpbmRleC5sZW5ndGg7XG4gICAgICAgIHZhciBzY3JpcHRUeXBlID0gZ2V0U2NyaXB0VHlwZShpbnB1dCk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBzaWdTY3JpcHQuIE5vdGUgdGhhdCBwMndwa2ggZG9lcyBub3QgaGF2ZSBhIHNjcmlwdFNpZy5cbiAgICAgICAgaWYgKHNjcmlwdFR5cGUgPT09IEJUQ19TQ1JJUFRfVFlQRV9QMlNIX1AyV1BLSCkge1xuICAgICAgICAgICAgLy8gQnVpbGQgYSB2ZWN0b3IgKHZhclNsaWNlIG9mIHZhclNsaWNlKSBjb250YWluaW5nIHRoZSByZWRlZW1TY3JpcHRcbiAgICAgICAgICAgIHZhciByZWRlZW1TY3JpcHQgPSBidWlsZFJlZGVlbVNjcmlwdChpbnB1dC5wdWJrZXkpO1xuICAgICAgICAgICAgdmFyIHJlZGVlbVNjcmlwdExlbiA9IGdldFZhckludChyZWRlZW1TY3JpcHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3JlZGVlbVNjcmlwdExlbiwgcmVkZWVtU2NyaXB0XSk7XG4gICAgICAgICAgICB2YXIgc2xpY2VMZW4gPSBnZXRWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2xpY2VMZW4pO1xuICAgICAgICAgICAgb2ZmICs9IHNsaWNlTGVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2xpY2UpO1xuICAgICAgICAgICAgb2ZmICs9IHNsaWNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JpcHRUeXBlID09PSBCVENfU0NSSVBUX1RZUEVfUDJQS0gpIHtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBzaWduYXR1cmUgKyBwdWJrZXkgc2NyaXB0IHRvIHNwZW5kIHRoaXMgaW5wdXRcbiAgICAgICAgICAgIHZhciBzbGljZSA9IGJ1aWxkU2lnKGlucHV0LnNpZywgaW5wdXQucHVia2V5KTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2xpY2UpO1xuICAgICAgICAgICAgb2ZmICs9IHNsaWNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JpcHRUeXBlID09PSBCVENfU0NSSVBUX1RZUEVfUDJXUEtIX1YwKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHlTY3JpcHQgPSBidWZmZXJfMS5CdWZmZXIuZnJvbSgnMDAnLCAnaGV4Jyk7XG4gICAgICAgICAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIGVtcHR5U2NyaXB0KTtcbiAgICAgICAgICAgIG9mZiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBzZXF1ZW5jZSBmb3IgYWxsIHRyYW5zYWN0aW9uc1xuICAgICAgICB2YXIgc2VxdWVuY2UgPSBnZXRVMzJMRShERUZBVUxUX1NFUVVFTkNFKTtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzZXF1ZW5jZSk7XG4gICAgICAgIG9mZiArPSBzZXF1ZW5jZS5sZW5ndGg7XG4gICAgfSk7XG4gICAgLy8gU2VyaWFsaXplIG91dHB1dHNcbiAgICB2YXIgbnVtT3V0cHV0cyA9IGdldFZhckludChvdXRwdXRzLmxlbmd0aCk7XG4gICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBudW1PdXRwdXRzKTtcbiAgICBvZmYgKz0gbnVtT3V0cHV0cy5sZW5ndGg7XG4gICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0VTY0TEUob3V0cHV0LnZhbHVlKTtcbiAgICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCB2YWx1ZSk7XG4gICAgICAgIG9mZiArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBvdXRwdXQgbG9ja2luZyBzY3JpcHQgYW5kIHdyaXRlIGl0IGFzIGEgdmFyIHNsaWNlXG4gICAgICAgIHZhciBzY3JpcHQgPSBidWlsZExvY2tpbmdTY3JpcHQob3V0cHV0LnJlY2lwaWVudCk7XG4gICAgICAgIHZhciBzY3JpcHRMZW4gPSBnZXRWYXJJbnQoc2NyaXB0Lmxlbmd0aCk7XG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2NyaXB0TGVuKTtcbiAgICAgICAgb2ZmICs9IHNjcmlwdExlbi5sZW5ndGg7XG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2NyaXB0KTtcbiAgICAgICAgb2ZmICs9IHNjcmlwdC5sZW5ndGg7XG4gICAgfSk7XG4gICAgLy8gQWRkIHdpdG5lc3MgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodXNlV2l0bmVzcykge1xuICAgICAgICB2YXIgc2lncyA9IFtdO1xuICAgICAgICB2YXIgcHVia2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2lncy5wdXNoKGlucHV0c1tpXS5zaWcpO1xuICAgICAgICAgICAgcHVia2V5cy5wdXNoKGlucHV0c1tpXS5wdWJrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aXRuZXNzU2xpY2UgPSBidWlsZFdpdG5lc3Moc2lncywgcHVia2V5cyk7XG4gICAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgd2l0bmVzc1NsaWNlKTtcbiAgICAgICAgb2ZmICs9IHdpdG5lc3NTbGljZS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIEZpbmlzaCB3aXRoIGxvY2t0aW1lXG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3BheWxvYWQsIGdldFUzMkxFKGxvY2tUaW1lKV0pLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vLyBDb252ZXJ0IGEgcHVia2V5aGFzaCB0byBhIGJpdGNvaW4gYmFzZTU4Y2hlY2sgYWRkcmVzcyB3aXRoIGEgdmVyc2lvbiBieXRlXG52YXIgZ2V0Qml0Y29pbkFkZHJlc3MgPSBmdW5jdGlvbiAocHVia2V5aGFzaCwgdmVyc2lvbikge1xuICAgIHZhciBiZWNoMzJQcmVmaXggPSBudWxsO1xuICAgIHZhciBiZWNoMzJWZXJzaW9uID0gbnVsbDtcbiAgICBpZiAodmVyc2lvbiA9PT0gRk1UX1NFR1dJVF9OQVRJVkVfVjApIHtcbiAgICAgICAgYmVjaDMyUHJlZml4ID0gU0VHV0lUX05BVElWRV9WMF9QUkVGSVg7XG4gICAgICAgIGJlY2gzMlZlcnNpb24gPSBTRUdXSVRfVjA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZlcnNpb24gPT09IEZNVF9TRUdXSVRfTkFUSVZFX1YwX1RFU1RORVQpIHtcbiAgICAgICAgYmVjaDMyUHJlZml4ID0gU0VHV0lUX05BVElWRV9WMF9URVNUTkVUX1BSRUZJWDtcbiAgICAgICAgYmVjaDMyVmVyc2lvbiA9IFNFR1dJVF9WMDtcbiAgICB9XG4gICAgaWYgKGJlY2gzMlByZWZpeCAhPT0gbnVsbCAmJiBiZWNoMzJWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKHB1YmtleWhhc2gpO1xuICAgICAgICB3b3Jkcy51bnNoaWZ0KGJlY2gzMlZlcnNpb24pO1xuICAgICAgICByZXR1cm4gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShiZWNoMzJQcmVmaXgsIHdvcmRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiczU4Y2hlY2tfMS5kZWZhdWx0LmVuY29kZShidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtidWZmZXJfMS5CdWZmZXIuZnJvbShbdmVyc2lvbl0pLCBwdWJrZXloYXNoXSkpO1xuICAgIH1cbn07XG4vLyBCdWlsZGVyIHV0aWxzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFJlZGVlbVNjcmlwdChwdWJrZXkpIHtcbiAgICB2YXIgcmVkZWVtU2NyaXB0ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDIyKTtcbiAgICB2YXIgc2hhSGFzaCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCBzaGFfMS5zaGEyNTYpKCkudXBkYXRlKHB1YmtleSkuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xuICAgIHZhciBwdWJrZXloYXNoID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIHJpcGVtZF8xLnJpcGVtZDE2MCkoKS51cGRhdGUoc2hhSGFzaCkuZGlnZXN0KCdoZXgnKSwgJ2hleCcpO1xuICAgIHJlZGVlbVNjcmlwdC53cml0ZVVJbnQ4KE9QLlpFUk8sIDApO1xuICAgIHJlZGVlbVNjcmlwdC53cml0ZVVJbnQ4KHB1YmtleWhhc2gubGVuZ3RoLCAxKTtcbiAgICBwdWJrZXloYXNoLmNvcHkocmVkZWVtU2NyaXB0LCAyKTtcbiAgICByZXR1cm4gcmVkZWVtU2NyaXB0O1xufVxuLy8gVmFyIHNsaWNlIG9mIHNpZ25hdHVyZSArIHZhciBzbGljZSBvZiBwdWJrZXlcbmZ1bmN0aW9uIGJ1aWxkU2lnKHNpZywgcHVia2V5KSB7XG4gICAgc2lnID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbc2lnLCBERUZBVUxUX1NJR0hBU0hfQlVGRkVSXSk7XG4gICAgdmFyIHNpZ0xlbiA9IGdldFZhckludChzaWcubGVuZ3RoKTtcbiAgICB2YXIgcHVia2V5TGVuID0gZ2V0VmFySW50KHB1YmtleS5sZW5ndGgpO1xuICAgIHZhciBzbGljZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3NpZ0xlbiwgc2lnLCBwdWJrZXlMZW4sIHB1YmtleV0pO1xuICAgIHZhciBsZW4gPSBnZXRWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbbGVuLCBzbGljZV0pO1xufVxuLy8gV2l0bmVzcyBpcyB3cml0dGVuIGFzIGEgXCJ2ZWN0b3JcIiwgd2hpY2ggaXMgYSBsaXN0IG9mIHZhclNsaWNlc1xuLy8gcHJlZml4ZWQgYnkgdGhlIG51bWJlciBvZiBpdGVtc1xuZnVuY3Rpb24gYnVpbGRXaXRuZXNzKHNpZ3MsIHB1YmtleXMpIHtcbiAgICB2YXIgd2l0bmVzcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygwKTtcbiAgICAvLyBUd28gaXRlbXMgaW4gZWFjaCB2ZWN0b3IgKHNpZywgcHVia2V5KVxuICAgIHZhciBsZW4gPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMSk7XG4gICAgbGVuLndyaXRlVUludDgoMiwgMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzaWcgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtzaWdzW2ldLCBERUZBVUxUX1NJR0hBU0hfQlVGRkVSXSk7XG4gICAgICAgIHZhciBzaWdMZW4gPSBnZXRWYXJJbnQoc2lnLmxlbmd0aCk7XG4gICAgICAgIHZhciBwdWJrZXkgPSBwdWJrZXlzW2ldO1xuICAgICAgICB2YXIgcHVia2V5TGVuID0gZ2V0VmFySW50KHB1YmtleS5sZW5ndGgpO1xuICAgICAgICB3aXRuZXNzID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbd2l0bmVzcywgbGVuLCBzaWdMZW4sIHNpZywgcHVia2V5TGVuLCBwdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpdG5lc3M7XG59XG4vLyBMb2NraW5nIHNjcmlwdCBidWlkZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZExvY2tpbmdTY3JpcHQoYWRkcmVzcykge1xuICAgIHZhciBkZWMgPSBkZWNvZGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgIHN3aXRjaCAoZGVjLnZlcnNpb25CeXRlKSB7XG4gICAgICAgIGNhc2UgRk1UX1NFR1dJVF9OQVRJVkVfVjA6XG4gICAgICAgIGNhc2UgRk1UX1NFR1dJVF9OQVRJVkVfVjBfVEVTVE5FVDpcbiAgICAgICAgICAgIHJldHVybiBidWlsZFAyd3BraExvY2tpbmdTY3JpcHQoZGVjLnBraCk7XG4gICAgICAgIGNhc2UgRk1UX1NFR1dJVF9XUkFQUEVEOlxuICAgICAgICBjYXNlIEZNVF9TRUdXSVRfV1JBUFBFRF9URVNUTkVUOlxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUDJzaExvY2tpbmdTY3JpcHQoZGVjLnBraCk7XG4gICAgICAgIGNhc2UgRk1UX0xFR0FDWTpcbiAgICAgICAgY2FzZSBGTVRfTEVHQUNZX1RFU1RORVQ6XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQMnBraExvY2tpbmdTY3JpcHQoZGVjLnBraCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHZlcnNpb24gYnl0ZTogXCIuY29uY2F0KGRlYy52ZXJzaW9uQnl0ZSwgXCIuIENhbm5vdCBidWlsZCBCVEMgdHJhbnNhY3Rpb24uXCIpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFAycGtoTG9ja2luZ1NjcmlwdChwdWJrZXloYXNoKSB7XG4gICAgdmFyIG91dCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg1ICsgcHVia2V5aGFzaC5sZW5ndGgpO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIG91dC53cml0ZVVJbnQ4KE9QLkRVUCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICBvdXQud3JpdGVVSW50OChPUC5IQVNIMTYwLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIG91dC53cml0ZVVJbnQ4KHB1YmtleWhhc2gubGVuZ3RoLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIHB1YmtleWhhc2guY29weShvdXQsIG9mZik7XG4gICAgb2ZmICs9IHB1YmtleWhhc2gubGVuZ3RoO1xuICAgIG91dC53cml0ZVVJbnQ4KE9QLkVRVUFMVkVSSUZZLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIG91dC53cml0ZVVJbnQ4KE9QLkNIRUNLU0lHLCBvZmYpO1xuICAgIG9mZisrO1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBidWlsZFAyc2hMb2NraW5nU2NyaXB0KHB1YmtleWhhc2gpIHtcbiAgICB2YXIgb3V0ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDMgKyBwdWJrZXloYXNoLmxlbmd0aCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgb3V0LndyaXRlVUludDgoT1AuSEFTSDE2MCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICBvdXQud3JpdGVVSW50OChwdWJrZXloYXNoLmxlbmd0aCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICBwdWJrZXloYXNoLmNvcHkob3V0LCBvZmYpO1xuICAgIG9mZiArPSBwdWJrZXloYXNoLmxlbmd0aDtcbiAgICBvdXQud3JpdGVVSW50OChPUC5FUVVBTCwgb2ZmKTtcbiAgICBvZmYrKztcbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gYnVpbGRQMndwa2hMb2NraW5nU2NyaXB0KHB1YmtleWhhc2gpIHtcbiAgICB2YXIgb3V0ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDIgKyBwdWJrZXloYXNoLmxlbmd0aCk7XG4gICAgb3V0LndyaXRlVUludDgoT1AuWkVSTywgMCk7XG4gICAgb3V0LndyaXRlVUludDgocHVia2V5aGFzaC5sZW5ndGgsIDEpO1xuICAgIHB1YmtleWhhc2guY29weShvdXQsIDIpO1xuICAgIHJldHVybiBvdXQ7XG59XG4vLyBTdGF0aWMgVXRpbHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29uY2F0KGJhc2UsIGFkZGl0aW9uKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2Jhc2UsIGFkZGl0aW9uXSk7XG59XG5mdW5jdGlvbiBnZXRVNjRMRSh4KSB7XG4gICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg4KTtcbiAgICB3cml0ZVVJbnQ2NExFKHgsIGJ1ZmZlciwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGdldFUzMkxFKHgpIHtcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHgsIDApO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBnZXRWYXJJbnQoeCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKHggPCAweGZkKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoeCwgMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggPD0gMHhmZmZmKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygzKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgMCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKHgsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4IDwgMHhmZmZmZmZmZikge1xuICAgICAgICBidWZmZXIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNSk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmUsIDApO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRSh4LCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg5KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiwgMCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHggPj4+IDAsIDEpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRSgoeCAvIDB4MTAwMDAwMDAwKSB8IDAsIDUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gd3JpdGVVSW50NjRMRShuLCBidWYsIG9mZikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpXG4gICAgICAgIG4gPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB2YXIgcHJlQnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDgpO1xuICAgIHZhciBuU3RyID0gbi5sZW5ndGggJSAyID09PSAwID8gbi50b1N0cmluZygxNikgOiBcIjBcIi5jb25jYXQobi50b1N0cmluZygxNikpO1xuICAgIHZhciBuQnVmID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oblN0ciwgJ2hleCcpO1xuICAgIG5CdWYucmV2ZXJzZSgpLmNvcHkocHJlQnVmLCAwKTtcbiAgICBwcmVCdWYuY29weShidWYsIG9mZik7XG4gICAgcmV0dXJuIHByZUJ1Zjtcbn1cbmZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHZhciB2ZXJzaW9uQnl0ZSwgcGtoO1xuICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb25CeXRlID0gYnM1OGNoZWNrXzEuZGVmYXVsdC5kZWNvZGUoYWRkcmVzcylbMF07XG4gICAgICAgIHBraCA9IGJzNThjaGVja18xLmRlZmF1bHQuZGVjb2RlKGFkZHJlc3MpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmVjaDMyRGVjID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChiZWNoMzJEZWMucHJlZml4ID09PSBTRUdXSVRfTkFUSVZFX1YwX1BSRUZJWClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uQnl0ZSA9IEZNVF9TRUdXSVRfTkFUSVZFX1YwO1xuICAgICAgICAgICAgZWxzZSBpZiAoYmVjaDMyRGVjLnByZWZpeCA9PT0gU0VHV0lUX05BVElWRV9WMF9URVNUTkVUX1BSRUZJWClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uQnl0ZSA9IEZNVF9TRUdXSVRfTkFUSVZFX1YwX1RFU1RORVQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcmVmaXg6IG11c3QgYmUgYmMgb3IgdGIuJyk7XG4gICAgICAgICAgICBpZiAoYmVjaDMyRGVjLndvcmRzWzBdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNlZ3dpdCB2ZXJzaW9uOiBtdXN0IGJlIDAsIGdvdCBcIi5jb25jYXQoYmVjaDMyRGVjLndvcmRzWzBdKSk7XG4gICAgICAgICAgICBwa2ggPSBidWZmZXJfMS5CdWZmZXIuZnJvbShiZWNoMzJfMS5iZWNoMzIuZnJvbVdvcmRzKGJlY2gzMkRlYy53b3Jkcy5zbGljZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgYWRkcmVzczogXCIuY29uY2F0KGFkZHJlc3MsIFwiOiBcIikuY29uY2F0KGVyci5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmVyc2lvbkJ5dGU6IHZlcnNpb25CeXRlLCBwa2g6IHBraCB9O1xufVxuLy8gRGV0ZXJtaW5lIHRoZSBhZGRyZXNzIGZvcm1hdCAoYS5rLmEuIFwidmVyc2lvblwiKSBkZXBlbmRpbmcgb24gdGhlXG4vLyBwdXJwb3NlIG9mIHRoZSBkZXJ2YXRpb24gcGF0aC5cbmZ1bmN0aW9uIGdldEFkZHJlc3NGb3JtYXQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IGJlID4xIGluZGV4Jyk7XG4gICAgdmFyIHB1cnBvc2UgPSBwYXRoWzBdO1xuICAgIHZhciBjb2luID0gcGF0aFsxXTtcbiAgICBpZiAocHVycG9zZSA9PT0gUFVSUE9TRVMuQlRDX1NFR1dJVCAmJiBjb2luID09PSBDT0lOUy5CVEMpIHtcbiAgICAgICAgcmV0dXJuIEZNVF9TRUdXSVRfTkFUSVZFX1YwO1xuICAgIH1cbiAgICBlbHNlIGlmIChwdXJwb3NlID09PSBQVVJQT1NFUy5CVENfU0VHV0lUICYmIGNvaW4gPT09IENPSU5TLkJUQ19URVNUTkVUKSB7XG4gICAgICAgIHJldHVybiBGTVRfU0VHV0lUX05BVElWRV9WMF9URVNUTkVUO1xuICAgIH1cbiAgICBlbHNlIGlmIChwdXJwb3NlID09PSBQVVJQT1NFUy5CVENfV1JBUFBFRF9TRUdXSVQgJiYgY29pbiA9PT0gQ09JTlMuQlRDKSB7XG4gICAgICAgIHJldHVybiBGTVRfU0VHV0lUX1dSQVBQRUQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1cnBvc2UgPT09IFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVCAmJlxuICAgICAgICBjb2luID09PSBDT0lOUy5CVENfVEVTVE5FVCkge1xuICAgICAgICByZXR1cm4gRk1UX1NFR1dJVF9XUkFQUEVEX1RFU1RORVQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHB1cnBvc2UgPT09IFBVUlBPU0VTLkJUQ19MRUdBQ1kgJiYgY29pbiA9PT0gQ09JTlMuQlRDKSB7XG4gICAgICAgIHJldHVybiBGTVRfTEVHQUNZO1xuICAgIH1cbiAgICBlbHNlIGlmIChwdXJwb3NlID09PSBQVVJQT1NFUy5CVENfTEVHQUNZICYmIGNvaW4gPT09IENPSU5TLkJUQ19URVNUTkVUKSB7XG4gICAgICAgIHJldHVybiBGTVRfTEVHQUNZX1RFU1RORVQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQml0Y29pbiBwYXRoIHByb3ZpZGVkLiBDYW5ub3QgZGV0ZXJtaW5lIGFkZHJlc3MgZm9ybWF0LicpO1xuICAgIH1cbn1cbi8vIERldGVybWluZSB0aGUgc2NyaXB0IHR5cGUgZm9yIGFuIGlucHV0IGJhc2VkIG9uIGl0cyBvd25lcidzIGRlcml2YXRpb25cbi8vIHBhdGgncyBgcHVycG9zZWAgaW5kZXguXG4vLyBXZSBkbyBub3Qgc3VwcG9ydCBwMnNoIGFuZCBvbmx5IGlzc3VlIHNpbmdsZS1rZXkgYWRkcmVzc2VzIGZyb20gdGhlIExhdHRpY2Vcbi8vIHNvIHdlIGNhbiBkZXRlcm1pbmUgdGhpcyBiYXNlZCBvbiBwYXRoIGFsb25lLlxuZnVuY3Rpb24gZ2V0U2NyaXB0VHlwZShpbnB1dCkge1xuICAgIHN3aXRjaCAoaW5wdXQuc2lnbmVyUGF0aFswXSkge1xuICAgICAgICBjYXNlIFBVUlBPU0VTLkJUQ19MRUdBQ1k6XG4gICAgICAgICAgICByZXR1cm4gQlRDX1NDUklQVF9UWVBFX1AyUEtIO1xuICAgICAgICBjYXNlIFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVDpcbiAgICAgICAgICAgIHJldHVybiBCVENfU0NSSVBUX1RZUEVfUDJTSF9QMldQS0g7XG4gICAgICAgIGNhc2UgUFVSUE9TRVMuQlRDX1NFR1dJVDpcbiAgICAgICAgICAgIHJldHVybiBCVENfU0NSSVBUX1RZUEVfUDJXUEtIX1YwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGF0aCBwdXJwb3NlIChcIi5jb25jYXQoaW5wdXQuc2lnbmVyUGF0aFswXSwgXCIpOiBjYW5ub3QgZGV0ZXJtaW5lIEJUQyBzY3JpcHQgdHlwZS5cIikpO1xuICAgIH1cbn1cbi8vIERldGVybWluZSBpZiBhIGEgdHJhbnNhY3Rpb24gc2hvdWxkIGhhdmUgYSB3aXRuZXNzIHBvcnRpb24uXG4vLyBUaGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgYW55IGlucHV0IGlzIHAyc2gocDJ3cGtoKSBvciBwMndwa2guXG4vLyBXZSBkZXRlcm1pbmUgdGhlIHNjcmlwdCB0eXBlIGJhc2VkIG9uIHRoZSBkZXJpdmF0aW9uIHBhdGguXG5mdW5jdGlvbiBuZWVkc1dpdG5lc3MoaW5wdXRzKSB7XG4gICAgdmFyIHcgPSBmYWxzZTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNpZ25lclBhdGhbMF0gPT09IFBVUlBPU0VTLkJUQ19TRUdXSVQgfHxcbiAgICAgICAgICAgIGlucHV0LnNpZ25lclBhdGhbMF0gPT09IFBVUlBPU0VTLkJUQ19XUkFQUEVEX1NFR1dJVCkge1xuICAgICAgICAgICAgdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBidWlsZEJpdGNvaW5UeFJlcXVlc3Q6IGJ1aWxkQml0Y29pblR4UmVxdWVzdCxcbiAgICBzZXJpYWxpemVUeDogc2VyaWFsaXplVHgsXG4gICAgZ2V0Qml0Y29pbkFkZHJlc3M6IGdldEJpdGNvaW5BZGRyZXNzLFxuICAgIGdldEFkZHJlc3NGb3JtYXQ6IGdldEFkZHJlc3NGb3JtYXQsXG59O1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcy5qc29uJylcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKVxudmFyIGVjcGFyYW1zID0gZWMuY3VydmVcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4QnVmZmVyKSB7XG4gIHZhciB4ID0gbmV3IEJOKHhCdWZmZXIpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICB2YXIgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeEJ1ZmZlciwgeUJ1ZmZlcikge1xuICB2YXIgeCA9IG5ldyBCTih4QnVmZmVyKVxuICB2YXIgeSA9IG5ldyBCTih5QnVmZmVyKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICB2YXIgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmxpY0tleSkge1xuICB2YXIgZmlyc3QgPSBwdWJsaWNLZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmxpY0tleS5zbGljZSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVibGljS2V5LnNsaWNlKDEsIDMzKSwgcHVibGljS2V5LnNsaWNlKDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi5jbXAoZWNwYXJhbXMubikgPCAwICYmICFibi5pc1plcm8oKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICByZXR1cm4gYm4uaXNaZXJvKCkgPyBCdWZmZXIuYWxsb2MoMzIpIDogZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9SQU5HRV9JTlZBTElEKVxuXG4gIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHZhciBibiA9IG5ldyBCTih0d2VhaylcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFdFQUtfQUREX0ZBSUwpXG5cbiAgYm4uaWFkZChuZXcgQk4ocHJpdmF0ZUtleSkpXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICBpZiAoYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gYm4udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19NVUxfRkFJTClcblxuICBibi5pbXVsKG5ldyBCTihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgcmV0dXJuIGJuLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfQ1JFQVRFX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICByZXR1cm4gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpICE9PSBudWxsXG59XG5cbmV4cG9ydHMucHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICB2YXIgcG9pbnQgPSBlY3BhcmFtcy5nLm11bCh0d2VhaykuYWRkKHBhaXIucHViKVxuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bCh0d2VhaykuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpcnMgPSBuZXcgQXJyYXkocHVibGljS2V5cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHVibGljS2V5cy5sZW5ndGg7ICsraSkge1xuICAgIHBhaXJzW2ldID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXlzW2ldKVxuICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcbiAgfVxuXG4gIHZhciBwb2ludCA9IHBhaXJzWzBdLnB1YlxuICBmb3IgKHZhciBqID0gMTsgaiA8IHBhaXJzLmxlbmd0aDsgKytqKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tqXS5wdWIpXG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0NPTUJJTkVfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSlcbiAgdmFyIHMgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpXG4gIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKVxuICBpZiAocy5jbXAoZWMubmgpID09PSAxKSBlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHJlc3VsdCwgMzIpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpXG4gIHZhciBzID0gc2lnbmF0dXJlLnNsaWNlKDMyLCA2NClcbiAgaWYgKG5ldyBCTihyKS5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBuZXcgQk4ocykuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gbmV3IEJOKHNpZ09iai5yKVxuICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKVxuICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICByLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLFxuICAgIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbiAgXSlcbn1cblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBub25jZWZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGdldE5vbmNlID0gbm9uY2VmblxuICAgIG5vbmNlZm4gPSBmdW5jdGlvbiAoY291bnRlcikge1xuICAgICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UobWVzc2FnZSwgcHJpdmF0ZUtleSwgbnVsbCwgZGF0YSwgY291bnRlcilcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTl9GQUlMKVxuXG4gICAgICByZXR1cm4gbmV3IEJOKG5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgdmFyIHJlc3VsdCA9IGVjLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgcmVzdWx0LnIudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksXG4gICAgICByZXN1bHQucy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICAgIF0pLFxuICAgIHJlY292ZXJ5OiByZXN1bHQucmVjb3ZlcnlQYXJhbVxuICB9XG59XG5cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIHZhciBzaWdPYmogPSB7IHI6IHNpZ25hdHVyZS5zbGljZSgwLCAzMiksIHM6IHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpIH1cblxuICB2YXIgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgdmFyIHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcbiAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiBmYWxzZVxuXG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiBlYy52ZXJpZnkobWVzc2FnZSwgc2lnT2JqLCB7IHg6IHBhaXIucHViLngsIHk6IHBhaXIucHViLnkgfSlcbn1cblxuZXhwb3J0cy5yZWNvdmVyID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHNpZ09iaiA9IHsgcjogc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSwgczogc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkgfVxuXG4gIHZhciBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICB2YXIgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHRyeSB7XG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKClcblxuICAgIHZhciBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobWVzc2FnZSwgc2lnT2JqLCByZWNvdmVyeSlcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfUkVDT1ZFUl9GQUlMKVxuICB9XG59XG5cbmV4cG9ydHMuZWNkaCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNoYXJlZCA9IGV4cG9ydHMuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIHRydWUpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhcmVkKS5kaWdlc3QoKVxufVxuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKHNjYWxhci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RIX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bChzY2FsYXIpLmVuY29kZSh0cnVlLCBjb21wcmVzc2VkKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0JylcbnZhciBkZXIgPSByZXF1aXJlKCcuL2RlcicpXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzb24nKVxuXG5mdW5jdGlvbiBpbml0Q29tcHJlc3NlZFZhbHVlICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmYXVsdFZhbHVlXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbih2YWx1ZSwgbWVzc2FnZXMuQ09NUFJFU1NFRF9UWVBFX0lOVkFMSUQpXG4gIHJldHVybiB2YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWNwMjU2azEpIHtcbiAgcmV0dXJuIHtcbiAgICBwcml2YXRlS2V5VmVyaWZ5OiBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIHJldHVybiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleUV4cG9ydDogZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuICAgICAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpXG5cbiAgICAgIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlJbXBvcnQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuXG4gICAgICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSlcbiAgICAgIGlmIChwcml2YXRlS2V5ICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkgcmV0dXJuIHByaXZhdGVLZXlcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0lNUE9SVF9ERVJfRkFJTClcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZTogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU1vZEludmVyc2U6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtNdWw6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGU6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZClcbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydDogZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnk6IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha0FkZDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lOiBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQXJyYXkocHVibGljS2V5cywgbWVzc2FnZXMuRUNfUFVCTElDX0tFWVNfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHB1YmxpY0tleXMsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlTX0xFTkdUSF9JTlZBTElEKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXlzW2ldLCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXlzW2ldLCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG4gICAgICB9XG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShwdWJsaWNLZXlzLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemU6IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihzaWduYXR1cmUsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgoc2lnbmF0dXJlLCA2NCwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWduYXR1cmUpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydDogZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBzaWdPYmogPSBzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSlcbiAgICAgIHJldHVybiBkZXIuc2lnbmF0dXJlRXhwb3J0KHNpZ09iailcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0OiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydChzaWcpXG4gICAgICBpZiAoc2lnT2JqKSByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWdPYmopXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUwpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydExheDogZnVuY3Rpb24gKHNpZykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0xlbmd0aEdUWmVybyhzaWcsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnKVxuICAgICAgaWYgKHNpZ09iaikgcmV0dXJuIHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0RFUl9GQUlMKVxuICAgIH0sXG5cbiAgICBzaWduOiBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKG1lc3NhZ2UsIG1lc3NhZ2VzLk1TRzMyX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChtZXNzYWdlLCAzMiwgbWVzc2FnZXMuTVNHMzJfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgZGF0YSA9IG51bGxcbiAgICAgIHZhciBub25jZWZuID0gbnVsbFxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQuaXNPYmplY3Qob3B0aW9ucywgbWVzc2FnZXMuT1BUSU9OU19UWVBFX0lOVkFMSUQpXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0LmlzQnVmZmVyKG9wdGlvbnMuZGF0YSwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgob3B0aW9ucy5kYXRhLCAzMiwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX0xFTkdUSF9JTlZBTElEKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydC5pc0Z1bmN0aW9uKG9wdGlvbnMubm9uY2VmbiwgbWVzc2FnZXMuT1BUSU9OU19OT05DRUZOX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBub25jZWZuID0gb3B0aW9ucy5ub25jZWZuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpXG4gICAgfSxcblxuICAgIHZlcmlmeTogZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpXG4gICAgfSxcblxuICAgIHJlY292ZXI6IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc051bWJlcihyZWNvdmVyeSwgbWVzc2FnZXMuUkVDT1ZFUllfSURfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTnVtYmVySW5JbnRlcnZhbChyZWNvdmVyeSwgLTEsIDQsIG1lc3NhZ2VzLlJFQ09WRVJZX0lEX1ZBTFVFX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBlY2RoOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBlY2RoVW5zYWZlOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNhcmRhbm9UeFdpdG5lc3NUeXBlID0gZXhwb3J0cy5DYXJkYW5vVHhTaWduaW5nTW9kZSA9IGV4cG9ydHMuQ2FyZGFub1Bvb2xSZWxheVR5cGUgPSBleHBvcnRzLkNhcmRhbm9OYXRpdmVTY3JpcHRIYXNoRGlzcGxheUZvcm1hdCA9IGV4cG9ydHMuQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBleHBvcnRzLkNhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBleHBvcnRzLkNhcmRhbm9BZGRyZXNzVHlwZSA9IHZvaWQgMDtcblxudmFyIF9wcm90b2J1ZiA9IHJlcXVpcmUoXCIuLi90cmV6b3IvcHJvdG9idWZcIik7XG5cbmV4cG9ydHMuQ2FyZGFub0FkZHJlc3NUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub0FkZHJlc3NUeXBlO1xuZXhwb3J0cy5DYXJkYW5vQ2VydGlmaWNhdGVUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub0NlcnRpZmljYXRlVHlwZTtcbmV4cG9ydHMuQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0VHlwZTtcbmV4cG9ydHMuQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0O1xuZXhwb3J0cy5DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IF9wcm90b2J1Zi5FbnVtX0NhcmRhbm9Qb29sUmVsYXlUeXBlO1xuZXhwb3J0cy5DYXJkYW5vVHhTaWduaW5nTW9kZSA9IF9wcm90b2J1Zi5FbnVtX0NhcmRhbm9UeFNpZ25pbmdNb2RlO1xuZXhwb3J0cy5DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IF9wcm90b2J1Zi5FbnVtX0NhcmRhbm9UeFdpdG5lc3NUeXBlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpKTtcblxudmFyIFAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wYXJhbXNcIikpO1xuXG52YXIgRGV2aWNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdHJlem9yL2RldmljZVwiKSk7XG5cbnZhciBNZ21udCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3RyZXpvci9tYW5hZ2VtZW50XCIpKTtcblxudmFyIFByb3RvYnVmID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdHJlem9yL3Byb3RvYnVmXCIpKTtcblxudmFyIEFjY291bnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9hY2NvdW50XCIpKTtcblxudmFyIEJpdGNvaW4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaXRjb2luXCIpKTtcblxudmFyIEJpbmFuY2UgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaW5hbmNlXCIpKTtcblxudmFyIENhcmRhbm8gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9jYXJkYW5vXCIpKTtcblxudmFyIENvaW5JbmZvID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvY29pbkluZm9cIikpO1xuXG52YXIgRU9TID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvZW9zXCIpKTtcblxudmFyIEV0aGVyZXVtID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvZXRoZXJldW1cIikpO1xuXG52YXIgTkVNID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvbmVtXCIpKTtcblxudmFyIFJpcHBsZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL3JpcHBsZVwiKSk7XG5cbnZhciBTdGVsbGFyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3Mvc3RlbGxhclwiKSk7XG5cbnZhciBUZXpvcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL3Rlem9zXCIpKTtcblxudmFyIE1pc2MgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9taXNjXCIpKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2V2ZW50c1wiKSk7XG5cbnZhciBCbG9ja2NoYWluID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vYmFja2VuZC9ibG9ja2NoYWluXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlRZUEVTID0gdm9pZCAwO1xudmFyIFRZUEVTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGJpdGNvaW46ICdCaXRjb2luJyxcbiAgZXRoZXJldW06ICdFdGhlcmV1bScsXG4gIGVvczogJ0VvcycsXG4gIG5lbTogJ05FTScsXG4gIHN0ZWxsYXI6ICdTdGVsbGFyJyxcbiAgY2FyZGFubzogJ0NhcmRhbm8nLFxuICByaXBwbGU6ICdSaXBwbGUnLFxuICB0ZXpvczogJ1Rlem9ycycsXG4gIGJpbmFuY2U6ICdCaW5hbmNlJ1xufSk7XG5leHBvcnRzLlRZUEVTID0gVFlQRVM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLldBSVRfRk9SX1NFTEVDVElPTiA9IGV4cG9ydHMuV09SRCA9IGV4cG9ydHMuUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBleHBvcnRzLlBBU1NQSFJBU0UgPSBleHBvcnRzLlBJTiA9IGV4cG9ydHMuQlVUVE9OID0gZXhwb3J0cy5MT0FESU5HID0gZXhwb3J0cy5VU0VEX0VMU0VXSEVSRSA9IGV4cG9ydHMuUkVMRUFTRUQgPSBleHBvcnRzLkFDUVVJUkVEID0gZXhwb3J0cy5SRUxFQVNFID0gZXhwb3J0cy5BQ1FVSVJFID0gZXhwb3J0cy5DSEFOR0VEID0gZXhwb3J0cy5ESVNDT05ORUNUID0gZXhwb3J0cy5DT05ORUNUX1VOQUNRVUlSRUQgPSBleHBvcnRzLkNPTk5FQ1QgPSB2b2lkIDA7XG4vLyBkZXZpY2UgbGlzdCBldmVudHNcbnZhciBDT05ORUNUID0gJ2RldmljZS1jb25uZWN0JztcbmV4cG9ydHMuQ09OTkVDVCA9IENPTk5FQ1Q7XG52YXIgQ09OTkVDVF9VTkFDUVVJUkVEID0gJ2RldmljZS1jb25uZWN0X3VuYWNxdWlyZWQnO1xuZXhwb3J0cy5DT05ORUNUX1VOQUNRVUlSRUQgPSBDT05ORUNUX1VOQUNRVUlSRUQ7XG52YXIgRElTQ09OTkVDVCA9ICdkZXZpY2UtZGlzY29ubmVjdCc7XG5leHBvcnRzLkRJU0NPTk5FQ1QgPSBESVNDT05ORUNUO1xudmFyIENIQU5HRUQgPSAnZGV2aWNlLWNoYW5nZWQnO1xuZXhwb3J0cy5DSEFOR0VEID0gQ0hBTkdFRDtcbnZhciBBQ1FVSVJFID0gJ2RldmljZS1hY3F1aXJlJztcbmV4cG9ydHMuQUNRVUlSRSA9IEFDUVVJUkU7XG52YXIgUkVMRUFTRSA9ICdkZXZpY2UtcmVsZWFzZSc7XG5leHBvcnRzLlJFTEVBU0UgPSBSRUxFQVNFO1xudmFyIEFDUVVJUkVEID0gJ2RldmljZS1hY3F1aXJlZCc7XG5leHBvcnRzLkFDUVVJUkVEID0gQUNRVUlSRUQ7XG52YXIgUkVMRUFTRUQgPSAnZGV2aWNlLXJlbGVhc2VkJztcbmV4cG9ydHMuUkVMRUFTRUQgPSBSRUxFQVNFRDtcbnZhciBVU0VEX0VMU0VXSEVSRSA9ICdkZXZpY2UtdXNlZF9lbHNld2hlcmUnO1xuZXhwb3J0cy5VU0VEX0VMU0VXSEVSRSA9IFVTRURfRUxTRVdIRVJFO1xudmFyIExPQURJTkcgPSAnZGV2aWNlLWxvYWRpbmcnOyAvLyB0cmV6b3ItbGluayBldmVudHMgaW4gcHJvdG9idWYgZm9ybWF0XG5cbmV4cG9ydHMuTE9BRElORyA9IExPQURJTkc7XG52YXIgQlVUVE9OID0gJ2J1dHRvbic7XG5leHBvcnRzLkJVVFRPTiA9IEJVVFRPTjtcbnZhciBQSU4gPSAncGluJztcbmV4cG9ydHMuUElOID0gUElOO1xudmFyIFBBU1NQSFJBU0UgPSAncGFzc3BocmFzZSc7XG5leHBvcnRzLlBBU1NQSFJBU0UgPSBQQVNTUEhSQVNFO1xudmFyIFBBU1NQSFJBU0VfT05fREVWSUNFID0gJ3Bhc3NwaHJhc2Vfb25fZGV2aWNlJztcbmV4cG9ydHMuUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBQQVNTUEhSQVNFX09OX0RFVklDRTtcbnZhciBXT1JEID0gJ3dvcmQnOyAvLyBjdXN0b21cblxuZXhwb3J0cy5XT1JEID0gV09SRDtcbnZhciBXQUlUX0ZPUl9TRUxFQ1RJT04gPSAnZGV2aWNlLXdhaXRfZm9yX3NlbGVjdGlvbic7XG5leHBvcnRzLldBSVRfRk9SX1NFTEVDVElPTiA9IFdBSVRfRk9SX1NFTEVDVElPTjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0FMTCA9IGV4cG9ydHMuRVJST1IgPSBleHBvcnRzLklOSVQgPSBleHBvcnRzLkxPQURFRCA9IGV4cG9ydHMuQk9PVFNUUkFQID0gdm9pZCAwO1xuLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpZnJhbWUuaHRtbCBpbmxpbmUgc2NyaXB0IGJlZm9yZSBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gaWZyYW1lIHRvIHdpbmRvdy5vcGVuZXIuXG52YXIgQk9PVFNUUkFQID0gJ2lmcmFtZS1ib290c3RyYXAnOyAvLyBNZXNzYWdlIGZyb20gaWZyYW1lLmpzIHRvIHdpbmRvdy5vcGVuZXIsIGNhbGxlZCBhZnRlciBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBzZWNvbmQgbWVzc2FnZSBmcm9tIGlmcmFtZSB0byB3aW5kb3cub3BlbmVyLlxuXG5leHBvcnRzLkJPT1RTVFJBUCA9IEJPT1RTVFJBUDtcbnZhciBMT0FERUQgPSAnaWZyYW1lLWxvYWRlZCc7IC8vIE1lc3NhZ2UgZnJvbSB3aW5kb3cub3BlbmVyIHRvIGlmcmFtZS5qc1xuXG5leHBvcnRzLkxPQURFRCA9IExPQURFRDtcbnZhciBJTklUID0gJ2lmcmFtZS1pbml0JzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIGlmcmFtZS5qcyB0byB3aW5kb3cub3BlbmVyLiBDb3VsZCBiZSB0aHJvd24gZHVyaW5nIGlmcmFtZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzXG5cbmV4cG9ydHMuSU5JVCA9IElOSVQ7XG52YXIgRVJST1IgPSAnaWZyYW1lLWVycm9yJzsgLy8gTWVzc2FnZSBmcm9tIHdpbmRvdy5vcGVuZXIgdG8gaWZyYW1lLiBDYWxsIG1ldGhvZFxuXG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgQ0FMTCA9ICdpZnJhbWUtY2FsbCc7XG5leHBvcnRzLkNBTEwgPSBDQUxMOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5TVEFSVF9QRU5ESU5HID0gZXhwb3J0cy5ESVNBQkxFX1dFQlVTQiA9IGV4cG9ydHMuUkVRVUVTVCA9IGV4cG9ydHMuU1RSRUFNID0gZXhwb3J0cy5VUERBVEUgPSBleHBvcnRzLkVSUk9SID0gZXhwb3J0cy5TVEFSVCA9IHZvaWQgMDtcbnZhciBTVEFSVCA9ICd0cmFuc3BvcnQtc3RhcnQnO1xuZXhwb3J0cy5TVEFSVCA9IFNUQVJUO1xudmFyIEVSUk9SID0gJ3RyYW5zcG9ydC1lcnJvcic7XG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgVVBEQVRFID0gJ3RyYW5zcG9ydC11cGRhdGUnO1xuZXhwb3J0cy5VUERBVEUgPSBVUERBVEU7XG52YXIgU1RSRUFNID0gJ3RyYW5zcG9ydC1zdHJlYW0nO1xuZXhwb3J0cy5TVFJFQU0gPSBTVFJFQU07XG52YXIgUkVRVUVTVCA9ICd0cmFuc3BvcnQtcmVxdWVzdF9kZXZpY2UnO1xuZXhwb3J0cy5SRVFVRVNUID0gUkVRVUVTVDtcbnZhciBESVNBQkxFX1dFQlVTQiA9ICd0cmFuc3BvcnQtZGlzYWJsZV93ZWJ1c2InO1xuZXhwb3J0cy5ESVNBQkxFX1dFQlVTQiA9IERJU0FCTEVfV0VCVVNCO1xudmFyIFNUQVJUX1BFTkRJTkcgPSAndHJhbnNwb3J0LXN0YXJ0X3BlbmRpbmcnO1xuZXhwb3J0cy5TVEFSVF9QRU5ESU5HID0gU1RBUlRfUEVORElORzsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuSUZSQU1FX0ZBSUxVUkUgPSBleHBvcnRzLkFERFJFU1NfVkFMSURBVElPTiA9IGV4cG9ydHMuQlVORExFX1BST0dSRVNTID0gZXhwb3J0cy5MT0dJTl9DSEFMTEVOR0VfUkVTUE9OU0UgPSBleHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVFVRVNUID0gZXhwb3J0cy5DVVNUT01fTUVTU0FHRV9SRVNQT05TRSA9IGV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVRVUVTVCA9IGV4cG9ydHMuQ0hBTkdFX1NFVFRJTkdTID0gZXhwb3J0cy5SRUNFSVZFX1dPUkQgPSBleHBvcnRzLlJFQ0VJVkVfRkVFID0gZXhwb3J0cy5SRUNFSVZFX0FDQ09VTlQgPSBleHBvcnRzLkNIQU5HRV9BQ0NPVU5UID0gZXhwb3J0cy5SRUNFSVZFX0RFVklDRSA9IGV4cG9ydHMuUkVDRUlWRV9QQVNTUEhSQVNFID0gZXhwb3J0cy5SRUNFSVZFX1BJTiA9IGV4cG9ydHMuUkVDRUlWRV9DT05GSVJNQVRJT04gPSBleHBvcnRzLlJFQ0VJVkVfUEVSTUlTU0lPTiA9IGV4cG9ydHMuUkVRVUVTVF9XT1JEID0gZXhwb3J0cy5SRVFVRVNUX0JVVFRPTiA9IGV4cG9ydHMuSU5TVUZGSUNJRU5UX0ZVTkRTID0gZXhwb3J0cy5VUERBVEVfQ1VTVE9NX0ZFRSA9IGV4cG9ydHMuU0VMRUNUX0ZFRSA9IGV4cG9ydHMuU0VMRUNUX0FDQ09VTlQgPSBleHBvcnRzLlNFTEVDVF9ERVZJQ0UgPSBleHBvcnRzLlNFVF9PUEVSQVRJT04gPSBleHBvcnRzLkxPQURJTkcgPSBleHBvcnRzLkNPTk5FQ1QgPSBleHBvcnRzLklOVkFMSURfUEFTU1BIUkFTRV9BQ1RJT04gPSBleHBvcnRzLklOVkFMSURfUEFTU1BIUkFTRSA9IGV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFX09OX0RFVklDRSA9IGV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFID0gZXhwb3J0cy5JTlZBTElEX1BJTiA9IGV4cG9ydHMuUkVRVUVTVF9QSU4gPSBleHBvcnRzLlJFUVVFU1RfQ09ORklSTUFUSU9OID0gZXhwb3J0cy5SRVFVRVNUX1BFUk1JU1NJT04gPSBleHBvcnRzLkNMT1NFX1VJX1dJTkRPVyA9IGV4cG9ydHMuUkVRVUVTVF9VSV9XSU5ET1cgPSBleHBvcnRzLkRFVklDRV9ORUVEU19CQUNLVVAgPSBleHBvcnRzLkZJUk1XQVJFX1BST0dSRVNTID0gZXhwb3J0cy5GSVJNV0FSRV9OT1RfSU5TVEFMTEVEID0gZXhwb3J0cy5GSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9IGV4cG9ydHMuRklSTVdBUkVfTk9UX1NVUFBPUlRFRCA9IGV4cG9ydHMuRklSTVdBUkVfT1VUREFURUQgPSBleHBvcnRzLkZJUk1XQVJFX09MRCA9IGV4cG9ydHMuU0VFRExFU1MgPSBleHBvcnRzLklOSVRJQUxJWkUgPSBleHBvcnRzLlJFUVVJUkVfTU9ERSA9IGV4cG9ydHMuTk9UX0lOX0JPT1RMT0FERVIgPSBleHBvcnRzLkJPT1RMT0FERVIgPSBleHBvcnRzLlRSQU5TUE9SVCA9IHZvaWQgMDtcbnZhciBUUkFOU1BPUlQgPSAndWktbm9fdHJhbnNwb3J0JztcbmV4cG9ydHMuVFJBTlNQT1JUID0gVFJBTlNQT1JUO1xudmFyIEJPT1RMT0FERVIgPSAndWktZGV2aWNlX2Jvb3Rsb2FkZXJfbW9kZSc7XG5leHBvcnRzLkJPT1RMT0FERVIgPSBCT09UTE9BREVSO1xudmFyIE5PVF9JTl9CT09UTE9BREVSID0gJ3VpLWRldmljZV9ub3RfaW5fYm9vdGxvYWRlcl9tb2RlJztcbmV4cG9ydHMuTk9UX0lOX0JPT1RMT0FERVIgPSBOT1RfSU5fQk9PVExPQURFUjtcbnZhciBSRVFVSVJFX01PREUgPSAndWktZGV2aWNlX3JlcXVpcmVfbW9kZSc7XG5leHBvcnRzLlJFUVVJUkVfTU9ERSA9IFJFUVVJUkVfTU9ERTtcbnZhciBJTklUSUFMSVpFID0gJ3VpLWRldmljZV9ub3RfaW5pdGlhbGl6ZWQnO1xuZXhwb3J0cy5JTklUSUFMSVpFID0gSU5JVElBTElaRTtcbnZhciBTRUVETEVTUyA9ICd1aS1kZXZpY2Vfc2VlZGxlc3MnO1xuZXhwb3J0cy5TRUVETEVTUyA9IFNFRURMRVNTO1xudmFyIEZJUk1XQVJFX09MRCA9ICd1aS1kZXZpY2VfZmlybXdhcmVfb2xkJztcbmV4cG9ydHMuRklSTVdBUkVfT0xEID0gRklSTVdBUkVfT0xEO1xudmFyIEZJUk1XQVJFX09VVERBVEVEID0gJ3VpLWRldmljZV9maXJtd2FyZV9vdXRkYXRlZCc7XG5leHBvcnRzLkZJUk1XQVJFX09VVERBVEVEID0gRklSTVdBUkVfT1VUREFURUQ7XG52YXIgRklSTVdBUkVfTk9UX1NVUFBPUlRFRCA9ICd1aS1kZXZpY2VfZmlybXdhcmVfdW5zdXBwb3J0ZWQnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfU1VQUE9SVEVEID0gRklSTVdBUkVfTk9UX1NVUFBPUlRFRDtcbnZhciBGSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9ICd1aS1kZXZpY2VfZmlybXdhcmVfbm90X2NvbXBhdGlibGUnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9IEZJUk1XQVJFX05PVF9DT01QQVRJQkxFO1xudmFyIEZJUk1XQVJFX05PVF9JTlNUQUxMRUQgPSAndWktZGV2aWNlX2Zpcm13YXJlX25vdF9pbnN0YWxsZWQnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfSU5TVEFMTEVEID0gRklSTVdBUkVfTk9UX0lOU1RBTExFRDtcbnZhciBGSVJNV0FSRV9QUk9HUkVTUyA9ICd1aS1maXJtd2FyZS1wcm9ncmVzcyc7XG5leHBvcnRzLkZJUk1XQVJFX1BST0dSRVNTID0gRklSTVdBUkVfUFJPR1JFU1M7XG52YXIgREVWSUNFX05FRURTX0JBQ0tVUCA9ICd1aS1kZXZpY2VfbmVlZHNfYmFja3VwJztcbmV4cG9ydHMuREVWSUNFX05FRURTX0JBQ0tVUCA9IERFVklDRV9ORUVEU19CQUNLVVA7XG52YXIgUkVRVUVTVF9VSV9XSU5ET1cgPSAndWktcmVxdWVzdF93aW5kb3cnO1xuZXhwb3J0cy5SRVFVRVNUX1VJX1dJTkRPVyA9IFJFUVVFU1RfVUlfV0lORE9XO1xudmFyIENMT1NFX1VJX1dJTkRPVyA9ICd1aS1jbG9zZV93aW5kb3cnO1xuZXhwb3J0cy5DTE9TRV9VSV9XSU5ET1cgPSBDTE9TRV9VSV9XSU5ET1c7XG52YXIgUkVRVUVTVF9QRVJNSVNTSU9OID0gJ3VpLXJlcXVlc3RfcGVybWlzc2lvbic7XG5leHBvcnRzLlJFUVVFU1RfUEVSTUlTU0lPTiA9IFJFUVVFU1RfUEVSTUlTU0lPTjtcbnZhciBSRVFVRVNUX0NPTkZJUk1BVElPTiA9ICd1aS1yZXF1ZXN0X2NvbmZpcm1hdGlvbic7XG5leHBvcnRzLlJFUVVFU1RfQ09ORklSTUFUSU9OID0gUkVRVUVTVF9DT05GSVJNQVRJT047XG52YXIgUkVRVUVTVF9QSU4gPSAndWktcmVxdWVzdF9waW4nO1xuZXhwb3J0cy5SRVFVRVNUX1BJTiA9IFJFUVVFU1RfUElOO1xudmFyIElOVkFMSURfUElOID0gJ3VpLWludmFsaWRfcGluJztcbmV4cG9ydHMuSU5WQUxJRF9QSU4gPSBJTlZBTElEX1BJTjtcbnZhciBSRVFVRVNUX1BBU1NQSFJBU0UgPSAndWktcmVxdWVzdF9wYXNzcGhyYXNlJztcbmV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFID0gUkVRVUVTVF9QQVNTUEhSQVNFO1xudmFyIFJFUVVFU1RfUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSAndWktcmVxdWVzdF9wYXNzcGhyYXNlX29uX2RldmljZSc7XG5leHBvcnRzLlJFUVVFU1RfUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBSRVFVRVNUX1BBU1NQSFJBU0VfT05fREVWSUNFO1xudmFyIElOVkFMSURfUEFTU1BIUkFTRSA9ICd1aS1pbnZhbGlkX3Bhc3NwaHJhc2UnO1xuZXhwb3J0cy5JTlZBTElEX1BBU1NQSFJBU0UgPSBJTlZBTElEX1BBU1NQSFJBU0U7XG52YXIgSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTiA9ICd1aS1pbnZhbGlkX3Bhc3NwaHJhc2VfYWN0aW9uJztcbmV4cG9ydHMuSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTiA9IElOVkFMSURfUEFTU1BIUkFTRV9BQ1RJT047XG52YXIgQ09OTkVDVCA9ICd1aS1jb25uZWN0JztcbmV4cG9ydHMuQ09OTkVDVCA9IENPTk5FQ1Q7XG52YXIgTE9BRElORyA9ICd1aS1sb2FkaW5nJztcbmV4cG9ydHMuTE9BRElORyA9IExPQURJTkc7XG52YXIgU0VUX09QRVJBVElPTiA9ICd1aS1zZXRfb3BlcmF0aW9uJztcbmV4cG9ydHMuU0VUX09QRVJBVElPTiA9IFNFVF9PUEVSQVRJT047XG52YXIgU0VMRUNUX0RFVklDRSA9ICd1aS1zZWxlY3RfZGV2aWNlJztcbmV4cG9ydHMuU0VMRUNUX0RFVklDRSA9IFNFTEVDVF9ERVZJQ0U7XG52YXIgU0VMRUNUX0FDQ09VTlQgPSAndWktc2VsZWN0X2FjY291bnQnO1xuZXhwb3J0cy5TRUxFQ1RfQUNDT1VOVCA9IFNFTEVDVF9BQ0NPVU5UO1xudmFyIFNFTEVDVF9GRUUgPSAndWktc2VsZWN0X2ZlZSc7XG5leHBvcnRzLlNFTEVDVF9GRUUgPSBTRUxFQ1RfRkVFO1xudmFyIFVQREFURV9DVVNUT01fRkVFID0gJ3VpLXVwZGF0ZV9jdXN0b21fZmVlJztcbmV4cG9ydHMuVVBEQVRFX0NVU1RPTV9GRUUgPSBVUERBVEVfQ1VTVE9NX0ZFRTtcbnZhciBJTlNVRkZJQ0lFTlRfRlVORFMgPSAndWktaW5zdWZmaWNpZW50X2Z1bmRzJztcbmV4cG9ydHMuSU5TVUZGSUNJRU5UX0ZVTkRTID0gSU5TVUZGSUNJRU5UX0ZVTkRTO1xudmFyIFJFUVVFU1RfQlVUVE9OID0gJ3VpLWJ1dHRvbic7XG5leHBvcnRzLlJFUVVFU1RfQlVUVE9OID0gUkVRVUVTVF9CVVRUT047XG52YXIgUkVRVUVTVF9XT1JEID0gJ3VpLXJlcXVlc3Rfd29yZCc7XG5leHBvcnRzLlJFUVVFU1RfV09SRCA9IFJFUVVFU1RfV09SRDtcbnZhciBSRUNFSVZFX1BFUk1JU1NJT04gPSAndWktcmVjZWl2ZV9wZXJtaXNzaW9uJztcbmV4cG9ydHMuUkVDRUlWRV9QRVJNSVNTSU9OID0gUkVDRUlWRV9QRVJNSVNTSU9OO1xudmFyIFJFQ0VJVkVfQ09ORklSTUFUSU9OID0gJ3VpLXJlY2VpdmVfY29uZmlybWF0aW9uJztcbmV4cG9ydHMuUkVDRUlWRV9DT05GSVJNQVRJT04gPSBSRUNFSVZFX0NPTkZJUk1BVElPTjtcbnZhciBSRUNFSVZFX1BJTiA9ICd1aS1yZWNlaXZlX3Bpbic7XG5leHBvcnRzLlJFQ0VJVkVfUElOID0gUkVDRUlWRV9QSU47XG52YXIgUkVDRUlWRV9QQVNTUEhSQVNFID0gJ3VpLXJlY2VpdmVfcGFzc3BocmFzZSc7XG5leHBvcnRzLlJFQ0VJVkVfUEFTU1BIUkFTRSA9IFJFQ0VJVkVfUEFTU1BIUkFTRTtcbnZhciBSRUNFSVZFX0RFVklDRSA9ICd1aS1yZWNlaXZlX2RldmljZSc7XG5leHBvcnRzLlJFQ0VJVkVfREVWSUNFID0gUkVDRUlWRV9ERVZJQ0U7XG52YXIgQ0hBTkdFX0FDQ09VTlQgPSAndWktY2hhbmdlX2FjY291bnQnO1xuZXhwb3J0cy5DSEFOR0VfQUNDT1VOVCA9IENIQU5HRV9BQ0NPVU5UO1xudmFyIFJFQ0VJVkVfQUNDT1VOVCA9ICd1aS1yZWNlaXZlX2FjY291bnQnO1xuZXhwb3J0cy5SRUNFSVZFX0FDQ09VTlQgPSBSRUNFSVZFX0FDQ09VTlQ7XG52YXIgUkVDRUlWRV9GRUUgPSAndWktcmVjZWl2ZV9mZWUnO1xuZXhwb3J0cy5SRUNFSVZFX0ZFRSA9IFJFQ0VJVkVfRkVFO1xudmFyIFJFQ0VJVkVfV09SRCA9ICd1aS1yZWNlaXZlX3dvcmQnO1xuZXhwb3J0cy5SRUNFSVZFX1dPUkQgPSBSRUNFSVZFX1dPUkQ7XG52YXIgQ0hBTkdFX1NFVFRJTkdTID0gJ3VpLWNoYW5nZV9zZXR0aW5ncyc7XG5leHBvcnRzLkNIQU5HRV9TRVRUSU5HUyA9IENIQU5HRV9TRVRUSU5HUztcbnZhciBDVVNUT01fTUVTU0FHRV9SRVFVRVNUID0gJ3VpLWN1c3RvbV9yZXF1ZXN0JztcbmV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVRVUVTVCA9IENVU1RPTV9NRVNTQUdFX1JFUVVFU1Q7XG52YXIgQ1VTVE9NX01FU1NBR0VfUkVTUE9OU0UgPSAndWktY3VzdG9tX3Jlc3BvbnNlJztcbmV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVTUE9OU0UgPSBDVVNUT01fTUVTU0FHRV9SRVNQT05TRTtcbnZhciBMT0dJTl9DSEFMTEVOR0VfUkVRVUVTVCA9ICd1aS1sb2dpbl9jaGFsbGVuZ2VfcmVxdWVzdCc7XG5leHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVFVRVNUID0gTE9HSU5fQ0hBTExFTkdFX1JFUVVFU1Q7XG52YXIgTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFID0gJ3VpLWxvZ2luX2NoYWxsZW5nZV9yZXNwb25zZSc7XG5leHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVNQT05TRSA9IExPR0lOX0NIQUxMRU5HRV9SRVNQT05TRTtcbnZhciBCVU5ETEVfUFJPR1JFU1MgPSAndWktYnVuZGxlX3Byb2dyZXNzJztcbmV4cG9ydHMuQlVORExFX1BST0dSRVNTID0gQlVORExFX1BST0dSRVNTO1xudmFyIEFERFJFU1NfVkFMSURBVElPTiA9ICd1aS1hZGRyZXNzX3ZhbGlkYXRpb24nO1xuZXhwb3J0cy5BRERSRVNTX1ZBTElEQVRJT04gPSBBRERSRVNTX1ZBTElEQVRJT047XG52YXIgSUZSQU1FX0ZBSUxVUkUgPSAndWktaWZyYW1lX2ZhaWx1cmUnO1xuZXhwb3J0cy5JRlJBTUVfRkFJTFVSRSA9IElGUkFNRV9GQUlMVVJFOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5GSUFUX1JBVEVTX1VQREFURSA9IGV4cG9ydHMuTk9USUZJQ0FUSU9OID0gZXhwb3J0cy5CTE9DSyA9IGV4cG9ydHMuQ09OTkVDVCA9IGV4cG9ydHMuRVJST1IgPSB2b2lkIDA7XG4vLyBibG9ja2NoYWluIGV2ZW50c1xudmFyIEVSUk9SID0gJ2Jsb2NrY2hhaW4tZXJyb3InO1xuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xudmFyIENPTk5FQ1QgPSAnYmxvY2tjaGFpbi1jb25uZWN0JztcbmV4cG9ydHMuQ09OTkVDVCA9IENPTk5FQ1Q7XG52YXIgQkxPQ0sgPSAnYmxvY2tjaGFpbi1ibG9jayc7XG5leHBvcnRzLkJMT0NLID0gQkxPQ0s7XG52YXIgTk9USUZJQ0FUSU9OID0gJ2Jsb2NrY2hhaW4tbm90aWZpY2F0aW9uJztcbmV4cG9ydHMuTk9USUZJQ0FUSU9OID0gTk9USUZJQ0FUSU9OO1xudmFyIEZJQVRfUkFURVNfVVBEQVRFID0gJ2ZpYXQtcmF0ZXMtdXBkYXRlJztcbmV4cG9ydHMuRklBVF9SQVRFU19VUERBVEUgPSBGSUFUX1JBVEVTX1VQREFURTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0xPU0VfV0lORE9XID0gZXhwb3J0cy5DQU5DRUxfUE9QVVBfUkVRVUVTVCA9IGV4cG9ydHMuQ0xPU0VEID0gZXhwb3J0cy5IQU5EU0hBS0UgPSBleHBvcnRzLkVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMgPSBleHBvcnRzLkVSUk9SID0gZXhwb3J0cy5JTklUID0gZXhwb3J0cy5MT0FERUQgPSBleHBvcnRzLkJPT1RTVFJBUCA9IHZvaWQgMDtcbi8vIE1lc3NhZ2UgY2FsbGVkIGZyb20gcG9wdXAuaHRtbCBpbmxpbmUgc2NyaXB0IGJlZm9yZSBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gcG9wdXAgdG8gd2luZG93Lm9wZW5lci5cbnZhciBCT09UU1RSQVAgPSAncG9wdXAtYm9vdHN0cmFwJzsgLy8gTWVzc2FnZSBmcm9tIHBvcHVwLmpzIHRvIHdpbmRvdy5vcGVuZXIsIGNhbGxlZCBhZnRlciBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBzZWNvbmQgbWVzc2FnZSBmcm9tIHBvcHVwIHRvIHdpbmRvdy5vcGVuZXIuXG5cbmV4cG9ydHMuQk9PVFNUUkFQID0gQk9PVFNUUkFQO1xudmFyIExPQURFRCA9ICdwb3B1cC1sb2FkZWQnOyAvLyBNZXNzYWdlIGZyb20gd2luZG93Lm9wZW5lciB0byBwb3B1cC5qcy4gU2VuZCBzZXR0aW5ncyB0byBwb3B1cC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gd2luZG93Lm9wZW5lciB0byBwb3B1cC5cblxuZXhwb3J0cy5MT0FERUQgPSBMT0FERUQ7XG52YXIgSU5JVCA9ICdwb3B1cC1pbml0JzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIHBvcHVwIHRvIHdpbmRvdy5vcGVuZXIuIENvdWxkIGJlIHRocm93biBkdXJpbmcgcG9wdXAgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyAoUE9QVVAuSU5JVClcblxuZXhwb3J0cy5JTklUID0gSU5JVDtcbnZhciBFUlJPUiA9ICdwb3B1cC1lcnJvcic7IC8vIE1lc3NhZ2UgdG8gd2ViZXh0ZW5zaW9ucywgb3BlbnMgXCJ0cmV6b3ItdXNiLXBlcm1pc3Npb24uaHRtbFwiIHdpdGhpbiB3ZWJleHRlbnNpb25cblxuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xudmFyIEVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMgPSAnb3Blbi11c2ItcGVybWlzc2lvbnMnOyAvLyBNZXNzYWdlIGNhbGxlZCBmcm9tIGJvdGggW3BvcHVwID4gaWZyYW1lXSB0aGVuIFtpZnJhbWUgPiBwb3B1cF0gaW4gdGhpcyBleGFjdCBvcmRlci5cbi8vIEZpcnN0bHkgcG9wdXAgY2FsbCBpZnJhbWUgdG8gcmVzb2x2ZSBwb3B1cCBwcm9taXNlIGluIENvcmVcbi8vIFRoZW4gaWZyYW1lIHJlYWN0cyB0byBQT1BVUC5IQU5EU0hBS0UgbWVzc2FnZSBhbmQgc2VuZHMgQ29ubmVjdFNldHRpbmdzLCB0cmFuc3BvcnQgaW5mb3JtYXRpb24gYW5kIHJlcXVlc3RlZCBtZXRob2QgZGV0YWlscyBiYWNrIHRvIHBvcHVwXG5cbmV4cG9ydHMuRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUyA9IEVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlM7XG52YXIgSEFORFNIQUtFID0gJ3BvcHVwLWhhbmRzaGFrZSc7IC8vIEV2ZW50IGVtaXR0ZWQgZnJvbSBQb3B1cE1hbmFnZXIgYXQgdGhlIGVuZCBvZiBwb3B1cCBjbG9zaW5nIHByb2Nlc3MuXG4vLyBTZW50IGZyb20gcG9wdXAgdGhydSB3aW5kb3cub3BlbmVyIHRvIGFuIGlmcmFtZSBiZWNhdXNlIG1lc3NhZ2UgY2hhbm5lbCBiZXR3ZWVuIHBvcHVwIGFuZCBpZnJhbWUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZVxuXG5leHBvcnRzLkhBTkRTSEFLRSA9IEhBTkRTSEFLRTtcbnZhciBDTE9TRUQgPSAncG9wdXAtY2xvc2VkJzsgLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpZnJhbWUgdG8gcG9wdXAsIGl0IG1lYW5zIHRoYXQgcG9wdXAgd2lsbCBub3QgYmUgbmVlZGVkIChleGFtcGxlOiBCbG9ja2NoYWluIG1ldGhvZHMgYXJlIG5vdCB1c2luZyBwb3B1cCBhdCBhbGwpXG4vLyBUaGlzIHdpbGwgY2xvc2UgYWN0aXZlIHBvcHVwIHdpbmRvdyBhbmQvb3IgY2xlYXIgb3BlbmluZyBwcm9jZXNzIGluIFBvcHVwTWFuYWdlciAobWF5YmUgcG9wdXAgd2Fzbid0IG9wZW5lZCB5ZXQpXG5cbmV4cG9ydHMuQ0xPU0VEID0gQ0xPU0VEO1xudmFyIENBTkNFTF9QT1BVUF9SRVFVRVNUID0gJ3VpLWNhbmNlbC1wb3B1cC1yZXF1ZXN0JzsgLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpbmxpbmUgZWxlbWVudCBpbiBwb3B1cC5odG1sICh3aW5kb3cuY2xvc2VXaW5kb3cpLCB0aGlzIGlzIHVzZWQgb25seSB3aXRoIHdlYmV4dGVuc2lvbnMgdG8gcHJvcGVybHkgaGFuZGxlIHBvcHVwIGNsb3NlIGV2ZW50XG5cbmV4cG9ydHMuQ0FOQ0VMX1BPUFVQX1JFUVVFU1QgPSBDQU5DRUxfUE9QVVBfUkVRVUVTVDtcbnZhciBDTE9TRV9XSU5ET1cgPSAnd2luZG93LmNsb3NlJztcbmV4cG9ydHMuQ0xPU0VfV0lORE9XID0gQ0xPU0VfV0lORE9XOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5QT09MX1JFTEFZX1RZUEUgPSBleHBvcnRzLkNFUlRJRklDQVRFX1RZUEUgPSBleHBvcnRzLkFERFJFU1NfVFlQRSA9IGV4cG9ydHMuTkVUV09SS19JRFMgPSBleHBvcnRzLlBST1RPQ09MX01BR0lDUyA9IHZvaWQgMDtcbnZhciBQUk9UT0NPTF9NQUdJQ1MgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFpbm5ldDogNzY0ODI0MDczLFxuICB0ZXN0bmV0OiA0MlxufSk7XG5leHBvcnRzLlBST1RPQ09MX01BR0lDUyA9IFBST1RPQ09MX01BR0lDUztcbnZhciBORVRXT1JLX0lEUyA9IE9iamVjdC5mcmVlemUoe1xuICBtYWlubmV0OiAxLFxuICB0ZXN0bmV0OiAwXG59KTsgLy8gY29uc3RhbnRzIGJlbG93IGFyZSBkZXByZWNhdGVkXG4vLyB1c2UgYENhcmRhbm9BZGRyZXNzVHlwZWAsIGBDYXJkYW5vQ2VydGlmaWNhdGVUeXBlYCBhbmQgYENhcmRhbm9Qb29sUmVsYXlUeXBlYCBmcm9tIHByb3RvYnVmIGluc3RlYWRcblxuZXhwb3J0cy5ORVRXT1JLX0lEUyA9IE5FVFdPUktfSURTO1xudmFyIEFERFJFU1NfVFlQRSA9IE9iamVjdC5mcmVlemUoe1xuICBCYXNlOiAwLFxuICBQb2ludGVyOiA0LFxuICBFbnRlcnByaXNlOiA2LFxuICBCeXJvbjogOCxcbiAgUmV3YXJkOiAxNFxufSk7XG5leHBvcnRzLkFERFJFU1NfVFlQRSA9IEFERFJFU1NfVFlQRTtcbnZhciBDRVJUSUZJQ0FURV9UWVBFID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlUmVnaXN0cmF0aW9uOiAwLFxuICBTdGFrZURlcmVnaXN0cmF0aW9uOiAxLFxuICBTdGFrZURlbGVnYXRpb246IDIsXG4gIFN0YWtlUG9vbFJlZ2lzdHJhdGlvbjogM1xufSk7XG5leHBvcnRzLkNFUlRJRklDQVRFX1RZUEUgPSBDRVJUSUZJQ0FURV9UWVBFO1xudmFyIFBPT0xfUkVMQVlfVFlQRSA9IE9iamVjdC5mcmVlemUoe1xuICBTaW5nbGVIb3N0SXA6IDAsXG4gIFNpbmdsZUhvc3ROYW1lOiAxLFxuICBNdWx0aXBsZUhvc3ROYW1lOiAyXG59KTtcbmV4cG9ydHMuUE9PTF9SRUxBWV9UWVBFID0gUE9PTF9SRUxBWV9UWVBFOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuTElCVVNCX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLldFQlVTQl9FUlJPUl9NRVNTQUdFID0gZXhwb3J0cy5JTlZBTElEX1BJTl9FUlJPUl9NRVNTQUdFID0gZXhwb3J0cy5XUk9OR19QUkVWSU9VU19TRVNTSU9OX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLlR5cGVkRXJyb3IgPSBleHBvcnRzLlRyZXpvckVycm9yID0gZXhwb3J0cy5FUlJPUl9DT0RFUyA9IHZvaWQgMDtcblxudmFyIF9pbmhlcml0c0xvb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZVwiKSk7XG5cbnZhciBfd3JhcE5hdGl2ZVN1cGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyXCIpKTtcblxudmFyIEVSUk9SX0NPREVTID0ge1xuICBJbml0X05vdEluaXRpYWxpemVkOiAnVHJlem9yQ29ubmVjdCBub3QgeWV0IGluaXRpYWxpemVkJyxcbiAgLy8gcmFjZSBjb25kaXRpb246IGNhbGwgb24gbm90IGluaXRpYWxpemVkIENvcmUgKHVzdWFsbHkgaG90LXJlbG9hZGluZylcbiAgSW5pdF9BbHJlYWR5SW5pdGlhbGl6ZWQ6ICdUcmV6b3JDb25uZWN0IGhhcyBiZWVuIGFscmVhZHkgaW5pdGlhbGl6ZWQnLFxuICAvLyB0aHJvd24gYnkgLmluaXQgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gIEluaXRfSWZyYW1lQmxvY2tlZDogJ0lmcmFtZSBibG9ja2VkJyxcbiAgLy8gaWZyYW1lIGluamVjdGlvbiBibG9ja2VkIChhZC1ibG9ja2VyKVxuICBJbml0X0lmcmFtZVRpbWVvdXQ6ICdJZnJhbWUgdGltZW91dCcsXG4gIC8vIGlmcmFtZSBkaWRuJ3QgbG9hZCBpbiBzcGVjaWZpZWQgdGltZVxuICBJbml0X01hbmlmZXN0TWlzc2luZzogJ01hbmlmZXN0IG5vdCBzZXQuIFJlYWQgbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdHJlem9yL2Nvbm5lY3QvYmxvYi9kZXZlbG9wL2RvY3MvaW5kZXgubWQnLFxuICAvLyBtYW5pZmVzdCBpcyBub3Qgc2V0XG4gIFBvcHVwX0Nvbm5lY3Rpb25NaXNzaW5nOiAnVW5hYmxlIHRvIGVzdGFibGlzaCBjb25uZWN0aW9uIHdpdGggaWZyYW1lJyxcbiAgLy8gdGhyb3duIGJ5IHBvcHVwXG4gIFRyYW5zcG9ydF9NaXNzaW5nOiAnVHJhbnNwb3J0IGlzIG1pc3NpbmcnLFxuICAvLyBubyB0cmFuc3BvcnQgYXZhaWxhYmxlXG4gIFRyYW5zcG9ydF9JbnZhbGlkUHJvdG9idWY6ICcnLFxuICAvLyBnZW5lcmljIGVycm9yIGZyb20gdHJhbnNwb3J0IGxheWVyICh0cmV6b3ItbGluaylcbiAgTWV0aG9kX0ludmFsaWRQYWNrYWdlOiAnVGhpcyB2ZXJzaW9uIG9mIHRyZXpvci1jb25uZWN0IGlzIG5vdCBzdWl0YWJsZSB0byB3b3JrIHdpdGhvdXQgYnJvd3Nlci4gVXNlIHRyZXpvci1jb25uZWN0QGV4dGVuZGVkIHBhY2thZ2UgaW5zdGVhZCcsXG4gIC8vIHRocm93biBieSBub2RlIGFuZCByZWFjdC1uYXRpdmUgZW52IHdoaWxlIHVzaW5nIHJlZ3VsYXIgJ3dlYicgcGFja2FnZVxuICBNZXRob2RfSW52YWxpZFBhcmFtZXRlcjogJycsXG4gIC8vIHJlcGxhY2VkIGJ5IGdlbmVyaWMgdGV4dFxuICBNZXRob2RfTm90QWxsb3dlZDogJ01ldGhvZCBub3QgYWxsb3dlZCBmb3IgdGhpcyBjb25maWd1cmF0aW9uJyxcbiAgLy8gZXhhbXBsZTogZGV2aWNlIG1hbmFnZW1lbnQgaW4gcG9wdXAgbW9kZVxuICBNZXRob2RfUGVybWlzc2lvbnNOb3RHcmFudGVkOiAnUGVybWlzc2lvbnMgbm90IGdyYW50ZWQnLFxuICAvLyBwZXJtaXNzaW9uL2NvbmZpcm1hdGlvbiBub3QgZ3JhbnRlZCBpbiBwb3B1cFxuICBNZXRob2RfQ2FuY2VsOiAnQ2FuY2VsbGVkJyxcbiAgLy8gcGVybWlzc2lvbi9jb25maXJtYXRpb24gbm90IGdyYW50ZWQgaW4gcG9wdXAgT1IgLmNhbmNlbCgpIGN1c3RvbSBlcnJvclxuICBNZXRob2RfSW50ZXJydXB0ZWQ6ICdQb3B1cCBjbG9zZWQnLFxuICAvLyBpbnRlcnJ1cHRpb246IHBvcHVwIGNsb3NlZFxuICBNZXRob2RfVW5rbm93bkNvaW46ICdDb2luIG5vdCBmb3VuZCcsXG4gIC8vIGNvaW4gZGVmaW5pdGlvbiBub3QgZm91bmRcbiAgTWV0aG9kX0FkZHJlc3NOb3RNYXRjaDogJ0FkZHJlc3NlcyBkbyBub3QgbWF0Y2gnLFxuICAvLyB0aHJvd24gYnkgYWxsIGdldEFkZHJlc3MgbWV0aG9kcyB3aXRoIGN1c3RvbSBVSSB2YWxpZGF0aW9uXG4gIE1ldGhvZF9GaXJtd2FyZVVwZGF0ZV9Eb3dubG9hZEZhaWxlZDogJ0ZhaWxlZCB0byBkb3dubG9hZCBmaXJtd2FyZSBiaW5hcnknLFxuICAvLyB0aHJvd24gYnkgRmlybXdhcmVVcGRhdGUgbWV0aG9kXG4gIE1ldGhvZF9DdXN0b21NZXNzYWdlX0NhbGxiYWNrOiAnUGFyYW1ldGVyIFwiY2FsbGJhY2tcIiBpcyBub3QgYSBmdW5jdGlvbicsXG4gIC8vIHRocm93biBieSBDdXN0b21NZXNzYWdlIG1ldGhvZFxuICBNZXRob2RfRGlzY292ZXJ5X0J1bmRsZUV4Y2VwdGlvbjogJycsXG4gIC8vIHRocm93biBieSBnZXRBY2NvdW50SW5mbyBtZXRob2RcbiAgTWV0aG9kX092ZXJyaWRlOiAnb3ZlcnJpZGUnLFxuICAvLyBpbm5lciBcImVycm9yXCIsIGl0J3MgbW9yZSBsaWtlIGEgaW50ZXJydXB0aW9uXG4gIE1ldGhvZF9Ob1Jlc3BvbnNlOiAnQ2FsbCByZXNvbHZlZCB3aXRob3V0IHJlc3BvbnNlJyxcbiAgLy8gdGhyb3duIGJ5IG5wbSBpbmRleChlcyksIGNhbGwgdG8gQ29yZSByZXNvbHZlZCB3aXRob3V0IHJlc3BvbnNlLCBzaG91bGQgbm90IGhhcHBlblxuICBCYWNrZW5kX05vdFN1cHBvcnRlZDogJ0Jsb2NrY2hhaW5MaW5rIHNldHRpbmdzIG5vdCBmb3VuZCBpbiBjb2lucy5qc29uJyxcbiAgLy8gdGhyb3duIGJ5IG1ldGhvZHMgd2hpY2ggdXNpbmcgYmFja2VuZHMsIGJsb2NrY2hhaW5MaW5rIG5vdCBkZWZpbmVkIGZvciB0aGlzIGNvaW5cbiAgQmFja2VuZF9Xb3JrZXJNaXNzaW5nOiAnJyxcbiAgLy8gdGhyb3duIGJ5IEJsb2NrY2hhaW5MaW5rIGNsYXNzLCB3b3JrZXIgbm90IHNwZWNpZmllZFxuICBCYWNrZW5kX0Rpc2Nvbm5lY3RlZDogJ0JhY2tlbmQgZGlzY29ubmVjdGVkJyxcbiAgLy8gdGhyb3duIGJ5IEJsb2NrY2hhaW5MaW5rIGNsYXNzXG4gIEJhY2tlbmRfSW52YWxpZDogJ0ludmFsaWQgYmFja2VuZCcsXG4gIC8vIHRocm93biBieSBCbG9ja2NoYWluTGluayBjbGFzcywgaW52YWxpZCBiYWNrZW5kIChpZTogYmFja2VuZCBmb3Igd3JvbmcgY29pbiBzZXQpXG4gIEJhY2tlbmRfRXJyb3I6ICcnLFxuICAvLyB0aHJvd24gYnkgQmxvY2tjaGFpbkxpbmsgY2xhc3MsIGdlbmVyaWMgbWVzc2FnZSBmcm9tICdibG9ja2NoYWluLWxpbmsnXG4gIFJ1bnRpbWU6ICcnLFxuICAvLyB0aHJvd24gZnJvbSBzZXZlcmFsIHBsYWNlcywgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gdGhvXG4gIERldmljZV9Ob3RGb3VuZDogJ0RldmljZSBub3QgZm91bmQnLFxuICBEZXZpY2VfSW5pdGlhbGl6ZUZhaWxlZDogJycsXG4gIC8vIGdlbmVyaWMgZXJyb3IgZnJvbSBmaXJtd2FyZSB3aGlsZSBjYWxsaW5nIFwiSW5pdGlhbGl6ZVwiIG1lc3NhZ2VcbiAgRGV2aWNlX0Z3RXhjZXB0aW9uOiAnJyxcbiAgLy8gZ2VuZXJpYyBGaXJtd2FyZUV4Y2VwdGlvbiB0eXBlXG4gIERldmljZV9Nb2RlRXhjZXB0aW9uOiAnJyxcbiAgLy8gZ2VuZXJpYyBEZXZpY2UuVW5leHBlY3RlZE1vZGUgdHlwZVxuICBEZXZpY2VfRGlzY29ubmVjdGVkOiAnRGV2aWNlIGRpc2Nvbm5lY3RlZCcsXG4gIC8vIGRldmljZSBkaXNjb25uZWN0ZWQgZHVyaW5nIGNhbGxcbiAgRGV2aWNlX1VzZWRFbHNld2hlcmU6ICdEZXZpY2UgaXMgdXNlZCBpbiBhbm90aGVyIHdpbmRvdycsXG4gIC8vIGludGVycnVwdGlvbjogY3VycmVudCBzZXNzaW9uIHRva2VkIGJ5IG90aGVyIGFwcGxpY2F0aW9uXG4gIERldmljZV9JbnZhbGlkU3RhdGU6ICdQYXNzcGhyYXNlIGlzIGluY29ycmVjdCcsXG4gIC8vIGF1dGhvcml6YXRpb24gZXJyb3IgKGRldmljZSBzdGF0ZSBjb21wYXJpc29uKVxuICBEZXZpY2VfQ2FsbEluUHJvZ3Jlc3M6ICdEZXZpY2UgY2FsbCBpbiBwcm9ncmVzcycgLy8gdGhyb3duIHdoZW4gdHJ5aW5nIHRvIG1ha2UgYW5vdGhlciBjYWxsIHdoaWxlIGN1cnJlbnQgaXMgc3RpbGwgcnVubmluZ1xuXG59O1xuZXhwb3J0cy5FUlJPUl9DT0RFUyA9IEVSUk9SX0NPREVTO1xuXG52YXIgVHJlem9yRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICAoMCwgX2luaGVyaXRzTG9vc2UyW1wiZGVmYXVsdFwiXSkoVHJlem9yRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gVHJlem9yRXJyb3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVHJlem9yRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovKDAsIF93cmFwTmF0aXZlU3VwZXIyW1wiZGVmYXVsdFwiXSkoRXJyb3IpKTtcblxuZXhwb3J0cy5UcmV6b3JFcnJvciA9IFRyZXpvckVycm9yO1xuXG52YXIgVHlwZWRFcnJvciA9IGZ1bmN0aW9uIFR5cGVkRXJyb3IoaWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUcmV6b3JFcnJvcihpZCwgbWVzc2FnZSB8fCBFUlJPUl9DT0RFU1tpZF0pO1xufTsgLy8gYSBzbGlnaHQgaGFja1xuLy8gdGhpcyBlcnJvciBzdHJpbmcgaXMgaGFyZC1jb2RlZFxuLy8gaW4gYm90aCBicmlkZ2UgYW5kIGV4dGVuc2lvblxuXG5cbmV4cG9ydHMuVHlwZWRFcnJvciA9IFR5cGVkRXJyb3I7XG52YXIgV1JPTkdfUFJFVklPVVNfU0VTU0lPTl9FUlJPUl9NRVNTQUdFID0gJ3dyb25nIHByZXZpb3VzIHNlc3Npb24nO1xuZXhwb3J0cy5XUk9OR19QUkVWSU9VU19TRVNTSU9OX0VSUk9SX01FU1NBR0UgPSBXUk9OR19QUkVWSU9VU19TRVNTSU9OX0VSUk9SX01FU1NBR0U7XG52YXIgSU5WQUxJRF9QSU5fRVJST1JfTUVTU0FHRSA9ICdQSU4gaW52YWxpZCc7XG5leHBvcnRzLklOVkFMSURfUElOX0VSUk9SX01FU1NBR0UgPSBJTlZBTElEX1BJTl9FUlJPUl9NRVNTQUdFO1xudmFyIFdFQlVTQl9FUlJPUl9NRVNTQUdFID0gJ05ldHdvcmtFcnJvcjogVW5hYmxlIHRvIGNsYWltIGludGVyZmFjZS4nOyAvLyB0cmV6b3JkIGVycm9yIHByZWZpeC5cbi8vIHVzZXIgaGFzIGluc3VmZmljaWVudCBwZXJtaXNzaW9ucy4gbWF5IG9jY3VyIGluIExpbnV4IChtaXNzaW5nIHVkZXYgcnVsZXMpLCBXaW5kb3dzIGFuZCBNYWNPUy5cblxuZXhwb3J0cy5XRUJVU0JfRVJST1JfTUVTU0FHRSA9IFdFQlVTQl9FUlJPUl9NRVNTQUdFO1xudmFyIExJQlVTQl9FUlJPUl9NRVNTQUdFID0gJ0xJQlVTQl9FUlJPUic7XG5leHBvcnRzLkxJQlVTQl9FUlJPUl9NRVNTQUdFID0gTElCVVNCX0VSUk9SX01FU1NBR0U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjbGFzc05hbWUsIHVybCwgb3JpZ2luKSB7XG4gIHZhciBxdWVyeSA9IGNsYXNzTmFtZSB8fCAnLnRyZXpvci13ZWJ1c2ItYnV0dG9uJztcbiAgdmFyIGJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbiAgdmFyIHNyYyA9IHVybCArIFwiP1wiICsgRGF0ZS5ub3coKTtcbiAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lmcmFtZScpLmxlbmd0aCA8IDEpIHtcbiAgICAgIHZhciBib3VuZHMgPSBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGJ0bklmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgYnRuSWZyYW1lLmZyYW1lQm9yZGVyID0gJzAnO1xuICAgICAgYnRuSWZyYW1lLndpZHRoID0gTWF0aC5yb3VuZChib3VuZHMud2lkdGgpICsgXCJweFwiO1xuICAgICAgYnRuSWZyYW1lLmhlaWdodCA9IE1hdGgucm91bmQoYm91bmRzLmhlaWdodCkgKyBcInB4XCI7XG4gICAgICBidG5JZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgYnRuSWZyYW1lLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgYnRuSWZyYW1lLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgIGJ0bklmcmFtZS5zdHlsZS56SW5kZXggPSAnMSc7IC8vIGJ0bklmcmFtZS5zdHlsZS5vcGFjaXR5ID0gJzAnOyAvLyB0aGlzIG1ha2VzIGNsaWNrIGltcG9zc2libGUgb24gY3Jvc3Mtb3JpZ2luXG5cbiAgICAgIGJ0bklmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93JywgJ3VzYicpO1xuICAgICAgYnRuSWZyYW1lLnNldEF0dHJpYnV0ZSgnc2Nyb2xsaW5nJywgJ25vJyk7XG5cbiAgICAgIGJ0bklmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ0bklmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHsvLyBzdHlsZTogSlNPTi5zdHJpbmdpZnkoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGIpICksXG4gICAgICAgICAgLy8gb3V0ZXI6IGIub3V0ZXJIVE1MLFxuICAgICAgICAgIC8vIGlubmVyOiBiLmlubmVySFRNTFxuICAgICAgICB9LCBvcmlnaW4pO1xuICAgICAgfTtcblxuICAgICAgYnRuSWZyYW1lLnNyYyA9IHNyYzsgLy8gaW5qZWN0IGlmcmFtZSBpbnRvIGJ1dHRvblxuXG4gICAgICBiLmFwcGVuZChidG5JZnJhbWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSByZW5kZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5nZXRMb2cgPSBleHBvcnRzLmVuYWJsZUxvZ0J5UHJlZml4ID0gZXhwb3J0cy5lbmFibGVMb2cgPSBleHBvcnRzLmluaXRMb2cgPSB2b2lkIDA7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbnZhciBjb2xvcnMgPSB7XG4gIC8vIGdyZWVuXG4gIERlc2NyaXB0b3JTdHJlYW06ICdjb2xvcjogIzc3YWI1OScsXG4gIERldmljZUxpc3Q6ICdjb2xvcjogIzM2ODAyZCcsXG4gIERldmljZTogJ2NvbG9yOiAjYmFkYTU1JyxcbiAgQ29yZTogJ2NvbG9yOiAjYzlkZjhhJyxcbiAgSUZyYW1lOiAnY29sb3I6ICNGRkZGRkY7IGJhY2tncm91bmQ6ICNmNGE3NDI7JyxcbiAgUG9wdXA6ICdjb2xvcjogI2Y0OGEwMCdcbn07XG52YXIgTUFYX0VOVFJJRVMgPSAxMDA7XG5cbnZhciBMb2cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb2cocHJlZml4LCBlbmFibGVkKSB7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5jc3MgPSBjb2xvcnNbcHJlZml4XSB8fCAnY29sb3I6ICMwMDAwMDA7IGJhY2tncm91bmQ6ICNGRkZGRkY7JztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2cucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRNZXNzYWdlID0gZnVuY3Rpb24gYWRkTWVzc2FnZShsZXZlbCwgcHJlZml4KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYXJncyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm1lc3NhZ2VzLmxlbmd0aCA+IE1BWF9FTlRSSUVTKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2cgPSBmdW5jdGlvbiBsb2coKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNZXNzYWdlLmFwcGx5KHRoaXMsIFsnbG9nJywgdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgW3RoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1lc3NhZ2UuYXBwbHkodGhpcywgWydlcnJvcicsIHRoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdmFyIF9jb25zb2xlMjtcblxuICAgICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlMiwgW3RoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ud2FybiA9IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNZXNzYWdlLmFwcGx5KHRoaXMsIFsnd2FybicsIHRoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdmFyIF9jb25zb2xlMztcblxuICAgICAgKF9jb25zb2xlMyA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUzLCBbdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWVzc2FnZS5hcHBseSh0aGlzLCBbJ2RlYnVnJywgdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB2YXIgX2NvbnNvbGU0O1xuXG4gICAgICAoX2NvbnNvbGU0ID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlNCwgW1wiJWNcIiArIHRoaXMucHJlZml4LCB0aGlzLmNzc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExvZztcbn0oKTtcblxudmFyIF9sb2dzID0ge307XG5cbnZhciBpbml0TG9nID0gZnVuY3Rpb24gaW5pdExvZyhwcmVmaXgsIGVuYWJsZWQpIHtcbiAgdmFyIGluc3RhbmNlID0gbmV3IExvZyhwcmVmaXgsICEhZW5hYmxlZCk7XG4gIF9sb2dzW3ByZWZpeF0gPSBpbnN0YW5jZTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuZXhwb3J0cy5pbml0TG9nID0gaW5pdExvZztcblxudmFyIGVuYWJsZUxvZyA9IGZ1bmN0aW9uIGVuYWJsZUxvZyhlbmFibGVkKSB7XG4gIE9iamVjdC5rZXlzKF9sb2dzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBfbG9nc1trZXldLmVuYWJsZWQgPSBlbmFibGVkO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZW5hYmxlTG9nID0gZW5hYmxlTG9nO1xuXG52YXIgZW5hYmxlTG9nQnlQcmVmaXggPSBmdW5jdGlvbiBlbmFibGVMb2dCeVByZWZpeChwcmVmaXgsIGVuYWJsZWQpIHtcbiAgaWYgKF9sb2dzW3ByZWZpeF0pIHtcbiAgICBfbG9nc1twcmVmaXhdLmVuYWJsZWQgPSBlbmFibGVkO1xuICB9XG59O1xuXG5leHBvcnRzLmVuYWJsZUxvZ0J5UHJlZml4ID0gZW5hYmxlTG9nQnlQcmVmaXg7XG5cbnZhciBnZXRMb2cgPSBmdW5jdGlvbiBnZXRMb2coKSB7XG4gIHZhciBsb2dzID0gW107XG4gIE9iamVjdC5rZXlzKF9sb2dzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBsb2dzID0gbG9ncy5jb25jYXQoX2xvZ3Nba2V5XS5tZXNzYWdlcyk7XG4gIH0pO1xuICBsb2dzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcDtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufTtcblxuZXhwb3J0cy5nZXRMb2cgPSBnZXRMb2c7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmVycm9yTWVzc2FnZSA9IGV4cG9ydHMucGFyc2VNZXNzYWdlID0gdm9pZCAwO1xuXG4vLyBwYXJzZSBNZXNzYWdlRXZlbnQgLmRhdGEgaW50byBDb3JlTWVzc2FnZVxudmFyIHBhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShtZXNzYWdlRGF0YSkge1xuICB2YXIgbWVzc2FnZSA9IHtcbiAgICBldmVudDogbWVzc2FnZURhdGEuZXZlbnQsXG4gICAgdHlwZTogbWVzc2FnZURhdGEudHlwZSxcbiAgICBwYXlsb2FkOiBtZXNzYWdlRGF0YS5wYXlsb2FkXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlRGF0YS5pZCA9PT0gJ251bWJlcicpIHtcbiAgICBtZXNzYWdlLmlkID0gbWVzc2FnZURhdGEuaWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2VEYXRhLnN1Y2Nlc3MgPT09ICdib29sZWFuJykge1xuICAgIG1lc3NhZ2Uuc3VjY2VzcyA9IG1lc3NhZ2VEYXRhLnN1Y2Nlc3M7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn07IC8vIGNvbW1vbiByZXNwb25zZSB1c2VkIHN0cmFpZ2h0IGZyb20gbnBtIGluZGV4IChub3QgZnJvbSBDb3JlKVxuXG5cbmV4cG9ydHMucGFyc2VNZXNzYWdlID0gcGFyc2VNZXNzYWdlO1xuXG52YXIgZXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgcGF5bG9hZDoge1xuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlXG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfaW5oZXJpdHNMb29zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2VcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2V2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImV2ZW50c1wiKSk7XG5cbnZhciBQT1BVUCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9jb25zdGFudHMvcG9wdXBcIikpO1xuXG52YXIgSUZSQU1FID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2NvbnN0YW50cy9pZnJhbWVcIikpO1xuXG52YXIgVUkgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vY29uc3RhbnRzL3VpXCIpKTtcblxudmFyIF9zaG93UG9wdXBSZXF1ZXN0ID0gcmVxdWlyZShcIi4vc2hvd1BvcHVwUmVxdWVzdFwiKTtcblxudmFyIF9uZXR3b3JrVXRpbHMgPSByZXF1aXJlKFwiLi4vZW52L2Jyb3dzZXIvbmV0d29ya1V0aWxzXCIpO1xuXG52YXIgX2RlZmVycmVkID0gcmVxdWlyZShcIi4uL3V0aWxzL2RlZmVycmVkXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vLyBjb25zdCBQT1BVUF9SRVFVRVNUX1RJTUVPVVQgPSA2MDI7XG52YXIgUE9QVVBfUkVRVUVTVF9USU1FT1VUID0gODUwO1xudmFyIFBPUFVQX0NMT1NFX0lOVEVSVkFMID0gNTAwO1xudmFyIFBPUFVQX09QRU5fVElNRU9VVCA9IDMwMDA7XG5cbnZhciBQb3B1cE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgKDAsIF9pbmhlcml0c0xvb3NlMltcImRlZmF1bHRcIl0pKFBvcHVwTWFuYWdlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgLy8gV2luZG93XG4gIGZ1bmN0aW9uIFBvcHVwTWFuYWdlcihzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcyksIFwicmVxdWVzdFRpbWVvdXRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcyksIFwiY2xvc2VJbnRlcnZhbFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSwgXCJleHRlbnNpb25UYWJJZFwiLCAwKTtcbiAgICBfdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIF90aGlzLm9yaWdpbiA9ICgwLCBfbmV0d29ya1V0aWxzLmdldE9yaWdpbikoc2V0dGluZ3MucG9wdXBTcmMpO1xuICAgIF90aGlzLmhhbmRsZU1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKTtcbiAgICBfdGhpcy5pZnJhbWVIYW5kc2hha2UgPSAoMCwgX2RlZmVycmVkLmNyZWF0ZSkoSUZSQU1FLkxPQURFRCk7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MuZW52ID09PSAnd2ViZXh0ZW5zaW9uJykge1xuICAgICAgX3RoaXMuaGFuZGxlRXh0ZW5zaW9uQ29ubmVjdCA9IF90aGlzLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QuYmluZCgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcykpO1xuICAgICAgX3RoaXMuaGFuZGxlRXh0ZW5zaW9uTWVzc2FnZSA9IF90aGlzLmhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UuYmluZCgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcykpOyAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuXG4gICAgICBjaHJvbWUucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIoX3RoaXMuaGFuZGxlRXh0ZW5zaW9uQ29ubmVjdCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfdGhpcy5oYW5kbGVNZXNzYWdlLCBmYWxzZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvcHVwTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGxhenlMb2FkKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAobGF6eUxvYWQgPT09IHZvaWQgMCkge1xuICAgICAgbGF6eUxvYWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBwb3B1cCByZXF1ZXN0XG4gICAgLy8gVE9ETzogaWUgLSBvcGVuIGltbWVkaWF0ZWx5IGFuZCBoaWRlIGl0IGJ1dCBwb3N0IGhhbmRzaGFrZSBhZnRlciB0aW1lb3V0XG4gICAgLy8gYnJpbmcgcG9wdXAgd2luZG93IHRvIGZyb250XG4gICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgIGNocm9tZS50YWJzLnVwZGF0ZSh0aGlzLl93aW5kb3cuaWQsIHtcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3dpbmRvdy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlbkZuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnN1cHBvcnRlZEJyb3dzZXIpIHtcbiAgICAgIG9wZW5GbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGltZW91dCA9IGxhenlMb2FkIHx8IHRoaXMuc2V0dGluZ3MuZW52ID09PSAnd2ViZXh0ZW5zaW9uJyA/IDEgOiBQT1BVUF9SRVFVRVNUX1RJTUVPVVQ7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucmVxdWVzdFRpbWVvdXQgPSAwO1xuICAgICAgICBvcGVuRm4obGF6eUxvYWQpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9O1xuXG4gIF9wcm90by51bmxvY2sgPSBmdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub3BlbiA9IGZ1bmN0aW9uIG9wZW4obGF6eUxvYWQpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBzcmMgPSB0aGlzLnNldHRpbmdzLnBvcHVwU3JjO1xuXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnN1cHBvcnRlZEJyb3dzZXIpIHtcbiAgICAgIHRoaXMub3BlbldyYXBwZXIoc3JjICsgXCIjdW5zdXBwb3J0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1cFByb21pc2UgPSAoMCwgX2RlZmVycmVkLmNyZWF0ZSkoUE9QVVAuTE9BREVEKTtcbiAgICB0aGlzLm9wZW5XcmFwcGVyKGxhenlMb2FkID8gc3JjICsgXCIjbG9hZGluZ1wiIDogc3JjKTtcbiAgICB0aGlzLmNsb3NlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpczMuX3dpbmRvdykgcmV0dXJuO1xuXG4gICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgY2hyb21lLnRhYnMuZ2V0KF90aGlzMy5fd2luZG93LmlkLCBmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgICAgaWYgKCF0YWIpIHtcbiAgICAgICAgICAgIF90aGlzMy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBfdGhpczMuZW1pdChQT1BVUC5DTE9TRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzMy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICBfdGhpczMuY2xvc2UoKTtcblxuICAgICAgICBfdGhpczMuZW1pdChQT1BVUC5DTE9TRUQpO1xuICAgICAgfVxuICAgIH0sIFBPUFVQX0NMT1NFX0lOVEVSVkFMKTsgLy8gb3BlbiB0aW1lb3V0IHdpbGwgYmUgY2FuY2VsbGVkIGJ5IFBPUFVQLkJPT1RTVFJBUCBtZXNzYWdlXG5cbiAgICB0aGlzLm9wZW5UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLmNsb3NlKCk7XG5cbiAgICAgICgwLCBfc2hvd1BvcHVwUmVxdWVzdC5zaG93UG9wdXBSZXF1ZXN0KShfdGhpczMub3Blbi5iaW5kKF90aGlzMyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgIH0pO1xuICAgIH0sIFBPUFVQX09QRU5fVElNRU9VVCk7XG4gIH07XG5cbiAgX3Byb3RvLm9wZW5XcmFwcGVyID0gZnVuY3Rpb24gb3BlbldyYXBwZXIodXJsKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbnYgPT09ICd3ZWJleHRlbnNpb24nKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgY2hyb21lLndpbmRvd3MuZ2V0Q3VycmVudChudWxsLCBmdW5jdGlvbiAoY3VycmVudFdpbmRvdykge1xuICAgICAgICAvLyBSZXF1ZXN0IGNvbWluZyBmcm9tIGV4dGVuc2lvbiBwb3B1cCxcbiAgICAgICAgLy8gY3JlYXRlIG5ldyB3aW5kb3cgYWJvdmUgaW5zdGVhZCBvZiBvcGVuaW5nIG5ldyB0YWJcbiAgICAgICAgaWYgKGN1cnJlbnRXaW5kb3cudHlwZSAhPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgIGNocm9tZS53aW5kb3dzLmNyZWF0ZSh7XG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChuZXdXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICAgICAgICBjaHJvbWUudGFicy5xdWVyeSh7XG4gICAgICAgICAgICAgIHdpbmRvd0lkOiBuZXdXaW5kb3cuaWQsXG4gICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHRhYnMpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgIF90aGlzNC5fd2luZG93ID0gdGFic1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICAgICAgY2hyb21lLnRhYnMucXVlcnkoe1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdzogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgICAgIH0sIGZ1bmN0aW9uICh0YWJzKSB7XG4gICAgICAgICAgICBfdGhpczQuZXh0ZW5zaW9uVGFiSWQgPSB0YWJzWzBdLmlkOyAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuXG4gICAgICAgICAgICBjaHJvbWUudGFicy5jcmVhdGUoe1xuICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgaW5kZXg6IHRhYnNbMF0uaW5kZXggKyAxXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgICAgICAgIF90aGlzNC5fd2luZG93ID0gdGFiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5lbnYgPT09ICdlbGVjdHJvbicpIHtcbiAgICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvdy5vcGVuKHVybCwgJ21vZGFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvdy5vcGVuKCcnLCAnX2JsYW5rJyk7XG5cbiAgICAgIGlmICh0aGlzLl93aW5kb3cpIHtcbiAgICAgICAgdGhpcy5fd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7IC8vIG90aGVyd2lzZSBhbmRyb2lkL2Nocm9tZSBsb29zZSB3aW5kb3cub3BlbmVyIHJlZmVyZW5jZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRXh0ZW5zaW9uQ29ubmVjdCA9IGZ1bmN0aW9uIGhhbmRsZUV4dGVuc2lvbkNvbm5lY3QocG9ydCkge1xuICAgIGlmIChwb3J0Lm5hbWUgIT09ICd0cmV6b3ItY29ubmVjdCcpIHJldHVybjtcblxuICAgIGlmICghdGhpcy5fd2luZG93IHx8IHRoaXMuX3dpbmRvdyAmJiB0aGlzLl93aW5kb3cuaWQgIT09IHBvcnQuc2VuZGVyLnRhYi5pZCkge1xuICAgICAgcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzaW5jZSBQT1BVUC5CT09UU1RSQVAgd2lsbCBub3QgYmUgaGFuZGxlZCBieSBcImhhbmRsZU1lc3NhZ2VcIiB3ZSBuZWVkIHRvIHRocmVhdCBcImNvbnRlbnQtc2NyaXB0XCIgY29ubmVjdGlvbiBhcyB0aGUgc2FtZSBldmVudFxuICAgIC8vIHBvcHVwIGlzIG9wZW5lZCBwcm9wZXJseSwgbm93IHdhaXQgZm9yIFBPUFVQLkxPQURFRCBtZXNzYWdlIChpbiB0aGlzIGNhc2UgaGFuZGxlZCBieSBcImhhbmRsZUV4dGVuc2lvbk1lc3NhZ2VcIilcblxuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLm9wZW5UaW1lb3V0KTtcbiAgICB0aGlzLmV4dGVuc2lvblBvcnQgPSBwb3J0OyAvLyAkRmxvd0lzc3VlIG5lZWQgdG8gdXBkYXRlIENocm9tZVBvcnQgZGVmaW5pdGlvblxuXG4gICAgdGhpcy5leHRlbnNpb25Qb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcih0aGlzLmhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVFeHRlbnNpb25NZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlRXh0ZW5zaW9uTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuZXh0ZW5zaW9uUG9ydCkgcmV0dXJuO1xuICAgIHZhciBwb3J0ID0gdGhpcy5leHRlbnNpb25Qb3J0O1xuICAgIHZhciBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybjtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkVSUk9SKSB7XG4gICAgICAvLyBoYW5kbGUgcG9wdXAgZXJyb3JcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBkYXRhLnBheWxvYWQgJiYgdHlwZW9mIGRhdGEucGF5bG9hZC5lcnJvciA9PT0gJ3N0cmluZycgPyBkYXRhLnBheWxvYWQuZXJyb3IgOiBudWxsO1xuICAgICAgdGhpcy5lbWl0KFBPUFVQLkNMT1NFRCwgZXJyb3JNZXNzYWdlID8gXCJQb3B1cCBlcnJvcjogXCIgKyBlcnJvck1lc3NhZ2UgOiBudWxsKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuTE9BREVEKSB7XG4gICAgICBpZiAodGhpcy5wb3B1cFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlmcmFtZUhhbmRzaGFrZS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHVzZUJyb2FkY2FzdENoYW5uZWwpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogUE9QVVAuSU5JVCxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBzZXR0aW5nczogX3RoaXM1LnNldHRpbmdzLFxuICAgICAgICAgICAgdXNlQnJvYWRjYXN0Q2hhbm5lbDogdXNlQnJvYWRjYXN0Q2hhbm5lbFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KHtcbiAgICAgICAgY3VycmVudFdpbmRvdzogdHJ1ZSxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9LCBmdW5jdGlvbiAodGFicykge1xuICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICBjaHJvbWUudGFicy5jcmVhdGUoe1xuICAgICAgICAgIHVybDogJ3RyZXpvci11c2ItcGVybWlzc2lvbnMuaHRtbCcsXG4gICAgICAgICAgaW5kZXg6IHRhYnNbMF0uaW5kZXggKyAxXG4gICAgICAgIH0sIGZ1bmN0aW9uIChfdGFiKSB7Ly8gZG8gbm90aGluZ1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5DTE9TRV9XSU5ET1cpIHtcbiAgICAgIHRoaXMuZW1pdChQT1BVUC5DTE9TRUQpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gaWdub3JlIG1lc3NhZ2VzIGZyb20gZG9tYWluIG90aGVyIHRoZW4gcG9wdXAgb3JpZ2luIGFuZCB3aXRob3V0IGRhdGFcbiAgICAvLyBjb25zdCBkYXRhOiBDb3JlTWVzc2FnZSA9IG1lc3NhZ2UuZGF0YTtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICBpZiAoKDAsIF9uZXR3b3JrVXRpbHMuZ2V0T3JpZ2luKShtZXNzYWdlLm9yaWdpbikgIT09IHRoaXMub3JpZ2luIHx8ICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gSUZSQU1FLkxPQURFRCkge1xuICAgICAgdmFyIHVzZUJyb2FkY2FzdENoYW5uZWwgPSBkYXRhLnBheWxvYWQgJiYgdHlwZW9mIGRhdGEucGF5bG9hZC51c2VCcm9hZGNhc3RDaGFubmVsID09PSAnYm9vbGVhbicgPyBkYXRhLnBheWxvYWQudXNlQnJvYWRjYXN0Q2hhbm5lbCA6IGZhbHNlO1xuICAgICAgdGhpcy5pZnJhbWVIYW5kc2hha2UucmVzb2x2ZSh1c2VCcm9hZGNhc3RDaGFubmVsKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuQk9PVFNUUkFQKSB7XG4gICAgICAvLyBwb3B1cCBpcyBvcGVuZWQgcHJvcGVybHksIG5vdyB3YWl0IGZvciBQT1BVUC5MT0FERUQgbWVzc2FnZVxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLm9wZW5UaW1lb3V0KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuRVJST1IgJiYgdGhpcy5fd2luZG93KSB7XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZGF0YS5wYXlsb2FkICYmIHR5cGVvZiBkYXRhLnBheWxvYWQuZXJyb3IgPT09ICdzdHJpbmcnID8gZGF0YS5wYXlsb2FkLmVycm9yIDogbnVsbDtcbiAgICAgIHRoaXMuZW1pdChQT1BVUC5DTE9TRUQsIGVycm9yTWVzc2FnZSA/IFwiUG9wdXAgZXJyb3I6IFwiICsgZXJyb3JNZXNzYWdlIDogbnVsbCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkxPQURFRCkge1xuICAgICAgaWYgKHRoaXMucG9wdXBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0gLy8gcG9wdXAgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuXG5cbiAgICAgIHRoaXMuaWZyYW1lSGFuZHNoYWtlLnByb21pc2UudGhlbihmdW5jdGlvbiAodXNlQnJvYWRjYXN0Q2hhbm5lbCkge1xuICAgICAgICBfdGhpczYuX3dpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogUE9QVVAuSU5JVCxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBzZXR0aW5nczogX3RoaXM2LnNldHRpbmdzLFxuICAgICAgICAgICAgdXNlQnJvYWRjYXN0Q2hhbm5lbDogdXNlQnJvYWRjYXN0Q2hhbm5lbFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX3RoaXM2Lm9yaWdpbik7XG4gICAgICB9KTsgLy8gc2VuZCBDb25uZWN0U2V0dGluZ3MgdG8gcG9wdXBcbiAgICAgIC8vIG5vdGUgdGhpcyBzZXR0aW5ncyBhbmQgaWZyYW1lLkNvbm5lY3RTZXR0aW5ncyBjb3VsZCBiZSBkaWZmZXJlbnQgKGVzcGVjaWFsbHk6IG9yaWdpbiwgcG9wdXAsIHdlYnVzYiwgZGVidWcpXG4gICAgICAvLyBub3cgcG9wdXAgaXMgYWJsZSB0byBsb2FkIGFzc2V0c1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5DQU5DRUxfUE9QVVBfUkVRVUVTVCB8fCBkYXRhLnR5cGUgPT09IFVJLkNMT1NFX1VJX1dJTkRPVykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMucG9wdXBQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVuVGltZW91dCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLm9wZW5UaW1lb3V0KTtcbiAgICAgIHRoaXMub3BlblRpbWVvdXQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlSW50ZXJ2YWwpIHtcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuY2xvc2VJbnRlcnZhbCk7XG4gICAgICB0aGlzLmNsb3NlSW50ZXJ2YWwgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4dGVuc2lvblBvcnQpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uUG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmV4dGVuc2lvblBvcnQgPSBudWxsO1xuICAgIH0gLy8gc3dpdGNoIHRvIHByZXZpb3VzbHkgZm9jdXNlZCB0YWJcblxuXG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uVGFiSWQpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICBjaHJvbWUudGFicy51cGRhdGUodGhpcy5leHRlbnNpb25UYWJJZCwge1xuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5leHRlbnNpb25UYWJJZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3dpbmRvdykge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZW52ID09PSAnd2ViZXh0ZW5zaW9uJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdmFyIF9lID0gY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yOyAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuXG4gICAgICAgIGNocm9tZS50YWJzLnJlbW92ZSh0aGlzLl93aW5kb3cuaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBfZSA9IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aW5kb3cuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBvc3RNZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Bvc3RNZXNzYWdlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobWVzc2FnZSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKCF0aGlzLl93aW5kb3cgJiYgbWVzc2FnZS50eXBlICE9PSBVSS5SRVFVRVNUX1VJX1dJTkRPVyAmJiB0aGlzLm9wZW5UaW1lb3V0KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAoMCwgX3Nob3dQb3B1cFJlcXVlc3Quc2hvd1BvcHVwUmVxdWVzdCkodGhpcy5vcGVuLmJpbmQodGhpcyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczcuZW1pdChQT1BVUC5DTE9TRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpZiAoIXRoaXMucG9wdXBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9wdXBQcm9taXNlLnByb21pc2U7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgLy8gcG9zdCBtZXNzYWdlIHRvIHBvcHVwIHdpbmRvd1xuICAgICAgICAgICAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRoaXMub3JpZ2luKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwb3N0TWVzc2FnZShfeCkge1xuICAgICAgcmV0dXJuIF9wb3N0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0TWVzc2FnZTtcbiAgfSgpO1xuXG4gIHJldHVybiBQb3B1cE1hbmFnZXI7XG59KF9ldmVudHNbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQb3B1cE1hbmFnZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuY29yc1ZhbGlkYXRvciA9IGV4cG9ydHMuZ2V0RW52ID0gZXhwb3J0cy5ERUZBVUxUX1BSSU9SSVRZID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKlxuICogSW5pdGlhbCBzZXR0aW5ncyBmb3IgY29ubmVjdC5cbiAqIEl0IGNvdWxkIGJlIGNoYW5nZWQgYnkgcGFzc2luZyB2YWx1ZXMgaW50byBUcmV6b3JDb25uZWN0LmluaXQoLi4uKSBtZXRob2RcbiAqL1xudmFyIFZFUlNJT04gPSAnOC4yLjYnO1xudmFyIHZlcnNpb25OID0gVkVSU0lPTi5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAocykge1xuICByZXR1cm4gcGFyc2VJbnQocywgMTApO1xufSk7IC8vIGNvbnN0IERJUkVDVE9SWSA9IGAkeyB2ZXJzaW9uTlswXSB9JHsgKHZlcnNpb25OWzFdID4gMCA/IGAuJHt2ZXJzaW9uTlsxXX1gIDogJycpIH0vYDtcblxudmFyIERJUkVDVE9SWSA9IHZlcnNpb25OWzBdICsgXCIvXCI7XG52YXIgREVGQVVMVF9ET01BSU4gPSBcImh0dHBzOi8vY29ubmVjdC50cmV6b3IuaW8vXCIgKyBESVJFQ1RPUlk7XG52YXIgREVGQVVMVF9QUklPUklUWSA9IDI7XG5leHBvcnRzLkRFRkFVTFRfUFJJT1JJVFkgPSBERUZBVUxUX1BSSU9SSVRZO1xudmFyIGluaXRpYWxTZXR0aW5ncyA9IHtcbiAgY29uZmlnU3JjOiAnLi9kYXRhL2NvbmZpZy5qc29uJyxcbiAgLy8gY29uc3RhbnRcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgLy8gY29uc3RhbnRcbiAgZGVidWc6IGZhbHNlLFxuICBwcmlvcml0eTogREVGQVVMVF9QUklPUklUWSxcbiAgdHJ1c3RlZEhvc3Q6IGZhbHNlLFxuICBjb25uZWN0U3JjOiBERUZBVUxUX0RPTUFJTixcbiAgaWZyYW1lU3JjOiBERUZBVUxUX0RPTUFJTiArIFwiaWZyYW1lLmh0bWxcIixcbiAgcG9wdXA6IHRydWUsXG4gIHBvcHVwU3JjOiBERUZBVUxUX0RPTUFJTiArIFwicG9wdXAuaHRtbFwiLFxuICB3ZWJ1c2JTcmM6IERFRkFVTFRfRE9NQUlOICsgXCJ3ZWJ1c2IuaHRtbFwiLFxuICB0cmFuc3BvcnRSZWNvbm5lY3Q6IGZhbHNlLFxuICB3ZWJ1c2I6IHRydWUsXG4gIHBlbmRpbmdUcmFuc3BvcnRFdmVudDogdHJ1ZSxcbiAgc3VwcG9ydGVkQnJvd3NlcjogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAhL1RyaWRlbnR8TVNJRXxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIDogdHJ1ZSxcbiAgbWFuaWZlc3Q6IG51bGwsXG4gIGVudjogJ3dlYicsXG4gIGxhenlMb2FkOiBmYWxzZSxcbiAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgaW50ZXJhY3Rpb25UaW1lb3V0OiA2MDAgLy8gNSBtaW51dGVzXG5cbn07XG52YXIgY3VycmVudFNldHRpbmdzID0gaW5pdGlhbFNldHRpbmdzO1xuXG52YXIgcGFyc2VNYW5pZmVzdCA9IGZ1bmN0aW9uIHBhcnNlTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgaWYgKCFtYW5pZmVzdCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIG1hbmlmZXN0LmVtYWlsICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG1hbmlmZXN0LmFwcFVybCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgcmV0dXJuIHtcbiAgICBlbWFpbDogbWFuaWZlc3QuZW1haWwsXG4gICAgYXBwVXJsOiBtYW5pZmVzdC5hcHBVcmxcbiAgfTtcbn07XG5cbnZhciBnZXRFbnYgPSBmdW5jdGlvbiBnZXRFbnYoKSB7XG4gIC8vICRGbG93SXNzdWU6IGNocm9tZSBpcyBub3QgZGVjbGFyZWQgb3V0c2lkZSB0aGUgcHJvamVjdFxuICBpZiAodHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hyb21lLnJ1bnRpbWUgJiYgdHlwZW9mIGNocm9tZS5ydW50aW1lLm9uQ29ubmVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJ3dlYmV4dGVuc2lvbic7XG4gIH1cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnKSB7XG4gICAgICByZXR1cm4gJ3JlYWN0LW5hdGl2ZSc7XG4gICAgfVxuXG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignIGVsZWN0cm9uLycpID4gLTEpIHtcbiAgICAgIHJldHVybiAnZWxlY3Ryb24nO1xuICAgIH1cbiAgfSAvLyBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnKSB7XG4gIC8vICAgICByZXR1cm4gJ3JlYWN0LW5hdGl2ZSc7XG4gIC8vIH1cbiAgLy8gaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zLmhhc093blByb3BlcnR5KCdlbGVjdHJvbicpKSB7XG4gIC8vICAgICByZXR1cm4gJ2VsZWN0cm9uJztcbiAgLy8gfVxuXG5cbiAgcmV0dXJuICd3ZWInO1xufTsgLy8gQ29ycyB2YWxpZGF0aW9uIGNvcGllZCBmcm9tIFRyZXpvciBCcmlkZ2Vcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3RyZXpvci90cmV6b3JkLWdvL2Jsb2IvMDU5OTFjZWE1OTAwZDE4YmNjNmVjZTVhZTVlMzE5ZDEzOGZjNTU1MS9zZXJ2ZXIvYXBpL2FwaS5nbyNMMjI5XG4vLyBJdHMgcG9pbnRsZXNzIHRvIGFsbG93IGB0cmV6b3ItY29ubmVjdGAgZW5kcG9pbnRzIHsgY29ubmVjdFNyYyB9IGZvciBkb21haW5zIG90aGVyIHRoYW4gbGlzdGVkIGJlbG93XG4vLyBgdHJlem9yZGAgd2lsbCBibG9jayBjb21tdW5pY2F0aW9uIGFueXdheVxuXG5cbmV4cG9ydHMuZ2V0RW52ID0gZ2V0RW52O1xuXG52YXIgY29yc1ZhbGlkYXRvciA9IGZ1bmN0aW9uIGNvcnNWYWxpZGF0b3IodXJsKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBpZiAodXJsLm1hdGNoKC9eaHR0cHM6XFwvXFwvKFtBLVphLXowLTlcXC1fXStcXC4pKnRyZXpvclxcLmlvXFwvLykpIHJldHVybiB1cmw7XG4gIGlmICh1cmwubWF0Y2goL15odHRwcz86XFwvXFwvbG9jYWxob3N0Ols1OF1bMC05XXszfVxcLy8pKSByZXR1cm4gdXJsO1xuICBpZiAodXJsLm1hdGNoKC9eaHR0cHM6XFwvXFwvKFtBLVphLXowLTlcXC1fXStcXC4pKnNsZGV2XFwuY3pcXC8vKSkgcmV0dXJuIHVybDtcbiAgaWYgKHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW0EtWmEtejAtOVxcLV9dK1xcLikqdHJlem9yaW92cGpjYWhwemtyZXdlbGNsdWxtc3p3YnFwem16Z3ViMzdnYmNqbHZsdXh0cnVxYWRcXC5vbmlvblxcLy8pKSByZXR1cm4gdXJsO1xufTtcblxuZXhwb3J0cy5jb3JzVmFsaWRhdG9yID0gY29yc1ZhbGlkYXRvcjtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICBpbnB1dCA9IHt9O1xuICB9XG5cbiAgdmFyIHNldHRpbmdzID0gX29iamVjdFNwcmVhZCh7fSwgY3VycmVudFNldHRpbmdzKTtcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0LCAnZGVidWcnKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgey8vIGVuYWJsZSBsb2cgd2l0aCBwcmVmaXhcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0LmRlYnVnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHNldHRpbmdzLmRlYnVnID0gaW5wdXQuZGVidWc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQuZGVidWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXR0aW5ncy5kZWJ1ZyA9IGlucHV0LmRlYnVnID09PSAndHJ1ZSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5jb25uZWN0U3JjID09PSAnc3RyaW5nJykge1xuICAgIHNldHRpbmdzLmNvbm5lY3RTcmMgPSBpbnB1dC5jb25uZWN0U3JjO1xuICB9IC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgYGNvbm5lY3RTcmNgIGNvdWxkIGJlIGRlZmluZWQgaW4gYGdsb2JhbC5fX1RSRVpPUl9DT05ORUNUX1NSQ2AgdmFyaWFibGVcblxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLl9fVFJFWk9SX0NPTk5FQ1RfU1JDID09PSAnc3RyaW5nJykge1xuICAgIHNldHRpbmdzLmNvbm5lY3RTcmMgPSBjb3JzVmFsaWRhdG9yKGdsb2JhbC5fX1RSRVpPUl9DT05ORUNUX1NSQyk7XG4gICAgc2V0dGluZ3MuZGVidWcgPSB0cnVlO1xuICB9IC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgYGNvbm5lY3RTcmNgIGNvdWxkIGJlIGRlZmluZWQgaW4gdXJsIHF1ZXJ5IG9mIGhvc3RpbmcgcGFnZS4gVXNhZ2U6XG4gIC8vIGh0dHBzOi8vM3JkcGFydHktcGFnZS5jb20vP3RyZXpvci1jb25uZWN0LXNyYz1odHRwczovL2xvY2FsaG9zdDo4MDg4L1xuXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB0eXBlb2Ygd2luZG93LmxvY2F0aW9uLnNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmFycyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3BsaXQoJyYnKTtcbiAgICB2YXIgY3VzdG9tVXJsID0gdmFycy5maW5kKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdi5pbmRleE9mKCd0cmV6b3ItY29ubmVjdC1zcmMnKSA+PSAwO1xuICAgIH0pO1xuXG4gICAgaWYgKGN1c3RvbVVybCkge1xuICAgICAgdmFyIF9jdXN0b21Vcmwkc3BsaXQgPSBjdXN0b21Vcmwuc3BsaXQoJz0nKSxcbiAgICAgICAgICBjb25uZWN0U3JjID0gX2N1c3RvbVVybCRzcGxpdFsxXTtcblxuICAgICAgc2V0dGluZ3MuY29ubmVjdFNyYyA9IGNvcnNWYWxpZGF0b3IoZGVjb2RlVVJJQ29tcG9uZW50KGNvbm5lY3RTcmMpKTtcbiAgICAgIHNldHRpbmdzLmRlYnVnID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3JjID0gc2V0dGluZ3MuY29ubmVjdFNyYyB8fCBERUZBVUxUX0RPTUFJTjtcbiAgc2V0dGluZ3MuaWZyYW1lU3JjID0gc3JjICsgXCJpZnJhbWUuaHRtbFwiO1xuICBzZXR0aW5ncy5wb3B1cFNyYyA9IHNyYyArIFwicG9wdXAuaHRtbFwiO1xuICBzZXR0aW5ncy53ZWJ1c2JTcmMgPSBzcmMgKyBcIndlYnVzYi5odG1sXCI7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC50cmFuc3BvcnRSZWNvbm5lY3QgPT09ICdib29sZWFuJykge1xuICAgIHNldHRpbmdzLnRyYW5zcG9ydFJlY29ubmVjdCA9IGlucHV0LnRyYW5zcG9ydFJlY29ubmVjdDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQud2VidXNiID09PSAnYm9vbGVhbicpIHtcbiAgICBzZXR0aW5ncy53ZWJ1c2IgPSBpbnB1dC53ZWJ1c2I7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LnBvcHVwID09PSAnYm9vbGVhbicpIHtcbiAgICBzZXR0aW5ncy5wb3B1cCA9IGlucHV0LnBvcHVwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5sYXp5TG9hZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc2V0dGluZ3MubGF6eUxvYWQgPSBpbnB1dC5sYXp5TG9hZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQucGVuZGluZ1RyYW5zcG9ydEV2ZW50ID09PSAnYm9vbGVhbicpIHtcbiAgICBzZXR0aW5ncy5wZW5kaW5nVHJhbnNwb3J0RXZlbnQgPSBpbnB1dC5wZW5kaW5nVHJhbnNwb3J0RXZlbnQ7XG4gIH0gLy8gbG9jYWwgZmlsZXNcblxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgc2V0dGluZ3Mub3JpZ2luID0gXCJmaWxlOi8vXCIgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgc2V0dGluZ3Mud2VidXNiID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LmV4dGVuc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXR0aW5ncy5leHRlbnNpb24gPSBpbnB1dC5leHRlbnNpb247XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LmVudiA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXR0aW5ncy5lbnYgPSBpbnB1dC5lbnY7XG4gIH0gZWxzZSB7XG4gICAgc2V0dGluZ3MuZW52ID0gZ2V0RW52KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LnRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBzZXR0aW5ncy50aW1lc3RhbXAgPSBpbnB1dC50aW1lc3RhbXA7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LmludGVyYWN0aW9uVGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICBzZXR0aW5ncy5pbnRlcmFjdGlvblRpbWVvdXQgPSBpbnB1dC5pbnRlcmFjdGlvblRpbWVvdXQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0Lm1hbmlmZXN0ID09PSAnb2JqZWN0Jykge1xuICAgIHNldHRpbmdzLm1hbmlmZXN0ID0gcGFyc2VNYW5pZmVzdChpbnB1dC5tYW5pZmVzdCk7XG4gIH1cblxuICBjdXJyZW50U2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgcmV0dXJuIGN1cnJlbnRTZXR0aW5ncztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkJsb2NrY2hhaW5NZXNzYWdlID0gZXhwb3J0cy5SZXNwb25zZU1lc3NhZ2UgPSBleHBvcnRzLlRyYW5zcG9ydE1lc3NhZ2UgPSBleHBvcnRzLkRldmljZU1lc3NhZ2UgPSBleHBvcnRzLlVpTWVzc2FnZSA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVWlNZXNzYWdlID0gZnVuY3Rpb24gVWlNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfTtcbn07XG5cbmV4cG9ydHMuVWlNZXNzYWdlID0gVWlNZXNzYWdlO1xuXG52YXIgRGV2aWNlTWVzc2FnZSA9IGZ1bmN0aW9uIERldmljZU1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLkRFVklDRV9FVkVOVCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfTtcbn07XG5cbmV4cG9ydHMuRGV2aWNlTWVzc2FnZSA9IERldmljZU1lc3NhZ2U7XG5cbnZhciBUcmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuVFJBTlNQT1JUX0VWRU5ULFxuICAgIHR5cGU6IHR5cGUsXG4gICAgLy8gY29udmVydCBFcnJvci9UeXBlRXJyb3Igb2JqZWN0IGludG8gcGF5bG9hZCBlcnJvciB0eXBlIChFcnJvciBvYmplY3QvY2xhc3MgaXMgY29udmVydGVkIHRvIHN0cmluZyB3aGlsZSBzZW50IHZpYSBwb3N0TWVzc2FnZSlcbiAgICBwYXlsb2FkOiBwYXlsb2FkLmVycm9yID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXlsb2FkKSwge30sIHtcbiAgICAgIGVycm9yOiBwYXlsb2FkLmVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBwYXlsb2FkLmVycm9yLmNvZGVcbiAgICB9KSA6IHBheWxvYWRcbiAgfTtcbn07XG5cbmV4cG9ydHMuVHJhbnNwb3J0TWVzc2FnZSA9IFRyYW5zcG9ydE1lc3NhZ2U7XG5cbnZhciBSZXNwb25zZU1lc3NhZ2UgPSBmdW5jdGlvbiBSZXNwb25zZU1lc3NhZ2UoaWQsIHN1Y2Nlc3MsIHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQgPT09IHZvaWQgMCkge1xuICAgIHBheWxvYWQgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudDogX2NvbnN0YW50cy5SRVNQT05TRV9FVkVOVCxcbiAgICB0eXBlOiBfY29uc3RhbnRzLlJFU1BPTlNFX0VWRU5ULFxuICAgIGlkOiBpZCxcbiAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgIC8vIGNvbnZlcnQgRXJyb3IvVHlwZUVycm9yIG9iamVjdCBpbnRvIHBheWxvYWQgZXJyb3IgdHlwZSAoRXJyb3Igb2JqZWN0L2NsYXNzIGlzIGNvbnZlcnRlZCB0byBzdHJpbmcgd2hpbGUgc2VudCB2aWEgcG9zdE1lc3NhZ2UpXG4gICAgcGF5bG9hZDogc3VjY2VzcyA/IHBheWxvYWQgOiB7XG4gICAgICBlcnJvcjogcGF5bG9hZC5lcnJvci5tZXNzYWdlLFxuICAgICAgY29kZTogcGF5bG9hZC5lcnJvci5jb2RlXG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5SZXNwb25zZU1lc3NhZ2UgPSBSZXNwb25zZU1lc3NhZ2U7XG5cbnZhciBCbG9ja2NoYWluTWVzc2FnZSA9IGZ1bmN0aW9uIEJsb2NrY2hhaW5NZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudDogX2NvbnN0YW50cy5CTE9DS0NIQUlOX0VWRU5ULFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9O1xufTtcblxuZXhwb3J0cy5CbG9ja2NoYWluTWVzc2FnZSA9IEJsb2NrY2hhaW5NZXNzYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZXhwb3J0cy5kaXNwb3NlID0gZXhwb3J0cy5wb3N0TWVzc2FnZSA9IGV4cG9ydHMuaW5pdCA9IGV4cG9ydHMubWVzc2FnZVByb21pc2VzID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMudGltZW91dCA9IGV4cG9ydHMuaW5pdFByb21pc2UgPSBleHBvcnRzLm9yaWdpbiA9IGV4cG9ydHMuaW5zdGFuY2UgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmVycmVkID0gcmVxdWlyZShcIi4uL3V0aWxzL2RlZmVycmVkXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbnZhciBfbmV0d29ya1V0aWxzID0gcmVxdWlyZShcIi4uL2Vudi9icm93c2VyL25ldHdvcmtVdGlsc1wiKTtcblxudmFyIF9pbmxpbmVTdHlsZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lubGluZS1zdHlsZXNcIikpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzICovXG52YXIgaW5zdGFuY2U7XG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XG52YXIgb3JpZ2luO1xuZXhwb3J0cy5vcmlnaW4gPSBvcmlnaW47XG52YXIgaW5pdFByb21pc2UgPSAoMCwgX2RlZmVycmVkLmNyZWF0ZSkoKTtcbmV4cG9ydHMuaW5pdFByb21pc2UgPSBpbml0UHJvbWlzZTtcbnZhciB0aW1lb3V0ID0gMDtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG52YXIgZXJyb3I7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHMgKi9cblxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xudmFyIF9tZXNzYWdlSUQgPSAwOyAvLyBldmVyeSBwb3N0TWVzc2FnZSB0byBpZnJhbWUgaGFzIGl0cyBvd24gcHJvbWlzZSB0byByZXNvbHZlXG5cbnZhciBtZXNzYWdlUHJvbWlzZXMgPSB7fTtcbmV4cG9ydHMubWVzc2FnZVByb21pc2VzID0gbWVzc2FnZVByb21pc2VzO1xuXG52YXIgaW5pdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc2V0dGluZ3MpIHtcbiAgICB2YXIgZXhpc3RlZEZyYW1lLCBzcmMsIG1hbmlmZXN0U3RyaW5nLCBtYW5pZmVzdCwgb25Mb2FkO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBleHBvcnRzLmluaXRQcm9taXNlID0gaW5pdFByb21pc2UgPSAoMCwgX2RlZmVycmVkLmNyZWF0ZSkoKTtcbiAgICAgICAgICAgIGV4aXN0ZWRGcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmV6b3Jjb25uZWN0Jyk7XG5cbiAgICAgICAgICAgIGlmIChleGlzdGVkRnJhbWUpIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlID0gZXhpc3RlZEZyYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmZyYW1lQm9yZGVyID0gJzAnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS53aWR0aCA9ICcwcHgnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5oZWlnaHQgPSAnMHB4JztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdHlsZS5ib3JkZXIgPSAnMHB4JztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmlkID0gJ3RyZXpvcmNvbm5lY3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW52ID09PSAnd2ViJykge1xuICAgICAgICAgICAgICBtYW5pZmVzdFN0cmluZyA9IHNldHRpbmdzLm1hbmlmZXN0ID8gSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MubWFuaWZlc3QpIDogJ3VuZGVmaW5lZCc7IC8vIG5vdGU6IGJ0b2EodW5kZWZpbmVkKSA9PT0gYnRvYSgndW5kZWZpbmVkJykgPT09IFwiZFc1a1pXWnBibVZrXCJcblxuICAgICAgICAgICAgICBtYW5pZmVzdCA9IFwidmVyc2lvbj1cIiArIHNldHRpbmdzLnZlcnNpb24gKyBcIiZtYW5pZmVzdD1cIiArIGVuY29kZVVSSUNvbXBvbmVudChidG9hKEpTT04uc3RyaW5naWZ5KG1hbmlmZXN0U3RyaW5nKSkpO1xuICAgICAgICAgICAgICBzcmMgPSBzZXR0aW5ncy5pZnJhbWVTcmMgKyBcIj9cIiArIG1hbmlmZXN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3JjID0gc2V0dGluZ3MuaWZyYW1lU3JjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53ZWJ1c2IpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cmlidXRlKCdhbGxvdycsICd1c2InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5vcmlnaW4gPSBvcmlnaW4gPSAoMCwgX25ldHdvcmtVdGlscy5nZXRPcmlnaW4pKGluc3RhbmNlLnNyYyk7XG4gICAgICAgICAgICBleHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbml0UHJvbWlzZS5yZWplY3QoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9JZnJhbWVUaW1lb3V0JykpO1xuICAgICAgICAgICAgfSwgMTAwMDApO1xuXG4gICAgICAgICAgICBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpbml0UHJvbWlzZS5yZWplY3QoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9JZnJhbWVCbG9ja2VkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaG9zdGluZyBwYWdlIGlzIGFibGUgdG8gYWNjZXNzIGNyb3NzLW9yaWdpbiBsb2NhdGlvbiBpdCBtZWFucyB0aGF0IHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZFxuICAgICAgICAgICAgICAgIHZhciBpZnJhbWVPcmlnaW4gPSBpbnN0YW5jZS5jb250ZW50V2luZG93LmxvY2F0aW9uLm9yaWdpbjtcblxuICAgICAgICAgICAgICAgIGlmICghaWZyYW1lT3JpZ2luIHx8IGlmcmFtZU9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgIGhhbmRsZUlmcmFtZUJsb2NrZWQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBlbXB0eVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbjsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgaXMgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hyb21lLnJ1bnRpbWUgJiYgdHlwZW9mIGNocm9tZS5ydW50aW1lLm9uQ29ubmVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGNocm9tZS5ydW50aW1lLmlkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5JRlJBTUUuSU5JVCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgb3JpZ2luKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uub25sb2FkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTsgLy8gSUUgaGFja1xuXG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5hdHRhY2hFdmVudCgnb25sb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLm9ubG9hZCA9IG9uTG9hZDtcbiAgICAgICAgICAgIH0gLy8gaW5qZWN0IGlmcmFtZSBpbnRvIGhvc3QgZG9jdW1lbnQgYm9keVxuXG5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5zdGFuY2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcblxuICAgICAgICAgICAgICBpbmplY3RTdHlsZVNoZWV0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiBpbml0UHJvbWlzZS5wcm9taXNlO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxMSk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIHRvIGFsbG93IGluaXRpYWxpemF0aW9uIGFnYWluXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMDtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBleHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjApO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxMSwgMTYsIDIwLCAyNF1dKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpbml0KF94KSB7XG4gICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcblxudmFyIGluamVjdFN0eWxlU2hlZXQgPSBmdW5jdGlvbiBpbmplY3RTdHlsZVNoZWV0KCkge1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgdGhyb3cgX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9JZnJhbWVCbG9ja2VkJyk7XG4gIH1cblxuICB2YXIgZG9jID0gaW5zdGFuY2Uub3duZXJEb2N1bWVudDtcbiAgdmFyIGhlYWQgPSBkb2MuaGVhZCB8fCBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnVHJlem9yQ29ubmVjdFN0eWxlc2hlZXQnKTsgLy8gJEZsb3dJc3N1ZVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgLy8gSUVcbiAgICAvLyAkRmxvd0lzc3VlXG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gX2lubGluZVN0eWxlc1tcImRlZmF1bHRcIl07XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoX2lubGluZVN0eWxlc1tcImRlZmF1bHRcIl0pKTtcbiAgICBoZWFkLmFwcGVuZChzdHlsZSk7XG4gIH1cbn07XG5cbnZhciBoYW5kbGVJZnJhbWVCbG9ja2VkID0gZnVuY3Rpb24gaGFuZGxlSWZyYW1lQmxvY2tlZCgpIHtcbiAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgZXhwb3J0cy5lcnJvciA9IGVycm9yID0gX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9JZnJhbWVCbG9ja2VkJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuXG4gIGRpc3Bvc2UoKTtcbiAgaW5pdFByb21pc2UucmVqZWN0KGVycm9yKTtcbn07IC8vIHBvc3QgbWVzc2FnZXMgdG8gaWZyYW1lXG5cblxudmFyIHBvc3RNZXNzYWdlID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2UobWVzc2FnZSwgdXNlUHJvbWlzZSkge1xuICBpZiAodXNlUHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgdXNlUHJvbWlzZSA9IHRydWU7XG4gIH1cblxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgdGhyb3cgX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9JZnJhbWVCbG9ja2VkJyk7XG4gIH1cblxuICBpZiAodXNlUHJvbWlzZSkge1xuICAgIF9tZXNzYWdlSUQrKztcbiAgICBtZXNzYWdlLmlkID0gX21lc3NhZ2VJRDtcbiAgICBtZXNzYWdlUHJvbWlzZXNbX21lc3NhZ2VJRF0gPSAoMCwgX2RlZmVycmVkLmNyZWF0ZSkoKTtcbiAgICB2YXIgcHJvbWlzZSA9IG1lc3NhZ2VQcm9taXNlc1tfbWVzc2FnZUlEXS5wcm9taXNlO1xuICAgIGluc3RhbmNlLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGluc3RhbmNlLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnRzLnBvc3RNZXNzYWdlID0gcG9zdE1lc3NhZ2U7XG5cbnZhciBkaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudE5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgaW5zdGFuY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnN0YW5jZSk7XG4gICAgfSBjYXRjaCAoZSkgey8vIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2UgPSBudWxsO1xuICBleHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0ID0gMDtcbn07XG5cbmV4cG9ydHMuZGlzcG9zZSA9IGRpc3Bvc2U7XG5cbnZhciBjbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhclRpbWVvdXQoKSB7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG59O1xuXG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gZXhwb3J0cy5wZXJzb25hbFNpZ24gPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENyZWF0ZSBhbiBFdGhlcmV1bS1zcGVjaWZpYyBzaWduYXR1cmUgZm9yIGEgbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGBldGhfc2lnbmAgRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kIGFzIHNwZWNpZmllZCBpbiBFSVAtMTQxNyxcbiAqIGFzIHdlbGwgYXMgdGhlIE1ldGFNYXNrJ3MgYHBlcnNvbmFsX3NpZ25gIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwZXJzb25hbCBzaWduIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRvIHNpZ24uXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHBlcnNvbmFsU2lnbih7IHByaXZhdGVLZXksIGRhdGEsIH0pIHtcbiAgICBpZiAodXRpbHNfMS5pc051bGxpc2goZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdXRpbHNfMS5sZWdhY3lUb0J1ZmZlcihkYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoZXJldW1qc191dGlsXzEuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKTtcbiAgICBjb25zdCBzaWcgPSBldGhlcmV1bWpzX3V0aWxfMS5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHV0aWxzXzEuY29uY2F0U2lnKGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKHNpZy52KSwgc2lnLnIsIHNpZy5zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmV4cG9ydHMucGVyc29uYWxTaWduID0gcGVyc29uYWxTaWduO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHVzZWQgdG8gY3JlYXRlIHRoZSBnaXZlbiBFdGhlcmV1bSBzaWduYXR1cmUuIFRoZSBtZXNzYWdlXG4gKiBtdXN0IGhhdmUgYmVlbiBzaWduZWQgdXNpbmcgdGhlIGBwZXJzb25hbFNpZ25gIGZ1bmN0aW9uLCBvciBhbiBlcXVpdmFsZW50IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25hdHVyZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBoZXggZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIGFkZHJlc3Mgb2YgdGhlIG1lc3NhZ2Ugc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhLCBzaWduYXR1cmUsIH0pIHtcbiAgICBpZiAodXRpbHNfMS5pc051bGxpc2goZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKGRhdGEsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZXRoZXJldW1qc191dGlsXzEucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbiAgICByZXR1cm4gc2VuZGVySGV4O1xufVxuZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSByZWNvdmVyUGVyc29uYWxTaWduYXR1cmU7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhlIGdpdmVuIEV0aGVyZXVtIHNpZ25hdHVyZS4gVGhlIG1lc3NhZ2VcbiAqIG11c3QgaGF2ZSBiZWVuIHNpZ25lZCB1c2luZyB0aGUgYHBlcnNvbmFsU2lnbmAgZnVuY3Rpb24sIG9yIGFuIGVxdWl2YWxlbnQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcHVibGljIGtleSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBoZXggZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2Ugc2lnbmVyLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UHVibGljS2V5KHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsc18xLmlzTnVsbGlzaChzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihkYXRhLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG4vKipcbiAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGV0aGVyZXVtanNfdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UodXRpbHNfMS5sZWdhY3lUb0J1ZmZlcihtZXNzYWdlKSk7XG4gICAgcmV0dXJuIHV0aWxzXzEucmVjb3ZlclB1YmxpY0tleShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcnNvbmFsLXNpZ24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW5jcnlwdGlvblB1YmxpY0tleSA9IGV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGV4cG9ydHMuZGVjcnlwdCA9IGV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGV4cG9ydHMuZW5jcnlwdCA9IHZvaWQgMDtcbmNvbnN0IG5hY2wgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbFwiKSk7XG5jb25zdCBuYWNsVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsLXV0aWxcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBFbmNyeXB0IGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBlbmNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSByZWNpcGllbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIG1lc3NhZ2UgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgdHlwZSBvZiBlbmNyeXB0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YSwgdmVyc2lvbiwgfSkge1xuICAgIGlmICh1dGlsc18xLmlzTnVsbGlzaChwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsc18xLmlzTnVsbGlzaCh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmVyc2lvbiBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgZGF0YSBtdXN0IGJlIGdpdmVuIGFzIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICAgICAgY29uc3QgZXBoZW1lcmFsS2V5UGFpciA9IG5hY2wuYm94LmtleVBhaXIoKTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGVuY3J5cHRpb24gcGFyYW1ldGVycyAtIGZyb20gc3RyaW5nIHRvIFVJbnQ4XG4gICAgICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHViS2V5VUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsVXRpbC5kZWNvZGVVVEY4KGRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNScsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRlZE1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJldHVybiBlbmNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG4vKipcbiAqIEVuY3J5cHQgYSBtZXNzYWdlIGluIGEgd2F5IHRoYXQgb2JzY3VyZXMgdGhlIG1lc3NhZ2UgbGVuZ3RoLlxuICpcbiAqIFRoZSBtZXNzYWdlIGlzIHBhZGRlZCB0byBhIG11bHRpcGxlIG9mIDIwNDggYmVmb3JlIGJlaW5nIGVuY3J5cHRlZCBzbyB0aGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gKiByZXN1bHRpbmcgZW5jcnlwdGVkIG1lc3NhZ2UgY2FuJ3QgYmUgdXNlZCB0byBndWVzcyB0aGUgZXhhY3QgbGVuZ3RoIG9mIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGVuY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBtZXNzYWdlIHJlY2lwaWVudC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgbWVzc2FnZSBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMudmVyc2lvbiAtIFRoZSB0eXBlIG9mIGVuY3J5cHRpb24gdG8gdXNlLlxuICogQHJldHVybnMgVGhlIGVuY3J5cHRlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBlbmNyeXB0U2FmZWx5KHsgcHVibGljS2V5LCBkYXRhLCB2ZXJzaW9uLCB9KSB7XG4gICAgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHNfMS5pc051bGxpc2goZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2ZXJzaW9uIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBERUZBVUxUX1BBRERJTkdfTEVOR1RIID0gMiAqKiAxMTtcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTY7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAndG9KU09OJyBpbiBkYXRhKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgICAvLyBUT0RPLCBjaGVjayBhbGwgcG9zc2libGUgY2hpbGRyZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYWRkaW5nOiAnJyxcbiAgICB9O1xuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpO1xuICAgIGNvbnN0IG1vZFZhbCA9IGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIO1xuICAgIGxldCBwYWRMZW5ndGggPSAwO1xuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICAgIHBhZExlbmd0aCA9IERFRkFVTFRfUEFERElOR19MRU5HVEggLSBtb2RWYWwgLSBOQUNMX0VYVFJBX0JZVEVTOyAvLyBuYWNsIGV4dHJhIGJ5dGVzXG4gICAgfVxuICAgIGRhdGFXaXRoUGFkZGluZy5wYWRkaW5nID0gJzAnLnJlcGVhdChwYWRMZW5ndGgpO1xuICAgIGNvbnN0IHBhZGRlZE1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpO1xuICAgIHJldHVybiBlbmNyeXB0KHsgcHVibGljS2V5LCBkYXRhOiBwYWRkZWRNZXNzYWdlLCB2ZXJzaW9uIH0pO1xufVxuZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZW5jcnlwdFNhZmVseTtcbi8qKlxuICogRGVjcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZGVjcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZW5jcnlwdGVkRGF0YSAtIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gZGVjcnlwdCB3aXRoLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0KHsgZW5jcnlwdGVkRGF0YSwgcHJpdmF0ZUtleSwgfSkge1xuICAgIGlmICh1dGlsc18xLmlzTnVsbGlzaChlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHNfMS5pc051bGxpc2gocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZW5jcnlwdGVkRGF0YS52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIC8vIHN0cmluZyB0byBidWZmZXIgdG8gVUludDhBcnJheVxuICAgICAgICAgICAgY29uc3QgcmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgY29uc3QgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmNpcGhlcnRleHQpO1xuICAgICAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5lcGhlbVB1YmxpY0tleSk7XG4gICAgICAgICAgICAvLyBkZWNyeXB0XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbmFjbFV0aWwuZW5jb2RlVVRGOChkZWNyeXB0ZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbi8qKlxuICogRGVjcnlwdCBhIG1lc3NhZ2UgdGhhdCBoYXMgYmVlbiBlbmNyeXB0ZWQgdXNpbmcgYGVuY3J5cHRTYWZlbHlgLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdFNhZmVseSh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAodXRpbHNfMS5pc051bGxpc2goZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKGRlY3J5cHQoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5IH0pKTtcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGE7XG59XG5leHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBkZWNyeXB0U2FmZWx5O1xuLyoqXG4gKiBHZXQgdGhlIGVuY3J5cHRpb24gcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBnZW5lcmF0ZSB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5LlxuICovXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uUHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRpb25QdWJsaWNLZXkpO1xufVxuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleTtcbi8qKlxuICogQ29udmVydCBhIGhleCBzdHJpbmcgdG8gdGhlIFVJbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbC5cbiAqXG4gKiBAcGFyYW0gbXNnSGV4IC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5hY2xfZGVjb2RlSGV4KG1zZ0hleCkge1xuICAgIGNvbnN0IG1zZ0Jhc2U2NCA9IEJ1ZmZlci5mcm9tKG1zZ0hleCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNyeXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aGVyZXVtanNfYWJpXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy1hYmlcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHZlcnNpb24gb2YgYHNpZ25UeXBlZERhdGFgIGJlaW5nIHVzZWQuXG4gKlxuICogVjEgaXMgYmFzZWQgdXBvbiBbYW4gZWFybHkgdmVyc2lvbiBvZiBFSVAtNzEyXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9wdWxsLzcxMi9jb21taXRzLzIxYWJlMjU0ZmUwNDUyZDg1ODNkNWIxMzJiMWQ3YmU4N2MwNDM5Y2EpXG4gKiB0aGF0IGxhY2tlZCBzb21lIGxhdGVyIHNlY3VyaXR5IGltcHJvdmVtZW50cywgYW5kIHNob3VsZCBnZW5lcmFsbHkgYmUgbmVnbGVjdGVkIGluIGZhdm9yIG9mXG4gKiBsYXRlciB2ZXJzaW9ucy5cbiAqXG4gKiBWMyBpcyBiYXNlZCBvbiBFSVAtNzEyLCBleGNlcHQgdGhhdCBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogVjQgaXMgYmFzZWQgb24gRUlQLTcxMiwgYW5kIGluY2x1ZGVzIGZ1bGwgc3VwcG9ydCBvZiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKi9cbnZhciBTaWduVHlwZWREYXRhVmVyc2lvbjtcbihmdW5jdGlvbiAoU2lnblR5cGVkRGF0YVZlcnNpb24pIHtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYxXCJdID0gXCJWMVwiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjNcIl0gPSBcIlYzXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWNFwiXSA9IFwiVjRcIjtcbn0pKFNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiB8fCAoZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHt9KSk7XG5leHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0ge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7IHR5cGU6ICdzdHJpbmcnLCBlbnVtOiBnZXRTb2xpZGl0eVR5cGVzKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgU29saWRpdHkgdHlwZXMuXG4gKlxuICogQHJldHVybnMgQSBsaXN0IG9mIGFsbCBTb2xpZGl0eSB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U29saWRpdHlUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFsnYm9vbCcsICdhZGRyZXNzJywgJ3N0cmluZycsICdieXRlcyddO1xuICAgIGNvbnN0IGludHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcCgoXywgaW5kZXgpID0+IGBpbnQkeyhpbmRleCArIDEpICogOH1gKTtcbiAgICBjb25zdCB1aW50cyA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKChfLCBpbmRleCkgPT4gYHVpbnQkeyhpbmRleCArIDEpICogOH1gKTtcbiAgICBjb25zdCBieXRlcyA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKChfLCBpbmRleCkgPT4gYGJ5dGVzJHtpbmRleCArIDF9YCk7XG4gICAgcmV0dXJuIFsuLi50eXBlcywgLi4uaW50cywgLi4udWludHMsIC4uLmJ5dGVzXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGFsbG93ZWRWZXJzaW9ucyAtIEEgbGlzdCBvZiBhbGxvd2VkIHZlcnNpb25zLiBJZiBvbWl0dGVkLCBhbGwgdmVyc2lvbnMgYXJlIGFzc3VtZWQgdG8gYmVcbiAqIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBhbGxvd2VkVmVyc2lvbnMpIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKFNpZ25UeXBlZERhdGFWZXJzaW9uKS5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93ZWRWZXJzaW9ucyAmJiAhYWxsb3dlZFZlcnNpb25zLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnblR5cGVkRGF0YVZlcnNpb24gbm90IGFsbG93ZWQ6ICcke3ZlcnNpb259Jy4gQWxsb3dlZCB2ZXJzaW9ucyBhcmU6ICR7YWxsb3dlZFZlcnNpb25zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gQWxsIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBmaWVsZCBiZWluZyBlbmNvZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCB0eXBlLCB2YWx1ZSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdieXRlczMyJyxcbiAgICAgICAgICAgIHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0ICYmIHZhbHVlID09IG51bGwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsXG4gICAgICAgICAgICAgICAgPyAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgICAgICAgICAgICAgIDogZXRoZXJldW1qc191dGlsXzEua2VjY2FrKGVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB2ZXJzaW9uKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aGVyZXVtanNfdXRpbF8xLmtlY2Nhayh2YWx1ZSldO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY29udmVydCBzdHJpbmcgdG8gYnVmZmVyIC0gcHJldmVudHMgZXRoVXRpbCBmcm9tIGludGVycHJldGluZyBzdHJpbmdzIGxpa2UgJzB4YWJjZCcgYXMgaGV4XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhlcmV1bWpzX3V0aWxfMS5rZWNjYWsodmFsdWUpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUubGFzdEluZGV4T2YoJ10nKSA9PT0gdHlwZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgYXJlIHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YTsgdXNlIFY0IGV4dGVuc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0eXBlLnNsaWNlKDAsIHR5cGUubGFzdEluZGV4T2YoJ1snKSk7XG4gICAgICAgIGNvbnN0IHR5cGVWYWx1ZVBhaXJzID0gdmFsdWUubWFwKChpdGVtKSA9PiBlbmNvZGVGaWVsZCh0eXBlcywgbmFtZSwgcGFyc2VkVHlwZSwgaXRlbSwgdmVyc2lvbikpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgZXRoZXJldW1qc191dGlsXzEua2VjY2FrKGV0aGVyZXVtanNfYWJpXzEucmF3RW5jb2RlKHR5cGVWYWx1ZVBhaXJzLm1hcCgoW3RdKSA9PiB0KSwgdHlwZVZhbHVlUGFpcnMubWFwKChbLCB2XSkgPT4gdikpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV07XG59XG4vKipcbiAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ107XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9IFtoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjMgJiYgZGF0YVtmaWVsZC5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQodHlwZXMsIGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0sIHZlcnNpb24pO1xuICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfYWJpXzEucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcyk7XG59XG4vKipcbiAqIEVuY29kZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBBbiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcmltYXJ5IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHVuc29ydGVkRGVwcyA9IGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcyk7XG4gICAgdW5zb3J0ZWREZXBzLmRlbGV0ZShwcmltYXJ5VHlwZSk7XG4gICAgY29uc3QgZGVwcyA9IFtwcmltYXJ5VHlwZSwgLi4uQXJyYXkuZnJvbSh1bnNvcnRlZERlcHMpLnNvcnQoKV07XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGAke3R5cGV9KCR7dHlwZXNbdHlwZV1cbiAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgIC5qb2luKCcsJyl9KWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmluaXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gcmVzdWx0cyAtIFRoZSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlcy5cbiAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcywgcmVzdWx0cyA9IG5ldyBTZXQoKSkge1xuICAgIFtwcmltYXJ5VHlwZV0gPSBwcmltYXJ5VHlwZS5tYXRjaCgvXlxcdyovdSk7XG4gICAgaWYgKHJlc3VsdHMuaGFzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEhhc2hlcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhayhlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikpO1xufVxuLyoqXG4gKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUgdG8gaGFzaC5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBvYmplY3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhayhlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xufVxuLyoqXG4gKiBSZW1vdmVzIHByb3BlcnRpZXMgZnJvbSBhIG1lc3NhZ2Ugb2JqZWN0IHRoYXQgYXJlIG5vdCBkZWZpbmVkIHBlciBFSVAtNzEyLlxuICpcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0LlxuICogQHJldHVybnMgVGhlIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0IHdpdGggb25seSBhbGxvd2VkIGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChkYXRhW2tleV0pIHtcbiAgICAgICAgICAgIHNhbml0aXplZERhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3R5cGVzJyBpbiBzYW5pdGl6ZWREYXRhKSB7XG4gICAgICAgIHNhbml0aXplZERhdGEudHlwZXMgPSBPYmplY3QuYXNzaWduKHsgRUlQNzEyRG9tYWluOiBbXSB9LCBzYW5pdGl6ZWREYXRhLnR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGE7XG59XG4vKipcbiAqIEhhc2ggYSB0eXBlZCBtZXNzYWdlIGFjY29yZGluZyB0byBFSVAtNzEyLiBUaGUgcmV0dXJuZWQgbWVzc2FnZSBzdGFydHMgd2l0aCB0aGUgRUlQLTcxMiBwcmVmaXgsXG4gKiB3aGljaCBpcyBcIjE5MDFcIiwgZm9sbG93ZWQgYnkgdGhlIGhhc2ggb2YgdGhlIGRvbWFpbiBzZXBhcmF0b3IsIHRoZW4gdGhlIGRhdGEgKGlmIGFueSkuXG4gKiBUaGUgcmVzdWx0IGlzIGhhc2hlZCBhZ2FpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzaWduIHRoZSBtZXNzYWdlLiBUaGUgcmVzdWx0aW5nIGhhc2ggbXVzdCBzdGlsbCBiZSBzaWduZWQgdG8gY3JlYXRlIGFuXG4gKiBFSVAtNzEyIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHR5cGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVpcDcxMkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gc2FuaXRpemVEYXRhKHR5cGVkRGF0YSk7XG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldO1xuICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgc2FuaXRpemVkRGF0YS5kb21haW4sIHNhbml0aXplZERhdGEudHlwZXMsIHZlcnNpb24pKTtcbiAgICBpZiAoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ0VJUDcxMkRvbWFpbicpIHtcbiAgICAgICAgcGFydHMucHVzaChoYXNoU3RydWN0KFxuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRoaXMgaXMgYSBzdHJpbmcsIHNvIHRoaXMgdHlwZSBjYXN0IGNhbiBiZSByZW1vdmVkLlxuICAgICAgICBzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHZlcnNpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmtlY2NhayhCdWZmZXIuY29uY2F0KHBhcnRzKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGEuXG4gKi9cbmV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSB7XG4gICAgZW5jb2RlRGF0YSxcbiAgICBlbmNvZGVUeXBlLFxuICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzLFxuICAgIGhhc2hTdHJ1Y3QsXG4gICAgaGFzaFR5cGUsXG4gICAgc2FuaXRpemVEYXRhLFxuICAgIGVpcDcxMkhhc2gsXG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgXCJWMVwiIGhhc2ggZm9yIHRoZSBwcm92aWRlZCB0eXBlZCBtZXNzYWdlLlxuICpcbiAqIFRoZSBoYXNoIHdpbGwgYmUgZ2VuZXJhdGVkIGluIGFjY29yZGFuY2Ugd2l0aCBhbiBlYXJsaWVyIHZlcnNpb24gb2YgdGhlIEVJUC03MTJcbiAqIHNwZWNpZmljYXRpb24uIFRoaXMgaGFzaCBpcyB1c2VkIGluIGBzaWduVHlwZWREYXRhX3YxYC5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBfdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpO1xufVxuZXhwb3J0cy50eXBlZFNpZ25hdHVyZUhhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2g7XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gX3R5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKGUudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS50eXBlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlLnR5cGV9ICR7ZS5uYW1lfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfYWJpXzEuc29saWRpdHlTSEEzKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgZXRoZXJldW1qc19hYmlfMS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgICBldGhlcmV1bWpzX2FiaV8xLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSksXG4gICAgXSk7XG59XG4vKipcbiAqIFNpZ24gdHlwZWQgZGF0YSBhY2NvcmRpbmcgdG8gRUlQLTcxMi4gVGhlIHNpZ25pbmcgZGlmZmVycyBiYXNlZCB1cG9uIHRoZSBgdmVyc2lvbmAuXG4gKlxuICogVjEgaXMgYmFzZWQgdXBvbiBbYW4gZWFybHkgdmVyc2lvbiBvZiBFSVAtNzEyXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9wdWxsLzcxMi9jb21taXRzLzIxYWJlMjU0ZmUwNDUyZDg1ODNkNWIxMzJiMWQ3YmU4N2MwNDM5Y2EpXG4gKiB0aGF0IGxhY2tlZCBzb21lIGxhdGVyIHNlY3VyaXR5IGltcHJvdmVtZW50cywgYW5kIHNob3VsZCBnZW5lcmFsbHkgYmUgbmVnbGVjdGVkIGluIGZhdm9yIG9mXG4gKiBsYXRlciB2ZXJzaW9ucy5cbiAqXG4gKiBWMyBpcyBiYXNlZCBvbiBbRUlQLTcxMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpLCBleGNlcHQgdGhhdCBhcnJheXMgYW5kXG4gKiByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFY0IGlzIGJhc2VkIG9uIFtFSVAtNzEyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMiksIGFuZCBpbmNsdWRlcyBmdWxsIHN1cHBvcnQgb2ZcbiAqIGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduaW5nIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgdHlwZWQgZGF0YSB0byBzaWduLlxuICogQHBhcmFtIG9wdGlvbnMudmVyc2lvbiAtIFRoZSBzaWduaW5nIHZlcnNpb24gdG8gdXNlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5mdW5jdGlvbiBzaWduVHlwZWREYXRhKHsgcHJpdmF0ZUtleSwgZGF0YSwgdmVyc2lvbiwgfSkge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uKTtcbiAgICBpZiAodXRpbHNfMS5pc051bGxpc2goZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNOdWxsaXNoKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMVxuICAgICAgICA/IF90eXBlZFNpZ25hdHVyZUhhc2goZGF0YSlcbiAgICAgICAgOiBleHBvcnRzLlR5cGVkRGF0YVV0aWxzLmVpcDcxMkhhc2goZGF0YSwgdmVyc2lvbik7XG4gICAgY29uc3Qgc2lnID0gZXRoZXJldW1qc191dGlsXzEuZWNzaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gdXRpbHNfMS5jb25jYXRTaWcoZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIoc2lnLnYpLCBzaWcuciwgc2lnLnMpO1xufVxuZXhwb3J0cy5zaWduVHlwZWREYXRhID0gc2lnblR5cGVkRGF0YTtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IGNyZWF0ZWQgdGhlIGdpdmVuIEVJUC03MTJcbiAqIHNpZ25hdHVyZS4gVGhlIHZlcnNpb24gcHJvdmlkZWQgbXVzdCBtYXRjaCB0aGUgdmVyc2lvbiB1c2VkIHRvXG4gKiBjcmVhdGUgdGhlIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgdHlwZWQgZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4LXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHBhcmFtIG9wdGlvbnMudmVyc2lvbiAtIFRoZSBzaWduaW5nIHZlcnNpb24gdG8gdXNlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGFkZHJlc3Mgb2YgdGhlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclR5cGVkU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB2ZXJzaW9uLCB9KSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICh1dGlsc18xLmlzTnVsbGlzaChkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHNfMS5pc051bGxpc2goc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSB1dGlsc18xLnJlY292ZXJQdWJsaWNLZXkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gZXRoZXJldW1qc191dGlsXzEucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KHNlbmRlcik7XG59XG5leHBvcnRzLnJlY292ZXJUeXBlZFNpZ25hdHVyZSA9IHJlY292ZXJUeXBlZFNpZ25hdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24tdHlwZWQtZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gZXhwb3J0cy5jb25jYXRTaWcgPSBleHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gZXhwb3J0cy5pc051bGxpc2ggPSBleHBvcnRzLnBhZFdpdGhaZXJvZXMgPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbi8qKlxuICogUGFkcyB0aGUgZnJvbnQgb2YgdGhlIGdpdmVuIGhleCBzdHJpbmcgd2l0aCB6ZXJvZXMgdW50aWwgaXQgcmVhY2hlcyB0aGVcbiAqIHRhcmdldCBsZW5ndGguIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgYWxyZWFkeSBsb25nZXIgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHRhcmdldCBsZW5ndGgsIGl0IGlzIHJldHVybmVkIHVubW9kaWZpZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IHN0cmluZyBpcyBcIjB4XCItcHJlZml4ZWQgb3Igbm90IGEgaGV4IHN0cmluZywgYW4gZXJyb3Igd2lsbCBiZVxuICogdGhyb3duLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHBhZCB3aXRoIHplcm9lcy5cbiAqIEBwYXJhbSB0YXJnZXRMZW5ndGggLSBUaGUgdGFyZ2V0IGxlbmd0aCBvZiB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGlucHV0IHN0cmluZyBmcm9udC1wYWRkZWQgd2l0aCB6ZXJvZXMsIG9yIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIGlmIGl0IHdhcyBhbHJlYWR5IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0byB0aGUgdGFyZ2V0IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyhoZXhTdHJpbmcsIHRhcmdldExlbmd0aCkge1xuICAgIGlmIChoZXhTdHJpbmcgIT09ICcnICYmICEvXlthLWYwLTldKyQvaXUudGVzdChoZXhTdHJpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gdW5wcmVmaXhlZCBoZXggc3RyaW5nLiBSZWNlaXZlZDogJHtoZXhTdHJpbmd9YCk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRMZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBub24tbmVnYXRpdmUgaW50ZWdlciB0YXJnZXQgbGVuZ3RoLiBSZWNlaXZlZDogJHt0YXJnZXRMZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0LmNhbGwoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgsICcwJyk7XG59XG5leHBvcnRzLnBhZFdpdGhaZXJvZXMgPSBwYWRXaXRoWmVyb2VzO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbnVsbGlzaC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIG51bGxpc2guXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbGlzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc051bGxpc2ggPSBpc051bGxpc2g7XG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIEJ1ZmZlci4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgZXF1aXZhbGVudCB0byB0aGUgYHRvQnVmZmVyYCBmdW5jdGlvbiBpblxuICogYGV0aGVyZXVtanMtdXRpbEA1LjIuMWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBCdWZmZXIuXG4gKiBAcmV0dXJucyBUaGUgZ2l2ZW4gdmFsdWUgYXMgYSBCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGxlZ2FjeVRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWV0aGpzX3V0aWxfMS5pc0hleFN0cmluZyh2YWx1ZSlcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgOiBldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcih2YWx1ZSk7XG59XG5leHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gbGVnYWN5VG9CdWZmZXI7XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgc2luZ2xlICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZSBhcyBhICcweCctcHJlZml4ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSBldGhlcmV1bWpzX3V0aWxfMS5mcm9tU2lnbmVkKHIpO1xuICAgIGNvbnN0IHNTaWcgPSBldGhlcmV1bWpzX3V0aWxfMS5mcm9tU2lnbmVkKHMpO1xuICAgIGNvbnN0IHZTaWcgPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0ludCh2KTtcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhldGhlcmV1bWpzX3V0aWxfMS50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKGV0aGVyZXVtanNfdXRpbF8xLnRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NCk7XG4gICAgY29uc3QgdlN0ciA9IGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChldGhqc191dGlsXzEuaW50VG9IZXgodlNpZykpO1xuICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpO1xufVxuZXhwb3J0cy5jb25jYXRTaWcgPSBjb25jYXRTaWc7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFuZCBtZXNzYWdlIGhhc2guXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHNpZ25lZCBtZXNzYWdlLlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWdQYXJhbXMgPSBldGhlcmV1bWpzX3V0aWxfMS5mcm9tUnBjU2lnKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmVjcmVjb3ZlcihtZXNzYWdlSGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucyk7XG59XG5leHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0IHRvIGEgbG93ZXItY2FzZWQgJzB4Jy1wcmVmaXhlZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcihpbnB1dCk7XG4gICAgICAgIGlucHV0ID0gZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgoYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IG1zZyA9ICdldGgtc2lnLXV0aWwubm9ybWFsaXplKCkgcmVxdWlyZXMgaGV4IHN0cmluZyBvciBpbnRlZ2VyIGlucHV0Lic7XG4gICAgICAgIG1zZyArPSBgIHJlY2VpdmVkICR7dHlwZW9mIGlucHV0fTogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChpbnB1dC50b0xvd2VyQ2FzZSgpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImxldCB7IHVybEFscGhhYmV0IH0gPSByZXF1aXJlKCcuL3VybC1hbHBoYWJldC9pbmRleC5janMnKVxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnICYmXG4gICAgdHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1JlYWN0IE5hdGl2ZSBkb2VzIG5vdCBoYXZlIGEgYnVpbHQtaW4gc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcyB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAgICdGb3Igc2VjdXJlIElEcywgaW1wb3J0IGByZWFjdC1uYXRpdmUtZ2V0LXJhbmRvbS12YWx1ZXNgICcgK1xuICAgICAgICAnYmVmb3JlIE5hbm8gSUQuJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbXBvcnQgZmlsZSB3aXRoIGBpZiAoIXdpbmRvdy5jcnlwdG8pIHdpbmRvdy5jcnlwdG8gPSB3aW5kb3cubXNDcnlwdG9gJyArXG4gICAgICAgICcgYmVmb3JlIGltcG9ydGluZyBOYW5vIElEIHRvIGZpeCBJRSAxMSBzdXBwb3J0J1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91ciBicm93c2VyIGRvZXMgbm90IGhhdmUgc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgc2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKE1hdGgubG9nKGFscGhhYmV0Lmxlbmd0aCAtIDEpIC8gTWF0aC5MTjIpKSAtIDFcbiAgbGV0IHN0ZXAgPSAtfigoMS42ICogbWFzayAqIHNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUpID0+IGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSlcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIGxldCBieXRlID0gYnl0ZXNbc2l6ZV0gJiA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjMpIHtcbiAgICAgIGlkICs9ICdfJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uZXR3b3JrQWNjZXNzRW5kb3dtZW50QnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IFBlcm1pc3Npb25fMSA9IHJlcXVpcmUoXCIuLi9QZXJtaXNzaW9uXCIpO1xuY29uc3QgcGVybWlzc2lvbk5hbWUgPSAnZW5kb3dtZW50Om5ldHdvcmstYWNjZXNzJztcbi8qKlxuICogYGVuZG93bWVudDpuZXR3b3JrLWFjY2Vzc2AgcmV0dXJucyB0aGUgbmFtZSBvZiBnbG9iYWwgYnJvd3NlciBBUEkocykgdGhhdFxuICogZW5hYmxlIG5ldHdvcmsgYWNjZXNzLiBUaGlzIGlzIGludGVuZGVkIHRvIHBvcHVsYXRlIHRoZSBlbmRvd21lbnRzIG9mIHRoZVxuICogU0VTIENvbXBhcnRtZW50IGluIHdoaWNoIGEgU25hcCBleGVjdXRlcy5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoX2J1aWxkZXJPcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGVybWlzc2lvblR5cGU6IFBlcm1pc3Npb25fMS5QZXJtaXNzaW9uVHlwZS5FbmRvd21lbnQsXG4gICAgICAgIHRhcmdldEtleTogcGVybWlzc2lvbk5hbWUsXG4gICAgICAgIGFsbG93ZWRDYXZlYXRzOiBudWxsLFxuICAgICAgICBlbmRvd21lbnRHZXR0ZXI6IChfZ2V0dGVyT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFsnZmV0Y2gnXTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMubmV0d29ya0FjY2Vzc0VuZG93bWVudEJ1aWxkZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICB0YXJnZXRLZXk6IHBlcm1pc3Npb25OYW1lLFxuICAgIHNwZWNpZmljYXRpb25CdWlsZGVyLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLWFjY2Vzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBleHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLnRpbWVTaW5jZSA9IHZvaWQgMDtcbmNvbnN0IGZhc3RfZGVlcF9lcXVhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIikpO1xuLyoqXG4gKiBAcGFyYW0gdGltZXN0YW1wIC0gQSBVbml4IG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gKi9cbmZ1bmN0aW9uIHRpbWVTaW5jZSh0aW1lc3RhbXApIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cbmV4cG9ydHMudGltZVNpbmNlID0gdGltZVNpbmNlO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3QsIGtleSkgPT4gUmVmbGVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICoge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIHtAbGluayBKc29ufSB0eXBlIGd1YXJkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIHZhbGlkIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZhc3RfZGVlcF9lcXVhbF8xLmRlZmF1bHQodmFsdWUsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IGV4cG9ydHMuRHVwbGljYXRlQ2F2ZWF0RXJyb3IgPSBleHBvcnRzLkZvcmJpZGRlbkNhdmVhdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IgPSBleHBvcnRzLkNhdmVhdEludmFsaWRKc29uRXJyb3IgPSBleHBvcnRzLkNhdmVhdE1pc3NpbmdWYWx1ZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RXJyb3IgPSBleHBvcnRzLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvciA9IGV4cG9ydHMuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3IgPSBleHBvcnRzLkludmFsaWRDYXZlYXRzUHJvcGVydHlFcnJvciA9IGV4cG9ydHMuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yID0gZXhwb3J0cy5FbmRvd21lbnRQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgPSBleHBvcnRzLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yID0gZXhwb3J0cy5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3IgPSBleHBvcnRzLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yID0gZXhwb3J0cy5pbnRlcm5hbEVycm9yID0gZXhwb3J0cy51c2VyUmVqZWN0ZWRSZXF1ZXN0ID0gZXhwb3J0cy5pbnZhbGlkUGFyYW1zID0gZXhwb3J0cy5tZXRob2ROb3RGb3VuZCA9IGV4cG9ydHMudW5hdXRob3JpemVkID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmZ1bmN0aW9uIHVuYXV0aG9yaXplZChvcHRzKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7XG4gICAgICAgIG1lc3NhZ2U6ICdVbmF1dGhvcml6ZWQgdG8gcGVyZm9ybSBhY3Rpb24uIFRyeSByZXF1ZXN0aW5nIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uKHMpIGZpcnN0LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2RvY3MubWV0YW1hc2suaW8vZ3VpZGUvcnBjLWFwaS5odG1sI3Blcm1pc3Npb25zJyxcbiAgICAgICAgZGF0YTogb3B0cy5kYXRhLFxuICAgIH0pO1xufVxuZXhwb3J0cy51bmF1dGhvcml6ZWQgPSB1bmF1dGhvcml6ZWQ7XG5mdW5jdGlvbiBtZXRob2ROb3RGb3VuZChtZXRob2QsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBtZXRob2QgXCIke21ldGhvZH1cIiBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuYDtcbiAgICBjb25zdCBvcHRzID0geyBtZXNzYWdlIH07XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKG9wdHMpO1xufVxuZXhwb3J0cy5tZXRob2ROb3RGb3VuZCA9IG1ldGhvZE5vdEZvdW5kO1xuZnVuY3Rpb24gaW52YWxpZFBhcmFtcyhvcHRzKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgZGF0YTogb3B0cy5kYXRhLFxuICAgICAgICBtZXNzYWdlOiBvcHRzLm1lc3NhZ2UsXG4gICAgfSk7XG59XG5leHBvcnRzLmludmFsaWRQYXJhbXMgPSBpbnZhbGlkUGFyYW1zO1xuZnVuY3Rpb24gdXNlclJlamVjdGVkUmVxdWVzdChkYXRhKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoeyBkYXRhIH0pO1xufVxuZXhwb3J0cy51c2VyUmVqZWN0ZWRSZXF1ZXN0ID0gdXNlclJlamVjdGVkUmVxdWVzdDtcbmZ1bmN0aW9uIGludGVybmFsRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlLCBkYXRhIH0pO1xufVxuZXhwb3J0cy5pbnRlcm5hbEVycm9yID0gaW50ZXJuYWxFcnJvcjtcbmNsYXNzIEludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbikge1xuICAgICAgICBzdXBlcihgSW52YWxpZCBzdWJqZWN0IGlkZW50aWZpZXI6IFwiJHt0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJyA/IG9yaWdpbiA6IHR5cGVvZiBvcmlnaW59XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yID0gSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3I7XG5jbGFzcyBVbnJlY29nbml6ZWRTdWJqZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luKSB7XG4gICAgICAgIHN1cGVyKGBVbnJlY29nbml6ZWQgc3ViamVjdDogXCIke29yaWdpbn1cIiBoYXMgbm8gcGVybWlzc2lvbnMuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3IgPSBVbnJlY29nbml6ZWRTdWJqZWN0RXJyb3I7XG5jbGFzcyBJbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luLCB0YXJnZXQsIGFwcHJvdmVkUGVybWlzc2lvbikge1xuICAgICAgICBzdXBlcihgSW52YWxpZCBhcHByb3ZlZCBwZXJtaXNzaW9uIGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBhbmQgdGFyZ2V0IFwiJHt0YXJnZXR9XCIuYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgb3JpZ2luLCB0YXJnZXQsIGFwcHJvdmVkUGVybWlzc2lvbiB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yID0gSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yO1xuY2xhc3MgUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBTdWJqZWN0IFwiJHtvcmlnaW59XCIgaGFzIG5vIHBlcm1pc3Npb24gZm9yIFwiJHt0YXJnZXR9XCIuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgPSBQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3I7XG5jbGFzcyBFbmRvd21lbnRQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoYFN1YmplY3QgXCIke29yaWdpbn1cIiBoYXMgbm8gcGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIi5gKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4gfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW5kb3dtZW50UGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yID0gRW5kb3dtZW50UGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yO1xuY2xhc3MgVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBVbnJlY29nbml6ZWQgY2F2ZWF0IHR5cGU6IFwiJHtjYXZlYXRUeXBlfVwiYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0VHlwZSB9O1xuICAgICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IgPSBVbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdHNQcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihgVGhlIFwiY2F2ZWF0c1wiIHByb3BlcnR5IG9mIHBlcm1pc3Npb24gZm9yIFwiJHt0YXJnZXR9XCIgb2Ygc3ViamVjdCBcIiR7b3JpZ2lufVwiIGlzIGludmFsaWQuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXkgaWYgc3BlY2lmaWVkLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRzUHJvcGVydHkgfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDYXZlYXRzUHJvcGVydHlFcnJvciA9IEludmFsaWRDYXZlYXRzUHJvcGVydHlFcnJvcjtcbmNsYXNzIENhdmVhdERvZXNOb3RFeGlzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiIG9mIHN1YmplY3QgXCIke29yaWdpbn1cIiBoYXMgbm8gY2F2ZWF0IG9mIHR5cGUgXCIke2NhdmVhdFR5cGV9XCIuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5DYXZlYXREb2VzTm90RXhpc3RFcnJvciA9IENhdmVhdERvZXNOb3RFeGlzdEVycm9yO1xuY2xhc3MgQ2F2ZWF0QWxyZWFkeUV4aXN0c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiIG9mIHN1YmplY3QgXCIke29yaWdpbn1cIiBhbHJlYWR5IGhhcyBhIGNhdmVhdCBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0QWxyZWFkeUV4aXN0c0Vycm9yID0gQ2F2ZWF0QWxyZWFkeUV4aXN0c0Vycm9yO1xuY2xhc3MgSW52YWxpZENhdmVhdEVycm9yIGV4dGVuZHMgZXRoX3JwY19lcnJvcnNfMS5FdGhlcmV1bVJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNlaXZlZENhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoZXRoX3JwY19lcnJvcnNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUGFyYW1zLCBgSW52YWxpZCBjYXZlYXQuIENhdmVhdHMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLmAsIHsgcmVjZWl2ZWRDYXZlYXQgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgb3JpZ2luLCB0YXJnZXQgfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDYXZlYXRFcnJvciA9IEludmFsaWRDYXZlYXRFcnJvcjtcbmNsYXNzIEludmFsaWRDYXZlYXRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IHR5cGVzIG11c3QgYmUgc3RyaW5ncy4gUmVjZWl2ZWQ6IFwiJHt0eXBlb2YgY2F2ZWF0LnR5cGV9XCJgKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yID0gSW52YWxpZENhdmVhdFR5cGVFcnJvcjtcbmNsYXNzIENhdmVhdE1pc3NpbmdWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYENhdmVhdCBpcyBtaXNzaW5nIFwidmFsdWVcIiBmaWVsZC5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5DYXZlYXRNaXNzaW5nVmFsdWVFcnJvciA9IENhdmVhdE1pc3NpbmdWYWx1ZUVycm9yO1xuY2xhc3MgQ2F2ZWF0SW52YWxpZEpzb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBDYXZlYXQgXCJ2YWx1ZVwiIGlzIGludmFsaWQgSlNPTi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5DYXZlYXRJbnZhbGlkSnNvbkVycm9yID0gQ2F2ZWF0SW52YWxpZEpzb25FcnJvcjtcbmNsYXNzIEludmFsaWRDYXZlYXRGaWVsZHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBDYXZlYXQgaGFzIHVuZXhwZWN0ZWQgbnVtYmVyIG9mIGZpZWxkczogXCIke09iamVjdC5rZXlzKGNhdmVhdCkubGVuZ3RofVwiYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENhdmVhdEZpZWxkc0Vycm9yID0gSW52YWxpZENhdmVhdEZpZWxkc0Vycm9yO1xuY2xhc3MgRm9yYmlkZGVuQ2F2ZWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9ucyBmb3IgdGFyZ2V0IFwiJHt0YXJnZXROYW1lfVwiIG1heSBub3QgaGF2ZSBjYXZlYXRzIG9mIHR5cGUgXCIke2NhdmVhdFR5cGV9XCIuYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXQ6IHRhcmdldE5hbWUgfTtcbiAgICB9XG59XG5leHBvcnRzLkZvcmJpZGRlbkNhdmVhdEVycm9yID0gRm9yYmlkZGVuQ2F2ZWF0RXJyb3I7XG5jbGFzcyBEdXBsaWNhdGVDYXZlYXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldE5hbWUpIHtcbiAgICAgICAgc3VwZXIoYFBlcm1pc3Npb25zIGZvciB0YXJnZXQgXCIke3RhcmdldE5hbWV9XCIgY29udGFpbnMgbXVsdGlwbGUgY2F2ZWF0cyBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0OiB0YXJnZXROYW1lIH07XG4gICAgfVxufVxuZXhwb3J0cy5EdXBsaWNhdGVDYXZlYXRFcnJvciA9IER1cGxpY2F0ZUNhdmVhdEVycm9yO1xuY2xhc3MgUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbnMgcmVxdWVzdCB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yID0gUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGcmVlemUgKG8pIHtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcblxuICB2YXIgb0lzRnVuY3Rpb24gPSB0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiO1xuICB2YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChoYXNPd25Qcm9wLmNhbGwobywgcHJvcClcbiAgICAmJiAob0lzRnVuY3Rpb24gPyBwcm9wICE9PSAnY2FsbGVyJyAmJiBwcm9wICE9PSAnY2FsbGVlJyAmJiBwcm9wICE9PSAnYXJndW1lbnRzJyA6IHRydWUgKVxuICAgICYmIG9bcHJvcF0gIT09IG51bGxcbiAgICAmJiAodHlwZW9mIG9bcHJvcF0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9bcHJvcF0gPT09IFwiZnVuY3Rpb25cIilcbiAgICAmJiAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pKSB7XG4gICAgICBkZWVwRnJlZXplKG9bcHJvcF0pO1xuICAgIH1cbiAgfSk7XG4gIFxuICByZXR1cm4gbztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBwZXJtaXNzaW9uIG1pZGRsZXdhcmUgZnVuY3Rpb24gZmFjdG9yeS4gSW50ZW5kZWQgZm9yIGludGVybmFsIHVzZVxuICogaW4gdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uIExpa2UgYW55IHtAbGluayBKc29uUnBjRW5naW5lfVxuICogbWlkZGxld2FyZSwgZWFjaCBtaWRkbGV3YXJlIHdpbGwgb25seSByZWNlaXZlIHJlcXVlc3RzIGZyb20gYSBwYXJ0aWN1bGFyXG4gKiBzdWJqZWN0IC8gb3JpZ2luLiBIb3dldmVyLCBlYWNoIG1pZGRsZXdhcmUgYWxzbyByZXF1aXJlcyBhY2Nlc3MgdG8gc29tZVxuICogYFBlcm1pc3Npb25Db250cm9sbGVyYCBpbnRlcm5hbHMsIHdoaWNoIGlzIHdoeSB0aGlzIFwiZmFjdG9yeSBmYWN0b3J5XCIgZXhpc3RzLlxuICpcbiAqIFRoZSBtaWRkbGV3YXJlcyByZXR1cm5lZCBieSB0aGUgZmFjdG9yeSB3aWxsIHBhc3MgdGhyb3VnaCByZXF1ZXN0cyBmb3JcbiAqIHVucmVzdHJpY3RlZCBtZXRob2RzLCBhbmQgYXR0ZW1wdCB0byBleGVjdXRlIHJlc3RyaWN0ZWQgbWV0aG9kcy4gSWYgYSBtZXRob2RcbiAqIGlzIG5laXRoZXIgcmVzdHJpY3RlZCBub3IgdW5yZXN0cmljdGVkLCBhIFwibWV0aG9kIG5vdCBmb3VuZFwiIGVycm9yIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICogSWYgYSBtZXRob2QgaXMgcmVzdHJpY3RlZCwgdGhlIG1pZGRsZXdhcmUgd2lsbCBmaXJzdCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZVxuICogc3ViamVjdCdzIHBlcm1pc3Npb24gZm9yIHRoYXQgbWV0aG9kLiBJZiB0aGUgcGVybWlzc2lvbiBpcyBmb3VuZCwgdGhlIG1ldGhvZFxuICogd2lsbCBiZSBleGVjdXRlZC4gT3RoZXJ3aXNlLCBhbiBcInVuYXV0aG9yaXplZFwiIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRpb25zLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kIC0ge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0uXG4gKiBAcGFyYW0gb3B0aW9ucy5nZXRSZXN0cmljdGVkTWV0aG9kIC0ge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmdldFJlc3RyaWN0ZWRNZXRob2R9LlxuICogQHBhcmFtIG9wdGlvbnMuaXNVbnJlc3RyaWN0ZWRNZXRob2QgLSBBIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHdoZXRoZXIgYVxuICogcGFydGljdWxhciBtZXRob2QgaXMgdW5yZXN0cmljdGVkLlxuICogQHJldHVybnMgQSBwZXJtaXNzaW9uIG1pZGRsZXdhcmUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5KHsgZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QsIGdldFJlc3RyaWN0ZWRNZXRob2QsIGlzVW5yZXN0cmljdGVkTWV0aG9kLCB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHN1YmplY3QpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IHN1YmplY3Q7XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJyB8fCAhb3JpZ2luKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJqZWN0IFwib3JpZ2luXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnNNaWRkbGV3YXJlID0gYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgICAgICAgICAvLyBTa2lwIHJlZ2lzdGVyZWQgdW5yZXN0cmljdGVkIG1ldGhvZHMuXG4gICAgICAgICAgICBpZiAoaXNVbnJlc3RyaWN0ZWRNZXRob2QobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgbm8gcmVzdHJpY3RlZCBtZXRob2QgaW1wbGVtZW50YXRpb24gaXMgZm91bmQuXG4gICAgICAgICAgICBjb25zdCBtZXRob2RJbXBsZW1lbnRhdGlvbiA9IGdldFJlc3RyaWN0ZWRNZXRob2QobWV0aG9kLCBvcmlnaW4pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QobWV0aG9kSW1wbGVtZW50YXRpb24sIHN1YmplY3QsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9IGVycm9yc18xLmludGVybmFsRXJyb3IoYFJlcXVlc3QgZm9yIG1ldGhvZCBcIiR7cmVxLm1ldGhvZH1cIiByZXR1cm5lZCB1bmRlZmluZWQgcmVzdWx0LmAsIHsgcmVxdWVzdDogcmVxIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShwZXJtaXNzaW9uc01pZGRsZXdhcmUpO1xuICAgIH07XG59XG5leHBvcnRzLmdldFBlcm1pc3Npb25NaWRkbGV3YXJlRmFjdG9yeSA9IGdldFBlcm1pc3Npb25NaWRkbGV3YXJlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcm1pc3Npb24tbWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGVybWlzc2lvbnNIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmV4cG9ydHMuZ2V0UGVybWlzc2lvbnNIYW5kbGVyID0ge1xuICAgIG1ldGhvZE5hbWVzOiBbdXRpbHNfMS5NZXRob2ROYW1lcy5nZXRQZXJtaXNzaW9uc10sXG4gICAgaW1wbGVtZW50YXRpb246IGdldFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24sXG4gICAgaG9va05hbWVzOiB7XG4gICAgICAgIGdldFBlcm1pc3Npb25zRm9yT3JpZ2luOiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnNJbXBsZW1lbnRhdGlvbihfcmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgZ2V0UGVybWlzc2lvbnNGb3JPcmlnaW4gfSkge1xuICAgIHJlcy5yZXN1bHQgPSBPYmplY3QudmFsdWVzKGdldFBlcm1pc3Npb25zRm9yT3JpZ2luKCkgfHwge30pO1xuICAgIHJldHVybiBlbmQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFBlcm1pc3Npb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXF1ZXN0UGVybWlzc2lvbnNIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuZXhwb3J0cy5yZXF1ZXN0UGVybWlzc2lvbnNIYW5kbGVyID0ge1xuICAgIG1ldGhvZE5hbWVzOiBbdXRpbHNfMS5NZXRob2ROYW1lcy5yZXF1ZXN0UGVybWlzc2lvbnNdLFxuICAgIGltcGxlbWVudGF0aW9uOiByZXF1ZXN0UGVybWlzc2lvbnNJbXBsZW1lbnRhdGlvbixcbiAgICBob29rTmFtZXM6IHtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25zRm9yT3JpZ2luOiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24ocmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgcmVxdWVzdFBlcm1pc3Npb25zRm9yT3JpZ2luIH0pIHtcbiAgICBjb25zdCB7IGlkLCBwYXJhbXMgfSA9IHJlcTtcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykgfHxcbiAgICAgICAgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgIWlkKSkge1xuICAgICAgICByZXR1cm4gZW5kKGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXF1ZXN0OiBNdXN0IHNwZWNpZnkgYSB2YWxpZCBpZC4nLFxuICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0OiByZXEgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSB8fCAhdXRpbHNfMi5pc1BsYWluT2JqZWN0KHBhcmFtc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcnNfMS5pbnZhbGlkUGFyYW1zKHsgZGF0YTogeyByZXF1ZXN0OiByZXEgfSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IFtyZXF1ZXN0ZWRQZXJtaXNzaW9uc10gPSBwYXJhbXM7XG4gICAgY29uc3QgW2dyYW50ZWRQZXJtaXNzaW9uc10gPSBhd2FpdCByZXF1ZXN0UGVybWlzc2lvbnNGb3JPcmlnaW4ocmVxdWVzdGVkUGVybWlzc2lvbnMsIFN0cmluZyhpZCkpO1xuICAgIC8vIGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25gIGlzIHNwZWNpZmllZCB0byByZXR1cm4gYW4gYXJyYXkuXG4gICAgcmVzLnJlc3VsdCA9IE9iamVjdC52YWx1ZXMoZ3JhbnRlZFBlcm1pc3Npb25zKTtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0UGVybWlzc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlMjA7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGUyMDtcbmNvbnN0IHNjaGVtYTIyID0geyBcInRpdGxlXCI6IFwiU25hcCBNYW5pZmVzdFwiLCBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFNuYXAgbWFuaWZlc3QgZmlsZSBNVVNUIGJlIG5hbWVkIGBzbmFwLm1hbmlmZXN0Lmpzb25gIGFuZCBsb2NhdGVkIGluIHRoZSBwYWNrYWdlIHJvb3QgZGlyZWN0b3J5LlwiLCBcInR5cGVcIjogXCJvYmplY3RcIiwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSwgXCJyZXF1aXJlZFwiOiBbXCJ2ZXJzaW9uXCIsIFwiZGVzY3JpcHRpb25cIiwgXCJwcm9wb3NlZE5hbWVcIiwgXCJzb3VyY2VcIiwgXCJpbml0aWFsUGVybWlzc2lvbnNcIiwgXCJtYW5pZmVzdFZlcnNpb25cIl0sIFwicHJvcGVydGllc1wiOiB7IFwidmVyc2lvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiVmVyc2lvblwiLCBcImRlc2NyaXB0aW9uXCI6IFwiTVVTVCBiZSBhIHZhbGlkIFNlbVZlciB2ZXJzaW9uIHN0cmluZyBhbmQgZXF1YWwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYHBhY2thZ2UuanNvbmAgZmllbGQuXCIsIFwicGF0dGVyblwiOiBcIl4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopKD86LSgoPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKD86XFxcXC4oPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKSopKT8oPzpcXFxcKyhbMC05YS16QS1aLV0rKD86XFxcXC5bMC05YS16QS1aLV0rKSopKT8kXCIgfSwgXCJkZXNjcmlwdGlvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiRGVzY3JpcHRpb25cIiwgXCJkZXNjcmlwdGlvblwiOiBcIk1VU1QgYmUgYSBub24tZW1wdHkgc3RyaW5nIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyODAgY2hhcmFjdGVycy4gQSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgU25hcC5cIiwgXCJtaW5MZW5ndGhcIjogMSwgXCJtYXhMZW5ndGhcIjogMjgwIH0sIFwicHJvcG9zZWROYW1lXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwidGl0bGVcIjogXCJQcm9wb3NlZCBOYW1lXCIsIFwiZGVzY3JpcHRpb25cIjogXCJNVVNUIGJlIGEgc3RyaW5nIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyMTQgY2hhcmFjdGVycy4gVGhlIFNuYXAgYXV0aG9yJ3MgcHJvcG9zZWQgbmFtZSBmb3IgdGhlIFNuYXAuIFRoZSBTbmFwIGhvc3QgYXBwbGljYXRpb24gbWF5IGRpc3BsYXkgdGhpcyBuYW1lIHVubW9kaWZpZWQgaW4gaXRzIHVzZXIgaW50ZXJmYWNlLiBUaGUgcHJvcG9zZWQgbmFtZSBTSE9VTEQgYmUgaHVtYW4tcmVhZGFibGUuXCIsIFwibWluTGVuZ3RoXCI6IDEsIFwibWF4TGVuZ3RoXCI6IDIxNCwgXCJwYXR0ZXJuXCI6IFwiXig/OltBLVphLXowLTktX10rKCBbQS1aYS16MC05LV9dKykqKXwoPzooPzpAW0EtWmEtejAtOS0qfl1bQS1aYS16MC05LSouX35dKi8pP1tBLVphLXowLTktfl1bQS1aYS16MC05LS5ffl0qKSRcIiB9LCBcInJlcG9zaXRvcnlcIjogeyBcInRpdGxlXCI6IFwiUmVwb3NpdG9yeVwiLCBcImRlc2NyaXB0aW9uXCI6IFwiTUFZIGJlIG9taXR0ZWQuIElmIHByZXNlbnQsIE1VU1QgYmUgZXF1YWwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcGFja2FnZS5qc29uIGZpZWxkLlwiLCBcIm9uZU9mXCI6IFt7IFwidHlwZVwiOiBcIm51bGxcIiB9LCB7IFwidHlwZVwiOiBcIm9iamVjdFwiLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLCBcInJlcXVpcmVkXCI6IFtcInR5cGVcIiwgXCJ1cmxcIl0sIFwicHJvcGVydGllc1wiOiB7IFwidHlwZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm1pbkxlbmd0aFwiOiAxIH0sIFwidXJsXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwibWluTGVuZ3RoXCI6IDEgfSB9IH1dIH0sIFwic291cmNlXCI6IHsgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwidGl0bGVcIjogXCJTb3VyY2VcIiwgXCJkZXNjcmlwdGlvblwiOiBcIlNwZWNpZmllcyBzb21lIFNuYXAgbWV0YWRhdGEgYW5kIHdoZXJlIHRvIGZldGNoIHRoZSBTbmFwIGR1cmluZyBpbnN0YWxsYXRpb24uXCIsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsIFwicmVxdWlyZWRcIjogW1wic2hhc3VtXCIsIFwibG9jYXRpb25cIl0sIFwicHJvcGVydGllc1wiOiB7IFwic2hhc3VtXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwiZGVzY3JpcHRpb25cIjogXCJNVVNUIGJlIHRoZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNIQS0yNTYgaGFzaCBvZiB0aGUgU25hcCBzb3VyY2UgZmlsZS5cIiwgXCJtaW5MZW5ndGhcIjogNDQsIFwibWF4TGVuZ3RoXCI6IDQ0LCBcInBhdHRlcm5cIjogXCJeKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXszfT18W0EtWmEtejAtOSsvXXsyfT09KT8kXCIgfSwgXCJsb2NhdGlvblwiOiB7IFwidGl0bGVcIjogXCJTb3VyY2UgTG9jYXRpb25cIiwgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsIFwicmVxdWlyZWRcIjogW1wibnBtXCJdLCBcInByb3BlcnRpZXNcIjogeyBcIm5wbVwiOiB7IFwidGl0bGVcIjogXCJucG1cIiwgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsIFwicmVxdWlyZWRcIjogW1wiZmlsZVBhdGhcIiwgXCJwYWNrYWdlTmFtZVwiLCBcInJlZ2lzdHJ5XCJdLCBcInByb3BlcnRpZXNcIjogeyBcImZpbGVQYXRoXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwidGl0bGVcIjogXCJGaWxlIFBhdGhcIiwgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwYXRoIHRvIHRoZSBTbmFwIGJ1bmRsZSBmaWxlIGZyb20gdGhlIHByb2plY3Qgcm9vdCBkaXJlY3RvcnkuXCIsIFwibWluTGVuZ3RoXCI6IDEgfSwgXCJpY29uUGF0aFwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiSWNvbiBQYXRoXCIsIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcGF0aCB0byBhbiAuc3ZnIGZpbGUgZnJvbSB0aGUgcHJvamVjdCByb290IGRpcmVjdG9yeS5cIiwgXCJwYXR0ZXJuXCI6IFwiXFxcXHcrXFxcXC5zdmckXCIgfSwgXCJwYWNrYWdlTmFtZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiUGFja2FnZSBOYW1lXCIsIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgU25hcCdzIG5wbSBwYWNrYWdlIG5hbWUuXCIsIFwibWluTGVuZ3RoXCI6IDEgfSwgXCJyZWdpc3RyeVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwibnBtIFJlZ2lzdHJ5XCIsIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbnBtIHJlZ2lzdHJ5IFVSTC5cIiwgXCJlbnVtXCI6IFtcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnXCIsIFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCJdIH0gfSB9IH0gfSB9IH0sIFwiaW5pdGlhbFBlcm1pc3Npb25zXCI6IHsgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwidGl0bGVcIjogXCJJbml0aWFsIFBlcm1pc3Npb25zXCIsIFwiZGVzY3JpcHRpb25cIjogXCJNVVNUIGJlIGEgdmFsaWQgRUlQLTIyNTUgd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9ucyBwYXJhbWV0ZXIgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSBpbml0aWFsIHBlcm1pc3Npb25zIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgd2hlbiB0aGUgU25hcCBpcyBhZGRlZCB0byB0aGUgaG9zdCBhcHBsaWNhdGlvbi5cIiB9LCBcIm1hbmlmZXN0VmVyc2lvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiTWFuaWZlc3QgVmVyc2lvblwiLCBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFNuYXAgbWFuaWZlc3Qgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIHRhcmdldGVkIGJ5IHRoZSBtYW5pZmVzdC5cIiwgXCJlbnVtXCI6IFtcIjAuMVwiXSB9IH0gfTtcbmNvbnN0IHBhdHRlcm4wID0gbmV3IFJlZ0V4cChcIl4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopKD86LSgoPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKD86XFxcXC4oPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKSopKT8oPzpcXFxcKyhbMC05YS16QS1aLV0rKD86XFxcXC5bMC05YS16QS1aLV0rKSopKT8kXCIsIFwidVwiKTtcbmNvbnN0IHBhdHRlcm4xID0gbmV3IFJlZ0V4cChcIl4oPzpbQS1aYS16MC05LV9dKyggW0EtWmEtejAtOS1fXSspKil8KD86KD86QFtBLVphLXowLTktKn5dW0EtWmEtejAtOS0qLl9+XSovKT9bQS1aYS16MC05LX5dW0EtWmEtejAtOS0uX35dKikkXCIsIFwidVwiKTtcbmNvbnN0IHBhdHRlcm4yID0gbmV3IFJlZ0V4cChcIl4oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezJ9PT0pPyRcIiwgXCJ1XCIpO1xuY29uc3QgcGF0dGVybjMgPSBuZXcgUmVnRXhwKFwiXFxcXHcrXFxcXC5zdmckXCIsIFwidVwiKTtcbmNvbnN0IGZ1bmM4ID0gcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0O1xuY29uc3QgZnVuYzAgPSByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0O1xuZnVuY3Rpb24gdmFsaWRhdGUyMChkYXRhLCB7IGluc3RhbmNlUGF0aCA9IFwiXCIsIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSwgcm9vdERhdGEgPSBkYXRhIH0gPSB7fSkgeyBsZXQgdkVycm9ycyA9IG51bGw7IGxldCBlcnJvcnMgPSAwOyBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgaWYgKGRhdGEudmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVycjAgPSB7IGluc3RhbmNlUGF0aCwgc2NoZW1hUGF0aDogXCIjL3JlcXVpcmVkXCIsIGtleXdvcmQ6IFwicmVxdWlyZWRcIiwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXCJ2ZXJzaW9uXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJ2ZXJzaW9uXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIwKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgaWYgKGRhdGEuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlcnIxID0geyBpbnN0YW5jZVBhdGgsIHNjaGVtYVBhdGg6IFwiIy9yZXF1aXJlZFwiLCBrZXl3b3JkOiBcInJlcXVpcmVkXCIsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFwiZGVzY3JpcHRpb25cIiB9LCBtZXNzYWdlOiBcIm11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnXCIgKyBcImRlc2NyaXB0aW9uXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgaWYgKGRhdGEucHJvcG9zZWROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyMiA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInByb3Bvc2VkTmFtZVwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwicHJvcG9zZWROYW1lXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgaWYgKGRhdGEuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyMyA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInNvdXJjZVwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwic291cmNlXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIzKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgaWYgKGRhdGEuaW5pdGlhbFBlcm1pc3Npb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyNCA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcImluaXRpYWxQZXJtaXNzaW9uc1wiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwiaW5pdGlhbFBlcm1pc3Npb25zXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI0KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgaWYgKGRhdGEubWFuaWZlc3RWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyNSA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcIm1hbmlmZXN0VmVyc2lvblwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwibWFuaWZlc3RWZXJzaW9uXCIgKyBcIidcIiB9O1xuICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI1XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI1KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcnMrKztcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkwIGluIGRhdGEpIHtcbiAgICAgICAgaWYgKCEoKCgoKCgoa2V5MCA9PT0gXCJ2ZXJzaW9uXCIpIHx8IChrZXkwID09PSBcImRlc2NyaXB0aW9uXCIpKSB8fCAoa2V5MCA9PT0gXCJwcm9wb3NlZE5hbWVcIikpIHx8IChrZXkwID09PSBcInJlcG9zaXRvcnlcIikpIHx8IChrZXkwID09PSBcInNvdXJjZVwiKSkgfHwgKGtleTAgPT09IFwiaW5pdGlhbFBlcm1pc3Npb25zXCIpKSB8fCAoa2V5MCA9PT0gXCJtYW5pZmVzdFZlcnNpb25cIikpKSB7XG4gICAgICAgICAgICBjb25zdCBlcnI2ID0geyBpbnN0YW5jZVBhdGgsIHNjaGVtYVBhdGg6IFwiIy9hZGRpdGlvbmFsUHJvcGVydGllc1wiLCBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIHBhcmFtczogeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleTAgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGEwID0gZGF0YS52ZXJzaW9uO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4wLnRlc3QoZGF0YTApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyNyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi92ZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3ZlcnNpb24vcGF0dGVyblwiLCBrZXl3b3JkOiBcInBhdHRlcm5cIiwgcGFyYW1zOiB7IHBhdHRlcm46IFwiXigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopXFxcXC4oMHxbMS05XVxcXFxkKikoPzotKCg/OjB8WzEtOV1cXFxcZCp8XFxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikoPzpcXFxcLig/OjB8WzEtOV1cXFxcZCp8XFxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikpKikpPyg/OlxcXFwrKFswLTlhLXpBLVotXSsoPzpcXFxcLlswLTlhLXpBLVotXSspKikpPyRcIiB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggcGF0dGVybiBcXFwiXCIgKyBcIl4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopKD86LSgoPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKD86XFxcXC4oPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKSopKT8oPzpcXFxcKyhbMC05YS16QS1aLV0rKD86XFxcXC5bMC05YS16QS1aLV0rKSopKT8kXCIgKyBcIlxcXCJcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyN107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyOCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi92ZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3ZlcnNpb24vdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyOF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBkYXRhMSA9IGRhdGEuZGVzY3JpcHRpb247XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YTEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChmdW5jOChkYXRhMSkgPiAyODApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnI5ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL2Rlc2NyaXB0aW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL2Rlc2NyaXB0aW9uL21heExlbmd0aFwiLCBrZXl3b3JkOiBcIm1heExlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDI4MCB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgbW9yZSB0aGFuIDI4MCBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jOChkYXRhMSkgPCAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyMTAgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvZGVzY3JpcHRpb25cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvZGVzY3JpcHRpb24vbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMSB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgZmV3ZXIgdGhhbiAxIGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnIxMSA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9kZXNjcmlwdGlvblwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9kZXNjcmlwdGlvbi90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIxMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEucHJvcG9zZWROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGEyID0gZGF0YS5wcm9wb3NlZE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChmdW5jOChkYXRhMikgPiAyMTQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIxMiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9wcm9wb3NlZE5hbWVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcHJvcG9zZWROYW1lL21heExlbmd0aFwiLCBrZXl3b3JkOiBcIm1heExlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDIxNCB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgbW9yZSB0aGFuIDIxNCBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjEyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmM4KGRhdGEyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIxMyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9wcm9wb3NlZE5hbWVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcHJvcG9zZWROYW1lL21pbkxlbmd0aFwiLCBrZXl3b3JkOiBcIm1pbkxlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDEgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGZld2VyIHRoYW4gMSBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjEzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuMS50ZXN0KGRhdGEyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjE0ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3Byb3Bvc2VkTmFtZVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9wcm9wb3NlZE5hbWUvcGF0dGVyblwiLCBrZXl3b3JkOiBcInBhdHRlcm5cIiwgcGFyYW1zOiB7IHBhdHRlcm46IFwiXig/OltBLVphLXowLTktX10rKCBbQS1aYS16MC05LV9dKykqKXwoPzooPzpAW0EtWmEtejAtOS0qfl1bQS1aYS16MC05LSouX35dKi8pP1tBLVphLXowLTktfl1bQS1aYS16MC05LS5ffl0qKSRcIiB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggcGF0dGVybiBcXFwiXCIgKyBcIl4oPzpbQS1aYS16MC05LV9dKyggW0EtWmEtejAtOS1fXSspKil8KD86KD86QFtBLVphLXowLTktKn5dW0EtWmEtejAtOS0qLl9+XSovKT9bQS1aYS16MC05LX5dW0EtWmEtejAtOS0uX35dKikkXCIgKyBcIlxcXCJcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjE0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnIxNSA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9wcm9wb3NlZE5hbWVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcHJvcG9zZWROYW1lL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBzdHJpbmdcIiB9O1xuICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5yZXBvc2l0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGEzID0gZGF0YS5yZXBvc2l0b3J5O1xuICAgICAgICBjb25zdCBfZXJyczkgPSBlcnJvcnM7XG4gICAgICAgIGxldCB2YWxpZDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBhc3NpbmcwID0gbnVsbDtcbiAgICAgICAgY29uc3QgX2VycnMxMCA9IGVycm9ycztcbiAgICAgICAgaWYgKGRhdGEzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIxNiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5XCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMC90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJudWxsXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIG51bGxcIiB9O1xuICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3ZhbGlkMCA9IF9lcnJzMTAgPT09IGVycm9ycztcbiAgICAgICAgaWYgKF92YWxpZDApIHtcbiAgICAgICAgICAgIHZhbGlkMSA9IHRydWU7XG4gICAgICAgICAgICBwYXNzaW5nMCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2VycnMxMiA9IGVycm9ycztcbiAgICAgICAgaWYgKGRhdGEzICYmIHR5cGVvZiBkYXRhMyA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEzKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjE3ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3JlcG9zaXRvcnlcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcmVwb3NpdG9yeS9vbmVPZi8xL3JlcXVpcmVkXCIsIGtleXdvcmQ6IFwicmVxdWlyZWRcIiwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXCJ0eXBlXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJ0eXBlXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjE3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTMudXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIxOCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5XCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMS9yZXF1aXJlZFwiLCBrZXl3b3JkOiBcInJlcXVpcmVkXCIsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFwidXJsXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJ1cmxcIiArIFwiJ1wiIH07XG4gICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIxOF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMTgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5MSBpbiBkYXRhMykge1xuICAgICAgICAgICAgICAgIGlmICghKChrZXkxID09PSBcInR5cGVcIikgfHwgKGtleTEgPT09IFwidXJsXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIxOSA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5XCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMS9hZGRpdGlvbmFsUHJvcGVydGllc1wiLCBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIHBhcmFtczogeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleTEgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxOSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEzLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhNCA9IGRhdGEzLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhNCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYzgoZGF0YTQpIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMjAgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeS90eXBlXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMS9wcm9wZXJ0aWVzL3R5cGUvbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMSB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgZmV3ZXIgdGhhbiAxIGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjIwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMjEgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeS90eXBlXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMS9wcm9wZXJ0aWVzL3R5cGUvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjIxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE1ID0gZGF0YTMudXJsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YTUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmM4KGRhdGE1KSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjIyID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3JlcG9zaXRvcnkvdXJsXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvb25lT2YvMS9wcm9wZXJ0aWVzL3VybC9taW5MZW5ndGhcIiwga2V5d29yZDogXCJtaW5MZW5ndGhcIiwgcGFyYW1zOiB7IGxpbWl0OiAxIH0sIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBmZXdlciB0aGFuIDEgY2hhcmFjdGVyc1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMjJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIyMyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5L3VybFwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L29uZU9mLzEvcHJvcGVydGllcy91cmwvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjIzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyMjQgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L29uZU9mLzEvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwib2JqZWN0XCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIG9iamVjdFwiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMjRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjI0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdmFsaWQwID0gX2VycnMxMiA9PT0gZXJyb3JzO1xuICAgICAgICBpZiAoX3ZhbGlkMCAmJiB2YWxpZDEpIHtcbiAgICAgICAgICAgIHZhbGlkMSA9IGZhbHNlO1xuICAgICAgICAgICAgcGFzc2luZzAgPSBbcGFzc2luZzAsIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKF92YWxpZDApIHtcbiAgICAgICAgICAgICAgICB2YWxpZDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhc3NpbmcwID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkMSkge1xuICAgICAgICAgICAgY29uc3QgZXJyMjUgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L29uZU9mXCIsIGtleXdvcmQ6IFwib25lT2ZcIiwgcGFyYW1zOiB7IHBhc3NpbmdTY2hlbWFzOiBwYXNzaW5nMCB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIyNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBfZXJyczk7XG4gICAgICAgICAgICBpZiAodkVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZXJyczkpIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5sZW5ndGggPSBfZXJyczk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGE2ID0gZGF0YS5zb3VyY2U7XG4gICAgICAgIGlmIChkYXRhNiAmJiB0eXBlb2YgZGF0YTYgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhNikpIHtcbiAgICAgICAgICAgIGlmIChkYXRhNi5zaGFzdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjI2ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInNoYXN1bVwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwic2hhc3VtXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMjZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTYubG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjI3ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcImxvY2F0aW9uXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJsb2NhdGlvblwiICsgXCInXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjI3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkyIGluIGRhdGE2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKGtleTIgPT09IFwic2hhc3VtXCIpIHx8IChrZXkyID09PSBcImxvY2F0aW9uXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIyOCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2VcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5MiB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMjhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjI4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTYuc2hhc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTcgPSBkYXRhNi5zaGFzdW07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhNyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYzgoZGF0YTcpID4gNDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjI5ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9zaGFzdW1cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvc2hhc3VtL21heExlbmd0aFwiLCBrZXl3b3JkOiBcIm1heExlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDQ0IH0sIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gNDQgY2hhcmFjdGVyc1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMjldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jOChkYXRhNykgPCA0NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMzAgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL3NoYXN1bVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcHJvcGVydGllcy9zaGFzdW0vbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogNDQgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGZld2VyIHRoYW4gNDQgY2hhcmFjdGVyc1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjMwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0dGVybjIudGVzdChkYXRhNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjMxID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9zaGFzdW1cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvc2hhc3VtL3BhdHRlcm5cIiwga2V5d29yZDogXCJwYXR0ZXJuXCIsIHBhcmFtczogeyBwYXR0ZXJuOiBcIl4oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezJ9PT0pPyRcIiB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggcGF0dGVybiBcXFwiXCIgKyBcIl4oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezJ9PT0pPyRcIiArIFwiXFxcIlwiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjMxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIzMiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2Uvc2hhc3VtXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL3NoYXN1bS90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjMyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTYubG9jYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhOCA9IGRhdGE2LmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhOCAmJiB0eXBlb2YgZGF0YTggPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhOCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGE4Lm5wbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIzMyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2UvbG9jYXRpb25cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcIm5wbVwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwibnBtXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjMzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIzMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleTMgaW4gZGF0YTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGtleTMgPT09IFwibnBtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMzQgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5MyB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjM0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIzNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhOC5ucG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE5ID0gZGF0YTgubnBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGE5ICYmIHR5cGVvZiBkYXRhOSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGE5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhOS5maWxlUGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjM1ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9sb2NhdGlvbi9ucG1cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcHJvcGVydGllcy9ucG0vcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcImZpbGVQYXRoXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJmaWxlUGF0aFwiICsgXCInXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjM1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGE5LnBhY2thZ2VOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMzYgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uL25wbVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcHJvcGVydGllcy9sb2NhdGlvbi9wcm9wZXJ0aWVzL25wbS9yZXF1aXJlZFwiLCBrZXl3b3JkOiBcInJlcXVpcmVkXCIsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFwicGFja2FnZU5hbWVcIiB9LCBtZXNzYWdlOiBcIm11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnXCIgKyBcInBhY2thZ2VOYW1lXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIzNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMzYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTkucmVnaXN0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIzNyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2UvbG9jYXRpb24vbnBtXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL3Byb3BlcnRpZXMvbnBtL3JlcXVpcmVkXCIsIGtleXdvcmQ6IFwicmVxdWlyZWRcIiwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXCJyZWdpc3RyeVwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwicmVnaXN0cnlcIiArIFwiJ1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjM3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIzNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5NCBpbiBkYXRhOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoKChrZXk0ID09PSBcImZpbGVQYXRoXCIpIHx8IChrZXk0ID09PSBcImljb25QYXRoXCIpKSB8fCAoa2V5NCA9PT0gXCJwYWNrYWdlTmFtZVwiKSkgfHwgKGtleTQgPT09IFwicmVnaXN0cnlcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIzOCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2UvbG9jYXRpb24vbnBtXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL3Byb3BlcnRpZXMvbnBtL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5NCB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIzOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGE5LmZpbGVQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGExMCA9IGRhdGE5LmZpbGVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGExMCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmM4KGRhdGExMCkgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMzkgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uL25wbS9maWxlUGF0aFwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcHJvcGVydGllcy9sb2NhdGlvbi9wcm9wZXJ0aWVzL25wbS9wcm9wZXJ0aWVzL2ZpbGVQYXRoL21pbkxlbmd0aFwiLCBrZXl3b3JkOiBcIm1pbkxlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDEgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGZld2VyIHRoYW4gMSBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjM5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIzOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyNDAgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uL25wbS9maWxlUGF0aFwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcHJvcGVydGllcy9sb2NhdGlvbi9wcm9wZXJ0aWVzL25wbS9wcm9wZXJ0aWVzL2ZpbGVQYXRoL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBzdHJpbmdcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjQwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI0MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTkuaWNvblBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTExID0gZGF0YTkuaWNvblBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YTExID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4zLnRlc3QoZGF0YTExKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjQxID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9sb2NhdGlvbi9ucG0vaWNvblBhdGhcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcHJvcGVydGllcy9ucG0vcHJvcGVydGllcy9pY29uUGF0aC9wYXR0ZXJuXCIsIGtleXdvcmQ6IFwicGF0dGVyblwiLCBwYXJhbXM6IHsgcGF0dGVybjogXCJcXFxcdytcXFxcLnN2ZyRcIiB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggcGF0dGVybiBcXFwiXCIgKyBcIlxcXFx3K1xcXFwuc3ZnJFwiICsgXCJcXFwiXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjQxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI0MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyNDIgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uL25wbS9pY29uUGF0aFwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvcHJvcGVydGllcy9sb2NhdGlvbi9wcm9wZXJ0aWVzL25wbS9wcm9wZXJ0aWVzL2ljb25QYXRoL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBzdHJpbmdcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjQyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTkucGFja2FnZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTEyID0gZGF0YTkucGFja2FnZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YTEyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuYzgoZGF0YTEyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnI0MyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2UvbG9jYXRpb24vbnBtL3BhY2thZ2VOYW1lXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL3Byb3BlcnRpZXMvbnBtL3Byb3BlcnRpZXMvcGFja2FnZU5hbWUvbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMSB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgZmV3ZXIgdGhhbiAxIGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnI0NCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9zb3VyY2UvbG9jYXRpb24vbnBtL3BhY2thZ2VOYW1lXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL3Byb3BlcnRpZXMvbnBtL3Byb3BlcnRpZXMvcGFja2FnZU5hbWUvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjQ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhOS5yZWdpc3RyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhMTMgPSBkYXRhOS5yZWdpc3RyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhMTMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjQ1ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9sb2NhdGlvbi9ucG0vcmVnaXN0cnlcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcHJvcGVydGllcy9ucG0vcHJvcGVydGllcy9yZWdpc3RyeS90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI0NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGRhdGExMyA9PT0gXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZ1wiKSB8fCAoZGF0YTEzID09PSBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL1wiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjQ2ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9sb2NhdGlvbi9ucG0vcmVnaXN0cnlcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcHJvcGVydGllcy9ucG0vcHJvcGVydGllcy9yZWdpc3RyeS9lbnVtXCIsIGtleXdvcmQ6IFwiZW51bVwiLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlczogc2NoZW1hMjIucHJvcGVydGllcy5zb3VyY2UucHJvcGVydGllcy5sb2NhdGlvbi5wcm9wZXJ0aWVzLm5wbS5wcm9wZXJ0aWVzLnJlZ2lzdHJ5LmVudW0gfSwgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjQ2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI0Nik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjQ3ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZS9sb2NhdGlvbi9ucG1cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvc291cmNlL3Byb3BlcnRpZXMvbG9jYXRpb24vcHJvcGVydGllcy9ucG0vdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwib2JqZWN0XCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIG9iamVjdFwiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI0N107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyNDggPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvc291cmNlL2xvY2F0aW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3NvdXJjZS9wcm9wZXJ0aWVzL2xvY2F0aW9uL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcIm9iamVjdFwiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBvYmplY3RcIiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI0OF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycjQ5ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3NvdXJjZVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9zb3VyY2UvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwib2JqZWN0XCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIG9iamVjdFwiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNDldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjQ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmluaXRpYWxQZXJtaXNzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBkYXRhMTQgPSBkYXRhLmluaXRpYWxQZXJtaXNzaW9ucztcbiAgICAgICAgaWYgKCEoZGF0YTE0ICYmIHR5cGVvZiBkYXRhMTQgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhMTQpKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyNTAgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvaW5pdGlhbFBlcm1pc3Npb25zXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL2luaXRpYWxQZXJtaXNzaW9ucy90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJvYmplY3RcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgb2JqZWN0XCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI1MF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEubWFuaWZlc3RWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGExNSA9IGRhdGEubWFuaWZlc3RWZXJzaW9uO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGExNSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZXJyNTEgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvbWFuaWZlc3RWZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL21hbmlmZXN0VmVyc2lvbi90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI1MV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZGF0YTE1ID09PSBcIjAuMVwiKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyNTIgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvbWFuaWZlc3RWZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL21hbmlmZXN0VmVyc2lvbi9lbnVtXCIsIGtleXdvcmQ6IFwiZW51bVwiLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlczogc2NoZW1hMjIucHJvcGVydGllcy5tYW5pZmVzdFZlcnNpb24uZW51bSB9LCBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICB9XG4gICAgfVxufVxuZWxzZSB7XG4gICAgY29uc3QgZXJyNTMgPSB7IGluc3RhbmNlUGF0aCwgc2NoZW1hUGF0aDogXCIjL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcIm9iamVjdFwiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBvYmplY3RcIiB9O1xuICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIHZFcnJvcnMgPSBbZXJyNTNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdkVycm9ycy5wdXNoKGVycjUzKTtcbiAgICB9XG4gICAgZXJyb3JzKys7XG59IHZhbGlkYXRlMjAuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIHZFcnJvcnM7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlU25hcE1hbmlmZXN0LmpzLm1hcCJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFzTWlkZGxld2FyZS5qcy5tYXAifQ==
