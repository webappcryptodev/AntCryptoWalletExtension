LavaPack.loadBundle([
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateNpmSnapPackageJson.js", {"ajv/dist/runtime/equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\equal.js","ajv/dist/runtime/ucs2length":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\ucs2length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\dist\snaps\json-schemas\validateNpmSnapPackageJson.js
      return function (require, module, exports) {
"use strict";
module.exports = validate20;
module.exports.default = validate20;
const schema22 = { "title": "npm Snap package.json", "type": "object", "required": ["version", "name"], "properties": { "version": { "type": "string", "title": "Version", "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" }, "name": { "type": "string", "title": "Package Name", "minLength": 1, "maxLength": 214, "pattern": "^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$" }, "private": { "type": "boolean", "title": "Private" }, "main": { "type": "string", "title": "Main", "minLength": 1 }, "publishConfig": { "type": "object", "title": "Publish Config", "required": ["registry"], "properties": { "access": { "type": "string", "minLength": 1 }, "registry": { "type": "string", "enum": ["https://registry.npmjs.org", "https://registry.npmjs.org/"] } } }, "repository": { "type": "object", "title": "Repository", "additionalProperties": false, "required": ["type", "url"], "properties": { "type": { "type": "string", "minLength": 1 }, "url": { "type": "string", "minLength": 1 } } } } };
const pattern0 = new RegExp("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$", "u");
const pattern1 = new RegExp("^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$", "u");
const func8 = require("ajv/dist/runtime/ucs2length").default;
const func0 = require("ajv/dist/runtime/equal").default;
function validate20(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) { let vErrors = null; let errors = 0; if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.version === undefined) {
        const err0 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "version" }, message: "must have required property '" + "version" + "'" };
        if (vErrors === null) {
            vErrors = [err0];
        }
        else {
            vErrors.push(err0);
        }
        errors++;
    }
    if (data.name === undefined) {
        const err1 = { instancePath, schemaPath: "#/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property '" + "name" + "'" };
        if (vErrors === null) {
            vErrors = [err1];
        }
        else {
            vErrors.push(err1);
        }
        errors++;
    }
    if (data.version !== undefined) {
        let data0 = data.version;
        if (typeof data0 === "string") {
            if (!pattern0.test(data0)) {
                const err2 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/pattern", keyword: "pattern", params: { pattern: "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" }, message: "must match pattern \"" + "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$" + "\"" };
                if (vErrors === null) {
                    vErrors = [err2];
                }
                else {
                    vErrors.push(err2);
                }
                errors++;
            }
        }
        else {
            const err3 = { instancePath: instancePath + "/version", schemaPath: "#/properties/version/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err3];
            }
            else {
                vErrors.push(err3);
            }
            errors++;
        }
    }
    if (data.name !== undefined) {
        let data1 = data.name;
        if (typeof data1 === "string") {
            if (func8(data1) > 214) {
                const err4 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/maxLength", keyword: "maxLength", params: { limit: 214 }, message: "must NOT have more than 214 characters" };
                if (vErrors === null) {
                    vErrors = [err4];
                }
                else {
                    vErrors.push(err4);
                }
                errors++;
            }
            if (func8(data1) < 1) {
                const err5 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                if (vErrors === null) {
                    vErrors = [err5];
                }
                else {
                    vErrors.push(err5);
                }
                errors++;
            }
            if (!pattern1.test(data1)) {
                const err6 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/pattern", keyword: "pattern", params: { pattern: "^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$" }, message: "must match pattern \"" + "^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$" + "\"" };
                if (vErrors === null) {
                    vErrors = [err6];
                }
                else {
                    vErrors.push(err6);
                }
                errors++;
            }
        }
        else {
            const err7 = { instancePath: instancePath + "/name", schemaPath: "#/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err7];
            }
            else {
                vErrors.push(err7);
            }
            errors++;
        }
    }
    if (data.private !== undefined) {
        if (typeof data.private !== "boolean") {
            const err8 = { instancePath: instancePath + "/private", schemaPath: "#/properties/private/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
                vErrors = [err8];
            }
            else {
                vErrors.push(err8);
            }
            errors++;
        }
    }
    if (data.main !== undefined) {
        let data3 = data.main;
        if (typeof data3 === "string") {
            if (func8(data3) < 1) {
                const err9 = { instancePath: instancePath + "/main", schemaPath: "#/properties/main/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                if (vErrors === null) {
                    vErrors = [err9];
                }
                else {
                    vErrors.push(err9);
                }
                errors++;
            }
        }
        else {
            const err10 = { instancePath: instancePath + "/main", schemaPath: "#/properties/main/type", keyword: "type", params: { type: "string" }, message: "must be string" };
            if (vErrors === null) {
                vErrors = [err10];
            }
            else {
                vErrors.push(err10);
            }
            errors++;
        }
    }
    if (data.publishConfig !== undefined) {
        let data4 = data.publishConfig;
        if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
            if (data4.registry === undefined) {
                const err11 = { instancePath: instancePath + "/publishConfig", schemaPath: "#/properties/publishConfig/required", keyword: "required", params: { missingProperty: "registry" }, message: "must have required property '" + "registry" + "'" };
                if (vErrors === null) {
                    vErrors = [err11];
                }
                else {
                    vErrors.push(err11);
                }
                errors++;
            }
            if (data4.access !== undefined) {
                let data5 = data4.access;
                if (typeof data5 === "string") {
                    if (func8(data5) < 1) {
                        const err12 = { instancePath: instancePath + "/publishConfig/access", schemaPath: "#/properties/publishConfig/properties/access/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                        if (vErrors === null) {
                            vErrors = [err12];
                        }
                        else {
                            vErrors.push(err12);
                        }
                        errors++;
                    }
                }
                else {
                    const err13 = { instancePath: instancePath + "/publishConfig/access", schemaPath: "#/properties/publishConfig/properties/access/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err13];
                    }
                    else {
                        vErrors.push(err13);
                    }
                    errors++;
                }
            }
            if (data4.registry !== undefined) {
                let data6 = data4.registry;
                if (typeof data6 !== "string") {
                    const err14 = { instancePath: instancePath + "/publishConfig/registry", schemaPath: "#/properties/publishConfig/properties/registry/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err14];
                    }
                    else {
                        vErrors.push(err14);
                    }
                    errors++;
                }
                if (!((data6 === "https://registry.npmjs.org") || (data6 === "https://registry.npmjs.org/"))) {
                    const err15 = { instancePath: instancePath + "/publishConfig/registry", schemaPath: "#/properties/publishConfig/properties/registry/enum", keyword: "enum", params: { allowedValues: schema22.properties.publishConfig.properties.registry.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                        vErrors = [err15];
                    }
                    else {
                        vErrors.push(err15);
                    }
                    errors++;
                }
            }
        }
        else {
            const err16 = { instancePath: instancePath + "/publishConfig", schemaPath: "#/properties/publishConfig/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
                vErrors = [err16];
            }
            else {
                vErrors.push(err16);
            }
            errors++;
        }
    }
    if (data.repository !== undefined) {
        let data7 = data.repository;
        if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
            if (data7.type === undefined) {
                const err17 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property '" + "type" + "'" };
                if (vErrors === null) {
                    vErrors = [err17];
                }
                else {
                    vErrors.push(err17);
                }
                errors++;
            }
            if (data7.url === undefined) {
                const err18 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/required", keyword: "required", params: { missingProperty: "url" }, message: "must have required property '" + "url" + "'" };
                if (vErrors === null) {
                    vErrors = [err18];
                }
                else {
                    vErrors.push(err18);
                }
                errors++;
            }
            for (const key0 in data7) {
                if (!((key0 === "type") || (key0 === "url"))) {
                    const err19 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: key0 }, message: "must NOT have additional properties" };
                    if (vErrors === null) {
                        vErrors = [err19];
                    }
                    else {
                        vErrors.push(err19);
                    }
                    errors++;
                }
            }
            if (data7.type !== undefined) {
                let data8 = data7.type;
                if (typeof data8 === "string") {
                    if (func8(data8) < 1) {
                        const err20 = { instancePath: instancePath + "/repository/type", schemaPath: "#/properties/repository/properties/type/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                        if (vErrors === null) {
                            vErrors = [err20];
                        }
                        else {
                            vErrors.push(err20);
                        }
                        errors++;
                    }
                }
                else {
                    const err21 = { instancePath: instancePath + "/repository/type", schemaPath: "#/properties/repository/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err21];
                    }
                    else {
                        vErrors.push(err21);
                    }
                    errors++;
                }
            }
            if (data7.url !== undefined) {
                let data9 = data7.url;
                if (typeof data9 === "string") {
                    if (func8(data9) < 1) {
                        const err22 = { instancePath: instancePath + "/repository/url", schemaPath: "#/properties/repository/properties/url/minLength", keyword: "minLength", params: { limit: 1 }, message: "must NOT have fewer than 1 characters" };
                        if (vErrors === null) {
                            vErrors = [err22];
                        }
                        else {
                            vErrors.push(err22);
                        }
                        errors++;
                    }
                }
                else {
                    const err23 = { instancePath: instancePath + "/repository/url", schemaPath: "#/properties/repository/properties/url/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                        vErrors = [err23];
                    }
                    else {
                        vErrors.push(err23);
                    }
                    errors++;
                }
            }
        }
        else {
            const err24 = { instancePath: instancePath + "/repository", schemaPath: "#/properties/repository/type", keyword: "type", params: { type: "object" }, message: "must be object" };
            if (vErrors === null) {
                vErrors = [err24];
            }
            else {
                vErrors.push(err24);
            }
            errors++;
        }
    }
}
else {
    const err25 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
    if (vErrors === null) {
        vErrors = [err25];
    }
    else {
        vErrors.push(err25);
    }
    errors++;
} validate20.errors = vErrors; return vErrors; }
//# sourceMappingURL=validateNpmSnapPackageJson.js.map
      };
    };
  }
}, {package:"@metamask\\snap-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\snaps\\json-schemas\\validateNpmSnapPackageJson.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-deep-equal\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fast-deep-equal\index.js
      return function (require, module, exports) {
'use strict';

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

      };
    };
  }
}, {package:"fast-deep-equal",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-deep-equal\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\lib\\index.js", {"readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-web-to-node-stream\lib\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadableWebToNodeStream = void 0;
const readable_stream_1 = require("readable-stream");
/**
 * Converts a Web-API stream into Node stream.Readable class
 * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams
 * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
 * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams
 */
class ReadableWebToNodeStream extends readable_stream_1.Readable {
    /**
     *
     * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
     */
    constructor(stream) {
        super();
        this.bytesRead = 0;
        this.released = false;
        this.reader = stream.getReader();
    }
    /**
     * Implementation of readable._read(size).
     * When readable._read() is called, if data is available from the resource,
     * the implementation should begin pushing that data into the read queue
     * https://nodejs.org/api/stream.html#stream_readable_read_size_1
     */
    async _read() {
        // Should start pushing data into the queue
        // Read data from the underlying Web-API-readable-stream
        if (this.released) {
            this.push(null); // Signal EOF
            return;
        }
        this.pendingRead = this.reader.read();
        const data = await this.pendingRead;
        // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()
        delete this.pendingRead;
        if (data.done || this.released) {
            this.push(null); // Signal EOF
        }
        else {
            this.bytesRead += data.value.length;
            this.push(data.value); // Push new data to the queue
        }
    }
    /**
     * If there is no unresolved read call to Web-API Readable​Stream immediately returns;
     * otherwise will wait until the read is resolved.
     */
    async waitForReadToComplete() {
        if (this.pendingRead) {
            await this.pendingRead;
        }
    }
    /**
     * Close wrapper
     */
    async close() {
        await this.syncAndRelease();
    }
    async syncAndRelease() {
        this.released = true;
        await this.waitForReadToComplete();
        await this.reader.releaseLock();
    }
}
exports.ReadableWebToNodeStream = ReadableWebToNodeStream;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"readable-web-to-node-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\concat-stream\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var Writable = require('readable-stream').Writable
var inherits = require('inherits')

var U8 = Uint8Array

function ConcatStream(opts, cb) {
  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }
  if (!opts) opts = {}

  var encoding = opts.encoding
  var shouldInferEncoding = false

  if (!encoding) {
    shouldInferEncoding = true
  } else {
    encoding =  String(encoding).toLowerCase()
    if (encoding === 'u8' || encoding === 'uint8') {
      encoding = 'uint8array'
    }
  }

  Writable.call(this, { objectMode: true })

  this.encoding = encoding
  this.shouldInferEncoding = shouldInferEncoding

  if (cb) this.on('finish', function () { cb(this.getBody()) })
  this.body = []
}

module.exports = ConcatStream
inherits(ConcatStream, Writable)

ConcatStream.prototype._write = function(chunk, enc, next) {
  this.body.push(chunk)
  next()
}

ConcatStream.prototype.inferEncoding = function (buff) {
  var firstBuffer = buff === undefined ? this.body[0] : buff;
  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
  if (Array.isArray(firstBuffer)) return 'array'
  if (typeof firstBuffer === 'string') return 'string'
  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
  return 'buffer'
}

ConcatStream.prototype.getBody = function () {
  if (!this.encoding && this.body.length === 0) return []
  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
  if (this.encoding === 'array') return arrayConcat(this.body)
  if (this.encoding === 'string') return stringConcat(this.body)
  if (this.encoding === 'buffer') return bufferConcat(this.body)
  if (this.encoding === 'uint8array') return u8Concat(this.body)
  return this.body
}

function isArrayish (arr) {
  return /Array\]$/.test(Object.prototype.toString.call(arr))
}

function isBufferish (p) {
  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')
}

function stringConcat (parts) {
  var strings = []
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (typeof p === 'string') {
      strings.push(p)
    } else if (Buffer.isBuffer(p)) {
      strings.push(p)
    } else if (isBufferish(p)) {
      strings.push(Buffer.from(p))
    } else {
      strings.push(Buffer.from(String(p)))
    }
  }
  if (Buffer.isBuffer(parts[0])) {
    strings = Buffer.concat(strings)
    strings = strings.toString('utf8')
  } else {
    strings = strings.join('')
  }
  return strings
}

function bufferConcat (parts) {
  var bufs = []
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (Buffer.isBuffer(p)) {
      bufs.push(p)
    } else if (isBufferish(p)) {
      bufs.push(Buffer.from(p))
    } else {
      bufs.push(Buffer.from(String(p)))
    }
  }
  return Buffer.concat(bufs)
}

function arrayConcat (parts) {
  var res = []
  for (var i = 0; i < parts.length; i++) {
    res.push.apply(res, parts[i])
  }
  return res
}

function u8Concat (parts) {
  var len = 0
  for (var i = 0; i < parts.length; i++) {
    if (typeof parts[i] === 'string') {
      parts[i] = Buffer.from(parts[i])
    }
    len += parts[i].length
  }
  var u8 = new U8(len)
  for (var i = 0, offset = 0; i < parts.length; i++) {
    var part = parts[i]
    for (var j = 0; j < part.length; j++) {
      u8[offset++] = part[j]
    }
  }
  return u8
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"concat-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\index.js", {"./extract":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\extract.js","./pack":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\pack.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\tar-stream\index.js
      return function (require, module, exports) {
exports.extract = require('./extract')
exports.pack = require('./pack')

      };
    };
  }
}, {package:"tar-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\index.js", {"is-deflate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-deflate\\index.js","is-gzip":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-gzip\\index.js","peek-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peek-stream\\index.js","pumpify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\pumpify\\index.js","through2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\through2\\through2.js","zlib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\browserify-zlib\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gunzip-maybe\index.js
      return function (require, module, exports) {
var zlib = require('zlib')
var peek = require('peek-stream')
var through = require('through2')
var pumpify = require('pumpify')
var isGzip = require('is-gzip')
var isDeflate = require('is-deflate')

var isCompressed = function (data) {
  if (isGzip(data)) return 1
  if (isDeflate(data)) return 2
  return 0
}

var gunzip = function (maxRecursion) {
  if (maxRecursion === undefined) maxRecursion = 3

  return peek({newline: false, maxBuffer: 10}, function (data, swap) {
    if (maxRecursion < 0) return swap(new Error('Maximum recursion reached'))
    switch (isCompressed(data)) {
      case 1:
        swap(null, pumpify(zlib.createGunzip(), gunzip(maxRecursion - 1)))
        break
      case 2:
        swap(null, pumpify(zlib.createInflate(), gunzip(maxRecursion - 1)))
        break
      default:
        swap(null, through())
    }
  })
}

module.exports = gunzip

      };
    };
  }
}, {package:"gunzip-maybe",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\index.js", {"./ObjectMultiplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\ObjectMultiplex.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\object-multiplex\dist\index.js
      return function (require, module, exports) {
"use strict";
const ObjectMultiplex_1 = require("./ObjectMultiplex");
module.exports = ObjectMultiplex_1.ObjectMultiplex;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\object-multiplex",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\index.js", {"./enums":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-workers\dist\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SNAP_STREAM_NAMES = void 0;
var enums_1 = require("./enums");
Object.defineProperty(exports, "SNAP_STREAM_NAMES", { enumerable: true, get: function () { return enums_1.STREAM_NAMES; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\snap-workers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\index.js", {"./createEngineStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js","./createStreamMiddleware":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\json-rpc-middleware-stream\dist\index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(require("./createEngineStream"));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(require("./createStreamMiddleware"));
exports.createStreamMiddleware = createStreamMiddleware_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\index.js", {"./WindowPostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WindowPostMessageStream.js","./WorkerParentPostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerParentPostMessageStream.js","./WorkerPostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerPostMessageStream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\post-message-stream\dist\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerParentPostMessageStream = exports.WorkerPostMessageStream = exports.WindowPostMessageStream = void 0;
var WindowPostMessageStream_1 = require("./WindowPostMessageStream");
Object.defineProperty(exports, "WindowPostMessageStream", { enumerable: true, get: function () { return WindowPostMessageStream_1.WindowPostMessageStream; } });
var WorkerPostMessageStream_1 = require("./WorkerPostMessageStream");
Object.defineProperty(exports, "WorkerPostMessageStream", { enumerable: true, get: function () { return WorkerPostMessageStream_1.WorkerPostMessageStream; } });
var WorkerParentPostMessageStream_1 = require("./WorkerParentPostMessageStream");
Object.defineProperty(exports, "WorkerParentPostMessageStream", { enumerable: true, get: function () { return WorkerParentPostMessageStream_1.WorkerParentPostMessageStream; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\post-message-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\eth-accounts.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\eth-accounts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

/**
 * A wrapper for `eth_accounts` that returns an empty array when permission is denied.
 */
const requestEthereumAccounts = {
  methodNames: [_app.MESSAGE_TYPE.ETH_ACCOUNTS],
  implementation: ethAccountsHandler,
  hookNames: {
    getAccounts: true
  }
};
var _default = requestEthereumAccounts;
/**
 * @typedef {Record<string, Function>} EthAccountsOptions
 * @property {Function} getAccounts - Gets the accounts for the requesting
 * origin.
 */

/**
 *
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} _req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {EthAccountsOptions} options - The RPC method hooks.
 */

exports.default = _default;

async function ethAccountsHandler(_req, res, _next, end, {
  getAccounts
}) {
  res.result = await getAccounts();
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\eth-accounts.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\watch-asset.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\watch-asset.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

const watchAsset = {
  methodNames: [_app.MESSAGE_TYPE.WATCH_ASSET, _app.MESSAGE_TYPE.WATCH_ASSET_LEGACY],
  implementation: watchAssetHandler,
  hookNames: {
    handleWatchAssetRequest: true
  }
};
var _default = watchAsset;
/**
 * @typedef {Object} WatchAssetOptions
 * @property {Function} handleWatchAssetRequest - The wallet_watchAsset method implementation.
 */

/**
 * @typedef {Object} WatchAssetParam
 * @property {string} type - The type of the asset to watch.
 * @property {Object} options - Watch options for the asset.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<WatchAssetParam>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {WatchAssetOptions} options
 */

exports.default = _default;

async function watchAssetHandler(req, res, _next, end, {
  handleWatchAssetRequest
}) {
  try {
    const {
      options: asset,
      type
    } = req.params;
    res.result = await handleWatchAssetRequest(asset, type);
    return end();
  } catch (error) {
    return end(error);
  }
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\watch-asset.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\log-web3-shim-usage.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\log-web3-shim-usage.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _app = require("../../../../../shared/constants/app");

/**
 * This RPC method is called by the inpage provider whenever it detects the
 * accessing of a non-existent property on our window.web3 shim.
 * We collect this data to understand which sites are breaking due to the
 * removal of our window.web3.
 */
const logWeb3ShimUsage = {
  methodNames: [_app.MESSAGE_TYPE.LOG_WEB3_SHIM_USAGE],
  implementation: logWeb3ShimUsageHandler,
  hookNames: {
    sendMetrics: true,
    getWeb3ShimUsageState: true,
    setWeb3ShimUsageRecorded: true
  }
};
var _default = logWeb3ShimUsage;
/**
 * @typedef {Object} LogWeb3ShimUsageOptions
 * @property {Function} sendMetrics - A function that registers a metrics event.
 * @property {Function} getWeb3ShimUsageState - A function that gets web3 shim
 * usage state for the given origin.
 * @property {Function} setWeb3ShimUsageRecorded - A function that records web3 shim
 * usage for a particular origin.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {LogWeb3ShimUsageOptions} options
 */

exports.default = _default;

function logWeb3ShimUsageHandler(req, res, _next, end, {
  sendMetrics,
  getWeb3ShimUsageState,
  setWeb3ShimUsageRecorded
}) {
  const {
    origin
  } = req;

  if (getWeb3ShimUsageState(origin) === undefined) {
    setWeb3ShimUsageRecorded(origin);
    sendMetrics({
      event: `Website Accessed window.web3 Shim`,
      category: 'inpage_provider',
      referrer: {
        url: origin
      }
    }, {
      excludeMetaMetricsId: true
    });
  }

  res.result = true;
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\log-web3-shim-usage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\request-accounts.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\request-accounts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../../../shared/constants/app");

/**
 * This method attempts to retrieve the Ethereum accounts available to the
 * requester, or initiate a request for account access if none are currently
 * available. It is essentially a wrapper of wallet_requestPermissions that
 * only errors if the user rejects the request. We maintain the method for
 * backwards compatibility reasons.
 */
const requestEthereumAccounts = {
  methodNames: [_app.MESSAGE_TYPE.ETH_REQUEST_ACCOUNTS],
  implementation: requestEthereumAccountsHandler,
  hookNames: {
    origin: true,
    getAccounts: true,
    getUnlockPromise: true,
    hasPermission: true,
    requestAccountsPermission: true
  }
};
var _default = requestEthereumAccounts; // Used to rate-limit pending requests to one per origin

exports.default = _default;
const locks = new Set();
/**
 * @typedef {Record<string, string | Function>} RequestEthereumAccountsOptions
 * @property {string} origin - The requesting origin.
 * @property {Function} getAccounts - Gets the accounts for the requesting
 * origin.
 * @property {Function} getUnlockPromise - Gets a promise that resolves when
 * the extension unlocks.
 * @property {Function} hasPermission - Returns whether the requesting origin
 * has the specified permission.
 * @property {Function} requestAccountsPermission - Requests the `eth_accounts`
 * permission for the requesting origin.
 */

/**
 *
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} _req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {RequestEthereumAccountsOptions} options - The RPC method hooks.
 */

async function requestEthereumAccountsHandler(_req, res, _next, end, {
  origin,
  getAccounts,
  getUnlockPromise,
  hasPermission,
  requestAccountsPermission
}) {
  if (locks.has(origin)) {
    res.error = _ethRpcErrors.ethErrors.rpc.resourceUnavailable(`Already processing ${_app.MESSAGE_TYPE.ETH_REQUEST_ACCOUNTS}. Please wait.`);
    return end();
  }

  if (hasPermission(_app.MESSAGE_TYPE.ETH_ACCOUNTS)) {
    // We wait for the extension to unlock in this case only, because permission
    // requests are handled when the extension is unlocked, regardless of the
    // lock state when they were received.
    try {
      locks.add(origin);
      await getUnlockPromise(true);
      res.result = await getAccounts();
      end();
    } catch (error) {
      end(error);
    } finally {
      locks.delete(origin);
    }

    return undefined;
  } // If no accounts, request the accounts permission


  try {
    await requestAccountsPermission();
  } catch (err) {
    res.error = err;
    return end();
  } // Get the approved accounts


  const accounts = await getAccounts();
  /* istanbul ignore else: too hard to induce, see below comment */

  if (accounts.length > 0) {
    res.result = accounts;
  } else {
    // This should never happen, because it should be caught in the
    // above catch clause
    res.error = _ethRpcErrors.ethErrors.rpc.internal('Accounts unexpectedly unavailable. Please report this bug.');
  }

  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\request-accounts.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\switch-ethereum-chain.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../../shared/modules/network.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\switch-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/constants/network");

var _network2 = require("../../../../../shared/modules/network.utils");

const switchEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN],
  implementation: switchEthereumChainHandler,
  hookNames: {
    getCurrentChainId: true,
    findCustomRpcBy: true,
    setProviderType: true,
    updateRpcTarget: true,
    requestUserApproval: true
  }
};
var _default = switchEthereumChain;
exports.default = _default;

function findExistingNetwork(chainId, findCustomRpcBy) {
  if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
    return {
      chainId,
      ticker: _network.ETH_SYMBOL,
      nickname: _network.NETWORK_TO_NAME_MAP[chainId],
      rpcUrl: _network.CHAIN_ID_TO_RPC_URL_MAP[chainId],
      type: _network.CHAIN_ID_TO_TYPE_MAP[chainId]
    };
  }

  return findCustomRpcBy({
    chainId
  });
}

async function switchEthereumChainHandler(req, res, _next, end, {
  getCurrentChainId,
  findCustomRpcBy,
  setProviderType,
  updateRpcTarget,
  requestUserApproval
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network2.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network2.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  const requestData = findExistingNetwork(_chainId, findCustomRpcBy);

  if (requestData) {
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      res.result = null;
      return end();
    }

    try {
      const approvedRequestData = await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData
      });

      if (chainId in _network.CHAIN_ID_TO_TYPE_MAP) {
        setProviderType(approvedRequestData.type);
      } else {
        await updateRpcTarget(approvedRequestData);
      }

      res.result = null;
    } catch (error) {
      return end(error);
    }

    return end();
  }

  return end(_ethRpcErrors.ethErrors.provider.custom({
    code: 4902,
    // To-be-standardized "unrecognized chain ID" error
    message: `Unrecognized chain ID "${chainId}". Try adding the chain using ${_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN} first.`
  }));
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\switch-ethereum-chain.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\add-ethereum-chain.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../../shared/modules/network.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js","../../../../../shared/modules/rpc.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\rpc.utils.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","lodash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\lodash.js","valid-url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\valid-url\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\add-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _validUrl = _interopRequireDefault(require("valid-url"));

var _lodash = require("lodash");

var _app = require("../../../../../shared/constants/app");

var _network = require("../../../../../shared/modules/network.utils");

var _rpc = require("../../../../../shared/modules/rpc.utils");

var _network2 = require("../../../../../shared/constants/network");

const addEthereumChain = {
  methodNames: [_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN],
  implementation: addEthereumChainHandler,
  hookNames: {
    addCustomRpc: true,
    getCurrentChainId: true,
    findCustomRpcBy: true,
    updateRpcTarget: true,
    requestUserApproval: true,
    sendMetrics: true
  }
};
var _default = addEthereumChain;
exports.default = _default;

async function addEthereumChainHandler(req, res, _next, end, {
  addCustomRpc,
  getCurrentChainId,
  findCustomRpcBy,
  updateRpcTarget,
  requestUserApproval,
  sendMetrics
}) {
  var _req$params;

  if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params[0]) || typeof req.params[0] !== 'object') {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected single, object parameter. Received:\n${JSON.stringify(req.params)}`
    }));
  }

  const {
    origin
  } = req;
  const {
    chainId,
    chainName = null,
    blockExplorerUrls = null,
    nativeCurrency = null,
    rpcUrls
  } = req.params[0];
  const otherKeys = Object.keys((0, _lodash.omit)(req.params[0], ['chainId', 'chainName', 'blockExplorerUrls', 'iconUrls', 'rpcUrls', 'nativeCurrency']));

  if (otherKeys.length > 0) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Received unexpected keys on object parameter. Unsupported keys:\n${otherKeys}`
    }));
  }

  const firstValidRPCUrl = Array.isArray(rpcUrls) ? rpcUrls.find(rpcUrl => _validUrl.default.isHttpsUri(rpcUrl)) : null;
  const firstValidBlockExplorerUrl = blockExplorerUrls !== null && Array.isArray(blockExplorerUrls) ? blockExplorerUrls.find(blockExplorerUrl => _validUrl.default.isHttpsUri(blockExplorerUrl)) : null;

  if (!firstValidRPCUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected an array with at least one valid string HTTPS url 'rpcUrls', Received:\n${rpcUrls}`
    }));
  }

  if (blockExplorerUrls !== null && !firstValidBlockExplorerUrl) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected null or array with at least one valid string HTTPS URL 'blockExplorerUrl'. Received: ${blockExplorerUrls}`
    }));
  }

  const _chainId = typeof chainId === 'string' && chainId.toLowerCase();

  if (!(0, _network.isPrefixedFormattedHexString)(_chainId)) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}`
    }));
  }

  if (!(0, _network.isSafeChainId)(parseInt(_chainId, 16))) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}`
    }));
  }

  if (_network2.CHAIN_ID_TO_NETWORK_ID_MAP[_chainId]) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `May not specify default MetaMask chain.`
    }));
  }

  const existingNetwork = findCustomRpcBy({
    chainId: _chainId
  });

  if (existingNetwork) {
    // If the network already exists, the request is considered successful
    res.result = null;
    const currentChainId = getCurrentChainId();

    if (currentChainId === _chainId) {
      return end();
    } // Ask the user to switch the network


    try {
      await updateRpcTarget(await requestUserApproval({
        origin,
        type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
        requestData: {
          rpcUrl: existingNetwork.rpcUrl,
          chainId: existingNetwork.chainId,
          nickname: existingNetwork.nickname,
          ticker: existingNetwork.ticker
        }
      }));
      res.result = null;
    } catch (error) {
      // For the purposes of this method, it does not matter if the user
      // declines to switch the selected network. However, other errors indicate
      // that something is wrong.
      if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
        return end(error);
      }
    }

    return end();
  }

  let endpointChainId;

  try {
    endpointChainId = await (0, _rpc.jsonRpcRequest)(firstValidRPCUrl, 'eth_chainId');
  } catch (err) {
    return end(_ethRpcErrors.ethErrors.rpc.internal({
      message: `Request for method 'eth_chainId on ${firstValidRPCUrl} failed`,
      data: {
        networkErr: err
      }
    }));
  }

  if (_chainId !== endpointChainId) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Chain ID returned by RPC URL ${firstValidRPCUrl} does not match ${_chainId}`,
      data: {
        chainId: endpointChainId
      }
    }));
  }

  if (typeof chainName !== 'string' || !chainName) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected non-empty string 'chainName'. Received:\n${chainName}`
    }));
  }

  const _chainName = chainName.length > 100 ? chainName.substring(0, 100) : chainName;

  if (nativeCurrency !== null) {
    if (typeof nativeCurrency !== 'object' || Array.isArray(nativeCurrency)) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected null or object 'nativeCurrency'. Received:\n${nativeCurrency}`
      }));
    }

    if (nativeCurrency.decimals !== 18) {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected the number 18 for 'nativeCurrency.decimals' when 'nativeCurrency' is provided. Received: ${nativeCurrency.decimals}`
      }));
    }

    if (!nativeCurrency.symbol || typeof nativeCurrency.symbol !== 'string') {
      return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
        message: `Expected a string 'nativeCurrency.symbol'. Received: ${nativeCurrency.symbol}`
      }));
    }
  }

  const ticker = (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || 'ETH';

  if (typeof ticker !== 'string' || ticker.length < 2 || ticker.length > 6) {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      message: `Expected 2-6 character string 'nativeCurrency.symbol'. Received:\n${ticker}`
    }));
  }

  try {
    await addCustomRpc(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN,
      requestData: {
        chainId: _chainId,
        blockExplorerUrl: firstValidBlockExplorerUrl,
        chainName: _chainName,
        rpcUrl: firstValidRPCUrl,
        ticker
      }
    }));
    sendMetrics({
      event: 'Custom Network Added',
      category: 'Network',
      referrer: {
        url: origin
      },
      sensitiveProperties: {
        chain_id: _chainId,
        rpc_url: firstValidRPCUrl,
        network_name: _chainName,
        // Including network to override the default network
        // property included in all events. For RPC type networks
        // the MetaMetrics controller uses the rpcUrl for the network
        // property.
        network: firstValidRPCUrl,
        symbol: ticker,
        block_explorer_url: firstValidBlockExplorerUrl,
        source: 'dapp'
      }
    }); // Once the network has been added, the requested is considered successful

    res.result = null;
  } catch (error) {
    return end(error);
  } // Ask the user to switch the network


  try {
    await updateRpcTarget(await requestUserApproval({
      origin,
      type: _app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN,
      requestData: {
        rpcUrl: firstValidRPCUrl,
        chainId: _chainId,
        nickname: _chainName,
        ticker
      }
    }));
  } catch (error) {
    // For the purposes of this method, it does not matter if the user
    // declines to switch the selected network. However, other errors indicate
    // that something is wrong.
    if (error.code !== _ethRpcErrors.errorCodes.provider.userRejectedRequest) {
      return end(error);
    }
  }

  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\add-ethereum-chain.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\get-provider-state.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\get-provider-state.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _app = require("../../../../../shared/constants/app");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This RPC method gets background state relevant to the provider.
 * The background sends RPC notifications on state changes, but the provider
 * first requests state on initialization.
 */
const getProviderState = {
  methodNames: [_app.MESSAGE_TYPE.GET_PROVIDER_STATE],
  implementation: getProviderStateHandler,
  hookNames: {
    getProviderState: true
  }
};
var _default = getProviderState;
/**
 * @typedef {Object} ProviderStateHandlerResult
 * @property {string} chainId - The current chain ID.
 * @property {boolean} isUnlocked - Whether the extension is unlocked or not.
 * @property {string} networkVersion - The current network ID.
 */

/**
 * @typedef {Object} ProviderStateHandlerOptions
 * @property {() => ProviderStateHandlerResult} getProviderState - A function that
 * gets the current provider state.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<[]>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<ProviderStateHandlerResult>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {ProviderStateHandlerOptions} options
 */

exports.default = _default;

async function getProviderStateHandler(req, res, _next, end, {
  getProviderState: _getProviderState
}) {
  res.result = _objectSpread({}, await _getProviderState(req.origin));
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\get-provider-state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\send-metadata.js", {"../../../../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/helpers/objectWithoutProperties":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\objectWithoutProperties.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\lib\rpc-method-middleware\handlers\send-metadata.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../../../../shared/constants/app");

const _excluded = ["icon", "name"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This internal method is used by our external provider to send metadata about
 * permission subjects so that we can e.g. display a proper name and icon in
 * our UI.
 */
const sendMetadata = {
  methodNames: [_app.MESSAGE_TYPE.SEND_METADATA],
  implementation: sendMetadataHandler,
  hookNames: {
    addSubjectMetadata: true,
    subjectType: true
  }
};
var _default = sendMetadata;
/**
 * @typedef {Record<string, Function>} SendMetadataOptions
 * @property {Function} addSubjectMetadata - A function that records subject
 * metadata, bound to the requesting origin.
 * @property {string} subjectType - The type of the requesting origin / subject.
 */

/**
 * @param {__import__('json-rpc-engine').JsonRpcRequest<unknown>} req - The JSON-RPC request object.
 * @param {__import__('json-rpc-engine').JsonRpcResponse<true>} res - The JSON-RPC response object.
 * @param {Function} _next - The json-rpc-engine 'next' callback.
 * @param {Function} end - The json-rpc-engine 'end' callback.
 * @param {SendMetadataOptions} options
 */

exports.default = _default;

function sendMetadataHandler(req, res, _next, end, {
  addSubjectMetadata,
  subjectType
}) {
  const {
    origin,
    params
  } = req;

  if (params && typeof params === 'object' && !Array.isArray(params)) {
    const {
      icon = null,
      name = null
    } = params,
          remainingParams = (0, _objectWithoutProperties2.default)(params, _excluded);
    addSubjectMetadata(_objectSpread(_objectSpread({}, remainingParams), {}, {
      iconUrl: icon,
      name,
      subjectType,
      origin
    }));
  } else {
    return end(_ethRpcErrors.ethErrors.rpc.invalidParams({
      data: params
    }));
  }

  res.result = true;
  return end();
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\rpc-method-middleware\\handlers\\send-metadata.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectHooks = exports.isPlainObject = void 0;
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
/**
 * Returns the subset of the specified `hooks` that are included in the
 * `hookNames` object. This is a Principle of Least Authority (POLA) measure
 * to ensure that each RPC method implementation only has access to the
 * API "hooks" it needs to do its job.
 *
 * @param hooks - The hooks to select from.
 * @param hookNames - The names of the hooks to select.
 * @returns The selected hooks.
 * @template Hooks - The hooks to select from.
 * @template HookName - The names of the hooks to select.
 */
function selectHooks(hooks, hookNames) {
    if (hookNames) {
        return Object.keys(hookNames).reduce((hookSubset, _hookName) => {
            const hookName = _hookName;
            hookSubset[hookName] = hooks[hookName];
            return hookSubset;
        }, {});
    }
    return undefined;
}
exports.selectHooks = selectHooks;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\index.js", {"./enable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\enable.js","./getAppKey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getAppKey.js","./getSnaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getSnaps.js","./installSnaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\installSnaps.js","./invokeSnapSugar":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\invokeSnapSugar.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const enable_1 = require("./enable");
const getAppKey_1 = require("./getAppKey");
const getSnaps_1 = require("./getSnaps");
const installSnaps_1 = require("./installSnaps");
const invokeSnapSugar_1 = require("./invokeSnapSugar");
exports.handlers = [
    enable_1.enableWalletHandler,
    getAppKey_1.getAppKeyHandler,
    getSnaps_1.getSnapsHandler,
    installSnaps_1.installSnapsHandler,
    invokeSnapSugar_1.invokeSnapSugarHandler,
];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\index.js", {"./confirm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\confirm.js","./getBip44Entropy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\getBip44Entropy.js","./invokeSnap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\invokeSnap.js","./manageState":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\manageState.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\restricted\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builders = exports.ManageStateOperation = void 0;
const confirm_1 = require("./confirm");
const getBip44Entropy_1 = require("./getBip44Entropy");
const invokeSnap_1 = require("./invokeSnap");
const manageState_1 = require("./manageState");
var manageState_2 = require("./manageState");
Object.defineProperty(exports, "ManageStateOperation", { enumerable: true, get: function () { return manageState_2.ManageStateOperation; } });
exports.builders = {
    [confirm_1.confirmBuilder.targetKey]: confirm_1.confirmBuilder,
    [getBip44Entropy_1.getBip44EntropyBuilder.targetKey]: getBip44Entropy_1.getBip44EntropyBuilder,
    [invokeSnap_1.invokeSnapBuilder.targetKey]: invokeSnap_1.invokeSnapBuilder,
    [manageState_1.manageStateBuilder.targetKey]: manageState_1.manageStateBuilder,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js", {"@keystonehq/bc-ur-registry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@keystonehq\bc-ur-registry-eth\dist\bc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');

const {
  RegistryType
} = bcUrRegistry.extend;
const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType('eth-sign-request', 401),
  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType('eth-signature', 402)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.setupData = args => {
      this.requestId = args.requestId;
      this.signData = args.signData;
      this.dataType = args.dataType;
      this.chainId = args.chainId;
      this.derivationPath = args.derivationPath;
      this.address = args.address;
      this.origin = args.origin;
    };

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.setupData(args);
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, '').split('/');
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ''));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, 'hex'));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressfromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = '0x' + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString('hex');
  return ethereumjsUtil.toChecksumAddress(address);
};
const findHDpatfromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;
    const caculateAddress = generateAddressfromXpub(xpub, path);

    if (address.toLowerCase() == caculateAddress.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

const {
  cbor
} = bcUrRegistry.extend;
cbor.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return bcUrRegistry[k];
        }
    });
});
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDpatfromAddress = findHDpatfromAddress;
exports.generateAddressfromXpub = generateAddressfromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\bc-ur-registry-eth",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js", {"@keystonehq/bc-ur-registry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\bc-ur-registry\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@keystonehq\bc-ur-registry-eth\dist\bc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),s=require("uuid"),a=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("ethereumjs-util");const{RegistryType:r}=e.extend,n={ETH_SIGN_REQUEST:new r("eth-sign-request",401),ETH_SIGNATAURE:new r("eth-signature",402)},{decodeToDataItem:d,RegistryTypes:o}=e.extend;var h,u;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(h||(h={})),(u=exports.DataType||(exports.DataType={}))[u.transaction=1]="transaction",u[u.typedData=2]="typedData",u[u.personalMessage=3]="personalMessage",u[u.typedTransaction=4]="typedTransaction";class g extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>n.ETH_SIGN_REQUEST,this.setupData=t=>{this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin},this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[h.requestId]=new e.DataItem(this.requestId,o.UUID.getTag())),this.address&&(t[h.address]=this.address),this.chainId&&(t[h.chainId]=this.chainId),this.origin&&(t[h.origin]=this.origin),t[h.signData]=this.signData,t[h.dataType]=this.dataType;const s=this.derivationPath.toDataItem();return s.setTag(this.derivationPath.getRegistryType().getTag()),t[h.derivationPath]=s,new e.DataItem(t)},this.setupData(t)}static constructETHRequest(t,a,i,r,n,d,o,h){const u=i.replace(/[m|M]\//,"").split("/"),c=new e.CryptoKeypath(u.map(t=>{const s=parseInt(t.replace("'",""));let a=!1;return t.endsWith("'")&&(a=!0),new e.PathComponent({index:s,hardened:a})}),Buffer.from(r,"hex"));return new g({requestId:n?Buffer.from(s.parse(n)):void 0,signData:t,dataType:a,derivationPath:c,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}g.fromDataItem=t=>{const s=t.getData(),a=s[h.signData],i=s[h.dataType],r=e.CryptoKeypath.fromDataItem(s[h.derivationPath]),n=s[h.chainId]?s[h.chainId]:void 0,d=s[h.address]?s[h.address]:void 0,o=s[h.requestId]?s[h.requestId].getData():void 0;return new g({requestId:o,signData:a,dataType:i,chainId:n,derivationPath:r,address:d,origin:s[h.origin]?s[h.origin]:void 0})},g.fromCBOR=t=>{const e=d(t);return g.fromDataItem(e)};const{RegistryTypes:c,decodeToDataItem:I}=e.extend;var p;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature"}(p||(p={}));class y extends e.RegistryItem{constructor(t,s){super(),this.getRegistryType=()=>n.ETH_SIGNATAURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.toDataItem=()=>{const t={};return this.requestId&&(t[p.requestId]=new e.DataItem(this.requestId,c.UUID.getTag())),t[p.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=s}}y.fromDataItem=t=>{const e=t.getData(),s=e[p.signature],a=e[p.requestId]?e[p.requestId].getData():void 0;return new y(s,a)},y.fromCBOR=t=>{const e=I(t);return y.fromDataItem(e)};const T=(t,e)=>{const s=a.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(s.publicKey,!0).toString("hex");return i.toChecksumAddress(r)},{cbor:D}=e.extend;D.patchTags(Object.values(n).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHSignature=y,exports.EthSignRequest=g,exports.findHDpatfromAddress=(t,e,s,a)=>{for(let i=0;i<s;i++){const s=T(e,"M/0/"+i);if(t.toLowerCase()==s.toLowerCase())return`${a}/0/${i}`}return null},exports.generateAddressfromXpub=T;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\bc-ur-registry-eth",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\base-eth-keyring\dist\base-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = 'QR Hardware Wallet Device';
const pathBase = 'm';
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = '0/*';
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error('KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.');
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error('KeystoneError#invalid_data: read signature error: mismatched requestId');
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString('hex');
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint');
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== '') {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString('hex');

      if (!xfp) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint');
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-account, no crypto output found');
      }

      if (outputs.length % 5 !== 0) {
        throw new Error('KeystoneError#invalid_data: only support 5x pubkey accounts for now');
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = '0x' + ethereumjsUtil.publicToAddress(key, true).toString('hex');
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[ethereumjsUtil.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[ethereumjsUtil.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      return new Promise(async (resolve, reject) => {
        try {
          const from = (this.page - 1) * this.perPage;
          const to = from + this.perPage;
          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = await this.__addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i
            });
            this.indexes[ethereumjsUtil.toChecksumAddress(address)] = i;
          }

          resolve(accounts);
        } catch (e) {
          reject(e);
        }
      });
    };

    this.__getLedgerLivePage = increment => {
      const nextPage = this.page + increment;
      return new Promise(async (resolve, reject) => {
        try {
          const from = (nextPage - 1) * this.perPage;
          const to = from + this.perPage;
          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = await this.__addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i
            });
          }

          this.page += increment;
          resolve(accounts);
        } catch (e) {
          reject(e);
        }
      });
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace('*', String(i)).replaceAll('*', '0');
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = '0x' + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString('hex');
        return ethereumjsUtil.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return ethereumjsUtil.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = 'QR Hardware';
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = '';
    this.xpub = '';
    this.hdPath = '';
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();

    if (result.getRegistryType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(result);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(result);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error('KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly');
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  addAccounts(n = 1) {
    return new Promise(async (resolve, reject) => {
      try {
        const from = this.unlockedAccount;
        const to = from + n;
        const newAccounts = [];

        for (let i = from; i < to; i++) {
          const address = await this.__addressFromIndex(pathBase, i);
          newAccounts.push(address);
          this.page = 0;
          this.unlockedAccount++;
        }

        this.accounts = this.accounts.concat(newAccounts);
        resolve(this.accounts);
      } catch (e) {
        reject(e);
      }
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  } // tx is an instance of the ethereumjs-transaction class.


  static serializeTx(tx) {
    // need use EIP-155
    // @ts-ignore
    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore

    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore

    tx.s = new ethereumjsUtil.BN(0);
    return tx.serialize();
  }

  async signTransaction(address, tx$1) {
    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    return tx.Transaction.fromTxData({
      to: txJson['to'],
      gasLimit: txJson['gasLimit'],
      gasPrice: txJson['gasPrice'],
      data: txJson['data'],
      nonce: txJson['nonce'],
      value: txJson['value'],
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, 'hex'), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), 'utf-8'), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === 'undefined') {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === 'undefined') {
        throw new Error('Unknown address');
      }

      return `${this.hdPath}/${this.childrenPath.replace('*', index.toString()).replaceAll('*', '0')}`;
    } else {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === 'undefined') {
        throw new Error('Unknown address');
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\base-eth-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/bc-ur-registry-eth":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","hdkey":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hdkey\\lib\\hdkey.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\base-eth-keyring\dist\base-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t,r,i=(e=require("hdkey"))&&"object"==typeof e&&"default"in e?e.default:e,s=require("ethereumjs-util"),n=require("@ethereumjs/tx"),a=require("@keystonehq/bc-ur-registry-eth"),o=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class h{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&o.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=e=>(this.page+=e,this.page<=0&&(this.page=1),new Promise(async(e,t)=>{try{const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}e(i)}catch(e){t(e)}})),this.__getLedgerLivePage=e=>{const t=this.page+e;return new Promise(async(r,i)=>{try{const i=(t-1)*this.perPage,s=i+this.perPage,n=[];for(let e=i;e<s;e++){const t=await this.__addressFromIndex("m",e);n.push({address:t,balance:null,index:e})}this.page+=e,r(n)}catch(e){i(e)}})},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replaceAll("*","0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();e.getRegistryType()===a.extend.RegistryTypes.CRYPTO_HDKEY?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}addAccounts(e=1){return new Promise(async(t,r)=>{try{const r=this.unlockedAccount,i=r+e,s=[];for(let e=r;e<i;e++){const t=await this.__addressFromIndex("m",e);s.push(t),this.page=0,this.unlockedAccount++}this.accounts=this.accounts.concat(s),t(this.accounts)}catch(e){r(e)}})}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}static serializeTx(e){return e.v=new s.BN(e.common.chainId()),e.r=new s.BN(0),e.s=new s.BN(0),e.serialize()}async signTransaction(e,t){const r=await this._pathFromAddress(e),i=t.common.chainId(),s=o.v4(),c=a.EthSignRequest.constructETHRequest(h.serializeTx(t),a.DataType.transaction,r,this.xfp,s,i),{r:d,s:u,v:g}=await this.requestSignature(s,c,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),l=t.toJSON();return n.Transaction.fromTxData({to:l.to,gasLimit:l.gasLimit,gasPrice:l.gasPrice,data:l.data,nonce:l.nonce,value:l.value,r:d,s:u,v:g},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=o.v4(),h=a.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),a.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,h,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=o.v4(),s=a.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),a.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:h,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,h,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replaceAll("*","0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}h.type="QR Hardware Wallet Device",exports.BaseKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq\\base-eth-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\util.js", {"../../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\controllers\network\util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTxMetaForRpcResult = formatTxMetaForRpcResult;
exports.getNetworkDisplayName = void 0;

var _network = require("../../../../shared/constants/network");

var _transaction = require("../../../../shared/constants/transaction");

const getNetworkDisplayName = key => _network.NETWORK_TO_NAME_MAP[key];

exports.getNetworkDisplayName = getNetworkDisplayName;

function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    hash,
    txReceipt,
    txParams
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    accessList,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = txParams;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash,
    nonce,
    input: data || '0x',
    value: value || '0x0',
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null
  };

  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.gasPrice = maxFeePerGas;
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }

  return formattedTxMeta;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\controllers\\network\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\keyValueStore.js", {"./config":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js","./utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\keyValueStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;

var KeyValueStore =
/*#__PURE__*/
function () {
  /**
   * Please use **box.public** or **box.private** to get the instance of this class
   */
  function KeyValueStore(orbitdb, name, ensureConnected, threeId) {
    (0, _classCallCheck2["default"])(this, KeyValueStore);
    this._orbitdb = orbitdb;
    this._name = name;

    if (this._name.startsWith('3box.space.')) {
      this._space = this._name.split('.')[2];
    }

    this._ensureConnected = ensureConnected;
    this._3id = threeId;
  }
  /**
   * Get the value and optionally metadata of the given key
   *
   * @param     {String}    key                             the key
   * @param     {Object}    opts                            optional parameters
   * @param     {Boolean}   opts.metadata                   return both value and metadata
   * @return    {String|{value: String, timestamp: Number}} the value associated with the key, undefined if there's no such key
   */


  (0, _createClass2["default"])(KeyValueStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            x,
            metadata,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this._get(key);

              case 3:
                x = _context.sent;

                if (x) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", x);

              case 6:
                if (!opts.metadata) {
                  _context.next = 9;
                  break;
                }

                metadata = this._extractMetadata(x);
                return _context.abrupt("return", _objectSpread({}, metadata, {
                  value: x.value
                }));

              case 9:
                return _context.abrupt("return", x.value);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Get metadata for for a given key
     *
     * @param     {String}    key                     the key
     * @return    {Metadata}                          Metadata for the key, undefined if there's no such key
     */

  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        var x;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._get(key);

              case 2:
                x = _context2.sent;

                if (x) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", x);

              case 5:
                return _context2.abrupt("return", this._extractMetadata(x));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * Set a value for the given key
     *
     * @param     {String}    key                     the key
     * @param     {String}    value                   the value
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        var timeStamp;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                timeStamp = new Date().getTime();
                _context3.next = 6;
                return this._db.put(key, {
                  value: value,
                  timeStamp: timeStamp
                });

              case 6:
                return _context3.abrupt("return", true);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
    /**
    * Set multiple values for multiple keys
    *
    * @param     {Array<String>}    keys                     the keys
    * @param     {Array<String>}    values                   the values
    * @return    {Boolean}                                  true if successful, throw error if not
    */

  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(keys, values) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);

                this._requireLoad();

                this._ensureConnected();

                _context5.prev = 3;
                _context5.next = 6;
                return keys.reduce(
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4(previousPromise, nextKey, index) {
                    var timeStamp;
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return previousPromise;

                          case 2:
                            throwIfUndefined(nextKey, 'key');
                            timeStamp = new Date().getTime();
                            return _context4.abrupt("return", _this._db.put(nextKey, {
                              value: values[index],
                              timeStamp: timeStamp
                            }));

                          case 5:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x7, _x8, _x9) {
                    return _ref.apply(this, arguments);
                  };
                }(), Promise.resolve());

              case 6:
                return _context5.abrupt("return", true);

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](3);
                throw new Error(_context5.t0);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 9]]);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
    /**
     * Remove the value for the given key
     *
     * @param     {String}    key                     the key
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(key) {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                _context6.next = 5;
                return this._db.del(key);

              case 5:
                return _context6.abrupt("return", true);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function remove(_x10) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Extract metadata from store object
     * @private
     * @param x {Object} data from store
     * @return {Metadata} store metadata
     */

  }, {
    key: "_extractMetadata",
    value: function _extractMetadata(x) {
      // ms -> seconds, see issue #396 for details
      var timestamp = Math.floor(x.timeStamp / 1000);
      return {
        timestamp: timestamp
      };
    }
    /**
     * Get the raw value of the given key
     * @private
     *
     * @param     {String}    key                     the key
     * @return    {String}                            the value associated with the key
     */

  }, {
    key: "_get",
    value: function () {
      var _get3 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(key) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.get(key));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _get(_x11) {
        return _get3.apply(this, arguments);
      }

      return _get;
    }()
  }, {
    key: "_sync",
    value: function () {
      var _sync2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(numRemoteEntries) {
        var _this2 = this;

        var numEntriesDefined;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._requireLoad(); // let toid = null


                numEntriesDefined = !(numRemoteEntries === null || numRemoteEntries === undefined);

                if (!(numEntriesDefined && numRemoteEntries <= this._db._oplog.values.length)) {
                  _context8.next = 4;
                  break;
                }

                return _context8.abrupt("return", Promise.resolve());

              case 4:
                _context8.next = 6;
                return new Promise(function (resolve, reject) {
                  if (!numRemoteEntries) {
                    setTimeout(function () {
                      _this2._db.events.removeAllListeners('replicated');

                      _this2._db.events.removeAllListeners('replicate.progress');

                      resolve();
                    }, 3000);
                  }

                  _this2._db.events.on('replicated', function () {
                    if (numRemoteEntries <= _this2._db._oplog.values.length) resolve();
                  });
                  /*
                  this._db.events.on('replicate.progress', (_x, _y, _z, num, max) => {
                    if (toid) {
                      clearTimeout(toid)
                      toid = null
                    }
                    const total = numRemoteEntries || max
                    if (num >= total) {
                      this._db.events.on('replicated', resolve)
                      listenerAdded = true
                    }
                  })
                  */

                });

              case 6:
                return _context8.abrupt("return", this._db.address.toString());

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _sync(_x12) {
        return _sync2.apply(this, arguments);
      }

      return _sync;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(odbAddress) {
        var key, opts;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                key = this._3id.getKeyringBySpaceName(this._name).getPublicKeys(true).signingKey;
                opts = _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                });

                if (!this._space) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 5;
                return this._3id.getOdbId(this._space);

              case 5:
                opts.identity = _context9.sent;

              case 6:
                _context9.next = 8;
                return this._orbitdb.keyvalue(odbAddress || this._name, opts);

              case 8:
                this._db = _context9.sent;
                _context9.next = 11;
                return this._db.load();

              case 11:
                return _context9.abrupt("return", this._db.address.toString());

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _load(_x13) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._requireLoad();

                _context10.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Get all values and optionally metadata
     *
     * @param     {Object}    opts                                    optional parameters
     * @param     {Boolean}   opts.metadata                           return both values and metadata
     * @return    {Array<String|{value: String, timestamp: Number}>}  the values
     */

  }, {
    key: "all",
    value: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var _this3 = this;

        var opts,
            entries,
            allSimple,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                opts = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};

                this._requireLoad();

                entries = this._db.all;
                allSimple = {};
                Object.keys(entries).map(function (key) {
                  var entry = entries[key];

                  if (opts.metadata) {
                    allSimple[key] = _objectSpread({}, _this3._extractMetadata(entry), {
                      value: entry.value
                    });
                  } else {
                    allSimple[key] = entry.value;
                  }
                });
                return _context11.abrupt("return", allSimple);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function all() {
        return _all.apply(this, arguments);
      }

      return all;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: 'Name', value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "log",
    get: function get() {
      return this._db._oplog.values.map(function (obj) {
        return {
          op: obj.payload.op,
          key: obj.payload.key,
          value: obj.payload.value ? obj.payload.value.value : null,
          timeStamp: obj.payload.value ? obj.payload.value.timeStamp : null
        };
      });
    }
  }]);
  return KeyValueStore;
}();

module.exports = KeyValueStore;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\keyValueStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\get.js", {"./superPropBase.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\superPropBase.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@babel\runtime\helpers\get.js
      return function (require, module, exports) {
var superPropBase = require("./superPropBase.js");

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get.apply(this, arguments);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel\\runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\get.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\store-engine.js", {"./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\src\store-engine.js
      return function (require, module, exports) {
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\store-engine.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\json2.js", {"./lib/json2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\lib\\json2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\plugins\json2.js
      return function (require, module, exports) {
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\json2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\all.js", {"./cookieStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\cookieStorage.js","./localStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\localStorage.js","./memoryStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\memoryStorage.js","./oldFF-globalStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldFF-globalStorage.js","./oldIE-userDataStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldIE-userDataStorage.js","./sessionStorage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\sessionStorage.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\all.js
      return function (require, module, exports) {
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\all.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\verifier.js", {"./index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js","https-did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\https-did-resolver\\lib\\register.js","muport-did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\muport-did-resolver\\lib\\register.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\utils\verifier.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('./index'),
    fetchText = _require.fetchText,
    getMessageConsent = _require.getMessageConsent;

var didJWT = require('did-jwt');

var ethers = require('ethers');

require('https-did-resolver')["default"]();

require('muport-did-resolver')();

module.exports = {
  /**
   * Verifies that the gist contains the given muportDID and returns the users github username.
   * Throws an error otherwise.
   *
   * @param     {String}            did                     The muport DID of the user
   * @param     {Object}            gistUrl                 URL of the proof
   * @return    {Object}                                    Object containing username, and proof
   */
  verifyGithub: function () {
    var _verifyGithub = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, gistUrl) {
      var gistFileContent, username;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!gistUrl || gistUrl.trim() === '')) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", null);

            case 2:
              _context.next = 4;
              return fetchText(gistUrl);

            case 4:
              gistFileContent = _context.sent;

              if (!(gistFileContent.indexOf(did) === -1)) {
                _context.next = 7;
                break;
              }

              throw new Error('Gist File provided does not contain the correct DID of the user');

            case 7:
              username = gistUrl.split('/')[3];
              return _context.abrupt("return", {
                username: username,
                proof: gistUrl
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function verifyGithub(_x, _x2) {
      return _verifyGithub.apply(this, arguments);
    }

    return verifyGithub;
  }(),

  /**
   * Verifies that the tweet contains the given muportDID and returns the users twitter username.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyTwitter: function () {
    var _verifyTwitter = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (claim) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", null);

            case 2:
              _context2.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context2.sent;

              if (!(verified.payload.sub !== did)) {
                _context2.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (!(!claimData.twitter_handle || !claimData.twitter_proof)) {
                _context2.next = 10;
                break;
              }

              throw new Error('The claim for your twitter is not correct');

            case 10:
              return _context2.abrupt("return", {
                username: claimData.twitter_handle,
                proof: claimData.twitter_proof,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function verifyTwitter(_x3, _x4) {
      return _verifyTwitter.apply(this, arguments);
    }

    return verifyTwitter;
  }(),

  /**
   * Verifies that the code entered by the user is the same one that was sent via email.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyEmail: function () {
    var _verifyEmail = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (claim) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", null);

            case 2:
              _context3.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context3.sent;

              if (!(verified.payload.sub !== did)) {
                _context3.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (claimData.email_address) {
                _context3.next = 10;
                break;
              }

              throw new Error('The claim for your email address is not correct');

            case 10:
              return _context3.abrupt("return", {
                email_address: claimData.email_address,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function verifyEmail(_x5, _x6) {
      return _verifyEmail.apply(this, arguments);
    }

    return verifyEmail;
  }(),

  /**
   * Verifies that the proof for a did is correct
   *
   * @param     {String}            claim           A did-JWT with claim
   * @return    {String}                            The DID of the user
   */
  verifyDID: function () {
    var _verifyDID = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(claim) {
      var verified;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return didJWT.verifyJWT(claim);

            case 2:
              verified = _context4.sent;
              return _context4.abrupt("return", verified.payload.iss);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function verifyDID(_x7) {
      return _verifyDID.apply(this, arguments);
    }

    return verifyDID;
  }(),

  /**
   * Verifies that the proof for an ethereum address is correct
   *
   * @param     {Object}    ethProof                      The claim generated by getLinkConsent
   * @param     {string}    ethProof.consent_msg
   * @param     {string}    ethProof.consent_signature
   * @param     {string}    ethProof.linked_did
   * @param     {String}    did                           The box' did
   * @return    {String}                                  The ethereum address used to sign the message
   */
  verifyEthereum: function () {
    var _verifyEthereum = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee5(ethProof, did) {
      var consentMsg, consentSig, expected;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              consentMsg = ethProof.version ? ethProof.message : ethProof['consent_msg'];
              consentSig = ethProof.version ? ethProof.signature : ethProof['consent_signature']; // Make sure the message matches our expectation

              expected = getMessageConsent(did);

              if (!(consentMsg !== expected)) {
                _context5.next = 5;
                break;
              }

              throw new Error("Invalid consent message, got: \"".concat(consentMsg, "\", expected: \"").concat(expected, "\""));

            case 5:
              return _context5.abrupt("return", ethers.utils.verifyMessage(consentMsg, consentSig));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function verifyEthereum(_x8, _x9) {
      return _verifyEthereum.apply(this, arguments);
    }

    return verifyEthereum;
  }()
};
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\verifier.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\index.js", {"./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\types.js","cross-fetch/polyfill":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\node_modules\\cross-fetch\\dist\\browser-polyfill.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\graphql-request\dist\src\index.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("./types");
var types_2 = require("./types");
exports.ClientError = types_2.ClientError;
require("cross-fetch/polyfill");
var GraphQLClient = /** @class */ (function () {
    function GraphQLClient(url, options) {
        this.url = url;
        this.options = options || {};
    }
    GraphQLClient.prototype.rawRequest = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, headers_1, status_1, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            headers_1 = response.headers, status_1 = response.status;
                            return [2 /*return*/, __assign({}, result, { headers: headers_1, status: status_1 })];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status, headers: response.headers }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.request = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            return [2 /*return*/, result.data];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.setHeaders = function (headers) {
        this.options.headers = headers;
        return this;
    };
    GraphQLClient.prototype.setHeader = function (key, value) {
        var headers = this.options.headers;
        if (headers) {
            headers[key] = value;
        }
        else {
            this.options.headers = (_a = {}, _a[key] = value, _a);
        }
        return this;
        var _a;
    };
    return GraphQLClient;
}());
exports.GraphQLClient = GraphQLClient;
function rawRequest(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.rawRequest(query, variables)];
        });
    });
}
exports.rawRequest = rawRequest;
function request(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.request(query, variables)];
        });
    });
}
exports.request = request;
exports.default = request;
function getResult(response) {
    return __awaiter(this, void 0, void 0, function () {
        var contentType;
        return __generator(this, function (_a) {
            contentType = response.headers.get('Content-Type');
            if (contentType && contentType.startsWith('application/json')) {
                return [2 /*return*/, response.json()];
            }
            else {
                return [2 /*return*/, response.text()];
            }
            return [2 /*return*/];
        });
    });
}
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"graphql-request",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\orbit-db-address.js", {"cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\orbit-db-address.js
      return function (require, module, exports) {
'use strict'
const path = require('path')
const multihash = require('multihashes')
const CID = require('cids')

const notEmpty = e => e !== '' && e !== ' '

class OrbitDBAddress {
  constructor (root, path) {
    this.root = root
    this.path = path
  }

  toString () {
    return path.join('/orbitdb', this.root, this.path)
  }

  static isValid (address) {
    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')

    const parts = address.toString()
      .split('/')
      .filter(containsProtocolPrefix)
      .filter(notEmpty)

    let accessControllerHash

    try {
      accessControllerHash = (parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1)
        ? new CID(parts[0]).toBaseEncodedString()
        : null
    } catch (e) {
      return false
    }

    return accessControllerHash !== null
  }

  static parse (address) {
    if (!address)
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    if (!OrbitDBAddress.isValid(address))
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    const parts = address.toString()
      .split('/')
      .filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb'))
      .filter(e => e !== '' && e !== ' ')

    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'))
  }
}

module.exports = OrbitDBAddress

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\orbit-db-address.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\thread.js", {"./api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\api.js","./config":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\config.js","@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","is-ipfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-ipfs\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\thread.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var isIPFS = require('is-ipfs');

var API = require('./api');

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;
var MODERATOR = 'MODERATOR';
var MEMBER = 'MEMBER';

var isValid3ID = function isValid3ID(did) {
  var parts = did.split(':');
  if (!parts[0] === 'did' || !parts[1] === '3') return false;
  return isIPFS.cid(parts[2]);
};

var Thread =
/*#__PURE__*/
function () {
  /**
   * Please use **space.joinThread** to get the instance of this class
   */
  function Thread(orbitdb, name, threeId, members, firstModerator, subscribe, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Thread);
    this._orbitdb = orbitdb;
    this._name = name;
    this._spaceName = name.split('.')[2];
    this._3id = threeId;
    this._subscribe = subscribe;
    this._ensureConnected = ensureConnected;
    this._queuedNewPosts = [];
    this._members = Boolean(members);
    this._firstModerator = firstModerator || this._3id.getSubDID(this._spaceName);
  }
  /**
   * Post a message to the thread
   *
   * @param     {Object}    message                 The message
   * @return    {String}                            The postId of the new post
   */


  (0, _createClass2["default"])(Thread, [{
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(message) {
        var timestamp;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._requireLoad();

                this._subscribe(this._address, {
                  firstModerator: this._firstModerator,
                  members: this._members,
                  name: this._name
                });

                this._ensureConnected(this._address, true);

                timestamp = Math.floor(new Date().getTime() / 1000); // seconds

                return _context.abrupt("return", this._db.add({
                  message: message,
                  timestamp: timestamp
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function post(_x) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "_getThreadAddress",
    value: function () {
      var _getThreadAddress2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var address;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._initConfigs();

              case 2:
                _context2.next = 4;
                return this._orbitdb._determineAddress(this._name, 'feed', {
                  accessController: this._accessController
                }, false);

              case 4:
                address = _context2.sent.toString();
                this._address = address;
                return _context2.abrupt("return", this._address);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getThreadAddress() {
        return _getThreadAddress2.apply(this, arguments);
      }

      return _getThreadAddress;
    }()
    /**
     * Add a moderator to this thread, throws error is user can not add a moderator
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "addModerator",
    value: function () {
      var _addModerator = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(id) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._requireLoad();

                if (!id.startsWith('0x')) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 4;
                return API.getSpaceDID(id, this._spaceName);

              case 4:
                id = _context3.sent;

              case 5:
                if (isValid3ID(id)) {
                  _context3.next = 7;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 7:
                return _context3.abrupt("return", this._db.access.grant(MODERATOR, id));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addModerator(_x2) {
        return _addModerator.apply(this, arguments);
      }

      return addModerator;
    }()
    /**
     * List moderators
     *
     * @return    {Array<String>}      Array of moderator DIDs
     */

  }, {
    key: "listModerators",
    value: function () {
      var _listModerators = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._requireLoad();

                return _context4.abrupt("return", this._db.access.capabilities['moderators']);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function listModerators() {
        return _listModerators.apply(this, arguments);
      }

      return listModerators;
    }()
    /**
     * Add a member to this thread, throws if user can not add member, throw is not member thread
     *
     * @param     {String}    id                      Member Id
     */

  }, {
    key: "addMember",
    value: function () {
      var _addMember = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(id) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._requireLoad();

                this._throwIfNotMembers();

                if (!id.startsWith('0x')) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return API.getSpaceDID(id, this._spaceName);

              case 5:
                id = _context5.sent;

              case 6:
                if (isValid3ID(id)) {
                  _context5.next = 8;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 8:
                this._throwIfNotMembers();

                return _context5.abrupt("return", this._db.access.grant(MEMBER, id));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addMember(_x3) {
        return _addMember.apply(this, arguments);
      }

      return addMember;
    }()
    /**
     * List members, throws if not member thread
     *
     * @return    {Array<String>}      Array of member DIDs
     */

  }, {
    key: "listMembers",
    value: function () {
      var _listMembers = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._throwIfNotMembers();

                this._requireLoad();

                return _context6.abrupt("return", this._db.access.capabilities['members']);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function listMembers() {
        return _listMembers.apply(this, arguments);
      }

      return listMembers;
    }()
  }, {
    key: "_throwIfNotMembers",
    value: function _throwIfNotMembers() {
      if (!this._members) throw new Error('Thread: Not a members only thread, function not available');
    }
    /**
     * Delete post
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "deletePost",
    value: function () {
      var _deletePost = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(hash) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.remove(hash));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function deletePost(_x4) {
        return _deletePost.apply(this, arguments);
      }

      return deletePost;
    }()
    /**
     * Returns an array of posts, based on the options.
     * If hash not found when passing gt, gte, lt, or lte,
     * the iterator will return all items (respecting limit and reverse).
     *
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.gt                 Greater than, takes an postId
     * @param     {String}    opts.gte                Greater than or equal to, takes an postId
     * @param     {String}    opts.lt                 Less than, takes an postId
     * @param     {String}    opts.lte                Less than or equal to, takes an postId
     * @param     {Integer}   opts.limit              Limiting the number of entries in result, defaults to -1 (no limit)
     * @param     {Boolean}   opts.reverse            If set to true will result in reversing the result
     *
     * @return    {Array<Object>}                           true if successful
     */

  }, {
    key: "getPosts",
    value: function () {
      var _getPosts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                this._requireLoad();

                if (!opts.limit) opts.limit = -1;
                return _context8.abrupt("return", this._db.iterator(opts).collect().map(function (entry) {
                  var post = entry.payload.value;
                  var metaData = {
                    postId: entry.hash,
                    author: entry.identity.id
                  };
                  return Object.assign(metaData, post);
                }));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPosts() {
        return _getPosts.apply(this, arguments);
      }

      return getPosts;
    }()
    /**
     * Register a function to be called after new updates
     * have been received from the network or locally.
     *
     * @param     {Function}  updateFn               The function that will get called
     */

  }, {
    key: "onUpdate",
    value: function () {
      var _onUpdate = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(updateFn) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._requireLoad();

                this._db.events.on('replicated', function (address, hash, entry, prog, tot) {
                  updateFn();
                });

                this._db.events.on('write', function (dbname, entry) {
                  updateFn();
                });

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onUpdate(_x5) {
        return _onUpdate.apply(this, arguments);
      }

      return onUpdate;
    }()
    /**
     * Register a function to be called for every new
     * capability that is added to the thread access controller.
     * This inlcudes when a moderator or member is added.
     * The function takes one parameter, which is the capabilities obj, or
     * you can call listModerator / listMembers again instead.
     *
     * @param     {Function}  updateFn     The function that will get called
     */

  }, {
    key: "onNewCapabilities",
    value: function () {
      var _onNewCapabilities = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(updateFn) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._db.access.on('updated', function (event) {
                  updateFn(_this._db.access.capabilities);
                });

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function onNewCapabilities(_x6) {
        return _onNewCapabilities.apply(this, arguments);
      }

      return onNewCapabilities;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(odbAddress) {
        var identity;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._initConfigs();

              case 2:
                identity = this._identity;
                _context11.next = 5;
                return this._orbitdb.feed(odbAddress || this._name, _objectSpread({}, ORBITDB_OPTS, {
                  identity: identity,
                  accessController: this._accessController
                }));

              case 5:
                this._db = _context11.sent;
                _context11.next = 8;
                return this._db.load();

              case 8:
                this._address = this._db.address.toString();

                this._ensureConnected(this._address, true);

                return _context11.abrupt("return", this._address);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _load(_x7) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._requireLoad();

                _context12.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_initConfigs",
    value: function () {
      var _initConfigs2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!this._identity) {
                  _context13.next = 2;
                  break;
                }

                return _context13.abrupt("return");

              case 2:
                _context13.next = 4;
                return this._3id.getOdbId(this._spaceName);

              case 4:
                this._identity = _context13.sent;

                if (!this._firstModerator.startsWith('0x')) {
                  _context13.next = 9;
                  break;
                }

                _context13.next = 8;
                return API.getSpaceDID(this._firstModerator, this._spaceName);

              case 8:
                this._firstModerator = _context13.sent;

              case 9:
                this._accessController = {
                  type: 'thread-access',
                  threadName: this._name,
                  members: this._members,
                  firstModerator: this._firstModerator,
                  identity: this._identity
                };

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _initConfigs() {
        return _initConfigs2.apply(this, arguments);
      }

      return _initConfigs;
    }()
  }, {
    key: "address",
    get: function get() {
      return this._db ? this._address : null;
    }
  }]);
  return Thread;
}();

module.exports = Thread;
      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\thread.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\node_modules\ethers\dist\ethers.min.js
      return function (require, module, exports) {
!function(e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).ethers=e()}(function(){return function o(s,a,u){function l(t,e){if(!a[t]){if(!s[t]){var r="function"==typeof require&&require;if(!e&&r)return r(t,!0);if(h)return h(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=a[t]={exports:{}};s[t][0].call(i.exports,function(e){return l(s[t][1][e]||e)},i,i.exports,o,s,a,u)}return a[t].exports}for(var h="function"==typeof require&&require,e=0;e<u.length;e++)l(u[e]);return l}({1:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.version="4.0.48"},{}],2:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./utils/properties"),i=(o.isSigner=function(e){return n.isType(e,"Signer")},o);function o(){n.setType(this,"Signer")}r.Signer=i},{"./utils/properties":74}],3:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./utils/bignumber");r.AddressZero="0x0000000000000000000000000000000000000000";r.HashZero="0x0000000000000000000000000000000000000000000000000000000000000000";r.EtherSymbol="\u039e";var i=n.bigNumberify(-1);r.NegativeOne=i;var o=n.bigNumberify(0);r.Zero=o;var s=n.bigNumberify(1);r.One=s;var a=n.bigNumberify(2);r.Two=a;var u=n.bigNumberify("1000000000000000000");r.WeiPerEther=u;var l=n.bigNumberify("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");r.MaxUint256=l},{"./utils/bignumber":63}],4:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,u=e("./constants"),l=o(e("./errors")),h=e("./utils/abi-coder"),a=e("./utils/address"),f=e("./utils/bignumber"),c=e("./utils/bytes"),d=e("./utils/interface"),p=e("./utils/properties"),v=e("./providers/abstract-provider"),y=e("./abstract-signer"),m=(s=y.Signer,i(g,s),g.prototype.getAddress=function(){return Promise.resolve(this.address)},g.prototype._fail=function(e,t){return Promise.resolve().then(function(){l.throwError(e,l.UNSUPPORTED_OPERATION,{operation:t})})},g.prototype.signMessage=function(e){return this._fail("VoidSigner cannot sign messages","signMessage")},g.prototype.sendTransaction=function(e){return this._fail("VoidSigner cannot sign transactions","sendTransaction")},g.prototype.connect=function(e){return new g(this.address,e)},g);function g(e,t){var r=s.call(this)||this;return p.defineReadOnly(r,"address",e),p.defineReadOnly(r,"provider",t),r}r.VoidSigner=m;var b={chainId:!0,data:!0,from:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0};function w(o,e,s){var a=o.interface.functions[e];return function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var i={},r=null;if(e.length===a.inputs.length+1&&"object"==typeof e[e.length-1])for(var n in null!=(i=p.shallowCopy(e.pop())).blockTag&&(r=i.blockTag),delete i.blockTag,i)if(!b[n])throw new Error("unknown transaction override "+n);if(e.length!=a.inputs.length)throw new Error("incorrect number of arguments");return["data","to"].forEach(function(e){null!=i[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),i.to=o._deployed(r).then(function(){return o.addressPromise}),function n(i,o,e){if(Array.isArray(e)){var s=[];return e.forEach(function(e,t){var r=null,r=Array.isArray(o)?o[t]:o[e.name];s.push(n(i,r,e))}),Promise.all(s)}if("address"===e.type)return i.resolveName(o);if("tuple"===e.type)return n(i,o,e.components);var t=e.type.match(/(.*)(\[[0-9]*\]$)/);if(t){if(!Array.isArray(o))throw new Error("invalid value for array");var r=[],a={components:e.components,type:t[1]};return o.forEach(function(e){r.push(n(i,e,a))}),Promise.all(r)}return Promise.resolve(o)}(o.provider,e,a.inputs).then(function(n){if(i.data=a.encode(n),"call"===a.type)return s?Promise.resolve(u.Zero):(o.provider||l.throwError("call (constant functions) require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"call"}),["gasLimit","gasPrice","value"].forEach(function(e){if(null!=i[e])throw new Error("call cannot override "+e)}),null==i.from&&o.signer&&(i.from=o.signer.getAddress()),o.provider.call(i,r).then(function(t){var e;c.hexDataLength(t)%32==4&&"0x08c379a0"===c.hexDataSlice(t,0,4)&&(e=h.defaultAbiCoder.decode(["string"],c.hexDataSlice(t,4)),l.throwError("call revert exception",l.CALL_EXCEPTION,{address:o.address,args:n,method:a.signature,errorSignature:"Error(string)",errorArgs:[e],reason:e,transaction:i}));try{var r=a.decode(t);return 1===a.outputs.length&&(r=r[0]),r}catch(e){throw"0x"===t&&0<a.outputs.length&&l.throwError("call exception",l.CALL_EXCEPTION,{address:o.address,method:a.signature,args:n}),e}}));if("transaction"===a.type)return s?(o.provider||l.throwError("estimate gas require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"estimateGas"}),null==i.from&&o.signer&&(i.from=o.signer.getAddress()),o.provider.estimateGas(i)):(null==i.gasLimit&&null!=a.gas&&(i.gasLimit=f.bigNumberify(a.gas).add(21e3)),o.signer||l.throwError("sending a transaction requires a signer",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction"}),null!=i.from&&l.throwError("cannot override from in a transaction",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction"}),o.signer.sendTransaction(i).then(function(e){var t=e.wait.bind(e);return e.wait=function(e){return t(e).then(function(n){return n.events=n.logs.map(function(e){var t=p.deepCopy(e),r=o.interface.parseLog(e);return r&&(t.args=r.values,t.decode=r.decode,t.event=r.name,t.eventSignature=r.signature),t.removeListener=function(){return o.provider},t.getBlock=function(){return o.provider.getBlock(n.blockHash)},t.getTransaction=function(){return o.provider.getTransaction(n.transactionHash)},t.getTransactionReceipt=function(){return Promise.resolve(n)},t}),n})},e}));throw new Error("invalid type - "+a.type)})}}function _(e){return!e.address||null!=e.topics&&0!==e.topics.length?(e.address||"*")+"@"+(e.topics?e.topics.join(":"):""):"*"}var M=(A.prototype.deployed=function(){return this._deployed()},A.prototype._deployed=function(e){var t=this;return this._deployedPromise||(this.deployTransaction?this._deployedPromise=this.deployTransaction.wait().then(function(){return t}):this._deployedPromise=this.provider.getCode(this.address,e).then(function(e){return"0x"===e&&l.throwError("contract not deployed",l.UNSUPPORTED_OPERATION,{contractAddress:t.address,operation:"getDeployed"}),t})),this._deployedPromise},A.prototype.fallback=function(e){var t=this;this.signer||l.throwError("sending a transaction requires a signer",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"});var r=p.shallowCopy(e||{});return["from","to"].forEach(function(e){null!=r[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),r.to=this.addressPromise,this.deployed().then(function(){return t.signer.sendTransaction(r)})},A.prototype.connect=function(e){"string"==typeof e&&(e=new m(e,this.provider));var t=new A(this.address,this.interface,e);return this.deployTransaction&&p.defineReadOnly(t,"deployTransaction",this.deployTransaction),t},A.prototype.attach=function(e){return new A(e,this.interface,this.signer||this.provider)},A.isIndexed=function(e){return d.Interface.isIndexed(e)},A.prototype._getEventFilter=function(e){var r=this;if("string"==typeof e){if("*"===e)return{prepareEvent:function(e){var t=r.interface.parseLog(e);return t&&(e.args=t.values,e.decode=t.decode,e.event=t.name,e.eventSignature=t.signature),[e]},eventTag:"*",filter:{address:this.address}};-1!==e.indexOf("(")&&(e=h.formatSignature(h.parseSignature("event "+e)));var n=this.interface.events[e];n||l.throwError("unknown event - "+e,l.INVALID_ARGUMENT,{argumnet:"eventName",value:e});var t={address:this.address,topics:[n.topic]};return{prepareEvent:function(e){var t=n.decode(e.data,e.topics);e.args=t;var r=Array.prototype.slice.call(t);return r.push(e),r},event:n,eventTag:_(t),filter:t}}var i={address:this.address},o=null;if(e.topics&&e.topics[0])for(var s in i.topics=e.topics,this.interface.events)if(-1!==s.indexOf("(")){var a=this.interface.events[s];if(a.topic===e.topics[0].toLowerCase()){o=a;break}}return{prepareEvent:function(e){if(!o)return[e];var t=o.decode(e.data,e.topics);e.args=t;var r=Array.prototype.slice.call(t);return r.push(e),r},event:o,eventTag:_(i),filter:i}},A.prototype._addEventListener=function(n,i,e){var o=this;this.provider||l.throwError("events require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"once"});function t(e){var t=p.deepCopy(e),r=n.prepareEvent(t);n.event&&(t.decode=n.event.decode,t.event=n.event.name,t.eventSignature=n.event.signature),t.removeListener=function(){o.removeListener(n.filter,i)},t.getBlock=function(){return o.provider.getBlock(e.blockHash)},t.getTransaction=function(){return o.provider.getTransaction(e.transactionHash)},t.getTransactionReceipt=function(){return o.provider.getTransactionReceipt(e.transactionHash)},o.emit.apply(o,[n.filter].concat(r))}this.provider.on(n.filter,t),this._events.push({eventFilter:n,listener:i,wrappedListener:t,once:e})},A.prototype.on=function(e,t){return this._addEventListener(this._getEventFilter(e),t,!1),this},A.prototype.once=function(e,t){return this._addEventListener(this._getEventFilter(e),t,!0),this},A.prototype.addListener=function(e,t){return this.on(e,t)},A.prototype.emit=function(e){for(var t=this,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];if(!this.provider)return!1;var i=!1,o=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==o.eventTag||(setTimeout(function(){e.listener.apply(t,r)},0),i=!0,!e.once)}),i},A.prototype.listenerCount=function(e){if(!this.provider)return 0;var t=this._getEventFilter(e);return this._events.filter(function(e){return e.eventFilter.eventTag===t.eventTag}).length},A.prototype.listeners=function(e){if(!this.provider)return[];var t=this._getEventFilter(e);return this._events.filter(function(e){return e.eventFilter.eventTag===t.eventTag}).map(function(e){return e.listener})},A.prototype.removeAllListeners=function(e){var t=this;if(!this.provider)return this;var r=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==r.eventTag||(t.provider.removeListener(e.eventFilter.filter,e.wrappedListener),!1)}),this},A.prototype.removeListener=function(e,t){var r=this;if(!this.provider)return this;var n=!1,i=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==i.eventTag||(e.listener!==t||(r.provider.removeListener(e.eventFilter.filter,e.wrappedListener),!!n||!(n=!0)))}),this},A);function A(t,e,r){var n=this;if(l.checkNew(this,A),d.Interface.isInterface(e)?p.defineReadOnly(this,"interface",e):p.defineReadOnly(this,"interface",new d.Interface(e)),y.Signer.isSigner(r)?(p.defineReadOnly(this,"provider",r.provider),p.defineReadOnly(this,"signer",r)):v.Provider.isProvider(r)?(p.defineReadOnly(this,"provider",r),p.defineReadOnly(this,"signer",null)):l.throwError("invalid signer or provider",l.INVALID_ARGUMENT,{arg:"signerOrProvider",value:r}),p.defineReadOnly(this,"estimate",{}),p.defineReadOnly(this,"functions",{}),p.defineReadOnly(this,"filters",{}),Object.keys(this.interface.events).forEach(function(e){var r=n.interface.events[e];p.defineReadOnly(n.filters,e,function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return{address:n.address,topics:r.encodeTopics(e)}})}),this._events=[],p.defineReadOnly(this,"address",t),this.provider)p.defineReadOnly(this,"addressPromise",this.provider.resolveName(t).then(function(e){if(null==e)throw new Error("name not found");return e}).catch(function(e){throw e}));else try{p.defineReadOnly(this,"addressPromise",Promise.resolve(a.getAddress(t)))}catch(e){l.throwError("provider is required to use non-address contract address",l.INVALID_ARGUMENT,{argument:"addressOrName",value:t})}Object.keys(this.interface.functions).forEach(function(e){var t=w(n,e,!1);null==n[e]?p.defineReadOnly(n,e,t):l.warn("WARNING: Multiple definitions for "+e),null==n.functions[e]&&(p.defineReadOnly(n.functions,e,t),p.defineReadOnly(n.estimate,e,w(n,e,!0)))})}r.Contract=M;var E=(S.prototype.getDeployTransaction=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r={};if(e.length===this.interface.deployFunction.inputs.length+1)for(var n in r=p.shallowCopy(e.pop()))if(!b[n])throw new Error("unknown transaction override "+n);return["data","from","to"].forEach(function(e){null!=r[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),l.checkArgumentCount(e.length,this.interface.deployFunction.inputs.length," in Contract constructor"),r.data=this.interface.deployFunction.encode(this.bytecode,e),r},S.prototype.deploy=function(){for(var r=this,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var n=this.getDeployTransaction.apply(this,e);return this.signer.sendTransaction(n).then(function(e){var t=new M(a.getContractAddress(e),r.interface,r.signer);return p.defineReadOnly(t,"deployTransaction",e),t})},S.prototype.attach=function(e){return new M(e,this.interface,this.signer)},S.prototype.connect=function(e){return new S(this.interface,this.bytecode,e)},S.fromSolidity=function(e,t){null==e&&l.throwError("missing compiler output",l.MISSING_ARGUMENT,{argument:"compilerOutput"}),"string"==typeof e&&(e=JSON.parse(e));var r=e.abi,n=null;return e.bytecode?n=e.bytecode:e.evm&&e.evm.bytecode&&(n=e.evm.bytecode),new S(r,n,t)},S);function S(e,t,r){var n=null;"string"==typeof t?n=t:c.isArrayish(t)?n=c.hexlify(t):"string"==typeof t.object?n=t.object:l.throwError("bytecode must be a valid hex string",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),"0x"!==n.substring(0,2)&&(n="0x"+n),c.isHexString(n)||l.throwError("bytecode must be a valid hex string",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),n.length%2!=0&&l.throwError("bytecode must be valid data (even length)",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),p.defineReadOnly(this,"bytecode",n),d.Interface.isInterface(e)?p.defineReadOnly(this,"interface",e):p.defineReadOnly(this,"interface",new d.Interface(e)),r&&!y.Signer.isSigner(r)&&l.throwError("invalid signer",l.INVALID_ARGUMENT,{arg:"signer",value:null}),p.defineReadOnly(this,"signer",r||null)}r.ContractFactory=E},{"./abstract-signer":2,"./constants":3,"./errors":5,"./providers/abstract-provider":50,"./utils/abi-coder":59,"./utils/address":60,"./utils/bignumber":63,"./utils/bytes":64,"./utils/interface":69,"./utils/properties":74}],5:[function(e,t,s){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var a=e("./_version");s.UNKNOWN_ERROR="UNKNOWN_ERROR",s.NOT_IMPLEMENTED="NOT_IMPLEMENTED",s.MISSING_NEW="MISSING_NEW",s.CALL_EXCEPTION="CALL_EXCEPTION",s.INVALID_ARGUMENT="INVALID_ARGUMENT",s.MISSING_ARGUMENT="MISSING_ARGUMENT",s.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",s.NUMERIC_FAULT="NUMERIC_FAULT",s.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",s.NONCE_EXPIRED="NONCE_EXPIRED",s.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED";var r=!(s.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION"),u=!1;function n(e,t,r){if(u)throw new Error("unknown error");t=t||s.UNKNOWN_ERROR,r=r||{};var n=[];Object.keys(r).forEach(function(t){try{n.push(t+"="+JSON.stringify(r[t]))}catch(e){n.push(t+"="+JSON.stringify(r[t].toString()))}}),n.push("version="+a.version);var i=e;n.length&&(e+=" ("+n.join(", ")+")");var o=new Error(e);throw o.reason=i,o.code=t,Object.keys(r).forEach(function(e){o[e]=r[e]}),o}s.throwError=n,s.checkNew=function(e,t){e instanceof t||n("missing new",s.MISSING_NEW,{name:t.name})},s.checkArgumentCount=function(e,t,r){r=r||"",e<t&&n("missing argument"+r,s.MISSING_ARGUMENT,{count:e,expectedCount:t}),t<e&&n("too many arguments"+r,s.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})},s.setCensorship=function(e,t){r&&n("error censorship permanent",s.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),u=!!e,r=!!t},s.checkNormalize=function(){try{if(["NFD","NFC","NFKD","NFKC"].forEach(function(t){try{"test".normalize(t)}catch(e){throw new Error("missing "+t)}}),String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769))throw new Error("broken implementation")}catch(e){n("platform missing String.prototype.normalize",s.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:e.message})}};var i={debug:1,default:2,info:2,warn:3,error:4,off:5},o=i.default;function l(e,t){o>i[e]||console.log.apply(console,t)}function h(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];l("warn",e)}s.setLogLevel=function(e){var t=i[e];null!=t?o=t:h("invliad log level - "+e)},s.warn=h,s.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];l("info",e)}},{"./_version":1}],6:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./contract");r.Contract=i.Contract,r.ContractFactory=i.ContractFactory,r.VoidSigner=i.VoidSigner;var o=e("./abstract-signer");r.Signer=o.Signer;var s=e("./wallet");r.Wallet=s.Wallet;var a=n(e("./constants"));r.constants=a;var u=n(e("./errors"));r.errors=u;var l=n(e("./providers"));r.providers=l;var h=n(e("./utils"));r.utils=h;var f=n(e("./wordlists"));r.wordlists=f;var c=e("./utils/shims");r.platform=c.platform;var d=e("./_version");r.version=d.version,r.getDefaultProvider=function(e){null==e&&(e="homestead");var t=h.getNetwork(e);return t&&t._defaultProvider||u.throwError("unsupported getDefaultProvider network",u.UNSUPPORTED_OPERATION,{operation:"getDefaultProvider",network:e}),t._defaultProvider(l)}},{"./_version":1,"./abstract-signer":2,"./constants":3,"./contract":4,"./errors":5,"./providers":54,"./utils":68,"./utils/shims":80,"./wallet":88,"./wordlists":89}],7:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("./ethers"));r.ethers=i,function(e){for(var t in e)r.hasOwnProperty(t)||(r[t]=e[t])}(e("./ethers"))},{"./ethers":6}],8:[function(e,C,L){"use strict";!function(e){function r(e){return parseInt(e)===e}function n(e){if(r(e.length)){for(var t=0;t<e.length;t++)if(!r(e[t])||e[t]<0||255<e[t])return;return 1}}function o(e,t){if(e.buffer&&ArrayBuffer.isView(e)&&"Uint8Array"===e.name)return t&&(e=e.slice?e.slice():Array.prototype.slice.call(e)),e;if(Array.isArray(e)){if(!n(e))throw new Error("Array contains invalid value: "+e);return new Uint8Array(e)}if(r(e.length)&&n(e))return new Uint8Array(e);throw new Error("unsupported array-like object")}function u(e){return new Uint8Array(e)}function s(e,t,r,n,i){null==n&&null==i||(e=e.slice?e.slice(n,i):Array.prototype.slice.call(e,n,i)),t.set(e,r)}var i,t={toBytes:function(e){var t=[],r=0;for(e=encodeURI(e);r<e.length;){var n=e.charCodeAt(r++);37===n?(t.push(parseInt(e.substr(r,2),16)),r+=2):t.push(n)}return o(t)},fromBytes:function(e){for(var t=[],r=0;r<e.length;){var n=e[r];n<128?(t.push(String.fromCharCode(n)),r++):191<n&&n<224?(t.push(String.fromCharCode((31&n)<<6|63&e[r+1])),r+=2):(t.push(String.fromCharCode((15&n)<<12|(63&e[r+1])<<6|63&e[r+2])),r+=3)}return t.join("")}},a=(i="0123456789abcdef",{toBytes:function(e){for(var t=[],r=0;r<e.length;r+=2)t.push(parseInt(e.substr(r,2),16));return t},fromBytes:function(e){for(var t=[],r=0;r<e.length;r++){var n=e[r];t.push(i[(240&n)>>4]+i[15&n])}return t.join("")}}),f={16:10,24:12,32:14},c=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],d=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],l=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],h=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],p=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],v=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],y=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],m=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],g=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],b=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],w=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],_=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],M=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],A=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],E=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function S(e){for(var t=[],r=0;r<e.length;r+=4)t.push(e[r]<<24|e[r+1]<<16|e[r+2]<<8|e[r+3]);return t}var k=function(e){if(!(this instanceof k))throw Error("AES must be instanitated with `new`");Object.defineProperty(this,"key",{value:o(e,!0)}),this._prepare()};k.prototype._prepare=function(){var e=f[this.key.length];if(null==e)throw new Error("invalid key size (must be 16, 24 or 32 bytes)");this._Ke=[],this._Kd=[];for(var t=0;t<=e;t++)this._Ke.push([0,0,0,0]),this._Kd.push([0,0,0,0]);for(var r,n=4*(e+1),i=this.key.length/4,o=S(this.key),t=0;t<i;t++)r=t>>2,this._Ke[r][t%4]=o[t],this._Kd[e-r][t%4]=o[t];for(var s,a=0,u=i;u<n;){if(s=o[i-1],o[0]^=d[s>>16&255]<<24^d[s>>8&255]<<16^d[255&s]<<8^d[s>>24&255]^c[a]<<24,a+=1,8!=i)for(t=1;t<i;t++)o[t]^=o[t-1];else{for(t=1;t<i/2;t++)o[t]^=o[t-1];s=o[i/2-1],o[i/2]^=d[255&s]^d[s>>8&255]<<8^d[s>>16&255]<<16^d[s>>24&255]<<24;for(t=i/2+1;t<i;t++)o[t]^=o[t-1]}for(t=0;t<i&&u<n;)l=u>>2,h=u%4,this._Ke[l][h]=o[t],this._Kd[e-l][h]=o[t++],u++}for(var l=1;l<e;l++)for(var h=0;h<4;h++)s=this._Kd[l][h],this._Kd[l][h]=_[s>>24&255]^M[s>>16&255]^A[s>>8&255]^E[255&s]},k.prototype.encrypt=function(e){if(16!=e.length)throw new Error("invalid plaintext size (must be 16 bytes)");for(var t=this._Ke.length-1,r=[0,0,0,0],n=S(e),i=0;i<4;i++)n[i]^=this._Ke[0][i];for(var o=1;o<t;o++){for(i=0;i<4;i++)r[i]=h[n[i]>>24&255]^p[n[(i+1)%4]>>16&255]^v[n[(i+2)%4]>>8&255]^y[255&n[(i+3)%4]]^this._Ke[o][i];n=r.slice()}for(var s,a=u(16),i=0;i<4;i++)s=this._Ke[t][i],a[4*i]=255&(d[n[i]>>24&255]^s>>24),a[4*i+1]=255&(d[n[(i+1)%4]>>16&255]^s>>16),a[4*i+2]=255&(d[n[(i+2)%4]>>8&255]^s>>8),a[4*i+3]=255&(d[255&n[(i+3)%4]]^s);return a},k.prototype.decrypt=function(e){if(16!=e.length)throw new Error("invalid ciphertext size (must be 16 bytes)");for(var t=this._Kd.length-1,r=[0,0,0,0],n=S(e),i=0;i<4;i++)n[i]^=this._Kd[0][i];for(var o=1;o<t;o++){for(i=0;i<4;i++)r[i]=m[n[i]>>24&255]^g[n[(i+3)%4]>>16&255]^b[n[(i+2)%4]>>8&255]^w[255&n[(i+1)%4]]^this._Kd[o][i];n=r.slice()}for(var s,a=u(16),i=0;i<4;i++)s=this._Kd[t][i],a[4*i]=255&(l[n[i]>>24&255]^s>>24),a[4*i+1]=255&(l[n[(i+3)%4]>>16&255]^s>>16),a[4*i+2]=255&(l[n[(i+2)%4]>>8&255]^s>>8),a[4*i+3]=255&(l[255&n[(i+1)%4]]^s);return a};var N=function(e){if(!(this instanceof N))throw Error("AES must be instanitated with `new`");this.description="Electronic Code Block",this.name="ecb",this._aes=new k(e)};N.prototype.encrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16)s(e,r,0,n,n+16),s(r=this._aes.encrypt(r),t,n);return t},N.prototype.decrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16)s(e,r,0,n,n+16),s(r=this._aes.decrypt(r),t,n);return t};var x=function(e,t){if(!(this instanceof x))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Block Chaining",this.name="cbc",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=u(16);this._lastCipherblock=o(t,!0),this._aes=new k(e)};x.prototype.encrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16){s(e,r,0,n,n+16);for(var i=0;i<16;i++)r[i]^=this._lastCipherblock[i];this._lastCipherblock=this._aes.encrypt(r),s(this._lastCipherblock,t,n)}return t},x.prototype.decrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16){s(e,r,0,n,n+16),r=this._aes.decrypt(r);for(var i=0;i<16;i++)t[n+i]=r[i]^this._lastCipherblock[i];s(e,this._lastCipherblock,0,n,n+16)}return t};var P=function(e,t,r){if(!(this instanceof P))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Feedback",this.name="cfb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 size)")}else t=u(16);r=r||1,this.segmentSize=r,this._shiftRegister=o(t,!0),this._aes=new k(e)};P.prototype.encrypt=function(e){if(e.length%this.segmentSize!=0)throw new Error("invalid plaintext size (must be segmentSize bytes)");for(var t,r=o(e,!0),n=0;n<r.length;n+=this.segmentSize){t=this._aes.encrypt(this._shiftRegister);for(var i=0;i<this.segmentSize;i++)r[n+i]^=t[i];s(this._shiftRegister,this._shiftRegister,0,this.segmentSize),s(r,this._shiftRegister,16-this.segmentSize,n,n+this.segmentSize)}return r},P.prototype.decrypt=function(e){if(e.length%this.segmentSize!=0)throw new Error("invalid ciphertext size (must be segmentSize bytes)");for(var t,r=o(e,!0),n=0;n<r.length;n+=this.segmentSize){t=this._aes.encrypt(this._shiftRegister);for(var i=0;i<this.segmentSize;i++)r[n+i]^=t[i];s(this._shiftRegister,this._shiftRegister,0,this.segmentSize),s(e,this._shiftRegister,16-this.segmentSize,n,n+this.segmentSize)}return r};var I=function(e,t){if(!(this instanceof I))throw Error("AES must be instanitated with `new`");if(this.description="Output Feedback",this.name="ofb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=u(16);this._lastPrecipher=o(t,!0),this._lastPrecipherIndex=16,this._aes=new k(e)};I.prototype.encrypt=function(e){for(var t=o(e,!0),r=0;r<t.length;r++)16===this._lastPrecipherIndex&&(this._lastPrecipher=this._aes.encrypt(this._lastPrecipher),this._lastPrecipherIndex=0),t[r]^=this._lastPrecipher[this._lastPrecipherIndex++];return t},I.prototype.decrypt=I.prototype.encrypt;var T=function(e){if(!(this instanceof T))throw Error("Counter must be instanitated with `new`");0===e||e||(e=1),"number"==typeof e?(this._counter=u(16),this.setValue(e)):this.setBytes(e)};T.prototype.setValue=function(e){if("number"!=typeof e||parseInt(e)!=e)throw new Error("invalid counter value (must be an integer)");for(var t=15;0<=t;--t)this._counter[t]=e%256,e>>=8},T.prototype.setBytes=function(e){if(16!=(e=o(e,!0)).length)throw new Error("invalid counter bytes size (must be 16 bytes)");this._counter=e},T.prototype.increment=function(){for(var e=15;0<=e;e--){if(255!==this._counter[e]){this._counter[e]++;break}this._counter[e]=0}};var R=function(e,t){if(!(this instanceof R))throw Error("AES must be instanitated with `new`");this.description="Counter",this.name="ctr",t instanceof T||(t=new T(t)),this._counter=t,this._remainingCounter=null,this._remainingCounterIndex=16,this._aes=new k(e)};R.prototype.encrypt=function(e){for(var t=o(e,!0),r=0;r<t.length;r++)16===this._remainingCounterIndex&&(this._remainingCounter=this._aes.encrypt(this._counter._counter),this._remainingCounterIndex=0,this._counter.increment()),t[r]^=this._remainingCounter[this._remainingCounterIndex++];return t},R.prototype.decrypt=R.prototype.encrypt;var O={AES:k,Counter:T,ModeOfOperation:{ecb:N,cbc:x,cfb:P,ofb:I,ctr:R},utils:{hex:a,utf8:t},padding:{pkcs7:{pad:function(e){var t=16-(e=o(e,!0)).length%16,r=u(e.length+t);s(e,r);for(var n=e.length;n<r.length;n++)r[n]=t;return r},strip:function(e){if((e=o(e,!0)).length<16)throw new Error("PKCS#7 invalid length");var t=e[e.length-1];if(16<t)throw new Error("PKCS#7 padding byte out of range");for(var r=e.length-t,n=0;n<t;n++)if(e[r+n]!==t)throw new Error("PKCS#7 invalid padding byte");var i=u(r);return s(e,i,0,0,r),i}}},_arrayTest:{coerceArray:o,createArray:u,copyArray:s}};void 0!==L?C.exports=O:(e.aesjs&&(O._aesjs=e.aesjs),e.aesjs=O)}(this)},{}],9:[function(A,e,t){!function(e,t){"use strict";function y(e,t){if(!e)throw new Error(t||"Assertion failed")}function r(e,t){e.super_=t;function r(){}r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}function m(e,t,r){if(m.isBN(e))return e;this.negative=0,this.words=null,this.length=0,(this.red=null)!==e&&("le"!==t&&"be"!==t||(r=t,t=10),this._init(e||0,t||10,r||"be"))}var n;"object"==typeof e?e.exports=m:t.BN=m,(m.BN=m).wordSize=26;try{n=A("buffer").Buffer}catch(e){}function s(e,t,r){for(var n=0,i=Math.min(e.length,r),o=t;o<i;o++){var s=e.charCodeAt(o)-48;n<<=4,n|=49<=s&&s<=54?s-49+10:17<=s&&s<=22?s-17+10:15&s}return n}function f(e,t,r,n){for(var i=0,o=Math.min(e.length,r),s=t;s<o;s++){var a=e.charCodeAt(s)-48;i*=n,i+=49<=a?a-49+10:17<=a?a-17+10:a}return i}m.isBN=function(e){return e instanceof m||null!==e&&"object"==typeof e&&e.constructor.wordSize===m.wordSize&&Array.isArray(e.words)},m.max=function(e,t){return 0<e.cmp(t)?e:t},m.min=function(e,t){return e.cmp(t)<0?e:t},m.prototype._init=function(e,t,r){if("number"==typeof e)return this._initNumber(e,t,r);if("object"==typeof e)return this._initArray(e,t,r);"hex"===t&&(t=16),y(t===(0|t)&&2<=t&&t<=36);var n=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&n++,16===t?this._parseHex(e,n):this._parseBase(e,t,n),"-"===e[0]&&(this.negative=1),this.strip(),"le"===r&&this._initArray(this.toArray(),t,r)},m.prototype._initNumber=function(e,t,r){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(y(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===r&&this._initArray(this.toArray(),t,r)},m.prototype._initArray=function(e,t,r){if(y("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var n,i,o=0;o<this.length;o++)this.words[o]=0;var s=0;if("be"===r)for(o=e.length-1,n=0;0<=o;o-=3)i=e[o]|e[o-1]<<8|e[o-2]<<16,this.words[n]|=i<<s&67108863,this.words[n+1]=i>>>26-s&67108863,26<=(s+=24)&&(s-=26,n++);else if("le"===r)for(n=o=0;o<e.length;o+=3)i=e[o]|e[o+1]<<8|e[o+2]<<16,this.words[n]|=i<<s&67108863,this.words[n+1]=i>>>26-s&67108863,26<=(s+=24)&&(s-=26,n++);return this.strip()},m.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var r,n=0;n<this.length;n++)this.words[n]=0;for(var i=0,n=e.length-6,o=0;t<=n;n-=6)r=s(e,n,n+6),this.words[o]|=r<<i&67108863,this.words[o+1]|=r>>>26-i&4194303,26<=(i+=24)&&(i-=26,o++);n+6!==t&&(r=s(e,t,n+6),this.words[o]|=r<<i&67108863,this.words[o+1]|=r>>>26-i&4194303),this.strip()},m.prototype._parseBase=function(e,t,r){this.words=[0];for(var n=0,i=this.length=1;i<=67108863;i*=t)n++;n--,i=i/t|0;for(var o=e.length-r,s=o%n,a=Math.min(o,o-s)+r,u=0,l=r;l<a;l+=n)u=f(e,l,l+n,t),this.imuln(i),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);if(0!=s){for(var h=1,u=f(e,l,e.length,t),l=0;l<s;l++)h*=t;this.imuln(h),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u)}},m.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},m.prototype.clone=function(){var e=new m(null);return this.copy(e),e},m.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},m.prototype.strip=function(){for(;1<this.length&&0===this.words[this.length-1];)this.length--;return this._normSign()},m.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},m.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],d=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],p=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function i(e,t,r){r.negative=t.negative^e.negative;var n=e.length+t.length|0,n=(r.length=n)-1|0,i=67108863&(f=(0|e.words[0])*(0|t.words[0])),o=f/67108864|0;r.words[0]=i;for(var s=1;s<n;s++){for(var a=o>>>26,u=67108863&o,l=Math.min(s,t.length-1),h=Math.max(0,s-e.length+1);h<=l;h++){var f,c=s-h|0;a+=(f=(0|e.words[c])*(0|t.words[h])+u)/67108864|0,u=67108863&f}r.words[s]=0|u,o=0|a}return 0!==o?r.words[s]=0|o:r.length--,r.strip()}m.prototype.toString=function(e,t){if(t=0|t||1,16===(e=e||10)||"hex"===e){a="";for(var r=0,n=0,i=0;i<this.length;i++){var o=this.words[i],s=(16777215&(o<<r|n)).toString(16),a=0!==(n=o>>>24-r&16777215)||i!==this.length-1?c[6-s.length]+s+a:s+a;26<=(r+=2)&&(r-=26,i--)}for(0!==n&&(a=n.toString(16)+a);a.length%t!=0;)a="0"+a;return 0!==this.negative&&(a="-"+a),a}if(e===(0|e)&&2<=e&&e<=36){var u=d[e],l=p[e];for(a="",(h=this.clone()).negative=0;!h.isZero();){var h,f=h.modn(l).toString(e);a=(h=h.idivn(l)).isZero()?f+a:c[u-f.length]+f+a}for(this.isZero()&&(a="0"+a);a.length%t!=0;)a="0"+a;return 0!==this.negative&&(a="-"+a),a}y(!1,"Base should be between 2 and 36")},m.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:2<this.length&&y(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},m.prototype.toJSON=function(){return this.toString(16)},m.prototype.toBuffer=function(e,t){return y(void 0!==n),this.toArrayLike(n,e,t)},m.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},m.prototype.toArrayLike=function(e,t,r){var n=this.byteLength(),i=r||Math.max(1,n);y(n<=i,"byte array longer than desired length"),y(0<i,"Requested array length <= 0"),this.strip();var o,s,a="le"===t,u=new e(i),l=this.clone();if(a){for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),u[s]=o;for(;s<i;s++)u[s]=0}else{for(s=0;s<i-n;s++)u[s]=0;for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),u[i-s-1]=o}return u},Math.clz32?m.prototype._countBits=function(e){return 32-Math.clz32(e)}:m.prototype._countBits=function(e){var t=e,r=0;return 4096<=t&&(r+=13,t>>>=13),64<=t&&(r+=7,t>>>=7),8<=t&&(r+=4,t>>>=4),2<=t&&(r+=2,t>>>=2),r+t},m.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0==(8191&t)&&(r+=13,t>>>=13),0==(127&t)&&(r+=7,t>>>=7),0==(15&t)&&(r+=4,t>>>=4),0==(3&t)&&(r+=2,t>>>=2),0==(1&t)&&r++,r},m.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},m.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},m.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},m.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},m.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},m.prototype.isNeg=function(){return 0!==this.negative},m.prototype.neg=function(){return this.clone().ineg()},m.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},m.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},m.prototype.ior=function(e){return y(0==(this.negative|e.negative)),this.iuor(e)},m.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},m.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},m.prototype.iuand=function(e){for(var t=this.length>e.length?e:this,r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this.strip()},m.prototype.iand=function(e){return y(0==(this.negative|e.negative)),this.iuand(e)},m.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},m.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},m.prototype.iuxor=function(e){for(var t,r=this.length>e.length?(t=this,e):(t=e,this),n=0;n<r.length;n++)this.words[n]=t.words[n]^r.words[n];if(this!==t)for(;n<t.length;n++)this.words[n]=t.words[n];return this.length=t.length,this.strip()},m.prototype.ixor=function(e){return y(0==(this.negative|e.negative)),this.iuxor(e)},m.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},m.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},m.prototype.inotn=function(e){y("number"==typeof e&&0<=e);var t=0|Math.ceil(e/26),r=e%26;this._expand(t),0<r&&t--;for(var n=0;n<t;n++)this.words[n]=67108863&~this.words[n];return 0<r&&(this.words[n]=~this.words[n]&67108863>>26-r),this.strip()},m.prototype.notn=function(e){return this.clone().inotn(e)},m.prototype.setn=function(e,t){y("number"==typeof e&&0<=e);var r=e/26|0,n=e%26;return this._expand(1+r),this.words[r]=t?this.words[r]|1<<n:this.words[r]&~(1<<n),this.strip()},m.prototype.iadd=function(e){var t,r,n;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();n=this.length>e.length?(r=this,e):(r=e,this);for(var i=0,o=0;o<n.length;o++)t=(0|r.words[o])+(0|n.words[o])+i,this.words[o]=67108863&t,i=t>>>26;for(;0!==i&&o<r.length;o++)t=(0|r.words[o])+i,this.words[o]=67108863&t,i=t>>>26;if(this.length=r.length,0!==i)this.words[this.length]=i,this.length++;else if(r!==this)for(;o<r.length;o++)this.words[o]=r.words[o];return this},m.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},m.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r,n,i=this.cmp(e);if(0===i)return this.negative=0,this.length=1,this.words[0]=0,this;n=0<i?(r=this,e):(r=e,this);for(var o=0,s=0;s<n.length;s++)o=(t=(0|r.words[s])-(0|n.words[s])+o)>>26,this.words[s]=67108863&t;for(;0!==o&&s<r.length;s++)o=(t=(0|r.words[s])+o)>>26,this.words[s]=67108863&t;if(0===o&&s<r.length&&r!==this)for(;s<r.length;s++)this.words[s]=r.words[s];return this.length=Math.max(this.length,s),r!==this&&(this.negative=1),this.strip()},m.prototype.sub=function(e){return this.clone().isub(e)};var o=function(e,t,r){var n,i,o,s=e.words,a=t.words,u=r.words,l=0|s[0],h=8191&l,f=l>>>13,c=0|s[1],d=8191&c,p=c>>>13,v=0|s[2],y=8191&v,m=v>>>13,g=0|s[3],b=8191&g,w=g>>>13,_=0|s[4],M=8191&_,A=_>>>13,E=0|s[5],S=8191&E,k=E>>>13,N=0|s[6],x=8191&N,P=N>>>13,I=0|s[7],T=8191&I,R=I>>>13,O=0|s[8],C=8191&O,L=O>>>13,B=0|s[9],D=8191&B,U=B>>>13,F=0|a[0],j=8191&F,G=F>>>13,H=0|a[1],z=8191&H,V=H>>>13,K=0|a[2],q=8191&K,W=K>>>13,Z=0|a[3],J=8191&Z,X=Z>>>13,$=0|a[4],Q=8191&$,Y=$>>>13,ee=0|a[5],te=8191&ee,re=ee>>>13,ne=0|a[6],ie=8191&ne,oe=ne>>>13,se=0|a[7],ae=8191&se,ue=se>>>13,le=0|a[8],he=8191&le,fe=le>>>13,ce=0|a[9],de=8191&ce,pe=ce>>>13;r.negative=e.negative^t.negative,r.length=19;var ve=(0+Math.imul(h,j)|0)+((8191&(i=Math.imul(h,G)+Math.imul(f,j)|0))<<13)|0,ye=(Math.imul(f,G)+(i>>>13)|0)+(ve>>>26)|0;ve&=67108863,n=Math.imul(d,j),i=Math.imul(d,G)+Math.imul(p,j)|0,o=Math.imul(p,G);var me=(ye+(n+Math.imul(h,z)|0)|0)+((8191&(i=(i+Math.imul(h,V)|0)+Math.imul(f,z)|0))<<13)|0;ye=((o+Math.imul(f,V)|0)+(i>>>13)|0)+(me>>>26)|0,me&=67108863,n=Math.imul(y,j),i=Math.imul(y,G)+Math.imul(m,j)|0,o=Math.imul(m,G),n=n+Math.imul(d,z)|0,i=(i+Math.imul(d,V)|0)+Math.imul(p,z)|0,o=o+Math.imul(p,V)|0;var ge=(ye+(n+Math.imul(h,q)|0)|0)+((8191&(i=(i+Math.imul(h,W)|0)+Math.imul(f,q)|0))<<13)|0;ye=((o+Math.imul(f,W)|0)+(i>>>13)|0)+(ge>>>26)|0,ge&=67108863,n=Math.imul(b,j),i=Math.imul(b,G)+Math.imul(w,j)|0,o=Math.imul(w,G),n=n+Math.imul(y,z)|0,i=(i+Math.imul(y,V)|0)+Math.imul(m,z)|0,o=o+Math.imul(m,V)|0,n=n+Math.imul(d,q)|0,i=(i+Math.imul(d,W)|0)+Math.imul(p,q)|0,o=o+Math.imul(p,W)|0;var be=(ye+(n+Math.imul(h,J)|0)|0)+((8191&(i=(i+Math.imul(h,X)|0)+Math.imul(f,J)|0))<<13)|0;ye=((o+Math.imul(f,X)|0)+(i>>>13)|0)+(be>>>26)|0,be&=67108863,n=Math.imul(M,j),i=Math.imul(M,G)+Math.imul(A,j)|0,o=Math.imul(A,G),n=n+Math.imul(b,z)|0,i=(i+Math.imul(b,V)|0)+Math.imul(w,z)|0,o=o+Math.imul(w,V)|0,n=n+Math.imul(y,q)|0,i=(i+Math.imul(y,W)|0)+Math.imul(m,q)|0,o=o+Math.imul(m,W)|0,n=n+Math.imul(d,J)|0,i=(i+Math.imul(d,X)|0)+Math.imul(p,J)|0,o=o+Math.imul(p,X)|0;var we=(ye+(n+Math.imul(h,Q)|0)|0)+((8191&(i=(i+Math.imul(h,Y)|0)+Math.imul(f,Q)|0))<<13)|0;ye=((o+Math.imul(f,Y)|0)+(i>>>13)|0)+(we>>>26)|0,we&=67108863,n=Math.imul(S,j),i=Math.imul(S,G)+Math.imul(k,j)|0,o=Math.imul(k,G),n=n+Math.imul(M,z)|0,i=(i+Math.imul(M,V)|0)+Math.imul(A,z)|0,o=o+Math.imul(A,V)|0,n=n+Math.imul(b,q)|0,i=(i+Math.imul(b,W)|0)+Math.imul(w,q)|0,o=o+Math.imul(w,W)|0,n=n+Math.imul(y,J)|0,i=(i+Math.imul(y,X)|0)+Math.imul(m,J)|0,o=o+Math.imul(m,X)|0,n=n+Math.imul(d,Q)|0,i=(i+Math.imul(d,Y)|0)+Math.imul(p,Q)|0,o=o+Math.imul(p,Y)|0;var _e=(ye+(n+Math.imul(h,te)|0)|0)+((8191&(i=(i+Math.imul(h,re)|0)+Math.imul(f,te)|0))<<13)|0;ye=((o+Math.imul(f,re)|0)+(i>>>13)|0)+(_e>>>26)|0,_e&=67108863,n=Math.imul(x,j),i=Math.imul(x,G)+Math.imul(P,j)|0,o=Math.imul(P,G),n=n+Math.imul(S,z)|0,i=(i+Math.imul(S,V)|0)+Math.imul(k,z)|0,o=o+Math.imul(k,V)|0,n=n+Math.imul(M,q)|0,i=(i+Math.imul(M,W)|0)+Math.imul(A,q)|0,o=o+Math.imul(A,W)|0,n=n+Math.imul(b,J)|0,i=(i+Math.imul(b,X)|0)+Math.imul(w,J)|0,o=o+Math.imul(w,X)|0,n=n+Math.imul(y,Q)|0,i=(i+Math.imul(y,Y)|0)+Math.imul(m,Q)|0,o=o+Math.imul(m,Y)|0,n=n+Math.imul(d,te)|0,i=(i+Math.imul(d,re)|0)+Math.imul(p,te)|0,o=o+Math.imul(p,re)|0;var Me=(ye+(n+Math.imul(h,ie)|0)|0)+((8191&(i=(i+Math.imul(h,oe)|0)+Math.imul(f,ie)|0))<<13)|0;ye=((o+Math.imul(f,oe)|0)+(i>>>13)|0)+(Me>>>26)|0,Me&=67108863,n=Math.imul(T,j),i=Math.imul(T,G)+Math.imul(R,j)|0,o=Math.imul(R,G),n=n+Math.imul(x,z)|0,i=(i+Math.imul(x,V)|0)+Math.imul(P,z)|0,o=o+Math.imul(P,V)|0,n=n+Math.imul(S,q)|0,i=(i+Math.imul(S,W)|0)+Math.imul(k,q)|0,o=o+Math.imul(k,W)|0,n=n+Math.imul(M,J)|0,i=(i+Math.imul(M,X)|0)+Math.imul(A,J)|0,o=o+Math.imul(A,X)|0,n=n+Math.imul(b,Q)|0,i=(i+Math.imul(b,Y)|0)+Math.imul(w,Q)|0,o=o+Math.imul(w,Y)|0,n=n+Math.imul(y,te)|0,i=(i+Math.imul(y,re)|0)+Math.imul(m,te)|0,o=o+Math.imul(m,re)|0,n=n+Math.imul(d,ie)|0,i=(i+Math.imul(d,oe)|0)+Math.imul(p,ie)|0,o=o+Math.imul(p,oe)|0;var Ae=(ye+(n+Math.imul(h,ae)|0)|0)+((8191&(i=(i+Math.imul(h,ue)|0)+Math.imul(f,ae)|0))<<13)|0;ye=((o+Math.imul(f,ue)|0)+(i>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,n=Math.imul(C,j),i=Math.imul(C,G)+Math.imul(L,j)|0,o=Math.imul(L,G),n=n+Math.imul(T,z)|0,i=(i+Math.imul(T,V)|0)+Math.imul(R,z)|0,o=o+Math.imul(R,V)|0,n=n+Math.imul(x,q)|0,i=(i+Math.imul(x,W)|0)+Math.imul(P,q)|0,o=o+Math.imul(P,W)|0,n=n+Math.imul(S,J)|0,i=(i+Math.imul(S,X)|0)+Math.imul(k,J)|0,o=o+Math.imul(k,X)|0,n=n+Math.imul(M,Q)|0,i=(i+Math.imul(M,Y)|0)+Math.imul(A,Q)|0,o=o+Math.imul(A,Y)|0,n=n+Math.imul(b,te)|0,i=(i+Math.imul(b,re)|0)+Math.imul(w,te)|0,o=o+Math.imul(w,re)|0,n=n+Math.imul(y,ie)|0,i=(i+Math.imul(y,oe)|0)+Math.imul(m,ie)|0,o=o+Math.imul(m,oe)|0,n=n+Math.imul(d,ae)|0,i=(i+Math.imul(d,ue)|0)+Math.imul(p,ae)|0,o=o+Math.imul(p,ue)|0;var Ee=(ye+(n+Math.imul(h,he)|0)|0)+((8191&(i=(i+Math.imul(h,fe)|0)+Math.imul(f,he)|0))<<13)|0;ye=((o+Math.imul(f,fe)|0)+(i>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,n=Math.imul(D,j),i=Math.imul(D,G)+Math.imul(U,j)|0,o=Math.imul(U,G),n=n+Math.imul(C,z)|0,i=(i+Math.imul(C,V)|0)+Math.imul(L,z)|0,o=o+Math.imul(L,V)|0,n=n+Math.imul(T,q)|0,i=(i+Math.imul(T,W)|0)+Math.imul(R,q)|0,o=o+Math.imul(R,W)|0,n=n+Math.imul(x,J)|0,i=(i+Math.imul(x,X)|0)+Math.imul(P,J)|0,o=o+Math.imul(P,X)|0,n=n+Math.imul(S,Q)|0,i=(i+Math.imul(S,Y)|0)+Math.imul(k,Q)|0,o=o+Math.imul(k,Y)|0,n=n+Math.imul(M,te)|0,i=(i+Math.imul(M,re)|0)+Math.imul(A,te)|0,o=o+Math.imul(A,re)|0,n=n+Math.imul(b,ie)|0,i=(i+Math.imul(b,oe)|0)+Math.imul(w,ie)|0,o=o+Math.imul(w,oe)|0,n=n+Math.imul(y,ae)|0,i=(i+Math.imul(y,ue)|0)+Math.imul(m,ae)|0,o=o+Math.imul(m,ue)|0,n=n+Math.imul(d,he)|0,i=(i+Math.imul(d,fe)|0)+Math.imul(p,he)|0,o=o+Math.imul(p,fe)|0;var Se=(ye+(n+Math.imul(h,de)|0)|0)+((8191&(i=(i+Math.imul(h,pe)|0)+Math.imul(f,de)|0))<<13)|0;ye=((o+Math.imul(f,pe)|0)+(i>>>13)|0)+(Se>>>26)|0,Se&=67108863,n=Math.imul(D,z),i=Math.imul(D,V)+Math.imul(U,z)|0,o=Math.imul(U,V),n=n+Math.imul(C,q)|0,i=(i+Math.imul(C,W)|0)+Math.imul(L,q)|0,o=o+Math.imul(L,W)|0,n=n+Math.imul(T,J)|0,i=(i+Math.imul(T,X)|0)+Math.imul(R,J)|0,o=o+Math.imul(R,X)|0,n=n+Math.imul(x,Q)|0,i=(i+Math.imul(x,Y)|0)+Math.imul(P,Q)|0,o=o+Math.imul(P,Y)|0,n=n+Math.imul(S,te)|0,i=(i+Math.imul(S,re)|0)+Math.imul(k,te)|0,o=o+Math.imul(k,re)|0,n=n+Math.imul(M,ie)|0,i=(i+Math.imul(M,oe)|0)+Math.imul(A,ie)|0,o=o+Math.imul(A,oe)|0,n=n+Math.imul(b,ae)|0,i=(i+Math.imul(b,ue)|0)+Math.imul(w,ae)|0,o=o+Math.imul(w,ue)|0,n=n+Math.imul(y,he)|0,i=(i+Math.imul(y,fe)|0)+Math.imul(m,he)|0,o=o+Math.imul(m,fe)|0;var ke=(ye+(n+Math.imul(d,de)|0)|0)+((8191&(i=(i+Math.imul(d,pe)|0)+Math.imul(p,de)|0))<<13)|0;ye=((o+Math.imul(p,pe)|0)+(i>>>13)|0)+(ke>>>26)|0,ke&=67108863,n=Math.imul(D,q),i=Math.imul(D,W)+Math.imul(U,q)|0,o=Math.imul(U,W),n=n+Math.imul(C,J)|0,i=(i+Math.imul(C,X)|0)+Math.imul(L,J)|0,o=o+Math.imul(L,X)|0,n=n+Math.imul(T,Q)|0,i=(i+Math.imul(T,Y)|0)+Math.imul(R,Q)|0,o=o+Math.imul(R,Y)|0,n=n+Math.imul(x,te)|0,i=(i+Math.imul(x,re)|0)+Math.imul(P,te)|0,o=o+Math.imul(P,re)|0,n=n+Math.imul(S,ie)|0,i=(i+Math.imul(S,oe)|0)+Math.imul(k,ie)|0,o=o+Math.imul(k,oe)|0,n=n+Math.imul(M,ae)|0,i=(i+Math.imul(M,ue)|0)+Math.imul(A,ae)|0,o=o+Math.imul(A,ue)|0,n=n+Math.imul(b,he)|0,i=(i+Math.imul(b,fe)|0)+Math.imul(w,he)|0,o=o+Math.imul(w,fe)|0;var Ne=(ye+(n+Math.imul(y,de)|0)|0)+((8191&(i=(i+Math.imul(y,pe)|0)+Math.imul(m,de)|0))<<13)|0;ye=((o+Math.imul(m,pe)|0)+(i>>>13)|0)+(Ne>>>26)|0,Ne&=67108863,n=Math.imul(D,J),i=Math.imul(D,X)+Math.imul(U,J)|0,o=Math.imul(U,X),n=n+Math.imul(C,Q)|0,i=(i+Math.imul(C,Y)|0)+Math.imul(L,Q)|0,o=o+Math.imul(L,Y)|0,n=n+Math.imul(T,te)|0,i=(i+Math.imul(T,re)|0)+Math.imul(R,te)|0,o=o+Math.imul(R,re)|0,n=n+Math.imul(x,ie)|0,i=(i+Math.imul(x,oe)|0)+Math.imul(P,ie)|0,o=o+Math.imul(P,oe)|0,n=n+Math.imul(S,ae)|0,i=(i+Math.imul(S,ue)|0)+Math.imul(k,ae)|0,o=o+Math.imul(k,ue)|0,n=n+Math.imul(M,he)|0,i=(i+Math.imul(M,fe)|0)+Math.imul(A,he)|0,o=o+Math.imul(A,fe)|0;var xe=(ye+(n+Math.imul(b,de)|0)|0)+((8191&(i=(i+Math.imul(b,pe)|0)+Math.imul(w,de)|0))<<13)|0;ye=((o+Math.imul(w,pe)|0)+(i>>>13)|0)+(xe>>>26)|0,xe&=67108863,n=Math.imul(D,Q),i=Math.imul(D,Y)+Math.imul(U,Q)|0,o=Math.imul(U,Y),n=n+Math.imul(C,te)|0,i=(i+Math.imul(C,re)|0)+Math.imul(L,te)|0,o=o+Math.imul(L,re)|0,n=n+Math.imul(T,ie)|0,i=(i+Math.imul(T,oe)|0)+Math.imul(R,ie)|0,o=o+Math.imul(R,oe)|0,n=n+Math.imul(x,ae)|0,i=(i+Math.imul(x,ue)|0)+Math.imul(P,ae)|0,o=o+Math.imul(P,ue)|0,n=n+Math.imul(S,he)|0,i=(i+Math.imul(S,fe)|0)+Math.imul(k,he)|0,o=o+Math.imul(k,fe)|0;var Pe=(ye+(n+Math.imul(M,de)|0)|0)+((8191&(i=(i+Math.imul(M,pe)|0)+Math.imul(A,de)|0))<<13)|0;ye=((o+Math.imul(A,pe)|0)+(i>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,n=Math.imul(D,te),i=Math.imul(D,re)+Math.imul(U,te)|0,o=Math.imul(U,re),n=n+Math.imul(C,ie)|0,i=(i+Math.imul(C,oe)|0)+Math.imul(L,ie)|0,o=o+Math.imul(L,oe)|0,n=n+Math.imul(T,ae)|0,i=(i+Math.imul(T,ue)|0)+Math.imul(R,ae)|0,o=o+Math.imul(R,ue)|0,n=n+Math.imul(x,he)|0,i=(i+Math.imul(x,fe)|0)+Math.imul(P,he)|0,o=o+Math.imul(P,fe)|0;var Ie=(ye+(n+Math.imul(S,de)|0)|0)+((8191&(i=(i+Math.imul(S,pe)|0)+Math.imul(k,de)|0))<<13)|0;ye=((o+Math.imul(k,pe)|0)+(i>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,n=Math.imul(D,ie),i=Math.imul(D,oe)+Math.imul(U,ie)|0,o=Math.imul(U,oe),n=n+Math.imul(C,ae)|0,i=(i+Math.imul(C,ue)|0)+Math.imul(L,ae)|0,o=o+Math.imul(L,ue)|0,n=n+Math.imul(T,he)|0,i=(i+Math.imul(T,fe)|0)+Math.imul(R,he)|0,o=o+Math.imul(R,fe)|0;var Te=(ye+(n+Math.imul(x,de)|0)|0)+((8191&(i=(i+Math.imul(x,pe)|0)+Math.imul(P,de)|0))<<13)|0;ye=((o+Math.imul(P,pe)|0)+(i>>>13)|0)+(Te>>>26)|0,Te&=67108863,n=Math.imul(D,ae),i=Math.imul(D,ue)+Math.imul(U,ae)|0,o=Math.imul(U,ue),n=n+Math.imul(C,he)|0,i=(i+Math.imul(C,fe)|0)+Math.imul(L,he)|0,o=o+Math.imul(L,fe)|0;var Re=(ye+(n+Math.imul(T,de)|0)|0)+((8191&(i=(i+Math.imul(T,pe)|0)+Math.imul(R,de)|0))<<13)|0;ye=((o+Math.imul(R,pe)|0)+(i>>>13)|0)+(Re>>>26)|0,Re&=67108863,n=Math.imul(D,he),i=Math.imul(D,fe)+Math.imul(U,he)|0,o=Math.imul(U,fe);var Oe=(ye+(n+Math.imul(C,de)|0)|0)+((8191&(i=(i+Math.imul(C,pe)|0)+Math.imul(L,de)|0))<<13)|0;ye=((o+Math.imul(L,pe)|0)+(i>>>13)|0)+(Oe>>>26)|0,Oe&=67108863;var Ce=(ye+Math.imul(D,de)|0)+((8191&(i=Math.imul(D,pe)+Math.imul(U,de)|0))<<13)|0;return ye=(Math.imul(U,pe)+(i>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,u[0]=ve,u[1]=me,u[2]=ge,u[3]=be,u[4]=we,u[5]=_e,u[6]=Me,u[7]=Ae,u[8]=Ee,u[9]=Se,u[10]=ke,u[11]=Ne,u[12]=xe,u[13]=Pe,u[14]=Ie,u[15]=Te,u[16]=Re,u[17]=Oe,u[18]=Ce,0!=ye&&(u[19]=ye,r.length++),r};function a(e,t,r){return(new u).mulp(e,t,r)}function u(e,t){this.x=e,this.y=t}Math.imul||(o=i),m.prototype.mulTo=function(e,t){var r=this.length+e.length,n=(10===this.length&&10===e.length?o:r<63?i:r<1024?function(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var n=0,i=0,o=0;o<r.length-1;o++){for(var s=i,i=0,a=67108863&n,u=Math.min(o,t.length-1),l=Math.max(0,o-e.length+1);l<=u;l++){var h=o-l,f=(0|e.words[h])*(0|t.words[l]),c=67108863&f,a=67108863&(c=c+a|0);i+=(s=(s=s+(f/67108864|0)|0)+(c>>>26)|0)>>>26,s&=67108863}r.words[o]=a,n=s,s=i}return 0!==n?r.words[o]=n:r.length--,r.strip()}:a)(this,e,t);return n},u.prototype.makeRBT=function(e){for(var t=new Array(e),r=m.prototype._countBits(e)-1,n=0;n<e;n++)t[n]=this.revBin(n,r,e);return t},u.prototype.revBin=function(e,t,r){if(0===e||e===r-1)return e;for(var n=0,i=0;i<t;i++)n|=(1&e)<<t-i-1,e>>=1;return n},u.prototype.permute=function(e,t,r,n,i,o){for(var s=0;s<o;s++)n[s]=t[e[s]],i[s]=r[e[s]]},u.prototype.transform=function(e,t,r,n,i,o){this.permute(o,e,t,r,n,i);for(var s=1;s<i;s<<=1)for(var a=s<<1,u=Math.cos(2*Math.PI/a),l=Math.sin(2*Math.PI/a),h=0;h<i;h+=a)for(var f=u,c=l,d=0;d<s;d++){var p=r[h+d],v=n[h+d],y=f*(g=r[h+d+s])-c*(m=n[h+d+s]),m=f*m+c*g,g=y;r[h+d]=p+g,n[h+d]=v+m,r[h+d+s]=p-g,n[h+d+s]=v-m,d!==a&&(y=u*f-l*c,c=u*c+l*f,f=y)}},u.prototype.guessLen13b=function(e,t){for(var r=1&(i=1|Math.max(t,e)),n=0,i=i/2|0;i;i>>>=1)n++;return 1<<n+1+r},u.prototype.conjugate=function(e,t,r){if(!(r<=1))for(var n=0;n<r/2;n++){var i=e[n];e[n]=e[r-n-1],e[r-n-1]=i,i=t[n],t[n]=-t[r-n-1],t[r-n-1]=-i}},u.prototype.normalize13b=function(e,t){for(var r=0,n=0;n<t/2;n++){var i=8192*Math.round(e[2*n+1]/t)+Math.round(e[2*n]/t)+r;e[n]=67108863&i,r=i<67108864?0:i/67108864|0}return e},u.prototype.convert13b=function(e,t,r,n){for(var i=0,o=0;o<t;o++)i+=0|e[o],r[2*o]=8191&i,i>>>=13,r[2*o+1]=8191&i,i>>>=13;for(o=2*t;o<n;++o)r[o]=0;y(0===i),y(0==(-8192&i))},u.prototype.stub=function(e){for(var t=new Array(e),r=0;r<e;r++)t[r]=0;return t},u.prototype.mulp=function(e,t,r){var n=2*this.guessLen13b(e.length,t.length),i=this.makeRBT(n),o=this.stub(n),s=new Array(n),a=new Array(n),u=new Array(n),l=new Array(n),h=new Array(n),f=new Array(n),c=r.words;c.length=n,this.convert13b(e.words,e.length,s,n),this.convert13b(t.words,t.length,l,n),this.transform(s,o,a,u,n,i),this.transform(l,o,h,f,n,i);for(var d=0;d<n;d++){var p=a[d]*h[d]-u[d]*f[d];u[d]=a[d]*f[d]+u[d]*h[d],a[d]=p}return this.conjugate(a,u,n),this.transform(a,u,c,o,n,i),this.conjugate(c,o,n),this.normalize13b(c,n),r.negative=e.negative^t.negative,r.length=e.length+t.length,r.strip()},m.prototype.mul=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},m.prototype.mulf=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),a(this,e,t)},m.prototype.imul=function(e){return this.clone().mulTo(e,this)},m.prototype.imuln=function(e){y("number"==typeof e),y(e<67108864);for(var t=0,r=0;r<this.length;r++){var n=(0|this.words[r])*e,i=(67108863&n)+(67108863&t);t>>=26,t+=n/67108864|0,t+=i>>>26,this.words[r]=67108863&i}return 0!==t&&(this.words[r]=t,this.length++),this},m.prototype.muln=function(e){return this.clone().imuln(e)},m.prototype.sqr=function(){return this.mul(this)},m.prototype.isqr=function(){return this.imul(this.clone())},m.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),r=0;r<t.length;r++){var n=r/26|0,i=r%26;t[r]=(e.words[n]&1<<i)>>>i}return t}(e);if(0===t.length)return new m(1);for(var r=this,n=0;n<t.length&&0===t[n];n++,r=r.sqr());if(++n<t.length)for(var i=r.sqr();n<t.length;n++,i=i.sqr())0!==t[n]&&(r=r.mul(i));return r},m.prototype.iushln=function(e){y("number"==typeof e&&0<=e);var t=e%26,r=(e-t)/26,n=67108863>>>26-t<<26-t;if(0!=t){for(var i=0,o=0;o<this.length;o++){var s=this.words[o]&n,a=(0|this.words[o])-s<<t;this.words[o]=a|i,i=s>>>26-t}i&&(this.words[o]=i,this.length++)}if(0!=r){for(o=this.length-1;0<=o;o--)this.words[o+r]=this.words[o];for(o=0;o<r;o++)this.words[o]=0;this.length+=r}return this.strip()},m.prototype.ishln=function(e){return y(0===this.negative),this.iushln(e)},m.prototype.iushrn=function(e,t,r){var n;y("number"==typeof e&&0<=e),n=t?(t-t%26)/26:0;var i=e%26,o=Math.min((e-i)/26,this.length),s=67108863^67108863>>>i<<i,a=r;if(n-=o,n=Math.max(0,n),a){for(var u=0;u<o;u++)a.words[u]=this.words[u];a.length=o}if(0!==o)if(this.length>o)for(this.length-=o,u=0;u<this.length;u++)this.words[u]=this.words[u+o];else this.words[0]=0,this.length=1;for(var l=0,u=this.length-1;0<=u&&(0!==l||n<=u);u--){var h=0|this.words[u];this.words[u]=l<<26-i|h>>>i,l=h&s}return a&&0!==l&&(a.words[a.length++]=l),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},m.prototype.ishrn=function(e,t,r){return y(0===this.negative),this.iushrn(e,t,r)},m.prototype.shln=function(e){return this.clone().ishln(e)},m.prototype.ushln=function(e){return this.clone().iushln(e)},m.prototype.shrn=function(e){return this.clone().ishrn(e)},m.prototype.ushrn=function(e){return this.clone().iushrn(e)},m.prototype.testn=function(e){y("number"==typeof e&&0<=e);var t=e%26,r=(e-t)/26,n=1<<t;return!(this.length<=r)&&!!(this.words[r]&n)},m.prototype.imaskn=function(e){y("number"==typeof e&&0<=e);var t,r=e%26,n=(e-r)/26;return y(0===this.negative,"imaskn works only with positive numbers"),this.length<=n?this:(0!=r&&n++,this.length=Math.min(n,this.length),0!=r&&(t=67108863^67108863>>>r<<r,this.words[this.length-1]&=t),this.strip())},m.prototype.maskn=function(e){return this.clone().imaskn(e)},m.prototype.iaddn=function(e){return y("number"==typeof e),y(e<67108864),e<0?this.isubn(-e):0!==this.negative?(1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0):(this.negative=0,this.isubn(e),this.negative=1),this):this._iaddn(e)},m.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&67108864<=this.words[t];t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},m.prototype.isubn=function(e){if(y("number"==typeof e),y(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,--this.words[t+1];return this.strip()},m.prototype.addn=function(e){return this.clone().iaddn(e)},m.prototype.subn=function(e){return this.clone().isubn(e)},m.prototype.iabs=function(){return this.negative=0,this},m.prototype.abs=function(){return this.clone().iabs()},m.prototype._ishlnsubmul=function(e,t,r){var n,i=e.length+r;this._expand(i);for(var o=0,s=0;s<e.length;s++){n=(0|this.words[s+r])+o;var a=(0|e.words[s])*t,o=((n-=67108863&a)>>26)-(a/67108864|0);this.words[s+r]=67108863&n}for(;s<this.length-r;s++)o=(n=(0|this.words[s+r])+o)>>26,this.words[s+r]=67108863&n;if(0===o)return this.strip();for(y(-1===o),s=o=0;s<this.length;s++)o=(n=-(0|this.words[s])+o)>>26,this.words[s]=67108863&n;return this.negative=1,this.strip()},m.prototype._wordDiv=function(e,t){var r=this.length-e.length,n=this.clone(),i=e,o=0|i.words[i.length-1];0!=(r=26-this._countBits(o))&&(i=i.ushln(r),n.iushln(r),o=0|i.words[i.length-1]);var s,a=n.length-i.length;if("mod"!==t){(s=new m(null)).length=1+a,s.words=new Array(s.length);for(var u=0;u<s.length;u++)s.words[u]=0}var l=n.clone()._ishlnsubmul(i,1,a);0===l.negative&&(n=l,s&&(s.words[a]=1));for(var h=a-1;0<=h;h--){var f=67108864*(0|n.words[i.length+h])+(0|n.words[i.length+h-1]),f=Math.min(f/o|0,67108863);for(n._ishlnsubmul(i,f,h);0!==n.negative;)f--,n.negative=0,n._ishlnsubmul(i,1,h),n.isZero()||(n.negative^=1);s&&(s.words[h]=f)}return s&&s.strip(),n.strip(),"div"!==t&&0!=r&&n.iushrn(r),{div:s||null,mod:n}},m.prototype.divmod=function(e,t,r){return y(!e.isZero()),this.isZero()?{div:new m(0),mod:new m(0)}:0!==this.negative&&0===e.negative?(o=this.neg().divmod(e,t),"mod"!==t&&(n=o.div.neg()),"div"!==t&&(i=o.mod.neg(),r&&0!==i.negative&&i.iadd(e)),{div:n,mod:i}):0===this.negative&&0!==e.negative?(o=this.divmod(e.neg(),t),"mod"!==t&&(n=o.div.neg()),{div:n,mod:o.mod}):0!=(this.negative&e.negative)?(o=this.neg().divmod(e.neg(),t),"div"!==t&&(i=o.mod.neg(),r&&0!==i.negative&&i.isub(e)),{div:o.div,mod:i}):e.length>this.length||this.cmp(e)<0?{div:new m(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new m(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new m(this.modn(e.words[0]))}:this._wordDiv(e,t);var n,i,o},m.prototype.div=function(e){return this.divmod(e,"div",!1).div},m.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},m.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},m.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,n=e.ushrn(1),i=e.andln(1),o=r.cmp(n);return o<0||1===i&&0===o?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},m.prototype.modn=function(e){y(e<=67108863);for(var t=(1<<26)%e,r=0,n=this.length-1;0<=n;n--)r=(t*r+(0|this.words[n]))%e;return r},m.prototype.idivn=function(e){y(e<=67108863);for(var t=0,r=this.length-1;0<=r;r--){var n=(0|this.words[r])+67108864*t;this.words[r]=n/e|0,t=n%e}return this.strip()},m.prototype.divn=function(e){return this.clone().idivn(e)},m.prototype.egcd=function(e){y(0===e.negative),y(!e.isZero());for(var t=this,r=e.clone(),t=0!==t.negative?t.umod(e):t.clone(),n=new m(1),i=new m(0),o=new m(0),s=new m(1),a=0;t.isEven()&&r.isEven();)t.iushrn(1),r.iushrn(1),++a;for(var u=r.clone(),l=t.clone();!t.isZero();){for(var h=0,f=1;0==(t.words[0]&f)&&h<26;++h,f<<=1);if(0<h)for(t.iushrn(h);0<h--;)(n.isOdd()||i.isOdd())&&(n.iadd(u),i.isub(l)),n.iushrn(1),i.iushrn(1);for(var c=0,d=1;0==(r.words[0]&d)&&c<26;++c,d<<=1);if(0<c)for(r.iushrn(c);0<c--;)(o.isOdd()||s.isOdd())&&(o.iadd(u),s.isub(l)),o.iushrn(1),s.iushrn(1);0<=t.cmp(r)?(t.isub(r),n.isub(o),i.isub(s)):(r.isub(t),o.isub(n),s.isub(i))}return{a:o,b:s,gcd:r.iushln(a)}},m.prototype._invmp=function(e){y(0===e.negative),y(!e.isZero());for(var t,r=this,n=e.clone(),r=0!==r.negative?r.umod(e):r.clone(),i=new m(1),o=new m(0),s=n.clone();0<r.cmpn(1)&&0<n.cmpn(1);){for(var a=0,u=1;0==(r.words[0]&u)&&a<26;++a,u<<=1);if(0<a)for(r.iushrn(a);0<a--;)i.isOdd()&&i.iadd(s),i.iushrn(1);for(var l=0,h=1;0==(n.words[0]&h)&&l<26;++l,h<<=1);if(0<l)for(n.iushrn(l);0<l--;)o.isOdd()&&o.iadd(s),o.iushrn(1);0<=r.cmp(n)?(r.isub(n),i.isub(o)):(n.isub(r),o.isub(i))}return(t=0===r.cmpn(1)?i:o).cmpn(0)<0&&t.iadd(e),t},m.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0;for(var n=r.negative=0;t.isEven()&&r.isEven();n++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var i=t.cmp(r);if(i<0)var o=t,t=r,r=o;else if(0===i||0===r.cmpn(1))break;t.isub(r)}return r.iushln(n)},m.prototype.invm=function(e){return this.egcd(e).a.umod(e)},m.prototype.isEven=function(){return 0==(1&this.words[0])},m.prototype.isOdd=function(){return 1==(1&this.words[0])},m.prototype.andln=function(e){return this.words[0]&e},m.prototype.bincn=function(e){y("number"==typeof e);var t=e%26,r=(e-t)/26,n=1<<t;if(this.length<=r)return this._expand(1+r),this.words[r]|=n,this;for(var i=n,o=r;0!==i&&o<this.length;o++){var s=0|this.words[o],i=(s+=i)>>>26;s&=67108863,this.words[o]=s}return 0!==i&&(this.words[o]=i,this.length++),this},m.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},m.prototype.cmpn=function(e){var t,r,n=e<0;return 0===this.negative||n?0===this.negative&&n?1:(this.strip(),r=1<this.length?1:(n&&(e=-e),y(e<=67108863,"Number is too big"),(t=0|this.words[0])===e?0:t<e?-1:1),0!==this.negative?0|-r:r):-1},m.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},m.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,r=this.length-1;0<=r;r--){var n=0|this.words[r],i=0|e.words[r];if(n!=i){n<i?t=-1:i<n&&(t=1);break}}return t},m.prototype.gtn=function(e){return 1===this.cmpn(e)},m.prototype.gt=function(e){return 1===this.cmp(e)},m.prototype.gten=function(e){return 0<=this.cmpn(e)},m.prototype.gte=function(e){return 0<=this.cmp(e)},m.prototype.ltn=function(e){return-1===this.cmpn(e)},m.prototype.lt=function(e){return-1===this.cmp(e)},m.prototype.lten=function(e){return this.cmpn(e)<=0},m.prototype.lte=function(e){return this.cmp(e)<=0},m.prototype.eqn=function(e){return 0===this.cmpn(e)},m.prototype.eq=function(e){return 0===this.cmp(e)},m.red=function(e){return new _(e)},m.prototype.toRed=function(e){return y(!this.red,"Already a number in reduction context"),y(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},m.prototype.fromRed=function(){return y(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},m.prototype._forceRed=function(e){return this.red=e,this},m.prototype.forceRed=function(e){return y(!this.red,"Already a number in reduction context"),this._forceRed(e)},m.prototype.redAdd=function(e){return y(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},m.prototype.redIAdd=function(e){return y(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},m.prototype.redSub=function(e){return y(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},m.prototype.redISub=function(e){return y(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},m.prototype.redShl=function(e){return y(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},m.prototype.redMul=function(e){return y(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},m.prototype.redIMul=function(e){return y(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},m.prototype.redSqr=function(){return y(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},m.prototype.redISqr=function(){return y(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},m.prototype.redSqrt=function(){return y(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},m.prototype.redInvm=function(){return y(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},m.prototype.redNeg=function(){return y(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},m.prototype.redPow=function(e){return y(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var l={k256:null,p224:null,p192:null,p25519:null};function h(e,t){this.name=e,this.p=new m(t,16),this.n=this.p.bitLength(),this.k=new m(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function v(){h.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function g(){h.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function b(){h.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function w(){h.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function _(e){var t;"string"==typeof e?(t=m._prime(e),this.m=t.p,this.prime=t):(y(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null)}function M(e){_.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new m(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}h.prototype._tmp=function(){var e=new m(null);return e.words=new Array(Math.ceil(this.n/13)),e},h.prototype.ireduce=function(e){for(var t,r=e;this.split(r,this.tmp),(t=(r=(r=this.imulK(r)).iadd(this.tmp)).bitLength())>this.n;);var n=t<this.n?-1:r.ucmp(this.p);return 0===n?(r.words[0]=0,r.length=1):0<n?r.isub(this.p):void 0!==r.strip?r.strip():r._strip(),r},h.prototype.split=function(e,t){e.iushrn(this.n,0,t)},h.prototype.imulK=function(e){return e.imul(this.k)},r(v,h),v.prototype.split=function(e,t){for(var r=Math.min(e.length,9),n=0;n<r;n++)t.words[n]=e.words[n];if(t.length=r,e.length<=9)return e.words[0]=0,void(e.length=1);var i=e.words[9];for(t.words[t.length++]=4194303&i,n=10;n<e.length;n++){var o=0|e.words[n];e.words[n-10]=(4194303&o)<<4|i>>>22,i=o}i>>>=22,0===(e.words[n-10]=i)&&10<e.length?e.length-=10:e.length-=9},v.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var n=0|e.words[r];t+=977*n,e.words[r]=67108863&t,t=64*n+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},r(g,h),r(b,h),r(w,h),w.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var n=19*(0|e.words[r])+t,i=67108863&n;n>>>=26,e.words[r]=i,t=n}return 0!==t&&(e.words[e.length++]=t),e},m._prime=function(e){if(l[e])return l[e];var t;if("k256"===e)t=new v;else if("p224"===e)t=new g;else if("p192"===e)t=new b;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new w}return l[e]=t},_.prototype._verify1=function(e){y(0===e.negative,"red works only with positives"),y(e.red,"red works only with red numbers")},_.prototype._verify2=function(e,t){y(0==(e.negative|t.negative),"red works only with positives"),y(e.red&&e.red===t.red,"red works only with red numbers")},_.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):e.umod(this.m)._forceRed(this)},_.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},_.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return 0<=r.cmp(this.m)&&r.isub(this.m),r._forceRed(this)},_.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return 0<=r.cmp(this.m)&&r.isub(this.m),r},_.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},_.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},_.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},_.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},_.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},_.prototype.isqr=function(e){return this.imul(e,e.clone())},_.prototype.sqr=function(e){return this.mul(e,e)},_.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(y(t%2==1),3===t){var r=this.m.add(new m(1)).iushrn(2);return this.pow(e,r)}for(var n=this.m.subn(1),i=0;!n.isZero()&&0===n.andln(1);)i++,n.iushrn(1);y(!n.isZero());for(var o=new m(1).toRed(this),s=o.redNeg(),a=this.m.subn(1).iushrn(1),u=new m(2*(u=this.m.bitLength())*u).toRed(this);0!==this.pow(u,a).cmp(s);)u.redIAdd(s);for(var l=this.pow(u,n),h=this.pow(e,n.addn(1).iushrn(1)),f=this.pow(e,n),c=i;0!==f.cmp(o);){for(var d=f,p=0;0!==d.cmp(o);p++)d=d.redSqr();y(p<c);var v=this.pow(l,new m(1).iushln(c-p-1)),h=h.redMul(v),l=v.redSqr(),f=f.redMul(l),c=p}return h},_.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},_.prototype.pow=function(e,t){if(t.isZero())return new m(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=new Array(16);r[0]=new m(1).toRed(this),r[1]=e;for(var n=2;n<r.length;n++)r[n]=this.mul(r[n-1],e);var i=r[0],o=0,s=0,a=t.bitLength()%26;for(0===a&&(a=26),n=t.length-1;0<=n;n--){for(var u=t.words[n],l=a-1;0<=l;l--){var h=u>>l&1;i!==r[0]&&(i=this.sqr(i)),0!=h||0!==o?(o<<=1,o|=h,(4===++s||0===n&&0===l)&&(i=this.mul(i,r[o]),o=s=0)):s=0}a=26}return i},_.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},_.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},m.mont=function(e){return new M(e)},r(M,_),M.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},M.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},M.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=r.isub(n).iushrn(this.shift),o=i;return 0<=i.cmp(this.m)?o=i.isub(this.m):i.cmpn(0)<0&&(o=i.iadd(this.m)),o._forceRed(this)},M.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new m(0)._forceRed(this);var r=e.mul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=r.isub(n).iushrn(this.shift),o=i;return 0<=i.cmp(this.m)?o=i.isub(this.m):i.cmpn(0)<0&&(o=i.iadd(this.m)),o._forceRed(this)},M.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(void 0===e||e,this)},{buffer:11}],10:[function(e,t,r){(function(r){t.exports=function(e){var t=new Uint8Array(e);return(r.crypto||r.msCrypto).getRandomValues(t),t}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],11:[function(e,t,r){},{}],12:[function(e,t,r){"use strict";var n=r;n.version=e("../package.json").version,n.utils=e("./elliptic/utils"),n.rand=e("brorand"),n.curve=e("./elliptic/curve"),n.curves=e("./elliptic/curves"),n.ec=e("./elliptic/ec"),n.eddsa=e("./elliptic/eddsa")},{"../package.json":25,"./elliptic/curve":15,"./elliptic/curves":18,"./elliptic/ec":19,"./elliptic/eddsa":22,"./elliptic/utils":24,brorand:10}],13:[function(e,t,r){"use strict";var n=e("bn.js"),i=e("../utils"),S=i.getNAF,k=i.getJSF,f=i.assert;function o(e,t){this.type=e,this.p=new n(t.p,16),this.red=t.prime?n.red(t.prime):n.mont(this.p),this.zero=new n(0).toRed(this.red),this.one=new n(1).toRed(this.red),this.two=new n(2).toRed(this.red),this.n=t.n&&new n(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4),this._bitLength=this.n?this.n.bitLength():0;var r=this.n&&this.p.div(this.n);!r||0<r.cmpn(100)?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function s(e,t){this.curve=e,this.type=t,this.precomputed=null}(t.exports=o).prototype.point=function(){throw new Error("Not implemented")},o.prototype.validate=function(){throw new Error("Not implemented")},o.prototype._fixedNafMul=function(e,t){f(e.precomputed);var r=e._getDoubles(),n=S(t,1,this._bitLength),i=(1<<r.step+1)-(r.step%2==0?2:1);i/=3;for(var o=[],s=0;s<n.length;s+=r.step){for(var a=0,t=s+r.step-1;s<=t;t--)a=(a<<1)+n[t];o.push(a)}for(var u=this.jpoint(null,null,null),l=this.jpoint(null,null,null),h=i;0<h;h--){for(s=0;s<o.length;s++){(a=o[s])===h?l=l.mixedAdd(r.points[s]):a===-h&&(l=l.mixedAdd(r.points[s].neg()))}u=u.add(l)}return u.toP()},o.prototype._wnafMul=function(e,t){for(var r=e._getNAFPoints(4),n=r.wnd,i=r.points,o=S(t,n,this._bitLength),s=this.jpoint(null,null,null),a=o.length-1;0<=a;a--){for(t=0;0<=a&&0===o[a];a--)t++;if(0<=a&&t++,s=s.dblp(t),a<0)break;var u=o[a];f(0!==u),s="affine"===e.type?0<u?s.mixedAdd(i[u-1>>1]):s.mixedAdd(i[-u-1>>1].neg()):0<u?s.add(i[u-1>>1]):s.add(i[-u-1>>1].neg())}return"affine"===e.type?s.toP():s},o.prototype._wnafMulAdd=function(e,t,r,n,i){for(var o=this._wnafT1,s=this._wnafT2,a=this._wnafT3,u=0,l=0;l<n;l++){var h=(A=t[l])._getNAFPoints(e);o[l]=h.wnd,s[l]=h.points}for(l=n-1;1<=l;l-=2){var f=l-1,c=l;if(1===o[f]&&1===o[c]){var d=[t[f],null,null,t[c]];0===t[f].y.cmp(t[c].y)?(d[1]=t[f].add(t[c]),d[2]=t[f].toJ().mixedAdd(t[c].neg())):0===t[f].y.cmp(t[c].y.redNeg())?(d[1]=t[f].toJ().mixedAdd(t[c]),d[2]=t[f].add(t[c].neg())):(d[1]=t[f].toJ().mixedAdd(t[c]),d[2]=t[f].toJ().mixedAdd(t[c].neg()));var p=[-3,-1,-5,-7,0,7,5,1,3],v=k(r[f],r[c]),u=Math.max(v[0].length,u);a[f]=new Array(u),a[c]=new Array(u);for(var y=0;y<u;y++){var m=0|v[0][y],g=0|v[1][y];a[f][y]=p[3*(1+m)+(1+g)],a[c][y]=0,s[f]=d}}else a[f]=S(r[f],o[f],this._bitLength),a[c]=S(r[c],o[c],this._bitLength),u=Math.max(a[f].length,u),u=Math.max(a[c].length,u)}for(var b=this.jpoint(null,null,null),w=this._wnafT4,l=u;0<=l;l--){for(var _=0;0<=l;){for(var M=!0,y=0;y<n;y++)w[y]=0|a[y][l],0!==w[y]&&(M=!1);if(!M)break;_++,l--}if(0<=l&&_++,b=b.dblp(_),l<0)break;for(y=0;y<n;y++){var A,E=w[y];0!==E&&(0<E?A=s[y][E-1>>1]:E<0&&(A=s[y][-E-1>>1].neg()),b="affine"===A.type?b.mixedAdd(A):b.add(A))}}for(l=0;l<n;l++)s[l]=null;return i?b:b.toP()},(o.BasePoint=s).prototype.eq=function(){throw new Error("Not implemented")},s.prototype.validate=function(){return this.curve.validate(this)},o.prototype.decodePoint=function(e,t){e=i.toArray(e,t);var r=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*r)return 6===e[0]?f(e[e.length-1]%2==0):7===e[0]&&f(e[e.length-1]%2==1),this.point(e.slice(1,1+r),e.slice(1+r,1+2*r));if((2===e[0]||3===e[0])&&e.length-1===r)return this.pointFromX(e.slice(1,1+r),3===e[0]);throw new Error("Unknown point format")},s.prototype.encodeCompressed=function(e){return this.encode(e,!0)},s.prototype._encode=function(e){var t=this.curve.p.byteLength(),r=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(r):[4].concat(r,this.getY().toArray("be",t))},s.prototype.encode=function(e,t){return i.encode(this._encode(t),e)},s.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},s.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},s.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var r=[this],n=this,i=0;i<t;i+=e){for(var o=0;o<e;o++)n=n.dbl();r.push(n)}return{step:e,points:r}},s.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],r=(1<<e)-1,n=1==r?null:this.dbl(),i=1;i<r;i++)t[i]=t[i-1].add(n);return{wnd:e,points:t}},s.prototype._getBeta=function(){return null},s.prototype.dblp=function(e){for(var t=this,r=0;r<e;r++)t=t.dbl();return t}},{"../utils":24,"bn.js":9}],14:[function(e,t,r){t.exports={}},{}],15:[function(e,t,r){"use strict";var n=r;n.base=e("./base"),n.short=e("./short"),n.mont=e("./mont"),n.edwards=e("./edwards")},{"./base":13,"./edwards":14,"./mont":16,"./short":17}],16:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],17:[function(e,t,r){"use strict";var n=e("../utils"),_=e("bn.js"),i=e("inherits"),o=e("./base"),s=n.assert;function a(e){o.call(this,"short",e),this.a=new _(e.a,16).toRed(this.red),this.b=new _(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function u(e,t,r,n){o.BasePoint.call(this,e,"affine"),null===t&&null===r?(this.x=null,this.y=null,this.inf=!0):(this.x=new _(t,16),this.y=new _(r,16),n&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function l(e,t,r,n){o.BasePoint.call(this,e,"jacobian"),null===t&&null===r&&null===n?(this.x=this.curve.one,this.y=this.curve.one,this.z=new _(0)):(this.x=new _(t,16),this.y=new _(r,16),this.z=new _(n,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}i(a,o),(t.exports=a).prototype._getEndomorphism=function(e){var t,r,n,i;if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3))return n=e.beta?new _(e.beta,16).toRed(this.red):(n=(r=this._getEndoRoots(this.p))[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red),e.lambda?t=new _(e.lambda,16):(i=this._getEndoRoots(this.n),0===this.g.mul(i[0]).x.cmp(this.g.x.redMul(n))?t=i[0]:(t=i[1],s(0===this.g.mul(t).x.cmp(this.g.x.redMul(n))))),{beta:n,lambda:t,basis:e.basis?e.basis.map(function(e){return{a:new _(e.a,16),b:new _(e.b,16)}}):this._getEndoBasis(t)}},a.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:_.mont(e),r=new _(2).toRed(t).redInvm(),n=r.redNeg(),i=new _(3).toRed(t).redNeg().redSqrt().redMul(r);return[n.redAdd(i).fromRed(),n.redSub(i).fromRed()]},a.prototype._getEndoBasis=function(e){for(var t,r,n,i,o,s,a,u=this.n.ushrn(Math.floor(this.n.bitLength()/2)),l=e,h=this.n.clone(),f=new _(1),c=new _(0),d=new _(0),p=new _(1),v=0;0!==l.cmpn(0);){var y=h.div(l),m=h.sub(y.mul(l)),g=d.sub(y.mul(f)),b=p.sub(y.mul(c));if(!n&&m.cmp(u)<0)t=a.neg(),r=f,n=m.neg(),i=g;else if(n&&2==++v)break;h=l,l=a=m,d=f,f=g,p=c,c=b}o=m.neg(),s=g;var w=n.sqr().add(i.sqr());return 0<=o.sqr().add(s.sqr()).cmp(w)&&(o=t,s=r),n.negative&&(n=n.neg(),i=i.neg()),o.negative&&(o=o.neg(),s=s.neg()),[{a:n,b:i},{a:o,b:s}]},a.prototype._endoSplit=function(e){var t=this.endo.basis,r=t[0],n=t[1],i=n.b.mul(e).divRound(this.n),o=r.b.neg().mul(e).divRound(this.n),s=i.mul(r.a),a=o.mul(n.a),u=i.mul(r.b),l=o.mul(n.b);return{k1:e.sub(s).sub(a),k2:u.add(l).neg()}},a.prototype.pointFromX=function(e,t){(e=new _(e,16)).red||(e=e.toRed(this.red));var r=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),n=r.redSqrt();if(0!==n.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");var i=n.fromRed().isOdd();return(t&&!i||!t&&i)&&(n=n.redNeg()),this.point(e,n)},a.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,r=e.y,n=this.a.redMul(t),i=t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);return 0===r.redSqr().redISub(i).cmpn(0)},a.prototype._endoWnafMulAdd=function(e,t,r){for(var n=this._endoWnafT1,i=this._endoWnafT2,o=0;o<e.length;o++){var s=this._endoSplit(t[o]),a=e[o],u=a._getBeta();s.k1.negative&&(s.k1.ineg(),a=a.neg(!0)),s.k2.negative&&(s.k2.ineg(),u=u.neg(!0)),n[2*o]=a,n[2*o+1]=u,i[2*o]=s.k1,i[2*o+1]=s.k2}for(var l=this._wnafMulAdd(1,n,i,2*o,r),h=0;h<2*o;h++)n[h]=null,i[h]=null;return l},i(u,o.BasePoint),a.prototype.point=function(e,t,r){return new u(this,e,t,r)},a.prototype.pointFromJSON=function(e,t){return u.fromJSON(this,e,t)},u.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t,r,n=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);return e&&(t=this.curve,r=function(e){return t.point(e.x.redMul(t.endo.beta),e.y)},(e.beta=n).precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(r)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(r)}}),n}},u.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},u.fromJSON=function(t,e,r){"string"==typeof e&&(e=JSON.parse(e));var n=t.point(e[0],e[1],r);if(!e[2])return n;function i(e){return t.point(e[0],e[1],r)}var o=e[2];return n.precomputed={beta:null,doubles:o.doubles&&{step:o.doubles.step,points:[n].concat(o.doubles.points.map(i))},naf:o.naf&&{wnd:o.naf.wnd,points:[n].concat(o.naf.points.map(i))}},n},u.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},u.prototype.isInfinity=function(){return this.inf},u.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var r=t.redSqr().redISub(this.x).redISub(e.x),n=t.redMul(this.x.redSub(r)).redISub(this.y);return this.curve.point(r,n)},u.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,r=this.x.redSqr(),n=e.redInvm(),i=r.redAdd(r).redIAdd(r).redIAdd(t).redMul(n),o=i.redSqr().redISub(this.x.redAdd(this.x)),s=i.redMul(this.x.redSub(o)).redISub(this.y);return this.curve.point(o,s)},u.prototype.getX=function(){return this.x.fromRed()},u.prototype.getY=function(){return this.y.fromRed()},u.prototype.mul=function(e){return e=new _(e,16),this.isInfinity()?this:this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},u.prototype.mulAdd=function(e,t,r){var n=[this,t],i=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(n,i):this.curve._wnafMulAdd(1,n,i,2)},u.prototype.jmulAdd=function(e,t,r){var n=[this,t],i=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(n,i,!0):this.curve._wnafMulAdd(1,n,i,2,!0)},u.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},u.prototype.neg=function(e){if(this.inf)return this;var t,r,n=this.curve.point(this.x,this.y.redNeg());return e&&this.precomputed&&(t=this.precomputed,r=function(e){return e.neg()},n.precomputed={naf:t.naf&&{wnd:t.naf.wnd,points:t.naf.points.map(r)},doubles:t.doubles&&{step:t.doubles.step,points:t.doubles.points.map(r)}}),n},u.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},i(l,o.BasePoint),a.prototype.jpoint=function(e,t,r){return new l(this,e,t,r)},l.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),r=this.x.redMul(t),n=this.y.redMul(t).redMul(e);return this.curve.point(r,n)},l.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},l.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),r=this.z.redSqr(),n=this.x.redMul(t),i=e.x.redMul(r),o=this.y.redMul(t.redMul(e.z)),s=e.y.redMul(r.redMul(this.z)),a=n.redSub(i),u=o.redSub(s);if(0===a.cmpn(0))return 0!==u.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var l=a.redSqr(),h=l.redMul(a),f=n.redMul(l),c=u.redSqr().redIAdd(h).redISub(f).redISub(f),d=u.redMul(f.redISub(c)).redISub(o.redMul(h)),p=this.z.redMul(e.z).redMul(a);return this.curve.jpoint(c,d,p)},l.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),r=this.x,n=e.x.redMul(t),i=this.y,o=e.y.redMul(t).redMul(this.z),s=r.redSub(n),a=i.redSub(o);if(0===s.cmpn(0))return 0!==a.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var u=s.redSqr(),l=u.redMul(s),h=r.redMul(u),f=a.redSqr().redIAdd(l).redISub(h).redISub(h),c=a.redMul(h.redISub(f)).redISub(i.redMul(l)),d=this.z.redMul(s);return this.curve.jpoint(f,c,d)},l.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,r=0;r<e;r++)t=t.dbl();return t}for(var n=this.curve.a,i=this.curve.tinv,o=this.x,s=this.y,a=this.z,u=a.redSqr().redSqr(),l=s.redAdd(s),r=0;r<e;r++){var h=o.redSqr(),f=l.redSqr(),c=f.redSqr(),d=h.redAdd(h).redIAdd(h).redIAdd(n.redMul(u)),p=o.redMul(f),v=d.redSqr().redISub(p.redAdd(p)),y=p.redISub(v),m=(m=d.redMul(y)).redIAdd(m).redISub(c),g=l.redMul(a);r+1<e&&(u=u.redMul(c)),o=v,a=g,l=m}return this.curve.jpoint(o,l.redMul(i),a)},l.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},l.prototype._zeroDbl=function(){var e,t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y=this.zOne?(r=this.x.redSqr(),i=(n=this.y.redSqr()).redSqr(),o=(o=this.x.redAdd(n).redSqr().redISub(r).redISub(i)).redIAdd(o),a=(s=r.redAdd(r).redIAdd(r)).redSqr().redISub(o).redISub(o),u=(u=(u=i.redIAdd(i)).redIAdd(u)).redIAdd(u),e=a,t=s.redMul(o.redISub(a)).redISub(u),this.y.redAdd(this.y)):(l=this.x.redSqr(),f=(h=this.y.redSqr()).redSqr(),c=(c=this.x.redAdd(h).redSqr().redISub(l).redISub(f)).redIAdd(c),p=(d=l.redAdd(l).redIAdd(l)).redSqr(),v=(v=(v=f.redIAdd(f)).redIAdd(v)).redIAdd(v),e=p.redISub(c).redISub(c),t=d.redMul(c.redISub(e)).redISub(v),(y=this.y.redMul(this.z)).redIAdd(y));return this.curve.jpoint(e,t,y)},l.prototype._threeDbl=function(){var e,t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y;return this.zOne?(r=this.x.redSqr(),i=(n=this.y.redSqr()).redSqr(),o=(o=this.x.redAdd(n).redSqr().redISub(r).redISub(i)).redIAdd(o),u=a=(s=r.redAdd(r).redIAdd(r).redIAdd(this.curve.a)).redSqr().redISub(o).redISub(o),l=(l=(l=i.redIAdd(i)).redIAdd(l)).redIAdd(l),e=s.redMul(o.redISub(a)).redISub(l),t=this.y.redAdd(this.y)):(h=this.z.redSqr(),f=this.y.redSqr(),c=this.x.redMul(f),d=(d=this.x.redSub(h).redMul(this.x.redAdd(h))).redAdd(d).redIAdd(d),v=(p=(p=c.redIAdd(c)).redIAdd(p)).redAdd(p),u=d.redSqr().redISub(v),t=this.y.redAdd(this.z).redSqr().redISub(f).redISub(h),y=(y=(y=(y=f.redSqr()).redIAdd(y)).redIAdd(y)).redIAdd(y),e=d.redMul(p.redISub(u)).redISub(y)),this.curve.jpoint(u,e,t)},l.prototype._dbl=function(){var e=this.curve.a,t=this.x,r=this.y,n=this.z,i=n.redSqr().redSqr(),o=t.redSqr(),s=r.redSqr(),a=o.redAdd(o).redIAdd(o).redIAdd(e.redMul(i)),u=t.redAdd(t),l=(u=u.redIAdd(u)).redMul(s),h=a.redSqr().redISub(l.redAdd(l)),f=l.redISub(h),c=s.redSqr();c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var d=a.redMul(f).redISub(c),p=r.redAdd(r).redMul(n);return this.curve.jpoint(h,d,p)},l.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr(),n=t.redSqr(),i=e.redAdd(e).redIAdd(e),o=i.redSqr(),s=this.x.redAdd(t).redSqr().redISub(e).redISub(n),a=(s=(s=(s=s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(o)).redSqr(),u=n.redIAdd(n);u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var l=i.redIAdd(s).redSqr().redISub(o).redISub(a).redISub(u),h=t.redMul(l);h=(h=h.redIAdd(h)).redIAdd(h);var f=this.x.redMul(a).redISub(h);f=(f=f.redIAdd(f)).redIAdd(f);var c=this.y.redMul(l.redMul(u.redISub(l)).redISub(s.redMul(a)));c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var d=this.z.redAdd(s).redSqr().redISub(r).redISub(a);return this.curve.jpoint(f,c,d)},l.prototype.mul=function(e,t){return e=new _(e,t),this.curve._wnafMul(this,e)},l.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),r=e.z.redSqr();if(0!==this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0))return!1;var n=t.redMul(this.z),i=r.redMul(e.z);return 0===this.y.redMul(i).redISub(e.y.redMul(n)).cmpn(0)},l.prototype.eqXToP=function(e){var t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(r))return!0;for(var n=e.clone(),i=this.curve.redN.redMul(t);;){if(n.iadd(this.curve.n),0<=n.cmp(this.curve.p))return!1;if(r.redIAdd(i),0===this.x.cmp(r))return!0}},l.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},l.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../utils":24,"./base":13,"bn.js":9,inherits:39}],18:[function(e,t,r){"use strict";var n,i=r,o=e("hash.js"),s=e("./curve"),a=e("./utils").assert;function u(e){"short"===e.type?this.curve=new s.short(e):"edwards"===e.type?this.curve=new s.edwards(e):this.curve=new s.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,a(this.g.validate(),"Invalid curve"),a(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function l(t,r){Object.defineProperty(i,t,{configurable:!0,enumerable:!0,get:function(){var e=new u(r);return Object.defineProperty(i,t,{configurable:!0,enumerable:!0,value:e}),e}})}i.PresetCurve=u,l("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:o.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),l("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:o.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),l("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:o.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),l("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:o.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),l("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:o.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),l("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["9"]}),l("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{n=e("./precomputed/secp256k1")}catch(e){n=void 0}l("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:o.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",n]})},{"./curve":15,"./precomputed/secp256k1":23,"./utils":24,"hash.js":26}],19:[function(e,t,r){"use strict";var y=e("bn.js"),m=e("hmac-drbg"),n=e("../utils"),i=e("../curves"),o=e("brorand"),d=n.assert,s=e("./key"),g=e("./signature");function a(e){if(!(this instanceof a))return new a(e);"string"==typeof e&&(d(i.hasOwnProperty(e),"Unknown curve "+e),e=i[e]),e instanceof i.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}(t.exports=a).prototype.keyPair=function(e){return new s(this,e)},a.prototype.keyFromPrivate=function(e,t){return s.fromPrivate(this,e,t)},a.prototype.keyFromPublic=function(e,t){return s.fromPublic(this,e,t)},a.prototype.genKeyPair=function(e){e=e||{};for(var t=new m({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||o(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),r=this.n.byteLength(),n=this.n.sub(new y(2));;){var i=new y(t.generate(r));if(!(0<i.cmp(n)))return i.iaddn(1),this.keyFromPrivate(i)}},a.prototype._truncateToN=function(e,t){var r=8*e.byteLength()-this.n.bitLength();return 0<r&&(e=e.ushrn(r)),!t&&0<=e.cmp(this.n)?e.sub(this.n):e},a.prototype.sign=function(e,t,r,n){"object"==typeof r&&(n=r,r=null),n=n||{},t=this.keyFromPrivate(t,r),e=this._truncateToN(new y(e,16));for(var i=this.n.byteLength(),o=t.getPrivate().toArray("be",i),s=e.toArray("be",i),a=new m({hash:this.hash,entropy:o,nonce:s,pers:n.pers,persEnc:n.persEnc||"utf8"}),u=this.n.sub(new y(1)),l=0;;l++){var h=n.k?n.k(l):new y(a.generate(this.n.byteLength()));if(!((h=this._truncateToN(h,!0)).cmpn(1)<=0||0<=h.cmp(u))){var f=this.g.mul(h);if(!f.isInfinity()){var c=f.getX(),d=c.umod(this.n);if(0!==d.cmpn(0)){var p=h.invm(this.n).mul(d.mul(t.getPrivate()).iadd(e));if(0!==(p=p.umod(this.n)).cmpn(0)){var v=(f.getY().isOdd()?1:0)|(0!==c.cmp(d)?2:0);return n.canonical&&0<p.cmp(this.nh)&&(p=this.n.sub(p),v^=1),new g({r:d,s:p,recoveryParam:v})}}}}}},a.prototype.verify=function(e,t,r,n){e=this._truncateToN(new y(e,16)),r=this.keyFromPublic(r,n);var i=(t=new g(t,"hex")).r,o=t.s;if(i.cmpn(1)<0||0<=i.cmp(this.n))return!1;if(o.cmpn(1)<0||0<=o.cmp(this.n))return!1;var s,a=o.invm(this.n),u=a.mul(e).umod(this.n),l=a.mul(i).umod(this.n);return this.curve._maxwellTrick?!(s=this.g.jmulAdd(u,r.getPublic(),l)).isInfinity()&&s.eqXToP(i):!(s=this.g.mulAdd(u,r.getPublic(),l)).isInfinity()&&0===s.getX().umod(this.n).cmp(i)},a.prototype.recoverPubKey=function(e,t,r,n){d((3&r)===r,"The recovery param is more than two bits"),t=new g(t,n);var i=this.n,o=new y(e),s=t.r,a=t.s,u=1&r,l=r>>1;if(0<=s.cmp(this.curve.p.umod(this.curve.n))&&l)throw new Error("Unable to find sencond key candinate");s=l?this.curve.pointFromX(s.add(this.curve.n),u):this.curve.pointFromX(s,u);var h=t.r.invm(i),f=i.sub(o).mul(h).umod(i),c=a.mul(h).umod(i);return this.g.mulAdd(f,s,c)},a.prototype.getKeyRecoveryParam=function(e,t,r,n){if(null!==(t=new g(t,n)).recoveryParam)return t.recoveryParam;for(var i,o=0;o<4;o++){try{i=this.recoverPubKey(e,t,o)}catch(e){continue}if(i.eq(r))return o}throw new Error("Unable to find valid recovery factor")}},{"../curves":18,"../utils":24,"./key":20,"./signature":21,"bn.js":9,brorand:10,"hmac-drbg":38}],20:[function(e,t,r){"use strict";var n=e("bn.js"),i=e("../utils").assert;function o(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}(t.exports=o).fromPublic=function(e,t,r){return t instanceof o?t:new o(e,{pub:t,pubEnc:r})},o.fromPrivate=function(e,t,r){return t instanceof o?t:new o(e,{priv:t,privEnc:r})},o.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},o.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},o.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},o.prototype._importPrivate=function(e,t){this.priv=new n(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},o.prototype._importPublic=function(e,t){if(e.x||e.y)return"mont"===this.ec.curve.type?i(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||i(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t)},o.prototype.derive=function(e){return e.mul(this.priv).getX()},o.prototype.sign=function(e,t,r){return this.ec.sign(e,this,t,r)},o.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},o.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"../utils":24,"bn.js":9}],21:[function(e,t,r){"use strict";var u=e("bn.js"),l=e("../utils"),n=l.assert;function i(e,t){if(e instanceof i)return e;this._importDER(e,t)||(n(e.r&&e.s,"Signature without r or s"),this.r=new u(e.r,16),this.s=new u(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam)}function h(){this.place=0}function f(e,t){var r=e[t.place++];if(!(128&r))return r;var n=15&r;if(0==n||4<n)return!1;for(var i=0,o=0,s=t.place;o<n;o++,s++)i<<=8,i|=e[s],i>>>=0;return!(i<=127)&&(t.place=s,i)}function s(e){for(var t=0,r=e.length-1;!e[t]&&!(128&e[t+1])&&t<r;)t++;return 0===t?e:e.slice(t)}function a(e,t){if(t<128)e.push(t);else{var r=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|r);--r;)e.push(t>>>(r<<3)&255);e.push(t)}}(t.exports=i).prototype._importDER=function(e,t){e=l.toArray(e,t);var r=new h;if(48!==e[r.place++])return!1;var n=f(e,r);if(!1===n)return!1;if(n+r.place!==e.length)return!1;if(2!==e[r.place++])return!1;var i=f(e,r);if(!1===i)return!1;var o=e.slice(r.place,i+r.place);if(r.place+=i,2!==e[r.place++])return!1;var s=f(e,r);if(!1===s)return!1;if(e.length!==s+r.place)return!1;var a=e.slice(r.place,s+r.place);if(0===o[0]){if(!(128&o[1]))return!1;o=o.slice(1)}if(0===a[0]){if(!(128&a[1]))return!1;a=a.slice(1)}return this.r=new u(o),this.s=new u(a),!(this.recoveryParam=null)},i.prototype.toDER=function(e){var t=this.r.toArray(),r=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&r[0]&&(r=[0].concat(r)),t=s(t),r=s(r);!(r[0]||128&r[1]);)r=r.slice(1);var n=[2];a(n,t.length),(n=n.concat(t)).push(2),a(n,r.length);var i=n.concat(r),o=[48];return a(o,i.length),o=o.concat(i),l.encode(o,e)}},{"../utils":24,"bn.js":9}],22:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],23:[function(e,t,r){t.exports=void 0},{}],24:[function(e,t,r){"use strict";var n=r,i=e("bn.js"),o=e("minimalistic-assert"),s=e("minimalistic-crypto-utils");n.assert=o,n.toArray=s.toArray,n.zero2=s.zero2,n.toHex=s.toHex,n.encode=s.encode,n.getNAF=function(e,t,r){var n=new Array(Math.max(e.bitLength(),r)+1);n.fill(0);for(var i=1<<t+1,o=e.clone(),s=0;s<n.length;s++){var a,u=o.andln(i-1);o.isOdd()?(a=(i>>1)-1<u?(i>>1)-u:u,o.isubn(a)):a=0,n[s]=a,o.iushrn(1)}return n},n.getJSF=function(e,t){var r=[[],[]];e=e.clone(),t=t.clone();for(var n=0,i=0;0<e.cmpn(-n)||0<t.cmpn(-i);){var o,s,a,u=e.andln(3)+n&3,l=t.andln(3)+i&3;3===u&&(u=-1),3===l&&(l=-1),o=0==(1&u)?0:3!==(s=e.andln(7)+n&7)&&5!==s||2!==l?u:-u,r[0].push(o),a=0==(1&l)?0:3!==(s=t.andln(7)+i&7)&&5!==s||2!==u?l:-l,r[1].push(a),2*n===o+1&&(n=1-n),2*i===a+1&&(i=1-i),e.iushrn(1),t.iushrn(1)}return r},n.cachedProperty=function(e,t,r){var n="_"+t;e.prototype[t]=function(){return void 0!==this[n]?this[n]:this[n]=r.call(this)}},n.parseBytes=function(e){return"string"==typeof e?n.toArray(e,"hex"):e},n.intFromLE=function(e){return new i(e,"hex","le")}},{"bn.js":9,"minimalistic-assert":41,"minimalistic-crypto-utils":42}],25:[function(e,t,r){t.exports={version:"6.5.3"}},{}],26:[function(e,t,r){var n=r;n.utils=e("./hash/utils"),n.common=e("./hash/common"),n.sha=e("./hash/sha"),n.ripemd=e("./hash/ripemd"),n.hmac=e("./hash/hmac"),n.sha1=n.sha.sha1,n.sha256=n.sha.sha256,n.sha224=n.sha.sha224,n.sha384=n.sha.sha384,n.sha512=n.sha.sha512,n.ripemd160=n.ripemd.ripemd160},{"./hash/common":27,"./hash/hmac":28,"./hash/ripemd":29,"./hash/sha":30,"./hash/utils":37}],27:[function(e,t,r){"use strict";var i=e("./utils"),n=e("minimalistic-assert");function o(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}(r.BlockHash=o).prototype.update=function(e,t){if(e=i.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var r=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-r,e.length),0===this.pending.length&&(this.pending=null),e=i.join32(e,0,e.length-r,this.endian);for(var n=0;n<e.length;n+=this._delta32)this._update(e,n,n+this._delta32)}return this},o.prototype.digest=function(e){return this.update(this._pad()),n(null===this.pending),this._digest(e)},o.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,r=t-(e+this.padLength)%t,n=new Array(r+this.padLength);n[0]=128;for(var i=1;i<r;i++)n[i]=0;if(e<<=3,"big"===this.endian){for(var o=8;o<this.padLength;o++)n[i++]=0;n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=e>>>24&255,n[i++]=e>>>16&255,n[i++]=e>>>8&255,n[i++]=255&e}else for(n[i++]=255&e,n[i++]=e>>>8&255,n[i++]=e>>>16&255,n[i++]=e>>>24&255,n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=0,o=8;o<this.padLength;o++)n[i++]=0;return n}},{"./utils":37,"minimalistic-assert":41}],28:[function(e,t,r){"use strict";var n=e("./utils"),i=e("minimalistic-assert");function o(e,t,r){if(!(this instanceof o))return new o(e,t,r);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(n.toArray(t,r))}(t.exports=o).prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),i(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},o.prototype.update=function(e,t){return this.inner.update(e,t),this},o.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"./utils":37,"minimalistic-assert":41}],29:[function(e,t,r){"use strict";var n=e("./utils"),i=e("./common"),y=n.rotl32,m=n.sum32,g=n.sum32_3,b=n.sum32_4,o=i.BlockHash;function s(){if(!(this instanceof s))return new s;o.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function w(e,t,r,n){return e<=15?t^r^n:e<=31?t&r|~t&n:e<=47?(t|~r)^n:e<=63?t&n|r&~n:t^(r|~n)}n.inherits(s,o),(r.ripemd160=s).blockSize=512,s.outSize=160,s.hmacStrength=192,s.padLength=64,s.prototype._update=function(e,t){for(var r,n,i=f=this.h[0],o=v=this.h[1],s=p=this.h[2],a=d=this.h[3],u=c=this.h[4],l=0;l<80;l++)var h=m(y(b(f,w(l,v,p,d),e[_[l]+t],(n=l)<=15?0:n<=31?1518500249:n<=47?1859775393:n<=63?2400959708:2840853838),A[l]),c),f=c,c=d,d=y(p,10),p=v,v=h,h=m(y(b(i,w(79-l,o,s,a),e[M[l]+t],(r=l)<=15?1352829926:r<=31?1548603684:r<=47?1836072691:r<=63?2053994217:0),E[l]),u),i=u,u=a,a=y(s,10),s=o,o=h;h=g(this.h[1],p,a),this.h[1]=g(this.h[2],d,u),this.h[2]=g(this.h[3],c,i),this.h[3]=g(this.h[4],f,o),this.h[4]=g(this.h[0],v,s),this.h[0]=h},s.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"little"):n.split32(this.h,"little")};var _=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],M=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],A=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],E=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"./common":27,"./utils":37}],30:[function(e,t,r){"use strict";r.sha1=e("./sha/1"),r.sha224=e("./sha/224"),r.sha256=e("./sha/256"),r.sha384=e("./sha/384"),r.sha512=e("./sha/512")},{"./sha/1":31,"./sha/224":32,"./sha/256":33,"./sha/384":34,"./sha/512":35}],31:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],32:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],33:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../common"),o=e("./common"),p=e("minimalistic-assert"),v=n.sum32,y=n.sum32_4,m=n.sum32_5,g=o.ch32,b=o.maj32,w=o.s0_256,_=o.s1_256,M=o.g0_256,A=o.g1_256,s=i.BlockHash,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function u(){if(!(this instanceof u))return new u;s.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=a,this.W=new Array(64)}n.inherits(u,s),(t.exports=u).blockSize=512,u.outSize=256,u.hmacStrength=192,u.padLength=64,u.prototype._update=function(e,t){for(var r=this.W,n=0;n<16;n++)r[n]=e[t+n];for(;n<r.length;n++)r[n]=y(A(r[n-2]),r[n-7],M(r[n-15]),r[n-16]);var i=this.h[0],o=this.h[1],s=this.h[2],a=this.h[3],u=this.h[4],l=this.h[5],h=this.h[6],f=this.h[7];for(p(this.k.length===r.length),n=0;n<r.length;n++)var c=m(f,_(u),g(u,l,h),this.k[n],r[n]),d=v(w(i),b(i,o,s)),f=h,h=l,l=u,u=v(a,c),a=s,s=o,o=i,i=v(c,d);this.h[0]=v(this.h[0],i),this.h[1]=v(this.h[1],o),this.h[2]=v(this.h[2],s),this.h[3]=v(this.h[3],a),this.h[4]=v(this.h[4],u),this.h[5]=v(this.h[5],l),this.h[6]=v(this.h[6],h),this.h[7]=v(this.h[7],f)},u.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":27,"../utils":37,"./common":36,"minimalistic-assert":41}],34:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],35:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../common"),C=e("minimalistic-assert"),L=n.rotr64_hi,B=n.rotr64_lo,c=n.shr64_hi,d=n.shr64_lo,D=n.sum64,U=n.sum64_hi,F=n.sum64_lo,p=n.sum64_4_hi,v=n.sum64_4_lo,j=n.sum64_5_hi,G=n.sum64_5_lo,o=i.BlockHash,s=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function a(){if(!(this instanceof a))return new a;o.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=s,this.W=new Array(160)}n.inherits(a,o),(t.exports=a).blockSize=1024,a.outSize=512,a.hmacStrength=192,a.padLength=128,a.prototype._prepareBlock=function(e,t){for(var r=this.W,n=0;n<32;n++)r[n]=e[t+n];for(;n<r.length;n+=2){var i=function(e,t){var r=L(e,t,19),n=L(t,e,29),i=c(e,t,6),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-4],r[n-3]),o=function(e,t){var r=B(e,t,19),n=B(t,e,29),i=d(e,t,6),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-4],r[n-3]),s=r[n-14],a=r[n-13],u=function(e,t){var r=L(e,t,1),n=L(e,t,8),i=c(e,t,7),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-30],r[n-29]),l=function(e,t){var r=B(e,t,1),n=B(e,t,8),i=d(e,t,7),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-30],r[n-29]),h=r[n-32],f=r[n-31];r[n]=p(i,o,s,a,u,l,h,f),r[n+1]=v(i,o,s,a,u,l,h,f)}},a.prototype._update=function(e,t){this._prepareBlock(e,t);var r=this.W,n=this.h[0],i=this.h[1],o=this.h[2],s=this.h[3],a=this.h[4],u=this.h[5],l=this.h[6],h=this.h[7],f=this.h[8],c=this.h[9],d=this.h[10],p=this.h[11],v=this.h[12],y=this.h[13],m=this.h[14],g=this.h[15];C(this.k.length===r.length);for(var b=0;b<r.length;b+=2)var w=m,_=g,M=function(e,t){var r=L(e,t,14),n=L(e,t,18),i=L(t,e,9),o=r^n^i;o<0&&(o+=4294967296);return o}(f,c),A=function(e,t){var r=B(e,t,14),n=B(e,t,18),i=B(t,e,9),o=r^n^i;o<0&&(o+=4294967296);return o}(f,c),E=function(e,t,r){var n=e&t^~e&r;n<0&&(n+=4294967296);return n}(f,d,v),S=function(e,t,r){var n=e&t^~e&r;n<0&&(n+=4294967296);return n}(c,p,y),k=this.k[b],N=this.k[b+1],x=r[b],P=r[b+1],I=j(w,_,M,A,E,S,k,N,x,P),T=G(w,_,M,A,E,S,k,N,x,P),w=function(e,t){var r=L(e,t,28),n=L(t,e,2),i=L(t,e,7),o=r^n^i;o<0&&(o+=4294967296);return o}(n,i),_=function(e,t){var r=B(e,t,28),n=B(t,e,2),i=B(t,e,7),o=r^n^i;o<0&&(o+=4294967296);return o}(n,i),M=function(e,t,r){var n=e&t^e&r^t&r;n<0&&(n+=4294967296);return n}(n,o,a),A=function(e,t,r){var n=e&t^e&r^t&r;n<0&&(n+=4294967296);return n}(i,s,u),R=U(w,_,M,A),O=F(w,_,M,A),m=v,g=y,v=d,y=p,d=f,p=c,f=U(l,h,I,T),c=F(h,h,I,T),l=a,h=u,a=o,u=s,o=n,s=i,n=U(I,T,R,O),i=F(I,T,R,O);D(this.h,0,n,i),D(this.h,2,o,s),D(this.h,4,a,u),D(this.h,6,l,h),D(this.h,8,f,c),D(this.h,10,d,p),D(this.h,12,v,y),D(this.h,14,m,g)},a.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":27,"../utils":37,"minimalistic-assert":41}],36:[function(e,t,r){"use strict";var n=e("../utils").rotr32;function i(e,t,r){return e&t^~e&r}function o(e,t,r){return e&t^e&r^t&r}function s(e,t,r){return e^t^r}r.ft_1=function(e,t,r,n){return 0===e?i(t,r,n):1===e||3===e?t^r^n:2===e?o(t,r,n):void 0},r.ch32=i,r.maj32=o,r.p32=s,r.s0_256=function(e){return n(e,2)^n(e,13)^n(e,22)},r.s1_256=function(e){return n(e,6)^n(e,11)^n(e,25)},r.g0_256=function(e){return n(e,7)^n(e,18)^e>>>3},r.g1_256=function(e){return n(e,17)^n(e,19)^e>>>10}},{"../utils":37}],37:[function(e,t,r){"use strict";var l=e("minimalistic-assert"),n=e("inherits");function o(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function i(e){return 1===e.length?"0"+e:e}function s(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}r.inherits=n,r.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)r.push(parseInt(e[n]+e[n+1],16))}else for(var n=0;n<e.length;n++){var i=e.charCodeAt(n),o=i>>8,s=255&i;o?r.push(o,s):r.push(s)}else for(n=0;n<e.length;n++)r[n]=0|e[n];return r},r.toHex=function(e){for(var t="",r=0;r<e.length;r++)t+=i(e[r].toString(16));return t},r.htonl=o,r.toHex32=function(e,t){for(var r="",n=0;n<e.length;n++){var i=e[n];"little"===t&&(i=o(i)),r+=s(i.toString(16))}return r},r.zero2=i,r.zero8=s,r.join32=function(e,t,r,n){var i=r-t;l(i%4==0);for(var o=new Array(i/4),s=0,a=t;s<o.length;s++,a+=4){var u="big"===n?e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3]:e[a+3]<<24|e[a+2]<<16|e[a+1]<<8|e[a];o[s]=u>>>0}return o},r.split32=function(e,t){for(var r=new Array(4*e.length),n=0,i=0;n<e.length;n++,i+=4){var o=e[n];"big"===t?(r[i]=o>>>24,r[i+1]=o>>>16&255,r[i+2]=o>>>8&255,r[i+3]=255&o):(r[i+3]=o>>>24,r[i+2]=o>>>16&255,r[i+1]=o>>>8&255,r[i]=255&o)}return r},r.rotr32=function(e,t){return e>>>t|e<<32-t},r.rotl32=function(e,t){return e<<t|e>>>32-t},r.sum32=function(e,t){return e+t>>>0},r.sum32_3=function(e,t,r){return e+t+r>>>0},r.sum32_4=function(e,t,r,n){return e+t+r+n>>>0},r.sum32_5=function(e,t,r,n,i){return e+t+r+n+i>>>0},r.sum64=function(e,t,r,n){var i=e[t],o=n+e[t+1]>>>0,s=(o<n?1:0)+r+i;e[t]=s>>>0,e[t+1]=o},r.sum64_hi=function(e,t,r,n){return(t+n>>>0<t?1:0)+e+r>>>0},r.sum64_lo=function(e,t,r,n){return t+n>>>0},r.sum64_4_hi=function(e,t,r,n,i,o,s,a){var u=0,l=t;return u+=(l=l+n>>>0)<t?1:0,u+=(l=l+o>>>0)<o?1:0,e+r+i+s+(u+=(l=l+a>>>0)<a?1:0)>>>0},r.sum64_4_lo=function(e,t,r,n,i,o,s,a){return t+n+o+a>>>0},r.sum64_5_hi=function(e,t,r,n,i,o,s,a,u,l){var h=0,f=t;return h+=(f=f+n>>>0)<t?1:0,h+=(f=f+o>>>0)<o?1:0,h+=(f=f+a>>>0)<a?1:0,e+r+i+s+u+(h+=(f=f+l>>>0)<l?1:0)>>>0},r.sum64_5_lo=function(e,t,r,n,i,o,s,a,u,l){return t+n+o+a+l>>>0},r.rotr64_hi=function(e,t,r){return(t<<32-r|e>>>r)>>>0},r.rotr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0},r.shr64_hi=function(e,t,r){return e>>>r},r.shr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0}},{inherits:39,"minimalistic-assert":41}],38:[function(e,t,r){"use strict";var n=e("hash.js"),s=e("minimalistic-crypto-utils"),i=e("minimalistic-assert");function o(e){if(!(this instanceof o))return new o(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=s.toArray(e.entropy,e.entropyEnc||"hex"),r=s.toArray(e.nonce,e.nonceEnc||"hex"),n=s.toArray(e.pers,e.persEnc||"hex");i(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,r,n)}(t.exports=o).prototype._init=function(e,t,r){var n=e.concat(t).concat(r);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++)this.K[i]=0,this.V[i]=1;this._update(n),this._reseed=1,this.reseedInterval=281474976710656},o.prototype._hmac=function(){return new n.hmac(this.hash,this.K)},o.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},o.prototype.reseed=function(e,t,r,n){"string"!=typeof t&&(n=r,r=t,t=null),e=s.toArray(e,t),r=s.toArray(r,n),i(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(r||[])),this._reseed=1},o.prototype.generate=function(e,t,r,n){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(n=r,r=t,t=null),r&&(r=s.toArray(r,n||"hex"),this._update(r));for(var i=[];i.length<e;)this.V=this._hmac().update(this.V).digest(),i=i.concat(this.V);var o=i.slice(0,e);return this._update(r),this._reseed++,s.encode(o,t)}},{"hash.js":26,"minimalistic-assert":41,"minimalistic-crypto-utils":42}],39:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(e,t){var r;t&&(e.super_=t,(r=function(){}).prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e)}},{}],40:[function(e,_,t){(function(b,w){!function(){"use strict";var e="object"==typeof window?window:{};!e.JS_SHA3_NO_NODE_JS&&"object"==typeof b&&b.versions&&b.versions.node&&(e=w);for(var t=!e.JS_SHA3_NO_COMMON_JS&&"object"==typeof _&&_.exports,u="0123456789abcdef".split(""),h=[0,8,16,24],he=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],r=[224,256,384,512],o=["hex","buffer","arrayBuffer","array"],s=function(t,r,n){return function(e){return new m(t,r,t).update(e)[n]()}},a=function(r,n,i){return function(e,t){return new m(r,n,t).update(e)[i]()}},n=function(e,t){var r=s(e,t,"hex");r.create=function(){return new m(e,t,e)},r.update=function(e){return r.create().update(e)};for(var n=0;n<o.length;++n){var i=o[n];r[i]=s(e,t,i)}return r},i=[{name:"keccak",padding:[1,256,65536,16777216],bits:r,createMethod:n},{name:"sha3",padding:[6,1536,393216,100663296],bits:r,createMethod:n},{name:"shake",padding:[31,7936,2031616,520093696],bits:[128,256],createMethod:function(t,r){var n=a(t,r,"hex");n.create=function(e){return new m(t,r,e)},n.update=function(e,t){return n.create(t).update(e)};for(var e=0;e<o.length;++e){var i=o[e];n[i]=a(t,r,i)}return n}}],l={},f=[],c=0;c<i.length;++c)for(var d=i[c],p=d.bits,v=0;v<p.length;++v){var y=d.name+"_"+p[v];f.push(y),l[y]=d.createMethod(p[v],d.padding)}function m(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}m.prototype.update=function(e){var t="string"!=typeof e;t&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e));for(var r,n,i=e.length,o=this.blocks,s=this.byteCount,a=this.blockCount,u=0,l=this.s;u<i;){if(this.reset)for(this.reset=!1,o[0]=this.block,r=1;r<a+1;++r)o[r]=0;if(t)for(r=this.start;u<i&&r<s;++u)o[r>>2]|=e[u]<<h[3&r++];else for(r=this.start;u<i&&r<s;++u)(n=e.charCodeAt(u))<128?o[r>>2]|=n<<h[3&r++]:(n<2048?o[r>>2]|=(192|n>>6)<<h[3&r++]:(n<55296||57344<=n?o[r>>2]|=(224|n>>12)<<h[3&r++]:(n=65536+((1023&n)<<10|1023&e.charCodeAt(++u)),o[r>>2]|=(240|n>>18)<<h[3&r++],o[r>>2]|=(128|n>>12&63)<<h[3&r++]),o[r>>2]|=(128|n>>6&63)<<h[3&r++]),o[r>>2]|=(128|63&n)<<h[3&r++]);if(s<=(this.lastByteIndex=r)){for(this.start=r-s,this.block=o[a],r=0;r<a;++r)l[r]^=o[r];g(l),this.reset=!0}else this.start=r}return this},m.prototype.finalize=function(){var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];g(n)},m.prototype.toString=m.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,n=this.outputBlocks,i=this.extraBytes,o=0,s=0,a="";s<n;){for(o=0;o<t&&s<n;++o,++s)e=r[o],a+=u[e>>4&15]+u[15&e]+u[e>>12&15]+u[e>>8&15]+u[e>>20&15]+u[e>>16&15]+u[e>>28&15]+u[e>>24&15];s%t==0&&(g(r),o=0)}return i&&(e=r[o],0<i&&(a+=u[e>>4&15]+u[15&e]),1<i&&(a+=u[e>>12&15]+u[e>>8&15]),2<i&&(a+=u[e>>20&15]+u[e>>16&15])),a},m.prototype.buffer=m.prototype.arrayBuffer=function(){this.finalize();for(var e=this.blockCount,t=this.s,r=this.outputBlocks,n=this.extraBytes,i=0,o=0,s=this.outputBits>>3,a=n?new ArrayBuffer(r+1<<2):new ArrayBuffer(s),u=new Uint32Array(a);o<r;){for(i=0;i<e&&o<r;++i,++o)u[o]=t[i];o%e==0&&g(t)}return n&&(u[i]=t[i],a=a.slice(0,s)),a},m.prototype.digest=m.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,i=this.outputBlocks,o=this.extraBytes,s=0,a=0,u=[];a<i;){for(s=0;s<r&&a<i;++s,++a)e=a<<2,t=n[s],u[e]=255&t,u[e+1]=t>>8&255,u[e+2]=t>>16&255,u[e+3]=t>>24&255;a%r==0&&g(n)}return o&&(e=a<<2,t=n[s],0<o&&(u[e]=255&t),1<o&&(u[e+1]=t>>8&255),2<o&&(u[e+2]=t>>16&255)),u};var g=function(e){for(var t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y,m,g,b,w,_,M,A,E,S,k,N,x,P,I,T,R,O,C,L,B,D,U,F,j,G,H,z,V,K,q,W,Z,J,X,$,Q,Y,ee,te,re,ne,ie,oe,se,ae,ue,le=0;le<48;le+=2)n=e[0]^e[10]^e[20]^e[30]^e[40],i=e[1]^e[11]^e[21]^e[31]^e[41],o=e[2]^e[12]^e[22]^e[32]^e[42],s=e[3]^e[13]^e[23]^e[33]^e[43],a=e[4]^e[14]^e[24]^e[34]^e[44],u=e[5]^e[15]^e[25]^e[35]^e[45],l=e[6]^e[16]^e[26]^e[36]^e[46],h=e[7]^e[17]^e[27]^e[37]^e[47],t=(f=e[8]^e[18]^e[28]^e[38]^e[48])^(o<<1|s>>>31),r=(c=e[9]^e[19]^e[29]^e[39]^e[49])^(s<<1|o>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=n^(a<<1|u>>>31),r=i^(u<<1|a>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=o^(l<<1|h>>>31),r=s^(h<<1|l>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=a^(f<<1|c>>>31),r=u^(c<<1|f>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=l^(n<<1|i>>>31),r=h^(i<<1|n>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,d=e[0],p=e[1],K=e[11]<<4|e[10]>>>28,q=e[10]<<4|e[11]>>>28,N=e[20]<<3|e[21]>>>29,x=e[21]<<3|e[20]>>>29,oe=e[31]<<9|e[30]>>>23,se=e[30]<<9|e[31]>>>23,G=e[40]<<18|e[41]>>>14,H=e[41]<<18|e[40]>>>14,O=e[2]<<1|e[3]>>>31,C=e[3]<<1|e[2]>>>31,v=e[13]<<12|e[12]>>>20,y=e[12]<<12|e[13]>>>20,W=e[22]<<10|e[23]>>>22,Z=e[23]<<10|e[22]>>>22,P=e[33]<<13|e[32]>>>19,I=e[32]<<13|e[33]>>>19,ae=e[42]<<2|e[43]>>>30,ue=e[43]<<2|e[42]>>>30,Y=e[5]<<30|e[4]>>>2,ee=e[4]<<30|e[5]>>>2,L=e[14]<<6|e[15]>>>26,B=e[15]<<6|e[14]>>>26,m=e[25]<<11|e[24]>>>21,g=e[24]<<11|e[25]>>>21,J=e[34]<<15|e[35]>>>17,X=e[35]<<15|e[34]>>>17,T=e[45]<<29|e[44]>>>3,R=e[44]<<29|e[45]>>>3,A=e[6]<<28|e[7]>>>4,E=e[7]<<28|e[6]>>>4,te=e[17]<<23|e[16]>>>9,re=e[16]<<23|e[17]>>>9,D=e[26]<<25|e[27]>>>7,U=e[27]<<25|e[26]>>>7,b=e[36]<<21|e[37]>>>11,w=e[37]<<21|e[36]>>>11,$=e[47]<<24|e[46]>>>8,Q=e[46]<<24|e[47]>>>8,z=e[8]<<27|e[9]>>>5,V=e[9]<<27|e[8]>>>5,S=e[18]<<20|e[19]>>>12,k=e[19]<<20|e[18]>>>12,ne=e[29]<<7|e[28]>>>25,ie=e[28]<<7|e[29]>>>25,F=e[38]<<8|e[39]>>>24,j=e[39]<<8|e[38]>>>24,_=e[48]<<14|e[49]>>>18,M=e[49]<<14|e[48]>>>18,e[0]=d^~v&m,e[1]=p^~y&g,e[10]=A^~S&N,e[11]=E^~k&x,e[20]=O^~L&D,e[21]=C^~B&U,e[30]=z^~K&W,e[31]=V^~q&Z,e[40]=Y^~te&ne,e[41]=ee^~re&ie,e[2]=v^~m&b,e[3]=y^~g&w,e[12]=S^~N&P,e[13]=k^~x&I,e[22]=L^~D&F,e[23]=B^~U&j,e[32]=K^~W&J,e[33]=q^~Z&X,e[42]=te^~ne&oe,e[43]=re^~ie&se,e[4]=m^~b&_,e[5]=g^~w&M,e[14]=N^~P&T,e[15]=x^~I&R,e[24]=D^~F&G,e[25]=U^~j&H,e[34]=W^~J&$,e[35]=Z^~X&Q,e[44]=ne^~oe&ae,e[45]=ie^~se&ue,e[6]=b^~_&d,e[7]=w^~M&p,e[16]=P^~T&A,e[17]=I^~R&E,e[26]=F^~G&O,e[27]=j^~H&C,e[36]=J^~$&z,e[37]=X^~Q&V,e[46]=oe^~ae&Y,e[47]=se^~ue&ee,e[8]=_^~d&v,e[9]=M^~p&y,e[18]=T^~A&S,e[19]=R^~E&k,e[28]=G^~O&L,e[29]=H^~C&B,e[38]=$^~z&K,e[39]=Q^~V&q,e[48]=ae^~Y&te,e[49]=ue^~ee&re,e[0]^=he[le],e[1]^=he[le+1]};if(t)_.exports=l;else for(c=0;c<f.length;++c)e[f[c]]=l[f[c]]}()}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{_process:43}],41:[function(e,t,r){function n(e,t){if(!e)throw new Error(t||"Assertion failed")}(t.exports=n).equal=function(e,t,r){if(e!=t)throw new Error(r||"Assertion failed: "+e+" != "+t)}},{}],42:[function(e,t,r){"use strict";var n=r;function i(e){return 1===e.length?"0"+e:e}function o(e){for(var t="",r=0;r<e.length;r++)t+=i(e[r].toString(16));return t}n.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"!=typeof e){for(var n=0;n<e.length;n++)r[n]=0|e[n];return r}if("hex"===t){(e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e);for(n=0;n<e.length;n+=2)r.push(parseInt(e[n]+e[n+1],16))}else for(n=0;n<e.length;n++){var i=e.charCodeAt(n),o=i>>8,s=255&i;o?r.push(o,s):r.push(s)}return r},n.zero2=i,n.toHex=o,n.encode=function(e,t){return"hex"===t?o(e):e}},{}],43:[function(e,t,r){t.exports={browser:!0}},{}],44:[function(e,r,o){(function(n){"use strict";function l(e){var y=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],m=1779033703,g=3144134277,b=1013904242,w=2773480762,_=1359893119,M=2600822924,A=528734635,E=1541459225,S=new Array(64);function t(e){for(var t=0,r=e.length;64<=r;){for(var n,i,o,s,a=m,u=g,l=b,h=w,f=_,c=M,d=A,p=E,v=0;v<16;v++)i=t+4*v,S[v]=(255&e[i])<<24|(255&e[i+1])<<16|(255&e[i+2])<<8|255&e[i+3];for(v=16;v<64;v++)o=((n=S[v-2])>>>17|n<<15)^(n>>>19|n<<13)^n>>>10,s=((n=S[v-15])>>>7|n<<25)^(n>>>18|n<<14)^n>>>3,S[v]=(o+S[v-7]|0)+(s+S[v-16]|0)|0;for(v=0;v<64;v++)o=(((f>>>6|f<<26)^(f>>>11|f<<21)^(f>>>25|f<<7))+(f&c^~f&d)|0)+(p+(y[v]+S[v]|0)|0)|0,s=((a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10))+(a&u^a&l^u&l)|0,p=d,d=c,c=f,f=h+o|0,h=l,l=u,u=a,a=o+s|0;m=m+a|0,g=g+u|0,b=b+l|0,w=w+h|0,_=_+f|0,M=M+c|0,A=A+d|0,E=E+p|0,t+=64,r-=64}}t(e);var r,n=e.length%64,i=e.length/536870912|0,o=e.length<<3,s=n<56?56:120,a=e.slice(e.length-n,e.length);for(a.push(128),r=1+n;r<s;r++)a.push(0);return a.push(i>>>24&255),a.push(i>>>16&255),a.push(i>>>8&255),a.push(i>>>0&255),a.push(o>>>24&255),a.push(o>>>16&255),a.push(o>>>8&255),a.push(o>>>0&255),t(a),[m>>>24&255,m>>>16&255,m>>>8&255,m>>>0&255,g>>>24&255,g>>>16&255,g>>>8&255,g>>>0&255,b>>>24&255,b>>>16&255,b>>>8&255,b>>>0&255,w>>>24&255,w>>>16&255,w>>>8&255,w>>>0&255,_>>>24&255,_>>>16&255,_>>>8&255,_>>>0&255,M>>>24&255,M>>>16&255,M>>>8&255,M>>>0&255,A>>>24&255,A>>>16&255,A>>>8&255,A>>>0&255,E>>>24&255,E>>>16&255,E>>>8&255,E>>>0&255]}function P(e,t,r){e=e.length<=64?e:l(e);for(var n=64+t.length+4,i=new Array(n),o=new Array(64),s=[],a=0;a<64;a++)i[a]=54;for(a=0;a<e.length;a++)i[a]^=e[a];for(a=0;a<t.length;a++)i[64+a]=t[a];for(a=n-4;a<n;a++)i[a]=0;for(a=0;a<64;a++)o[a]=92;for(a=0;a<e.length;a++)o[a]^=e[a];function u(){for(var e=n-1;n-4<=e;e--){if(i[e]++,i[e]<=255)return;i[e]=0}}for(;32<=r;)u(),s=s.concat(l(o.concat(l(i)))),r-=32;return 0<r&&(u(),s=s.concat(l(o.concat(l(i))).slice(0,r))),s}function I(e,t,r,n,i){var o;for(R(e,16*(2*r-1),i,0,16),o=0;o<2*r;o++)T(e,16*o,i,16),function(e,t){R(e,0,t,0,16);for(var r=8;0<r;r-=2)t[4]^=s(t[0]+t[12],7),t[8]^=s(t[4]+t[0],9),t[12]^=s(t[8]+t[4],13),t[0]^=s(t[12]+t[8],18),t[9]^=s(t[5]+t[1],7),t[13]^=s(t[9]+t[5],9),t[1]^=s(t[13]+t[9],13),t[5]^=s(t[1]+t[13],18),t[14]^=s(t[10]+t[6],7),t[2]^=s(t[14]+t[10],9),t[6]^=s(t[2]+t[14],13),t[10]^=s(t[6]+t[2],18),t[3]^=s(t[15]+t[11],7),t[7]^=s(t[3]+t[15],9),t[11]^=s(t[7]+t[3],13),t[15]^=s(t[11]+t[7],18),t[1]^=s(t[0]+t[3],7),t[2]^=s(t[1]+t[0],9),t[3]^=s(t[2]+t[1],13),t[0]^=s(t[3]+t[2],18),t[6]^=s(t[5]+t[4],7),t[7]^=s(t[6]+t[5],9),t[4]^=s(t[7]+t[6],13),t[5]^=s(t[4]+t[7],18),t[11]^=s(t[10]+t[9],7),t[8]^=s(t[11]+t[10],9),t[9]^=s(t[8]+t[11],13),t[10]^=s(t[9]+t[8],18),t[12]^=s(t[15]+t[14],7),t[13]^=s(t[12]+t[15],9),t[14]^=s(t[13]+t[12],13),t[15]^=s(t[14]+t[13],18);for(r=0;r<16;++r)e[r]+=t[r]}(i,n),R(i,0,e,t+16*o,16);for(o=0;o<r;o++)R(e,t+2*o*16,e,16*o,16);for(o=0;o<r;o++)R(e,t+16*(2*o+1),e,16*(o+r),16)}function s(e,t){return e<<t|e>>>32-t}function T(e,t,r,n){for(var i=0;i<n;i++)r[i]^=e[t+i]}function R(e,t,r,n,i){for(;i--;)r[n++]=e[t++]}function i(e){if(e&&"number"==typeof e.length){for(var t=0;t<e.length;t++){if("number"!=typeof e[t])return;var r=parseInt(e[t]);if(r!=e[t]||r<0||256<=r)return}return 1}}function O(e,t){var r=parseInt(e);if(e!=r)throw new Error("invalid "+t);return r}function e(o,e,s,a,u,l,h){if(!h)throw new Error("missing callback");if(s=O(s,"N"),a=O(a,"r"),u=O(u,"p"),l=O(l,"dkLen"),0===s||0!=(s&s-1))throw new Error("N must be power of 2");if(C/128/a<s)throw new Error("N too large");if(C/128/u<a)throw new Error("r too large");if(!i(o))throw new Error("password must be an array or buffer");if(o=Array.prototype.slice.call(o),!i(e))throw new Error("salt must be an array or buffer");e=Array.prototype.slice.call(e);for(var f=P(o,e,128*u*a),c=new Uint32Array(32*u*a),t=0;t<c.length;t++){var r=4*t;c[t]=(255&f[3+r])<<24|(255&f[2+r])<<16|(255&f[1+r])<<8|(255&f[0+r])<<0}var d,p,v=new Uint32Array(64*a),y=new Uint32Array(32*a*s),m=32*a,g=new Uint32Array(16),b=new Uint32Array(16),w=u*s*2,_=0,M=null,A=!1,E=0,S=0,k=parseInt(1e3/a),N=void 0!==n?n:setTimeout,x=function(){if(A)return h(new Error("cancelled"),_/w);switch(E){case 0:R(c,p=32*S*a,v,0,m),E=1,d=0;case 1:k<(t=s-d)&&(t=k);for(var e=0;e<t;e++)R(v,0,y,(d+e)*m,m),I(v,m,a,g,b);if(d+=t,_+=t,(r=parseInt(1e3*_/w))!==M){if(A=h(null,_/w))break;M=r}if(d<s)break;d=0,E=2;case 2:var t;k<(t=s-d)&&(t=k);for(var r,e=0;e<t;e++){var n=v[16*(2*a-1)]&s-1;T(y,n*m,v,m),I(v,m,a,g,b)}if(d+=t,_+=t,(r=parseInt(1e3*_/w))!==M){if(A=h(null,_/w))break;M=r}if(d<s)break;if(R(v,0,c,p,m),++S<u){E=0;break}f=[];for(e=0;e<c.length;e++)f.push(c[e]>>0&255),f.push(c[e]>>8&255),f.push(c[e]>>16&255),f.push(c[e]>>24&255);var i=P(o,f,l);return h(null,1,i)}N(x)};x()}var t,C;t=this,C=2147483647,void 0!==o?r.exports=e:t&&(t.scrypt&&(t._scrypt=t.scrypt),t.scrypt=e)}).call(this,e("timers").setImmediate)},{timers:46}],45:[function(e,t,r){(function(y,e,t){!function(r,n){"use strict";var t,i,o,s,e,a,u,l,h;function f(e){return i[t]=c.apply(n,e),t++}function c(e){var t=[].slice.call(arguments,1);return function(){"function"==typeof e?e.apply(n,t):new Function(""+e)()}}function d(e){if(o)setTimeout(c(d,e),0);else{var t=i[e];if(t){o=!0;try{t()}finally{p(e),o=!1}}}}function p(e){delete i[e]}function v(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(l)&&d(+e.data.slice(l.length))}r.setImmediate||(t=1,o=!(i={}),s=r.document,h=(h=Object.getPrototypeOf&&Object.getPrototypeOf(r))&&h.setTimeout?h:r,e="[object process]"==={}.toString.call(r.process)?function(){var e=f(arguments);return y.nextTick(c(d,e)),e}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1},r.postMessage("","*"),r.onmessage=t,e}}()?(l="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",v,!1):r.attachEvent("onmessage",v),function(){var e=f(arguments);return r.postMessage(l+e,"*"),e}):r.MessageChannel?((u=new MessageChannel).port1.onmessage=function(e){d(e.data)},function(){var e=f(arguments);return u.port2.postMessage(e),e}):s&&"onreadystatechange"in s.createElement("script")?(a=s.documentElement,function(){var e=f(arguments),t=s.createElement("script");return t.onreadystatechange=function(){d(e),t.onreadystatechange=null,a.removeChild(t),t=null},a.appendChild(t),e}):function(){var e=f(arguments);return setTimeout(c(d,e),0),e},h.setImmediate=e,h.clearImmediate=p)}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("timers").clearImmediate)},{_process:43,timers:46}],46:[function(e,t,r){(function(e){t.exports={setImmediate:e.setImmediate}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],47:[function(e,i,t){(function(e){var t,r,n;e.crypto&&crypto.getRandomValues&&(t=new Uint8Array(16),r=function(){return crypto.getRandomValues(t),t}),r||(n=new Array(16),r=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),n[t]=e>>>((3&t)<<3)&255;return n}),i.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],48:[function(e,t,r){for(var s=e("./rng"),n=[],o={},i=0;i<256;i++)n[i]=(i+256).toString(16).substr(1),o[n[i]]=i;function d(e,t){var r=t||0;return n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]}var a=s(),p=[1|a[0],a[1],a[2],a[3],a[4],a[5]],v=16383&(a[6]<<8|a[7]),y=0,m=0;function u(e,t,r){var n=t&&r||0;"string"==typeof e&&(t="binary"==e?new Array(16):null,e=null);var i=(e=e||{}).random||(e.rng||s)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t)for(var o=0;o<16;o++)t[n+o]=i[o];return t||d(i)}var l=u;l.v1=function(e,t,r){var n=t&&r||0,i=t||[],o=void 0!==(e=e||{}).clockseq?e.clockseq:v,s=void 0!==e.msecs?e.msecs:(new Date).getTime(),a=void 0!==e.nsecs?e.nsecs:m+1,u=s-y+(a-m)/1e4;if(u<0&&void 0===e.clockseq&&(o=o+1&16383),(u<0||y<s)&&void 0===e.nsecs&&(a=0),1e4<=a)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");y=s,v=o;var l=(1e4*(268435455&(s+=122192928e5))+(m=a))%4294967296;i[n++]=l>>>24&255,i[n++]=l>>>16&255,i[n++]=l>>>8&255,i[n++]=255&l;var h=s/4294967296*1e4&268435455;i[n++]=h>>>8&255,i[n++]=255&h,i[n++]=h>>>24&15|16,i[n++]=h>>>16&255,i[n++]=o>>>8|128,i[n++]=255&o;for(var f=e.node||p,c=0;c<6;c++)i[n+c]=f[c];return t||d(i)},l.v4=u,l.parse=function(e,t,r){var n=t&&r||0,i=0;for(t=t||[],e.toLowerCase().replace(/[0-9a-f]{2}/g,function(e){i<16&&(t[n+i++]=o[e])});i<16;)t[n+i++]=0;return t},l.unparse=d,t.exports=l},{"./rng":47}],49:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});try{t.exports.XMLHttpRequest=XMLHttpRequest}catch(e){console.log("Warning: XMLHttpRequest is not defined"),t.exports.XMLHttpRequest=null}},{}],50:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../utils/properties"),i=(o.isProvider=function(e){return n.isType(e,"Provider")},o);function o(){n.setType(this,"Provider")}r.Provider=i},{"../utils/properties":74}],51:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("../utils/address"),a=e("../utils/bignumber"),u=e("../utils/bytes"),l=e("../constants"),h=e("../utils/hash"),f=e("../utils/networks"),c=e("../utils/properties"),d=e("../utils/rlp"),p=e("../utils/transaction"),v=e("../utils/utf8"),y=e("../utils/web"),m=o(e("../errors")),g=e("./abstract-provider");function b(e,t){var r={};for(var n in e)try{var i=e[n](t[n]);void 0!==i&&(r[n]=i)}catch(e){throw e.checkKey=n,e.checkValue=t[n],e}return r}function w(t,r){return function(e){return null==e?r:t(e)}}function _(r){return function(e){if(!Array.isArray(e))throw new Error("not an array");var t=[];return e.forEach(function(e){t.push(r(e))}),t}}function M(e,t){return"string"==typeof e&&(t||"0x"===e.substring(0,2)||(e="0x"+e),32===u.hexDataLength(e))?e.toLowerCase():(m.throwError("invalid hash",m.INVALID_ARGUMENT,{arg:"hash",value:e}),null)}function A(e){return a.bigNumberify(e).toNumber()}function E(e){if(!u.isHexString(e))throw new Error("invalid uint256");for(;e.length<66;)e="0x0"+e.substring(2);return e}function S(e){if(null==e)return"latest";if("earliest"===e)return"0x0";if("latest"===e||"pending"===e)return e;if("number"==typeof e)return u.hexStripZeros(u.hexlify(e));if(u.isHexString(e))return u.hexStripZeros(e);throw new Error("invalid blockTag")}var k={hash:M,blockHash:w(M,null),blockNumber:w(A,null),transactionIndex:w(A,null),confirmations:w(A,null),from:s.getAddress,gasPrice:a.bigNumberify,gasLimit:a.bigNumberify,to:w(s.getAddress,null),value:a.bigNumberify,nonce:A,data:u.hexlify,r:w(E),s:w(E),v:w(A),creates:w(s.getAddress,null),raw:w(u.hexlify)};function N(e){var t;null!=e.gas&&null==e.gasLimit&&(e.gasLimit=e.gas),e.to&&a.bigNumberify(e.to).isZero()&&(e.to="0x0000000000000000000000000000000000000000"),null!=e.input&&null==e.data&&(e.data=e.input),null==e.to&&null==e.creates&&(e.creates=s.getContractAddress(e)),e.raw||e.v&&e.r&&e.s&&(t=[u.stripZeros(u.hexlify(e.nonce)),u.stripZeros(u.hexlify(e.gasPrice)),u.stripZeros(u.hexlify(e.gasLimit)),e.to||"0x",u.stripZeros(u.hexlify(e.value||"0x")),u.hexlify(e.data||"0x"),u.stripZeros(u.hexlify(e.v||"0x")),u.stripZeros(u.hexlify(e.r)),u.stripZeros(u.hexlify(e.s))],e.raw=d.encode(t));var r=b(k,e),n=e.networkId;return null!=e.chainId&&null==n&&null==r.v&&(n=e.chainId),u.isHexString(n)&&(n=a.bigNumberify(n).toNumber()),"number"!=typeof n&&null!=r.v&&((n=(r.v-35)/2)<0&&(n=0),n=parseInt(n)),"number"!=typeof n&&(n=0),r.networkId=n,null==r.chainId&&null!=n&&(r.chainId=n),r.blockHash&&"x"===r.blockHash.replace(/0/g,"")&&(r.blockHash=null),r}var x={hash:M,parentHash:M,number:A,timestamp:A,nonce:w(u.hexlify),difficulty:function(e){var t=a.bigNumberify(e);try{return t.toNumber()}catch(e){}return null},gasLimit:a.bigNumberify,gasUsed:a.bigNumberify,miner:s.getAddress,extraData:u.hexlify,transactions:w(_(M))},P=c.shallowCopy(x);function I(e,t){return null!=e.author&&null==e.miner&&(e.miner=e.author),b(t?P:x,e)}P.transactions=w(_(N));var T={from:w(s.getAddress),nonce:w(A),gasLimit:w(a.bigNumberify),gasPrice:w(a.bigNumberify),to:w(s.getAddress),value:w(a.bigNumberify),data:w(u.hexlify)};function R(e){return b(T,e)}var O={transactionLogIndex:w(A),transactionIndex:A,blockNumber:A,transactionHash:M,address:s.getAddress,topics:_(M),data:u.hexlify,logIndex:A,blockHash:M};var C={to:w(s.getAddress,null),from:w(s.getAddress,null),contractAddress:w(s.getAddress,null),transactionIndex:A,root:w(M),gasUsed:a.bigNumberify,logsBloom:w(u.hexlify),blockHash:M,transactionHash:M,logs:_(function(e){return b(O,e)}),blockNumber:A,confirmations:w(A,null),cumulativeGasUsed:a.bigNumberify,status:w(A)};function L(e){return Array.isArray(e)?e.forEach(function(e){L(e)}):null!=e&&M(e),e}var B={fromBlock:w(S,void 0),toBlock:w(S,void 0),address:w(s.getAddress,void 0),topics:w(L,void 0)},D={blockHash:w(M,void 0),address:w(s.getAddress,void 0),topics:w(L,void 0)};var U,F,j={blockNumber:w(A),blockHash:w(M),transactionIndex:A,removed:w(function(e){if("boolean"==typeof e)return e;if("string"==typeof e){if("true"===e)return!0;if("false"===e)return!1}throw new Error("invaid boolean - "+e)}),address:s.getAddress,data:(U=u.hexlify,F="0x",function(e){return e?U(e):F}),topics:_(M),transactionHash:M,logIndex:A};function G(e){return b(j,e)}function H(e){return e.map(function(e){return"string"==typeof e?e:Array.isArray(e)?(e.forEach(function(e){null!==e&&32!==u.hexDataLength(e)&&m.throwError("invalid topic",m.INVALID_ARGUMENT,{argument:"topic",value:e})}),e.join(",")):null===e?"":m.throwError("invalid topic value",m.INVALID_ARGUMENT,{argument:"topic",value:e})}).join("&")}function z(e){if("string"==typeof e){if(20===u.hexDataLength(e))return"address:"+s.getAddress(e);if(e=e.toLowerCase(),32===u.hexDataLength(e))return"tx:"+e;if(-1===e.indexOf(":"))return e}else{if(Array.isArray(e))return"filter::"+H(e);if(e&&"object"==typeof e)return"filter:"+(e.address||"")+":"+H(e.topics||[])}throw new Error("invalid event - "+e)}function V(){return(new Date).getTime()}var K,q=(K=g.Provider,i(W,K),W.prototype._doPoll=function(){var u=this;this.getBlockNumber().then(function(s){if(u.polling&&(u._setFastBlockNumber(s),s!==u._lastBlockNumber)){-2===u._emitted.block&&(u._emitted.block=s-1);for(var e=u._emitted.block+1;e<=s;e++)u.emit("block",e);u._emitted.block!==s&&(u._emitted.block=s,Object.keys(u._emitted).forEach(function(e){var t;"block"===e||"pending"!==(t=u._emitted[e])&&12<s-t&&delete u._emitted[e]})),-2===u._lastBlockNumber&&(u._lastBlockNumber=s-1);var a={},t={};return u._events.forEach(function(e){t[e.tag]=!0}),Object.keys(t).forEach(function(e){var t=e.split(":");switch(t[0]){case"tx":var r=t[1];u.getTransactionReceipt(r).then(function(e){return e&&null!=e.blockNumber&&(u._emitted["t:"+r]=e.blockNumber,u.emit(r,e)),null}).catch(function(e){u.emit("error",e)});break;case"address":var n=t[1];u._balances[n]&&(a[n]=u._balances[n]),u.getBalance(n,"latest").then(function(e){var t=u._balances[n];if(!t||!e.eq(t))return u._balances[n]=e,u.emit(n,e),null}).catch(function(e){u.emit("error",e)});break;case"filter":var i=t[2].split(/&/g).map(function(e){var t=e.split(",");return 1===t.length?""===t[0]?null:e:t.map(function(e){return""===e?null:e})}),o={address:t[1],fromBlock:u._lastBlockNumber+1,toBlock:s,topics:i};o.address||delete o.address,u.getLogs(o).then(function(e){if(0!==e.length)return e.forEach(function(e){u._emitted["b:"+e.blockHash]=e.blockNumber,u._emitted["t:"+e.transactionHash]=e.blockNumber,u.emit(o,e)}),null}).catch(function(e){u.emit("error",e)})}}),u._lastBlockNumber=s,u._balances=a,null}}).catch(function(e){}),this.doPoll()},W.prototype.resetEventsBlock=function(e){this._lastBlockNumber=e-1,this.polling&&this._doPoll()},Object.defineProperty(W.prototype,"network",{get:function(){return this._network},enumerable:!0,configurable:!0}),W.prototype.getNetwork=function(){return this.ready},Object.defineProperty(W.prototype,"blockNumber",{get:function(){return this._fastBlockNumber},enumerable:!0,configurable:!0}),Object.defineProperty(W.prototype,"polling",{get:function(){return null!=this._poller},set:function(e){var t=this;setTimeout(function(){e&&!t._poller?(t._poller=setInterval(t._doPoll.bind(t),t.pollingInterval),t._doPoll()):!e&&t._poller&&(clearInterval(t._poller),t._poller=null)},0)},enumerable:!0,configurable:!0}),Object.defineProperty(W.prototype,"pollingInterval",{get:function(){return this._pollingInterval},set:function(e){var t=this;if("number"!=typeof e||e<=0||parseInt(String(e))!=e)throw new Error("invalid polling interval");this._pollingInterval=e,this._poller&&(clearInterval(this._poller),this._poller=setInterval(function(){t._doPoll()},this._pollingInterval))},enumerable:!0,configurable:!0}),W.prototype._getFastBlockNumber=function(){var t=this,e=V();return e-this._fastQueryDate>2*this._pollingInterval&&(this._fastQueryDate=e,this._fastBlockNumberPromise=this.getBlockNumber().then(function(e){return(null==t._fastBlockNumber||e>t._fastBlockNumber)&&(t._fastBlockNumber=e),t._fastBlockNumber})),this._fastBlockNumberPromise},W.prototype._setFastBlockNumber=function(e){null!=this._fastBlockNumber&&e<this._fastBlockNumber||(this._fastQueryDate=V(),(null==this._fastBlockNumber||e>this._fastBlockNumber)&&(this._fastBlockNumber=e,this._fastBlockNumberPromise=Promise.resolve(e)))},W.prototype.waitForTransaction=function(n,i){var o=this;return null==i&&(i=1),this.getTransactionReceipt(n).then(function(e){return 0===i||e&&e.confirmations>=i?e:new Promise(function(t){var r=function(e){e.confirmations<i||(o.removeListener(n,r),t(e))};o.on(n,r)})})},W.prototype.getBlockNumber=function(){var r=this;return this.ready.then(function(){return r.perform("getBlockNumber",{}).then(function(e){var t=parseInt(e);if(t!=e)throw new Error("invalid response - getBlockNumber");return r._setFastBlockNumber(t),t})})},W.prototype.getGasPrice=function(){var e=this;return this.ready.then(function(){return e.perform("getGasPrice",{}).then(function(e){return a.bigNumberify(e)})})},W.prototype.getBalance=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getBalance",t).then(function(e){return a.bigNumberify(e)})})})})},W.prototype.getTransactionCount=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getTransactionCount",t).then(function(e){return a.bigNumberify(e).toNumber()})})})})},W.prototype.getCode=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getCode",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.getStorageAt=function(e,t,r){var i=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,position:t,blockTag:r}).then(function(e){var t=e.addressOrName,r=e.position,n=e.blockTag;return i._getAddress(t).then(function(e){var t={address:e,blockTag:S(n),position:u.hexStripZeros(u.hexlify(r))};return i.perform("getStorageAt",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.sendTransaction=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties({signedTransaction:e}).then(function(e){var t=e.signedTransaction,r={signedTransaction:u.hexlify(t)};return n.perform("sendTransaction",r).then(function(e){return n._wrapTransaction(p.parse(t),e)},function(e){throw e.transaction=p.parse(t),e.transaction.hash&&(e.transactionHash=e.transaction.hash),e})})})},W.prototype._wrapTransaction=function(r,e){var n=this;if(null!=e&&32!==u.hexDataLength(e))throw new Error("invalid response - sendTransaction");var t=r;return null!=e&&r.hash!==e&&m.throwError("Transaction hash mismatch from Provider.sendTransaction.",m.UNKNOWN_ERROR,{expectedHash:r.hash,returnedHash:e}),t.wait=function(t){return 0!==t&&(n._emitted["t:"+r.hash]="pending"),n.waitForTransaction(r.hash,t).then(function(e){return null==e&&0===t?null:(n._emitted["t:"+r.hash]=e.blockNumber,0===e.status&&m.throwError("transaction failed",m.CALL_EXCEPTION,{transactionHash:r.hash,transaction:r}),e)})},t},W.prototype.call=function(e,t){var n=this,r=c.shallowCopy(e);return this.ready.then(function(){return c.resolveProperties({blockTag:t,tx:r}).then(function(e){var r=e.blockTag,t=e.tx;return n._resolveNames(t,["to","from"]).then(function(e){var t={blockTag:S(r),transaction:R(e)};return n.perform("call",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.estimateGas=function(e){var r=this,t={to:e.to,from:e.from,data:e.data,gasPrice:e.gasPrice,value:e.value};return this.ready.then(function(){return c.resolveProperties(t).then(function(e){return r._resolveNames(e,["to","from"]).then(function(e){var t={transaction:R(e)};return r.perform("estimateGas",t).then(function(e){return a.bigNumberify(e)})})})})},W.prototype.getBlock=function(e,o){var s=this;return this.ready.then(function(){return c.resolveProperties({blockHashOrBlockTag:e}).then(function(e){var t=e.blockHashOrBlockTag;try{var r=u.hexlify(t);if(32===u.hexDataLength(r))return y.poll(function(){return s.perform("getBlock",{blockHash:r,includeTransactions:!!o}).then(function(e){return null==e?null==s._emitted["b:"+r]?null:void 0:I(e,o)})},{onceBlock:s})}catch(e){}try{var n=-128,i=S(t);return u.isHexString(i)&&(n=parseInt(i.substring(2),16)),y.poll(function(){return s.perform("getBlock",{blockTag:i,includeTransactions:!!o}).then(function(e){return null!=e?I(e,o):n<=s._emitted.block?void 0:null})},{onceBlock:s})}catch(e){}throw new Error("invalid block hash or block tag")})})},W.prototype.getTransaction=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties({transactionHash:e}).then(function(e){var t=e.transactionHash,r={transactionHash:M(t,!0)};return y.poll(function(){return n.perform("getTransaction",r).then(function(e){if(null==e)return null==n._emitted["t:"+t]?null:void 0;var r=W.checkTransactionResponse(e);if(null==r.blockNumber)r.confirmations=0;else if(null==r.confirmations)return n._getFastBlockNumber().then(function(e){var t=e-r.blockNumber+1;return t<=0&&(t=1),r.confirmations=t,n._wrapTransaction(r)});return n._wrapTransaction(r)})},{onceBlock:n})})})},W.prototype.getTransactionReceipt=function(e){var o=this;return this.ready.then(function(){return c.resolveProperties({transactionHash:e}).then(function(e){var i=e.transactionHash,t={transactionHash:M(i,!0)};return y.poll(function(){return o.perform("getTransactionReceipt",t).then(function(e){if(null==e)return null==o._emitted["t:"+i]?null:void 0;if(null!=e.blockHash){var t,r,n=((r=b(C,t=e)).logs.forEach(function(e,t){null==e.transactionLogIndex&&(e.transactionLogIndex=t)}),null!=t.status&&(r.byzantium=!0),r);if(null==n.blockNumber)n.confirmations=0;else if(null==n.confirmations)return o._getFastBlockNumber().then(function(e){var t=e-n.blockNumber+1;return t<=0&&(t=1),n.confirmations=t,n});return n}})},{onceBlock:o})})})},W.prototype.getLogs=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties(e).then(function(e){return n._resolveNames(e,["address"]).then(function(e){var t,r={filter:(t=e)&&t.blockHash?b(D,t):b(B,t)};return n.perform("getLogs",r).then(function(e){return _(G)(e)})})})})},W.prototype.getEtherPrice=function(){var e=this;return this.ready.then(function(){return e.perform("getEtherPrice",{}).then(function(e){return e})})},W.prototype._getAddress=function(t){return this.resolveName(t).then(function(e){return null==e&&m.throwError("ENS name not configured",m.UNSUPPORTED_OPERATION,{operation:"resolveName("+JSON.stringify(t)+")"}),e})},W.prototype._resolveNames=function(e,t){var r=[],n=c.shallowCopy(e);return t.forEach(function(t){null!=n[t]&&r.push(this._getAddress(n[t]).then(function(e){n[t]=e}))},this),Promise.all(r).then(function(){return n})},W.prototype._getResolver=function(n){var i=this;return this.getNetwork().then(function(e){e.ensAddress||m.throwError("network does not support ENS",m.UNSUPPORTED_OPERATION,{operation:"ENS",network:e.name});var t="0x0178b8bf"+h.namehash(n).substring(2),r={to:e.ensAddress,data:t};return i.call(r).then(function(e){if(32!==u.hexDataLength(e))return null;var t=s.getAddress(u.hexDataSlice(e,12));return t===l.AddressZero?null:t})})},W.prototype.resolveName=function(t){var r=this;if(t instanceof Promise)return t.then(function(e){return r.resolveName(e)});try{return Promise.resolve(s.getAddress(t))}catch(e){if(u.isHexString(t))throw e}var n=this,i=h.namehash(t);return this._getResolver(t).then(function(e){if(null==e)return null;var t={to:e,data:"0x3b3b57de"+i.substring(2)};return n.call(t)}).then(function(e){if(32!==u.hexDataLength(e))return null;var t=s.getAddress(u.hexDataSlice(e,12));return t===l.AddressZero?null:t})},W.prototype.lookupAddress=function(n){var t=this;if(n instanceof Promise)return n.then(function(e){return t.lookupAddress(e)});var e=(n=s.getAddress(n)).substring(2)+".addr.reverse",r=h.namehash(e),i=this;return this._getResolver(e).then(function(e){if(!e)return null;var t={to:e,data:"0x691f3431"+r.substring(2)};return i.call(t)}).then(function(e){if(null==e)return null;if((e=e.substring(2)).length<64)return null;if((e=e.substring(64)).length<64)return null;var t=a.bigNumberify("0x"+e.substring(0,64)).toNumber();if(2*t>(e=e.substring(64)).length)return null;var r=v.toUtf8String("0x"+e.substring(0,2*t));return i.resolveName(r).then(function(e){return e!=n?null:r})})},W.checkTransactionResponse=N,W.prototype.doPoll=function(){},W.prototype.perform=function(e,t){return m.throwError(e+" not implemented",m.NOT_IMPLEMENTED,{operation:e}),null},W.prototype._startPending=function(){m.warn("WARNING: this provider does not support pending events")},W.prototype._stopPending=function(){},W.prototype._addEventListener=function(e,t,r){this._events.push({tag:z(e),listener:t,once:r}),"pending"===e&&this._startPending(),this.polling=!0},W.prototype.on=function(e,t){return this._addEventListener(e,t,!1),this},W.prototype.once=function(e,t){return this._addEventListener(e,t,!0),this},W.prototype.addEventListener=function(e,t){return this.on(e,t)},W.prototype.emit=function(e){for(var t=this,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];var i=!1,o=z(e);return this._events=this._events.filter(function(e){return e.tag!==o||(setTimeout(function(){e.listener.apply(t,r)},0),i=!0,!e.once)}),0===this.listenerCount()&&(this.polling=!1),i},W.prototype.listenerCount=function(e){if(!e)return this._events.length;var t=z(e);return this._events.filter(function(e){return e.tag===t}).length},W.prototype.listeners=function(e){var t=z(e);return this._events.filter(function(e){return e.tag===t}).map(function(e){return e.listener})},W.prototype.removeAllListeners=function(e){var t;return null==e?(this._events=[],this._stopPending()):(t=z(e),this._events=this._events.filter(function(e){return e.tag!==t}),"pending"===e&&this._stopPending()),0===this._events.length&&(this.polling=!1),this},W.prototype.removeListener=function(e,t){var r=!1,n=z(e);return this._events=this._events.filter(function(e){return e.tag!==n||e.listener!=t||(!!r||!(r=!0))}),"pending"===e&&0===this.listenerCount("pending")&&this._stopPending(),0===this.listenerCount()&&(this.polling=!1),this},W);function W(e){var t,r=K.call(this)||this;return m.checkNew(r,g.Provider),e instanceof Promise?(c.defineReadOnly(r,"ready",e.then(function(e){return c.defineReadOnly(r,"_network",e),e})),r.ready.catch(function(e){})):(t=f.getNetwork(null==e?"homestead":e))?(c.defineReadOnly(r,"_network",t),c.defineReadOnly(r,"ready",Promise.resolve(r._network))):m.throwError("invalid network",m.INVALID_ARGUMENT,{arg:"network",value:e}),r._lastBlockNumber=-2,r._balances={},r._events=[],r._pollingInterval=4e3,r._emitted={block:-2},r._fastQueryDate=0,r}r.BaseProvider=q,c.defineReadOnly(g.Provider,"inherits",c.inheritable(g.Provider))},{"../constants":3,"../errors":5,"../utils/address":60,"../utils/bignumber":63,"../utils/bytes":64,"../utils/hash":65,"../utils/networks":72,"../utils/properties":74,"../utils/rlp":76,"../utils/transaction":83,"../utils/utf8":85,"../utils/web":86,"./abstract-provider":50}],52:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=e("../utils/bytes"),u=e("../utils/properties"),l=e("../utils/web"),h=o(e("../errors"));function f(e){var t,r=[];for(var n in e){null!=e[n]&&(t=a.hexlify(e[n]),{gasLimit:!0,gasPrice:!0,nonce:!0,value:!0}[n]&&(t=a.hexStripZeros(t)),r.push(n+"="+t))}return r.join("&")}function c(e){if(0==e.status&&("No records found"===e.message||"No transactions found"===e.message))return e.result;if(1==e.status&&"OK"==e.message)return e.result;var t=new Error("invalid response");throw t.result=JSON.stringify(e),t}function d(e){if("2.0"!=e.jsonrpc)throw(t=new Error("invalid response")).result=JSON.stringify(e),t;if(e.error){var t=new Error(e.error.message||"unknown error");throw e.error.code&&(t.code=e.error.code),e.error.data&&(t.data=e.error.data),t}return e.result}function p(e){if("pending"===e)throw new Error("pending not supported");return"latest"===e?e:parseInt(e.substring(2),16)}var v,y="8FG3JMZ9USS4NTA6YKEKHINU56SEPPVBJR",m=(v=s.BaseProvider,i(g,v),g.prototype.perform=function(e,t){var r=this,n=this.baseUrl,i="";this.apiKey&&(i+="&apikey="+this.apiKey);function o(t,e){return l.fetchJson(t,null,e||d).then(function(e){return r.emit("debug",{action:"perform",request:t,response:e,provider:r}),e})}var s;switch(e){case"getBlockNumber":return o(n+="/api?module=proxy&action=eth_blockNumber"+i);case"getGasPrice":return o(n+="/api?module=proxy&action=eth_gasPrice"+i);case"getBalance":return n+="/api?module=account&action=balance&address="+t.address,o(n+="&tag="+t.blockTag+i,c);case"getTransactionCount":return n+="/api?module=proxy&action=eth_getTransactionCount&address="+t.address,o(n+="&tag="+t.blockTag+i);case"getCode":return n+="/api?module=proxy&action=eth_getCode&address="+t.address,o(n+="&tag="+t.blockTag+i,d);case"getStorageAt":return n+="/api?module=proxy&action=eth_getStorageAt&address="+t.address,n+="&position="+t.position,o(n+="&tag="+t.blockTag+i,d);case"sendTransaction":return n+="/api?module=proxy&action=eth_sendRawTransaction&hex="+t.signedTransaction,o(n+=i).catch(function(e){throw e.responseText&&(0<=e.responseText.toLowerCase().indexOf("insufficient funds")&&h.throwError("insufficient funds",h.INSUFFICIENT_FUNDS,{}),0<=e.responseText.indexOf("same hash was already imported")&&h.throwError("nonce has already been used",h.NONCE_EXPIRED,{}),0<=e.responseText.indexOf("another transaction with same nonce")&&h.throwError("replacement fee too low",h.REPLACEMENT_UNDERPRICED,{})),e});case"getBlock":return t.blockTag?(n+="/api?module=proxy&action=eth_getBlockByNumber&tag="+t.blockTag,t.includeTransactions?n+="&boolean=true":n+="&boolean=false",o(n+=i)):Promise.reject(new Error("getBlock by blockHash not implemeneted"));case"getTransaction":return n+="/api?module=proxy&action=eth_getTransactionByHash&txhash="+t.transactionHash,o(n+=i);case"getTransactionReceipt":return n+="/api?module=proxy&action=eth_getTransactionReceipt&txhash="+t.transactionHash,o(n+=i);case"call":return(n+="/api?module=proxy&action=eth_call"+(s=(s=f(t.transaction))&&"&"+s),"latest"!==t.blockTag)?Promise.reject(new Error("EtherscanProvider does not support blockTag for call")):o(n+=i);case"estimateGas":return n+="/api?module=proxy&action=eth_estimateGas&"+(s=(s=f(t.transaction))&&"&"+s),o(n+=i);case"getLogs":n+="/api?module=logs&action=getLogs";try{if(t.filter.fromBlock&&(n+="&fromBlock="+p(t.filter.fromBlock)),t.filter.toBlock&&(n+="&toBlock="+p(t.filter.toBlock)),t.filter.blockHash)try{h.throwError("Etherscan does not support blockHash filters",h.UNSUPPORTED_OPERATION,{operation:"getLogs(blockHash)"})}catch(e){return Promise.reject(e)}if(t.filter.address&&(n+="&address="+t.filter.address),t.filter.topics&&0<t.filter.topics.length){if(1<t.filter.topics.length)throw new Error("unsupported topic format");var a=t.filter.topics[0];if("string"!=typeof a||66!==a.length)throw new Error("unsupported topic0 format");n+="&topic0="+a}}catch(e){return Promise.reject(e)}var u=this;return o(n+=i,c).then(function(e){var r={},n=Promise.resolve();return e.forEach(function(t){n=n.then(function(){return null!=t.blockHash?null:(t.blockHash=r[t.transactionHash],null==t.blockHash?u.getTransaction(t.transactionHash).then(function(e){return r[t.transactionHash]=e.blockHash,t.blockHash=e.blockHash,null}):null)})}),n.then(function(){return e})});case"getEtherPrice":return"homestead"!==this.network.name?Promise.resolve(0):(n+="/api?module=stats&action=ethprice",o(n+=i,c).then(function(e){return parseFloat(e.ethusd)}))}return v.prototype.perform.call(this,e,t)},g.prototype.getHistory=function(e,t,r){var n=this,i=this.baseUrl,o="";return this.apiKey&&(o+="&apikey="+this.apiKey),null==t&&(t=0),null==r&&(r=99999999),this.resolveName(e).then(function(e){return i+="/api?module=account&action=txlist&address="+e,i+="&startblock="+t,i+="&endblock="+r,i+="&sort=asc"+o,l.fetchJson(i,null,c).then(function(e){n.emit("debug",{action:"getHistory",request:i,response:e,provider:n});var r=[];return e.forEach(function(t){["contractAddress","to"].forEach(function(e){""==t[e]&&delete t[e]}),null==t.creates&&null!=t.contractAddress&&(t.creates=t.contractAddress);var e=s.BaseProvider.checkTransactionResponse(t);t.timeStamp&&(e.timestamp=parseInt(t.timeStamp)),r.push(e)}),r})})},g);function g(e,t){var r=v.call(this,e)||this;h.checkNew(r,g);var n="invalid";r.network&&(n=r.network.name);var i=null;switch(n){case"homestead":i="https://api.etherscan.io";break;case"ropsten":i="https://api-ropsten.etherscan.io";break;case"rinkeby":i="https://api-rinkeby.etherscan.io";break;case"kovan":i="https://api-kovan.etherscan.io";break;case"goerli":i="https://api-goerli.etherscan.io";break;default:throw new Error("unsupported network")}return u.defineReadOnly(r,"baseUrl",i),u.defineReadOnly(r,"apiKey",t||y),r}r.EtherscanProvider=m},{"../errors":5,"../utils/bytes":64,"../utils/properties":74,"../utils/web":86,"./base-provider":51}],53:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=o(e("../errors"));function u(t){var r=!0,n=null;return t.forEach(function(e){null!=e?null!=n?n.name===e.name&&n.chainId===e.chainId&&(n.ensAddress===e.ensAddress||null==n.ensAddress&&null==e.ensAddress)||a.throwError("provider mismatch",a.INVALID_ARGUMENT,{arg:"networks",value:t}):n=e:r=!1}),r}var l,h=(l=s.BaseProvider,i(f,l),Object.defineProperty(f.prototype,"providers",{get:function(){return this._providers.slice(0)},enumerable:!0,configurable:!0}),f.prototype.perform=function(i,o){var s=this.providers;return new Promise(function(r,e){var n=null;!function t(){s.length?s.shift().perform(i,o).then(function(e){return r(e)}).catch(function(e){n=n||e,setTimeout(t,0)}):e(n)}()})},f);function f(e){var t,r=this;if(0===e.length)throw new Error("no providers");return r=u(e.map(function(e){return e.network}))?l.call(this,e[0].network)||this:(t=Promise.all(e.map(function(e){return e.getNetwork()})).then(function(e){return u(e)||a.throwError("getNetwork returned null",a.UNKNOWN_ERROR,{}),e[0]}),l.call(this,t)||this),a.checkNew(r,f),r._providers=e.slice(0),r}r.FallbackProvider=h},{"../errors":5,"./base-provider":51}],54:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./abstract-provider");r.Provider=n.Provider;var i=e("./base-provider");r.BaseProvider=i.BaseProvider;var o=e("./etherscan-provider");r.EtherscanProvider=o.EtherscanProvider;var s=e("./fallback-provider");r.FallbackProvider=s.FallbackProvider;var a=e("./ipc-provider");r.IpcProvider=a.IpcProvider;var u=e("./infura-provider");r.InfuraProvider=u.InfuraProvider;var l=e("./json-rpc-provider");r.JsonRpcProvider=l.JsonRpcProvider,r.JsonRpcSigner=l.JsonRpcSigner;var h=e("./web3-provider");r.Web3Provider=h.Web3Provider},{"./abstract-provider":50,"./base-provider":51,"./etherscan-provider":52,"./fallback-provider":53,"./infura-provider":55,"./ipc-provider":56,"./json-rpc-provider":57,"./web3-provider":58}],55:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./json-rpc-provider"),u=e("../utils/bytes"),l=e("../utils/networks"),h=e("../utils/properties"),f=o(e("../errors")),c="7d0d81d0919f4f05b9ab6634be01ee73",d=(s=a.JsonRpcProvider,i(p,s),p.prototype._startPending=function(){f.warn("WARNING: INFURA does not support pending filters")},p.prototype.getSigner=function(e){return f.throwError("INFURA does not support signing",f.UNSUPPORTED_OPERATION,{operation:"getSigner"})},p.prototype.listAccounts=function(){return Promise.resolve([])},p);function p(e,t){var r=this,n=l.getNetwork(null==e?"homestead":e);null==t&&(t=c);var i=null;switch(n.name){case"homestead":i="mainnet.infura.io";break;case"ropsten":i="ropsten.infura.io";break;case"rinkeby":i="rinkeby.infura.io";break;case"goerli":i="goerli.infura.io";break;case"kovan":i="kovan.infura.io";break;default:f.throwError("unsupported network",f.INVALID_ARGUMENT,{argument:"network",value:e})}return u.isHexString("0x"+t,16)?(r=s.call(this,"https://"+i+"/v3/"+t,n)||this,h.defineReadOnly(r,"apiAccessToken",null),h.defineReadOnly(r,"projectId",t)):(f.warn("The legacy INFURA apiAccesToken API is deprecated; please upgrade to a Project ID instead (see INFURA dshboard; https://infura.io)"),r=s.call(this,"https://"+i+"/"+t,n)||this,h.defineReadOnly(r,"apiAccessToken",t),h.defineReadOnly(r,"projectId",null)),f.checkNew(r,p),r}r.InfuraProvider=d},{"../errors":5,"../utils/bytes":64,"../utils/networks":72,"../utils/properties":74,"./json-rpc-provider":57}],56:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0})},{}],57:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=e("../abstract-signer"),u=o(e("../errors")),l=e("../utils/address"),h=e("../utils/bytes"),f=e("../utils/networks"),c=e("../utils/properties"),d=e("../utils/utf8"),p=e("../utils/web");function v(e){if(e.error){var t=new Error(e.error.message);throw t.code=e.error.code,t.data=e.error.data,t}return e.result}function y(e){return e?e.toLowerCase():e}var m,g={},b=42,w=(m=a.Signer,i(_,m),_.prototype.getAddress=function(){var t=this;return this._address?Promise.resolve(this._address):this.provider.send("eth_accounts",[]).then(function(e){return e.length<=t._index&&u.throwError("unknown account #"+t._index,u.UNSUPPORTED_OPERATION,{operation:"getAddress"}),t._address=l.getAddress(e[t._index]),t._address})},_.prototype.getBalance=function(e){return this.provider.getBalance(this.getAddress(),e)},_.prototype.getTransactionCount=function(e){return this.provider.getTransactionCount(this.getAddress(),e)},_.prototype.sendUncheckedTransaction=function(e){var n=this;e=c.shallowCopy(e);var t,r=this.getAddress().then(function(e){return e=e&&e.toLowerCase()});return null==e.gasLimit&&((t=c.shallowCopy(e)).from=r,e.gasLimit=this.provider.estimateGas(t)),Promise.all([c.resolveProperties(e),r]).then(function(e){var t=e[0],r=E.hexlifyTransaction(t);return r.from=e[1],n.provider.send("eth_sendTransaction",[r]).then(function(e){return e},function(e){throw e.responseText&&(0<=e.responseText.indexOf("insufficient funds")&&u.throwError("insufficient funds",u.INSUFFICIENT_FUNDS,{transaction:t}),0<=e.responseText.indexOf("nonce too low")&&u.throwError("nonce has already been used",u.NONCE_EXPIRED,{transaction:t}),0<=e.responseText.indexOf("replacement transaction underpriced")&&u.throwError("replacement fee too low",u.REPLACEMENT_UNDERPRICED,{transaction:t})),e})})},_.prototype.sendTransaction=function(e){var r=this;return this.sendUncheckedTransaction(e).then(function(t){return p.poll(function(){return r.provider.getTransaction(t).then(function(e){if(null!==e)return r.provider._wrapTransaction(e,t)})},{fastRetry:250,onceBlock:r.provider}).catch(function(e){throw e.transactionHash=t,e})})},_.prototype.signMessage=function(e){var t=this,r="string"==typeof e?d.toUtf8Bytes(e):e;return this.getAddress().then(function(e){return t.provider.send("eth_sign",[e.toLowerCase(),h.hexlify(r)])})},_.prototype.unlock=function(t){var r=this.provider;return this.getAddress().then(function(e){return r.send("personal_unlockAccount",[e.toLowerCase(),t,null])})},_);function _(e,t,r){var n=m.call(this)||this;if(u.checkNew(n,_),e!==g)throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");return c.defineReadOnly(n,"provider",t),r?"string"==typeof r?c.defineReadOnly(n,"_address",l.getAddress(r)):"number"==typeof r?c.defineReadOnly(n,"_index",r):u.throwError("invalid address or index",u.INVALID_ARGUMENT,{argument:"addressOrIndex",value:r}):c.defineReadOnly(n,"_index",0),n}r.JsonRpcSigner=w;var M,A={chainId:!0,data:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0},E=(M=s.BaseProvider,i(S,M),S.prototype.getSigner=function(e){return new w(g,this,e)},S.prototype.listAccounts=function(){return this.send("eth_accounts",[]).then(function(e){return e.map(function(e){return l.getAddress(e)})})},S.prototype.send=function(e,t){var r=this,n={method:e,params:t,id:b++,jsonrpc:"2.0"};return p.fetchJson(this.connection,JSON.stringify(n),v).then(function(e){return r.emit("debug",{action:"send",request:n,response:e,provider:r}),e})},S.prototype.perform=function(e,t){switch(e){case"getBlockNumber":return this.send("eth_blockNumber",[]);case"getGasPrice":return this.send("eth_gasPrice",[]);case"getBalance":return this.send("eth_getBalance",[y(t.address),t.blockTag]);case"getTransactionCount":return this.send("eth_getTransactionCount",[y(t.address),t.blockTag]);case"getCode":return this.send("eth_getCode",[y(t.address),t.blockTag]);case"getStorageAt":return this.send("eth_getStorageAt",[y(t.address),t.position,t.blockTag]);case"sendTransaction":return this.send("eth_sendRawTransaction",[t.signedTransaction]).catch(function(e){throw e.responseText&&(0<e.responseText.indexOf("insufficient funds")&&u.throwError("insufficient funds",u.INSUFFICIENT_FUNDS,{}),0<e.responseText.indexOf("nonce too low")&&u.throwError("nonce has already been used",u.NONCE_EXPIRED,{}),0<e.responseText.indexOf("replacement transaction underpriced")&&u.throwError("replacement fee too low",u.REPLACEMENT_UNDERPRICED,{})),e});case"getBlock":return t.blockTag?this.send("eth_getBlockByNumber",[t.blockTag,!!t.includeTransactions]):t.blockHash?this.send("eth_getBlockByHash",[t.blockHash,!!t.includeTransactions]):Promise.reject(new Error("invalid block tag or block hash"));case"getTransaction":return this.send("eth_getTransactionByHash",[t.transactionHash]);case"getTransactionReceipt":return this.send("eth_getTransactionReceipt",[t.transactionHash]);case"call":return this.send("eth_call",[S.hexlifyTransaction(t.transaction,{from:!0}),t.blockTag]);case"estimateGas":return this.send("eth_estimateGas",[S.hexlifyTransaction(t.transaction,{from:!0})]);case"getLogs":return t.filter&&null!=t.filter.address&&(t.filter.address=y(t.filter.address)),this.send("eth_getLogs",[t.filter])}return u.throwError(e+" not implemented",u.NOT_IMPLEMENTED,{operation:e}),null},S.prototype._startPending=function(){var r,n;null==this._pendingFilter&&(n=(r=this).send("eth_newPendingTransactionFilter",[]),(this._pendingFilter=n).then(function(t){return function e(){r.send("eth_getFilterChanges",[t]).then(function(e){if(r._pendingFilter!=n)return null;var t=Promise.resolve();return e.forEach(function(e){r._emitted["t:"+e.toLowerCase()]="pending",t=t.then(function(){return r.getTransaction(e).then(function(e){return r.emit("pending",e),null})})}),t.then(function(){return t=1e3,new Promise(function(e){setTimeout(function(){e()},t)});var t})}).then(function(){return r._pendingFilter==n?(setTimeout(function(){e()},0),null):void r.send("eth_uninstallFilter",[t])}).catch(function(e){})}(),t}).catch(function(e){}))},S.prototype._stopPending=function(){this._pendingFilter=null},S.hexlifyTransaction=function(r,e){var t=c.shallowCopy(A);if(e)for(var n in e)e[n]&&(t[n]=!0);c.checkProperties(r,t);var i={};return["gasLimit","gasPrice","nonce","value"].forEach(function(e){var t;null!=r[e]&&(t=h.hexStripZeros(h.hexlify(r[e])),"gasLimit"===e&&(e="gas"),i[e]=t)}),["from","to","data"].forEach(function(e){null!=r[e]&&(i[e]=h.hexlify(r[e]))}),i},S);function S(e,t){var r,n=this;return"string"==typeof e&&null===t&&f.getNetwork(e)&&(t=e,e=null),n=t?M.call(this,t)||this:(r=new Promise(function(t,r){setTimeout(function(){n.send("net_version",[]).then(function(e){return t(f.getNetwork(parseInt(e)))}).catch(function(e){r(e)})})}),M.call(this,r)||this),u.checkNew(n,S),e=e||"http://localhost:8545",n.connection="string"==typeof e?{url:e}:e,n}r.JsonRpcProvider=E},{"../abstract-signer":2,"../errors":5,"../utils/address":60,"../utils/bytes":64,"../utils/networks":72,"../utils/properties":74,"../utils/utf8":85,"../utils/web":86,"./base-provider":51}],58:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./json-rpc-provider"),u=e("../utils/properties"),l=o(e("../errors")),h=42,f=(s=a.JsonRpcProvider,i(c,s),c.prototype.send=function(t,r){var o=this;return"eth_sign"==t&&this._web3Provider.isMetaMask&&(t="personal_sign",r=[r[1],r[0]]),new Promise(function(n,i){var e={method:t,params:r,id:h++,jsonrpc:"2.0"};o._sendAsync(e,function(e,t){if(e)i(e);else{if(t.error){var r=new Error(t.error.message);return r.code=t.error.code,r.data=t.error.data,void i(r)}n(t.result)}})})},c);function c(e,t){var r=s.call(this,e.host||e.path||"",t)||this;return l.checkNew(r,c),e&&(e.sendAsync?r._sendAsync=e.sendAsync.bind(e):e.send&&(r._sendAsync=e.send.bind(e))),e&&r._sendAsync||l.throwError("invalid web3Provider",l.INVALID_ARGUMENT,{arg:"web3Provider",value:e}),u.defineReadOnly(r,"_web3Provider",e),u.defineReadOnly(r,"provider",e),r}r.Web3Provider=f},{"../errors":5,"../utils/properties":74,"./json-rpc-provider":57}],59:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("../constants"),l=o(e("../errors")),a=e("./address"),u=e("./bignumber"),h=e("./bytes"),f=e("./utf8"),c=e("./properties"),d=new RegExp(/^bytes([0-9]*)$/),p=new RegExp(/^(u?int)([0-9]*)$/),v=new RegExp(/^(.*)\[([0-9]*)\]$/);r.defaultCoerceFunc=function(e,t){var r=e.match(p);return r&&parseInt(r[2])<=48?t.toNumber():t};var y=new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$"),m=new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");function g(e){return e.match(/^uint($|[^1-9])/)?e="uint256"+e.substring(4):e.match(/^int($|[^1-9])/)&&(e="int256"+e.substring(3)),e}function b(e,t){var r=e;function n(e){throw new Error('unexpected character "'+r[e]+'" at position '+e+' in "'+r+'"')}e=e.replace(/\s/g," ");for(var i={type:"",name:"",state:{allowType:!0}},o=i,s=0;s<e.length;s++){var a=e[s];switch(a){case"(":o.state.allowParams||n(s),o.state.allowType=!1,o.type=g(o.type),o.components=[{type:"",name:"",parent:o,state:{allowType:!0}}],o=o.components[0];break;case")":delete o.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),o.type=g(o.type);var u=o;(o=o.parent)||n(s),delete u.parent,o.state.allowParams=!1,o.state.allowName=!0,o.state.allowArray=!0;break;case",":delete o.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),o.type=g(o.type);var l={type:"",name:"",parent:o.parent,state:{allowType:!0}};o.parent.components.push(l),delete o.parent,o=l;break;case" ":o.state.allowType&&""!==o.type&&(o.type=g(o.type),delete o.state.allowType,o.state.allowName=!0,o.state.allowParams=!0),o.state.allowName&&""!==o.name&&(t&&"indexed"===o.name?(o.indexed=!0,o.name=""):o.state.allowName=!1);break;case"[":o.state.allowArray||n(s),o.type+=a,o.state.allowArray=!1,o.state.allowName=!1,o.state.readArray=!0;break;case"]":o.state.readArray||n(s),o.type+=a,o.state.readArray=!1,o.state.allowArray=!0,o.state.allowName=!0;break;default:o.state.allowType?(o.type+=a,o.state.allowParams=!0,o.state.allowArray=!0):o.state.allowName?(o.name+=a,delete o.state.allowArray):o.state.readArray?o.type+=a:n(s)}}if(o.parent)throw new Error("unexpected eof");return delete i.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),i.type=g(i.type),i}function w(e){return se(r.defaultCoerceFunc,e).type}r.parseParamType=function(e){return b(e,!0)},r.formatParamType=w,r.formatSignature=function(e){return e.name+"("+e.inputs.map(w).join(",")+")"},r.parseSignature=function(e){if("string"==typeof e)return"event "===(e=(e=(e=e.replace(/\s/g," ")).replace(/\(/g," (").replace(/\)/g,") ").replace(/\s+/g," ")).trim()).substring(0,6)?function(e){var t={anonymous:!1,inputs:[],name:"",type:"event"},r=e.match(y);if(!r)throw new Error("invalid event: "+e);if(t.name=r[1].trim(),ie(r[2]).forEach(function(e){(e=b(e,!0)).indexed=!!e.indexed,t.inputs.push(e)}),r[3].split(" ").forEach(function(e){switch(e){case"anonymous":t.anonymous=!0;break;case"":break;default:l.info("unknown modifier: "+e)}}),t.name&&!t.name.match(m))throw new Error('invalid identifier: "'+t.name+'"');return t}(e.substring(6).trim()):("function "===e.substring(0,9)&&(e=e.substring(9)),function(e){var t={constant:!1,gas:null,inputs:[],name:"",outputs:[],payable:!1,stateMutability:null,type:"function"},r=e.split("@");if(1!==r.length){if(2<r.length)throw new Error("invalid signature");if(!r[1].match(/^[0-9]+$/))throw new Error("invalid signature gas");t.gas=u.bigNumberify(r[1]),e=r[0]}var n=(r=e.split(" returns "))[0].match(y);if(!n)throw new Error("invalid signature");if(t.name=n[1].trim(),!t.name.match(m))throw new Error('invalid identifier: "'+n[1]+'"');if(ie(n[2]).forEach(function(e){t.inputs.push(b(e))}),n[3].split(" ").forEach(function(e){switch(e){case"constant":t.constant=!0;break;case"payable":t.payable=!0,t.stateMutability="payable";break;case"pure":t.constant=!0,t.stateMutability="pure";break;case"view":t.constant=!0,t.stateMutability="view";break;case"external":case"public":case"":break;default:l.info("unknown modifier: "+e)}}),1<r.length){var i=r[1].match(y);if(""!=i[1].trim()||""!=i[3].trim())throw new Error("unexpected tokens");ie(i[2]).forEach(function(e){t.outputs.push(b(e))})}if("constructor"===t.name){if(t.type="constructor",t.outputs.length)throw new Error("constructor may not have outputs");delete t.name,delete t.outputs}return t}(e.trim()));throw new Error("unknown signature")};function _(e,t,r,n,i){this.coerceFunc=e,this.name=t,this.type=r,this.localName=n,this.dynamic=i}var M,A=(i(E,M=_),E.prototype.encode=function(e){return this.coder.encode(e)},E.prototype.decode=function(e,t){return this.coder.decode(e,t)},E);function E(e){var t=M.call(this,e.coerceFunc,e.name,e.type,void 0,e.dynamic)||this;return c.defineReadOnly(t,"coder",e),t}var S,k=(i(N,S=_),N.prototype.encode=function(e){return h.arrayify([])},N.prototype.decode=function(e,t){if(t>e.length)throw new Error("invalid null");return{consumed:0,value:this.coerceFunc("null",void 0)}},N);function N(e,t){return S.call(this,e,"null","",t,!1)||this}var x,P=(i(I,x=_),I.prototype.encode=function(t){try{var e=u.bigNumberify(t);if(this.signed){var r=s.MaxUint256.maskn(8*this.size-1);if(e.gt(r))throw new Error("out-of-bounds");if(r=r.add(s.One).mul(s.NegativeOne),e.lt(r))throw new Error("out-of-bounds")}else if(e.lt(s.Zero)||e.gt(s.MaxUint256.maskn(8*this.size)))throw new Error("out-of-bounds");return e=e.toTwos(8*this.size).maskn(8*this.size),this.signed&&(e=e.fromTwos(8*this.size).toTwos(256)),h.padZeros(h.arrayify(e),32)}catch(e){l.throwError("invalid number value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:t})}return null},I.prototype.decode=function(e,t){e.length<t+32&&l.throwError("insufficient data for "+this.name+" type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:h.hexlify(e.slice(t,t+32))});var r=32-this.size,n=u.bigNumberify(e.slice(t+r,t+32)),n=this.signed?n.fromTwos(8*this.size):n.maskn(8*this.size);return{consumed:32,value:this.coerceFunc(this.name,n)}},I);function I(e,t,r,n){var i=this,o=(r?"int":"uint")+8*t;return(i=x.call(this,e,o,o,n,!1)||this).size=t,i.signed=r,i}var T,R=new P(function(e,t){return t},32,!1,"none"),O=(i(C,T=_),C.prototype.encode=function(e){return R.encode(e?1:0)},C.prototype.decode=function(e,t){try{var r=R.decode(e,t)}catch(e){throw"insufficient data for uint256 type"===e.reason&&l.throwError("insufficient data for boolean type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"boolean",value:e.value}),e}return{consumed:r.consumed,value:this.coerceFunc("bool",!r.value.isZero())}},C);function C(e,t){return T.call(this,e,"bool","bool",t,!1)||this}var L,B=(i(D,L=_),D.prototype.encode=function(t){var e=new Uint8Array(32);try{var r=h.arrayify(t);if(r.length!==this.length)throw new Error("incorrect data length");e.set(r)}catch(e){l.throwError("invalid "+this.name+" value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:e.value||t})}return e},D.prototype.decode=function(e,t){return e.length<t+32&&l.throwError("insufficient data for "+this.name+" type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:h.hexlify(e.slice(t,t+32))}),{consumed:32,value:this.coerceFunc(this.name,h.hexlify(e.slice(t,t+this.length)))}},D);function D(e,t,r){var n=this,i="bytes"+t;return(n=L.call(this,e,i,i,r,!1)||this).length=t,n}var U,F=(i(j,U=_),j.prototype.encode=function(t){var e=new Uint8Array(32);try{e.set(h.arrayify(a.getAddress(t)),12)}catch(e){l.throwError("invalid address",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"address",value:t})}return e},j.prototype.decode=function(e,t){return e.length<t+32&&l.throwError("insufficient data for address type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"address",value:h.hexlify(e.slice(t,t+32))}),{consumed:32,value:this.coerceFunc("address",a.getAddress(h.hexlify(e.slice(t+12,t+32))))}},j);function j(e,t){return U.call(this,e,"address","address",t,!1)||this}function G(e){var t=32*Math.ceil(e.length/32),r=new Uint8Array(t-e.length);return h.concat([R.encode(e.length),e,r])}function H(e,t,r){e.length<t+32&&l.throwError("insufficient data for dynamicBytes length",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:h.hexlify(e.slice(t,t+32))});var n=R.decode(e,t).value;try{n=n.toNumber()}catch(e){l.throwError("dynamic bytes count too large",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:n.toString()})}return e.length<t+32+n&&l.throwError("insufficient data for dynamicBytes type",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:h.hexlify(e.slice(t,t+32+n))}),{consumed:32+32*Math.ceil(n/32),value:e.slice(t+32,t+32+n)}}var z,V=(i(K,z=_),K.prototype.encode=function(e){try{return G(h.arrayify(e))}catch(e){l.throwError("invalid bytes value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"bytes",value:e.value})}return null},K.prototype.decode=function(e,t){var r=H(e,t,this.localName);return r.value=this.coerceFunc("bytes",h.hexlify(r.value)),r},K);function K(e,t){return z.call(this,e,"bytes","bytes",t,!0)||this}var q,W=(i(Z,q=_),Z.prototype.encode=function(e){return"string"!=typeof e&&l.throwError("invalid string value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"string",value:e}),G(f.toUtf8Bytes(e))},Z.prototype.decode=function(e,t){var r=H(e,t,this.localName);return r.value=this.coerceFunc("string",f.toUtf8String(r.value)),r},Z);function Z(e,t){return q.call(this,e,"string","string",t,!0)||this}function J(e){return 32*Math.ceil(e/32)}function X(e,r){var t;Array.isArray(r)||(r&&"object"==typeof r?(t=[],e.forEach(function(e){t.push(r[e.localName])}),r=t):l.throwError("invalid tuple value",l.INVALID_ARGUMENT,{coderType:"tuple",value:r})),e.length!==r.length&&l.throwError("types/value length mismatch",l.INVALID_ARGUMENT,{coderType:"tuple",value:r});var n=[];e.forEach(function(e,t){n.push({dynamic:e.dynamic,value:e.encode(r[t])})});var i=0,o=0;n.forEach(function(e){e.dynamic?(i+=32,o+=J(e.value.length)):i+=J(e.value.length)});var s=0,a=i,u=new Uint8Array(i+o);return n.forEach(function(e){e.dynamic?(u.set(R.encode(a),s),s+=32,u.set(e.value,a),a+=J(e.value.length)):(u.set(e.value,s),s+=J(e.value.length))}),u}function $(e,n,i){var o=i,s=0,a=[];return e.forEach(function(e){var t,r;e.dynamic?(t=R.decode(n,i),(r=e.decode(n,o+t.value.toNumber())).consumed=t.consumed):r=e.decode(n,i),null!=r.value&&a.push(r.value),i+=r.consumed,s+=r.consumed}),e.forEach(function(e,t){var r=e.localName;r&&("length"===r&&(r="_length"),null==a[r]&&(a[r]=a[t]))}),{value:a,consumed:s}}var Q,Y=(i(ee,Q=_),ee.prototype.encode=function(e){Array.isArray(e)||l.throwError("expected array value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:e});var t=this.length,r=new Uint8Array(0);-1===t&&(t=e.length,r=R.encode(t)),l.checkArgumentCount(t,e.length," in coder array"+(this.localName?" "+this.localName:""));for(var n=[],i=0;i<e.length;i++)n.push(this.coder);return h.concat([r,X(n,e)])},ee.prototype.decode=function(e,t){var r=0,n=this.length;if(-1===n){try{var i=R.decode(e,t)}catch(e){l.throwError("insufficient data for dynamic array length",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:e.value})}try{n=i.value.toNumber()}catch(e){l.throwError("array count too large",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:i.value.toString()})}r+=i.consumed,t+=i.consumed}for(var o=[],s=0;s<n;s++)o.push(new A(this.coder));var a=$(o,e,t);return a.consumed+=r,a.value=this.coerceFunc(this.type,a.value),a},ee);function ee(e,t,r,n){var i=this,o=t.type+"["+(0<=r?r:"")+"]",s=-1===r||t.dynamic;return(i=Q.call(this,e,"array",o,n,s)||this).coder=t,i.length=r,i}var te,re=(i(ne,te=_),ne.prototype.encode=function(e){return X(this.coders,e)},ne.prototype.decode=function(e,t){var r=$(this.coders,e,t);return r.value=this.coerceFunc(this.type,r.value),r},ne);function ne(e,t,r){var n=this,i=!1,o=[];t.forEach(function(e){e.dynamic&&(i=!0),o.push(e.type)});var s="tuple("+o.join(",")+")";return(n=te.call(this,e,"tuple",s,r,i)||this).coders=t,n}function ie(e){e=e.trim();for(var t=[],r="",n=0,i=0;i<e.length;i++){var o=e[i];if(","===o&&0===n)t.push(r),r="";else if(r+=o,"("===o)n++;else if(")"===o&&-1===--n)throw new Error("unbalanced parenthsis")}return r&&t.push(r),t}var oe={address:F,bool:O,string:W,bytes:V};function se(e,t){var r=oe[t.type];if(r)return new r(e,t.name);var n,i,o,s,a=t.type.match(p);if(a)return(0===(u=parseInt(a[2]||"256"))||256<u||u%8!=0)&&l.throwError("invalid "+a[1]+" bit length",l.INVALID_ARGUMENT,{arg:"param",value:t}),new P(e,u/8,"int"===a[1],t.name);if(a=t.type.match(d))return(0===(u=parseInt(a[1]))||32<u)&&l.throwError("invalid bytes length",l.INVALID_ARGUMENT,{arg:"param",value:t}),new B(e,u,t.name);if(a=t.type.match(v)){var u=parseInt(a[2]||"-1");return(t=c.shallowCopy(t)).type=a[1],t=c.deepCopy(t),new Y(e,se(e,t),u,t.name)}return"tuple"===t.type.substring(0,5)?(n=e,i=t.components,o=t.name,s=[],(i=i||[]).forEach(function(e){s.push(se(n,e))}),new re(n,s,o)):""===t.type?new k(e,t.name):(l.throwError("invalid type",l.INVALID_ARGUMENT,{arg:"type",value:t.type}),null)}var ae=(ue.prototype.encode=function(e,t){e.length!==t.length&&l.throwError("types/values length mismatch",l.INVALID_ARGUMENT,{count:{types:e.length,values:t.length},value:{types:e,values:t}});var r=[];return e.forEach(function(e){var t=null,t="string"==typeof e?b(e):e;r.push(se(this.coerceFunc,t))},this),h.hexlify(new re(this.coerceFunc,r,"_").encode(t))},ue.prototype.decode=function(e,t){var r=[];return e.forEach(function(e){var t=null,t="string"==typeof e?b(e):c.deepCopy(e);r.push(se(this.coerceFunc,t))},this),new re(this.coerceFunc,r,"_").decode(h.arrayify(t),0).value},ue);function ue(e){l.checkNew(this,ue),e=e||r.defaultCoerceFunc,c.defineReadOnly(this,"coerceFunc",e)}r.AbiCoder=ae,r.defaultAbiCoder=new ae},{"../constants":3,"../errors":5,"./address":60,"./bignumber":63,"./bytes":64,"./properties":74,"./utf8":85}],60:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("bn.js")),o=e("./bytes"),s=e("./keccak256"),a=e("./rlp"),u=e("../errors");function l(e){"string"==typeof e&&e.match(/^0x[0-9A-Fa-f]{40}$/)||u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e});for(var t=(e=e.toLowerCase()).substring(2).split(""),r=new Uint8Array(40),n=0;n<40;n++)r[n]=t[n].charCodeAt(0);r=o.arrayify(s.keccak256(r));for(var i=0;i<40;i+=2)8<=r[i>>1]>>4&&(t[i]=t[i].toUpperCase()),8<=(15&r[i>>1])&&(t[i+1]=t[i+1].toUpperCase());return"0x"+t.join("")}for(var h={},f=0;f<10;f++)h[String(f)]=String(f);for(f=0;f<26;f++)h[String.fromCharCode(65+f)]=String(10+f);var c,d=Math.floor((c=9007199254740991,Math.log10?Math.log10(c):Math.log(c)/Math.LN10));function p(e){e=(e=e.toUpperCase()).substring(4)+e.substring(0,2)+"00";var t="";for(e.split("").forEach(function(e){t+=h[e]});t.length>=d;)var r=t.substring(0,d),t=parseInt(r,10)%97+t.substring(r.length);for(var n=String(98-parseInt(t,10)%97);n.length<2;)n="0"+n;return n}function v(e){var t=null;if("string"!=typeof e&&u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e}),e.match(/^(0x)?[0-9a-fA-F]{40}$/))"0x"!==e.substring(0,2)&&(e="0x"+e),t=l(e),e.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&t!==e&&u.throwError("bad address checksum",u.INVALID_ARGUMENT,{arg:"address",value:e});else if(e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){for(e.substring(2,4)!==p(e)&&u.throwError("bad icap checksum",u.INVALID_ARGUMENT,{arg:"address",value:e}),t=new i.default.BN(e.substring(4),36).toString(16);t.length<40;)t="0"+t;t=l("0x"+t)}else u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e});return t}r.getAddress=v,r.getIcapAddress=function(e){for(var t=new i.default.BN(v(e).substring(2),16).toString(36).toUpperCase();t.length<30;)t="0"+t;return"XE"+p("XE00"+t)+t},r.getContractAddress=function(e){if(!e.from)throw new Error("missing from address");var t=e.nonce;return v("0x"+s.keccak256(a.encode([v(e.from),o.stripZeros(o.hexlify(t))])).substring(26))},r.getCreate2Address=function(e){var t=e.initCodeHash;e.initCode&&(t?s.keccak256(e.initCode)!==t&&u.throwError("initCode/initCodeHash mismatch",u.INVALID_ARGUMENT,{arg:"options",value:e}):t=s.keccak256(e.initCode)),t||u.throwError("missing initCode or initCodeHash",u.INVALID_ARGUMENT,{arg:"options",value:e});var r=v(e.from),n=o.arrayify(e.salt);return 32!==n.length&&u.throwError("invalid salt",u.INVALID_ARGUMENT,{arg:"options",value:e}),v("0x"+s.keccak256(o.concat(["0xff",r,n,t])).substring(26))}},{"../errors":5,"./bytes":64,"./keccak256":71,"./rlp":76,"bn.js":9}],61:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../utils/bytes");t.exports={decode:function(e){e=atob(e);for(var t=[],r=0;r<e.length;r++)t.push(e.charCodeAt(r));return n.arrayify(t)},encode:function(e){e=n.arrayify(e);for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return btoa(t)}}},{"../utils/bytes":64}],62:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var l=e("./bytes"),n=e("./properties"),i=(o.prototype.encode=function(e){var t=l.arrayify(e);if(0===t.length)return"";for(var r=[0],n=0;n<t.length;++n){for(var i=t[n],o=0;o<r.length;++o)i+=r[o]<<8,r[o]=i%this.base,i=i/this.base|0;for(;0<i;)r.push(i%this.base),i=i/this.base|0}for(var s="",a=0;0===t[a]&&a<t.length-1;++a)s+=this._leader;for(var u=r.length-1;0<=u;--u)s+=this.alphabet[r[u]];return s},o.prototype.decode=function(e){if("string"!=typeof e)throw new TypeError("Expected String");var t=[];if(0===e.length)return new Uint8Array(t);t.push(0);for(var r=0;r<e.length;r++){var n=this._alphabetMap[e[r]];if(void 0===n)throw new Error("Non-base"+this.base+" character");for(var i=n,o=0;o<t.length;++o)i+=t[o]*this.base,t[o]=255&i,i>>=8;for(;0<i;)t.push(255&i),i>>=8}for(var s=0;e[s]===this._leader&&s<e.length-1;++s)t.push(0);return l.arrayify(new Uint8Array(t.reverse()))},o);function o(e){n.defineReadOnly(this,"alphabet",e),n.defineReadOnly(this,"base",e.length),n.defineReadOnly(this,"_alphabetMap",{}),n.defineReadOnly(this,"_leader",e.charAt(0));for(var t=0;t<e.length;t++)this._alphabetMap[e.charAt(t)]=t}var s=new(r.BaseX=i)("abcdefghijklmnopqrstuvwxyz234567");r.Base32=s;var a=new i("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");r.Base58=a},{"./bytes":64,"./properties":74}],63:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var o=n(e("bn.js")),s=e("./bytes"),a=e("./properties"),u=i(e("../errors")),l=new o.default.BN(-1);function h(e){var t=e.toString(16);return"-"===t[0]?t.length%2==0?"-0x0"+t.substring(1):"-0x"+t.substring(1):t.length%2==1?"0x0"+t:"0x"+t}function f(e){return d(y(e))}function c(e){return new p(h(e))}function d(e){var t=e._hex;return"-"===t[0]?new o.default.BN(t.substring(3),16).mul(l):new o.default.BN(t.substring(2),16)}var p=(v.prototype.fromTwos=function(e){return c(d(this).fromTwos(e))},v.prototype.toTwos=function(e){return c(d(this).toTwos(e))},v.prototype.abs=function(){return"-"===this._hex[0]?c(d(this).mul(l)):this},v.prototype.add=function(e){return c(d(this).add(f(e)))},v.prototype.sub=function(e){return c(d(this).sub(f(e)))},v.prototype.div=function(e){return y(e).isZero()&&u.throwError("division by zero",u.NUMERIC_FAULT,{operation:"divide",fault:"division by zero"}),c(d(this).div(f(e)))},v.prototype.mul=function(e){return c(d(this).mul(f(e)))},v.prototype.mod=function(e){return c(d(this).mod(f(e)))},v.prototype.pow=function(e){return c(d(this).pow(f(e)))},v.prototype.maskn=function(e){return c(d(this).maskn(e))},v.prototype.eq=function(e){return d(this).eq(f(e))},v.prototype.lt=function(e){return d(this).lt(f(e))},v.prototype.lte=function(e){return d(this).lte(f(e))},v.prototype.gt=function(e){return d(this).gt(f(e))},v.prototype.gte=function(e){return d(this).gte(f(e))},v.prototype.isZero=function(){return d(this).isZero()},v.prototype.toNumber=function(){try{return d(this).toNumber()}catch(e){u.throwError("overflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"overflow",details:e.message})}return null},v.prototype.toString=function(){return d(this).toString(10)},v.prototype.toHexString=function(){return this._hex},v.isBigNumber=function(e){return a.isType(e,"BigNumber")},v);function v(e){if(u.checkNew(this,v),a.setType(this,"BigNumber"),"string"==typeof e)s.isHexString(e)?("0x"==e&&(e="0x0"),a.defineReadOnly(this,"_hex",e)):"-"===e[0]&&s.isHexString(e.substring(1))?a.defineReadOnly(this,"_hex",e):e.match(/^-?[0-9]*$/)?(""==e&&(e="0"),a.defineReadOnly(this,"_hex",h(new o.default.BN(e)))):u.throwError("invalid BigNumber string value",u.INVALID_ARGUMENT,{arg:"value",value:e});else if("number"==typeof e){parseInt(String(e))!==e&&u.throwError("underflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"underflow",value:e,outputValue:parseInt(String(e))});try{a.defineReadOnly(this,"_hex",h(new o.default.BN(e)))}catch(e){u.throwError("overflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"overflow",details:e.message})}}else e instanceof v?a.defineReadOnly(this,"_hex",e._hex):e.toHexString?a.defineReadOnly(this,"_hex",h(f(e.toHexString()))):e._hex&&s.isHexString(e._hex)?a.defineReadOnly(this,"_hex",e._hex):s.isArrayish(e)?a.defineReadOnly(this,"_hex",h(new o.default.BN(s.hexlify(e).substring(2),16))):u.throwError("invalid BigNumber value",u.INVALID_ARGUMENT,{arg:"value",value:e})}function y(e){return p.isBigNumber(e)?e:new p(e)}r.BigNumber=p,r.bigNumberify=y},{"../errors":5,"./bytes":64,"./properties":74,"bn.js":9}],64:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var a=n(e("../errors"));function s(e){return!!e.toHexString}function u(t){return t.slice||(t.slice=function(){var e=Array.prototype.slice.call(arguments);return u(new Uint8Array(Array.prototype.slice.apply(t,e)))}),t}function l(e){if(!e||parseInt(String(e.length))!=e.length||"string"==typeof e)return!1;for(var t=0;t<e.length;t++){var r=e[t];if(r<0||256<=r||parseInt(String(r))!=r)return!1}return!0}function h(e){if(null==e&&a.throwError("cannot convert null value to array",a.INVALID_ARGUMENT,{arg:"value",value:e}),s(e)&&(e=e.toHexString()),"string"!=typeof e)return l(e)?u(new Uint8Array(e)):(a.throwError("invalid arrayify value",null,{arg:"value",value:e,type:typeof e}),null);var t=e.match(/^(0x)?[0-9a-fA-F]*$/);t||a.throwError("invalid hexidecimal string",a.INVALID_ARGUMENT,{arg:"value",value:e}),"0x"!==t[1]&&a.throwError("hex string must have 0x prefix",a.INVALID_ARGUMENT,{arg:"value",value:e}),(e=e.substring(2)).length%2&&(e="0"+e);for(var r=[],n=0;n<e.length;n+=2)r.push(parseInt(e.substr(n,2),16));return u(new Uint8Array(r))}function i(e){for(var t=[],r=0,n=0;n<e.length;n++){var i=h(e[n]);t.push(i),r+=i.length}for(var o=new Uint8Array(r),s=0,n=0;n<t.length;n++)o.set(t[n],s),s+=t[n].length;return u(o)}function o(e,t){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))&&(!t||e.length===2+2*t)}r.isHexable=s,r.isArrayish=l,r.arrayify=h,r.concat=i,r.stripZeros=function(e){var t=h(e);if(0===t.length)return t;for(var r=0;0===t[r];)r++;return r&&(t=t.slice(r)),t},r.padZeros=function(e,t){if(t<(e=h(e)).length)throw new Error("cannot pad");var r=new Uint8Array(t);return r.set(e,t-e.length),u(r)},r.isHexString=o;var f="0123456789abcdef";function c(e){if(s(e))return e.toHexString();if("number"==typeof e){e<0&&a.throwError("cannot hexlify negative value",a.INVALID_ARGUMENT,{arg:"value",value:e}),9007199254740991<=e&&a.throwError("out-of-range",a.NUMERIC_FAULT,{operartion:"hexlify",fault:"out-of-safe-range"});for(var t="";e;)t=f[15&e]+t,e=Math.floor(e/16);return t.length?(t.length%2&&(t="0"+t),"0x"+t):"0x00"}if("string"==typeof e){var r=e.match(/^(0x)?[0-9a-fA-F]*$/);return r||a.throwError("invalid hexidecimal string",a.INVALID_ARGUMENT,{arg:"value",value:e}),"0x"!==r[1]&&a.throwError("hex string must have 0x prefix",a.INVALID_ARGUMENT,{arg:"value",value:e}),e.length%2&&(e="0x0"+e.substring(2)),e}if(l(e)){for(var n=[],i=0;i<e.length;i++){var o=e[i];n.push(f[(240&o)>>4]+f[15&o])}return"0x"+n.join("")}return a.throwError("invalid hexlify value",null,{arg:"value",value:e}),"never"}function d(e,t){for(o(e)||a.throwError("invalid hex string",a.INVALID_ARGUMENT,{arg:"value",value:e});e.length<2*t+2;)e="0x0"+e.substring(2);return e}function p(e){var t,r=0,n="0x",i="0x";if((t=e)&&null!=t.r&&null!=t.s){null==e.v&&null==e.recoveryParam&&a.throwError("at least on of recoveryParam or v must be specified",a.INVALID_ARGUMENT,{argument:"signature",value:e}),n=d(e.r,32),i=d(e.s,32),"string"==typeof(r=e.v)&&(r=parseInt(r,16));var o=e.recoveryParam;null==o&&null!=e.v&&(o=1-r%2),r=27+o}else{var s=h(e);if(65!==s.length)throw new Error("invalid signature");n=c(s.slice(0,32)),i=c(s.slice(32,64)),27!==(r=s[64])&&28!==r&&(r=27+r%2)}return{r:n,s:i,recoveryParam:r-27,v:r}}r.hexlify=c,r.hexDataLength=function(e){return o(e)&&e.length%2==0?(e.length-2)/2:null},r.hexDataSlice=function(e,t,r){return o(e)||a.throwError("invalid hex data",a.INVALID_ARGUMENT,{arg:"value",value:e}),e.length%2!=0&&a.throwError("hex data length must be even",a.INVALID_ARGUMENT,{arg:"value",value:e}),t=2+2*t,null!=r?"0x"+e.substring(t,2+2*r):"0x"+e.substring(t)},r.hexStripZeros=function(e){for(o(e)||a.throwError("invalid hex string",a.INVALID_ARGUMENT,{arg:"value",value:e});3<e.length&&"0x0"===e.substring(0,3);)e="0x"+e.substring(3);return e},r.hexZeroPad=d,r.splitSignature=p,r.joinSignature=function(e){return c(i([(e=p(e)).r,e.s,e.recoveryParam?"0x1c":"0x1b"]))}},{"../errors":5}],65:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("../errors")),o=e("./bytes"),s=e("./utf8"),a=e("./keccak256"),u=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),l=new RegExp("^((.*)\\.)?([^.]+)$"),h=new RegExp("^[a-z0-9.-]*$");r.namehash=function(e){"string"!=typeof e&&i.throwError("invalid address - "+String(e),i.INVALID_ARGUMENT,{argument:"name",value:e}),(e=e.toLowerCase()).match(h)||i.throwError("contains invalid UseSTD3ASCIIRules characters",i.INVALID_ARGUMENT,{argument:"name",value:e});for(var t=u;e.length;){var r=e.match(l),n=s.toUtf8Bytes(r[3]),t=a.keccak256(o.concat([t,a.keccak256(n)]));e=r[2]||""}return o.hexlify(t)},r.id=function(e){return a.keccak256(s.toUtf8Bytes(e))},r.hashMessage=function(e){return a.keccak256(o.concat([s.toUtf8Bytes("\x19Ethereum Signed Message:\n"),s.toUtf8Bytes(String(e.length)),"string"==typeof e?s.toUtf8Bytes(e):e]))}},{"../errors":5,"./bytes":64,"./keccak256":71,"./utf8":85}],66:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var f=n(e("../errors")),c=e("../wordlists/lang-en"),a=e("./basex"),d=e("./bytes"),l=e("./bignumber"),i=e("./utf8"),o=e("./pbkdf2"),h=e("./hmac"),p=e("./properties"),v=e("./secp256k1"),y=e("./sha2"),m=l.bigNumberify("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),s=i.toUtf8Bytes("Bitcoin seed"),g=2147483648;function b(e){return(1<<e)-1<<8-e}function w(e){return d.hexZeroPad(d.hexlify(e),32)}function u(e){var t=d.hexDataSlice(y.sha256(y.sha256(e)),0,4);return a.Base58.encode(d.concat([e,t]))}var _={};r.defaultPath="m/44'/60'/0'/0/0";var M=(Object.defineProperty(A.prototype,"extendedKey",{get:function(){if(256<=this.depth)throw new Error("Depth too large!");return u(d.concat([null!=this.privateKey?"0x0488ADE4":"0x0488B21E",d.hexlify(this.depth),this.parentFingerprint,d.hexZeroPad(d.hexlify(this.index),4),this.chainCode,null!=this.privateKey?d.concat(["0x00",this.privateKey]):this.publicKey]))},enumerable:!0,configurable:!0}),A.prototype.neuter=function(){return new A(_,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,null,this.path)},A.prototype._derive=function(e){if(4294967295<e)throw new Error("invalid index - "+String(e));var t=this.path;t&&(t+="/"+(e&~g));var r=new Uint8Array(37);if(e&g){if(!this.privateKey)throw new Error("cannot derive child of neutered node");r.set(d.arrayify(this.privateKey),1),t&&(t+="'")}else r.set(d.arrayify(this.publicKey));for(var n=24;0<=n;n-=8)r[33+(n>>3)]=e>>24-n&255;var i=h.computeHmac(h.SupportedAlgorithms.sha512,this.chainCode,r),o=i.slice(0,32),s=i.slice(32),a=null,u=null;return this.privateKey?a=w(l.bigNumberify(o).add(this.privateKey).mod(m)):u=new v.KeyPair(d.hexlify(o))._addPoint(this.publicKey),new A(_,a,u,this.fingerprint,w(s),e,this.depth+1,this.mnemonic,t)},A.prototype.derivePath=function(e){var t=e.split("/");if(0===t.length||"m"===t[0]&&0!==this.depth)throw new Error("invalid path - "+e);"m"===t[0]&&t.shift();for(var r=this,n=0;n<t.length;n++){var i=t[n];if(i.match(/^[0-9]+'$/)){var o=parseInt(i.substring(0,i.length-1));if(g<=o)throw new Error("invalid path index - "+i);r=r._derive(g+o)}else{if(!i.match(/^[0-9]+$/))throw new Error("invalid path component - "+i);o=parseInt(i);if(g<=o)throw new Error("invalid path index - "+i);r=r._derive(o)}}return r},A.isHDNode=function(e){return p.isType(e,"HDNode")},A);function A(e,t,r,n,i,o,s,a,u){if(f.checkNew(this,A),e!==_)throw new Error("HDNode constructor cannot be called directly");var l;t?(l=new v.KeyPair(t),p.defineReadOnly(this,"privateKey",l.privateKey),p.defineReadOnly(this,"publicKey",l.compressedPublicKey)):(p.defineReadOnly(this,"privateKey",null),p.defineReadOnly(this,"publicKey",d.hexlify(r))),p.defineReadOnly(this,"parentFingerprint",n),p.defineReadOnly(this,"fingerprint",d.hexDataSlice(y.ripemd160(y.sha256(this.publicKey)),0,4)),p.defineReadOnly(this,"address",v.computeAddress(this.publicKey)),p.defineReadOnly(this,"chainCode",i),p.defineReadOnly(this,"index",o),p.defineReadOnly(this,"depth",s),p.defineReadOnly(this,"mnemonic",a),p.defineReadOnly(this,"path",u),p.setType(this,"HDNode")}function E(e,t){var r=d.arrayify(e);if(r.length<16||64<r.length)throw new Error("invalid seed");var n=d.arrayify(h.computeHmac(h.SupportedAlgorithms.sha512,s,r));return new M(_,w(n.slice(0,32)),null,"0x00000000",w(n.slice(32)),0,0,t,"m")}function S(e,t){t=t||"";var r=i.toUtf8Bytes("mnemonic"+t,i.UnicodeNormalizationForm.NFKD);return d.hexlify(o.pbkdf2(i.toUtf8Bytes(e,i.UnicodeNormalizationForm.NFKD),r,2048,64,"sha512"))}function k(e,t){t=t||c.langEn,f.checkNormalize();var r=t.split(e);if(r.length%3!=0)throw new Error("invalid mnemonic");for(var n=d.arrayify(new Uint8Array(Math.ceil(11*r.length/8))),i=0,o=0;o<r.length;o++){var s=t.getWordIndex(r[o].normalize("NFKD"));if(-1===s)throw new Error("invalid mnemonic");for(var a=0;a<11;a++)s&1<<10-a&&(n[i>>3]|=1<<7-i%8),i++}var u=32*r.length/3,l=b(r.length/3),h=d.arrayify(y.sha256(n.slice(0,u/8)))[0];if((h&=l)!=(n[n.length-1]&l))throw new Error("invalid checksum");return d.hexlify(n.slice(0,u/8))}function N(e,t){if((e=d.arrayify(e)).length%4!=0||e.length<16||32<e.length)throw new Error("invalid entropy");for(var r=[0],n=11,i=0;i<e.length;i++)8<n?(r[r.length-1]<<=8,r[r.length-1]|=e[i],n-=8):(r[r.length-1]<<=n,r[r.length-1]|=e[i]>>8-n,r.push(e[i]&(1<<8-n)-1),n+=3);var o=d.arrayify(y.sha256(e))[0],s=e.length/4;return o&=b(s),r[r.length-1]<<=s,r[r.length-1]|=o>>8-s,(t=t||c.langEn).join(r.map(function(e){return t.getWord(e)}))}r.HDNode=M,r.fromExtendedKey=function(e){var t=a.Base58.decode(e);82===t.length&&u(t.slice(0,78))===e||f.throwError("invalid extended key",f.INVALID_ARGUMENT,{argument:"extendedKey",value:"[REDACTED]"});var r=t[4],n=d.hexlify(t.slice(5,9)),i=parseInt(d.hexlify(t.slice(9,13)).substring(2),16),o=d.hexlify(t.slice(13,45)),s=t.slice(45,78);switch(d.hexlify(t.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new M(_,null,d.hexlify(s),n,o,i,r,null,null);case"0x0488ade4":case"0x04358394":if(0!==s[0])break;return new M(_,d.hexlify(s.slice(1)),null,n,o,i,r,null,null)}return f.throwError("invalid extended key",f.INVALID_ARGUMENT,{argument:"extendedKey",value:"[REDACTED]"})},r.fromMnemonic=function(e,t,r){return E(S(e=N(k(e,t),t),r),e)},r.fromSeed=function(e){return E(e,null)},r.mnemonicToSeed=S,r.mnemonicToEntropy=k,r.entropyToMnemonic=N,r.isValidMnemonic=function(e,t){try{return k(e,t),!0}catch(e){}return!1}},{"../errors":5,"../wordlists/lang-en":90,"./basex":62,"./bignumber":63,"./bytes":64,"./hmac":67,"./pbkdf2":73,"./properties":74,"./secp256k1":77,"./sha2":79,"./utf8":85}],67:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i,o,s=n(e("hash.js")),a=e("../utils/bytes"),u=n(e("../errors"));(o=i=r.SupportedAlgorithms||(r.SupportedAlgorithms={})).sha256="sha256",o.sha512="sha512",r.computeHmac=function(e,t,r){return i[e]||u.throwError("unsupported algorithm "+e,u.UNSUPPORTED_OPERATION,{operation:"hmac",algorithm:e}),a.arrayify(s.hmac(s[e],a.arrayify(t)).update(a.arrayify(r)).digest())}},{"../errors":5,"../utils/bytes":64,"hash.js":26}],68:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./abi-coder");r.AbiCoder=i.AbiCoder,r.defaultAbiCoder=i.defaultAbiCoder,r.formatSignature=i.formatSignature,r.formatParamType=i.formatParamType,r.parseSignature=i.parseSignature,r.parseParamType=i.parseParamType;var o=e("./address");r.getAddress=o.getAddress,r.getContractAddress=o.getContractAddress,r.getCreate2Address=o.getCreate2Address,r.getIcapAddress=o.getIcapAddress;var s=n(e("./base64"));r.base64=s;var a=e("./bignumber");r.BigNumber=a.BigNumber,r.bigNumberify=a.bigNumberify;var u=e("./bytes");r.arrayify=u.arrayify,r.concat=u.concat,r.hexDataSlice=u.hexDataSlice,r.hexDataLength=u.hexDataLength,r.hexlify=u.hexlify,r.hexStripZeros=u.hexStripZeros,r.hexZeroPad=u.hexZeroPad,r.isHexString=u.isHexString,r.joinSignature=u.joinSignature,r.padZeros=u.padZeros,r.splitSignature=u.splitSignature,r.stripZeros=u.stripZeros;var l=e("./hash");r.hashMessage=l.hashMessage,r.id=l.id,r.namehash=l.namehash;var h=n(e("./hdnode"));r.HDNode=h;var f=e("./interface");r.Interface=f.Interface;var c=e("./json-wallet");r.getJsonWalletAddress=c.getJsonWalletAddress;var d=e("./keccak256");r.keccak256=d.keccak256;var p=e("./sha2");r.sha256=p.sha256;var v=e("./solidity");r.solidityKeccak256=v.keccak256,r.solidityPack=v.pack,r.soliditySha256=v.sha256;var y=e("./random-bytes");r.randomBytes=y.randomBytes;var m=e("./networks");r.getNetwork=m.getNetwork;var g=e("./properties");r.checkProperties=g.checkProperties,r.deepCopy=g.deepCopy,r.defineReadOnly=g.defineReadOnly,r.resolveProperties=g.resolveProperties,r.shallowCopy=g.shallowCopy;var b=n(e("./rlp"));r.RLP=b;var w=e("./secp256k1");r.computeAddress=w.computeAddress,r.computePublicKey=w.computePublicKey,r.recoverAddress=w.recoverAddress,r.recoverPublicKey=w.recoverPublicKey,r.verifyMessage=w.verifyMessage;var _=e("./signing-key");r.SigningKey=_.SigningKey;var M=e("./transaction");r.populateTransaction=M.populateTransaction;var A=e("./transaction");r.parseTransaction=A.parse,r.serializeTransaction=A.serialize;var E=e("./utf8");r.formatBytes32String=E.formatBytes32String,r.parseBytes32String=E.parseBytes32String,r.toUtf8Bytes=E.toUtf8Bytes,r.toUtf8String=E.toUtf8String;var S=e("./units");r.commify=S.commify,r.formatEther=S.formatEther,r.parseEther=S.parseEther,r.formatUnits=S.formatUnits,r.parseUnits=S.parseUnits;var k=e("./web");r.fetchJson=k.fetchJson,r.poll=k.poll;var N=e("./hmac");r.SupportedAlgorithms=N.SupportedAlgorithms;var x=e("./utf8");r.UnicodeNormalizationForm=x.UnicodeNormalizationForm;var P=e("./wordlist");r.Wordlist=P.Wordlist},{"./abi-coder":59,"./address":60,"./base64":61,"./bignumber":63,"./bytes":64,"./hash":65,"./hdnode":66,"./hmac":67,"./interface":69,"./json-wallet":70,"./keccak256":71,"./networks":72,"./properties":74,"./random-bytes":75,"./rlp":76,"./secp256k1":77,"./sha2":79,"./signing-key":81,"./solidity":82,"./transaction":83,"./units":84,"./utf8":85,"./web":86,"./wordlist":87}],69:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});function s(e){for(var t in p.setType(this,"Description"),e)p.defineReadOnly(this,t,p.deepCopy(e[t],!0));Object.freeze(this)}var a,u=e("./address"),f=e("./abi-coder"),l=e("./bignumber"),c=e("./bytes"),h=e("./hash"),d=e("./keccak256"),p=e("./properties"),v=o(e("../errors")),y=function(e){p.setType(this,"Indexed"),p.defineReadOnly(this,"hash",e)},m=(i(g,a=s),g.prototype.encode=function(e,t){c.isHexString(e)||v.throwError("invalid contract bytecode",v.INVALID_ARGUMENT,{arg:"bytecode",value:e}),v.checkArgumentCount(t.length,this.inputs.length," in Interface constructor");try{return e+f.defaultAbiCoder.encode(this.inputs,t).substring(2)}catch(e){v.throwError("invalid constructor argument",v.INVALID_ARGUMENT,{arg:e.arg,reason:e.reason,value:e.value})}return null},g);function g(){return null!==a&&a.apply(this,arguments)||this}var b,w=(i(_,b=s),_.prototype.encode=function(e){v.checkArgumentCount(e.length,this.inputs.length," in interface function "+this.name);try{return this.sighash+f.defaultAbiCoder.encode(this.inputs,e).substring(2)}catch(e){v.throwError("invalid input argument",v.INVALID_ARGUMENT,{arg:e.arg,reason:e.reason,value:e.value})}return null},_.prototype.decode=function(t){try{return f.defaultAbiCoder.decode(this.outputs,c.arrayify(t))}catch(e){v.throwError("invalid data for function output",v.INVALID_ARGUMENT,{arg:"data",errorArg:e.arg,errorValue:e.value,value:t,reason:e.reason})}},_);function _(){return null!==b&&b.apply(this,arguments)||this}var M,A=(i(E,M=s),E);function E(){return null!==M&&M.apply(this,arguments)||this}var S,k=(i(N,S=s),N.prototype.encodeTopics=function(e){var n=this;e.length>this.inputs.length&&v.throwError("too many arguments for "+this.name,v.UNEXPECTED_ARGUMENT,{maxCount:e.length,expectedCount:this.inputs.length});var i=[];for(this.anonymous||i.push(this.topic),e.forEach(function(e,t){var r=n.inputs[t];r.indexed?null==e?i.push(null):"string"===r.type?i.push(h.id(e)):"bytes"===r.type?i.push(d.keccak256(e)):-1!==r.type.indexOf("[")||"tuple"===r.type.substring(0,5)?v.throwError("filtering with tuples or arrays not implemented yet; bug us on GitHub",v.NOT_IMPLEMENTED,{operation:"filter(array|tuple)"}):("address"===r.type&&u.getAddress(e),i.push(c.hexZeroPad(c.hexlify(e),32).toLowerCase())):null!=e&&v.throwError("cannot filter non-indexed parameters; must be null",v.INVALID_ARGUMENT,{argument:r.name||t,value:e})});i.length&&null===i[i.length-1];)i.pop();return i},N.prototype.decode=function(e,r){null==r||this.anonymous||(r=r.slice(1));var n,i=[],o=[],s=[];this.inputs.forEach(function(e,t){e.indexed?"string"===e.type||"bytes"===e.type||0<=e.type.indexOf("[")||"tuple"===e.type.substring(0,5)?(i.push({type:"bytes32",name:e.name||""}),s.push(!0)):(i.push(e),s.push(!1)):(o.push(e),s.push(!1))}),null!=r&&(n=f.defaultAbiCoder.decode(i,c.concat(r)));var a=f.defaultAbiCoder.decode(o,c.arrayify(e)),u={},l=0,h=0;return this.inputs.forEach(function(e,t){e.indexed?null==r?u[t]=new y(null):s[t]?u[t]=new y(n[h++]):u[t]=n[h++]:u[t]=a[l++],e.name&&(u[e.name]=u[t])}),u.length=this.inputs.length,new A(u)},N);function N(){return null!==S&&S.apply(this,arguments)||this}var x,P=(i(I,x=s),I);function I(){return null!==x&&x.apply(this,arguments)||this}var T,R=(i(O,T=s),O);function O(){return null!==T&&T.apply(this,arguments)||this}function C(e){switch(e.type){case"constructor":var t=new m({inputs:e.inputs,payable:null==e.payable||!!e.payable});this.deployFunction||(this.deployFunction=t);break;case"function":var r=f.formatSignature(e).replace(/tuple/g,""),n=h.id(r).substring(0,10),i=!1;null!=e.constant?i=e.constant:null!=e.stateMutability&&(i="view"==e.stateMutability||"pure"==e.stateMutability);t=new w({inputs:e.inputs,outputs:e.outputs,gas:e.gas,payable:null==e.payable||!!e.payable,type:i?"call":"transaction",name:e.name,signature:r,sighash:n});e.name&&(null==this.functions[e.name]?p.defineReadOnly(this.functions,e.name,t):v.warn("WARNING: Multiple definitions for "+e.name)),null==this.functions[t.signature]&&p.defineReadOnly(this.functions,t.signature,t);break;case"event":r=f.formatSignature(e).replace(/tuple/g,""),t=new k({name:e.name,signature:r,inputs:e.inputs,topic:h.id(r),anonymous:!!e.anonymous});e.name&&null==this.events[e.name]&&p.defineReadOnly(this.events,e.name,t),null==this.events[t.signature]&&p.defineReadOnly(this.events,t.signature,t);break;case"receive":case"fallback":break;default:v.warn("WARNING: unsupported ABI type - "+e.type)}}var L=(B.prototype.parseTransaction=function(e){var t=e.data.substring(0,10).toLowerCase();for(var r in this.functions)if(-1!==r.indexOf("(")){var n=this.functions[r];if(n.sighash===t){var i=f.defaultAbiCoder.decode(n.inputs,"0x"+e.data.substring(10));return new P({args:i,decode:n.decode,name:n.name,signature:n.signature,sighash:n.sighash,value:l.bigNumberify(e.value||"0")})}}return null},B.prototype.parseLog=function(e){for(var t in this.events)if(-1!==t.indexOf("(")){var r=this.events[t];if(!r.anonymous&&r.topic===e.topics[0])return new R({decode:r.decode,name:r.name,signature:r.signature,topic:r.topic,values:r.decode(e.data,e.topics)})}return null},B.isInterface=function(e){return p.isType(e,"Interface")},B.isIndexed=function(e){return p.isType(e,"Indexed")},B);function B(t){if(v.checkNew(this,B),"string"==typeof t){try{t=JSON.parse(t)}catch(e){v.throwError("could not parse ABI JSON",v.INVALID_ARGUMENT,{arg:"abi",errorMessage:e.message,value:t})}if(!Array.isArray(t))return v.throwError("invalid abi",v.INVALID_ARGUMENT,{arg:"abi",value:t}),null}p.defineReadOnly(this,"functions",{}),p.defineReadOnly(this,"events",{});var r=[];t.forEach(function(e){"string"==typeof e&&(e=f.parseSignature(e)),r.push(e)}),p.defineReadOnly(this,"abi",p.deepCopy(r,!0)),r.forEach(C,this),this.deployFunction||C.call(this,{type:"constructor",inputs:[]}),p.setType(this,"Interface")}r.Interface=L},{"../errors":5,"./abi-coder":59,"./address":60,"./bignumber":63,"./bytes":64,"./hash":65,"./keccak256":71,"./properties":74}],70:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./address");function i(e){try{var t=JSON.parse(e)}catch(e){return!1}return t.encseed&&t.ethaddr}function o(e){try{var t=JSON.parse(e)}catch(e){return!1}return!(!t.version||parseInt(t.version)!==t.version||3!==parseInt(t.version))}r.isCrowdsaleWallet=i,r.isSecretStorageWallet=o,r.getJsonWalletAddress=function(e){if(i(e))try{return n.getAddress(JSON.parse(e).ethaddr)}catch(e){return null}if(o(e))try{return n.getAddress(JSON.parse(e).address)}catch(e){return null}return null}},{"./address":60}],71:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("js-sha3"),i=e("./bytes");r.keccak256=function(e){return"0x"+n.keccak_256(i.arrayify(e))}},{"./bytes":64,"js-sha3":40}],72:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var o=n(e("../errors"));function i(r){return function(e){var t=[];return e.InfuraProvider&&t.push(new e.InfuraProvider(r)),e.EtherscanProvider&&t.push(new e.EtherscanProvider(r)),0===t.length?null:e.FallbackProvider?new e.FallbackProvider(t):t[0]}}function s(t,r){return function(e){return e.JsonRpcProvider?new e.JsonRpcProvider(t,r):null}}var a={chainId:1,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"homestead",_defaultProvider:i("homestead")},u={chainId:3,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"ropsten",_defaultProvider:i("ropsten")},l={unspecified:{chainId:0,name:"unspecified"},homestead:a,mainnet:a,morden:{chainId:2,name:"morden"},ropsten:u,testnet:u,rinkeby:{chainId:4,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"rinkeby",_defaultProvider:i("rinkeby")},goerli:{chainId:5,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"goerli",_defaultProvider:i("goerli")},kovan:{chainId:42,name:"kovan",_defaultProvider:i("kovan")},classic:{chainId:61,name:"classic",_defaultProvider:s("https://web3.gastracker.io","classic")},classicTestnet:{chainId:62,name:"classicTestnet",_defaultProvider:s("https://web3.gastracker.io/morden","classicTestnet")}};r.getNetwork=function(e){if(null==e)return null;if("number"==typeof e){for(var t in l){var r=l[t];if(r.chainId===e)return{name:r.name,chainId:r.chainId,ensAddress:r.ensAddress||null,_defaultProvider:r._defaultProvider||null}}return{chainId:e,name:"unknown"}}if("string"==typeof e){var n=l[e];return null==n?null:{name:n.name,chainId:n.chainId,ensAddress:n.ensAddress,_defaultProvider:n._defaultProvider||null}}var i=l[e.name];return i?(0!==e.chainId&&e.chainId!==i.chainId&&o.throwError("network chainId mismatch",o.INVALID_ARGUMENT,{arg:"network",value:e}),{name:e.name,chainId:i.chainId,ensAddress:e.ensAddress||i.ensAddress||null,_defaultProvider:e._defaultProvider||i._defaultProvider||null}):("number"!=typeof e.chainId&&o.throwError("invalid network chainId",o.INVALID_ARGUMENT,{arg:"network",value:e}),e)}},{"../errors":5}],73:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var m=e("../utils/bytes"),g=e("./hmac");r.pbkdf2=function(e,t,r,n,i){var o;e=m.arrayify(e),t=m.arrayify(t);var s,a,u=1,l=new Uint8Array(n),h=new Uint8Array(t.length+4);h.set(t);for(var f=1;f<=u;f++){h[t.length]=f>>24&255,h[t.length+1]=f>>16&255,h[t.length+2]=f>>8&255,h[t.length+3]=255&f;var c=g.computeHmac(i,e,h);o||(o=c.length,a=new Uint8Array(o),s=n-((u=Math.ceil(n/o))-1)*o),a.set(c);for(var d=1;d<r;d++){c=g.computeHmac(i,e,c);for(var p=0;p<o;p++)a[p]^=c[p]}var v=(f-1)*o,y=f===u?s:o;l.set(m.arrayify(a).slice(0,y),v)}return m.arrayify(l)}},{"../utils/bytes":64,"./hmac":67}],74:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("../errors"));function s(e,t,r){Object.defineProperty(e,t,{enumerable:!0,value:r,writable:!1})}function a(e,t){return e&&e._ethersType===t}r.defineReadOnly=s,r.setType=function(e,t){Object.defineProperty(e,"_ethersType",{configurable:!1,value:t,writable:!1})},r.isType=a,r.resolveProperties=function(r){var n={},i=[];return Object.keys(r).forEach(function(t){var e=r[t];e instanceof Promise?i.push(e.then(function(e){return n[t]=e,null})):n[t]=e}),Promise.all(i).then(function(){return n})},r.checkProperties=function(t,r){t&&"object"==typeof t||i.throwError("invalid object",i.INVALID_ARGUMENT,{argument:"object",value:t}),Object.keys(t).forEach(function(e){r[e]||i.throwError("invalid object key - "+e,i.INVALID_ARGUMENT,{argument:"transaction",value:t,key:e})})},r.shallowCopy=function(e){var t={};for(var r in e)t[r]=e[r];return t};var u={boolean:!0,number:!0,string:!0};r.deepCopy=function t(e,r){if(null==e||u[typeof e])return e;if(Array.isArray(e)){var n=e.map(function(e){return t(e,r)});return r&&Object.freeze(n),n}if("object"==typeof e){if(a(e,"BigNumber"))return e;if(a(e,"Description"))return e;if(a(e,"Indexed"))return e;for(var i in n={},e){var o=e[i];void 0!==o&&s(n,i,t(o,r))}return r&&Object.freeze(n),n}if("function"==typeof e)return e;throw new Error("Cannot deepCopy "+typeof e)},r.inheritable=function n(i){return function(e){var t,r;r=i,(t=e).super_=r,t.prototype=Object.create(r.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),s(e,"inherits",n(e))}}},{"../errors":5}],75:[function(o,e,s){(function(e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var r=o("../utils/bytes"),t=o("../utils/properties"),n=e.crypto||e.msCrypto;function i(e){if(e<=0||1024<e||parseInt(String(e))!=e)throw new Error("invalid length");var t=new Uint8Array(e);return n.getRandomValues(t),r.arrayify(t)}n&&n.getRandomValues||(console.log("WARNING: Missing strong random number source; using weak randomBytes"),n={getRandomValues:function(e){for(var t=0;t<20;t++)for(var r=0;r<e.length;r++)t?e[r]^=Math.trunc(256*Math.random()):e[r]=Math.trunc(256*Math.random());return e},_weakCrypto:!0}),s.randomBytes=i,!0===n._weakCrypto&&t.defineReadOnly(i,"_weakCrypto",!0)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../utils/bytes":64,"../utils/properties":74}],76:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var o=e("./bytes");function s(e){for(var t=[];e;)t.unshift(255&e),e>>=8;return t}function i(e,t,r){for(var n=0,i=0;i<r;i++)n=256*n+e[t+i];return n}function a(e,t,r,n){for(var i=[];r<t+1+n;){var o=u(e,r);if(i.push(o.result),t+1+n<(r+=o.consumed))throw new Error("invalid rlp")}return{consumed:1+n,result:i}}function u(e,t){if(0===e.length)throw new Error("invalid rlp data");if(248<=e[t]){if(t+1+(r=e[t]-247)>e.length)throw new Error("too short");if(t+1+r+(n=i(e,t+1,r))>e.length)throw new Error("to short");return a(e,t,t+1+r,r+n)}if(192<=e[t]){if(t+1+(n=e[t]-192)>e.length)throw new Error("invalid rlp data");return a(e,t,t+1,n)}if(184<=e[t]){var r;if(t+1+(r=e[t]-183)>e.length)throw new Error("invalid rlp data");if(t+1+r+(n=i(e,t+1,r))>e.length)throw new Error("invalid rlp data");return{consumed:1+r+n,result:o.hexlify(e.slice(t+1+r,t+1+r+n))}}if(128<=e[t]){var n;if(t+1+(n=e[t]-128)>e.length)throw new Error("invalid rlp data");return{consumed:1+n,result:o.hexlify(e.slice(t+1,t+1+n))}}return{consumed:1,result:o.hexlify(e[t])}}r.encode=function(e){return o.hexlify(function t(e){if(Array.isArray(e)){var r=[];return e.forEach(function(e){r=r.concat(t(e))}),r.length<=55?(r.unshift(192+r.length),r):((n=s(r.length)).unshift(247+n.length),n.concat(r))}var n,i=Array.prototype.slice.call(o.arrayify(e));return 1===i.length&&i[0]<=127?i:i.length<=55?(i.unshift(128+i.length),i):((n=s(i.length)).unshift(183+n.length),n.concat(i))}(e))},r.decode=function(e){var t=o.arrayify(e),r=u(t,0);if(r.consumed!==t.length)throw new Error("invalid rlp data");return r.result}},{"./bytes":64}],77:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("elliptic"),o=e("./address"),s=e("./bytes"),a=e("./hash"),u=e("./keccak256"),l=e("./properties"),h=n(e("../errors")),f=null;function c(){return f=f||new i.ec("secp256k1")}var d=(p.prototype.sign=function(e){var t=c().keyFromPrivate(s.arrayify(this.privateKey)).sign(s.arrayify(e),{canonical:!0});return{recoveryParam:t.recoveryParam,r:s.hexZeroPad("0x"+t.r.toString(16),32),s:s.hexZeroPad("0x"+t.s.toString(16),32),v:27+t.recoveryParam}},p.prototype.computeSharedSecret=function(e){var t=c().keyFromPrivate(s.arrayify(this.privateKey)),r=c().keyFromPublic(s.arrayify(v(e)));return s.hexZeroPad("0x"+t.derive(r.getPublic()).toString(16),32)},p.prototype._addPoint=function(e){var t=c().keyFromPublic(s.arrayify(this.publicKey)),r=c().keyFromPublic(s.arrayify(e));return"0x"+t.pub.add(r.pub).encodeCompressed("hex")},p);function p(e){var t=c().keyFromPrivate(s.arrayify(e));l.defineReadOnly(this,"privateKey",s.hexlify(t.priv.toArray("be",32))),l.defineReadOnly(this,"publicKey","0x"+t.getPublic(!1,"hex")),l.defineReadOnly(this,"compressedPublicKey","0x"+t.getPublic(!0,"hex")),l.defineReadOnly(this,"publicKeyBytes",t.getPublic().encode(null,!0))}function v(e,t){var r=s.arrayify(e);if(32!==r.length)return 33===r.length?t?s.hexlify(r):"0x"+c().keyFromPublic(r).getPublic(!1,"hex"):65===r.length?t?"0x"+c().keyFromPublic(r).getPublic(!0,"hex"):s.hexlify(r):(h.throwError("invalid public or private key",h.INVALID_ARGUMENT,{arg:"key",value:"[REDACTED]"}),null);var n=new d(r);return t?n.compressedPublicKey:n.publicKey}function y(e){var t="0x"+v(e).slice(4);return o.getAddress("0x"+u.keccak256(t).substring(26))}function m(e,t){var r=s.splitSignature(t),n={r:s.arrayify(r.r),s:s.arrayify(r.s)};return"0x"+c().recoverPubKey(s.arrayify(e),n,r.recoveryParam).encode("hex",!1)}function g(e,t){return y(m(s.arrayify(e),t))}r.KeyPair=d,r.computePublicKey=v,r.computeAddress=y,r.recoverPublicKey=m,r.recoverAddress=g,r.verifyMessage=function(e,t){return g(a.hashMessage(e),t)}},{"../errors":5,"./address":60,"./bytes":64,"./hash":65,"./keccak256":71,"./properties":74,elliptic:12}],78:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var R=n(e("aes-js")),y=n(e("scrypt-js")),O=n(e("uuid")),C=e("./signing-key"),g=i(e("./hdnode")),b=e("./address"),L=e("./bytes"),w=e("./pbkdf2"),B=e("./keccak256"),p=e("./utf8"),D=e("./random-bytes");function _(e){return"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),L.arrayify(e)}function U(e,t){for(e=String(e);e.length<t;)e="0"+e;return e}function F(e){return"string"==typeof e?p.toUtf8Bytes(e,p.UnicodeNormalizationForm.NFKC):L.arrayify(e)}function M(e,t){for(var r=e,n=t.toLowerCase().split("/"),i=0;i<n.length;i++){var o=null;for(var s in r)if(s.toLowerCase()===n[i]){o=r[s];break}if(null===o)return null;r=o}return r}r.decryptCrowdsale=function(e,t){var r=JSON.parse(e);t=F(t);var n=b.getAddress(M(r,"ethaddr")),i=_(M(r,"encseed"));if(!i||i.length%16!=0)throw new Error("invalid encseed");for(var o=w.pbkdf2(t,t,2e3,32,"sha256").slice(0,16),s=i.slice(0,16),a=i.slice(16),u=new R.default.ModeOfOperation.cbc(o,s),l=L.arrayify(u.decrypt(a)),l=R.default.padding.pkcs7.strip(l),h="",f=0;f<l.length;f++)h+=String.fromCharCode(l[f]);var c=p.toUtf8Bytes(h),d=new C.SigningKey(B.keccak256(c));if(d.address!==n)throw new Error("corrupt crowdsale wallet");return d},r.decrypt=function(e,t,d){function p(e,t){var r,n,i=_(M(m,"crypto/ciphertext"));if(L.hexlify((r=e.slice(16,32),n=i,B.keccak256(L.concat([r,n])))).substring(2)!==M(m,"crypto/mac").toLowerCase())return t(new Error("invalid password")),null;var o=function(e,t){if("aes-128-ctr"!==M(m,"crypto/cipher"))return null;var r=_(M(m,"crypto/cipherparams/iv")),n=new R.default.Counter(r),i=new R.default.ModeOfOperation.ctr(e,n);return L.arrayify(i.decrypt(t))}(e.slice(0,16),i),s=e.slice(32,64);if(!o)return t(new Error("unsupported cipher")),null;var a=new C.SigningKey(o);if(m.address&&a.address!==b.getAddress(m.address))return t(new Error("address mismatch")),null;var u=M(m,"x-ethers/locale");if("0.1"===M(m,"x-ethers/version")&&(null==u||"en"===u)){var l=_(M(m,"x-ethers/mnemonicCiphertext")),h=_(M(m,"x-ethers/mnemonicCounter")),f=new R.default.Counter(h),c=new R.default.ModeOfOperation.ctr(s,f),d=M(m,"x-ethers/path")||g.defaultPath,p=L.arrayify(c.decrypt(l)),v=g.entropyToMnemonic(p),y=g.fromMnemonic(v).derivePath(d);if(y.privateKey!=L.hexlify(o))return t(new Error("mnemonic mismatch")),null;a=new C.SigningKey(y)}return a}var m=JSON.parse(e),v=F(t);return new Promise(function(i,o){var e=M(m,"crypto/kdf");if(e&&"string"==typeof e)if("scrypt"===e.toLowerCase()){var t=_(M(m,"crypto/kdfparams/salt")),r=parseInt(M(m,"crypto/kdfparams/n")),n=parseInt(M(m,"crypto/kdfparams/r")),s=parseInt(M(m,"crypto/kdfparams/p"));if(!r||!n||!s)return void o(new Error("unsupported key-derivation function parameters"));if(0!=(r&r-1))return void o(new Error("unsupported key-derivation function parameter value for N"));if(32!==(l=parseInt(M(m,"crypto/kdfparams/dklen"))))return void o(new Error("unsupported key-derivation derived-key length"));d&&d(0),y.default(v,t,r,n,s,64,function(e,t,r){if(e)e.progress=t,o(e);else if(r){r=L.arrayify(r);var n=p(r,o);if(!n)return;d&&d(1),i(n)}else if(d)return d(t)})}else if("pbkdf2"===e.toLowerCase()){var t=_(M(m,"crypto/kdfparams/salt")),a=null,u=M(m,"crypto/kdfparams/prf");if("hmac-sha256"===u)a="sha256";else{if("hmac-sha512"!==u)return void o(new Error("unsupported prf"));a="sha512"}var l,h=parseInt(M(m,"crypto/kdfparams/c"));if(32!==(l=parseInt(M(m,"crypto/kdfparams/dklen"))))return void o(new Error("unsupported key-derivation derived-key length"));var f=w.pbkdf2(v,t,h,l,a),c=p(f,o);if(!c)return;i(c)}else o(new Error("unsupported key-derivation function"));else o(new Error("unsupported key-derivation function"))})},r.encrypt=function(e,t,w,_){"function"!=typeof w||_||(_=w,w={}),w=w||{};var M=null;if(32!==(M=C.SigningKey.isSigningKey(e)?L.arrayify(e.privateKey):L.arrayify(e)).length)throw new Error("invalid private key");var r=F(t),A=null;if(w.entropy&&(A=L.arrayify(w.entropy)),w.mnemonic)if(A){if(g.entropyToMnemonic(A)!==w.mnemonic)throw new Error("entropy and mnemonic mismatch")}else A=L.arrayify(g.mnemonicToEntropy(w.mnemonic,w.wordlist));var E=w.path;A&&!E&&(E=g.defaultPath);var S=(S=w.client)||"ethers.js",k=null,k=w.salt?L.arrayify(w.salt):D.randomBytes(32),N=null;if(w.iv){if(16!==(N=L.arrayify(w.iv)).length)throw new Error("invalid iv")}else N=D.randomBytes(16);var x=null;if(w.uuid){if(16!==(x=L.arrayify(w.uuid)).length)throw new Error("invalid uuid")}else x=D.randomBytes(16);var P=1<<17,I=8,T=1;return w.scrypt&&(w.scrypt.N&&(P=w.scrypt.N),w.scrypt.r&&(I=w.scrypt.r),w.scrypt.p&&(T=w.scrypt.p)),new Promise(function(g,b){_&&_(0),y.default(r,k,P,I,T,64,function(e,t,r){if(e)e.progress=t,b(e);else if(r){var n,i,o,s,a,u,l=(r=L.arrayify(r)).slice(0,16),h=r.slice(16,32),f=r.slice(32,64),c=new C.SigningKey(M).address,d=new R.default.Counter(N),p=new R.default.ModeOfOperation.ctr(l,d),v=L.arrayify(p.encrypt(M)),y=B.keccak256(L.concat([h,v])),m={address:c.substring(2).toLowerCase(),id:O.default.v4({random:x}),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:L.hexlify(N).substring(2)},ciphertext:L.hexlify(v).substring(2),kdf:"scrypt",kdfparams:{salt:L.hexlify(k).substring(2),n:P,dklen:32,p:T,r:I},mac:y.substring(2)}};A&&(n=D.randomBytes(16),i=new R.default.Counter(n),o=new R.default.ModeOfOperation.ctr(f,i),s=L.arrayify(o.encrypt(A)),u=(a=new Date).getUTCFullYear()+"-"+U(a.getUTCMonth()+1,2)+"-"+U(a.getUTCDate(),2)+"T"+U(a.getUTCHours(),2)+"-"+U(a.getUTCMinutes(),2)+"-"+U(a.getUTCSeconds(),2)+".0Z",m["x-ethers"]={client:S,gethFilename:"UTC--"+u+"--"+m.address,mnemonicCounter:L.hexlify(n).substring(2),mnemonicCiphertext:L.hexlify(s).substring(2),path:E,version:"0.1"},w.wordlist&&"string"==typeof w.wordlist.locale&&(m["x-ethers"].locale=w.wordlist.locale)),_&&_(1),g(JSON.stringify(m))}else if(_)return _(t)})})}},{"./address":60,"./bytes":64,"./hdnode":66,"./keccak256":71,"./pbkdf2":73,"./random-bytes":75,"./signing-key":81,"./utf8":85,"aes-js":8,"scrypt-js":44,uuid:48}],79:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("hash.js")),o=e("./bytes");r.ripemd160=function(e){return"0x"+i.default.ripemd160().update(o.arrayify(e)).digest("hex")},r.sha256=function(e){return"0x"+i.default.sha256().update(o.arrayify(e)).digest("hex")},r.sha512=function(e){return"0x"+i.default.sha512().update(o.arrayify(e)).digest("hex")}},{"./bytes":64,"hash.js":26}],80:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),e("setimmediate"),r.platform="browser"},{setimmediate:45}],81:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./hdnode"),o=e("./bytes"),s=e("./properties"),a=e("./secp256k1"),u=n(e("../errors")),l=(h.prototype.signDigest=function(e){return this.keyPair.sign(e)},h.prototype.computeSharedSecret=function(e){return this.keyPair.computeSharedSecret(o.arrayify(e))},h.isSigningKey=function(e){return s.isType(e,"SigningKey")},h);function h(e){u.checkNew(this,h);var t=null,t=i.HDNode.isHDNode(e)?(s.defineReadOnly(this,"mnemonic",e.mnemonic),s.defineReadOnly(this,"path",e.path),o.arrayify(e.privateKey)):("string"==typeof e&&e.match(/^[0-9a-f]*$/i)&&64===e.length&&(e="0x"+e),o.arrayify(e));try{32!==t.length&&u.throwError("exactly 32 bytes required",u.INVALID_ARGUMENT,{arg:"privateKey",value:"[REDACTED]"})}catch(e){var r={arg:"privateKey",reason:e.reason,value:"[REDACTED]"};e.value&&("number"==typeof e.value.length&&(r.length=e.value.length),r.type=typeof e.value),u.throwError("invalid private key",e.code,r)}s.defineReadOnly(this,"privateKey",o.hexlify(t)),s.defineReadOnly(this,"keyPair",new a.KeyPair(t)),s.defineReadOnly(this,"publicKey",this.keyPair.publicKey),s.defineReadOnly(this,"address",a.computeAddress(this.keyPair.publicKey)),s.setType(this,"SigningKey")}r.SigningKey=l},{"../errors":5,"./bytes":64,"./hdnode":66,"./properties":74,"./secp256k1":77}],82:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var u=e("./bignumber"),l=e("./bytes"),h=e("./utf8"),n=e("./keccak256"),i=e("./sha2"),f=new RegExp("^bytes([0-9]+)$"),c=new RegExp("^(u?int)([0-9]*)$"),d=new RegExp("^(.*)\\[([0-9]*)\\]$"),p="0000000000000000000000000000000000000000000000000000000000000000";function o(e,r){if(e.length!=r.length)throw new Error("type/value count mismatch");var n=[];return e.forEach(function(e,t){n.push(function t(e,r,n){switch(e){case"address":return n?l.padZeros(r,32):l.arrayify(r);case"string":return h.toUtf8Bytes(r);case"bytes":return l.arrayify(r);case"bool":return r=r?"0x01":"0x00",n?l.padZeros(r,32):l.arrayify(r)}var i=e.match(c);if(i){if((o=parseInt(i[2]||"256"))%8!=0||0===o||256<o)throw new Error("invalid number type - "+e);return n&&(o=256),r=u.bigNumberify(r).toTwos(o),l.padZeros(r,o/8)}if(i=e.match(f)){var o=parseInt(i[1]);if(String(o)!=i[1]||0===o||32<o)throw new Error("invalid number type - "+e);if(l.arrayify(r).byteLength!==o)throw new Error("invalid value for "+e);return n?l.arrayify((r+p).substring(0,66)):r}if((i=e.match(d))&&Array.isArray(r)){var s=i[1];if(parseInt(i[2]||String(r.length))!=r.length)throw new Error("invalid value for "+e);var a=[];return r.forEach(function(e){a.push(t(s,e,!0))}),l.concat(a)}throw new Error("unknown type - "+e)}(e,r[t]))}),l.hexlify(l.concat(n))}r.pack=o,r.keccak256=function(e,t){return n.keccak256(o(e,t))},r.sha256=function(e,t){return i.sha256(o(e,t))}},{"./bignumber":63,"./bytes":64,"./keccak256":71,"./sha2":79,"./utf8":85}],83:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("../constants"),a=n(e("../errors")),u=e("./secp256k1"),l=e("./address"),h=e("./bignumber"),f=e("./bytes"),c=e("./keccak256"),s=e("./properties"),d=n(e("./rlp")),o=e("../providers/abstract-provider");function p(e){return"0x"===e?i.Zero:h.bigNumberify(e)}var v=[{name:"nonce",maxLength:32},{name:"gasPrice",maxLength:32},{name:"gasLimit",maxLength:32},{name:"to",length:20},{name:"value",maxLength:32},{name:"data"}],y={chainId:!0,data:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0};r.serialize=function(r,e){s.checkProperties(r,y);var n=[];v.forEach(function(e){var t=r[e.name]||[],t=f.arrayify(f.hexlify(t));e.length&&t.length!==e.length&&0<t.length&&a.throwError("invalid length for "+e.name,a.INVALID_ARGUMENT,{arg:"transaction"+e.name,value:t}),e.maxLength&&(t=f.stripZeros(t)).length>e.maxLength&&a.throwError("invalid length for "+e.name,a.INVALID_ARGUMENT,{arg:"transaction"+e.name,value:t}),n.push(f.hexlify(t))}),null!=r.chainId&&0!==r.chainId&&(n.push(f.hexlify(r.chainId)),n.push("0x"),n.push("0x"));var t=d.encode(n);if(!e)return t;var i=f.splitSignature(e),o=27+i.recoveryParam;return 9===n.length&&(n.pop(),n.pop(),n.pop(),o+=2*r.chainId+8),n.push(f.hexlify(o)),n.push(f.stripZeros(f.arrayify(i.r))),n.push(f.stripZeros(f.arrayify(i.s))),d.encode(n)},r.parse=function(e){var t=d.decode(e);9!==t.length&&6!==t.length&&a.throwError("invalid raw transaction",a.INVALID_ARGUMENT,{arg:"rawTransactin",value:e});var r,n={nonce:p(t[0]).toNumber(),gasPrice:p(t[1]),gasLimit:p(t[2]),to:"0x"===(r=t[3])?null:l.getAddress(r),value:p(t[4]),data:t[5],chainId:0};if(6===t.length)return n;try{n.v=h.bigNumberify(t[6]).toNumber()}catch(e){return a.info(e),n}if(n.r=f.hexZeroPad(t[7],32),n.s=f.hexZeroPad(t[8],32),h.bigNumberify(n.r).isZero()&&h.bigNumberify(n.s).isZero())n.chainId=n.v,n.v=0;else{n.chainId=Math.floor((n.v-35)/2),n.chainId<0&&(n.chainId=0);var i=n.v-27,o=t.slice(0,6);0!==n.chainId&&(o.push(f.hexlify(n.chainId)),o.push("0x"),o.push("0x"),i-=2*n.chainId+8);var s=c.keccak256(d.encode(o));try{n.from=u.recoverAddress(s,{r:f.hexlify(n.r),s:f.hexlify(n.s),recoveryParam:i})}catch(e){a.info(e)}n.hash=c.keccak256(e)}return n},r.populateTransaction=function(e,t,r){o.Provider.isProvider(t)||a.throwError("missing provider",a.INVALID_ARGUMENT,{argument:"provider",value:t}),s.checkProperties(e,y);var n,i=s.shallowCopy(e);return null!=i.to&&(i.to=t.resolveName(i.to)),null==i.gasPrice&&(i.gasPrice=t.getGasPrice()),null==i.nonce&&(i.nonce=t.getTransactionCount(r)),null==i.gasLimit&&((n=s.shallowCopy(i)).from=r,i.gasLimit=t.estimateGas(n)),null==i.chainId&&(i.chainId=t.getNetwork().then(function(e){return e.chainId})),s.resolveProperties(i)}},{"../constants":3,"../errors":5,"../providers/abstract-provider":50,"./address":60,"./bignumber":63,"./bytes":64,"./keccak256":71,"./properties":74,"./rlp":76,"./secp256k1":77}],84:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i,h=e("../constants"),f=n(e("../errors")),c=e("./bignumber"),o={};function s(e){return{decimals:e.length-1,tenPower:c.bigNumberify(e)}}function d(e){var t=o[String(e).toLowerCase()];if(!t&&"number"==typeof e&&parseInt(String(e))==e&&0<=e&&e<=256){for(var r="1",n=0;n<e;n++)r+="0";t=s(r)}return t||f.throwError("invalid unitType",f.INVALID_ARGUMENT,{argument:"name",value:e}),t}function a(e,t){var r=d(t),n=(e=c.bigNumberify(e)).lt(h.Zero);n&&(e=e.mul(h.NegativeOne));for(var i=e.mod(r.tenPower).toString();i.length<r.decimals;)i="0"+i;return i=i.match(/^([0-9]*[1-9]|0)(0*)/)[1],e=e.div(r.tenPower).toString()+"."+i,n&&(e="-"+e),e}function u(e,t){null==t&&(t=18);var r=d(t);if("string"==typeof e&&e.match(/^-?[0-9.,]+$/)||f.throwError("invalid decimal value",f.INVALID_ARGUMENT,{arg:"value",value:e}),0===r.decimals)return c.bigNumberify(e);var n="-"===e.substring(0,1);n&&(e=e.substring(1)),"."===e&&f.throwError("missing value",f.INVALID_ARGUMENT,{arg:"value",value:e});var i=e.split(".");2<i.length&&f.throwError("too many decimal points",f.INVALID_ARGUMENT,{arg:"value",value:e});var o=i[0],s=i[1],o=o||"0";for((s=s||"0").length>r.decimals&&f.throwError("underflow occurred",f.NUMERIC_FAULT,{operation:"division",fault:"underflow"});s.length<r.decimals;)s+="0";var a=c.bigNumberify(o),u=c.bigNumberify(s),l=a.mul(r.tenPower).add(u);return n&&(l=l.mul(h.NegativeOne)),l}i="1",["wei","kwei","Mwei","Gwei","szabo","finney","ether"].forEach(function(e){var t=s(i);o[e.toLowerCase()]=t,o[String(t.decimals)]=t,i+="000"}),r.commify=function(e){var t=String(e).split(".");(2<t.length||!t[0].match(/^-?[0-9]*$/)||t[1]&&!t[1].match(/^[0-9]*$/)||"."===e||"-."===e)&&f.throwError("invalid value",f.INVALID_ARGUMENT,{argument:"value",value:e});var r=t[0],n="";for("-"===r.substring(0,1)&&(n="-",r=r.substring(1));"0"===r.substring(0,1);)r=r.substring(1);""===r&&(r="0");var i="";2===t.length&&(i="."+(t[1]||"0"));for(var o=[];r.length;){if(r.length<=3){o.unshift(r);break}var s=r.length-3;o.unshift(r.substring(s)),r=r.substring(0,s)}return n+o.join(",")+i},r.formatUnits=a,r.parseUnits=u,r.formatEther=function(e){return a(e,18)},r.parseEther=function(e){return u(e,18)}},{"../constants":3,"../errors":5,"./bignumber":63}],85:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var s,n,i=e("../constants"),a=e("../errors"),h=e("./bytes");function o(e,t){void 0===t&&(t=s.current),t!=s.current&&(a.checkNormalize(),e=e.normalize(t));for(var r=[],n=0;n<e.length;n++){var i=e.charCodeAt(n);if(i<128)r.push(i);else if(i<2048)r.push(i>>6|192),r.push(63&i|128);else if(55296==(64512&i)){n++;var o=e.charCodeAt(n);if(n>=e.length||56320!=(64512&o))throw new Error("invalid utf-8 string");i=65536+((1023&i)<<10)+(1023&o),r.push(i>>18|240),r.push(i>>12&63|128),r.push(i>>6&63|128),r.push(63&i|128)}else r.push(i>>12|224),r.push(i>>6&63|128),r.push(63&i|128)}return h.arrayify(r)}function u(e,t){e=h.arrayify(e);for(var r="",n=0;n<e.length;){var i=e[n++];if(i>>7!=0){var o=null,s=null;if(192==(224&i))o=1,s=127;else if(224==(240&i))o=2,s=2047;else{if(240!=(248&i)){if(t)continue;if(128==(192&i))throw new Error("invalid utf8 byte sequence; unexpected continuation byte");throw new Error("invalid utf8 byte sequence; invalid prefix")}o=3,s=65535}if(n+o>e.length){if(!t)throw new Error("invalid utf8 byte sequence; too short");for(;n<e.length&&e[n]>>6==2;n++);}else{for(var a=i&(1<<8-o-1)-1,u=0;u<o;u++){var l=e[n];if(128!=(192&l)){a=null;break}a=a<<6|63&l,n++}if(null!==a)if(a<=s){if(!t)throw new Error("invalid utf8 byte sequence; overlong")}else if(1114111<a){if(!t)throw new Error("invalid utf8 byte sequence; out-of-range")}else if(55296<=a&&a<=57343){if(!t)throw new Error("invalid utf8 byte sequence; utf-16 surrogate")}else a<=65535?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296+(a>>10&1023),56320+(1023&a)));else if(!t)throw new Error("invalid utf8 byte sequence; invalid continuation byte")}}else r+=String.fromCharCode(i)}return r}(n=s=r.UnicodeNormalizationForm||(r.UnicodeNormalizationForm={})).current="",n.NFC="NFC",n.NFD="NFD",n.NFKC="NFKC",n.NFKD="NFKD",r.toUtf8Bytes=o,r.toUtf8String=u,r.formatBytes32String=function(e){var t=o(e);if(31<t.length)throw new Error("bytes32 string must be less than 32 bytes");return h.hexlify(h.concat([t,i.HashZero]).slice(0,32))},r.parseBytes32String=function(e){var t=h.arrayify(e);if(32!==t.length)throw new Error("invalid bytes32 - not 32 bytes long");if(0!==t[31])throw new Error("invalid bytes32 string - no null terminator");for(var r=31;0===t[r-1];)r--;return u(t.slice(0,r))}},{"../constants":3,"../errors":5,"./bytes":64}],86:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var f=e("xmlhttprequest"),i=e("./base64"),o=e("./properties"),s=e("./utf8"),c=n(e("../errors"));r.fetchJson=function(e,a,u){var t,r={},l=null,h=12e4;if("string"==typeof e)l=e;else if("object"==typeof e){if(null==e.url&&c.throwError("missing URL",c.MISSING_ARGUMENT,{arg:"url"}),l=e.url,"number"==typeof e.timeout&&0<e.timeout&&(h=e.timeout),e.headers)for(var n in e.headers)r[n.toLowerCase()]={key:n,value:String(e.headers[n])};null!=e.user&&null!=e.password&&("https:"!==l.substring(0,6)&&!0!==e.allowInsecure&&c.throwError("basic authentication requires a secure https url",c.INVALID_ARGUMENT,{arg:"url",url:l,user:e.user,password:"[REDACTED]"}),t=e.user+":"+e.password,r.authorization={key:"Authorization",value:"Basic "+i.encode(s.toUtf8Bytes(t))})}return new Promise(function(n,i){function o(){null!=e&&(clearTimeout(e),e=null)}var s=new f.XMLHttpRequest,e=null,e=setTimeout(function(){null!=e&&(e=null,i(new Error("timeout")),setTimeout(function(){s.abort()},0))},h);a?(s.open("POST",l,!0),r["content-type"]={key:"Content-Type",value:"application/json"}):s.open("GET",l,!0),Object.keys(r).forEach(function(e){var t=r[e];s.setRequestHeader(t.key,t.value)}),s.onreadystatechange=function(){if(4===s.readyState){if(200!=s.status){o();var e=new Error("invalid response - "+s.status);return e.statusCode=s.status,s.responseText&&(e.responseText=s.responseText),void i(e)}var t=null;try{t=JSON.parse(s.responseText)}catch(e){o();var r=new Error("invalid json response");return r.orginialError=e,r.responseText=s.responseText,null!=a&&(r.requestBody=a),r.url=l,void i(r)}if(u)try{t=u(t)}catch(e){return o(),e.url=l,e.body=a,e.responseText=s.responseText,void i(e)}o(),n(t)}},s.onerror=function(e){o(),i(e)};try{null!=a?s.send(a):s.send()}catch(e){o();var t=new Error("connection error");t.error=e,i(t)}})},r.poll=function(u,l){return l=l||{},null==(l=o.shallowCopy(l)).floor&&(l.floor=0),null==l.ceiling&&(l.ceiling=1e4),null==l.interval&&(l.interval=250),new Promise(function(n,t){var e=null,i=!1,o=function(){return!i&&(i=!0,e&&clearTimeout(e),!0)};l.timeout&&(e=setTimeout(function(){o()&&t(new Error("timeout"))},l.timeout));var s=l.fastRetry||null,a=0;!function r(){return u().then(function(e){var t;return void 0!==e?o()&&n(e):l.onceBlock?l.onceBlock.once("block",r):i||(a++,(t=l.interval*parseInt(String(Math.random()*Math.pow(2,a))))<l.floor&&(t=l.floor),t>l.ceiling&&(t=l.ceiling),s&&(a--,t=s,s=null),setTimeout(r,t)),null},function(e){o()&&t(e)})}()})}},{"../errors":5,"./base64":61,"./properties":74,"./utf8":85,xmlhttprequest:49}],87:[function(o,e,s){(function(e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var i=o("../utils/hash"),t=o("../utils/properties");s.check=function(e){for(var t=[],r=0;r<2048;r++){var n=e.getWord(r);if(r!==e.getWordIndex(n))return"0x";t.push(n)}return i.id(t.join("\n")+"\n")};var r=(n.prototype.split=function(e){return e.toLowerCase().split(/ +/g)},n.prototype.join=function(e){return e.join(" ")},n);function n(e){t.defineReadOnly(this,"locale",e)}s.Wordlist=r,s.register=function(e,t){t=t||e.locale}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../utils/hash":65,"../utils/properties":74}],88:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./utils/bytes"),u=e("./utils/hash"),l=e("./utils/hdnode"),h=e("./utils/json-wallet"),f=e("./utils/keccak256"),c=e("./utils/properties"),d=e("./utils/random-bytes"),p=o(e("./utils/secret-storage")),v=e("./utils/signing-key"),y=e("./utils/transaction"),m=e("./abstract-signer"),g=e("./providers/abstract-provider"),b=o(e("./errors")),w=(s=m.Signer,i(_,s),Object.defineProperty(_.prototype,"address",{get:function(){return this.signingKey.address},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"mnemonic",{get:function(){return this.signingKey.mnemonic},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"path",{get:function(){return this.signingKey.path},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"privateKey",{get:function(){return this.signingKey.privateKey},enumerable:!0,configurable:!0}),_.prototype.connect=function(e){return g.Provider.isProvider(e)||b.throwError("invalid provider",b.INVALID_ARGUMENT,{argument:"provider",value:e}),new _(this.signingKey,e)},_.prototype.getAddress=function(){return Promise.resolve(this.address)},_.prototype.sign=function(e){var n=this;return c.resolveProperties(e).then(function(e){var t=y.serialize(e),r=n.signingKey.signDigest(f.keccak256(t));return y.serialize(e,r)})},_.prototype.signMessage=function(e){return Promise.resolve(a.joinSignature(this.signingKey.signDigest(u.hashMessage(e))))},_.prototype.getBalance=function(e){if(!this.provider)throw new Error("missing provider");return this.provider.getBalance(this.address,e)},_.prototype.getTransactionCount=function(e){if(!this.provider)throw new Error("missing provider");return this.provider.getTransactionCount(this.address,e)},_.prototype.sendTransaction=function(e){var t=this;if(!this.provider)throw new Error("missing provider");return null==e.nonce&&((e=c.shallowCopy(e)).nonce=this.getTransactionCount("pending")),y.populateTransaction(e,this.provider,this.address).then(function(e){return t.sign(e).then(function(e){return t.provider.sendTransaction(e)})})},_.prototype.encrypt=function(e,t,r){if("function"!=typeof t||r||(r=t,t={}),r&&"function"!=typeof r)throw new Error("invalid callback");return t=t||{},this.mnemonic&&((t=c.shallowCopy(t)).mnemonic=this.mnemonic,t.path=this.path),p.encrypt(this.privateKey,e,t,r)},_.createRandom=function(e){var t=d.randomBytes(16);(e=e||{}).extraEntropy&&(t=a.arrayify(f.keccak256(a.concat([t,e.extraEntropy])).substring(0,34)));var r=l.entropyToMnemonic(t,e.locale);return _.fromMnemonic(r,e.path,e.locale)},_.fromEncryptedJson=function(e,t,r){if(h.isCrowdsaleWallet(e))try{r&&r(0);var n=p.decryptCrowdsale(e,t);return r&&r(1),Promise.resolve(new _(n))}catch(e){return Promise.reject(e)}else if(h.isSecretStorageWallet(e))return p.decrypt(e,t,r).then(function(e){return new _(e)});return Promise.reject("invalid wallet JSON")},_.fromMnemonic=function(e,t,r){return t=t||l.defaultPath,new _(l.fromMnemonic(e,r).derivePath(t))},_);function _(e,t){var r=s.call(this)||this;return b.checkNew(r,_),v.SigningKey.isSigningKey(e)?c.defineReadOnly(r,"signingKey",e):c.defineReadOnly(r,"signingKey",new v.SigningKey(e)),c.defineReadOnly(r,"provider",t),r}r.Wallet=w},{"./abstract-signer":2,"./errors":5,"./providers/abstract-provider":50,"./utils/bytes":64,"./utils/hash":65,"./utils/hdnode":66,"./utils/json-wallet":70,"./utils/keccak256":71,"./utils/properties":74,"./utils/random-bytes":75,"./utils/secret-storage":78,"./utils/signing-key":81,"./utils/transaction":83}],89:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../wordlists/lang-en").langEn;r.en=n},{"../wordlists/lang-en":90}],90:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(r,"__esModule",{value:!0});var o,s=e("../utils/wordlist"),a="AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo",u=null;function l(e){if(null==u&&(u=a.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" "),"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"!==s.check(e)))throw u=null,new Error("BIP39 Wordlist for en (English) FAILED")}function h(){return o.call(this,"en")||this}var f=new(o=s.Wordlist,i(h,o),h.prototype.getWord=function(e){return l(this),u[e]},h.prototype.getWordIndex=function(e){return l(this),u.indexOf(e)},h);r.langEn=f,s.register(f)},{"../utils/wordlist":87}]},{},[7])(7)});
//# sourceMappingURL=ethers.min.js.map

      };
    };
  }
}, {package:"ethers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha256\\src\\sha256.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\js-sha256\src\sha256.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = (0,eval)("require('crypto')");
    var Buffer = (0,eval)("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha256",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha256\\src\\sha256.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\constants.js","bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multihashes\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const bs58 = require('bs58')

const cs = require('./constants')

exports.names = cs.names
exports.codes = cs.codes
exports.defaultLengths = cs.defaultLengths

const varint = require('varint')

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return hash.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Buffer} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!Buffer.isBuffer(hash)) {
    throw new Error('must be passed a buffer')
  }

  return bs58.encode(hash)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Buffer} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  let encoded = hash
  if (Buffer.isBuffer(hash)) {
    encoded = hash.toString()
  }

  return Buffer.from(bs58.decode(encoded))
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Buffer} buf
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (buf) {
  if (!(Buffer.isBuffer(buf))) {
    throw new Error('multihash must be a Buffer')
  }

  if (buf.length < 3) {
    throw new Error('multihash too short. must be > 3 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 1) {
    throw new Error(`multihash invalid length: 0x${len.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code: code,
    name: cs.codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Buffer} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(Buffer.isBuffer(digest))) {
    throw new Error('digest should be a Buffer')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  return Buffer.concat([
    Buffer.from(varint.encode(hashfn)),
    Buffer.from(varint.encode(length)),
    digest
  ])
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (cs.names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = cs.names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (cs.codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Buffer} multihash
 * @returns {undefined}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return multihash.slice(0, 2)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashes",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\src\\ipfs-pubsub.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ipfs-pubsub-peer-monitor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-peer-monitor\\src\\ipfs-pubsub-peer-monitor.js","logplease":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js","p-series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-series\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-pubsub\src\ipfs-pubsub.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pSeries = require('p-series')
const PeerMonitor = require('ipfs-pubsub-peer-monitor')

const Logger = require('logplease')
const logger = Logger.create("pubsub", { color: Logger.Colors.Yellow })
Logger.setLogLevel('ERROR')

const maxTopicsOpen = 256
let topicsOpenCount = 0

class IPFSPubsub {
  constructor(ipfs, id) {
    this._ipfs = ipfs
    this._id = id
    this._subscriptions = {}

    if (this._ipfs.pubsub === null)
      logger.error("The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.")

    this._handleMessage = this._handleMessage.bind(this)

    // Bump up the number of listeners we can have open,
    // ie. number of databases replicating
    if (this._ipfs.setMaxListeners)
      this._ipfs.setMaxListeners(maxTopicsOpen)
  }

  async subscribe(topic, onMessageCallback, onNewPeerCallback) {
    if(!this._subscriptions[topic] && this._ipfs.pubsub) {
      await this._ipfs.pubsub.subscribe(topic, this._handleMessage)

      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic)

      topicMonitor.on('join', (peer) => {
        logger.debug(`Peer joined ${topic}:`)
        logger.debug(peer)
        if (this._subscriptions[topic]) {
          onNewPeerCallback(topic, peer)
        } else {
          logger.warn('Peer joined a room we don\'t have a subscription for')
          logger.warn(topic, peer)
        }
      })

      topicMonitor.on('leave', (peer) => logger.debug(`Peer ${peer} left ${topic}`))
      topicMonitor.on('error', (e) => logger.error(e))

      this._subscriptions[topic] = {
        topicMonitor: topicMonitor,
        onMessage: onMessageCallback,
        onNewPeer: onNewPeerCallback
      }

      topicsOpenCount ++
      logger.debug("Topics open:", topicsOpenCount)
    }
  }

  async unsubscribe(hash) {
    if(this._subscriptions[hash]) {
      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage)
      this._subscriptions[hash].topicMonitor.stop()
      delete this._subscriptions[hash]
      logger.debug(`Unsubscribed from '${hash}'`)
      topicsOpenCount --
      logger.debug("Topics open:", topicsOpenCount)
    }
  }

  publish(topic, message) {
    if(this._subscriptions[topic] && this._ipfs.pubsub) {
      this._ipfs.pubsub.publish(topic, Buffer.from(JSON.stringify(message)))
    }
  }

  async disconnect() {
    const topics = Object.keys(this._subscriptions)
    await pSeries(topics.map((t) => this.unsubscribe.bind(this, t)))
    this._subscriptions = {}
  }

  async _handleMessage(message) {
    // Don't process our own messages
    if (message.from === this._id)
      return

    // Get the message content and a subscription
    let content, subscription, topicId
    try {
      // Get the topic
      topicId = message.topicIDs[0]
      content = JSON.parse(message.data)
      subscription = this._subscriptions[topicId]
    } catch (e) {
      logger.error(e)
      logger.error('Couldn\'t parse pubsub message:', message)
    }

    if(subscription && subscription.onMessage && content) {
      await subscription.onMessage(topicId, content)
    }
  }
}

module.exports = IPFSPubsub

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-pubsub\\src\\ipfs-pubsub.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log.js", {"./default-access-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\default-access-controller.js","./entry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry.js","./entry-index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry-index.js","./g-set":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\g-set.js","./lamport-clock":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js","./log-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-errors.js","./log-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-io.js","./log-sorting":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-sorting.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","p-each-series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-each-series\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\log.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pEachSeries = require('p-each-series')
const GSet = require('./g-set')
const Entry = require('./entry')
const LogIO = require('./log-io')
const LogError = require('./log-errors')
const Clock = require('./lamport-clock')
const Sorting = require('./log-sorting')
const { LastWriteWins, NoZeroes } = Sorting
const AccessController = require('./default-access-controller')
const { isDefined, findUniques } = require('./utils')
const EntryIndex = require('./entry-index')
const randomId = () => new Date().getTime().toString()
const getHash = e => e.hash
const flatMap = (res, acc) => res.concat(acc)
const getNextPointers = entry => entry.next
const maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time)
const uniqueEntriesReducer = (res, acc) => {
  res[acc.hash] = acc
  return res
}

/**
 * Log.
 *
 * @description
 * Log implements a G-Set CRDT and adds ordering.
 *
 * From:
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * https://hal.inria.fr/inria-00555588
 */
class Log extends GSet {
  /**
   * Create a new Log instance
   * @param {IPFS} ipfs An IPFS instance
   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)
   * @param {Object} options
   * @param {string} options.logId ID of the log
   * @param {Object} options.access AccessController (./default-access-controller)
   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log
   * @param {Array<Entry>} options.heads Set the heads of the log
   * @param {Clock} options.clock Set the clock of the log
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Log} The log instance
   */
  constructor (ipfs, identity, { logId, access, entries, heads, clock, sortFn } = {}) {
    if (!isDefined(ipfs)) {
      throw LogError.IPFSNotDefinedError()
    }

    if (!isDefined(identity)) {
      throw new Error('Identity is required')
    }

    if (!isDefined(access)) {
      access = new AccessController()
    }

    if (isDefined(entries) && !Array.isArray(entries)) {
      throw new Error(`'entries' argument must be an array of Entry instances`)
    }

    if (isDefined(heads) && !Array.isArray(heads)) {
      throw new Error(`'heads' argument must be an array`)
    }

    if (!isDefined(sortFn)) {
      sortFn = LastWriteWins
    }

    super()

    this._sortFn = NoZeroes(sortFn)

    this._storage = ipfs
    this._id = logId || randomId()

    // Access Controller
    this._access = access
    // Identity
    this._identity = identity

    // Add entries to the internal cache
    entries = entries || []
    this._entryIndex = new EntryIndex(entries.reduce(uniqueEntriesReducer, {}))

    // Set heads if not passed as an argument
    heads = heads || Log.findHeads(entries)
    this._headsIndex = heads.reduce(uniqueEntriesReducer, {})

    // Index of all next pointers in this log
    this._nextsIndex = {}
    const addToNextsIndex = e => e.next.forEach(a => (this._nextsIndex[a] = e.hash))
    entries.forEach(addToNextsIndex)

    // Set the length, we calculate the length manually internally
    this._length = entries.length

    // Set the clock
    const maxTime = Math.max(clock ? clock.time : 0, this.heads.reduce(maxClockTimeReducer, 0))
    // Take the given key as the clock id is it's a Key instance,
    // otherwise if key was given, take whatever it is,
    // and if it was null, take the given id as the clock id
    this._clock = new Clock(this._identity.publicKey, maxTime)
  }

  /**
   * Returns the ID of the log.
   * @returns {string}
   */
  get id () {
    return this._id
  }

  /**
   * Returns the clock of the log.
   * @returns {string}
   */
  get clock () {
    return this._clock
  }

  /**
   * Returns the length of the log.
   * @return {number} Length
   */
  get length () {
    return this._length
  }

  /**
   * Returns the values in the log.
   * @returns {Array<Entry>}
   */
  get values () {
    return Object.values(this.traverse(this.heads)).reverse()
  }

  /**
   * Returns an array of heads as hashes.
   * @returns {Array<string>}
   */
  get heads () {
    return Object.values(this._headsIndex).sort(this._sortFn).reverse()
  }

  /**
   * Returns an array of Entry objects that reference entries which
   * are not in the log currently.
   * @returns {Array<Entry>}
   */
  get tails () {
    return Log.findTails(this.values)
  }

  /**
   * Returns an array of hashes that are referenced by entries which
   * are not in the log currently.
   * @returns {Array<string>} Array of hashes
   */
  get tailHashes () {
    return Log.findTailHashes(this.values)
  }

  /**
   * Set the identity for the log
   * @param {Identity} [identity] The identity to be set
   */
  setIdentity (identity) {
    this._identity = identity
    // Find the latest clock from the heads
    const time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0))
    this._clock = new Clock(this._identity.publicKey, time)
  }

  /**
   * Find an entry.
   * @param {string} [hash] The hashes of the entry
   * @returns {Entry|undefined}
   */
  get (hash) {
    return this._entryIndex.get(hash)
  }

  /**
   * Checks if a entry is part of the log
   * @param {string} hash The hash of the entry
   * @returns {boolean}
   */
  has (entry) {
    return this._entryIndex.get(entry.hash || entry) !== undefined
  }

  traverse (rootEntries, amount = -1, endHash) {
    // Sort the given given root entries and use as the starting stack
    var stack = rootEntries.sort(this._sortFn).reverse()
    // Cache for checking if we've processed an entry already
    let traversed = {}
    // End result
    let result = {}
    // We keep a counter to check if we have traversed requested amount of entries
    let count = 0

    // Named function for getting an entry from the log
    const getEntry = e => this.get(e)

    // Add an entry to the stack and traversed nodes index
    const addToStack = entry => {
      // If we've already processed the entry, don't add it to the stack
      if (!entry || traversed[entry.hash]) {
        return
      }

      // Add the entry in front of the stack and sort
      stack = [entry, ...stack]
        .sort(this._sortFn)
        .reverse()

      // Add to the cache of processed entries
      traversed[entry.hash] = true
    }

    // Start traversal
    // Process stack until it's empty (traversed the full log)
    // or when we have the requested amount of entries
    // If requested entry amount is -1, traverse all
    while (stack.length > 0 && (amount === -1 || count < amount)) { // eslint-disable-line no-unmodified-loop-condition
      // Get the next element from the stack
      const entry = stack.shift()

      // Add to the result
      count++
      result[entry.hash] = entry
      // Add entry's next references to the stack
      entry.next.map(getEntry)
        .filter(isDefined)
        .forEach(addToStack)

      // If it is the specified end hash, break out of the while loop
      if (entry.hash === endHash) break
    }

    return result
  }

  /**
   * Append an entry to the log.
   * @param {Entry} entry Entry to add
   * @return {Log} New Log containing the appended value
   */
  async append (data, pointerCount = 1) {
    // Update the clock (find the latest clock)
    const newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1
    this._clock = new Clock(this.clock.id, newTime)

    // Get the required amount of hashes to next entries (as per current state of the log)
    const references = this.traverse(this.heads, Math.max(pointerCount, this.heads.length))

    const sortedHeadIndex = this.heads.reverse().reduce(uniqueEntriesReducer, {})
    const nexts = Object.keys(Object.assign({}, sortedHeadIndex, references))
    // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS
    // Create the entry and add it to the internal cache
    const entry = await Entry.create(
      this._storage,
      this._identity,
      this.id,
      data,
      nexts,
      this.clock
    )

    const canAppend = await this._access.canAppend(entry, this._identity.provider)
    if (!canAppend) {
      throw new Error(`Could not append entry, key "${this._identity.id}" is not allowed to write to the log`)
    }

    this._entryIndex.set(entry.hash, entry)
    nexts.forEach(e => (this._nextsIndex[e] = entry.hash))
    this._headsIndex = {}
    this._headsIndex[entry.hash] = entry
    // Update the length
    this._length++
    return entry
  }

  /*
   * Creates a javscript iterator over log entries
   *
   * @param {Object} options
   * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive
   * @param {string|Array} options.gte Beginning hash of the iterator, inclusive
   * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive
   * @param {string|Array} options.lte Ending hash of the iterator, inclusive
   * @param {amount} options.amount Number of entried to return to / from the gte / lte hash
   * @returns {Symbol.Iterator} Iterator object containing log entries
   *
   * @examples
   *
   * (async () => {
   *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })
   *
   *   for (let i = 0; i <= 100; i++) {
   *     await log1.append('entry' + i)
   *   }
   *
   *   let it = log1.iterator({
   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',
   *     amount: 10
   *   })
   *
   *   [...it].length // 10
   * })()
   *
   *
   */
  iterator ({ gt = undefined, gte = undefined, lt = undefined, lte = undefined, amount = -1 } =
  {}) {
    if (amount === 0) return (function * () {})()
    if (typeof lte === 'string') lte = [this.get(lte)]
    if (typeof lt === 'string') lt = [this.get(this.get(lt).next)]

    if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray()
    if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray()

    let start = lte || (lt || this.heads)
    let endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null
    let count = endHash ? -1 : amount || -1

    let entries = this.traverse(start, count, endHash)
    let entryValues = Object.values(entries)

    // Strip off last entry if gt is non-inclusive
    if (gt) entryValues.pop()

    // Deal with the amount argument working backwards from gt/gte
    if ((gt || gte) && amount > -1) {
      entryValues = entryValues.slice(entryValues.length - amount, entryValues.length)
    }

    return (function * () {
      for (let i in entryValues) {
        yield entryValues[i]
      }
    })()
  }

  /**
   * Join two logs.
   *
   * Joins another log into this one.
   *
   * @param {Log} log Log to join with this Log
   * @param {number} [size=-1] Max size of the joined log
   * @returns {Promise<Log>} This Log instance
   * @example
   * await log1.join(log2)
   */
  async join (log, size = -1) {
    if (!isDefined(log)) throw LogError.LogNotDefinedError()
    if (!Log.isLog(log)) throw LogError.NotALogError()
    if (this.id !== log.id) return

    // Get the difference of the logs
    const newItems = Log.difference(log, this)

    const identityProvider = this._identity.provider
    // Verify if entries are allowed to be added to the log and throws if
    // there's an invalid entry
    const permitted = async (entry) => {
      const canAppend = await this._access.canAppend(entry, identityProvider)
      if (!canAppend) {
        throw new Error(`Could not append entry, key "${entry.identity.id}" is not allowed to write to the log`)
      }
    }

    // Verify signature for each entry and throws if there's an invalid signature
    const verify = async (entry) => {
      const isValid = await Entry.verify(identityProvider, entry)
      const publicKey = entry.identity ? entry.identity.publicKey : entry.key
      if (!isValid) throw new Error(`Could not validate signature "${entry.sig}" for entry "${entry.hash}" and key "${publicKey}"`)
    }

    const entriesToJoin = Object.values(newItems)
    await pEachSeries(entriesToJoin, async e => {
      await permitted(e)
      await verify(e)
    })

    // Update the internal next pointers index
    const addToNextsIndex = e => {
      const entry = this.get(e.hash)
      if (!entry) this._length++ /* istanbul ignore else */
      e.next.forEach(a => (this._nextsIndex[a] = e.hash))
    }
    Object.values(newItems).forEach(addToNextsIndex)

    // Update the internal entry index
    this._entryIndex.add(newItems)

    // Merge the heads
    const notReferencedByNewItems = e => !nextsFromNewItems.find(a => a === e.hash)
    const notInCurrentNexts = e => !this._nextsIndex[e.hash]
    const nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, [])
    const mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex)))
      .filter(notReferencedByNewItems)
      .filter(notInCurrentNexts)
      .reduce(uniqueEntriesReducer, {})

    this._headsIndex = mergedHeads

    // Slice to the requested size
    if (size > -1) {
      let tmp = this.values
      tmp = tmp.slice(-size)
      this._entryIndex = null
      this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}))
      this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {})
      this._length = this._entryIndex.length
    }

    // Find the latest clock from the heads
    const maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0)
    this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock))
    return this
  }

  /**
   * Get the log in JSON format.
   * @returns {Object} An object with the id and heads properties
   */
  toJSON () {
    return {
      id: this.id,
      heads: this.heads
        .sort(this._sortFn) // default sorting
        .reverse() // we want the latest as the first element
        .map(getHash) // return only the head hashes
    }
  }

  /**
   * Get the log in JSON format as a snapshot.
   * @returns {Object} An object with the id, heads and value properties
   */
  toSnapshot () {
    return {
      id: this.id,
      heads: this.heads,
      values: this.values
    }
  }

  /**
   * Get the log as a Buffer.
   * @returns {Buffer}
   */
  toBuffer () {
    return Buffer.from(JSON.stringify(this.toJSON()))
  }

  /**
   * Returns the log entries as a formatted string.
   * @returns {string}
   * @example
   * two
   * └─one
   *   └─three
   */
  toString (payloadMapper) {
    return this.values
      .slice()
      .reverse()
      .map((e, idx) => {
        const parents = Entry.findChildren(e, this.values)
        const len = parents.length
        let padding = new Array(Math.max(len - 1, 0))
        padding = len > 1 ? padding.fill('  ') : padding
        padding = len > 0 ? padding.concat(['└─']) : padding
        /* istanbul ignore next */
        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload)
      })
      .join('\n')
  }

  /**
   * Check whether an object is a Log instance.
   * @param {Object} log An object to check
   * @returns {boolean}
   */
  static isLog (log) {
    return log.id !== undefined &&
      log.heads !== undefined &&
      log._entryIndex !== undefined
  }

  /**
   * Get the log's multihash.
   * @returns {Promise<string>} Multihash of the Log as Base58 encoded stringx
   */
  toMultihash ({ format } = {}) {
    return LogIO.toMultihash(this._storage, this, { format })
  }

  /**
   * Create a log from a hashes.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} hash The log hash
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @returns {Promise<Log>}
   */
  static async fromMultihash (ipfs, identity, hash,
    { access, length = -1, exclude, onProgressCallback, sortFn, timeout, format } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromMultihash(ipfs, hash, { length, exclude, onProgressCallback, timeout, format })
    return new Log(ipfs, identity, {
      logId: data.id,
      access: access,
      entries: data.values,
      heads: data.heads,
      clock: new Clock(data.clock.id, data.clock.time),
      sortFn: sortFn
    })
  }

  /**
   * Create a log from a single entry's hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} hash The entry's hash
   * @param {Object} options
   * @param {string} options.logId The ID of the log
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @param {number} options.timeout Timeout for fetching a log entry from IPFS
   * @return {Promise<Log>} New Log
   */
  static async fromEntryHash (ipfs, identity, hash,
    { logId, access, length = -1, exclude, onProgressCallback, sortFn, timeout }) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromEntryHash(ipfs, hash, { length, exclude, onProgressCallback, timeout })
    return new Log(ipfs, identity, { logId, access, entries: data.values, sortFn })
  }

  /**
   * Create a log from a Log Snapshot JSON.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {Object} json Log snapshot as JSON object
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include in the log
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Promise<Log>} New Log
   */
  static async fromJSON (ipfs, identity, json,
    { access, length = -1, timeout, onProgressCallback, sortFn } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromJSON(ipfs, json, { length, timeout, onProgressCallback })
    return new Log(ipfs, identity, { logId: data.id, access, entries: data.values, sortFn })
  }

  /**
   * Create a new log from an Entry instance.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from
   * @param {Object} options
   * @param {AccessController} options.access The access controller instance
   * @param {number} options.length How many entries to include. Default: infinite.
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]
   * @param {Function} options.sortFn The sort function - by default LastWriteWins
   * @return {Promise<Log>} New Log
   */
  static async fromEntry (ipfs, identity, sourceEntries,
    { access, length = -1, exclude, onProgressCallback, timeout, sortFn } = {}) {
    // TODO: need to verify the entries with 'key'
    const data = await LogIO.fromEntry(ipfs, sourceEntries,
      { length, exclude, onProgressCallback, timeout })
    return new Log(ipfs, identity, { logId: data.id, access, entries: data.values, sortFn })
  }

  /**
   * Find heads from a collection of entries.
   *
   * Finds entries that are the heads of this collection,
   * ie. entries that are not referenced by other entries.
   *
   * @param {Array<Entry>} entries Entries to search heads from
   * @returns {Array<Entry>}
   */
  static findHeads (entries) {
    var indexReducer = (res, entry, idx, arr) => {
      var addToResult = e => (res[e] = entry.hash)
      entry.next.forEach(addToResult)
      return res
    }

    var items = entries.reduce(indexReducer, {})

    var exists = e => items[e.hash] === undefined
    var compareIds = (a, b) => a.clock.id > b.clock.id

    return entries.filter(exists).sort(compareIds)
  }

  // Find entries that point to another entry that is not in the
  // input array
  static findTails (entries) {
    // Reverse index { next -> entry }
    var reverseIndex = {}
    // Null index containing entries that have no parents (nexts)
    var nullIndex = []
    // Hashes for all entries for quick lookups
    var hashes = {}
    // Hashes of all next entries
    var nexts = []

    var addToIndex = (e) => {
      if (e.next.length === 0) {
        nullIndex.push(e)
      }
      var addToReverseIndex = (a) => {
        /* istanbul ignore else */
        if (!reverseIndex[a]) reverseIndex[a] = []
        reverseIndex[a].push(e)
      }

      // Add all entries and their parents to the reverse index
      e.next.forEach(addToReverseIndex)
      // Get all next references
      nexts = nexts.concat(e.next)
      // Get the hashes of input entries
      hashes[e.hash] = true
    }

    // Create our indices
    entries.forEach(addToIndex)

    var addUniques = (res, entries, idx, arr) => res.concat(findUniques(entries, 'hash'))
    var exists = e => hashes[e] === undefined
    var findFromReverseIndex = e => reverseIndex[e]

    // Drop hashes that are not in the input entries
    const tails = nexts // For every hash in nexts:
      .filter(exists) // Remove undefineds and nulls
      .map(findFromReverseIndex) // Get the Entry from the reverse index
      .reduce(addUniques, []) // Flatten the result and take only uniques
      .concat(nullIndex) // Combine with tails the have no next refs (ie. first-in-their-chain)

    return findUniques(tails, 'hash').sort(Entry.compare)
  }

  // Find the hashes to entries that are not in a collection
  // but referenced by other entries
  static findTailHashes (entries) {
    var hashes = {}
    var addToIndex = e => (hashes[e.hash] = true)
    var reduceTailHashes = (res, entry, idx, arr) => {
      var addToResult = (e) => {
        /* istanbul ignore else */
        if (hashes[e] === undefined) {
          res.splice(0, 0, e)
        }
      }
      entry.next.reverse().forEach(addToResult)
      return res
    }

    entries.forEach(addToIndex)
    return entries.reduce(reduceTailHashes, [])
  }

  static difference (a, b) {
    let stack = Object.keys(a._headsIndex)
    let traversed = {}
    let res = {}

    const pushToStack = hash => {
      if (!traversed[hash] && !b.get(hash)) {
        stack.push(hash)
        traversed[hash] = true
      }
    }

    while (stack.length > 0) {
      const hash = stack.shift()
      const entry = a.get(hash)
      if (entry && !b.get(hash) && entry.id === b.id) {
        res[entry.hash] = entry
        traversed[entry.hash] = true
        entry.next.forEach(pushToStack)
      }
    }
    return res
  }
}

module.exports = Log
module.exports.Sorting = Sorting
module.exports.AccessController = AccessController

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js", {"@stablelib/utf8":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@stablelib\\utf8\\lib\\utf8.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js","js-sha256":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha256\\src\\sha256.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\node_modules\\js-sha3\\src\\sha3.js","tweetnacl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js","uport-base64url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uport-base64url\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\node_modules\did-jwt\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
function r(r){return r&&"object"==typeof r&&"default"in r?r.default:r}var e=require("js-sha256"),t=require("js-sha3"),n=require("elliptic"),o=r(require("tweetnacl")),i=require("@stablelib/utf8"),a=require("buffer"),u=r(require("uport-base64url")),c=r(require("did-resolver"));function f(r){return a.Buffer.from(e.sha256.arrayBuffer(r))}function s(r){return"0x"+(e=a.Buffer.from(r.slice(2),"hex"),a.Buffer.from(t.keccak_256.arrayBuffer(e))).slice(-20).toString("hex");var e}var d=new n.ec("secp256k1");function h(r,e){return void 0===e&&(e=64),r.length===e?r:"0".repeat(e-r.length)+r}function l(r){return new Uint8Array(Array.prototype.slice.call(Buffer.from(r,"base64"),0))}var p=new n.ec("secp256k1");function v(r,e){void 0===e&&(e=!1);var t=u.toBuffer(r);if(t.length!==(e?65:64))throw new Error("wrong signature length");var n={r:t.slice(0,32).toString("hex"),s:t.slice(32,64).toString("hex")};return e&&(n.recoveryParam=t[64]),n}var w={ES256K:function(r,e,t){var n=f(r),o=v(e),i=t.find(function(r){return p.keyFromPublic(r.publicKeyHex,"hex").verify(n,o)});if(!i)throw new Error("Signature invalid for JWT");return i},"ES256K-R":function(r,e,t){var n=v(e,!0),o=f(r),i=p.recoverPubKey(o,n,n.recoveryParam),a=i.encode("hex"),u=i.encode("hex",!0),c=s(a),d=t.find(function(r){var e=r.publicKeyHex;return e===a||e===u||r.ethereumAddress===c});if(!d)throw new Error("Signature invalid for JWT");return d},Ed25519:function(r,e,t){var n=i.encode(r),a=l(u.toBase64(e)),c=t.find(function(r){return o.sign.detached.verify(n,a,l(r.publicKeyBase64))});if(!c)throw new Error("Signature invalid for JWT");return c}};function y(r){var e=w[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}function g(r){return"object"==typeof r&&"r"in r&&"s"in r}function m(r){return function(e,t){try{return Promise.resolve(t(e)).then(function(e){if(g(e))return function(t){var n=e.r,o=e.s,i=e.recoveryParam,c=a.Buffer.alloc(r?65:64);if(a.Buffer.from(n,"hex").copy(c,0),a.Buffer.from(o,"hex").copy(c,32),r){if(void 0===i)throw new Error("Signer did not return a recoveryParam");c[64]=i}return u.encode(c)}();throw new Error("expected a signer function that returns a signature object instead of string")})}catch(r){return Promise.reject(r)}}}y.toSignatureObject=v;var E={ES256K:m(),"ES256K-R":m(!0),Ed25519:function(r,e){try{return Promise.resolve(e(r)).then(function(r){if(g(r))throw new Error("expected a signer function that returns a string instead of signature object");return r})}catch(r){return Promise.reject(r)}}},b={ES256K:["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],"ES256K-R":["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],Ed25519:["ED25519SignatureVerification"]};function S(r){return u.encode(JSON.stringify(r))}function x(r){return r.match(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/)}function P(r){if(r.match(/^did:/))return r;if(x(r))return"did:uport:"+r;throw new Error("Not a valid DID '"+r+"'")}function k(r){if(!r)throw new Error("no JWT passed into decodeJWT");var e=r.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(e)return{header:JSON.parse(u.decode(e[1])),payload:JSON.parse(u.decode(e[2])),signature:e[3],data:e[1]+"."+e[2]};throw new Error("Incorrect format JWT")}exports.SimpleSigner=function(r){var e=d.keyFromPrivate(r);return function(r){try{var t=e.sign(f(r)),n=t.s,o=t.recoveryParam;return Promise.resolve({r:h(t.r.toString("hex")),s:h(n.toString("hex")),recoveryParam:o})}catch(r){return Promise.reject(r)}}},exports.NaclSigner=function(r){var e=l(r);return function(r){try{var t=i.encode(r),n=o.sign.detached(t,e),c=u.encode(a.Buffer.from(n));return Promise.resolve(c)}catch(r){return Promise.reject(r)}}},exports.verifyJWT=function(r,e){void 0===e&&(e={auth:null,audience:null,callbackUrl:null});try{var t=e.audience?P(e.audience):void 0,n=k(r),o=n.payload,i=n.header,a=n.signature,u=n.data;return Promise.resolve(function(r,e,t){try{var n=b[r];if(!n||0===n.length)throw new Error("No supported signature types for algorithm "+r);var o=P(e);return Promise.resolve(c(o)).then(function(e){if(!e)throw new Error("Unable to resolve DID document for "+o);var i=!t||(e.authentication||[]).map(function(r){return r.publicKey}),a=(e.publicKey||[]).filter(function(r){var e=r.type,o=r.id;return n.find(function(r){return r===e&&(!t||Array.isArray(i)&&i.indexOf(o)>=0)})});if(t&&(!a||0===a.length))throw new Error("DID document for "+o+" does not have public keys suitable for authenticationg user");if(!a||0===a.length)throw new Error("DID document for "+o+" does not have public keys for "+r);return{authenticators:a,issuer:o,doc:e}})}catch(r){return Promise.reject(r)}}(i.alg,o.iss,e.auth)).then(function(n){var c,f=n.doc,s=n.authenticators,d=n.issuer,h=y(i.alg)(u,a,s),l=Math.floor(Date.now()/1e3);if(h){if(o.iat&&o.iat>l+300)throw new Error("JWT not valid yet (issued in the future): iat: "+o.iat+" > now: "+l);if(o.exp&&o.exp<=l-300)throw new Error("JWT has expired: exp: "+o.exp+" < now: "+l);if(o.aud)if((c=o.aud)&&(c.match(/^did:/)||x(c))){if(!t)throw new Error("JWT audience is required but your app address has not been configured");if(t!==P(o.aud))throw new Error("JWT audience does not match your DID: aud: "+o.aud+" !== yours: "+t)}else{if(!e.callbackUrl)throw new Error("JWT audience matching your callback url is required but one wasn't passed in");if(o.aud!==e.callbackUrl)throw new Error("JWT audience does not match the callback url: aud: "+o.aud+" !== url: "+e.callbackUrl)}return{payload:o,doc:f,issuer:d,signer:h,jwt:r}}})}catch(r){return Promise.reject(r)}},exports.createJWT=function(r,e){var t=e.issuer,n=e.signer,o=e.alg,i=e.expiresIn;try{if(!n)throw new Error("No Signer functionality has been configured");if(!t)throw new Error("No issuing DID has been configured");var a={typ:"JWT",alg:o||"ES256K"},u={iat:Math.floor(Date.now()/1e3),exp:void 0};if(i){if("number"!=typeof i)throw new Error("JWT expiresIn is not a number");u.exp=u.iat+Math.floor(i)}var c=[S(a),S(Object.assign({},u,r,{iss:t}))].join("."),f=function(r){var e=E[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}(a.alg);return Promise.resolve(f(c,n)).then(function(r){return[c,r].join(".")})}catch(r){return Promise.reject(r)}},exports.decodeJWT=k,exports.toEthereumAddress=s;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"did-jwt",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\index.js", {"./src/identities":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\src\\identities.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-identity-provider\index.js
      return function (require, module, exports) {
'use strict'
const IdentityProvider = require('./src/identities')

module.exports = IdentityProvider

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-did-document\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-did-document\index.js
      return function (require, module, exports) {
const DID_PLACEHOLDER = 'GENESIS'

/**
 * A class for creating ipfs based DID Documents.
 * Based on the DID spec: https://w3c-ccg.github.io/did-spec/
 */
class DidDocument {
  /**
   * Create a new DID Document.
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        method          The name of the DID Method
   * @return    {DidDocument}                   self
   */
  constructor (ipfs, method) {
    this._ipfs = ipfs
    this._content = {
      id: `did:${method}:${DID_PLACEHOLDER}`
    }
  }

  get DID () {
    if (this._content.id.includes(DID_PLACEHOLDER)) {
      throw new Error('DID is not available before commit')
    }
    return this._content.id
  }

  /**
   * Load an already existing DID Document.
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        documentCid     The CID of the document
   * @return    {Promise<DidDocument>}                   self
   */
  static async load (ipfs, documentCid) {
    const doc = new DidDocument(ipfs)
    doc._content = await DidDocument.cidToDocument(ipfs, documentCid)
    doc._content.previousDocument = { '/': documentCid.toString() }
    return doc
  }

  /**
   * Add a new public key
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   * @param     {String}        type            The type of the key
   * @param     {String}        encoding        The encoding of the key
   * @param     {String}        key             The encoded public key
   * @param     {String}        owner           The owner of the key (optional)
   */
  addPublicKey (id, type, encoding, key, owner) {
    if (!this._content.publicKey) {
      this._content.publicKey = []
    }
    let entry = {
      id: `${this._content.id}#${id}`,
      type
    }
    entry[encoding] = key
    if (owner) {
      entry.owner = owner
    }
    this._content.publicKey.push(entry)
  }

  /**
   * Remove a public key
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removePublicKey (id) {
    const idx = this._content.publicKey.findIndex(e => e.id.endsWith(id))
    this._content.publicKey.splice(idx, 1)
    if (!this._content.publicKey.length) {
      delete this._content.publicKey
    }
  }

  /**
   * Add a new authentication
   *
   * @param     {String}        type            The type of the authentication
   * @param     {String}        id              The id of the key to be used, e.g. "key1"
   */
  addAuthentication (type, id) {
    if (!this._content.authentication) {
      this._content.authentication = []
    }
    this._content.authentication.push({
      type,
      publicKey: `${this._content.id}#${id}`
    })
  }

  /**
   * Remove an authentication
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removeAuthentication (id) {
    const idx = this._content.authentication.findIndex(e => e.publicKey.endsWith(id))
    this._content.authentication.splice(idx, 1)
    if (!this._content.authentication.length) {
      delete this._content.authentication
    }
  }

  /**
   * Add a new service
   *
   * @param     {String}        id                  The id of the key to be used, e.g. "key1"
   * @param     {String}        type                The type of the service
   * @param     {String}        serviceEndpoint     The endpoint of the service
   * @param     {Object}        additionalFields    Any additional fields (optional)
   */
  addService (id, type, serviceEndpoint, additionalFields) {
    if (!this._content.service) {
      this._content.service = []
    }
    this._content.service.push(Object.assign({
      id: `${this._content.id};${id}`,
      type,
      serviceEndpoint
    }, additionalFields))
  }

  /**
   * Remove a service
   *
   * @param     {String}        id              The id of the key, e.g. "key1"
   */
  removeService (id) {
    const idx = this._content.service.findIndex(e => e.id.endsWith(id))
    this._content.service.splice(idx, 1)
    if (!this._content.service.length) {
      delete this._content.service
    }
  }

  /**
   * Set the revocationMethod. This can be of any js object
   * and is determined by the implementer of a revocation module.
   *
   * @param     {Object}        methodDescriptor    the object that defines the revocation method
   */
  setRevocationMethod (methodDescriptor) {
    this._content.revocationMethod = methodDescriptor
  }

  /**
   * Add a new property
   *
   * @param     {String}        propName            The name of the property
   * @param     {Object}        propValue           The value of the property
   */
  addCustomProperty (propName, propValue) {
    this._content[propName] = propValue
  }

  /**
   * Remove a property
   *
   * @param     {String}        propName            The name of the property
   */
  removeCustomProperty (propName) {
    delete this._content[propName]
  }

  /**
   * Commit all changes and create a new ipfs dag object.
   *
   * @param     {Object}        opts                Optional parameters
   * @param     {Boolean}       noTimestamp         Don't use timestamps if true
   *
   * @return    {Promise<CID>}                   The CID of the object
   */
  async commit (opts = {}) {
    if (!this._content.created) {
      this._content['@context'] = 'https://w3id.org/did/v1'
      if (!opts.noTimestamp) {
        this._content.created = (new Date(Date.now())).toISOString()
      }
    } else if (!opts.noTimestamp) {
      this._content.updated = (new Date(Date.now())).toISOString()
    }
    const cid = await this._ipfs.dag.put(this._content, { format: 'dag-cbor', hashAlg: 'sha2-256' })
    // set up for further changes:
    this._content = await DidDocument.cidToDocument(this._ipfs, cid)
    this._content.previousDocument = { '/': cid.toString() }
    return cid
  }

  /**
   * Returns the DID document of a document CID
   *
   * @param     {Object}        ipfs            An js-ipfs instance
   * @param     {String}        documentCid     The CID of the document
   * @return    {Promise<Object>}                        The DID document as a js object
   */
  static async cidToDocument (ipfs, documentCid) {
    let doc = (await ipfs.dag.get(documentCid)).value
    // If genesis document replace placeholder identifier with cid
    if (doc.id.includes(DID_PLACEHOLDER)) {
      const re = new RegExp(DID_PLACEHOLDER, 'gi')
      doc.id = doc.id.replace(re, documentCid)
      if (doc.publicKey) {
        doc.publicKey = JSON.parse(JSON.stringify(doc.publicKey).replace(re, documentCid))
      }
      if (doc.authentication) {
        doc.authentication = JSON.parse(JSON.stringify(doc.authentication).replace(re, documentCid))
      }
      if (doc.service) {
        doc.service = JSON.parse(JSON.stringify(doc.service).replace(re, documentCid))
      }
    }
    if (doc.previousDocument) {
      // make CID human readable
      doc.previousDocument = { '/': doc.previousDocument.toString() }
    }
    return doc
  }
}

module.exports = DidDocument

      };
    };
  }
}, {package:"ipfs-did-document",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-did-document\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\index.js", {"./lib/XMLHttpRequest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\lib\\XMLHttpRequest-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-mini\src\index.js
      return function (require, module, exports) {
var XMLHttpRequest = require('./lib/XMLHttpRequest');

module.exports = IPFS;

/**
 * The varructor object
 * @param {Object} `provider` the provider object
 * @return {Object} `ipfs` returns an IPFS instance
 * @throws if the `new` flag is not used
 */
function IPFS(provider) {
  if (!(this instanceof IPFS)) { throw new Error('[ipfs-mini] IPFS instance must be instantiated with "new" flag (e.g. var ipfs = new IPFS("http://localhost:8545");).'); }

  var self = this;
  self.setProvider(provider || {});
}

/**
 * No operation method
 */
function noop() {}
function newPromise(val) { return new Promise(val); }
function noopPromise(val) { val(noop, noop); }

/**
 * Sets the provider of the IPFS instance
 * @param {Object} `provider` the provider object
 * @throws if the provider object is not an object
 */
IPFS.prototype.setProvider = function setProvider(provider) {
  if (typeof provider !== 'object') { throw new Error(`[ifpsjs] provider must be type Object, got '${typeof provider}'.`); }
  var self = this;
  var data = self.provider = Object.assign({
    host: '127.0.0.1',
    pinning: true,
    port: '5001',
    protocol: 'http',
    base: '/api/v0' }, provider || {});
  self.requestBase = String(`${data.protocol}://${data.host}:${data.port}${data.base}`);
};

/**
 * Sends an async data packet to an IPFS node
 * @param {Object} `opts` the options object
 * @param {Function} `cb` the provider callback
 * @callback returns an error if any, or the data from IPFS
 */
IPFS.prototype.sendAsync = function sendAsync(opts, cb) {
  var self = this;
  var request = new XMLHttpRequest(); // eslint-disable-line
  var options = opts || {};

  return (cb ? noopPromise : newPromise)(function (resolve, reject) {
    function callback(e, r){
      (cb || noop)(e, options.takeHash && r ? r.Hash : r);
      if (e) return reject(e);
      if (!e && r) return resolve(options.takeHash ? r.Hash : r);
    };

    request.onreadystatechange = function () {
      if (request.readyState === 4 && request.timeout !== 1) {
        if (request.status !== 200) {
          callback(new Error(`[ipfs-mini] status ${request.status}: ${request.responseText}`), null);
        } else {
          try {
            callback(null, (options.jsonParse ? JSON.parse(request.responseText) : request.responseText));
          } catch (jsonError) {
            callback(new Error(`[ipfs-mini] while parsing data: '${String(request.responseText)}', error: ${String(jsonError)} with provider: '${self.requestBase}'`, null));
          }
        }
      }
    };

    try {
      var pinningURI = self.provider.pinning && opts.uri === '/add' ? '?pin=true' : '';

      if (options.payload) {
        request.open('POST', `${self.requestBase}${opts.uri}${pinningURI}`);
      } else {
        request.open('GET', `${self.requestBase}${opts.uri}${pinningURI}`);
      }

      if (options.accept) {
        request.setRequestHeader('accept', options.accept);
      }

      if (options.payload && options.boundary) {
        request.setRequestHeader('Content-Type', `multipart/form-data; boundary=${options.boundary}`);
        request.send(options.payload);
      } else {
        request.send();
      }
    } catch (err) {
      callback(err, null);
    }
  });
};

/**
 * creates a boundary that isn't part of the payload
 */
function createBoundary(data) {
  while (true) {
    var boundary = `----IPFSMini${Math.random() * 100000}.${Math.random() * 100000}`;
    if (data.indexOf(boundary) === -1) {
      return boundary;
    }
  }
}

/**
 * Add an string or buffer to IPFS
 * @param {String|Buffer} `input` a single string or buffer
 * @param {Function} `callback` a callback, with (error, ipfsHash String)
 * @callback {String} `ipfsHash` returns an IPFS hash string
 */
IPFS.prototype.add = function addData(input, callback) {
  var data = ((typeof input === 'object' && input.isBuffer) ? input.toString('binary') : input);
  var boundary = createBoundary(data);
  var payload = `--${boundary}\r\nContent-Disposition: form-data; name="path"\r\nContent-Type: application/octet-stream\r\n\r\n${data}\r\n--${boundary}--`;

  return this.sendAsync({
    jsonParse: true,
    accept: 'application/json',
    uri: '/add',
    takeHash: true,
    payload, boundary,
  }, callback);
};

/**
 * Add an JSON object to IPFS
 * @param {Object} `jsonData` a single JSON object
 * @param {Function} `callback` a callback, with (error, ipfsHash String)
 * @callback {String} `ipfsHash` returns an IPFS hash string
 */
IPFS.prototype.addJSON = function addJson(jsonData, callback) {
  var self = this;
  return self.add(JSON.stringify(jsonData), callback);
};

/**
 * Get an object stat `/object/stat` for an IPFS hash
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, stats Object)
 * @callback {Object} `stats` returns the stats object for that IPFS hash
 */
IPFS.prototype.stat = function cat(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ jsonParse: true, uri: `/object/stat/${ipfsHash}` }, callback);
};

/**
 * Get the data from an IPFS hash
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, stats Object)
 * @callback {String} `data` returns the output data
 */
IPFS.prototype.cat = function cat(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ uri: `/cat/${ipfsHash}` }, callback);
};

/**
 * Get the data from an IPFS hash that is a JSON object
 * @param {String} `ipfsHash` a single IPFS hash String
 * @param {Function} `callback` a callback, with (error, json Object)
 * @callback {Object} `data` returns the output data JSON object
 */
IPFS.prototype.catJSON = function catJSON(ipfsHash, callback) {
  var self = this;
  return self.sendAsync({ uri: `/cat/${ipfsHash}`, jsonParse: true }, callback);
};

      };
    };
  }
}, {package:"ipfs-mini",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3id-resolver\\lib\\register.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","base64url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64url\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\index.js","did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js","ipfs-did-document":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-did-document\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3id-resolver\lib\register.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didJwt = require("did-jwt");

var _ipfsDidDocument = _interopRequireDefault(require("ipfs-did-document"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = require("did-resolver");

var PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];
var SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _didResolver.registerMethod)('3', function (_, _ref) {
    var id = _ref.id;
    return resolve(ipfs, id);
  });
}

function resolve(_x, _x2, _x3) {
  return _resolve.apply(this, arguments);
}

function _resolve() {
  _resolve = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(ipfs, cid, isRoot) {
    var doc, rootDoc;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _ipfsDidDocument["default"].cidToDocument(ipfs, cid);

          case 3:
            doc = _context.sent;
            validateDoc(doc);

            if (!doc.root) {
              _context.next = 14;
              break;
            }

            if (!isRoot) {
              _context.next = 8;
              break;
            }

            throw new Error('Only one layer subDoc allowed');

          case 8:
            _context.next = 10;
            return resolve(ipfs, doc.root.split(':')[2], true);

          case 10:
            rootDoc = _context.sent;
            _context.next = 13;
            return verifyProof(doc);

          case 13:
            doc = mergeDocuments(rootDoc, doc);

          case 14:
            _context.next = 26;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](0);
            _context.prev = 18;
            _context.next = 21;
            return ipfs.pin.rm(cid);

          case 21:
            _context.next = 25;
            break;

          case 23:
            _context.prev = 23;
            _context.t1 = _context["catch"](18);

          case 25:
            throw new Error('Invalid 3ID');

          case 26:
            return _context.abrupt("return", doc);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 16], [18, 23]]);
  }));
  return _resolve.apply(this, arguments);
}

function validateDoc(doc) {
  var pubKeyIds = PUBKEY_IDS;

  if (!doc || !doc.publicKey || !doc.authentication) {
    throw new Error('Not a valid 3ID');
  }

  if (doc.root) {
    pubKeyIds = SUB_PUBKEY_IDS;
    if (!doc.space) throw new Error('Not a valid 3ID');
  }

  doc.publicKey.map(function (entry) {
    var id = entry.id.split('#')[1];
    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');
  });
}

function encodeSection(data) {
  return _base64url["default"].encode(JSON.stringify(data));
}

function verifyProof(_x4) {
  return _verifyProof.apply(this, arguments);
}

function _verifyProof() {
  _verifyProof = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(subDoc) {
    var subSigningKey, subEncryptionKey, payload, header, jwt;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            subSigningKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[0]);
            }).publicKeyHex;
            subEncryptionKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[1]);
            }).publicKeyBase64;
            payload = encodeSection({
              iat: null,
              subSigningKey: subSigningKey,
              subEncryptionKey: subEncryptionKey,
              space: subDoc.space,
              iss: subDoc.root
            });
            header = encodeSection({
              typ: 'JWT',
              alg: subDoc.proof.alg
            });
            jwt = "".concat(header, ".").concat(payload, ".").concat(subDoc.proof.signature);
            _context2.next = 7;
            return (0, _didJwt.verifyJWT)(jwt);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _verifyProof.apply(this, arguments);
}

function mergeDocuments(doc, subDoc) {
  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);
  return subDoc;
}

module.exports = register;
      };
    };
  }
}, {package:"3id-resolver",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3id-resolver\\lib\\register.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\keyring.js", {"../utils/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\utils\\index.js","@babel/runtime/helpers/classCallCheck":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\classCallCheck.js","@babel/runtime/helpers/createClass":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\lib\\index.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\ethers\\dist\\ethers.min.js","tweetnacl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\lib\3id\keyring.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var nacl = require('tweetnacl');

nacl.util = require('tweetnacl-util');

var SimpleSigner = require('did-jwt').SimpleSigner;

var _require = require('../utils/index'),
    sha256 = _require.sha256;

var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var BASE_PATH = "m/7696500'/0'/0'";
var MM_PATH = "m/44'/60'/0'/0";

var Keyring =
/*#__PURE__*/
function () {
  function Keyring(seed) {
    (0, _classCallCheck2["default"])(this, Keyring);
    this._seed = seed;
    var seedNode = HDNode.fromSeed(this._seed);
    var baseNode = seedNode.derivePath(BASE_PATH);
    this.signingKey = baseNode.derivePath("0");
    var tmpEncKey = Buffer.from(baseNode.derivePath("2").privateKey.slice(2), 'hex');
    this.asymEncryptionKey = nacl.box.keyPair.fromSecretKey(new Uint8Array(tmpEncKey));
    this.symEncryptionKey = new Uint8Array(Buffer.from(baseNode.derivePath("3").privateKey.slice(2), 'hex'));
    this.ethereumKey = seedNode.derivePath(MM_PATH).derivePath("0");
  }

  (0, _createClass2["default"])(Keyring, [{
    key: "asymEncrypt",
    value: function asymEncrypt(msg, toPublic, nonce) {
      nonce = nonce || randomNonce();
      toPublic = nacl.util.decodeBase64(toPublic);

      if (typeof msg === 'string') {
        msg = nacl.util.decodeUTF8(msg);
      }

      var ciphertext = nacl.box(msg, nonce, toPublic, this.asymEncryptionKey.secretKey);
      return {
        nonce: nacl.util.encodeBase64(nonce),
        ciphertext: nacl.util.encodeBase64(ciphertext)
      };
    }
  }, {
    key: "asymDecrypt",
    value: function asymDecrypt(ciphertext, fromPublic, nonce, toBuffer) {
      fromPublic = nacl.util.decodeBase64(fromPublic);
      ciphertext = nacl.util.decodeBase64(ciphertext);
      nonce = nacl.util.decodeBase64(nonce);
      var cleartext = nacl.box.open(ciphertext, nonce, fromPublic, this.asymEncryptionKey.secretKey);

      if (toBuffer) {
        return cleartext ? Buffer.from(cleartext) : null;
      }

      return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
    }
  }, {
    key: "symEncrypt",
    value: function symEncrypt(msg, nonce) {
      return symEncryptBase(msg, this.symEncryptionKey, nonce);
    }
  }, {
    key: "symDecrypt",
    value: function symDecrypt(ciphertext, nonce, toBuffer) {
      return symDecryptBase(ciphertext, this.symEncryptionKey, nonce, toBuffer);
    }
  }, {
    key: "getJWTSigner",
    value: function getJWTSigner() {
      return SimpleSigner(this.signingKey.privateKey.slice(2));
    }
  }, {
    key: "getDBSalt",
    value: function getDBSalt() {
      return sha256(this.signingKey.derivePath('0').privateKey.slice(2));
    }
  }, {
    key: "getPublicKeys",
    value: function getPublicKeys(uncompressed) {
      var signingKey = this.signingKey.publicKey.slice(2);
      var ethereumKey = this.ethereumKey.publicKey.slice(2);

      if (uncompressed) {
        signingKey = ec.keyFromPublic(Buffer.from(signingKey, 'hex')).getPublic(false, 'hex');
        ethereumKey = ec.keyFromPublic(Buffer.from(ethereumKey, 'hex')).getPublic(false, 'hex');
      }

      return {
        signingKey: signingKey,
        ethereumKey: ethereumKey,
        asymEncryptionKey: nacl.util.encodeBase64(this.asymEncryptionKey.publicKey)
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this._seed;
    }
  }]);
  return Keyring;
}();

var randomNonce = function randomNonce() {
  return nacl.randomBytes(24);
};

var symEncryptBase = function symEncryptBase(msg, symKey, nonce) {
  nonce = nonce || randomNonce();

  if (typeof msg === 'string') {
    msg = nacl.util.decodeUTF8(msg);
  }

  var ciphertext = nacl.secretbox(msg, nonce, symKey);
  return {
    nonce: nacl.util.encodeBase64(nonce),
    ciphertext: nacl.util.encodeBase64(ciphertext)
  };
};

var symDecryptBase = function symDecryptBase(ciphertext, symKey, nonce, toBuffer) {
  ciphertext = nacl.util.decodeBase64(ciphertext);
  nonce = nacl.util.decodeBase64(nonce);
  var cleartext = nacl.secretbox.open(ciphertext, nonce, symKey);

  if (toBuffer) {
    return cleartext ? Buffer.from(cleartext) : null;
  }

  return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
};

module.exports = Keyring;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\lib\\3id\\keyring.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controllers.js", {"./access-controller-manifest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-manifest.js","./ipfs-access-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\ipfs-access-controller.js","./legacy-ipfs-access-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\legacy-ipfs-access-controller.js","./orbitdb-access-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\orbitdb-access-controller.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\access-controllers.js
      return function (require, module, exports) {
'use strict'

const AccessControllerManifest = require('./access-controller-manifest')
const LegacyIPFSAccessController = require('./legacy-ipfs-access-controller')
const IPFSAccessController = require('./ipfs-access-controller')
const OrbitDBAccessController = require('./orbitdb-access-controller')

let supportedTypes = {
  'legacy-ipfs': LegacyIPFSAccessController,
  'ipfs': IPFSAccessController,
  'orbitdb': OrbitDBAccessController
}

const getHandlerFor = (type) => {
  if (!AccessControllers.isSupported(type)) {
    throw new Error(`AccessController type '${type}' is not supported`)
  }
  return supportedTypes[type]
}

class AccessControllers {
  static isSupported (type) {
    return Object.keys(supportedTypes).includes(type)
  }

  static addAccessController (options) {
    if (!options.AccessController) {
      throw new Error('AccessController class needs to be given as an option')
    }

    if (!options.AccessController.type ||
      typeof options.AccessController.type !== 'string') {
      throw new Error('Given AccessController class needs to implement: static get type() { /* return a string */}.')
    }

    supportedTypes[options.AccessController.type] = options.AccessController
  }

  static addAccessControllers (options) {
    const accessControllers = options.AccessControllers
    if (!accessControllers) {
      throw new Error('AccessController classes need to be given as an option')
    }

    accessControllers.forEach((accessController) => {
      AccessControllers.addAccessController({ AccessController: accessController })
    })
  }

  static removeAccessController (type) {
    delete supportedTypes[type]
  }

  static async resolve (orbitdb, manifestAddress, options = {}) {
    const { type, params } = await AccessControllerManifest.resolve(orbitdb._ipfs, manifestAddress, options)
    const AccessController = getHandlerFor(type)
    const accessController = await AccessController.create(orbitdb, Object.assign({}, options, params))
    await accessController.load(params.address)
    return accessController
  }

  static async create (orbitdb, type, options = {}) {
    const AccessController = getHandlerFor(type)
    const ac = await AccessController.create(orbitdb, options)
    const params = await ac.save()
    const hash = await AccessControllerManifest.create(orbitdb._ipfs, type, params)
    return hash
  }
}

module.exports = AccessControllers

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controllers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\moderatorAccessController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box-orbitdb-plugins\src\moderatorAccessController.js
      return function (require, module, exports) {
const type = 'moderator-access'

const MODERATOR = 'MODERATOR'
const MEMBER = 'MEMBER'

class ModeratorAccessController {
  constructor (firstModerator, options) {
    this._capabilityTypes = [MODERATOR]
    this._write = []     // Allowed to add other mods or members
    this._firstModerator = firstModerator
    this._write.push(this._firstModerator)
    this._members = Boolean(options.members)
    if (this._members) this._capabilityTypes.push(MEMBER)
  }

  static get type () { return type }

  isMod(id) {
    return this._write.includes(id)
  }

  isValidCapability (capability) {
    return this._capabilityTypes.includes(capability)
  }

  get firstModerator () {
    return this._firstModerator
  }

  async canAppend (entry, identityProvider) {
    const entryID = entry.identity.id
    const capability = entry.payload.value.capability
    const idAdd = entry.payload.value.id
    const isMod = this.isMod(entryID)
    const validCapability = this.isValidCapability(capability)
    const validSig = async () => identityProvider.verifyIdentity(entry.identity)
    if (isMod && validCapability && (await validSig())) {
      if (capability === MODERATOR) this._write.push(idAdd)
      return true
    }

    return false
  }

  async load (address) {
    const addList = address.split('/')
    const suffix = addList.pop()
    this._members = suffix === 'members'
    const mod = suffix.includes('mod') ? suffix : addList.pop()
    this._firstModerator = mod.split('_')[1]
  }

  async save () {
    // TODO if entire obj saved in manfest, can just pass our own fields
    let address = `${type}/mod_${this._firstModerator}`
    address += this._members ? '/members' : ''
    return { address }
  }

  static async create (orbitdb, options = {}) {
    if (!options.firstModerator) throw new Error('Moderator AC: firstModerator required')
    return new ModeratorAccessController(options.firstModerator, options)
  }
}

module.exports = ModeratorAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\moderatorAccessController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\legacyIpfs3boxAccessController.js", {"did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js","orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box-orbitdb-plugins\src\legacyIpfs3boxAccessController.js
      return function (require, module, exports) {
const io = require('orbit-db-io')
const Buffer = require('safe-buffer').Buffer
//const AccessController = require('./access-controller-interface')
const resolve = require('did-resolver').default
const type = 'legacy-ipfs-3box'

const publicKeyFromDID = async did => {
  // TODO - this should look at authentication keys and get publicKey from that
  const doc = await resolve(did)
  return doc.publicKey.find(entry => {
    const id = entry.id.split('#')
    return id[0] === doc.id &&
      (id[1] === 'subSigningKey' || id[1] === 'signingKey')
  }).publicKeyHex
}

class LegacyIPFS3BoxAccessController {
  constructor (ipfs, options) {
    //super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const publicKey = entry.v === 0 ? entry.key : await publicKeyFromDID(entry.identity.id)
    if (this.write.includes(publicKey) ||
      this.write.includes('*')) {
      return entry.v === 0 ? true : await identityProvider.verifyIdentity(entry.identity)
    }
    return false
  }

  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      const access = await io.read(this._ipfs, address)
      this._write = access.write
    } catch (e) {
      console.log('LegacyIPFS3BoxAccessController.load ERROR:', e)
    }
  }

  async save (options) {
    let cid
    const access = { admin: [], write: this.write, read: [] }
    try {
      cid = await io.write(this._ipfs, 'raw', Buffer.from(JSON.stringify(access, null, 2)), { format: 'dag-pb'})

    } catch (e) {
      console.log('LegacyIPFS3BoxAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid, skipManifest: true }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.publicKey] } }
    return new LegacyIPFS3BoxAccessController(orbitdb._ipfs, options)
  }
}

module.exports = LegacyIPFS3BoxAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\legacyIpfs3boxAccessController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\threadAccessController.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","ipfs-log/src/entry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry.js","is-ipfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-ipfs\\src\\index.js","orbit-db-access-controllers/src/utils/ensure-ac-address":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\utils\\ensure-ac-address.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box-orbitdb-plugins\src\threadAccessController.js
      return function (require, module, exports) {
const ensureAddress = require('orbit-db-access-controllers/src/utils/ensure-ac-address')
const EventEmitter = require('events').EventEmitter
const entryIPFS = require('ipfs-log/src/entry')
const isIPFS = require('is-ipfs')

const type = 'thread-access'
const MODERATOR = 'MODERATOR'
const MEMBER = 'MEMBER'

const isValid3ID = did => {
  const parts = did.split(':')
  if (!parts[0] === 'did' || !parts[1] === '3') return false
  return isIPFS.cid(parts[2])
}

class ThreadAccessController extends EventEmitter{
  constructor (orbitdb, ipfs, identity, firstModerator, options) {
    super()
    this._orbitdb = orbitdb
    this._db = null
    this._options = options || {}
    this._ipfs = ipfs
    this._members = Boolean(options.members)
    this._firstModerator = firstModerator
    this._threadName = options.threadName
    this._identity = identity
  }

  static get type () { return type }

  // return addres of AC (in this case orbitdb address of AC)
  get address () {
    return this._db.address
  }

  async canAppend (entry, identityProvider) {
    const trueIfValidSig = async () => await identityProvider.verifyIdentity(entry.identity)

    const op = entry.payload.op
    const mods = this.capabilities['moderators']
    const members = this.capabilities['members']
    const isMod = mods.includes(entry.identity.id)
    const isMember = members.includes(entry.identity.id)

    if (op === 'ADD') {
      // Anyone can add entry if open thread
      if (!this._members) return await trueIfValidSig()
      // Not open thread, any member or mod can add to thread
      if (isMember || isMod) return await trueIfValidSig()
    }

    if (op === 'DEL') {
      const hash = entry.payload.value
      const delEntry = await entryIPFS.fromMultihash(this._ipfs, hash)

      // An id can delete their own entries
      if (delEntry.identity.id === entry.identity.id) return await trueIfValidSig()

      // Mods can delete any entry
      if (isMod) return await trueIfValidSig()
    }

    return false
  }

  get capabilities () {
    if (!this._capabilities) this._updateCapabilites()
    return this._capabilities
  }

  _updateCapabilites () {
    let moderators = [], members = []
    if (this._db) {
      moderators.push(this._db.access._firstModerator)
      Object.entries(this._db.index).forEach(entry => {
        const capability = entry[1].payload.value.capability
        const id = entry[1].payload.value.id
        if (capability === MODERATOR) moderators.push(id)
        if (capability === MEMBER) members.push(id)
      })
    }
    this._capabilities = {moderators, members}
    return this._capabilities
  }

  get (capability) {
    return this.capabilities[capability] || []
  }

  async close () {
    await this._db.close()
  }

  async load (address) {
    if (this._db) { await this._db.close() }

    // TODO - skip manifest for mod-access
    this._db = await this._orbitdb.feed(ensureAddress(address), {
      identity: this._identity,
      accessController: {
        type: 'moderator-access',
        firstModerator: this._firstModerator,
        members: this._members
      },
      sync: true
    })

    this._db.events.on('ready', this._onUpdate.bind(this))
    this._db.events.on('write', this._onUpdate.bind(this))
    this._db.events.on('replicated', this._onUpdate.bind(this))

    await this._db.load()
  }

  async save () {
    return {
      address: this._db.address.toString(),
      firstModerator: this._firstModerator,
      members: this._members
    }
  }

  async grant (capability, id) {
    if (!this._db.access.isValidCapability(capability)) {
      throw new Error('grant: Invalid capability to grant')
    }
    if (capability === MEMBER && this.capabilities['members'].includes(id)) {
        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)
    }
    if (capability === MODERATOR && this.capabilities['moderators'].includes(id)) {
        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)
    }
    try {
      await this._db.add({capability, id})
    } catch (e) {
      if (e.toString().includes('not append entry')) throw new Error(`grant: Capability ${capability} can not be granted to ${id}`)
      throw e
    }
  }

  _onUpdate () {
    this._updateCapabilites()
    this.emit('updated')
  }

  /* Factory */
  static async create (orbitdb, options = {}) {
    if (!options.firstModerator) throw new Error('Thread AC: firstModerator required')
    const ac = new ThreadAccessController(orbitdb, orbitdb._ipfs, options.identity, options.firstModerator, options)
    await ac.load(options.address || options.threadName)
    return ac
  }
}

module.exports = ThreadAccessController

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\threadAccessController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\odbIdentityProvider.js", {"base64url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64url\\index.js","did-jwt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box-orbitdb-plugins\src\odbIdentityProvider.js
      return function (require, module, exports) {
const base64url = require('base64url')
const { verifyJWT } = require('did-jwt')

const encodeSection = data => base64url.encode(JSON.stringify(data))

const TYPE = '3ID'
const JWT_HEADER = encodeSection({ typ: 'JWT', alg: 'ES256K' })


class OdbIdentityProvider {
  constructor ({ threeId }) {
    // super(options)
    this.threeId = threeId
  }

  static get type () {
    return '3ID'
  }

  async getId ({ space }) {
    if (space) {
      return this.threeId.getSubDID(space)
    } else {
      return this.threeId.DID
    }
  }

  async signIdentity (data, { space }) {
    const payload = {
      data,
      iat: null
    }
    const opts = !space ? { use3ID: true } : { space }
    return (await this.threeId.signJWT(payload, opts)).split('.')[2]
  }

  static async verifyIdentity (identity) {
    const payload = encodeSection({
      iat: null,
      data: identity.publicKey + identity.signatures.id,
      iss: identity.id
    })
    const jwt = `${JWT_HEADER}.${payload}.${identity.signatures.publicKey}`
    try {
      await verifyJWT(jwt, { auth: true })
    } catch (e) {
      return false
    }
    return true
   }
}

module.exports = OdbIdentityProvider

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box-orbitdb-plugins\\src\\odbIdentityProvider.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\db-manifest.js", {"orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\db-manifest.js
      return function (require, module, exports) {
const path = require('path')
const io = require('orbit-db-io')

// Creates a DB manifest file and saves it in IPFS
const createDBManifest = async (ipfs, name, type, accessControllerAddress, options) => {
  const manifest = {
    name: name,
    type: type,
    accessController: path.join('/ipfs', accessControllerAddress),
  }

  return io.write(ipfs, options.format || 'dag-cbor', manifest, options)
}

module.exports = createDBManifest

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\db-manifest.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","fs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\logplease\src\index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

const fs = require('fs');
const format = require('util').format;
const EventEmitter = require('events').EventEmitter;

let isElectronRenderer = process.type && process.type === 'renderer';
let isNodejs = !isElectronRenderer && process.version ? true : false;

const LogLevels = {
  'DEBUG': 'DEBUG',
  'INFO':  'INFO',
  'WARN':  'WARN',
  'ERROR': 'ERROR',
  'NONE':  'NONE',
};

// Global log level
let GlobalLogLevel = LogLevels.DEBUG;

// Global log file name
let GlobalLogfile = null;

let GlobalEvents = new EventEmitter();

// ANSI colors
let Colors = {
  'Black':   0,
  'Red':     1,
  'Green':   2,
  'Yellow':  3,
  'Blue':    4,
  'Magenta': 5,
  'Cyan':    6,
  'Grey':    7,
  'White':   9,
  'Default': 9,
};

// CSS colors
if(!isNodejs) {
  Colors = {
    'Black':   'Black',
    'Red':     'IndianRed',
    'Green':   'LimeGreen',
    'Yellow':  'Orange',
    'Blue':    'RoyalBlue',
    'Magenta': 'Orchid',
    'Cyan':    'SkyBlue',
    'Grey':    'DimGrey',
    'White':   'White',
    'Default': 'Black',
  };
}

const loglevelColors = [Colors.Cyan, Colors.Green, Colors.Yellow, Colors.Red, Colors.Default];

const defaultOptions = {
  useColors: true,
  color: Colors.Default,
  showTimestamp: true,
  useLocalTime: false,
  showLevel: true,
  filename: GlobalLogfile,
  appendFile: true,
};

class Logger {
  constructor(category, options) {
    this.category = category;
    let opts = {};
    Object.assign(opts, defaultOptions);
    Object.assign(opts, options);
    this.options = opts;
    this.debug = this.debug.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.warn = this.warn.bind(this);
    this.error = this.error.bind(this);
  }

  debug() {
    if(this._shouldLog(LogLevels.DEBUG))
      this._write(LogLevels.DEBUG, format.apply(null, arguments));
  }

  log() {
    if(this._shouldLog(LogLevels.DEBUG))
      this.debug.apply(this, arguments);
  }

  info() {
    if(this._shouldLog(LogLevels.INFO))
      this._write(LogLevels.INFO, format.apply(null, arguments));
  }

  warn() {
    if(this._shouldLog(LogLevels.WARN))
      this._write(LogLevels.WARN, format.apply(null, arguments));
  }

  error() {
    if(this._shouldLog(LogLevels.ERROR))
      this._write(LogLevels.ERROR, format.apply(null, arguments));
  }

  _write(level, text) {
    if((this.options.filename || GlobalLogfile) && !this.fileWriter && isNodejs)
      this.fileWriter = fs.openSync(this.options.filename || GlobalLogfile, this.options.appendFile ? 'a+' : 'w+');

    let format = this._format(level, text);
    let unformattedText = this._createLogMessage(level, text);
    let formattedText = this._createLogMessage(level, text, format.timestamp, format.level, format.category, format.text);

    if(this.fileWriter && isNodejs)
      fs.writeSync(this.fileWriter, unformattedText + '\n', null, 'utf-8');

    if(isNodejs || !this.options.useColors) {
      console.log(formattedText)
      GlobalEvents.emit('data', this.category, level, text)
    } else {
      // TODO: clean this up
      if(level === LogLevels.ERROR) {
        if(this.options.showTimestamp && this.options.showLevel) {
          console.error(formattedText, format.timestamp, format.level, format.category, format.text)
        } else if(this.options.showTimestamp && !this.options.showLevel) {
          console.error(formattedText, format.timestamp, format.category, format.text)
        } else if(!this.options.showTimestamp && this.options.showLevel) {
          console.error(formattedText, format.level, format.category, format.text)
        } else {
          console.error(formattedText, format.category, format.text)
        }
      } else {
        if(this.options.showTimestamp && this.options.showLevel) {
          console.log(formattedText, format.timestamp, format.level, format.category, format.text)
        } else if(this.options.showTimestamp && !this.options.showLevel) {
          console.log(formattedText, format.timestamp, format.category, format.text)
        } else if(!this.options.showTimestamp && this.options.showLevel) {
          console.log(formattedText, format.level, format.category, format.text)
        } else {
          console.log(formattedText, format.category, format.text)
        }
      }
    }
  }

  _format(level, text) {
    let timestampFormat = '';
    let levelFormat     = '';
    let categoryFormat  = '';
    let textFormat      = ': ';

    if(this.options.useColors) {
        const levelColor    = Object.keys(LogLevels).map((f) => LogLevels[f]).indexOf(level);
        const categoryColor = this.options.color;

      if(isNodejs) {
        if(this.options.showTimestamp)
          timestampFormat = '\u001b[3' + Colors.Grey + 'm';

        if(this.options.showLevel)
          levelFormat = '\u001b[3' + loglevelColors[levelColor] + ';22m';

        categoryFormat = '\u001b[3' + categoryColor + ';1m';
        textFormat = '\u001b[0m: ';
      } else {
        if(this.options.showTimestamp)
          timestampFormat = 'color:' + Colors.Grey;

        if(this.options.showLevel)
          levelFormat = 'color:' + loglevelColors[levelColor];

        categoryFormat = 'color:' + categoryColor + '; font-weight: bold';
      }
    }

    return {
      timestamp: timestampFormat,
      level: levelFormat,
      category: categoryFormat,
      text: textFormat
    };
  }

  _createLogMessage(level, text, timestampFormat, levelFormat, categoryFormat, textFormat) {
    timestampFormat = timestampFormat || '';
    levelFormat     = levelFormat     || '';
    categoryFormat  = categoryFormat  || '';
    textFormat      = textFormat      || ': ';

    if(!isNodejs && this.options.useColors) {
      if(this.options.showTimestamp)
        timestampFormat = '%c';

      if(this.options.showLevel)
        levelFormat = '%c';

      categoryFormat  = '%c';
      textFormat = ': %c';
    }

    let result = '';

    if(this.options.showTimestamp && !this.options.useLocalTime)
      result += '' + new Date().toISOString() + ' ';

    if(this.options.showTimestamp && this.options.useLocalTime)
      result += '' + new Date().toLocaleString() + ' ';

    result = timestampFormat + result;

    if(this.options.showLevel)
      result += levelFormat + '[' + level +']' + (level === LogLevels.INFO || level === LogLevels.WARN ? ' ' : '') + ' ';

    result += categoryFormat + this.category;
    result += textFormat + text;
    return result;
  }

  _shouldLog(level) {
    let envLogLevel = (typeof process !== "undefined" && process.env !== undefined && process.env.LOG !== undefined) ? process.env.LOG.toUpperCase() : null;
    envLogLevel = (typeof window !== "undefined" && window.LOG) ? window.LOG.toUpperCase() : envLogLevel;

    const logLevel = envLogLevel || GlobalLogLevel;
    const levels   = Object.keys(LogLevels).map((f) => LogLevels[f]);
    const index    = levels.indexOf(level);
    const levelIdx = levels.indexOf(logLevel);
    return index >= levelIdx;
  }
};

/* Public API */
module.exports = {
  Colors: Colors,
  LogLevels: LogLevels,
  setLogLevel: (level) => {
    GlobalLogLevel = level;
  },
  setLogfile: (filename) => {
    GlobalLogfile = filename;
  },
  create: (category, options) => {
    const logger = new Logger(category, options);
    return logger;
  },
  forceBrowserMode: (force) => isNodejs = !force, // for testing,
  events: GlobalEvents,
};

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"logplease",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedStore.js", {"./FeedIndex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedIndex.js","orbit-db-eventstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-feedstore\src\FeedStore.js
      return function (require, module, exports) {
'use strict'

const EventStore = require('orbit-db-eventstore')
const FeedIndex  = require('./FeedIndex')

class FeedStore extends EventStore {
  constructor (ipfs, id, dbname, options) {
    if(!options) options = {}
    if(!options.Index) Object.assign(options, { Index: FeedIndex })
    super(ipfs, id, dbname, options)
    this._type = 'feed'
  }

  remove (hash) {
    return this.del(hash)
  }

  del (hash) {
    const operation = {
      op: 'DEL',
      key: null,
      value: hash
    }
    return this._addOperation(operation)
  }
}

module.exports = FeedStore

      };
    };
  }
}, {package:"orbit-db-feedstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventStore.js", {"./EventIndex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventIndex.js","orbit-db-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-eventstore\src\EventStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const EventIndex = require('./EventIndex')

// TODO: generalize the Iterator functions and spin to its own module

class EventStore extends Store {
  constructor (ipfs, id, dbname, options = {}) {
    if (options.Index === undefined) Object.assign(options, { Index: EventIndex })
    super(ipfs, id, dbname, options)
    this._type = 'eventlog'
  }

  add (data) {
    return this._addOperation({
      op: 'ADD',
      key: null,
      value: data
    })
  }

  get (hash) {
    return this.iterator({ gte: hash, limit: 1 }).collect()[0]
  }

  iterator (options) {
    const messages = this._query(options)
    let currentIndex = 0
    let iterator = {
      [Symbol.iterator] () {
        return this
      },
      next () {
        let item = { value: null, done: true }
        if (currentIndex < messages.length) {
          item = { value: messages[currentIndex], done: false }
          currentIndex++
        }
        return item
      },
      collect: () => messages
    }

    return iterator
  }

  _query (opts) {
    if (!opts) opts = {}

    const amount = opts.limit ? (opts.limit > -1 ? opts.limit : this._index.get().length) : 1 // Return 1 if no limit is provided
    const events = this._index.get().slice()
    let result = []

    if (opts.gt || opts.gte) {
      // Greater than case
      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte)
    } else {
      // Lower than and lastN case, search latest first by reversing the sequence
      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse()
    }

    return result
  }

  _read (ops, hash, amount, inclusive) {
    // Find the index of the gt/lt hash, or start from the beginning of the array if not found
    const index = ops.map((e) => e.hash).indexOf(hash)
    let startIndex = Math.max(index, 0)
    // If gte/lte is set, we include the given hash, if not, start from the next element
    startIndex += inclusive ? 0 : 1
    // Slice the array to its requested size
    const res = ops.slice(startIndex).slice(0, amount)
    return res
  }
}

module.exports = EventStore

      };
    };
  }
}, {package:"orbit-db-eventstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueStore.js", {"./KeyValueIndex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueIndex.js","orbit-db-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-kvstore\src\KeyValueStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const KeyValueIndex = require('./KeyValueIndex')

class KeyValueStore extends Store {
  constructor(ipfs, id, dbname, options) {
    let opts = Object.assign({}, { Index: KeyValueIndex })
    Object.assign(opts, options)
    super(ipfs, id, dbname, opts)
    this._type = 'keyvalue'
  }

  get all () {
    return this._index._index
  }

  get (key) {
    return this._index.get(key)
  }

  set (key, data) {
    return this.put(key, data)
  }

  put (key, data) {
    return this._addOperation({
      op: 'PUT',
      key: key,
      value: data
    })
  }

  del (key) {
    return this._addOperation({
      op: 'DEL',
      key: key,
      value: null
    })
  }
}

module.exports = KeyValueStore

      };
    };
  }
}, {package:"orbit-db-kvstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentStore.js", {"./DocumentIndex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentIndex.js","orbit-db-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js","p-map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\node_modules\\p-map\\index.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-docstore\src\DocumentStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const DocumentIndex = require('./DocumentIndex')
const pMap = require('p-map')
const Readable = require('readable-stream')

const replaceAll = (str, search, replacement) => str.toString().split(search).join(replacement)

class DocumentStore extends Store {
  constructor (ipfs, id, dbname, options) {
    if (!options) options = {}
    if (!options.indexBy) Object.assign(options, { indexBy: '_id' })
    if (!options.Index) Object.assign(options, { Index: DocumentIndex })
    super(ipfs, id, dbname, options)
    this._type = 'docstore'
  }

  get (key, caseSensitive = false) {
    key = key.toString()
    const terms = key.split(' ')
    key = terms.length > 1 ? replaceAll(key, '.', ' ').toLowerCase() : key.toLowerCase()

    const search = (e) => {
      if (terms.length > 1) {
        return replaceAll(e, '.', ' ').toLowerCase().indexOf(key) !== -1
      }
      return e.toLowerCase().indexOf(key) !== -1
    }
    const mapper = e => this._index.get(e)
    const filter = e => caseSensitive
      ? e.indexOf(key) !== -1 
      : search(e)

    return Object.keys(this._index._index)
      .filter(filter)
      .map(mapper)
  }

  query (mapper, options = {}) {
    // Whether we return the full operation data or just the db value
    const fullOp = options.fullOp || false

    return Object.keys(this._index._index)
      .map((e) => this._index.get(e, fullOp))
      .filter(mapper)
  }

  batchPut (docs, onProgressCallback) {
    const mapper = (doc, idx) => {
      return this._addOperationBatch(
        {
          op: 'PUT',
          key: doc[this.options.indexBy],
          value: doc
        },
        true,
        idx === docs.length - 1,
        onProgressCallback
      )
    }

    return pMap(docs, mapper, { concurrency: 1 })
      .then(() => this.saveSnapshot())
  }

  put (doc) {
    if (!doc[this.options.indexBy])
      throw new Error(`The provided document doesn't contain field '${this.options.indexBy}'`)

    return this._addOperation({
      op: 'PUT',
      key: doc[this.options.indexBy],
      value: doc
    })
  }

  del (key) {
    if (!this._index.get(key))
      throw new Error(`No entry with key '${key}' in the database`)

    return this._addOperation({
      op: 'DEL',
      key: key,
      value: null
    })
  }
}

module.exports = DocumentStore
      };
    };
  }
}, {package:"orbit-db-docstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\index.js", {"./is-defined":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\is-defined.js","orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\utils\index.js
      return function (require, module, exports) {
'use strict'

const isDefined = require('./is-defined')
const io = require('orbit-db-io')

module.exports = {
  isDefined,
  io
}

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\exchange-heads.js", {"ipfs-pubsub-1on1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\direct-channel.js","logplease":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\exchange-heads.js
      return function (require, module, exports) {
'use strict'

const Channel = require('ipfs-pubsub-1on1')

const Logger = require('logplease')
const logger = Logger.create("exchange-heads", { color: Logger.Colors.Yellow })
Logger.setLogLevel('ERROR')

const getHeadsForDatabase = store => (store && store._oplog) ? store._oplog.heads : []

const exchangeHeads = async (ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) => {
  const _handleMessage = message => {
    const msg = JSON.parse(message.data)
    const { address, heads } = msg
    onMessage(address, heads)
  }

  let channel = getDirectConnection(peer)
  if (!channel) {
    try {
      logger.debug(`Create a channel to ${peer}`)
      channel = await Channel.open(ipfs, peer)
      channel.on('message', _handleMessage)
      logger.debug(`Channel created to ${peer}`)
      onChannelCreated(channel)
    } catch (e) {
      logger.error(e)
    }
  }

  // Wait for the direct channel to be fully connected
  await channel.connect()
  logger.debug(`Connected to ${peer}`)

  // Send the heads if we have any
  const heads = getHeadsForDatabase(getStore(address))
  logger.debug(`Send latest heads of '${address}':\n`, JSON.stringify(heads.map(e => e.hash), null, 2))
  if (heads) {
    await channel.send(JSON.stringify({ address: address, heads: heads }))
  }

  return channel
}

module.exports = exchangeHeads

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\exchange-heads.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterStore.js", {"./CounterIndex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterIndex.js","crdts/src/G-Counter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crdts\\src\\G-Counter.js","orbit-db-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-counterstore\src\CounterStore.js
      return function (require, module, exports) {
'use strict'

const Store = require('orbit-db-store')
const CounterIndex = require('./CounterIndex')
const Counter = require('crdts/src/G-Counter')

class CounterStore extends Store {
  constructor(ipfs, id, dbname, options = {}) {
    if(!options.Index) Object.assign(options, { Index: CounterIndex })
    super(ipfs, id, dbname, options)
    this._type = 'counter'
  }

  get value() {
    return this._index.get().value
  }

  inc(amount) {
    const counter = new Counter(this.identity.publicKey, Object.assign({}, this._index.get()._counters))
    counter.increment(amount)
    return this._addOperation({
      op: 'COUNTER',
      key: null,
      value: counter.toJSON(),
    })
  }
}

module.exports = CounterStore

      };
    };
  }
}, {package:"orbit-db-counterstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\index-browser.js", {"./Cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\Cache.js","level-js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-cache\index-browser.js
      return function (require, module, exports) {
const level = require('level-js')
const Cache = require('./Cache')
module.exports = Cache(level)

      };
    };
  }
}, {package:"orbit-db-cache",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\index-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\index-browser.js", {"./src/keystore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\src\\keystore.js","level-js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-keystore\index-browser.js
      return function (require, module, exports) {
const level = require('level-js')
const Keystore = require('./src/keystore')
module.exports = Keystore(level)

      };
    };
  }
}, {package:"orbit-db-keystore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\index-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-ipfs\\src\\index.js", {"bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","mafmt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\is-ipfs\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const base58 = require('bs58')
const multihash = require('multihashes')
const multibase = require('multibase')
const Multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const CID = require('cids')

const urlPattern = /^https?:\/\/[^/]+\/(ip(f|n)s)\/((\w+).*)/
const pathPattern = /^\/(ip(f|n)s)\/((\w+).*)/
const defaultProtocolMatch = 1
const defaultHashMath = 4

const fqdnPattern = /^https?:\/\/([^/]+)\.(ip(?:f|n)s)\.[^/]+/
const fqdnHashMatch = 1
const fqdnProtocolMatch = 2

function isMultihash (hash) {
  const formatted = convertToString(hash)
  try {
    const buffer = Buffer.from(base58.decode(formatted))
    multihash.decode(buffer)
    return true
  } catch (e) {
    return false
  }
}

function isMultibase (hash) {
  try {
    return multibase.isEncoded(hash)
  } catch (e) {
    return false
  }
}

function isCID (hash) {
  try {
    new CID(hash) // eslint-disable-line no-new
    return true
  } catch (e) {
    return false
  }
}

function isMultiaddr (input) {
  if (!input) return false
  if (Multiaddr.isMultiaddr(input)) return true
  try {
    new Multiaddr(input) // eslint-disable-line no-new
    return true
  } catch (e) {
    return false
  }
}

function isPeerMultiaddr (input) {
  return isMultiaddr(input) && mafmt.IPFS.matches(input)
}

function isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input)
  if (!formatted) {
    return false
  }

  const match = formatted.match(pattern)
  if (!match) {
    return false
  }

  if (match[protocolMatch] !== 'ipfs') {
    return false
  }

  let hash = match[hashMatch]

  if (hash && pattern === fqdnPattern) {
    // when doing checks for subdomain context
    // ensure hash is case-insensitive
    // (browsers force-lowercase authority compotent anyway)
    hash = hash.toLowerCase()
  }

  return isCID(hash)
}

function isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {
  const formatted = convertToString(input)
  if (!formatted) {
    return false
  }
  const match = formatted.match(pattern)
  if (!match) {
    return false
  }

  if (match[protocolMatch] !== 'ipns') {
    return false
  }

  if (hashMatch && pattern === fqdnPattern) {
    let hash = match[hashMatch]
    // when doing checks for subdomain context
    // ensure hash is case-insensitive
    // (browsers force-lowercase authority compotent anyway)
    hash = hash.toLowerCase()
    return isCID(hash)
  }

  return true
}

function isString (input) {
  return typeof input === 'string'
}

function convertToString (input) {
  if (Buffer.isBuffer(input)) {
    return base58.encode(input)
  }

  if (isString(input)) {
    return input
  }

  return false
}

const ipfsSubdomain = (url) => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)
const ipnsSubdomain = (url) => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)

module.exports = {
  multihash: isMultihash,
  multiaddr: isMultiaddr,
  peerMultiaddr: isPeerMultiaddr,
  cid: isCID,
  base32cid: (cid) => (isMultibase(cid) === 'base32' && isCID(cid)),
  ipfsSubdomain: ipfsSubdomain,
  ipnsSubdomain: ipnsSubdomain,
  subdomain: (url) => (ipfsSubdomain(url) || ipnsSubdomain(url)),
  subdomainPattern: fqdnPattern,
  ipfsUrl: (url) => isIpfs(url, urlPattern),
  ipnsUrl: (url) => isIpns(url, urlPattern),
  url: (url) => (isIpfs(url, urlPattern) || isIpns(url, urlPattern)),
  urlPattern: urlPattern,
  ipfsPath: (path) => isIpfs(path, pathPattern),
  ipnsPath: (path) => isIpns(path, pathPattern),
  path: (path) => (isIpfs(path, pathPattern) || isIpns(path, pathPattern)),
  pathPattern: pathPattern,
  urlOrPath: (x) => (isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern)),
  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"is-ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-ipfs\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\merge-options\\index.js", {"is-plain-obj":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-plain-obj\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\merge-options\index.js
      return function (require, module, exports) {
'use strict';
const isOptionObject = require('is-plain-obj');

const hasOwnProperty = Object.prototype.hasOwnProperty;
const propIsEnumerable = Object.propertyIsEnumerable;
const defineProperty = (obj, name, value) => Object.defineProperty(obj, name, {
	value,
	writable: true,
	enumerable: true,
	configurable: true
});

const globalThis = this;
const defaultMergeOpts = {
	concatArrays: false
};

const getEnumerableOwnPropertyKeys = value => {
	const keys = [];

	for (const key in value) {
		if (hasOwnProperty.call(value, key)) {
			keys.push(key);
		}
	}

	/* istanbul ignore else  */
	if (Object.getOwnPropertySymbols) {
		const symbols = Object.getOwnPropertySymbols(value);

		for (let i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(value, symbols[i])) {
				keys.push(symbols[i]);
			}
		}
	}

	return keys;
};

function clone(value) {
	if (Array.isArray(value)) {
		return cloneArray(value);
	}

	if (isOptionObject(value)) {
		return cloneOptionObject(value);
	}

	return value;
}

function cloneArray(array) {
	const result = array.slice(0, 0);

	getEnumerableOwnPropertyKeys(array).forEach(key => {
		defineProperty(result, key, clone(array[key]));
	});

	return result;
}

function cloneOptionObject(obj) {
	const result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};

	getEnumerableOwnPropertyKeys(obj).forEach(key => {
		defineProperty(result, key, clone(obj[key]));
	});

	return result;
}

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 */
const mergeKeys = (merged, source, keys, mergeOpts) => {
	keys.forEach(key => {
		// Do not recurse into prototype chain of merged
		if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
			defineProperty(merged, key, merge(merged[key], source[key], mergeOpts));
		} else {
			defineProperty(merged, key, clone(source[key]));
		}
	});

	return merged;
};

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */
const concatArrays = (merged, source, mergeOpts) => {
	let result = merged.slice(0, 0);
	let resultIndex = 0;

	[merged, source].forEach(array => {
		const indices = [];

		// `result.concat(array)` with cloning
		for (let k = 0; k < array.length; k++) {
			if (!hasOwnProperty.call(array, k)) {
				continue;
			}

			indices.push(String(k));

			if (array === merged) {
				// Already cloned
				defineProperty(result, resultIndex++, array[k]);
			} else {
				defineProperty(result, resultIndex++, clone(array[k]));
			}
		}

		// Merge non-index keys
		result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => {
			return indices.indexOf(key) === -1;
		}), mergeOpts);
	});

	return result;
};

/**
 * @param merged {already cloned}
 * @return {cloned Object}
 */
function merge(merged, source, mergeOpts) {
	if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
		return concatArrays(merged, source, mergeOpts);
	}

	if (!isOptionObject(source) || !isOptionObject(merged)) {
		return clone(source);
	}

	return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);
}

module.exports = function () {
	const mergeOpts = merge(clone(defaultMergeOpts), (this !== globalThis && this) || {}, defaultMergeOpts);
	let merged = {foobar: {}};

	for (let i = 0; i < arguments.length; i++) {
		const option = arguments[i];

		if (option === undefined) {
			continue;
		}

		if (!isOptionObject(option)) {
			throw new TypeError('`' + option + '` is not an Option Object');
		}

		merged = merge(merged, {foobar: option}, mergeOpts);
	}

	return merged.foobar;
};

      };
    };
  }
}, {package:"merge-options",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\merge-options\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\repo-browser.js", {"ipfs-repo":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\runtime\repo-browser.js
      return function (require, module, exports) {
'use strict'

const IPFSRepo = require('ipfs-repo')

module.exports = (dir) => {
  const repoPath = dir || 'ipfs'
  return new IPFSRepo(repoPath)
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\repo-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\mfs-preload.js", {"async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\mfs-preload.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const setImmediate = require('async/setImmediate')
const log = debug('ipfs:mfs-preload')
log.error = debug('ipfs:mfs-preload:error')

module.exports = (self) => {
  const options = self._options.preload || {}
  options.interval = options.interval || 30 * 1000

  if (!options.enabled) {
    log('MFS preload disabled')
    return {
      start: (cb) => setImmediate(cb),
      stop: (cb) => setImmediate(cb)
    }
  }

  let rootCid
  let timeoutId

  const preloadMfs = () => {
    self.files.stat('/', (err, stats) => {
      if (err) {
        timeoutId = setTimeout(preloadMfs, options.interval)
        return log.error('failed to stat MFS root for preload', err)
      }

      if (rootCid !== stats.hash) {
        log(`preloading updated MFS root ${rootCid} -> ${stats.hash}`)

        return self._preload(stats.hash, (err) => {
          timeoutId = setTimeout(preloadMfs, options.interval)
          if (err) return log.error(`failed to preload MFS root ${stats.hash}`, err)
          rootCid = stats.hash
        })
      }

      timeoutId = setTimeout(preloadMfs, options.interval)
    })
  }

  return {
    start (cb) {
      self.files.stat('/', (err, stats) => {
        if (err) return cb(err)
        rootCid = stats.hash
        log(`monitoring MFS root ${rootCid}`)
        timeoutId = setTimeout(preloadMfs, options.interval)
        cb()
      })
    },
    stop (cb) {
      clearTimeout(timeoutId)
      cb()
    }
  }
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\mfs-preload.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-book\\src\\index.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58\\index.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peer-book\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const bs58 = require('bs58')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')

function getB58Str (peer) {
  let b58Str

  if (typeof peer === 'string') {
    b58Str = peer
  } else if (Buffer.isBuffer(peer)) {
    b58Str = bs58.encode(peer).toString()
  } else if (PeerId.isPeerId(peer)) {
    b58Str = peer.toB58String()
  } else if (PeerInfo.isPeerInfo(peer)) {
    b58Str = peer.id.toB58String()
  } else {
    throw new Error('not valid PeerId or PeerInfo, or B58Str')
  }

  return b58Str
}

class PeerBook {
  constructor () {
    this._peers = {}
  }

  // checks if peer exists
  // peer can be PeerId, b58String or PeerInfo
  has (peer) {
    const b58Str = getB58Str(peer)
    return Boolean(this._peers[b58Str])
  }

  /**
   * Stores a peerInfo, if already exist, merges the new into the old.
   *
   * @param {PeerInfo} peerInfo
   * @param {Boolean} replace
   * @returns {PeerInfo}
   */
  put (peerInfo, replace) {
    const localPeerInfo = this._peers[peerInfo.id.toB58String()]

    // insert if doesn't exist or replace if replace flag is true
    if (!localPeerInfo || replace) {
      this._peers[peerInfo.id.toB58String()] = peerInfo
      return peerInfo
    }

    // peerInfo.replace merges by default if none to replace are passed
    peerInfo.multiaddrs.forEach((ma) => localPeerInfo.multiaddrs.add(ma))

    // pass active connection state
    const ma = peerInfo.isConnected()
    if (ma) {
      localPeerInfo.connect(ma)
    }

    // pass known protocols
    peerInfo.protocols.forEach((p) => localPeerInfo.protocols.add(p))

    if (!localPeerInfo.id.privKey && peerInfo.id.privKey) {
      localPeerInfo.id.privKey = peerInfo.id.privKey
    }

    if (!localPeerInfo.id.pubKey && peerInfo.id.pubKey) {
      localPeerInfo.id.pubKey = peerInfo.id.pubKey
    }

    return localPeerInfo
  }

  /**
   * Get the info to the given PeerId, PeerInfo or b58Str id
   *
   * @param {PeerId} peer
   * @returns {PeerInfo}
   */
  get (peer) {
    const b58Str = getB58Str(peer)

    const peerInfo = this._peers[b58Str]

    if (peerInfo) {
      return peerInfo
    }
    throw new Error('PeerInfo not found')
  }

  getAll () {
    return this._peers
  }

  getAllArray () {
    return Object.keys(this._peers).map((b58Str) => this._peers[b58Str])
  }

  getMultiaddrs (peer) {
    const info = this.get(peer)
    return info.multiaddrs.toArray()
  }

  remove (peer) {
    const b58Str = getB58Str(peer)

    if (this._peers[b58Str]) {
      delete this._peers[b58Str]
    }
  }
}

module.exports = PeerBook

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"peer-book",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-book\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block-service\\src\\index.js", {"async/map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-block-service\src\index.js
      return function (require, module, exports) {
'use strict'

const asyncMap = require('async/map')

/**
 * BlockService is a hybrid block datastore. It stores data in a local
 * datastore and may retrieve data from a remote Exchange.
 * It uses an internal `datastore.Datastore` instance to store values.
 */
class BlockService {
  /**
   * Create a new BlockService
   *
   * @param {IPFSRepo} ipfsRepo
   */
  constructor (ipfsRepo) {
    this._repo = ipfsRepo
    this._bitswap = null
  }

  /**
   * Add a bitswap instance that communicates with the
   * network to retreive blocks that are not in the local store.
   *
   * If the node is online all requests for blocks first
   * check locally and afterwards ask the network for the blocks.
   *
   * @param {Bitswap} bitswap
   * @returns {void}
   */
  setExchange (bitswap) {
    this._bitswap = bitswap
  }

  /**
   * Go offline, i.e. drop the reference to bitswap.
   *
   * @returns {void}
   */
  unsetExchange () {
    this._bitswap = null
  }

  /**
   * Is the blockservice online, i.e. is bitswap present.
   *
   * @returns {bool}
   */
  hasExchange () {
    return this._bitswap != null
  }

  /**
   * Put a block to the underlying datastore.
   *
   * @param {Block} block
   * @param {function(Error)} callback
   * @returns {void}
   */
  put (block, callback) {
    if (this.hasExchange()) {
      this._bitswap.put(block, callback)
    } else {
      this._repo.blocks.put(block, callback)
    }
  }

  /**
   * Put a multiple blocks to the underlying datastore.
   *
   * @param {Array<Block>} blocks
   * @param {function(Error)} callback
   * @returns {void}
   */
  putMany (blocks, callback) {
    if (this.hasExchange()) {
      this._bitswap.putMany(blocks, callback)
    } else {
      this._repo.blocks.putMany(blocks, callback)
    }
  }

  /**
   * Get a block by cid.
   *
   * @param {CID} cid
   * @param {function(Error, Block)} callback
   * @returns {void}
   */
  get (cid, callback) {
    if (this.hasExchange()) {
      this._bitswap.get(cid, callback)
    } else {
      this._repo.blocks.get(cid, callback)
    }
  }

  /**
   * Get multiple blocks back from an array of cids.
   *
   * @param {Array<CID>} cids
   * @param {function(Error, Block)} callback
   * @returns {void}
   */
  getMany (cids, callback) {
    if (!Array.isArray(cids)) {
      callback(new Error('first arg must be an array of cids'))
    } else if (this.hasExchange()) {
      this._bitswap.getMany(cids, callback)
    } else {
      asyncMap(cids, (cid, cb) => this._repo.blocks.get(cid, cb), callback)
    }
  }

  /**
   * Delete a block from the blockstore.
   *
   * @param {CID} cid
   * @param {function(Error)} callback
   * @return {void}
   */
  delete (cid, callback) {
    this._repo.blocks.delete(cid, callback)
  }
}

module.exports = BlockService

      };
    };
  }
}, {package:"ipfs-block-service",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block-service\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\state.js", {"debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","fsm-event":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm-event\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\state.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')
const log = debug('ipfs:state')
log.error = debug('ipfs:state:error')

const fsm = require('fsm-event')

module.exports = (self) => {
  const s = fsm('uninitialized', {
    uninitialized: {
      init: 'initializing',
      initialized: 'stopped'
    },
    initializing: {
      initialized: 'stopped'
    },
    stopped: {
      start: 'starting'
    },
    starting: {
      started: 'running'
    },
    running: {
      stop: 'stopping'
    },
    stopping: {
      stopped: 'stopped'
    }
  })

  // log events
  s.on('error', (err) => log.error(err))
  s.on('done', () => log('-> ' + s._state))

  // -- Actions

  s.init = () => {
    s('init')
  }

  s.initialized = () => {
    s('initialized')
  }

  s.stop = () => {
    s('stop')
  }

  s.stopped = () => {
    s('stopped')
  }

  s.start = () => {
    s('start')
  }

  s.started = () => {
    s('started')
  }

  s.state = () => s._state

  return s
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\constants.js","./name-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\name-table.js","./print":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\print.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\util.js","./varint-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\varint-table.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

const varint = require('varint')
const codecNameToCodeVarint = require('./varint-table')
const codeToCodecName = require('./name-table')
const util = require('./util')

exports = module.exports

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {string|number} multicodecStrOrCode
 * @param {Buffer} data
 * @returns {Buffer}
 */
exports.addPrefix = (multicodecStrOrCode, data) => {
  let prefix

  if (Buffer.isBuffer(multicodecStrOrCode)) {
    prefix = util.varintBufferEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return Buffer.concat([prefix, data])
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Buffer} data
 * @returns {Buffer}
 */
exports.rmPrefix = (data) => {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 * @param {Buffer} prefixedData
 * @returns {string}
 */
exports.getCodec = (prefixedData) => {
  const code = util.varintBufferDecode(prefixedData)
  const codecName = codeToCodecName[code.toString('hex')]
  if (codecName === undefined) {
    throw new Error('Code `0x' + code.toString('hex') + '` not found')
  }
  return codecName
}

/**
 * Get the name of the codec.
 * @param {number} codec
 * @returns {string}
 */
exports.getName = (codec) => {
  return codeToCodecName[codec.toString(16)]
}

/**
 * Get the code of the codec
 * @param {string} name
 * @returns {number}
 */
exports.getNumber = (name) => {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return util.varintBufferDecode(code)[0]
}

/**
 * Get the code of the prefixed data.
 * @param {Buffer} prefixedData
 * @returns {number}
 */
exports.getCode = (prefixedData) => {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 * @param {string} codecName
 * @returns {Buffer}
 */
exports.getCodeVarint = (codecName) => {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 * @param {Number} code
 * @returns {Array.<number>}
 */
exports.getVarint = (code) => {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')
Object.assign(exports, constants)

// Human friendly names for printing, e.g. in error messages
exports.print = require('./print')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js", {"./cid-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\cid-util.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","multicodec/src/base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\base-table.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\cids\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashes')
const multibase = require('multibase')
const multicodec = require('multicodec')
const codecs = require('multicodec/src/base-table')
const CIDUtil = require('./cid-util')
const withIs = require('class-is')

/**
 * @typedef {Object} SerializedCID
 * @param {string} codec
 * @param {number} version
 * @param {Buffer} multihash
 */

/**
 * Test if the given input is a CID.
 * @function isCID
 * @memberof CID
 * @static
 * @param {any} other
 * @returns {bool}
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Buffer)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {string|Buffer|CID} version
   * @param {string} [codec]
   * @param {Buffer} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.buffer>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    if (_CID.isCID(version)) {
      // version is an exising CID instance
      const cid = version
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = Buffer.from(cid.multihash)
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (Buffer.isBuffer(version)) {
      const firstByte = version.slice(0, 1)
      const v = parseInt(firstByte.toString('hex'), 16)
      if (v === 1) {
        // version is a CID buffer
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash buffer, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    /**
     * @type {number}
     */
    this.version = version

    /**
     * @type {string}
     */
    this.codec = codec

    /**
     * @type {Buffer}
     */
    this.multihash = multihash

    /**
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Buffer`
   *
   * @return {Buffer}
   * @readonly
   *
   * @memberOf CID
   */
  get buffer () {
    let buffer = this._buffer

    if (!buffer) {
      if (this.version === 0) {
        buffer = this.multihash
      } else if (this.version === 1) {
        buffer = Buffer.concat([
          Buffer.from('01', 'hex'),
          multicodec.getCodeVarint(this.codec),
          this.multihash
        ])
      } else {
        throw new Error('unsupported version')
      }

      // Cache this buffer so it doesn't have to be recreated
      Object.defineProperty(this, '_buffer', { value: buffer })
    }

    return buffer
  }

  /**
   * Get the prefix of the CID.
   *
   * @returns {Buffer}
   * @readonly
   */
  get prefix () {
    return Buffer.concat([
      Buffer.from(`0${this.version}`, 'hex'),
      multicodec.getCodeVarint(this.codec),
      mh.prefix(this.multihash)
    ])
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new _CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new _CID(1, this.codec, this.multihash)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {string} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    if (this.string && base === this.multibaseName) {
      return this.string
    }
    let str = null
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = multibase.encode(base, this.buffer).toString()
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {bool}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      this.multihash.equals(other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other
   * @returns {void}
   */
  static validateCID (other) {
    let errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }
}

const _CID = withIs(CID, {
  className: 'CID',
  symbolName: '@ipld/js-cid/CID'
})

_CID.codecs = codecs

module.exports = _CID

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"cids",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js", {"./multiaddr-set":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\multiaddr-set.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\utils.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peer-info\src\index.js
      return function (require, module, exports) {
'use strict'

const PeerId = require('peer-id')
const { ensureMultiaddr } = require('./utils')
const MultiaddrSet = require('./multiaddr-set')
const assert = require('assert')

// Peer represents a peer on the IPFS network
class PeerInfo {
  constructor (peerId) {
    assert(peerId, 'Missing peerId. Use Peer.create(cb) to create one')

    this.id = peerId
    this.multiaddrs = new MultiaddrSet()
    this.protocols = new Set()
    this._connectedMultiaddr = undefined
  }

  // only stores the current multiaddr being used
  connect (ma) {
    ma = ensureMultiaddr(ma)
    if (!this.multiaddrs.has(ma) && ma.toString() !== `/ipfs/${this.id.toB58String()}`) {
      throw new Error('can\'t be connected to missing multiaddr from set')
    }
    this._connectedMultiaddr = ma
  }

  disconnect () {
    this._connectedMultiaddr = undefined
  }

  isConnected () {
    return this._connectedMultiaddr
  }
}

PeerInfo.create = (peerId, callback) => {
  if (typeof peerId === 'function') {
    callback = peerId
    peerId = null

    PeerId.create((err, id) => {
      if (err) {
        return callback(err)
      }

      callback(null, new PeerInfo(id))
    })
    return
  }

  // Already a PeerId instance
  if (typeof peerId.toJSON === 'function') {
    callback(null, new PeerInfo(peerId))
  } else {
    PeerId.createFromJSON(peerId, (err, id) => callback(err, new PeerInfo(id)))
  }
}

PeerInfo.isPeerInfo = (peerInfo) => {
  return Boolean(typeof peerInfo === 'object' &&
    peerInfo.id &&
    peerInfo.multiaddrs)
}

module.exports = PeerInfo

      };
    };
  }
}, {package:"peer-info",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\config.js", {"mafmt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","superstruct":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superstruct\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\config.js
      return function (require, module, exports) {
'use strict'

const Multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const { struct, superstruct } = require('superstruct')

const { optional, union } = struct
const s = superstruct({
  types: {
    multiaddr: v => {
      if (v === null) {
        return `multiaddr invalid, value must be a string, Buffer, or another Multiaddr got ${v}`
      }

      try {
        Multiaddr(v)
      } catch (err) {
        return `multiaddr invalid, ${err.message}`
      }

      return true
    },
    'multiaddr-ipfs': v => mafmt.IPFS.matches(v) ? true : `multiaddr IPFS invalid`
  }
})

const configSchema = s({
  repo: optional(s('object|string')),
  repoOwner: 'boolean?',
  preload: s({
    enabled: 'boolean?',
    addresses: optional(s(['multiaddr'])),
    interval: 'number?'
  }, { enabled: true, interval: 30 * 1000 }),
  init: optional(union(['boolean', s({
    bits: 'number?',
    emptyRepo: 'boolean?',
    privateKey: optional(s('object|string')), // object should be a custom type for PeerId using 'kind-of'
    pass: 'string?'
  })])),
  start: 'boolean?',
  offline: 'boolean?',
  pass: 'string?',
  silent: 'boolean?',
  relay: 'object?', // relay validates in libp2p
  EXPERIMENTAL: optional(s({
    pubsub: 'boolean?',
    ipnsPubsub: 'boolean?',
    sharding: 'boolean?',
    dht: 'boolean?'
  })),
  connectionManager: 'object?',
  config: optional(s({
    API: 'object?',
    Addresses: optional(s({
      Swarm: optional(s(['multiaddr'])),
      API: 'multiaddr?',
      Gateway: 'multiaddr'
    })),
    Discovery: optional(s({
      MDNS: optional(s({
        Enabled: 'boolean?',
        Interval: 'number?'
      })),
      webRTCStar: optional(s({
        Enabled: 'boolean?'
      }))
    })),
    Bootstrap: optional(s(['multiaddr-ipfs']))
  })),
  ipld: 'object?',
  libp2p: optional(union(['function', 'object'])) // libp2p validates this
}, {
  repoOwner: true
})

const validate = (opts) => {
  const [err, options] = configSchema.validate(opts)

  if (err) {
    throw err
  }

  return options
}

module.exports = { validate }

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\config.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","libp2p-crypto/src/keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peer-id\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
 * Id is an object representation of a peer Id. a peer Id is a multihash
 */

'use strict'

const mh = require('multihashes')
const cryptoKeys = require('libp2p-crypto/src/keys')
const assert = require('assert')
const waterfall = require('async/waterfall')
const withIs = require('class-is')

class PeerId {
  constructor (id, privKey, pubKey) {
    assert(Buffer.isBuffer(id), 'invalid id provided')

    if (privKey && pubKey) {
      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')
    }

    this._id = id
    this._idB58String = mh.toB58String(this.id)
    this._privKey = privKey
    this._pubKey = pubKey
  }

  get id () {
    return this._id
  }

  set id (val) {
    throw new Error('Id is immutable')
  }

  get privKey () {
    return this._privKey
  }

  set privKey (privKey) {
    this._privKey = privKey
  }

  get pubKey () {
    if (this._pubKey) {
      return this._pubKey
    }

    if (this._privKey) {
      return this._privKey.public
    }
  }

  set pubKey (pubKey) {
    this._pubKey = pubKey
  }

  // Return the protobuf version of the public key, matching go ipfs formatting
  marshalPubKey () {
    if (this.pubKey) {
      return cryptoKeys.marshalPublicKey(this.pubKey)
    }
  }

  // Return the protobuf version of the private key, matching go ipfs formatting
  marshalPrivKey () {
    if (this.privKey) {
      return cryptoKeys.marshalPrivateKey(this.privKey)
    }
  }

  toPrint () {
    let pid = this.toB58String()
    // All sha256 nodes start with Qm
    // We can skip the Qm to make the peer.ID more useful
    if (pid.startsWith('Qm')) {
      pid = pid.slice(2)
    }
    let maxRunes = 6
    if (pid.length < maxRunes) {
      maxRunes = pid.length
    }

    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'
  }

  // return the jsonified version of the key, matching the formatting
  // of go-ipfs for its config file
  toJSON () {
    return {
      id: this.toB58String(),
      privKey: toB64Opt(this.marshalPrivKey()),
      pubKey: toB64Opt(this.marshalPubKey())
    }
  }

  // encode/decode functions
  toHexString () {
    return mh.toHexString(this.id)
  }

  toBytes () {
    return this.id
  }

  toB58String () {
    return this._idB58String
  }

  isEqual (id) {
    if (Buffer.isBuffer(id)) {
      return this.id.equals(id)
    } else if (id.id) {
      return this.id.equals(id.id)
    } else {
      throw new Error('not valid Id')
    }
  }

  /*
   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)
   */
  isValid (callback) {
    // TODO Needs better checking
    if (this.privKey &&
      this.privKey.public &&
      this.privKey.public.bytes &&
      Buffer.isBuffer(this.pubKey.bytes) &&
      this.privKey.public.bytes.equals(this.pubKey.bytes)) {
      callback()
    } else {
      callback(new Error('Keys not match'))
    }
  }
}

const PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })

exports = module.exports = PeerIdWithIs

const computeDigest = (pubKey, cb) => {
  if (pubKey.bytes.length <= 42) {
    const digest = mh.encode(pubKey.bytes, 'identity')
    cb(null, digest)
  } else {
    pubKey.hash((err, digest) => {
      cb(err, digest)
    })
  }
}

const computePeerId = (privKey, pubKey, cb) => {
  computeDigest(pubKey, (err, digest) => {
    if (err != null) {
      cb(err)
    } else {
      cb(null, new PeerIdWithIs(digest, privKey, pubKey))
    }
  })
}

// generation
exports.create = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts
    opts = {}
  }
  opts = opts || {}
  opts.bits = opts.bits || 2048
  opts.keyType = opts.keyType || 'RSA'

  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {
    if (err != null) {
      callback(err)
    } else {
      computePeerId(privKey, privKey.public, callback)
    }
  })
}

exports.createFromHexString = function (str) {
  return new PeerIdWithIs(mh.fromHexString(str))
}

exports.createFromBytes = function (buf) {
  return new PeerIdWithIs(buf)
}

exports.createFromB58String = function (str) {
  return new PeerIdWithIs(mh.fromB58String(str))
}

// Public Key input will be a buffer
exports.createFromPubKey = function (key, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let pubKey

  try {
    let buf = key
    if (typeof buf === 'string') {
      buf = Buffer.from(key, 'base64')
    }

    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')

    pubKey = cryptoKeys.unmarshalPublicKey(buf)
  } catch (err) {
    return callback(err)
  }

  computePeerId(null, pubKey, callback)
}

// Private key input will be a string
exports.createFromPrivKey = function (key, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let buf = key

  try {
    if (typeof buf === 'string') {
      buf = Buffer.from(key, 'base64')
    }

    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')
  } catch (err) {
    return callback(err)
  }

  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {
    if (err != null) {
      callback(err)
    } else {
      computePeerId(privKey, privKey.public, callback)
    }
  })
}

exports.createFromJSON = function (obj, callback) {
  if (typeof callback !== 'function') {
    throw new Error('callback is required')
  }

  let id
  let rawPrivKey
  let rawPubKey
  let pub

  try {
    id = mh.fromB58String(obj.id)
    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')
    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')
    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)
  } catch (err) {
    return callback(err)
  }

  if (!rawPrivKey) {
    callback(null, new PeerIdWithIs(id, null, pub))
    return
  }

  waterfall([
    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),
    (priv, cb) => {
      computeDigest(priv.public, (err, digest) => {
        cb(err, digest, priv)
      })
    },
    (privDigest, priv, cb) => {
      if (pub) {
        computeDigest(pub, (err, pubDigest) => {
          cb(err, privDigest, priv, pubDigest)
        })
      } else {
        cb(null, privDigest, priv)
      }
    }
  ], (err, privDigest, priv, pubDigest) => {
    if (err) {
      return callback(err)
    }

    if (pub && !privDigest.equals(pubDigest)) {
      return callback(new Error('Public and private key do not match'))
    }

    if (id && !privDigest.equals(id)) {
      return callback(new Error('Id and private key do not match'))
    }

    callback(null, new PeerIdWithIs(id, priv, pub))
  })
}

exports.isPeerId = function (peerId) {
  return Boolean(typeof peerId === 'object' &&
    peerId._id &&
    peerId._idB58String)
}

function toB64Opt (val) {
  if (val) {
    return val.toString('base64')
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"peer-id",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\index.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\util.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","ipfs-block":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block\\src\\index.js","ipld-dag-cbor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\index.js","ipld-dag-pb":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js","ipld-raw":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-raw\\src\\index.js","merge-options":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\merge-options\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","promisify-es6":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promisify-es6\\index.js","typical":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\typical\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipld\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Block = require('ipfs-block')
const CID = require('cids')
const mergeOptions = require('merge-options')
const ipldDagCbor = require('ipld-dag-cbor')
const ipldDagPb = require('ipld-dag-pb')
const ipldRaw = require('ipld-raw')
const multicodec = require('multicodec')
const promisify = require('promisify-es6')
const typical = require('typical')
const { extendIterator } = require('./util')

class IPLDResolver {
  constructor (userOptions) {
    const options = mergeOptions(IPLDResolver.defaultOptions, userOptions)

    if (!options.blockService) {
      throw new Error('Missing blockservice')
    }
    this.bs = options.blockService

    // Object with current list of active resolvers
    this.resolvers = {}

    if (typeof options.loadFormat !== 'function') {
      this.loadFormat = async (codec) => {
        const codecName = multicodec.print[codec]
        throw new Error(`No resolver found for codec "${codecName}"`)
      }
    } else {
      this.loadFormat = options.loadFormat
    }

    // Enable all supplied formats
    for (const format of options.formats) {
      this.addFormat(format)
    }
  }

  /**
   * Add support for an IPLD Format.
   *
   * @param {Object} format - The implementation of an IPLD Format.
   * @returns {this}
   */
  addFormat (format) {
    const codec = format.codec
    if (this.resolvers[format.format]) {
      const codecName = multicodec.print[codec]
      throw new Error(`Resolver already exists for codec "${codecName}"`)
    }

    this.resolvers[codec] = format

    return this
  }

  /**
   * Remove support for an IPLD Format.
   *
   * @param {number} codec - The codec of the IPLD Format to remove.
   * @returns {this}
   */
  removeFormat (codec) {
    if (this.resolvers[codec]) {
      delete this.resolvers[codec]
    }

    return this
  }

  /**
   * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.
   *
   * @param {CID} cid - the CID the resolving starts.
   * @param {string} path - the path that should be resolved.
   * @returns {Iterable.<Promise.<{remainderPath: string, value}>>} - Returns an async iterator of all the IPLD Nodes that were traversed during the path resolving. Every element is an object with these fields:
   *   - `remainderPath`: the part of the path that wasn’t resolved yet.
   *   - `value`: the value where the resolved path points to. If further traversing is possible, then the value is a CID object linking to another IPLD Node. If it was possible to fully resolve the path, value is the value the path points to. So if you need the CID of the IPLD Node you’re currently at, just take the value of the previously returned IPLD Node.
   */
  resolve (cid, path) {
    if (!CID.isCID(cid)) {
      throw new Error('`cid` argument must be a CID')
    }
    if (typeof path !== 'string') {
      throw new Error('`path` argument must be a string')
    }

    const generator = async function * () {
      // End iteration if there isn't a CID to follow anymore
      while (cid !== null) {
        const format = await this._getFormat(cid.codec)

        // get block
        // use local resolver
        // update path value
        const block = await promisify(this.bs.get.bind(this.bs))(cid)
        const result = format.resolver.resolve(block.data, path)

        // Prepare for the next iteration if there is a `remainderPath`
        path = result.remainderPath
        let value = result.value
        // NOTE vmx 2018-11-29: Not all IPLD Formats return links as
        // CIDs yet. Hence try to convert old style links to CIDs
        if (Object.keys(value).length === 1 && '/' in value) {
          try {
            value = new CID(value['/'])
          } catch (_error) {
            value = null
          }
        }
        cid = CID.isCID(value) ? value : null

        yield {
          remainderPath: path,
          value
        }
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Get a node by CID.
   *
   * @param {CID} cid - The CID of the IPLD Node that should be retrieved.
   * @returns {Promise.<Object>} - Returns a Promise with the IPLD Node that correspond to the given `cid`.
   */
  async get (cid) {
    const block = await promisify(this.bs.get.bind(this.bs))(cid)
    const format = await this._getFormat(block.cid.codec)
    const node = format.util.deserialize(block.data)

    return node
  }

  /**
   * Get multiple nodes back from an array of CIDs.
   *
   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.
   * @returns {Iterable.<Promise.<Object>>} - Returns an async iterator with the IPLD Nodes that correspond to the given `cids`.
   */
  getMany (cids) {
    if (!typical.isIterable(cids) || typeof cids === 'string' ||
        Buffer.isBuffer(cids)) {
      throw new Error('`cids` must be an iterable of CIDs')
    }

    const generator = async function * () {
      for await (const cid of cids) {
        yield this.get(cid)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Stores the given IPLD Node of a recognized IPLD Format.
   *
   * @param {Object} node - The deserialized IPLD node that should be inserted.
   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.
   * @param {Object} [userOptions] -  Options is an object with the following properties.
   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.
   * @param {number} [userOptions.cidVersion=1] - The CID version to use.
   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.
   * @returns {Promise.<CID>} - Returns the CID of the serialized IPLD Nodes.
   */
  async put (node, format, userOptions) {
    if (format === undefined) {
      throw new Error('`put` requires a format')
    }
    if (typeof format !== 'number') {
      throw new Error('`format` parameter must be number (multicodec)')
    }

    const formatImpl = await this._getFormat(format)
    const defaultOptions = {
      hashAlg: formatImpl.defaultHashAlg,
      cidVersion: 1,
      onlyHash: false
    }
    const options = mergeOptions(defaultOptions, userOptions)

    const cidOptions = {
      cidVersion: options.cidVersion,
      hashAlg: options.hashAlg,
      onlyHash: options.onlyHash
    }
    const serialized = formatImpl.util.serialize(node)
    const cid = await formatImpl.util.cid(serialized, cidOptions)

    if (!options.onlyHash) {
      const block = new Block(serialized, cid)
      await promisify(this.bs.put.bind(this.bs))(block)
    }

    return cid
  }

  /**
   * Stores the given IPLD Nodes of a recognized IPLD Format.
   *
   * @param {Iterable.<Object>} nodes - Deserialized IPLD nodes that should be inserted.
   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.
   * @param {Object} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.
   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.
   * @param {number} [userOptions.cidVersion=1] - The CID version to use.
   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.
   * @returns {Iterable.<Promise.<CID>>} - Returns an async iterator with the CIDs of the serialized IPLD Nodes.
   */
  putMany (nodes, format, userOptions) {
    if (!typical.isIterable(nodes) || typeof nodes === 'string' ||
        Buffer.isBuffer(nodes)) {
      throw new Error('`nodes` must be an iterable')
    }
    if (format === undefined) {
      throw new Error('`put` requires a format')
    }
    if (typeof format !== 'number') {
      throw new Error('`format` parameter must be number (multicodec)')
    }

    let options
    let formatImpl

    const generator = async function * () {
      for await (const node of nodes) {
        // Lazy load the options not when the iterator is initialized, but
        // when we hit the first iteration. This way the constructor can be
        // a synchronous function.
        if (options === undefined) {
          formatImpl = await this._getFormat(format)
          const defaultOptions = {
            hashAlg: formatImpl.defaultHashAlg,
            cidVersion: 1,
            onlyHash: false
          }
          options = mergeOptions(defaultOptions, userOptions)
        }

        yield this.put(node, format, options)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Remove an IPLD Node by the given CID.
   *
   * @param {CID} cid - The CID of the IPLD Node that should be removed.
   * @return {Promise.<CID>} The CID of the removed IPLD Node.
   */
  async remove (cid) {
    return promisify(this.bs.delete.bind(this.bs))(cid)
  }

  /**
   * Remove IPLD Nodes by the given CIDs.
   *
   * Throws an error if any of the Blocks can’t be removed. This operation is
   * *not* atomic, some Blocks might have already been removed.
   *
   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be removed.
   * @return {Iterable.<Promise.<CID>>} Returns an async iterator with the CIDs of the removed IPLD Nodes.
   */
  removeMany (cids) {
    if (!typical.isIterable(cids) || typeof cids === 'string' ||
        Buffer.isBuffer(cids)) {
      throw new Error('`cids` must be an iterable of CIDs')
    }

    const generator = async function * () {
      for await (const cid of cids) {
        yield this.remove(cid)
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /**
   * Returns all the paths that can be resolved into.
   *
   * @param {Object} cid - The ID to get the paths from
   * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.
   * @param {Object} [userOptions]
   * @param {number} [userOptions.recursive=false] - whether to get the paths recursively or not. `false` resolves only the paths of the given CID.
   * @returns {Iterable.<Promise.<String>>} - Returns an async iterator with paths that can be resolved into
   */
  tree (cid, offsetPath, userOptions) {
    if (typeof offsetPath === 'object') {
      userOptions = offsetPath
      offsetPath = undefined
    }
    offsetPath = offsetPath || ''

    const defaultOptions = {
      recursive: false
    }
    const options = mergeOptions(defaultOptions, userOptions)

    // If a path is a link then follow it and return its CID
    const maybeRecurse = async (block, treePath) => {
      // A treepath we might want to follow recursively
      const format = await this._getFormat(block.cid.codec)
      const result = format.resolver.resolve(block.data, treePath)
      // Something to follow recusively, hence push it into the queue
      if (CID.isCID(result.value)) {
        return result.value
      } else {
        return null
      }
    }

    const generator = async function * () {
      // The list of paths that will get returned
      const treePaths = []
      // The current block, needed to call `isLink()` on every interation
      let block
      // The list of items we want to follow recursively. The items are
      // an object consisting of the CID and the currently already resolved
      // path
      const queue = [{ cid, basePath: '' }]
      // The path that was already traversed
      let basePath

      // End of iteration if there aren't any paths left to return or
      // if we don't want to traverse recursively and have already
      // returne the first level
      while (treePaths.length > 0 || queue.length > 0) {
        // There aren't any paths left, get them from the given CID
        if (treePaths.length === 0 && queue.length > 0) {
          ({ cid, basePath } = queue.shift())
          const format = await this._getFormat(cid.codec)
          block = await promisify(this.bs.get.bind(this.bs))(cid)

          const paths = format.resolver.tree(block.data)
          treePaths.push(...paths)
        }

        const treePath = treePaths.shift()
        let fullPath = basePath + treePath

        // Only follow links if recursion is intended
        if (options.recursive) {
          cid = await maybeRecurse(block, treePath)
          if (cid !== null) {
            queue.push({ cid, basePath: fullPath + '/' })
          }
        }

        // Return it if it matches the given offset path, but is not the
        // offset path itself
        if (fullPath.startsWith(offsetPath) &&
            fullPath.length > offsetPath.length) {
          if (offsetPath.length > 0) {
            fullPath = fullPath.slice(offsetPath.length + 1)
          }

          yield fullPath
        }
      }
    }.bind(this)

    return extendIterator(generator())
  }

  /*           */
  /* internals */
  /*           */
  async _getFormat (codec) {
    // TODO vmx 2019-01-24: Once all CIDs support accessing the codec code
    // instead of the name, remove this part
    if (typeof codec === 'string') {
      const constantName = codec.toUpperCase().replace(/-/g, '_')
      codec = multicodec[constantName]
    }

    if (this.resolvers[codec]) {
      return this.resolvers[codec]
    }

    // If not supported, attempt to dynamically load this format
    const format = await this.loadFormat(codec)
    this.addFormat(format)
    return format
  }
}

/**
 * Default options for IPLD.
 */
IPLDResolver.defaultOptions = {
  formats: [ipldDagCbor, ipldDagPb, ipldRaw]
}

module.exports = IPLDResolver

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipld",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\constants.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multibase\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */
'use strict'

const constants = require('./constants')

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.names = Object.freeze(Object.keys(constants.names))
exports.codes = Object.freeze(Object.keys(constants.codes))

const errNotSupported = new Error('Unsupported encoding')

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const base = getBase(nameOrCode)
  const codeBuf = Buffer.from(base.code)

  const name = base.name
  validEncode(name, buf)
  return Buffer.concat([codeBuf, buf])
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */
function encode (nameOrCode, buf) {
  const base = getBase(nameOrCode)
  const name = base.name

  return multibase(name, Buffer.from(base.encode(buf)))
}

/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */
function decode (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  const code = bufOrString.substring(0, 1)
  bufOrString = bufOrString.substring(1, bufOrString.length)

  if (typeof bufOrString === 'string') {
    bufOrString = Buffer.from(bufOrString)
  }

  const base = getBase(code)
  return Buffer.from(base.decode(bufOrString.toString()))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */
function isEncoded (bufOrString) {
  if (Buffer.isBuffer(bufOrString)) {
    bufOrString = bufOrString.toString()
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
    return false
  }

  const code = bufOrString.substring(0, 1)
  try {
    const base = getBase(code)
    return base.name
  } catch (err) {
    return false
  }
}

/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */
function validEncode (name, buf) {
  const base = getBase(name)
  base.decode(buf.toString())
}

function getBase (nameOrCode) {
  let base

  if (constants.names[nameOrCode]) {
    base = constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    base = constants.codes[nameOrCode]
  } else {
    throw errNotSupported
  }

  if (!base.isImplemented()) {
    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
  }

  return base
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js", {"./codec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\codec.js","./protocols-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\protocols-table.js","bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multiaddr\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const codec = require('./codec')
const protocols = require('./protocols-table')
const varint = require('varint')
const bs58 = require('bs58')
const withIs = require('class-is')

/**
 * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from
 * a Buffer, String or another Multiaddr instance
 * public key.
 * @class Multiaddr
 * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere
 * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 */
const Multiaddr = withIs.proto(function (addr) {
  if (!(this instanceof Multiaddr)) {
    return new Multiaddr(addr)
  }

  // default
  if (addr == null) {
    addr = ''
  }

  if (addr instanceof Buffer) {
    /**
     * @type {Buffer} - The raw bytes representing this multiaddress
     */
    this.buffer = codec.fromBuffer(addr)
  } else if (typeof addr === 'string' || addr instanceof String) {
    if (addr.length > 0 && addr.charAt(0) !== '/') {
      throw new Error(`multiaddr "${addr}" must start with a "/"`)
    }
    this.buffer = codec.fromString(addr)
  } else if (addr.buffer && addr.protos && addr.protoCodes) { // Multiaddr
    this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer
  } else {
    throw new Error('addr must be a string, Buffer, or another Multiaddr')
  }
}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })

/**
 * Returns Multiaddr as a String
 *
 * @returns {String}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
 * // '/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.toString = function toString () {
  return codec.bufferToString(this.buffer)
}

/**
 * Returns Multiaddr as a JSON encoded object
 *
 * @returns {String}
 * @example
 * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))
 * // '/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.toJSON = Multiaddr.prototype.toString

/**
 * Returns Multiaddr as a convinient options object to be used with net.createConnection
 *
 * @returns {{family: String, host: String, transport: String, port: String}}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
 * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }
 */
Multiaddr.prototype.toOptions = function toOptions () {
  const opts = {}
  const parsed = this.toString().split('/')
  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'
  opts.host = parsed[2]
  opts.transport = parsed[3]
  opts.port = parsed[4]
  return opts
}

/**
 * Returns Multiaddr as a human-readable string
 *
 * @returns {String}
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
 * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
 */
Multiaddr.prototype.inspect = function inspect () {
  return '<Multiaddr ' +
    this.buffer.toString('hex') + ' - ' +
    codec.bufferToString(this.buffer) + '>'
}

/**
 * Returns the protocols the Multiaddr is defined with, as an array of objects, in
 * left-to-right order. Each object contains the protocol code, protocol name,
 * and the size of its address space in bits.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @returns {Array.<Object>} protocols - All the protocols the address is composed of
 * @returns {Number} protocols[].code
 * @returns {Number} protocols[].size
 * @returns {String} protocols[].name
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
 * // [ { code: 4, size: 32, name: 'ip4' },
 * //   { code: 6, size: 16, name: 'tcp' } ]
 */
Multiaddr.prototype.protos = function protos () {
  return this.protoCodes().map(code => Object.assign({}, protocols(code)))
}

/**
 * Returns the codes of the protocols in left-to-right order.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @returns {Array.<Number>} protocol codes
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
 * // [ 4, 6 ]
 */
Multiaddr.prototype.protoCodes = function protoCodes () {
  const codes = []
  const buf = this.buffer
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)
    const size = codec.sizeForAddr(p, buf.slice(i + n))

    i += (size + n)
    codes.push(code)
  }

  return codes
}

/**
 * Returns the names of the protocols in left-to-right order.
 * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
 *
 * @return {Array.<String>} protocol names
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
 * // [ 'ip4', 'tcp' ]
 */
Multiaddr.prototype.protoNames = function protoNames () {
  return this.protos().map(proto => proto.name)
}

/**
 * Returns a tuple of parts
 *
 * @return {Array.<Array>} tuples
 * @return {Number} tuples[].0 code of protocol
 * @return {Buffer} tuples[].1 contents of address
 * @example
 * Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
 * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
 */
Multiaddr.prototype.tuples = function tuples () {
  return codec.bufferToTuples(this.buffer)
}

/**
 * Returns a tuple of string/number parts
 *
 * @return {Array.<Array>} tuples
 * @return {Number} tuples[].0 code of protocol
 * @return {(String|Number)} tuples[].1 contents of address
 * @example
 * Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
 * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]
 */
Multiaddr.prototype.stringTuples = function stringTuples () {
  const t = codec.bufferToTuples(this.buffer)
  return codec.tuplesToStringTuples(t)
}

/**
 * Encapsulates a Multiaddr in another Multiaddr
 *
 * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr
 * @return {Multiaddr}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
 *
 * mh3.toString()
 * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
 */
Multiaddr.prototype.encapsulate = function encapsulate (addr) {
  addr = Multiaddr(addr)
  return Multiaddr(this.toString() + addr.toString())
}

/**
 * Decapsulates a Multiaddr from another Multiaddr
 *
 * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr
 * @return {Multiaddr}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
 *
 * mh3.decapsulate(mh2).toString()
 * // '/ip4/8.8.8.8/tcp/1080'
 */
Multiaddr.prototype.decapsulate = function decapsulate (addr) {
  addr = addr.toString()
  const s = this.toString()
  const i = s.lastIndexOf(addr)
  if (i < 0) {
    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)
  }
  return Multiaddr(s.slice(0, i))
}

/**
 * Extract the peerId if the multiaddr contains one
 *
 * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
 *
 * // should return QmValidBase58string or null if the id is missing or invalid
 * const peerId = mh1.getPeerId()
 */
Multiaddr.prototype.getPeerId = function getPeerId () {
  let b58str = null
  try {
    b58str = this.stringTuples().filter((tuple) => {
      if (tuple[0] === protocols.names.ipfs.code) {
        return true
      }
    })[0][1]

    bs58.decode(b58str)
  } catch (e) {
    b58str = null
  }

  return b58str
}

/**
 * Extract the path if the multiaddr contains one
 *
 * @return {String|null} path - The path of the multiaddr, or null if no path protocol is present
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
 *
 * // should return utf8 string or null if the id is missing or invalid
 * const path = mh1.getPath()
 */
Multiaddr.prototype.getPath = function getPath () {
  let path = null
  try {
    path = this.stringTuples().filter((tuple) => {
      const proto = protocols(tuple[0])
      if (proto.path) {
        return true
      }
    })[0][1]
  } catch (e) {
    path = null
  }

  return path
}

/**
 * Checks if two Multiaddrs are the same
 *
 * @param {Multiaddr} addr
 * @return {Bool}
 * @example
 * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')
 * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
 *
 * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 *
 * mh1.equals(mh1)
 * // true
 *
 * mh1.equals(mh2)
 * // false
 */
Multiaddr.prototype.equals = function equals (addr) {
  return this.buffer.equals(addr.buffer)
}

/**
 * Gets a Multiaddrs node-friendly address object. Note that protocol information
 * is left out: in Node (and most network systems) the protocol is unknowable
 * given only the address.
 *
 * Has to be a ThinWaist Address, otherwise throws error
 *
 * @returns {{family: String, address: String, port: String}}
 * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
 * @example
 * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
 * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}
 */
Multiaddr.prototype.nodeAddress = function nodeAddress () {
  const codes = this.protoCodes()
  const names = this.protoNames()
  const parts = this.toString().split('/').slice(1)

  if (parts.length < 4) {
    throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".')
  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
    throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`)
  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {
    throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
  }

  return {
    family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,
    address: parts[1], // ip addr
    port: parts[3] // tcp or udp port
  }
}

/**
 * Creates a Multiaddr from a node-friendly address object
 *
 * @param {String} addr
 * @param {String} transport
 * @returns {Multiaddr} multiaddr
 * @throws {Error} Throws error if addr is not truthy
 * @throws {Error} Throws error if transport is not truthy
 * @example
 * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 */
Multiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {
  if (!addr) throw new Error('requires node address object')
  if (!transport) throw new Error('requires transport protocol')
  const ip = (addr.family === 'IPv6') ? 'ip6' : 'ip4'
  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))
}

// TODO find a better example, not sure about it's good enough
/**
 * Returns if a Multiaddr is a Thin Waist address or not.
 *
 * Thin Waist is if a Multiaddr adheres to the standard combination of:
 *
 * `{IPv4, IPv6}/{TCP, UDP}`
 *
 * @param {Multiaddr} [addr] - Defaults to using `this` instance
 * @returns {Boolean} isThinWaistAddress
 * @example
 * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
 * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')
 * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
 * const mh3 = mh1.encapsulate(mh2)
 * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
 * mh1.isThinWaistAddress()
 * // true
 * mh2.isThinWaistAddress()
 * // true
 * mh3.isThinWaistAddress()
 * // false
 */
Multiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {
  const protos = (addr || this).protos()

  if (protos.length !== 2) {
    return false
  }

  if (protos[0].code !== 4 && protos[0].code !== 41) {
    return false
  }
  if (protos[1].code !== 6 && protos[1].code !== 273) {
    return false
  }
  return true
}

/**
 * Object containing table, names and codes of all supported protocols.
 * To get the protocol values from a Multiaddr, you can use
 * [`.protos()`](#multiaddrprotos),
 * [`.protoCodes()`](#multiaddrprotocodes) or
 * [`.protoNames()`](#multiaddrprotonames)
 *
 * @instance
 * @returns {{table: Array, names: Object, codes: Object}}
 *
 */
Multiaddr.protocols = protocols

/**
 * Returns if something is a Multiaddr that is a name
 *
 * @param {Multiaddr} addr
 * @return {Bool} isName
 */
Multiaddr.isName = function isName (addr) {
  if (!Multiaddr.isMultiaddr(addr)) {
    return false
  }

  // if a part of the multiaddr is resolvable, then return true
  return addr.protos().some((proto) => proto.resolvable)
}

/**
 * Returns an array of multiaddrs, by resolving the multiaddr that is a name
 *
 * @param {Multiaddr} addr
 *
 * @param {Function} callback
 * @return {Bool} isName
 */
Multiaddr.resolve = function resolve (addr, callback) {
  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {
    return callback(new Error('not a valid name'))
  }

  /*
   * Needs more consideration from spec design:
   *   - what to return
   *   - how to achieve it in the browser?
   */
  return callback(new Error('not implemented yet'))
}

exports = module.exports = Multiaddr

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multiaddr",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\preload.js", {"./runtime/preload-nodejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\preload-browser.js","async/retry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\retry.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","multiaddr-to-uri":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr-to-uri\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\preload.js
      return function (require, module, exports) {
'use strict'

const setImmediate = require('async/setImmediate')
const retry = require('async/retry')
const toUri = require('multiaddr-to-uri')
const debug = require('debug')
const CID = require('cids')
const preload = require('./runtime/preload-nodejs')

const log = debug('ipfs:preload')
log.error = debug('ipfs:preload:error')

const noop = (err) => { if (err) log.error(err) }

module.exports = self => {
  const options = self._options.preload || {}
  options.enabled = Boolean(options.enabled)
  options.addresses = options.addresses || []

  if (!options.enabled || !options.addresses.length) {
    log('preload disabled')
    const api = (_, callback) => {
      if (callback) {
        setImmediate(() => callback())
      }
    }
    api.start = () => {}
    api.stop = () => {}
    return api
  }

  let stopped = true
  let requests = []
  const apiUris = options.addresses.map(apiAddrToUri)

  const api = (cid, callback) => {
    callback = callback || noop

    if (typeof cid !== 'string') {
      try {
        cid = new CID(cid).toBaseEncodedString()
      } catch (err) {
        return setImmediate(() => callback(err))
      }
    }

    const fallbackApiUris = Array.from(apiUris)
    let request
    const now = Date.now()

    retry({ times: fallbackApiUris.length }, (cb) => {
      if (stopped) return cb(new Error(`preload aborted for ${cid}`))

      // Remove failed request from a previous attempt
      requests = requests.filter(r => r !== request)

      const apiUri = fallbackApiUris.shift()

      request = preload(`${apiUri}/api/v0/refs?r=true&arg=${cid}`, cb)
      requests = requests.concat(request)
    }, (err) => {
      requests = requests.filter(r => r !== request)

      if (err) {
        return callback(err)
      }

      log(`preloaded ${cid} in ${Date.now() - now}ms`)
      callback()
    })
  }

  api.start = () => {
    stopped = false
  }

  api.stop = () => {
    stopped = true
    log(`canceling ${requests.length} pending preload request(s)`)
    requests.forEach(r => r.cancel())
    requests = []
  }

  return api
}

function apiAddrToUri (addr) {
  if (!(addr.endsWith('http') || addr.endsWith('https'))) {
    addr = addr + '/http'
  }
  return toUri(addr)
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\preload.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\node_modules\\multihashing-async\\src\\index.js", {"./crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\node_modules\\multihashing-async\\src\\crypto.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\node_modules\multihashing-async\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = (data, hash, callback) => {
  let algo = multihash.decode(hash).name
  Multihashing(data, algo, (err, newHash) => {
    if (err) return callback(err)
    callback(err, Buffer.compare(hash, newHash) === 0)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\node_modules\\multihashing-async\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\ipld-browser.js", {"ipld-dag-cbor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\index.js","ipld-dag-pb":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js","ipld-raw":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-raw\\src\\index.js","merge-options":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\merge-options\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\runtime\ipld-browser.js
      return function (require, module, exports) {
'use strict'
const mergeOptions = require('merge-options')
const ipldDagCbor = require('ipld-dag-cbor')
const ipldDagPb = require('ipld-dag-pb')
const ipldRaw = require('ipld-raw')

module.exports = (blockService, options = {}) => {
  return mergeOptions.call(
    // ensure we have the defaults formats even if the user overrides `formats: []`
    { concatArrays: true },
    {
      blockService: blockService,
      formats: [ipldDagCbor, ipldDagPb, ipldRaw]
    }, options)
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\ipld-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\boot.js", {"async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","ipfs-repo":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\boot.js
      return function (require, module, exports) {
'use strict'

const waterfall = require('async/waterfall')
const RepoErrors = require('ipfs-repo').errors

// Boot an IPFS node depending on the options set
module.exports = (self) => {
  self.log('booting')
  const options = self._options
  const doInit = options.init
  const doStart = options.start

  // Do the actual boot sequence
  waterfall([
    // Checks if a repo exists, and if so opens it
    // Will return callback with a bool indicating the existence
    // of the repo
    (cb) => {
      // nothing to do
      if (!self._repo.closed) {
        return cb(null, true)
      }

      self._repo.open((err, res) => {
        if (isRepoUninitializedError(err)) return cb(null, false)
        if (err) return cb(err)
        cb(null, true)
      })
    },
    (repoOpened, cb) => {
      // Init with existing initialized, opened, repo
      if (repoOpened) {
        return self.init({ repo: self._repo }, (err) => {
          if (err) return cb(Object.assign(err, { emitted: true }))
          cb()
        })
      }

      if (doInit) {
        const initOptions = Object.assign(
          { bits: 2048, pass: self._options.pass },
          typeof options.init === 'object' ? options.init : {}
        )
        return self.init(initOptions, (err) => {
          if (err) return cb(Object.assign(err, { emitted: true }))
          cb()
        })
      }

      cb()
    },
    (cb) => {
      // No problem, we don't have to start the node
      if (!doStart) {
        return cb()
      }

      self.start((err) => {
        if (err) return cb(Object.assign(err, { emitted: true }))
        cb()
      })
    }
  ], (err) => {
    if (err) {
      if (!err.emitted) {
        self.emit('error', err)
      }
      return
    }
    self.log('booted')
    self.emit('ready')
  })
}

function isRepoUninitializedError (err) {
  if (!err) {
    return false
  }

  // If the error is that no repo exists,
  // which happens when the version file is not found
  // we just want to signal that no repo exist, not
  // fail the whole process.

  // Use standardized errors as much as possible
  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {
    return true
  }

  // TODO: As error codes continue to be standardized, this logic can be phase out;
  // it is here to maintain compatibility
  if (err.message.match(/not found/) || // indexeddb
    err.message.match(/ENOENT/) || // fs
    err.message.match(/No value/) // memory
  ) {
    return true
  }

  return false
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\boot.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js", {"./aes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\aes\\index.js","./hmac":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\hmac\\index-browser.js","./keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\index.js","./pbkdf2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\pbkdf2.js","./random-bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\random-bytes.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-crypto\src\index.js
      return function (require, module, exports) {
'use strict'

const hmac = require('./hmac')
const aes = require('./aes')
const keys = require('./keys')

exports = module.exports

exports.aes = aes
exports.hmac = hmac
exports.keys = keys
exports.randomBytes = require('./random-bytes')
exports.pbkdf2 = require('./pbkdf2')

      };
    };
  }
}, {package:"libp2p-crypto",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\index.js", {"./bitswap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\bitswap.js","./block":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\block.js","./bootstrap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\bootstrap.js","./config":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\config.js","./dag":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\dag.js","./dht":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\dht.js","./dns":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\dns.js","./files-mfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\files-mfs.js","./files-regular":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\files-regular\\index.js","./id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\id.js","./init":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\init.js","./is-online":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\is-online.js","./key":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\key.js","./libp2p":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\libp2p.js","./name":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\name.js","./object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\object.js","./pin":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\pin.js","./ping":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\ping.js","./ping-pull-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\ping-pull-stream.js","./ping-readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\ping-readable-stream.js","./pre-start":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\pre-start.js","./pubsub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\pubsub.js","./repo":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\repo.js","./resolve":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\resolve.js","./start":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\start.js","./stats":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\stats.js","./stop":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\stop.js","./swarm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\swarm.js","./version":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\version.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\components\index.js
      return function (require, module, exports) {
'use strict'

exports.preStart = require('./pre-start')
exports.start = require('./start')
exports.stop = require('./stop')
exports.isOnline = require('./is-online')
exports.version = require('./version')
exports.id = require('./id')
exports.repo = require('./repo')
exports.init = require('./init')
exports.bootstrap = require('./bootstrap')
exports.config = require('./config')
exports.block = require('./block')
exports.object = require('./object')
exports.dag = require('./dag')
exports.libp2p = require('./libp2p')
exports.swarm = require('./swarm')
exports.ping = require('./ping')
exports.pingPullStream = require('./ping-pull-stream')
exports.pingReadableStream = require('./ping-readable-stream')
exports.pin = require('./pin')
exports.filesRegular = require('./files-regular')
exports.filesMFS = require('./files-mfs')
exports.bitswap = require('./bitswap')
exports.pubsub = require('./pubsub')
exports.dht = require('./dht')
exports.dns = require('./dns')
exports.key = require('./key')
exports.stats = require('./stats')
exports.resolve = require('./resolve')
exports.name = require('./name')

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\components\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\node_modules\\fast-deep-equal\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fast-json-patch\node_modules\fast-deep-equal\index.js
      return function (require, module, exports) {
'use strict';

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};

      };
    };
  }
}, {package:"fast-deep-equal",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-json-patch\\node_modules\\fast-deep-equal\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\equals.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\uint8arrays\equals.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns true if the two passed Uint8Arrays have the same content
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */
function equals (a, b) {
  if (a === b) {
    return true
  }

  if (a.byteLength !== b.byteLength) {
    return false
  }

  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false
    }
  }

  return true
}

module.exports = equals

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\equals.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\uint8arrays\concat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {number} [length]
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\concat.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\cid-util.js", {"multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\src\cid-util.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')

const CIDUtil = {
  /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string|undefined}
   */
  checkCIDComponents: function (other) {
    if (other == null) {
      return 'null values are not valid CIDs'
    }

    if (!(other.version === 0 || other.version === 1)) {
      return 'Invalid version, must be a number equal to 1 or 0'
    }

    if (typeof other.codec !== 'string') {
      return 'codec must be string'
    }

    if (other.version === 0) {
      if (other.codec !== 'dag-pb') {
        return "codec must be 'dag-pb' for CIDv0"
      }
      if (other.multibaseName !== 'base58btc') {
        return "multibaseName must be 'base58btc' for CIDv0"
      }
    }

    if (!(other.multihash instanceof Uint8Array)) {
      return 'multihash must be a Uint8Array'
    }

    try {
      mh.validate(other.multihash)
    } catch (err) {
      let errorMsg = err.message
      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
        errorMsg = 'Multihash validation failed'
      }
      return errorMsg
    }
  }
}

module.exports = CIDUtil

      };
    };
  }
}, {package:"cids",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\src\\cid-util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\to-string.js", {"multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\uint8arrays\to-string.js
      return function (require, module, exports) {
'use strict'

const { encoding: getCodec } = require('multibase')
const utf8Decoder = new TextDecoder('utf8')

/**
 * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
 */

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array - The array to turn into a string
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array - The array to turn into a string
 * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
 * @returns {string}
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  return getCodec(encoding).encode(array)
}

module.exports = toString

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\to-string.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\src\\index.js", {"./maps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\src\\maps.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\src\\util.js","uint8arrays/concat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\concat.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\multicodec\src\index.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecCode} CodecCode */

const varint = require('varint')
const uint8ArrayConcat = require('uint8arrays/concat')
const util = require('./util')
const { nameToVarint, constantToCode, nameToCode, codeToName } = require('./maps')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (nameToVarint[multicodecStrOrCode]) {
      prefix = nameToVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }

  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(/** @type {Buffer} */(data))
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getNameFromData (prefixedData) {
  const code = /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
  const name = codeToName[code]
  if (name === undefined) {
    throw new Error(`Code "${code}" not found`)
  }
  return name
}

/**
 * Get the codec name from a code.
 *
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getNameFromCode (codec) {
  return codeToName[codec]
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getCodeFromName (name) {
  const code = nameToCode[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCodeFromData (prefixedData) {
  return /** @type {CodecCode} */(varint.decode(/** @type {Buffer} */(prefixedData)))
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getVarintFromName (name) {
  const code = nameToVarint[name]
  if (code === undefined) {
    throw new Error(`Codec "${name}" not found`)
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecCode} code
 * @returns {Uint8Array}
 */
function getVarintFromCode (code) {
  return util.varintEncode(code)
}

/**
 * Get the codec name of the prefixed data.
 *
 * @deprecated use getNameFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  return getNameFromData(prefixedData)
}

/**
 * Get the codec name from a code.
 *
 * @deprecated use getNameFromCode instead.
 * @param {CodecCode} codec
 * @returns {CodecName}
 */
function getName (codec) {
  return getNameFromCode(codec)
}

/**
 * Get the code of the codec
 *
 * @deprecated use getCodeFromName instead.
 * @param {CodecName} name
 * @returns {CodecCode}
 */
function getNumber (name) {
  return getCodeFromName(name)
}

/**
 * Get the code of the prefixed data.
 *
 * @deprecated use getCodeFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */
function getCode (prefixedData) {
  return getCodeFromData(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @deprecated use getVarintFromName instead.
 * @param {CodecName} name
 * @returns {Uint8Array}
 */
function getCodeVarint (name) {
  return getVarintFromName(name)
}

/**
 * Get the varint of a code.
 *
 * @deprecated use getVarintFromCode instead.
 * @param {CodecCode} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return Array.from(getVarintFromCode(code))
}

module.exports = {
  addPrefix,
  rmPrefix,
  getNameFromData,
  getNameFromCode,
  getCodeFromName,
  getCodeFromData,
  getVarintFromName,
  getVarintFromCode,
  // Deprecated
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  // Make the constants top-level constants
  ...constantToCode,
  // Export the maps
  nameToVarint,
  nameToCode,
  codeToName
}

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multicodec\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multihashes\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multihashes\\src\\constants.js","multibase":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\index.js","uint8arrays/concat":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\concat.js","uint8arrays/from-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\uint8arrays\\to-string.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\multihashes\src\index.js
      return function (require, module, exports) {
/**
 * Multihash implementation in JavaScript.
 */
'use strict'

const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')
const uint8ArrayConcat = require('uint8arrays/concat')

const codes = /** @type {__import__('./types').CodeNameMap} */({})

// eslint-disable-next-line guard-for-in
for (const key in names) {
  const name = /** @type {HashName} */(key)
  codes[names[name]] = name
}
Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return uint8ArrayToString(hash, 'base16')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Uint8Array}
 */
function fromHexString (hash) {
  return uint8ArrayFromString(hash, 'base16')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Uint8Array}
 */
function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? uint8ArrayToString(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result
 */
function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }

  if (bytes.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = /** @type {HashCode} */(varint.decode(bytes))
  if (!isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  bytes = bytes.slice(varint.decode.bytes)

  const len = varint.decode(bytes)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  bytes = bytes.slice(varint.decode.bytes)

  if (bytes.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: bytes
  }
}

/**
 * Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {HashName | HashCode} code
 * @param {number} [length]
 * @returns {Uint8Array}
 */
function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 *
 * @param {HashName | number} name
 * @returns {number}
 */
function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  // @ts-ignore
  if (codes[code] === undefined && !isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks if a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
function isAppCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {HashCode} code
 * @returns {boolean}
 */
function isValidCode (code) {
  if (isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  decode(multihash) // throws if bad.
}

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 * @throws {Error}
 */
function prefix (multihash) {
  validate(multihash)

  return multihash.subarray(0, 2)
}

module.exports = {
  names,
  codes,
  toHexString,
  fromHexString,
  toB58String,
  fromB58String,
  decode,
  encode,
  coerceCode,
  isAppCode,
  validate,
  prefix,
  isValidCode
}

/**
 * @typedef { __import__("./constants").HashCode } HashCode
 * @typedef { __import__("./constants").HashName } HashName
 */

      };
    };
  }
}, {package:"multihashes",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multihashes\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\constants.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\cids\node_modules\multibase\src\index.js
      return function (require, module, exports) {
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 */
'use strict'

const constants = require('./constants')
const { encodeText, decodeText, concat } = require('./util')

/** @typedef {__import__('./base')} Base */
/** @typedef {__import__("./types").BaseNameOrCode} BaseNameOrCode */
/** @typedef {__import__("./types").BaseCode} BaseCode */
/** @typedef {__import__("./types").BaseName} BaseName */

/**
 * Create a new Uint8Array with the multibase varint+code.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded Uint8Array')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  return concat([codeBuf, buf], codeBuf.length + buf.length)
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)
  const data = encodeText(enc.encode(buf))

  return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(/** @type {BaseCode} */(data[0]))
  return enc.decode(data.substring(1))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(/** @type {BaseCode} */(data[0]))
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {BaseNameOrCode} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {BaseNameOrCode} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {
    return constants.names[/** @type {BaseName} */(nameOrCode)]
  } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {
    return constants.codes[/** @type {BaseCode} */(nameOrCode)]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(/** @type {BaseCode} */(data[0]))
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
const names = Object.freeze(constants.names)
const codes = Object.freeze(constants.codes)
exports.names = names
exports.codes = codes

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\cids\\node_modules\\multibase\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\encode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\varint\encode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\encode.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\decode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\varint\decode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\decode.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\varint\length.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\length.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js", {"./base.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js","./rfc4648":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js","base-x":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multibase\src\constants.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const baseX = require('base-x')
const Base = require('./base.js')
const rfc4648 = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 * @typedef {__import__('./base').CodecFactory} CodecFactory
 *
 * name, code, implementation, alphabet
 * @type {Array<[string, string, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names,
  codes
}

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","web-encoding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multibase\src\util.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const { Buffer } = require('buffer')
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * @param {ArrayBufferView} bytes
 * @returns {Buffer}
 */
const asBuffer = ({ buffer, byteLength, byteOffset }) =>
  Buffer.from(buffer, byteOffset, byteLength)

module.exports = { decodeText, encodeText, asBuffer }

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\src\base-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameNumberMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\node_modules\varint\encode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\node_modules\varint\length.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\multicodec\node_modules\varint\decode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
}, {package:"varint",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js", {"multibase/src/constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\node_modules\\multibase\\src\\constants.js","web-encoding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\uint8arrays\to-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextDecoder } = require('web-encoding')
const utf8Decoder = new TextDecoder('utf8')

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array The array to turn into a string
 * @returns {String}
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array The array to turn into a string
 * @param {String} [encoding=utf8] The encoding to use
 * @returns {String}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.encode(array)
}

module.exports = toString

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js", {"multibase/src/constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\node_modules\\multibase\\src\\constants.js","web-encoding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ensdomains\content-hash\node_modules\uint8arrays\from-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextEncoder } = require('web-encoding')
const utf8Encoder = new TextEncoder()

/**
 * Interperets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {String} string The string to turn into an array
 * @returns {Uint8Array}
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {String} string
 * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.decode(string)
}

module.exports = fromString

      };
    };
  }
}, {package:"uint8arrays",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-retry-allowed\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\is-retry-allowed\index.js
      return function (require, module, exports) {
'use strict';

var WHITELIST = [
	'ETIMEDOUT',
	'ECONNRESET',
	'EADDRINUSE',
	'ESOCKETTIMEDOUT',
	'ECONNREFUSED',
	'EPIPE',
	'EHOSTUNREACH',
	'EAI_AGAIN'
];

var BLACKLIST = [
	'ENOTFOUND',
	'ENETUNREACH',

	// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
	'UNABLE_TO_GET_ISSUER_CERT',
	'UNABLE_TO_GET_CRL',
	'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
	'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
	'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
	'CERT_SIGNATURE_FAILURE',
	'CRL_SIGNATURE_FAILURE',
	'CERT_NOT_YET_VALID',
	'CERT_HAS_EXPIRED',
	'CRL_NOT_YET_VALID',
	'CRL_HAS_EXPIRED',
	'ERROR_IN_CERT_NOT_BEFORE_FIELD',
	'ERROR_IN_CERT_NOT_AFTER_FIELD',
	'ERROR_IN_CRL_LAST_UPDATE_FIELD',
	'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
	'OUT_OF_MEM',
	'DEPTH_ZERO_SELF_SIGNED_CERT',
	'SELF_SIGNED_CERT_IN_CHAIN',
	'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
	'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
	'CERT_CHAIN_TOO_LONG',
	'CERT_REVOKED',
	'INVALID_CA',
	'PATH_LENGTH_EXCEEDED',
	'INVALID_PURPOSE',
	'CERT_UNTRUSTED',
	'CERT_REJECTED'
];

module.exports = function (err) {
	if (!err || !err.code) {
		return true;
	}

	if (WHITELIST.indexOf(err.code) !== -1) {
		return true;
	}

	if (BLACKLIST.indexOf(err.code) !== -1) {
		return false;
	}

	return true;
};

      };
    };
  }
}, {package:"is-retry-allowed",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-retry-allowed\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\Cancel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\cancel\Cancel.js
      return function (require, module, exports) {
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\Cancel.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\bind.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\helpers\bind.js
      return function (require, module, exports) {
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\bind.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\isCancel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\cancel\isCancel.js
      return function (require, module, exports) {
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\isCancel.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\spread.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\helpers\spread.js
      return function (require, module, exports) {
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\spread.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\isAxiosError.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\helpers\isAxiosError.js
      return function (require, module, exports) {
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\isAxiosError.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js", {"./helpers/bind":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\bind.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\utils.js
      return function (require, module, exports) {
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\mergeConfig.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\core\mergeConfig.js
      return function (require, module, exports) {
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\mergeConfig.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\CancelToken.js", {"./Cancel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\Cancel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\cancel\CancelToken.js
      return function (require, module, exports) {
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\cancel\\CancelToken.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\Axios.js", {"../helpers/buildURL":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\buildURL.js","../helpers/validator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\validator.js","./../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js","./InterceptorManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\InterceptorManager.js","./dispatchRequest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\dispatchRequest.js","./mergeConfig":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\mergeConfig.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\core\Axios.js
      return function (require, module, exports) {
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\Axios.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\defaults.js", {"./adapters/http":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\adapters\\xhr.js","./adapters/xhr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\adapters\\xhr.js","./core/enhanceError":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\core\\enhanceError.js","./helpers/normalizeHeaderName":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\helpers\\normalizeHeaderName.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\utils.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\axios\lib\defaults.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var enhanceError = require('./core/enhanceError');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"axios",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\axios\\lib\\defaults.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\secp256k1v3-lib\der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
    // begin
    0x30,
    0x81,
    0xd3,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0x85,
    0x30,
    0x81,
    0x82,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x21,
    0x02,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x24,
    0x03,
    0x22,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
    // begin
    0x30,
    0x82,
    0x01,
    0x13,
    0x02,
    0x01,
    0x01,
    0x04,
    0x20,
    // private key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    // middle
    0xa0,
    0x81,
    0xa5,
    0x30,
    0x81,
    0xa2,
    0x02,
    0x01,
    0x01,
    0x30,
    0x2c,
    0x06,
    0x07,
    0x2a,
    0x86,
    0x48,
    0xce,
    0x3d,
    0x01,
    0x01,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xff,
    0xff,
    0xfc,
    0x2f,
    0x30,
    0x06,
    0x04,
    0x01,
    0x00,
    0x04,
    0x01,
    0x07,
    0x04,
    0x41,
    0x04,
    0x79,
    0xbe,
    0x66,
    0x7e,
    0xf9,
    0xdc,
    0xbb,
    0xac,
    0x55,
    0xa0,
    0x62,
    0x95,
    0xce,
    0x87,
    0x0b,
    0x07,
    0x02,
    0x9b,
    0xfc,
    0xdb,
    0x2d,
    0xce,
    0x28,
    0xd9,
    0x59,
    0xf2,
    0x81,
    0x5b,
    0x16,
    0xf8,
    0x17,
    0x98,
    0x48,
    0x3a,
    0xda,
    0x77,
    0x26,
    0xa3,
    0xc4,
    0x65,
    0x5d,
    0xa4,
    0xfb,
    0xfc,
    0x0e,
    0x11,
    0x08,
    0xa8,
    0xfd,
    0x17,
    0xb4,
    0x48,
    0xa6,
    0x85,
    0x54,
    0x19,
    0x9c,
    0x47,
    0xd0,
    0x8f,
    0xfb,
    0x10,
    0xd4,
    0xb8,
    0x02,
    0x21,
    0x00,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xff,
    0xfe,
    0xba,
    0xae,
    0xdc,
    0xe6,
    0xaf,
    0x48,
    0xa0,
    0x3b,
    0xbf,
    0xd2,
    0x5e,
    0x8c,
    0xd0,
    0x36,
    0x41,
    0x41,
    0x02,
    0x01,
    0x01,
    0xa1,
    0x44,
    0x03,
    0x42,
    0x00,
    // public key
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
]);
exports.privateKeyExport = function (privateKey, publicKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
    privateKey.copy(result, compressed ? 8 : 9);
    publicKey.copy(result, compressed ? 181 : 214);
    return result;
};
exports.privateKeyImport = function (privateKey) {
    var length = privateKey.length;
    // sequence header
    var index = 0;
    if (length < index + 1 || privateKey[index] !== 0x30)
        return null;
    index += 1;
    // sequence length constructor
    if (length < index + 1 || !(privateKey[index] & 0x80))
        return null;
    var lenb = privateKey[index] & 0x7f;
    index += 1;
    if (lenb < 1 || lenb > 2)
        return null;
    if (length < index + lenb)
        return null;
    // sequence length
    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
    index += lenb;
    if (length < index + len)
        return null;
    // sequence element 0: version number (=1)
    if (length < index + 3 ||
        privateKey[index] !== 0x02 ||
        privateKey[index + 1] !== 0x01 ||
        privateKey[index + 2] !== 0x01) {
        return null;
    }
    index += 3;
    // sequence element 1: octet string, up to 32 bytes
    if (length < index + 2 ||
        privateKey[index] !== 0x04 ||
        privateKey[index + 1] > 0x20 ||
        length < index + 2 + privateKey[index + 1]) {
        return null;
    }
    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};
exports.signatureImportLax = function (signature) {
    var r = Buffer.alloc(32, 0);
    var s = Buffer.alloc(32, 0);
    var length = signature.length;
    var index = 0;
    // sequence tag byte
    if (signature[index++] !== 0x30) {
        return null;
    }
    // sequence length byte
    var lenbyte = signature[index++];
    if (lenbyte & 0x80) {
        index += lenbyte - 0x80;
        if (index > length) {
            return null;
        }
    }
    // sequence tag byte for r
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for r
    var rlen = signature[index++];
    if (rlen & 0x80) {
        lenbyte = rlen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            rlen = (rlen << 8) + signature[index];
    }
    if (rlen > length - index) {
        return null;
    }
    var rindex = index;
    index += rlen;
    // sequence tag byte for s
    if (signature[index++] !== 0x02) {
        return null;
    }
    // length for s
    var slen = signature[index++];
    if (slen & 0x80) {
        lenbyte = slen - 0x80;
        if (index + lenbyte > length) {
            return null;
        }
        for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1)
            ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
            slen = (slen << 8) + signature[index];
    }
    if (slen > length - index) {
        return null;
    }
    var sindex = index;
    index += slen;
    // ignore leading zeros in r
    for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1)
        ;
    // copy r value
    if (rlen > 32) {
        return null;
    }
    var rvalue = signature.slice(rindex, rindex + rlen);
    rvalue.copy(r, 32 - rvalue.length);
    // ignore leading zeros in s
    for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1)
        ;
    // copy s value
    if (slen > 32) {
        return null;
    }
    var svalue = signature.slice(sindex, sindex + slen);
    svalue.copy(s, 32 - svalue.length);
    return { r: r, s: s };
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\der.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-wallet\node_modules\ethereumjs-util\dist\secp256k1v3-lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE
Object.defineProperty(exports, "__esModule", { value: true });
var BN = require("bn.js");
var EC = require('elliptic').ec;
var ec = new EC('secp256k1');
var ecparams = ec.curve;
exports.privateKeyExport = function (privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var d = new BN(privateKey);
    if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
    }
    var point = ec.g.mul(d);
    return toPublicKey(point.getX(), point.getY(), compressed);
};
exports.privateKeyModInverse = function (privateKey) {
    var bn = new BN(privateKey);
    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error('private key range is invalid');
    }
    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.signatureImport = function (sigObj) {
    var r = new BN(sigObj.r);
    if (r.ucmp(ecparams.n) >= 0) {
        r = new BN(0);
    }
    var s = new BN(sigObj.s);
    if (s.ucmp(ecparams.n) >= 0) {
        s = new BN(0);
    }
    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    if (compressed === void 0) { compressed = true; }
    var point = ec.keyFromPublic(publicKey);
    var scalar = new BN(privateKey);
    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error('scalar was invalid (zero or overflow)');
    }
    var shared = point.pub.mul(scalar);
    return toPublicKey(shared.getX(), shared.getY(), compressed);
};
var toPublicKey = function (x, y, compressed) {
    var publicKey;
    if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 0x03 : 0x02;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    }
    else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 0x04;
        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-wallet\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js", {"./BaseBlockTracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js","json-rpc-random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-random-id\\index.js","pify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-block-tracker\dist\PollingBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const pify_1 = __importDefault(require("pify"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const createRandomId = json_rpc_random_id_1.default();
const sec = 1000;
class PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        // parse + validate args
        if (!opts.provider) {
            throw new Error('PollingBlockTracker - no provider specified.');
        }
        super({
            blockResetDuration: opts.pollingInterval,
        });
        // config
        this._provider = opts.provider;
        this._pollingInterval = opts.pollingInterval || 20 * sec;
        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;
        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
    }
    // trigger block polling
    async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
    }
    _start() {
        this._synchronize().catch((err) => this.emit('error', err));
    }
    async _synchronize() {
        while (this._isRunning) {
            try {
                await this._updateLatestBlock();
                await timeout(this._pollingInterval, !this._keepEventLoopActive);
            }
            catch (err) {
                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
                try {
                    this.emit('error', newErr);
                }
                catch (emitErr) {
                    console.error(newErr);
                }
                await timeout(this._retryTimeout, !this._keepEventLoopActive);
            }
        }
    }
    async _updateLatestBlock() {
        // fetch + set latest block
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
    }
    async _fetchLatestBlock() {
        const req = {
            jsonrpc: '2.0',
            id: createRandomId(),
            method: 'eth_blockNumber',
            params: [],
        };
        if (this._setSkipCacheFlag) {
            req.skipCache = true;
        }
        const res = await pify_1.default((cb) => this._provider.sendAsync(req, cb))();
        if (res.error) {
            throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`);
        }
        return res.result;
    }
}
exports.PollingBlockTracker = PollingBlockTracker;
function timeout(duration, unref) {
    return new Promise((resolve) => {
        const timeoutRef = setTimeout(resolve, duration);
        // don't keep process open
        if (timeoutRef.unref && unref) {
            timeoutRef.unref();
        }
    });
}
//# sourceMappingURL=PollingBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\PollingBlockTracker.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js", {"./BaseBlockTracker":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js","json-rpc-random-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-rpc-random-id\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-block-tracker\dist\SubscribeBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscribeBlockTracker = void 0;
const json_rpc_random_id_1 = __importDefault(require("json-rpc-random-id"));
const BaseBlockTracker_1 = require("./BaseBlockTracker");
const createRandomId = json_rpc_random_id_1.default();
class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
    constructor(opts = {}) {
        // parse + validate args
        if (!opts.provider) {
            throw new Error('SubscribeBlockTracker - no provider specified.');
        }
        // BaseBlockTracker constructor
        super(opts);
        // config
        this._provider = opts.provider;
        this._subscriptionId = null;
    }
    async checkForLatestBlock() {
        return await this.getLatestBlock();
    }
    async _start() {
        if (this._subscriptionId === undefined || this._subscriptionId === null) {
            try {
                const blockNumber = await this._call('eth_blockNumber');
                this._subscriptionId = await this._call('eth_subscribe', 'newHeads', {});
                this._provider.on('data', this._handleSubData.bind(this));
                this._newPotentialLatest(blockNumber);
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    async _end() {
        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {
            try {
                await this._call('eth_unsubscribe', this._subscriptionId);
                this._subscriptionId = null;
            }
            catch (e) {
                this.emit('error', e);
            }
        }
    }
    _call(method, ...params) {
        return new Promise((resolve, reject) => {
            this._provider.sendAsync({
                id: createRandomId(), method, params, jsonrpc: '2.0',
            }, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res.result);
                }
            });
        });
    }
    _handleSubData(_, response) {
        var _a;
        if (response.method === 'eth_subscription' && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {
            this._newPotentialLatest(response.params.result.number);
        }
    }
}
exports.SubscribeBlockTracker = SubscribeBlockTracker;
//# sourceMappingURL=SubscribeBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\SubscribeBlockTracker.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-block-tracker\dist\BaseBlockTracker.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseBlockTracker = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const sec = 1000;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
const blockTrackerEvents = ['sync', 'latest'];
class BaseBlockTracker extends safe_event_emitter_1.default {
    constructor(opts = {}) {
        super();
        // config
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        // state
        this._currentBlock = null;
        this._isRunning = false;
        // bind functions for internal use
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        // listen for handler changes
        this._setupInternalEvents();
    }
    isRunning() {
        return this._isRunning;
    }
    getCurrentBlock() {
        return this._currentBlock;
    }
    async getLatestBlock() {
        // return if available
        if (this._currentBlock) {
            return this._currentBlock;
        }
        // wait for a new latest block
        const latestBlock = await new Promise((resolve) => this.once('latest', resolve));
        // return newly set current block
        return latestBlock;
    }
    // dont allow module consumer to remove our internal event listeners
    removeAllListeners(eventName) {
        // perform default behavior, preserve fn arity
        if (eventName) {
            super.removeAllListeners(eventName);
        }
        else {
            super.removeAllListeners();
        }
        // re-add internal events
        this._setupInternalEvents();
        // trigger stop check just in case
        this._onRemoveListener();
        return this;
    }
    /**
     * To be implemented in subclass.
     */
    _start() {
        // default behavior is noop
    }
    /**
     * To be implemented in subclass.
     */
    _end() {
        // default behavior is noop
    }
    _setupInternalEvents() {
        // first remove listeners for idempotence
        this.removeListener('newListener', this._onNewListener);
        this.removeListener('removeListener', this._onRemoveListener);
        // then add them
        this.on('newListener', this._onNewListener);
        this.on('removeListener', this._onRemoveListener);
    }
    _onNewListener(eventName) {
        // `newListener` is called *before* the listener is added
        if (blockTrackerEvents.includes(eventName)) {
            this._maybeStart();
        }
    }
    _onRemoveListener() {
        // `removeListener` is called *after* the listener is removed
        if (this._getBlockTrackerEventCount() > 0) {
            return;
        }
        this._maybeEnd();
    }
    _maybeStart() {
        if (this._isRunning) {
            return;
        }
        this._isRunning = true;
        // cancel setting latest block to stale
        this._cancelBlockResetTimeout();
        this._start();
    }
    _maybeEnd() {
        if (!this._isRunning) {
            return;
        }
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
    }
    _getBlockTrackerEventCount() {
        return blockTrackerEvents
            .map((eventName) => this.listenerCount(eventName))
            .reduce(calculateSum);
    }
    _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        // only update if blok number is higher
        if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) {
            return;
        }
        this._setCurrentBlock(newBlock);
    }
    _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit('latest', newBlock);
        this.emit('sync', { oldBlock, newBlock });
    }
    _setupBlockResetTimeout() {
        // clear any existing timeout
        this._cancelBlockResetTimeout();
        // clear latest block when stale
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        // nodejs - dont hold process open
        if (this._blockResetTimeout.unref) {
            this._blockResetTimeout.unref();
        }
    }
    _cancelBlockResetTimeout() {
        if (this._blockResetTimeout) {
            clearTimeout(this._blockResetTimeout);
        }
    }
    _resetCurrentBlock() {
        this._currentBlock = null;
    }
}
exports.BaseBlockTracker = BaseBlockTracker;
function hexToInt(hexInt) {
    return Number.parseInt(hexInt, 16);
}
//# sourceMappingURL=BaseBlockTracker.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-block-tracker\\dist\\BaseBlockTracker.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\messages.json
      return function (require, module, exports) {
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js", {"../../../../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\assert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js", {"bip66":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip66\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\der.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var bip66 = require('bip66')

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\keccak.js", {"./keccak-state-unroll":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\keccak-state-unroll.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\keccak\lib\keccak.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var keccakState = require('./keccak-state-unroll')

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  var output = Buffer.alloc(length)
  for (var i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak

      };
    };
  }
}, {package:"keccak",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\keccak.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\api\\index.js", {"./keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\api\\keccak.js","./shake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\api\\shake.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\keccak\lib\api\index.js
      return function (require, module, exports) {
'use strict'
var createKeccak = require('./keccak')
var createShake = require('./shake')

module.exports = function (KeccakState) {
  var Keccak = createKeccak(KeccakState)
  var Shake = createShake(KeccakState)

  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}

      };
    };
  }
}, {package:"keccak",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\keccak\\lib\\api\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\secp256k1\\elliptic.js", {"./lib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\secp256k1\elliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\secp256k1\\elliptic.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\keccak\\js.js", {"./lib/api":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\keccak\\lib\\api\\index.js","./lib/keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\keccak\\lib\\keccak.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\keccak\js.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib/api')(require('./lib/keccak'))

      };
    };
  }
}, {package:"keccak",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\keccak\\js.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\lib\\index.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-middleware\node_modules\ethereumjs-abi\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* eslint-disable no-useless-escape */
const utils = require('ethereumjs-util')
const BN = require('bn.js')

var ABI = function () {
}

// Convert from short to canonical names
// FIXME: optimise or make this nicer?
function elementaryName (name) {
  if (name.startsWith('int[')) {
    return 'int256' + name.slice(3)
  } else if (name === 'int') {
    return 'int256'
  } else if (name.startsWith('uint[')) {
    return 'uint256' + name.slice(4)
  } else if (name === 'uint') {
    return 'uint256'
  } else if (name.startsWith('fixed[')) {
    return 'fixed128x128' + name.slice(5)
  } else if (name === 'fixed') {
    return 'fixed128x128'
  } else if (name.startsWith('ufixed[')) {
    return 'ufixed128x128' + name.slice(6)
  } else if (name === 'ufixed') {
    return 'ufixed128x128'
  }
  return name
}

ABI.eventID = function (name, types) {
  // FIXME: use node.js util.format?
  var sig = name + '(' + types.map(elementaryName).join(',') + ')'
  return utils.keccak256(Buffer.from(sig))
}

ABI.methodID = function (name, types) {
  return ABI.eventID(name, types).slice(0, 4)
}

// Parse N from type<N>
function parseTypeN (type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10)
}

// Parse N,M from type<N>x<M>
function parseTypeNxM (type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type)
  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]
}

// Parse N in type[<N>] where "type" can itself be an array type.
function parseTypeArray (type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/)
  if (tmp) {
    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)
  }
  return null
}

function parseNumber (arg) {
  var type = typeof arg
  if (type === 'string') {
    if (utils.isHexPrefixed(arg)) {
      return new BN(utils.stripHexPrefix(arg), 16)
    } else {
      return new BN(arg, 10)
    }
  } else if (type === 'number') {
    return new BN(arg)
  } else if (arg.toArray) {
    // assume this is a BN for the moment, replace with BN.isBN soon
    return arg
  } else {
    throw new Error('Argument is not a number')
  }
}

// someMethod(bytes,uint)
// someMethod(bytes,uint):(boolean)
function parseSignature (sig) {
  var tmp = /^(\w+)\((.*)\)$/.exec(sig)

  if (tmp.length !== 3) {
    throw new Error('Invalid method signature')
  }

  var args = /^(.+)\):\((.+)$/.exec(tmp[2])

  if (args !== null && args.length === 3) {
    return {
      method: tmp[1],
      args: args[1].split(','),
      retargs: args[2].split(',')
    }
  } else {
    var params = tmp[2].split(',')
    if (params.length === 1 && params[0] === '') {
      // Special-case (possibly naive) fixup for functions that take no arguments.
      // TODO: special cases are always bad, but this makes the function return
      // match what the calling functions expect
      params = []
    }
    return {
      method: tmp[1],
      args: params
    }
  }
}

// Encodes a single item (can be dynamic array)
// @returns: Buffer
function encodeSingle (type, arg) {
  var size, num, ret, i

  if (type === 'address') {
    return encodeSingle('uint160', parseNumber(arg))
  } else if (type === 'bool') {
    return encodeSingle('uint8', arg ? 1 : 0)
  } else if (type === 'string') {
    return encodeSingle('bytes', Buffer.from(arg, 'utf8'))
  } else if (isArray(type)) {
    // this part handles fixed-length ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    if (typeof arg.length === 'undefined') {
      throw new Error('Not an array?')
    }
    size = parseTypeArray(type)
    if (size !== 'dynamic' && size !== 0 && arg.length > size) {
      throw new Error('Elements exceed array size: ' + size)
    }
    ret = []
    type = type.slice(0, type.lastIndexOf('['))
    if (typeof arg === 'string') {
      arg = JSON.parse(arg)
    }
    for (i in arg) {
      ret.push(encodeSingle(type, arg[i]))
    }
    if (size === 'dynamic') {
      var length = encodeSingle('uint256', arg.length)
      ret.unshift(length)
    }
    return Buffer.concat(ret)
  } else if (type === 'bytes') {
    arg = Buffer.from(arg)

    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])

    if ((arg.length % 32) !== 0) {
      ret = Buffer.concat([ ret, utils.zeros(32 - (arg.length % 32)) ])
    }

    return ret
  } else if (type.startsWith('bytes')) {
    size = parseTypeN(type)
    if (size < 1 || size > 32) {
      throw new Error('Invalid bytes<N> width: ' + size)
    }

    return utils.setLengthRight(arg, 32)
  } else if (type.startsWith('uint')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid uint<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    if (num < 0) {
      throw new Error('Supplied uint is negative')
    }

    return num.toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('int')) {
    size = parseTypeN(type)
    if ((size % 8) || (size < 8) || (size > 256)) {
      throw new Error('Invalid int<N> width: ' + size)
    }

    num = parseNumber(arg)
    if (num.bitLength() > size) {
      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
    }

    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)
  } else if (type.startsWith('ufixed')) {
    size = parseTypeNxM(type)

    num = parseNumber(arg)

    if (num < 0) {
      throw new Error('Supplied ufixed is negative')
    }

    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))
  } else if (type.startsWith('fixed')) {
    size = parseTypeNxM(type)

    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))
  }

  throw new Error('Unsupported or invalid type: ' + type)
}

// Decodes a single item (can be dynamic array)
// @returns: array
// FIXME: this method will need a lot of attention at checking limits and validation
function decodeSingle (parsedType, data, offset) {
  if (typeof parsedType === 'string') {
    parsedType = parseType(parsedType)
  }
  var size, num, ret, i

  if (parsedType.name === 'address') {
    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex')
  } else if (parsedType.name === 'bool') {
    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString()
  } else if (parsedType.name === 'string') {
    var bytes = decodeSingle(parsedType.rawType, data, offset)
    return Buffer.from(bytes, 'utf8').toString()
  } else if (parsedType.isArray) {
    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays
    // NOTE: we catch here all calls to arrays, that simplifies the rest
    ret = []
    size = parsedType.size

    if (parsedType.size === 'dynamic') {
      offset = decodeSingle('uint256', data, offset).toNumber()
      size = decodeSingle('uint256', data, offset).toNumber()
      offset = offset + 32
    }
    for (i = 0; i < size; i++) {
      var decoded = decodeSingle(parsedType.subArray, data, offset)
      ret.push(decoded)
      offset += parsedType.subArray.memoryUsage
    }
    return ret
  } else if (parsedType.name === 'bytes') {
    offset = decodeSingle('uint256', data, offset).toNumber()
    size = decodeSingle('uint256', data, offset).toNumber()
    return data.slice(offset + 32, offset + 32 + size)
  } else if (parsedType.name.startsWith('bytes')) {
    return data.slice(offset, offset + parsedType.size)
  } else if (parsedType.name.startsWith('uint')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be')
    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())
    }
    return num
  } else if (parsedType.name.startsWith('int')) {
    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256)
    if (num.bitLength() > parsedType.size) {
      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())
    }

    return num
  } else if (parsedType.name.startsWith('ufixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]))
    num = decodeSingle('uint256', data, offset)
    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet')
    }
    return num.div(size)
  } else if (parsedType.name.startsWith('fixed')) {
    size = new BN(2).pow(new BN(parsedType.size[1]))
    num = decodeSingle('int256', data, offset)
    if (!num.mod(size).isZero()) {
      throw new Error('Decimals not supported yet')
    }
    return num.div(size)
  }
  throw new Error('Unsupported or invalid type: ' + parsedType.name)
}

// Parse the given type
// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)
function parseType (type) {
  var size
  var ret
  if (isArray(type)) {
    size = parseTypeArray(type)
    var subArray = type.slice(0, type.lastIndexOf('['))
    subArray = parseType(subArray)
    ret = {
      isArray: true,
      name: type,
      size: size,
      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,
      subArray: subArray
    }
    return ret
  } else {
    var rawType
    switch (type) {
      case 'address':
        rawType = 'uint160'
        break
      case 'bool':
        rawType = 'uint8'
        break
      case 'string':
        rawType = 'bytes'
        break
    }
    ret = {
      rawType: rawType,
      name: type,
      memoryUsage: 32
    }

    if ((type.startsWith('bytes') && type !== 'bytes') || type.startsWith('uint') || type.startsWith('int')) {
      ret.size = parseTypeN(type)
    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {
      ret.size = parseTypeNxM(type)
    }

    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {
      throw new Error('Invalid bytes<N> width: ' + ret.size)
    }
    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
      throw new Error('Invalid int/uint<N> width: ' + ret.size)
    }
    return ret
  }
}

// Is a type dynamic?
function isDynamic (type) {
  // FIXME: handle all types? I don't think anything is missing now
  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')
}

// Is a type an array?
function isArray (type) {
  return type.lastIndexOf(']') === type.length - 1
}

// Encode a method/event with arguments
// @types an array of string type names
// @args  an array of the appropriate values
ABI.rawEncode = function (types, values) {
  var output = []
  var data = []

  var headLength = 0

  types.forEach(function (type) {
    if (isArray(type)) {
      var size = parseTypeArray(type)

      if (size !== 'dynamic') {
        headLength += 32 * size
      } else {
        headLength += 32
      }
    } else {
      headLength += 32
    }
  })

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var value = values[i]
    var cur = encodeSingle(type, value)

    // Use the head/tail method for storing dynamic data
    if (isDynamic(type)) {
      output.push(encodeSingle('uint256', headLength))
      data.push(cur)
      headLength += cur.length
    } else {
      output.push(cur)
    }
  }

  return Buffer.concat(output.concat(data))
}

ABI.rawDecode = function (types, data) {
  var ret = []
  data = Buffer.from(data)
  var offset = 0
  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var parsed = parseType(type, data, offset)
    var decoded = decodeSingle(parsed, data, offset)
    offset += parsed.memoryUsage
    ret.push(decoded)
  }
  return ret
}

ABI.simpleEncode = function (method) {
  var args = Array.prototype.slice.call(arguments).slice(1)
  var sig = parseSignature(method)

  // FIXME: validate/convert arguments
  if (args.length !== sig.args.length) {
    throw new Error('Argument count mismatch')
  }

  return Buffer.concat([ ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args) ])
}

ABI.simpleDecode = function (method, data) {
  var sig = parseSignature(method)

  // FIXME: validate/convert arguments
  if (!sig.retargs) {
    throw new Error('No return values in method')
  }

  return ABI.rawDecode(sig.retargs, data)
}

function stringify (type, value) {
  if (type.startsWith('address') || type.startsWith('bytes')) {
    return '0x' + value.toString('hex')
  } else {
    return value.toString()
  }
}

ABI.stringify = function (types, values) {
  var ret = []

  for (var i in types) {
    var type = types[i]
    var value = values[i]

    // if it is an array type, concat the items
    if (/^[^\[]+\[.*\]$/.test(type)) {
      value = value.map(function (item) {
        return stringify(type, item)
      }).join(', ')
    } else {
      value = stringify(type, value)
    }

    ret.push(value)
  }

  return ret
}

ABI.solidityPack = function (types, values) {
  if (types.length !== values.length) {
    throw new Error('Number of types are not matching the values')
  }

  var size, num
  var ret = []

  for (var i = 0; i < types.length; i++) {
    var type = elementaryName(types[i])
    var value = values[i]

    if (type === 'bytes') {
      ret.push(value)
    } else if (type === 'string') {
      ret.push(Buffer.from(value, 'utf8'))
    } else if (type === 'bool') {
      ret.push(Buffer.from(value ? '01' : '00', 'hex'))
    } else if (type === 'address') {
      ret.push(utils.setLengthLeft(value, 20))
    } else if (type.startsWith('bytes')) {
      size = parseTypeN(type)
      if (size < 1 || size > 32) {
        throw new Error('Invalid bytes<N> width: ' + size)
      }

      ret.push(utils.setLengthRight(value, size))
    } else if (type.startsWith('uint')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid uint<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toArrayLike(Buffer, 'be', size / 8))
    } else if (type.startsWith('int')) {
      size = parseTypeN(type)
      if ((size % 8) || (size < 8) || (size > 256)) {
        throw new Error('Invalid int<N> width: ' + size)
      }

      num = parseNumber(value)
      if (num.bitLength() > size) {
        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
      }

      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8))
    } else {
      // FIXME: support all other types
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }

  return Buffer.concat(ret)
}

ABI.soliditySHA3 = function (types, values) {
  return utils.keccak256(ABI.solidityPack(types, values))
}

ABI.soliditySHA256 = function (types, values) {
  return utils.sha256(ABI.solidityPack(types, values))
}

ABI.solidityRIPEMD160 = function (types, values) {
  return utils.ripemd160(ABI.solidityPack(types, values), true)
}

// Serpent's users are familiar with this encoding
// - s: string
// - b: bytes
// - b<N>: bytes<N>
// - i: int256
// - a: int256[]

function isNumeric (c) {
  // FIXME: is this correct? Seems to work
  return (c >= '0') && (c <= '9')
}

// For a "documentation" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp
ABI.fromSerpent = function (sig) {
  var ret = []
  for (var i = 0; i < sig.length; i++) {
    var type = sig[i]
    if (type === 's') {
      ret.push('bytes')
    } else if (type === 'b') {
      var tmp = 'bytes'
      var j = i + 1
      while ((j < sig.length) && isNumeric(sig[j])) {
        tmp += sig[j] - '0'
        j++
      }
      i = j - 1
      ret.push(tmp)
    } else if (type === 'i') {
      ret.push('int256')
    } else if (type === 'a') {
      ret.push('int256[]')
    } else {
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }
  return ret
}

ABI.toSerpent = function (types) {
  var ret = []
  for (var i = 0; i < types.length; i++) {
    var type = types[i]
    if (type === 'bytes') {
      ret.push('s')
    } else if (type.startsWith('bytes')) {
      ret.push('b' + parseTypeN(type))
    } else if (type === 'int256') {
      ret.push('i')
    } else if (type === 'int256[]') {
      ret.push('a')
    } else {
      throw new Error('Unsupported or invalid type: ' + type)
    }
  }
  return ret.join('')
}

module.exports = ABI

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-abi",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-middleware\\node_modules\\ethereumjs-abi\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\helpers.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\node_modules\fast-json-patch\commonjs\helpers.js
      return function (require, module, exports) {
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
Object.defineProperty(exports, "hasOwnProperty", { value: hasOwnProperty });
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\core.js", {"./helpers.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\node_modules\fast-json-patch\commonjs\core.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_js_1 = require("./helpers.js");
exports.JsonPatchError = helpers_js_1.PatchError;
exports.deepClone = helpers_js_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_js_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_js_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: _areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_js_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_js_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (key && key.indexOf('~') != -1) {
                key = helpers_js_1.unescapePathComponent(key);
            }
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_js_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_js_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
            // If we have more keys in the path, but the next value isn't a non-null object,
            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.
            if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
                throw new exports.JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_js_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_js_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_js_1._deepClone(document), helpers_js_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!_areEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!b.hasOwnProperty(keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!_areEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
exports._areEquals = _areEquals;
;

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\core.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\duplex.js", {"./core.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\core.js","./helpers.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\smart-transactions-controller\node_modules\fast-json-patch\commonjs\duplex.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var helpers_js_1 = require("./helpers.js");
var core_js_1 = require("./core.js");
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_js_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_js_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_js_1._objectKeys(obj);
    var oldKeys = helpers_js_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_js_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_js_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_js_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_js_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;

      };
    };
  }
}, {package:"fast-json-patch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\commonjs\\duplex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_arrayEach.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_arrayEach.js
      return function (require, module, exports) {
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_arrayEach.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyArray.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_copyArray.js
      return function (require, module, exports) {
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyArray.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneArray.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_initCloneArray.js
      return function (require, module, exports) {
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneArray.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssign.js", {"./_copyObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyObject.js","./keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keys.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_baseAssign.js
      return function (require, module, exports) {
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssign.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbols.js", {"./_copyObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyObject.js","./_getSymbols":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getSymbols.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_copySymbols.js
      return function (require, module, exports) {
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbols.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_assignValue.js", {"./_baseAssignValue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssignValue.js","./eq":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\eq.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_assignValue.js
      return function (require, module, exports) {
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_assignValue.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssignIn.js", {"./_copyObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyObject.js","./keysIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keysIn.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_baseAssignIn.js
      return function (require, module, exports) {
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseAssignIn.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isSet.js", {"./_baseIsSet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseIsSet.js","./_baseUnary":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseUnary.js","./_nodeUtil":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_nodeUtil.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\isSet.js
      return function (require, module, exports) {
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isSet.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isMap.js", {"./_baseIsMap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseIsMap.js","./_baseUnary":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseUnary.js","./_nodeUtil":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_nodeUtil.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\isMap.js
      return function (require, module, exports) {
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isMap.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneBuffer.js", {"./_root":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_root.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_cloneBuffer.js
      return function (require, module, exports) {
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneBuffer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbolsIn.js", {"./_copyObject":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copyObject.js","./_getSymbolsIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getSymbolsIn.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_copySymbolsIn.js
      return function (require, module, exports) {
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_copySymbolsIn.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getAllKeysIn.js", {"./_baseGetAllKeys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseGetAllKeys.js","./_getSymbolsIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getSymbolsIn.js","./keysIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keysIn.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_getAllKeysIn.js
      return function (require, module, exports) {
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getAllKeysIn.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneObject.js", {"./_baseCreate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseCreate.js","./_getPrototype":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_getPrototype.js","./_isPrototype":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_isPrototype.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_initCloneObject.js
      return function (require, module, exports) {
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneObject.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keysIn.js", {"./_arrayLikeKeys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_arrayLikeKeys.js","./_baseKeysIn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_baseKeysIn.js","./isArrayLike":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isArrayLike.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\keysIn.js
      return function (require, module, exports) {
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\keysIn.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneByTag.js", {"./_cloneArrayBuffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneArrayBuffer.js","./_cloneDataView":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneDataView.js","./_cloneRegExp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneRegExp.js","./_cloneSymbol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneSymbol.js","./_cloneTypedArray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_cloneTypedArray.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash\_initCloneByTag.js
      return function (require, module, exports) {
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

      };
    };
  }
}, {package:"lodash",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\_initCloneByTag.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\node_modules\bignumber.js\bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bignumber.js\\bignumber.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\is-object.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superagent\lib\is-object.js
      return function (require, module, exports) {
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

      };
    };
  }
}, {package:"superagent",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\is-object.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\agent-base.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superagent\lib\agent-base.js
      return function (require, module, exports) {
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;

      };
    };
  }
}, {package:"superagent",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\agent-base.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\component-emitter\index.js
      return function (require, module, exports) {

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

      };
    };
  }
}, {package:"component-emitter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\request-base.js", {"./is-object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\is-object.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superagent\lib\request-base.js
      return function (require, module, exports) {
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

      };
    };
  }
}, {package:"superagent",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\request-base.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\response-base.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superagent\lib\response-base.js
      return function (require, module, exports) {
'use strict';

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

      };
    };
  }
}, {package:"superagent",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superagent\\lib\\response-base.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\string\\index.js", {"./to-bits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\string\\to-bits.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\string\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBits = void 0;
var to_bits_1 = require("./to-bits");
exports.toBits = to_bits_1.default;
exports.default = { toBits: to_bits_1.default };

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\string\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\index.js", {"./and":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\and.js","./circular-shift-left":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\circular-shift-left.js","./circular-shift-right":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\circular-shift-right.js","./nand":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\nand.js","./nor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\nor.js","./not":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\not.js","./or":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\or.js","./reduce-and":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-and.js","./reduce-nand":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-nand.js","./reduce-nor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-nor.js","./reduce-or":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-or.js","./reduce-xnor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-xnor.js","./reduce-xor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\reduce-xor.js","./to-boolean":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\to-boolean.js","./to-string":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\to-string.js","./xnor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\xnor.js","./xor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\xor.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\bits\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xor = exports.xnor = exports.toString = exports.toBoolean = exports.reduceXor = exports.reduceXnor = exports.reduceOr = exports.reduceNor = exports.reduceNand = exports.reduceAnd = exports.or = exports.not = exports.nor = exports.nand = exports.circularShiftRight = exports.circularShiftLeft = exports.and = void 0;
var and_1 = require("./and");
exports.and = and_1.default;
var circular_shift_left_1 = require("./circular-shift-left");
exports.circularShiftLeft = circular_shift_left_1.default;
var circular_shift_right_1 = require("./circular-shift-right");
exports.circularShiftRight = circular_shift_right_1.default;
var nand_1 = require("./nand");
exports.nand = nand_1.default;
var nor_1 = require("./nor");
exports.nor = nor_1.default;
var not_1 = require("./not");
exports.not = not_1.default;
var or_1 = require("./or");
exports.or = or_1.default;
var reduce_and_1 = require("./reduce-and");
exports.reduceAnd = reduce_and_1.default;
var reduce_nand_1 = require("./reduce-nand");
exports.reduceNand = reduce_nand_1.default;
var reduce_nor_1 = require("./reduce-nor");
exports.reduceNor = reduce_nor_1.default;
var reduce_or_1 = require("./reduce-or");
exports.reduceOr = reduce_or_1.default;
var reduce_xnor_1 = require("./reduce-xnor");
exports.reduceXnor = reduce_xnor_1.default;
var reduce_xor_1 = require("./reduce-xor");
exports.reduceXor = reduce_xor_1.default;
var to_boolean_1 = require("./to-boolean");
exports.toBoolean = to_boolean_1.default;
var to_string_1 = require("./to-string");
exports.toString = to_string_1.default;
var xnor_1 = require("./xnor");
exports.xnor = xnor_1.default;
var xor_1 = require("./xor");
exports.xor = xor_1.default;
exports.default = {
    and: and_1.default,
    circularShiftLeft: circular_shift_left_1.default,
    circularShiftRight: circular_shift_right_1.default,
    nand: nand_1.default,
    nor: nor_1.default,
    not: not_1.default,
    or: or_1.default,
    reduceAnd: reduce_and_1.default,
    reduceNand: reduce_nand_1.default,
    reduceNor: reduce_nor_1.default,
    reduceOr: reduce_or_1.default,
    reduceXnor: reduce_xnor_1.default,
    reduceXor: reduce_xor_1.default,
    toBoolean: to_boolean_1.default,
    toString: to_string_1.default,
    xnor: xnor_1.default,
    xor: xor_1.default,
};

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\bits\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\nibble\\index.js", {"./read":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\nibble\\read.js","./write":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\nibble\\write.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\nibble\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
var read_1 = require("./read");
exports.read = read_1.default;
var write_1 = require("./write");
exports.write = write_1.default;
exports.default = { read: read_1.default, write: write_1.default };

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\nibble\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\index.js", {"./get-bit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\get-bit.js","./set-bit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\set-bit.js","./toggle-bit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\toggle-bit.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\integer\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggleBit = exports.setBit = exports.getBit = void 0;
var get_bit_1 = require("./get-bit");
exports.getBit = get_bit_1.default;
var set_bit_1 = require("./set-bit");
exports.setBit = set_bit_1.default;
var toggle_bit_1 = require("./toggle-bit");
exports.toggleBit = toggle_bit_1.default;
exports.default = { getBit: get_bit_1.default, setBit: set_bit_1.default, toggleBit: toggle_bit_1.default };

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\integer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\byte\\index.js", {"./read":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\byte\\read.js","./write":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\byte\\write.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\byte\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.read = void 0;
var read_1 = require("./read");
exports.read = read_1.default;
var write_1 = require("./write");
exports.write = write_1.default;
exports.default = { read: read_1.default, write: write_1.default };

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\byte\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\index.js", {"./and":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\and.js","./create":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\create.js","./modify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\modify.js","./nand":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\nand.js","./nor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\nor.js","./not":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\not.js","./or":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\or.js","./read":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\read.js","./read-int":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\read-int.js","./read-u-int":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\read-u-int.js","./xnor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\xnor.js","./xor":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\xor.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bitwise\buffer\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xor = exports.xnor = exports.readUInt = exports.readInt = exports.read = exports.or = exports.not = exports.nor = exports.nand = exports.modify = exports.create = exports.and = void 0;
var and_1 = require("./and");
exports.and = and_1.default;
var create_1 = require("./create");
exports.create = create_1.default;
var modify_1 = require("./modify");
exports.modify = modify_1.default;
var nand_1 = require("./nand");
exports.nand = nand_1.default;
var nor_1 = require("./nor");
exports.nor = nor_1.default;
var not_1 = require("./not");
exports.not = not_1.default;
var or_1 = require("./or");
exports.or = or_1.default;
var read_1 = require("./read");
exports.read = read_1.default;
var read_int_1 = require("./read-int");
exports.readInt = read_int_1.default;
var read_u_int_1 = require("./read-u-int");
exports.readUInt = read_u_int_1.default;
var xnor_1 = require("./xnor");
exports.xnor = xnor_1.default;
var xor_1 = require("./xor");
exports.xor = xor_1.default;
exports.default = {
    and: and_1.default,
    create: create_1.default,
    modify: modify_1.default,
    nand: nand_1.default,
    nor: nor_1.default,
    not: not_1.default,
    or: or_1.default,
    read: read_1.default,
    readInt: read_int_1.default,
    readUInt: read_u_int_1.default,
    xnor: xnor_1.default,
    xor: xor_1.default,
};

      };
    };
  }
}, {package:"bitwise",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bitwise\\buffer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp-browser\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\rlp-browser\index.js
      return function (require, module, exports) {
const assert = require('assert')
const Buffer = require('buffer/').Buffer
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 *
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Buffer} - returns buffer of encoded data
 **/
exports.encode = function (input) {
  if (input instanceof Array) {
    var output = []
    for (var i = 0; i < input.length; i++) {
      output.push(exports.encode(input[i]))
    }
    var buf = Buffer.concat(output)
    return Buffer.concat([encodeLength(buf.length, 192), buf])
  } else {
    input = toBuffer(input)
    if (input.length === 1 && input[0] < 128) {
      return input
    } else {
      return Buffer.concat([encodeLength(input.length, 128), input])
    }
  }
}

function safeParseInt (v, base) {
  if (v.slice(0, 2) === '00') {
    throw (new Error('invalid RLP: extra zeros'))
  }

  return parseInt(v, base)
}

function encodeLength (len, offset) {
  if (len < 56) {
    return new Buffer([len + offset])
  } else {
    var hexLength = intToHex(len)
    var lLength = hexLength.length / 2
    var firstByte = intToHex(offset + 55 + lLength)
    return new Buffer(firstByte + hexLength, 'hex')
  }
}

/**
 * RLP Decoding based on: {@link https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP|RLP}
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Array} - returns decode Array of Buffers containg the original message
 **/
exports.decode = function (input, stream) {
  if (!input || input.length === 0) {
    return new Buffer([])
  }

  input = toBuffer(input)
  var decoded = _decode(input)

  if (stream) {
    return decoded
  }

  assert.equal(decoded.remainder.length, 0, 'invalid remainder')
  return decoded.data
}

exports.getLength = function (input) {
  if (!input || input.length === 0) {
    return new Buffer([])
  }

  input = toBuffer(input)
  var firstByte = input[0]
  if (firstByte <= 0x7f) {
    return input.length
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6
    var length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    return llength + length
  }
}

function _decode (input) {
  var length, llength, data, innerRemainder, d
  var decoded = []
  var firstByte = input[0]

  if (firstByte <= 0x7f) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    }
  } else if (firstByte <= 0xb7) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 0x7f

    // set 0x80 null to 0
    if (firstByte === 0x80) {
      data = new Buffer([])
    } else {
      data = input.slice(1, length)
    }

    if (length === 2 && data[0] < 0x80) {
      throw new Error('invalid rlp encoding: byte must be less 0x80')
    }

    return {
      data: data,
      remainder: input.slice(length)
    }
  } else if (firstByte <= 0xbf) {
    llength = firstByte - 0xb6
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    data = input.slice(llength, length + llength)
    if (data.length < length) {
      throw (new Error('invalid RLP'))
    }

    return {
      data: data,
      remainder: input.slice(length + llength)
    }
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    length = firstByte - 0xbf
    innerRemainder = input.slice(1, length)
    while (innerRemainder.length) {
      d = _decode(innerRemainder)
      decoded.push(d.data)
      innerRemainder = d.remainder
    }

    return {
      data: decoded,
      remainder: input.slice(length)
    }
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 0xf6
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16)
    var totalLength = llength + length
    if (totalLength > input.length) {
      throw new Error('invalid rlp: total length is larger than the data')
    }

    innerRemainder = input.slice(llength, totalLength)
    if (innerRemainder.length === 0) {
      throw new Error('invalid rlp, List has a invalid length')
    }

    while (innerRemainder.length) {
      d = _decode(innerRemainder)
      decoded.push(d.data)
      innerRemainder = d.remainder
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    }
  }
}

function isHexPrefixed (str) {
  return str.slice(0, 2) === '0x'
}

// Removes 0x from a given String
function stripHexPrefix (str) {
  if (typeof str !== 'string') {
    return str
  }
  return isHexPrefixed(str) ? str.slice(2) : str
}

function intToHex (i) {
  var hex = i.toString(16)
  if (hex.length % 2) {
    hex = '0' + hex
  }

  return hex
}

function padToEven (a) {
  if (a.length % 2) a = '0' + a
  return a
}

function intToBuffer (i) {
  var hex = intToHex(i)
  return new Buffer(hex, 'hex')
}

function toBuffer (v) {
  if (!Buffer.isBuffer(v)) {
    if (typeof v === 'string') {
      if (isHexPrefixed(v)) {
        v = new Buffer(padToEven(stripHexPrefix(v)), 'hex')
      } else {
        v = new Buffer(v)
      }
    } else if (typeof v === 'number') {
      if (!v) {
        v = new Buffer([])
      } else {
        v = intToBuffer(v)
      }
    } else if (v === null || v === undefined) {
      v = new Buffer([])
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = new Buffer(v.toArray())
    } else {
      throw new Error('invalid type')
    }
  }
  return v
}

      };
    };
  }
}, {package:"rlp-browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp-browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\index.js", {"./abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\abi.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\util.js","buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-eip712-util-browser\index.js
      return function (require, module, exports) {
const util = require('./util')
const abi = require('./abi')
const Buffer = require('buffer/').Buffer

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {type: 'string'},
            type: {type: 'string'},
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: {type: 'string'},
    domain: {type: 'object'},
    message: {type: 'object'},
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if(useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value == null ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            util.keccak(this.encodeData(type, value, types, useV4))]
        }

        if(value === undefined)
          throw new Error(`missing value for field ${name} of type ${type}`)

        if (type === 'bytes') {
          return ['bytes32', util.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', util.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map(item =>
            encodeField(name, parsedType, item))
          return ['bytes32', util.keccak(abi.rawEncode(
            typeValuePairs.map(([type]) => type),
            typeValuePairs.map(([, value]) => value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = util.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = util.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = util.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return abi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error('No type definition specified: ' + type)
      }
      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    primaryType = primaryType.match(/^\w*/)[0]
    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return util.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return util.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key in TYPED_MESSAGE_SCHEMA.properties) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)
    }
    return sanitizedData
  },

  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return util.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  hashForSignTypedDataLegacy: function (msgParams) {
    return typedSignatureHashLegacy(msgParams.data)
  },

  hashForSignTypedData_v3: function (msgParams) {
    return TypedDataUtils.hash(msgParams.data, false)
  },

  hashForSignTypedData_v4: function (msgParams) {
    return TypedDataUtils.hash(msgParams.data)
  },
}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHashLegacy(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return abi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      abi.soliditySHA3(types, data)
    ]
  )
}

      };
    };
  }
}, {package:"eth-eip712-util-browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-eip712-util-browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\index.js", {"./decoder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\decoder.js","./diagnose":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\diagnose.js","./encoder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\encoder.js","./simple":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\simple.js","./tagged":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\tagged.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\borc\src\index.js
      return function (require, module, exports) {
'use strict'

// exports.Commented = require('./commented')
exports.Diagnose = require('./diagnose')
exports.Decoder = require('./decoder')
exports.Encoder = require('./encoder')
exports.Simple = require('./simple')
exports.Tagged = require('./tagged')

// exports.comment = exports.Commented.comment
exports.decodeAll = exports.Decoder.decodeAll
exports.decodeFirst = exports.Decoder.decodeFirst
exports.diagnose = exports.Diagnose.diagnose
exports.encode = exports.Encoder.encode
exports.decode = exports.Decoder.decode

exports.leveldb = {
  decode: exports.Decoder.decodeAll,
  encode: exports.Encoder.encode,
  buffer: true,
  name: 'cbor'
}

      };
    };
  }
}, {package:"borc",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\borc\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gridplus-sdk\node_modules\bech32\dist\index.js
      return function (require, module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

      };
    };
  }
}, {package:"bech32",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gridplus-sdk\\node_modules\\bech32\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\lib\messages.json
      return function (require, module, exports) {
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js", {"../../../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\lib\assert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

}).call(this)}).call(this,{"isBuffer":require("../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js", {"bip66":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip66\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-trezor-keyring\node_modules\secp256k1\lib\der.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var bip66 = require('bip66')

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\types\trezor\protobuf.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.Enum_TezosBallotType = exports.Enum_TezosContractType = exports.Enum_StellarSignerType = exports.Enum_StellarMemoType = exports.Enum_StellarAssetType = exports.Enum_NEMImportanceTransferMode = exports.Enum_NEMModificationType = exports.Enum_NEMSupplyChangeType = exports.Enum_NEMMosaicLevy = exports.Enum_WordRequestType = exports.Enum_RecoveryDeviceType = exports.Enum_SdProtectOperationType = exports.Enum_Capability = exports.Enum_SafetyCheckLevel = exports.Enum_BackupType = exports.Enum_EthereumDataType = exports.Enum_PinMatrixRequestType = exports.Enum_ButtonRequestType = exports.Enum_FailureType = exports.Enum_CardanoTxWitnessType = exports.Enum_CardanoTxSigningMode = exports.Enum_CardanoTxAuxiliaryDataSupplementType = exports.Enum_CardanoPoolRelayType = exports.Enum_CardanoCertificateType = exports.Enum_CardanoNativeScriptHashDisplayFormat = exports.Enum_CardanoNativeScriptType = exports.Enum_CardanoAddressType = exports.Enum_CardanoDerivationType = exports.Enum_RequestType = exports.Enum_AmountUnit = exports.Enum_DecredStakingSpendType = exports.Enum_OutputScriptType = exports.Enum_InputScriptType = exports.Enum_BinanceTimeInForce = exports.Enum_BinanceOrderSide = exports.Enum_BinanceOrderType = void 0;
// This file is auto generated from data/messages/message.json
// custom type uint32/64 may be represented as string
// BinanceGetAddress
// BinanceAddress
// BinanceGetPublicKey
// BinancePublicKey
// BinanceSignTx
// BinanceTxRequest
// BinanceTransferMsg
var Enum_BinanceOrderType = Object.freeze({
  OT_UNKNOWN: 0,
  MARKET: 1,
  LIMIT: 2,
  OT_RESERVED: 3
});
exports.Enum_BinanceOrderType = Enum_BinanceOrderType;
var Enum_BinanceOrderSide = Object.freeze({
  SIDE_UNKNOWN: 0,
  BUY: 1,
  SELL: 2
});
exports.Enum_BinanceOrderSide = Enum_BinanceOrderSide;
var Enum_BinanceTimeInForce = Object.freeze({
  TIF_UNKNOWN: 0,
  GTE: 1,
  TIF_RESERVED: 2,
  IOC: 3
});
exports.Enum_BinanceTimeInForce = Enum_BinanceTimeInForce;
var Enum_InputScriptType = Object.freeze({
  SPENDADDRESS: 0,
  SPENDMULTISIG: 1,
  EXTERNAL: 2,
  SPENDWITNESS: 3,
  SPENDP2SHWITNESS: 4,
  SPENDTAPROOT: 5
});
exports.Enum_InputScriptType = Enum_InputScriptType;
var Enum_OutputScriptType = Object.freeze({
  PAYTOADDRESS: 0,
  PAYTOSCRIPTHASH: 1,
  PAYTOMULTISIG: 2,
  PAYTOOPRETURN: 3,
  PAYTOWITNESS: 4,
  PAYTOP2SHWITNESS: 5,
  PAYTOTAPROOT: 6
});
exports.Enum_OutputScriptType = Enum_OutputScriptType;
var Enum_DecredStakingSpendType = Object.freeze({
  SSGen: 0,
  SSRTX: 1
});
exports.Enum_DecredStakingSpendType = Enum_DecredStakingSpendType;
var Enum_AmountUnit = Object.freeze({
  BITCOIN: 0,
  MILLIBITCOIN: 1,
  MICROBITCOIN: 2,
  SATOSHI: 3
});
exports.Enum_AmountUnit = Enum_AmountUnit;
var Enum_RequestType = Object.freeze({
  TXINPUT: 0,
  TXOUTPUT: 1,
  TXMETA: 2,
  TXFINISHED: 3,
  TXEXTRADATA: 4,
  TXORIGINPUT: 5,
  TXORIGOUTPUT: 6
});
exports.Enum_RequestType = Enum_RequestType;
var Enum_CardanoDerivationType = Object.freeze({
  LEDGER: 0,
  ICARUS: 1,
  ICARUS_TREZOR: 2
});
exports.Enum_CardanoDerivationType = Enum_CardanoDerivationType;
var Enum_CardanoAddressType = Object.freeze({
  BASE: 0,
  BASE_SCRIPT_KEY: 1,
  BASE_KEY_SCRIPT: 2,
  BASE_SCRIPT_SCRIPT: 3,
  POINTER: 4,
  POINTER_SCRIPT: 5,
  ENTERPRISE: 6,
  ENTERPRISE_SCRIPT: 7,
  BYRON: 8,
  REWARD: 14,
  REWARD_SCRIPT: 15
});
exports.Enum_CardanoAddressType = Enum_CardanoAddressType;
var Enum_CardanoNativeScriptType = Object.freeze({
  PUB_KEY: 0,
  ALL: 1,
  ANY: 2,
  N_OF_K: 3,
  INVALID_BEFORE: 4,
  INVALID_HEREAFTER: 5
});
exports.Enum_CardanoNativeScriptType = Enum_CardanoNativeScriptType;
var Enum_CardanoNativeScriptHashDisplayFormat = Object.freeze({
  HIDE: 0,
  BECH32: 1,
  POLICY_ID: 2
});
exports.Enum_CardanoNativeScriptHashDisplayFormat = Enum_CardanoNativeScriptHashDisplayFormat;
var Enum_CardanoCertificateType = Object.freeze({
  STAKE_REGISTRATION: 0,
  STAKE_DEREGISTRATION: 1,
  STAKE_DELEGATION: 2,
  STAKE_POOL_REGISTRATION: 3
});
exports.Enum_CardanoCertificateType = Enum_CardanoCertificateType;
var Enum_CardanoPoolRelayType = Object.freeze({
  SINGLE_HOST_IP: 0,
  SINGLE_HOST_NAME: 1,
  MULTIPLE_HOST_NAME: 2
});
exports.Enum_CardanoPoolRelayType = Enum_CardanoPoolRelayType;
var Enum_CardanoTxAuxiliaryDataSupplementType = Object.freeze({
  NONE: 0,
  CATALYST_REGISTRATION_SIGNATURE: 1
});
exports.Enum_CardanoTxAuxiliaryDataSupplementType = Enum_CardanoTxAuxiliaryDataSupplementType;
var Enum_CardanoTxSigningMode = Object.freeze({
  ORDINARY_TRANSACTION: 0,
  POOL_REGISTRATION_AS_OWNER: 1,
  MULTISIG_TRANSACTION: 2
});
exports.Enum_CardanoTxSigningMode = Enum_CardanoTxSigningMode;
var Enum_CardanoTxWitnessType = Object.freeze({
  BYRON_WITNESS: 0,
  SHELLEY_WITNESS: 1
});
exports.Enum_CardanoTxWitnessType = Enum_CardanoTxWitnessType;
var Enum_FailureType = Object.freeze({
  Failure_UnexpectedMessage: 1,
  Failure_ButtonExpected: 2,
  Failure_DataError: 3,
  Failure_ActionCancelled: 4,
  Failure_PinExpected: 5,
  Failure_PinCancelled: 6,
  Failure_PinInvalid: 7,
  Failure_InvalidSignature: 8,
  Failure_ProcessError: 9,
  Failure_NotEnoughFunds: 10,
  Failure_NotInitialized: 11,
  Failure_PinMismatch: 12,
  Failure_WipeCodeMismatch: 13,
  Failure_InvalidSession: 14,
  Failure_FirmwareError: 99
});
exports.Enum_FailureType = Enum_FailureType;
var Enum_ButtonRequestType = Object.freeze({
  ButtonRequest_Other: 1,
  ButtonRequest_FeeOverThreshold: 2,
  ButtonRequest_ConfirmOutput: 3,
  ButtonRequest_ResetDevice: 4,
  ButtonRequest_ConfirmWord: 5,
  ButtonRequest_WipeDevice: 6,
  ButtonRequest_ProtectCall: 7,
  ButtonRequest_SignTx: 8,
  ButtonRequest_FirmwareCheck: 9,
  ButtonRequest_Address: 10,
  ButtonRequest_PublicKey: 11,
  ButtonRequest_MnemonicWordCount: 12,
  ButtonRequest_MnemonicInput: 13,
  _Deprecated_ButtonRequest_PassphraseType: 14,
  ButtonRequest_UnknownDerivationPath: 15,
  ButtonRequest_RecoveryHomepage: 16,
  ButtonRequest_Success: 17,
  ButtonRequest_Warning: 18,
  ButtonRequest_PassphraseEntry: 19,
  ButtonRequest_PinEntry: 20
});
exports.Enum_ButtonRequestType = Enum_ButtonRequestType;
var Enum_PinMatrixRequestType = Object.freeze({
  PinMatrixRequestType_Current: 1,
  PinMatrixRequestType_NewFirst: 2,
  PinMatrixRequestType_NewSecond: 3,
  PinMatrixRequestType_WipeCodeFirst: 4,
  PinMatrixRequestType_WipeCodeSecond: 5
});
exports.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType;
var Enum_EthereumDataType = Object.freeze({
  UINT: 1,
  INT: 2,
  BYTES: 3,
  STRING: 4,
  BOOL: 5,
  ADDRESS: 6,
  ARRAY: 7,
  STRUCT: 8
});
exports.Enum_EthereumDataType = Enum_EthereumDataType;
var Enum_BackupType = Object.freeze({
  Bip39: 0,
  Slip39_Basic: 1,
  Slip39_Advanced: 2
});
exports.Enum_BackupType = Enum_BackupType;
var Enum_SafetyCheckLevel = Object.freeze({
  Strict: 0,
  PromptAlways: 1,
  PromptTemporarily: 2
});
exports.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel;
var Enum_Capability = Object.freeze({
  Capability_Bitcoin: 1,
  Capability_Bitcoin_like: 2,
  Capability_Binance: 3,
  Capability_Cardano: 4,
  Capability_Crypto: 5,
  Capability_EOS: 6,
  Capability_Ethereum: 7,
  Capability_Lisk: 8,
  Capability_Monero: 9,
  Capability_NEM: 10,
  Capability_Ripple: 11,
  Capability_Stellar: 12,
  Capability_Tezos: 13,
  Capability_U2F: 14,
  Capability_Shamir: 15,
  Capability_ShamirGroups: 16,
  Capability_PassphraseEntry: 17
});
exports.Enum_Capability = Enum_Capability;
var Enum_SdProtectOperationType = Object.freeze({
  DISABLE: 0,
  ENABLE: 1,
  REFRESH: 2
});
exports.Enum_SdProtectOperationType = Enum_SdProtectOperationType;
var Enum_RecoveryDeviceType = Object.freeze({
  RecoveryDeviceType_ScrambledWords: 0,
  RecoveryDeviceType_Matrix: 1
});
exports.Enum_RecoveryDeviceType = Enum_RecoveryDeviceType;
var Enum_WordRequestType = Object.freeze({
  WordRequestType_Plain: 0,
  WordRequestType_Matrix9: 1,
  WordRequestType_Matrix6: 2
});
exports.Enum_WordRequestType = Enum_WordRequestType;
var Enum_NEMMosaicLevy = Object.freeze({
  MosaicLevy_Absolute: 1,
  MosaicLevy_Percentile: 2
});
exports.Enum_NEMMosaicLevy = Enum_NEMMosaicLevy;
var Enum_NEMSupplyChangeType = Object.freeze({
  SupplyChange_Increase: 1,
  SupplyChange_Decrease: 2
});
exports.Enum_NEMSupplyChangeType = Enum_NEMSupplyChangeType;
var Enum_NEMModificationType = Object.freeze({
  CosignatoryModification_Add: 1,
  CosignatoryModification_Delete: 2
});
exports.Enum_NEMModificationType = Enum_NEMModificationType;
var Enum_NEMImportanceTransferMode = Object.freeze({
  ImportanceTransfer_Activate: 1,
  ImportanceTransfer_Deactivate: 2
});
exports.Enum_NEMImportanceTransferMode = Enum_NEMImportanceTransferMode;
var Enum_StellarAssetType = Object.freeze({
  NATIVE: 0,
  ALPHANUM4: 1,
  ALPHANUM12: 2
});
exports.Enum_StellarAssetType = Enum_StellarAssetType;
var Enum_StellarMemoType = Object.freeze({
  NONE: 0,
  TEXT: 1,
  ID: 2,
  HASH: 3,
  RETURN: 4
});
exports.Enum_StellarMemoType = Enum_StellarMemoType;
var Enum_StellarSignerType = Object.freeze({
  ACCOUNT: 0,
  PRE_AUTH: 1,
  HASH: 2
});
exports.Enum_StellarSignerType = Enum_StellarSignerType;
var Enum_TezosContractType = Object.freeze({
  Implicit: 0,
  Originated: 1
});
exports.Enum_TezosContractType = Enum_TezosContractType;
var Enum_TezosBallotType = Object.freeze({
  Yay: 0,
  Nay: 1,
  Pass: 2
});
exports.Enum_TezosBallotType = Enum_TezosBallotType;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\wrapNativeSuper.js", {"./construct.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\construct.js","./getPrototypeOf.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js","./isNativeFunction.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\isNativeFunction.js","./setPrototypeOf.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\setPrototypeOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@babel\runtime\helpers\wrapNativeSuper.js
      return function (require, module, exports) {
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel\\runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\wrapNativeSuper.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\deferred.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\utils\deferred.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.create = create;
exports.createAsync = createAsync;
exports.resolveTimeoutPromise = resolveTimeoutPromise;
exports.rejectTimeoutPromise = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function create(arg, device) {
  var localResolve = function localResolve(_t) {};

  var localReject = function localReject(_e) {};

  var id; // eslint-disable-next-line no-async-promise-executor

  var promise = new Promise( /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(resolve, reject) {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localResolve = resolve;
              localReject = reject;

              if (!(typeof arg === 'function')) {
                _context.next = 11;
                break;
              }

              _context.prev = 3;
              _context.next = 6;
              return arg();

            case 6:
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](3);
              reject(_context.t0);

            case 11:
              if (typeof arg === 'string') id = arg;

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 8]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    id: id,
    device: device,
    resolve: localResolve,
    reject: localReject,
    promise: promise
  };
}

function createAsync(innerFn) {
  var localResolve = function localResolve(_t) {};

  var localReject = function localReject(_e) {};

  var promise = new Promise(function (resolve, reject) {
    localResolve = resolve;
    localReject = reject;
  });

  var inner = /*#__PURE__*/function () {
    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return innerFn();

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function inner() {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    resolve: localResolve,
    reject: localReject,
    promise: promise,
    run: function run() {
      inner();
      return promise;
    }
  };
}

function resolveTimeoutPromise(delay, result) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve(result);
    }, delay);
  });
}

var rejectTimeoutPromise = function rejectTimeoutPromise(delay, error) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      reject(error);
    }, delay);
  });
};

exports.rejectTimeoutPromise = rejectTimeoutPromise;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\utils\\deferred.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","cross-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cross-fetch\\dist\\browser-ponyfill.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\env\browser\networkUtils.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getOrigin = exports.httpRequest = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

var httpRequest = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url, type) {
    var response, txt;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (type === void 0) {
              type = 'text';
            }

            _context.next = 3;
            return (0, _crossFetch["default"])(url, {
              credentials: 'same-origin'
            });

          case 3:
            response = _context.sent;

            if (!response.ok) {
              _context.next = 13;
              break;
            }

            if (!(type === 'json')) {
              _context.next = 10;
              break;
            }

            _context.next = 8;
            return response.text();

          case 8:
            txt = _context.sent;
            return _context.abrupt("return", JSON.parse(txt));

          case 10:
            if (!(type === 'binary')) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", response.arrayBuffer());

          case 12:
            return _context.abrupt("return", response.text());

          case 13:
            throw new Error("httpRequest error: " + url + " " + response.statusText);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function httpRequest(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.httpRequest = httpRequest;

var getOrigin = function getOrigin(url) {
  if (url.indexOf('file://') === 0) return 'file://'; // eslint-disable-next-line no-useless-escape

  var parts = url.match(/^.+\:\/\/[^\/]+/);
  return Array.isArray(parts) && parts.length > 0 ? parts[0] : 'unknown';
};

exports.getOrigin = getOrigin;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\showPopupRequest.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\popup\showPopupRequest.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.showPopupRequest = void 0;
var LAYER_ID = 'TrezorConnectInteractionLayer';
var HTML = "\n    <div class=\"trezorconnect-container\" id=\"" + LAYER_ID + "\">\n        <div class=\"trezorconnect-window\">\n            <div class=\"trezorconnect-head\">\n                <svg class=\"trezorconnect-logo\" x=\"0px\" y=\"0px\" viewBox=\"0 0 163.7 41.9\" width=\"78px\" height=\"20px\" preserveAspectRatio=\"xMinYMin meet\">\n                    <polygon points=\"101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1\"/>\n                    <path d=\"M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z\"/>\n                    <path d=\"M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z\"/>\n                    <polygon points=\"82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 \"/>\n                    <path d=\"M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z\"/>\n                    <path d=\"M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z\"/>\n                    <polygon points=\"40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 \"/>\n                </svg>\n                <div class=\"trezorconnect-close\">\n                    <svg x=\"0px\" y=\"0px\" viewBox=\"24 24 60 60\" width=\"24px\" height=\"24px\" preserveAspectRatio=\"xMinYMin meet\">\n                        <polygon class=\"st0\" points=\"40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 \"/>\n                    </svg>\n                </div>\n            </div>\n            <div class=\"trezorconnect-body\">\n                <h3>Popup was blocked</h3>\n                <p>Please click to \u201CContinue\u201D to open popup manually</p>\n                <button class=\"trezorconnect-open\">Continue</button>\n            </div>\n        </div>\n    </div>\n";

var showPopupRequest = function showPopupRequest(open, cancel) {
  if (document.getElementById(LAYER_ID)) {
    return;
  }

  var div = document.createElement('div');
  div.id = LAYER_ID;
  div.className = 'trezorconnect-container';
  div.innerHTML = HTML;

  if (document.body) {
    document.body.appendChild(div);
  }

  var button = div.getElementsByClassName('trezorconnect-open')[0];

  button.onclick = function () {
    open();

    if (document.body) {
      document.body.removeChild(div);
    }
  };

  var close = div.getElementsByClassName('trezorconnect-close')[0];

  close.onclick = function () {
    cancel();

    if (document.body) {
      document.body.removeChild(div);
    }
  };
};

exports.showPopupRequest = showPopupRequest;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\popup\\showPopupRequest.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\inline-styles.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\trezor-connect\lib\iframe\inline-styles.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = void 0;
var css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
var _default = css;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\trezor-connect\\lib\\iframe\\inline-styles.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./account":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\account.js","./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\bytes.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\constants.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\hash.js","./object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\object.js","./secp256k1v3-adapter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1v3-adapter.js","./signature":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\signature.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\eth-sig-util\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\@metamask\obs-store\dist\transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask\\obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\url-alphabet\\index.cjs", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\nanoid\url-alphabet\index.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
}, {package:"nanoid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\nanoid\\url-alphabet\\index.cjs",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\equal.js", {"fast-deep-equal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fast-deep-equal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\ajv\dist\runtime\equal.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// https://github.com/ajv-validator/ajv/issues/889
const equal = require("fast-deep-equal");
equal.code = 'require("ajv/dist/runtime/equal").default';
exports.default = equal;
//# sourceMappingURL=equal.js.map
      };
    };
  }
}, {package:"ajv",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\equal.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\ucs2length.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\ajv\dist\runtime\ucs2length.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
exports.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
//# sourceMappingURL=ucs2length.js.map
      };
    };
  }
}, {package:"ajv",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\ajv\\dist\\runtime\\ucs2length.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\readable-browser.js", {"./lib/_stream_duplex.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./lib/_stream_passthrough.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","./lib/_stream_readable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\_stream_readable.js","./lib/_stream_transform.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\_stream_transform.js","./lib/_stream_writable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\_stream_writable.js","./lib/internal/streams/end-of-stream.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","./lib/internal/streams/pipeline.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-web-to-node-stream\node_modules\readable-stream\readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-web-to-node-stream\\node_modules\\readable-stream\\readable-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\readable-browser.js", {"./lib/_stream_duplex.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./lib/_stream_passthrough.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","./lib/_stream_readable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\_stream_readable.js","./lib/_stream_transform.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\_stream_transform.js","./lib/_stream_writable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\_stream_writable.js","./lib/internal/streams/end-of-stream.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","./lib/internal/streams/pipeline.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\concat-stream\node_modules\readable-stream\readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\concat-stream\\node_modules\\readable-stream\\readable-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\extract.js", {"./headers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\headers.js","bl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\node_modules\\bl\\bl.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\tar-stream\extract.js
      return function (require, module, exports) {
var util = require('util')
var bl = require('bl')
var headers = require('./headers')

var Writable = require('readable-stream').Writable
var PassThrough = require('readable-stream').PassThrough

var noop = function () {}

var overflow = function (size) {
  size &= 511
  return size && 512 - size
}

var emptyStream = function (self, offset) {
  var s = new Source(self, offset)
  s.end()
  return s
}

var mixinPax = function (header, pax) {
  if (pax.path) header.name = pax.path
  if (pax.linkpath) header.linkname = pax.linkpath
  if (pax.size) header.size = parseInt(pax.size, 10)
  header.pax = pax
  return header
}

var Source = function (self, offset) {
  this._parent = self
  this.offset = offset
  PassThrough.call(this, { autoDestroy: false })
}

util.inherits(Source, PassThrough)

Source.prototype.destroy = function (err) {
  this._parent.destroy(err)
}

var Extract = function (opts) {
  if (!(this instanceof Extract)) return new Extract(opts)
  Writable.call(this, opts)

  opts = opts || {}

  this._offset = 0
  this._buffer = bl()
  this._missing = 0
  this._partial = false
  this._onparse = noop
  this._header = null
  this._stream = null
  this._overflow = null
  this._cb = null
  this._locked = false
  this._destroyed = false
  this._pax = null
  this._paxGlobal = null
  this._gnuLongPath = null
  this._gnuLongLinkPath = null

  var self = this
  var b = self._buffer

  var oncontinue = function () {
    self._continue()
  }

  var onunlock = function (err) {
    self._locked = false
    if (err) return self.destroy(err)
    if (!self._stream) oncontinue()
  }

  var onstreamend = function () {
    self._stream = null
    var drain = overflow(self._header.size)
    if (drain) self._parse(drain, ondrain)
    else self._parse(512, onheader)
    if (!self._locked) oncontinue()
  }

  var ondrain = function () {
    self._buffer.consume(overflow(self._header.size))
    self._parse(512, onheader)
    oncontinue()
  }

  var onpaxglobalheader = function () {
    var size = self._header.size
    self._paxGlobal = headers.decodePax(b.slice(0, size))
    b.consume(size)
    onstreamend()
  }

  var onpaxheader = function () {
    var size = self._header.size
    self._pax = headers.decodePax(b.slice(0, size))
    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)
    b.consume(size)
    onstreamend()
  }

  var ongnulongpath = function () {
    var size = self._header.size
    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var ongnulonglinkpath = function () {
    var size = self._header.size
    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var onheader = function () {
    var offset = self._offset
    var header
    try {
      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat)
    } catch (err) {
      self.emit('error', err)
    }
    b.consume(512)

    if (!header) {
      self._parse(512, onheader)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath)
      oncontinue()
      return
    }
    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader)
      oncontinue()
      return
    }
    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader)
      oncontinue()
      return
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath
      self._gnuLongPath = null
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath
      self._gnuLongLinkPath = null
    }

    if (self._pax) {
      self._header = header = mixinPax(header, self._pax)
      self._pax = null
    }

    self._locked = true

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader)
      self.emit('entry', header, emptyStream(self, offset), onunlock)
      return
    }

    self._stream = new Source(self, offset)

    self.emit('entry', header, self._stream, onunlock)
    self._parse(header.size, onstreamend)
    oncontinue()
  }

  this._onheader = onheader
  this._parse(512, onheader)
}

util.inherits(Extract, Writable)

Extract.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream) this._stream.emit('close')
}

Extract.prototype._parse = function (size, onparse) {
  if (this._destroyed) return
  this._offset += size
  this._missing = size
  if (onparse === this._onheader) this._partial = false
  this._onparse = onparse
}

Extract.prototype._continue = function () {
  if (this._destroyed) return
  var cb = this._cb
  this._cb = noop
  if (this._overflow) this._write(this._overflow, undefined, cb)
  else cb()
}

Extract.prototype._write = function (data, enc, cb) {
  if (this._destroyed) return

  var s = this._stream
  var b = this._buffer
  var missing = this._missing
  if (data.length) this._partial = true

  // we do not reach end-of-chunk now. just forward it

  if (data.length < missing) {
    this._missing -= data.length
    this._overflow = null
    if (s) return s.write(data, cb)
    b.append(data)
    return cb()
  }

  // end-of-chunk. the parser should call cb.

  this._cb = cb
  this._missing = 0

  var overflow = null
  if (data.length > missing) {
    overflow = data.slice(missing)
    data = data.slice(0, missing)
  }

  if (s) s.end(data)
  else b.append(data)

  this._overflow = overflow
  this._onparse()
}

Extract.prototype._final = function (cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
  cb()
}

module.exports = Extract

      };
    };
  }
}, {package:"tar-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\extract.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\pack.js", {"./headers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\headers.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\end-of-stream\\index.js","fs-constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fs-constants\\browser.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\node_modules\\readable-stream\\readable-browser.js","string_decoder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\string_decoder\\lib\\string_decoder.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\tar-stream\pack.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
var constants = require('fs-constants')
var eos = require('end-of-stream')
var inherits = require('inherits')
var alloc = Buffer.alloc

var Readable = require('readable-stream').Readable
var Writable = require('readable-stream').Writable
var StringDecoder = require('string_decoder').StringDecoder

var headers = require('./headers')

var DMODE = parseInt('755', 8)
var FMODE = parseInt('644', 8)

var END_OF_TAR = alloc(1024)

var noop = function () {}

var overflow = function (self, size) {
  size &= 511
  if (size) self.push(END_OF_TAR.slice(0, 512 - size))
}

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

var Sink = function (to) {
  Writable.call(this)
  this.written = 0
  this._to = to
  this._destroyed = false
}

inherits(Sink, Writable)

Sink.prototype._write = function (data, enc, cb) {
  this.written += data.length
  if (this._to.push(data)) return cb()
  this._to._drain = cb
}

Sink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var LinkSink = function () {
  Writable.call(this)
  this.linkname = ''
  this._decoder = new StringDecoder('utf-8')
  this._destroyed = false
}

inherits(LinkSink, Writable)

LinkSink.prototype._write = function (data, enc, cb) {
  this.linkname += this._decoder.write(data)
  cb()
}

LinkSink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Void = function () {
  Writable.call(this)
  this._destroyed = false
}

inherits(Void, Writable)

Void.prototype._write = function (data, enc, cb) {
  cb(new Error('No body allowed for this entry'))
}

Void.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Pack = function (opts) {
  if (!(this instanceof Pack)) return new Pack(opts)
  Readable.call(this, opts)

  this._drain = noop
  this._finalized = false
  this._finalizing = false
  this._destroyed = false
  this._stream = null
}

inherits(Pack, Readable)

Pack.prototype.entry = function (header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry')
  if (this._finalized || this._destroyed) return

  if (typeof buffer === 'function') {
    callback = buffer
    buffer = null
  }

  if (!callback) callback = noop

  var self = this

  if (!header.size || header.type === 'symlink') header.size = 0
  if (!header.type) header.type = modeToType(header.mode)
  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
  if (!header.uid) header.uid = 0
  if (!header.gid) header.gid = 0
  if (!header.mtime) header.mtime = new Date()

  if (typeof buffer === 'string') buffer = Buffer.from(buffer)
  if (Buffer.isBuffer(buffer)) {
    header.size = buffer.length
    this._encode(header)
    var ok = this.push(buffer)
    overflow(self, header.size)
    if (ok) process.nextTick(callback)
    else this._drain = callback
    return new Void()
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new LinkSink()
    eos(linkSink, function (err) {
      if (err) { // stream was closed
        self.destroy()
        return callback(err)
      }

      header.linkname = linkSink.linkname
      self._encode(header)
      callback()
    })

    return linkSink
  }

  this._encode(header)

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    process.nextTick(callback)
    return new Void()
  }

  var sink = new Sink(this)

  this._stream = sink

  eos(sink, function (err) {
    self._stream = null

    if (err) { // stream was closed
      self.destroy()
      return callback(err)
    }

    if (sink.written !== header.size) { // corrupting tar
      self.destroy()
      return callback(new Error('size mismatch'))
    }

    overflow(self, header.size)
    if (self._finalizing) self.finalize()
    callback()
  })

  return sink
}

Pack.prototype.finalize = function () {
  if (this._stream) {
    this._finalizing = true
    return
  }

  if (this._finalized) return
  this._finalized = true
  this.push(END_OF_TAR)
  this.push(null)
}

Pack.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream && this._stream.destroy) this._stream.destroy()
}

Pack.prototype._encode = function (header) {
  if (!header.pax) {
    var buf = headers.encode(header)
    if (buf) {
      this.push(buf)
      return
    }
  }
  this._encodePax(header)
}

Pack.prototype._encodePax = function (header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  })

  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  }

  this.push(headers.encode(newHeader))
  this.push(paxHeader)
  overflow(this, paxHeader.length)

  newHeader.size = header.size
  newHeader.type = header.type
  this.push(headers.encode(newHeader))
}

Pack.prototype._read = function (n) {
  var drain = this._drain
  this._drain = noop
  drain()
}

module.exports = Pack

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"tar-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tar-stream\\pack.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-deflate\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\is-deflate\index.js
      return function (require, module, exports) {
'use strict'

module.exports = function (buf) {
  if (!buf || buf.length < 2) return false
  return buf[0] === 0x78 && (buf[1] === 1 || buf[1] === 0x9c || buf[1] === 0xda)
}

      };
    };
  }
}, {package:"is-deflate",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-deflate\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-gzip\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\is-gzip\index.js
      return function (require, module, exports) {
'use strict';

/**
 * Check if a Buffer/Uint8Array is a GZIP file
 *
 * @param {Buffer} buf
 * @api public
 */

module.exports = function (buf) {
    if (!buf || buf.length < 3) {
        return false;
    }

    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
};

      };
    };
  }
}, {package:"is-gzip",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-gzip\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\through2\\through2.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gunzip-maybe\node_modules\through2\through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\through2\\through2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\pumpify\\index.js", {"duplexify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\duplexify\\index.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gunzip-maybe\node_modules\pumpify\index.js
      return function (require, module, exports) {
var pump = require('pump')
var inherits = require('inherits')
var Duplexify = require('duplexify')

var toArray = function(args) {
  if (!args.length) return []
  return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)
}

var define = function(opts) {
  var Pumpify = function() {
    var streams = toArray(arguments)
    if (!(this instanceof Pumpify)) return new Pumpify(streams)
    Duplexify.call(this, null, null, opts)
    if (streams.length) this.setPipeline(streams)
  }

  inherits(Pumpify, Duplexify)

  Pumpify.prototype.setPipeline = function() {
    var streams = toArray(arguments)
    var self = this
    var ended = false
    var w = streams[0]
    var r = streams[streams.length-1]

    r = r.readable ? r : null
    w = w.writable ? w : null

    var onclose = function() {
      streams[0].emit('error', new Error('stream was destroyed'))
    }

    this.on('close', onclose)
    this.on('prefinish', function() {
      if (!ended) self.cork()
    })

    pump(streams, function(err) {
      self.removeListener('close', onclose)
      if (err) return self.destroy(err)
      ended = true
      self.uncork()
    })

    if (this.destroyed) return onclose()
    this.setWritable(w)
    this.setReadable(r)
  }

  return Pumpify
}

module.exports = define({destroy:false})
module.exports.obj = define({destroy:false, objectMode:true, highWaterMark:16})

      };
    };
  }
}, {package:"pumpify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\pumpify\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peek-stream\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","buffer-from":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer-from\\index.js","duplexify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peek-stream\\node_modules\\duplexify\\index.js","through2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peek-stream\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peek-stream\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var duplexify = require('duplexify')
var through = require('through2')
var bufferFrom = require('buffer-from')

var noop = function() {}

var isObject = function(data) {
  return !Buffer.isBuffer(data) && typeof data !== 'string'
}

var peek = function(opts, onpeek) {
  if (typeof opts === 'number') opts = {maxBuffer:opts}
  if (typeof opts === 'function') return peek(null, opts)
  if (!opts) opts = {}

  var maxBuffer = typeof opts.maxBuffer === 'number' ? opts.maxBuffer : 65535
  var strict = opts.strict
  var newline = opts.newline !== false

  var buffer = []
  var bufferSize = 0
  var dup = duplexify.obj()

  var peeker = through.obj({highWaterMark:1}, function(data, enc, cb) {
    if (isObject(data)) return ready(data, null, cb)
    if (!Buffer.isBuffer(data)) data = bufferFrom(data)

    if (newline) {
      var nl = Array.prototype.indexOf.call(data, 10)
      if (nl > 0 && data[nl-1] === 13) nl--

      if (nl > -1) {
        buffer.push(data.slice(0, nl))
        return ready(Buffer.concat(buffer), data.slice(nl), cb)
      }
    }

    buffer.push(data)
    bufferSize += data.length

    if (bufferSize < maxBuffer) return cb()
    if (strict) return cb(new Error('No newline found'))
    ready(Buffer.concat(buffer), null, cb)
  })

  var onpreend = function() {
    if (strict) return dup.destroy(new Error('No newline found'))
    dup.cork()
    ready(Buffer.concat(buffer), null, function(err) {
      if (err) return dup.destroy(err)
      dup.uncork()
    })
  }

  var ready = function(data, overflow, cb) {
    dup.removeListener('preend', onpreend)
    onpeek(data, function(err, parser) {
      if (err) return cb(err)

      dup.setWritable(parser)
      dup.setReadable(parser)

      if (data) parser.write(data)
      if (overflow) parser.write(overflow)

      overflow = buffer = peeker = null // free the data
      cb()
    })
  }

  dup.on('preend', onpreend)
  dup.setWritable(peeker)

  return dup
}

module.exports = peek

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"peek-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peek-stream\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\browserify-zlib\\src\\index.js", {"./binding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\browserify-zlib\\src\\binding.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","_stream_transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\transform.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\gunzip-maybe\node_modules\browserify-zlib\src\index.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"browserify-zlib",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\gunzip-maybe\\node_modules\\browserify-zlib\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\ObjectMultiplex.js", {"./Substream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\Substream.js","end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\end-of-stream\\index.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\object-multiplex\dist\ObjectMultiplex.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectMultiplex = void 0;
const readable_stream_1 = require("readable-stream");
const end_of_stream_1 = __importDefault(require("end-of-stream"));
const once_1 = __importDefault(require("once"));
const Substream_1 = require("./Substream");
const IGNORE_SUBSTREAM = Symbol('IGNORE_SUBSTREAM');
class ObjectMultiplex extends readable_stream_1.Duplex {
    constructor(opts = {}) {
        super(Object.assign(Object.assign({}, opts), { objectMode: true }));
        this._substreams = {};
    }
    createStream(name) {
        // guard stream against destroyed already
        if (this.destroyed) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already destroyed`);
        }
        // guard stream against ended already
        if (this._readableState.ended || this._writableState.ended) {
            throw new Error(`ObjectMultiplex - parent stream for name "${name}" already ended`);
        }
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // create substream
        const substream = new Substream_1.Substream({ parent: this, name });
        this._substreams[name] = substream;
        // listen for parent stream to end
        anyStreamEnd(this, (_error) => {
            return substream.destroy(_error || undefined);
        });
        return substream;
    }
    // ignore streams (dont display orphaned data warning)
    ignoreStream(name) {
        // validate name
        if (!name) {
            throw new Error('ObjectMultiplex - name must not be empty');
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // set
        this._substreams[name] = IGNORE_SUBSTREAM;
    }
    _read() {
        return undefined;
    }
    _write(chunk, _encoding, callback) {
        const { name, data } = chunk;
        if (!name) {
            console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
            return callback();
        }
        // get corresponding substream
        const substream = this._substreams[name];
        if (!substream) {
            console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
            return callback();
        }
        // push data into substream
        if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
        }
        return callback();
    }
}
exports.ObjectMultiplex = ObjectMultiplex;
// util
function anyStreamEnd(stream, _cb) {
    const cb = once_1.default(_cb);
    end_of_stream_1.default(stream, { readable: false }, cb);
    end_of_stream_1.default(stream, { writable: false }, cb);
}
//# sourceMappingURL=ObjectMultiplex.js.map
      };
    };
  }
}, {package:"@metamask\\object-multiplex",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\object-multiplex\\dist\\ObjectMultiplex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-workers\dist\enums.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STREAM_NAMES = void 0;
// I have no idea why this rule fires but you do you eslint
// eslint-disable-next-line no-shadow
var STREAM_NAMES;
(function (STREAM_NAMES) {
    STREAM_NAMES["JSON_RPC"] = "jsonRpc";
    STREAM_NAMES["COMMAND"] = "command";
})(STREAM_NAMES = exports.STREAM_NAMES || (exports.STREAM_NAMES = {}));
//# sourceMappingURL=enums.js.map
      };
    };
  }
}, {package:"@metamask\\snap-workers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-workers\\dist\\enums.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js", {"readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\json-rpc-middleware-stream\dist\createEngineStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readable_stream_1 = require("readable-stream");
/**
 * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
 *
 * @param opts - Options bag.
 * @param opts.engine - The JsonRpcEngine to wrap in a stream.
 * @returns The stream wrapping the engine.
 */
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error('Missing engine parameter!');
    }
    const { engine } = opts;
    const stream = new readable_stream_1.Duplex({ objectMode: true, read, write });
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            stream.push(message);
        });
    }
    return stream;
    function read() {
        return undefined;
    }
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res) => {
            stream.push(res);
        });
        cb();
    }
}
exports.default = createEngineStream;
//# sourceMappingURL=createEngineStream.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createEngineStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js", {"@metamask/safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\safe-event-emitter\\index.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\snap-controllers\node_modules\json-rpc-middleware-stream\dist\createStreamMiddleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const readable_stream_1 = require("readable-stream");
/**
 * Creates a JsonRpcEngine middleware with an associated Duplex stream and
 * EventEmitter. The middleware, and by extension stream, assume that middleware
 * parameters are properly formatted. No runtime type checking or validation is
 * performed.
 *
 * @returns The event emitter, middleware, and stream.
 */
function createStreamMiddleware() {
    const idMap = {};
    const stream = new readable_stream_1.Duplex({
        objectMode: true,
        read: readNoop,
        write: processMessage,
    });
    const events = new safe_event_emitter_1.default();
    const middleware = (req, res, next, end) => {
        // write req to stream
        stream.push(req);
        // register request on id map
        idMap[req.id] = { req, res, next, end };
    };
    return { events, middleware, stream };
    function readNoop() {
        return false;
    }
    function processMessage(res, _encoding, cb) {
        let err;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            }
            else {
                processResponse(res);
            }
        }
        catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    function processNotification(res) {
        events.emit('notification', res);
    }
}
exports.default = createStreamMiddleware;
//# sourceMappingURL=createStreamMiddleware.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\node_modules\\json-rpc-middleware-stream\\dist\\createStreamMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WindowPostMessageStream.js", {"./BasePostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\BasePostMessageStream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\post-message-stream\dist\WindowPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowPostMessageStream = void 0;
const BasePostMessageStream_1 = require("./BasePostMessageStream");
/**
 * Window.postMessage stream.
 */
class WindowPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with other streams across the same or
     * different window objects.
     *
     * @param args.name - The name of the stream. Used to differentiate between
     * multiple streams sharing the same window object.
     * @param args.target - The name of the stream to exchange messages with.
     * @param args.targetWindow - The window object of the target stream. Defaults
     * to `window`.
     */
    constructor({ name, target, targetWindow }) {
        if (!name || !target) {
            throw new Error('Invalid input.');
        }
        super();
        this._name = name;
        this._target = target;
        this._targetOrigin = targetWindow ? '*' : location.origin;
        this._targetWindow = targetWindow || window;
        this._onMessage = this._onMessage.bind(this);
        window.addEventListener('message', this._onMessage, false);
        this._handshake();
    }
    _postMessage(data) {
        this._targetWindow.postMessage({
            target: this._target,
            data,
        }, this._targetOrigin);
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if ((this._targetOrigin !== '*' && event.origin !== this._targetOrigin) ||
            event.source !== this._targetWindow ||
            typeof message !== 'object' ||
            message.target !== this._name ||
            !message.data) {
            return;
        }
        this._onData(message.data);
    }
    _destroy() {
        window.removeEventListener('message', this._onMessage, false);
    }
}
exports.WindowPostMessageStream = WindowPostMessageStream;
//# sourceMappingURL=WindowPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask\\post-message-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WindowPostMessageStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerPostMessageStream.js", {"./BasePostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\BasePostMessageStream.js","./enums":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\post-message-stream\dist\WorkerPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerPostMessageStream = void 0;
/* istanbul ignore file */
// We ignore coverage for the entire file due to limits on our instrumentation,
// but it is in fact covered by our tests.
const BasePostMessageStream_1 = require("./BasePostMessageStream");
const enums_1 = require("./enums");
/**
 * Worker-side dedicated web worker `postMessage` stream.
 */
class WorkerPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Note: Designed for use in web workers only.
     *
     * Creates a stream for communicating with the window that created this web
     * worker.
     */
    constructor() {
        super();
        this._name = enums_1.DEDICATED_WORKER_NAME;
        self.onmessage = this._onMessage.bind(this);
        this._handshake();
    }
    _postMessage(data) {
        // Cast of self.postMessage due to usage of DOM lib
        self.postMessage({ data });
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if (typeof message !== 'object' ||
            message.target !== this._name ||
            !message.data) {
            return;
        }
        this._onData(message.data);
    }
    // worker stream lifecycle assumed to be coterminous with global scope
    _destroy() {
        return undefined;
    }
}
exports.WorkerPostMessageStream = WorkerPostMessageStream;
//# sourceMappingURL=WorkerPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask\\post-message-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerPostMessageStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerParentPostMessageStream.js", {"./BasePostMessageStream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\BasePostMessageStream.js","./enums":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\post-message-stream\dist\WorkerParentPostMessageStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerParentPostMessageStream = void 0;
const BasePostMessageStream_1 = require("./BasePostMessageStream");
const enums_1 = require("./enums");
/**
 * Parent-side dedicated web worker `postMessage` stream.
 */
class WorkerParentPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
    /**
     * Creates a stream for communicating with a dedicated web worker.
     *
     * @param args.worker - The Web Worker to exchange messages with. The worker
     * must instantiate a WorkerPostMessageStream.
     */
    constructor({ worker }) {
        if (!worker) {
            throw new Error('Invalid input.');
        }
        super();
        this._target = enums_1.DEDICATED_WORKER_NAME;
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._handshake();
    }
    _postMessage(data) {
        this._worker.postMessage({
            target: this._target,
            data,
        });
    }
    _onMessage(event) {
        const message = event.data;
        // validate message
        if (typeof message !== 'object' || !message.data) {
            return;
        }
        this._onData(message.data);
    }
    _destroy() {
        this._worker.onmessage = null;
        this._worker = null;
    }
}
exports.WorkerParentPostMessageStream = WorkerParentPostMessageStream;
//# sourceMappingURL=WorkerParentPostMessageStream.js.map
      };
    };
  }
}, {package:"@metamask\\post-message-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\post-message-stream\\dist\\WorkerParentPostMessageStream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getSnaps.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\getSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSnapsHandler = void 0;
/**
 * `wallet_getSnaps` gets the requester's permitted and installed Snaps.
 */
exports.getSnapsHandler = {
    methodNames: ['wallet_getSnaps'],
    implementation: getSnapsImplementation,
    hookNames: {
        getSnaps: true,
    },
};
async function getSnapsImplementation(_req, res, _next, end, { getSnaps }) {
    // getSnaps is already bound to the origin
    res.result = getSnaps();
    return end();
}
//# sourceMappingURL=getSnaps.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getSnaps.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getAppKey.js", {"eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\getAppKey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAppKeyHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * `snap_getAppKey` gets the Snap's app key.
 */
exports.getAppKeyHandler = {
    methodNames: ['snap_getAppKey'],
    implementation: getAppKeyImplementation,
    hookNames: {
        getAppKey: true,
    },
};
async function getAppKeyImplementation(req, res, _next, end, { getAppKey }) {
    const [requestedAccount] = (req === null || req === void 0 ? void 0 : req.params) || [];
    if (requestedAccount !== undefined &&
        (!requestedAccount || typeof requestedAccount !== 'string')) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must omit params completely or specify a single hexadecimal string Ethereum account.',
        }));
    }
    try {
        res.result = await getAppKey(requestedAccount);
        return end();
    }
    catch (error) {
        return end(error);
    }
}
//# sourceMappingURL=getAppKey.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\getAppKey.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\enable.js", {"./common/snapInstallation":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\common\\snapInstallation.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\enable.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableWalletHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snap_controllers_1 = require("@metamask/snap-controllers");
const snapInstallation_1 = require("./common/snapInstallation");
/**
 * `wallet_enable` is a convenience method that takes a request permissions
 * object as its single parameter, and then calls `wallet_requestPermissions`,
 * `wallet_installSnaps`, and `eth_accounts` as appropriate based on the
 * requested permissions. The method returns a single object result with
 * separate properties for the return values of each method, and any errors
 * that occurred:
 *
 * `{ accounts, permissions, snaps, errors? }`
 */
exports.enableWalletHandler = {
    methodNames: ['wallet_enable'],
    implementation: enableWallet,
    hookNames: {
        getAccounts: true,
        installSnaps: true,
        requestPermissions: true,
    },
};
async function enableWallet(req, res, _next, end, { getAccounts, installSnaps, requestPermissions }) {
    if (!Array.isArray(req.params)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"params" must be an array.',
        }));
    }
    const result = {
        accounts: [],
        permissions: [],
        snaps: {},
    };
    // request the permissions
    let requestedPermissions;
    try {
        // we expect the params to be the same as wallet_requestPermissions
        requestedPermissions = snapInstallation_1.preprocessRequestedPermissions(req.params[0]);
        result.permissions = await requestPermissions(requestedPermissions);
        if (!result.permissions || !result.permissions.length) {
            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data: req });
        }
    }
    catch (err) {
        return end(err);
    }
    // install snaps, if any
    // get the names of the approved snaps
    const requestedSnaps = result.permissions
        // requestPermissions returns all permissions for the domain,
        // so we're filtering out non-snap and preexisting permissions
        .filter((perm) => perm.parentCapability.startsWith(snap_controllers_1.SNAP_PREFIX) &&
        perm.parentCapability in requestedPermissions)
        // convert from namespaced permissions to snap ids
        .reduce((_requestedSnaps, perm) => {
        const snapId = perm.parentCapability.replace(snap_controllers_1.SNAP_PREFIX_REGEX, '');
        _requestedSnaps[snapId] = requestedPermissions[perm.parentCapability];
        return _requestedSnaps;
    }, {});
    try {
        if (Object.keys(requestedSnaps).length > 0) {
            // this throws if requestedSnaps is empty
            result.snaps = await snapInstallation_1.handleInstallSnaps(requestedSnaps, installSnaps);
        }
    }
    catch (err) {
        if (!result.errors) {
            result.errors = [];
        }
        result.errors.push(eth_rpc_errors_1.serializeError(err));
    }
    // get whatever accounts we have
    result.accounts = await getAccounts();
    // return the result
    res.result = result;
    return end();
}
//# sourceMappingURL=enable.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\enable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\invokeSnapSugar.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\invokeSnapSugar.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeSnapSugarHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snap_controllers_1 = require("@metamask/snap-controllers");
const utils_1 = require("../utils");
/**
 * `wallet_invokeSnap` attempts to invoke an RPC method of the specified Snap.
 */
exports.invokeSnapSugarHandler = {
    methodNames: ['wallet_invokeSnap'],
    implementation: invokeSnapSugar,
    hookNames: undefined,
};
async function invokeSnapSugar(req, _res, next, end) {
    if (!Array.isArray(req.params) ||
        typeof req.params[0] !== 'string' ||
        !utils_1.isPlainObject(req.params[1])) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must specify a string snap ID and a plain request object.',
        }));
    }
    req.method = snap_controllers_1.SNAP_PREFIX + req.params[0];
    req.params = [req.params[1]];
    return next();
}
//# sourceMappingURL=invokeSnapSugar.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\invokeSnapSugar.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\installSnaps.js", {"./common/snapInstallation":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\common\\snapInstallation.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\permitted\installSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.installSnapsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const snapInstallation_1 = require("./common/snapInstallation");
/**
 * `wallet_installSnaps` installs the requested Snaps, if they are permitted.
 */
exports.installSnapsHandler = {
    methodNames: ['wallet_installSnaps'],
    implementation: installSnapsImplementation,
    hookNames: {
        installSnaps: true,
    },
};
async function installSnapsImplementation(req, res, _next, end, { installSnaps }) {
    if (!Array.isArray(req.params)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"params" must be an array.',
        }));
    }
    try {
        res.result = await snapInstallation_1.handleInstallSnaps(req.params[0], installSnaps);
    }
    catch (err) {
        res.error = err;
    }
    return end();
}
//# sourceMappingURL=installSnaps.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\permitted\\installSnaps.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\manageState.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\restricted\manageState.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManageStateOperation = exports.manageStateBuilder = void 0;
const snap_controllers_1 = require("@metamask/snap-controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const methodName = 'snap_manageState';
/**
 * `snap_manageState` let's the Snap store and manage some of its state on
 * your device.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        permissionType: snap_controllers_1.PermissionType.RestrictedMethod,
        targetKey: methodName,
        allowedCaveats,
        methodImplementation: getManageStateImplementation(methodHooks),
    };
};
exports.manageStateBuilder = Object.freeze({
    targetKey: methodName,
    specificationBuilder,
    methodHooks: {
        clearSnapState: true,
        getSnapState: true,
        updateSnapState: true,
    },
});
var ManageStateOperation;
(function (ManageStateOperation) {
    ManageStateOperation["clearState"] = "clear";
    ManageStateOperation["getState"] = "get";
    ManageStateOperation["updateState"] = "update";
})(ManageStateOperation = exports.ManageStateOperation || (exports.ManageStateOperation = {}));
function getManageStateImplementation({ clearSnapState, getSnapState, updateSnapState, }) {
    return async function manageState(options) {
        const { params = [], method, context: { origin }, } = options;
        const [operation, newState] = params;
        switch (operation) {
            case ManageStateOperation.clearState:
                await clearSnapState(origin);
                return null;
            case ManageStateOperation.getState:
                return await getSnapState(origin);
            case ManageStateOperation.updateState:
                if (!utils_1.isPlainObject(newState)) {
                    throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                        message: `Invalid ${method} "updateState" parameter: The new state must be a plain object.`,
                        data: {
                            receivedNewState: typeof newState === 'undefined' ? 'undefined' : newState,
                        },
                    });
                }
                await updateSnapState(origin, newState);
                return null;
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid ${method} operation: "${operation}"`);
        }
    };
}
//# sourceMappingURL=manageState.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\manageState.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\invokeSnap.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\restricted\invokeSnap.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeSnapBuilder = void 0;
const snap_controllers_1 = require("@metamask/snap-controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const methodPrefix = snap_controllers_1.SNAP_PREFIX;
const targetKey = `${methodPrefix}*`;
/**
 * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.
 * Requesting its corresponding permission will attempt to connect to the Snap,
 * and install it if it's not avaialble yet.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        permissionType: snap_controllers_1.PermissionType.RestrictedMethod,
        targetKey,
        allowedCaveats,
        methodImplementation: getInvokeSnapImplementation(methodHooks),
    };
};
exports.invokeSnapBuilder = Object.freeze({
    targetKey,
    specificationBuilder,
    methodHooks: {
        getSnap: true,
        addSnap: true,
        getSnapRpcHandler: true,
    },
});
function getInvokeSnapImplementation({ getSnap, addSnap, getSnapRpcHandler, }) {
    return async function invokeSnap(options) {
        const { params = [], method, context } = options;
        const snapRpcRequest = params[0];
        if (!utils_1.isPlainObject(snapRpcRequest)) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: 'Must specify snap RPC request object as single parameter.',
            });
        }
        const snapIdString = method.substr(snap_controllers_1.SNAP_PREFIX.length);
        if (!getSnap(snapIdString)) {
            await addSnap({
                id: snapIdString,
            });
        }
        const handler = await getSnapRpcHandler(snapIdString);
        if (!handler) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                message: `Snap RPC message handler not found for snap "${snapIdString}".`,
            });
        }
        const fromSubject = context.origin;
        // Handler is an async function that takes an snapOriginString string and a request object.
        // It should return the result it would like returned to the fromDomain as part of response.result
        return (await handler(fromSubject, snapRpcRequest));
    };
}
//# sourceMappingURL=invokeSnap.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\invokeSnap.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\confirm.js", {"../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\restricted\confirm.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmBuilder = void 0;
const snap_controllers_1 = require("@metamask/snap-controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const methodName = 'snap_confirm';
/**
 * `snap_confirm` lets the Snap display a confirmation dialog to the user.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        permissionType: snap_controllers_1.PermissionType.RestrictedMethod,
        targetKey: methodName,
        allowedCaveats,
        methodImplementation: getConfirmImplementation(methodHooks),
    };
};
exports.confirmBuilder = Object.freeze({
    targetKey: methodName,
    specificationBuilder,
    methodHooks: {
        showConfirmation: true,
    },
});
function getConfirmImplementation({ showConfirmation }) {
    return async function confirmImplementation(args) {
        const { params, context: { origin }, } = args;
        return await showConfirmation(origin, getValidatedParams(params));
    };
}
/**
 * Validates the confirm method `params` and returns them cast to the correct
 * type. Throws if validation fails.
 *
 * @param params - The unvalidated params object from the method request.
 * @returns The validated confirm method parameter object.
 */
function getValidatedParams(params) {
    if (!Array.isArray(params) || !utils_1.isPlainObject(params[0])) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Expected array params with single object.',
        });
    }
    const { prompt, description, textAreaContent } = params[0];
    if (!prompt || typeof prompt !== 'string' || prompt.length > 40) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: 'Must specify a non-empty string "prompt" less than 40 characters long.',
        });
    }
    if (description &&
        (typeof description !== 'string' || description.length > 140)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"description" must be a string no more than 140 characters long if specified.',
        });
    }
    if (textAreaContent &&
        (typeof textAreaContent !== 'string' || textAreaContent.length > 1800)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: '"textAreaContent" must be a string no more than 1800 characters long if specified.',
        });
    }
    return params[0];
}
//# sourceMappingURL=confirm.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\confirm.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\getBip44Entropy.js", {"@metamask/key-tree":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\dist\\index.js","@metamask/snap-controllers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\snap-controllers\\dist\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\rpc-methods\dist\restricted\getBip44Entropy.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBip44EntropyBuilder = void 0;
const snap_controllers_1 = require("@metamask/snap-controllers");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const key_tree_1 = require("@metamask/key-tree");
const methodPrefix = 'snap_getBip44Entropy_';
const targetKey = `${methodPrefix}*`;
/**
 * `snap_getBip44Entropy_*` lets the Snap control private keys for a particular
 * BIP-32 coin type.
 */
const specificationBuilder = ({ allowedCaveats = null, methodHooks, }) => {
    return {
        permissionType: snap_controllers_1.PermissionType.RestrictedMethod,
        targetKey,
        allowedCaveats,
        methodImplementation: getBip44EntropyImplementation(methodHooks),
    };
};
exports.getBip44EntropyBuilder = Object.freeze({
    targetKey,
    specificationBuilder,
    methodHooks: {
        getMnemonic: true,
    },
});
const ALL_DIGIT_REGEX = /^\d+$/u;
function getBip44EntropyImplementation({ getMnemonic, }) {
    return async function getBip44Entropy(args) {
        const bip44Code = args.method.substr(methodPrefix.length);
        if (!ALL_DIGIT_REGEX.test(bip44Code)) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                message: `Invalid BIP-44 code: ${bip44Code}`,
            });
        }
        return new key_tree_1.BIP44CoinTypeNode([
            `bip39:${await getMnemonic()}`,
            `bip32:44'`,
            `bip32:${Number(bip44Code)}'`,
        ]).toJSON();
    };
}
//# sourceMappingURL=getBip44Entropy.js.map
      };
    };
  }
}, {package:"@metamask\\rpc-methods",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\rpc-methods\\dist\\restricted\\getBip44Entropy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\through2\through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"through2",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js", {"./transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\transaction.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\types.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\base-eth-keyring\node_modules\@ethereumjs\tx\dist.browser\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
var transaction_1 = require("./transaction");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return transaction_1.default; } });
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@ethereumjs\\tx",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js", {"./bc-ur-registry-eth.cjs.development.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@keystonehq\base-eth-keyring\node_modules\@keystonehq\bc-ur-registry-eth\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq\\bc-ur-registry-eth",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\superPropBase.js", {"./getPrototypeOf.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@babel\runtime\helpers\superPropBase.js
      return function (require, module, exports) {
var getPrototypeOf = require("./getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel\\runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\superPropBase.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\src\util.js
      return function (require, module, exports) {
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\lib\\json2.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\plugins\lib\json2.js
      return function (require, module, exports) {
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = (0,eval)("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\plugins\\lib\\json2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\memoryStorage.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\memoryStorage.js
      return function (require, module, exports) {
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\memoryStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\cookieStorage.js", {"../src/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\cookieStorage.js
      return function (require, module, exports) {
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\cookieStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldFF-globalStorage.js", {"../src/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\oldFF-globalStorage.js
      return function (require, module, exports) {
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldFF-globalStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\localStorage.js", {"../src/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\localStorage.js
      return function (require, module, exports) {
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\localStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldIE-userDataStorage.js", {"../src/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\oldIE-userDataStorage.js
      return function (require, module, exports) {
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\oldIE-userDataStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\sessionStorage.js", {"../src/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\store\storages\sessionStorage.js
      return function (require, module, exports) {
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

      };
    };
  }
}, {package:"store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\store\\storages\\sessionStorage.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\https-did-resolver\\lib\\register.js", {"did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js","xmlhttprequest":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\https-did-resolver\lib\register.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var did_resolver_1 = require("did-resolver");
var DOC_PATH = '/.well-known/did.json';
function get(url) {
    return new Promise(function (resolve, reject) {
        // declare XMLHttpRequest in here so it can be mocked for tests
        var XMLHttpRequest = typeof window !== 'undefined'
            ? window.XMLHttpRequest
            : require('xmlhttprequest').XMLHttpRequest;
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.onreadystatechange = function () {
            if (!request || request.readyState !== 4)
                return;
            if (request.status === 200) {
                resolve(request.responseText);
            }
            else {
                reject(new Error(("Invalid http response status " + request.status + " " + request.responseText).trim()));
            }
        };
        request.setRequestHeader('accept', 'application/json');
        request.send();
    });
}
function register() {
    function resolve(did, parsed) {
        return __awaiter(this, void 0, void 0, function () {
            var url, response, error_1, data, hasContext, docIdMatchesDid, docHasPublicKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "https://" + parsed.id + DOC_PATH;
                        response = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, get(url)];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error("DID must resolve to a valid https URL: " + error_1.message);
                    case 4:
                        data = null;
                        try {
                            data = JSON.parse(response);
                        }
                        catch (error) {
                            throw new Error('DID must resolve to a JSON document');
                        }
                        hasContext = data['@context'] === 'https://w3id.org/did/v1';
                        if (!hasContext)
                            throw new Error('DID document missing context');
                        docIdMatchesDid = data.id === did;
                        if (!docIdMatchesDid)
                            throw new Error('DID document id does not match requested did');
                        docHasPublicKey = Array.isArray(data.publicKey) && data.publicKey.length > 0;
                        if (!docHasPublicKey)
                            throw new Error('DID document has no public keys');
                        return [2 /*return*/, data];
                }
            });
        });
    }
    did_resolver_1.registerMethod('https', resolve);
}
exports.default = register;
//# sourceMappingURL=register.js.map
      };
    };
  }
}, {package:"https-did-resolver",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\https-did-resolver\\lib\\register.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\muport-did-resolver\\lib\\register.js", {"@babel/runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@babel/runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\regenerator\\index.js","did-resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js","node-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\muport-did-resolver\lib\register.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didResolver = require("did-resolver");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var INFURA = 'https://ipfs.infura.io/ipfs/';

function register(ipfs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  function resolve(_x, _x2) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, parsed) {
      var doc;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchMuPortDoc(ipfs, parsed.id);

            case 2:
              doc = _context.sent;
              return _context.abrupt("return", wrapDocument(did, doc));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolve.apply(this, arguments);
  }

  (0, _didResolver.registerMethod)('muport', resolve);
}

function fetchMuPortDoc(_x3, _x4) {
  return _fetchMuPortDoc.apply(this, arguments);
}

function _fetchMuPortDoc() {
  _fetchMuPortDoc = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(ipfs, ipfsHash) {
    var doc;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;

            if (!ipfs) {
              _context2.next = 9;
              break;
            }

            _context2.t1 = JSON;
            _context2.next = 5;
            return ipfs.cat(ipfsHash);

          case 5:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 12;
            break;

          case 9:
            _context2.next = 11;
            return httpFetch(ipfsHash);

          case 11:
            _context2.t0 = _context2.sent;

          case 12:
            doc = _context2.t0;
            _context2.next = 17;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t3 = _context2["catch"](0);

          case 17:
            if (!(!doc || doc.version !== 1 || !doc.signingKey || !doc.managementKey || !doc.asymEncryptionKey)) {
              _context2.next = 20;
              break;
            }

            try {
              if (ipfs) ipfs.pin.rm(ipfsHash);
            } catch (e) {}

            throw new Error('Invalid muport did');

          case 20:
            return _context2.abrupt("return", doc);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 15]]);
  }));
  return _fetchMuPortDoc.apply(this, arguments);
}

function httpFetch(_x5) {
  return _httpFetch.apply(this, arguments);
}

function _httpFetch() {
  _httpFetch = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(cid) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _nodeFetch["default"])(INFURA + cid);

          case 2:
            return _context3.abrupt("return", _context3.sent.json());

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _httpFetch.apply(this, arguments);
}

function wrapDocument(did, muportDocument) {
  var doc = {
    "@context": "https://w3id.org/did/v1",
    "id": did,
    "publicKey": [{
      "id": did + "#signingKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did,
      "publicKeyHex": muportDocument.signingKey
    }, {
      "id": did + "#managementKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did
    }, {
      "id": did + "#encryptionKey",
      "type": "Curve25519EncryptionPublicKey",
      "owner": did,
      "publicKeyBase64": muportDocument.asymEncryptionKey
    }],
    "authentication": [{
      "type": "Secp256k1SignatureAuthentication2018",
      "publicKey": did + "#signingKey"
    }],
    "muportData": {}
  };

  if (muportDocument.managementKey.length === 42) {
    doc.publicKey[1].ethereumAddress = muportDocument.managementKey;
  } else {
    doc.publicKey[1].publicKeyHex = muportDocument.managementKey;
  }

  if (muportDocument.publicProfile) doc.uportProfile = muportDocument.publicProfile;
  if (muportDocument.symEncryptedData) doc.muportData.symEncryptedData = muportDocument.symEncryptedData;
  if (muportDocument.recoveryNetwork) doc.muportData.recoveryNetwork = muportDocument.recoveryNetwork;
  return doc;
}

module.exports = register;
      };
    };
  }
}, {package:"muport-did-resolver",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\muport-did-resolver\\lib\\register.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\types.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\graphql-request\dist\src\types.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ClientError = /** @class */ (function (_super) {
    __extends(ClientError, _super);
    function ClientError(response, request) {
        var _this = this;
        var message = ClientError.extractMessage(response) + ": " + JSON.stringify({ response: response, request: request });
        _this = _super.call(this, message) || this;
        _this.response = response;
        _this.request = request;
        // this is needed as Safari doesn't support .captureStackTrace
        /* tslint:disable-next-line */
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(_this, ClientError);
        }
        return _this;
    }
    ClientError.extractMessage = function (response) {
        try {
            return response.errors[0].message;
        }
        catch (e) {
            return "GraphQL Error (Code: " + response.status + ")";
        }
    };
    return ClientError;
}(Error));
exports.ClientError = ClientError;
//# sourceMappingURL=types.js.map
      };
    };
  }
}, {package:"graphql-request",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\dist\\src\\types.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\node_modules\\cross-fetch\\dist\\browser-polyfill.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\graphql-request\node_modules\cross-fetch\dist\browser-polyfill.js
      return function (require, module, exports) {
(function(self) {

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);

      };
    };
  }
}, {package:"cross-fetch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\graphql-request\\node_modules\\cross-fetch\\dist\\browser-polyfill.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multihashes\src\constants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
/* eslint key-spacing: off */
'use strict'

exports.names = Object.freeze({
  'identity':   0x0,
  'sha1':       0x11,
  'sha2-256':   0x12,
  'sha2-512':   0x13,
  'dbl-sha2-256': 0x56,
  'sha3-224':   0x17,
  'sha3-256':   0x16,
  'sha3-384':   0x15,
  'sha3-512':   0x14,
  'shake-128':  0x18,
  'shake-256':  0x19,
  'keccak-224': 0x1A,
  'keccak-256': 0x1B,
  'keccak-384': 0x1C,
  'keccak-512': 0x1D,
  'murmur3-128': 0x22,
  'murmur3-32':  0x23,
  'blake2b-8':   0xb201,
  'blake2b-16':  0xb202,
  'blake2b-24':  0xb203,
  'blake2b-32':  0xb204,
  'blake2b-40':  0xb205,
  'blake2b-48':  0xb206,
  'blake2b-56':  0xb207,
  'blake2b-64':  0xb208,
  'blake2b-72':  0xb209,
  'blake2b-80':  0xb20a,
  'blake2b-88':  0xb20b,
  'blake2b-96':  0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8':   0xb241,
  'blake2s-16':  0xb242,
  'blake2s-24':  0xb243,
  'blake2s-32':  0xb244,
  'blake2s-40':  0xb245,
  'blake2s-48':  0xb246,
  'blake2s-56':  0xb247,
  'blake2s-64':  0xb248,
  'blake2s-72':  0xb249,
  'blake2s-80':  0xb24a,
  'blake2s-88':  0xb24b,
  'blake2s-96':  0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'Skein256-8': 0xb301,
  'Skein256-16': 0xb302,
  'Skein256-24': 0xb303,
  'Skein256-32': 0xb304,
  'Skein256-40': 0xb305,
  'Skein256-48': 0xb306,
  'Skein256-56': 0xb307,
  'Skein256-64': 0xb308,
  'Skein256-72': 0xb309,
  'Skein256-80': 0xb30a,
  'Skein256-88': 0xb30b,
  'Skein256-96': 0xb30c,
  'Skein256-104': 0xb30d,
  'Skein256-112': 0xb30e,
  'Skein256-120': 0xb30f,
  'Skein256-128': 0xb310,
  'Skein256-136': 0xb311,
  'Skein256-144': 0xb312,
  'Skein256-152': 0xb313,
  'Skein256-160': 0xb314,
  'Skein256-168': 0xb315,
  'Skein256-176': 0xb316,
  'Skein256-184': 0xb317,
  'Skein256-192': 0xb318,
  'Skein256-200': 0xb319,
  'Skein256-208': 0xb31a,
  'Skein256-216': 0xb31b,
  'Skein256-224': 0xb31c,
  'Skein256-232': 0xb31d,
  'Skein256-240': 0xb31e,
  'Skein256-248': 0xb31f,
  'Skein256-256': 0xb320,
  'Skein512-8': 0xb321,
  'Skein512-16': 0xb322,
  'Skein512-24': 0xb323,
  'Skein512-32': 0xb324,
  'Skein512-40': 0xb325,
  'Skein512-48': 0xb326,
  'Skein512-56': 0xb327,
  'Skein512-64': 0xb328,
  'Skein512-72': 0xb329,
  'Skein512-80': 0xb32a,
  'Skein512-88': 0xb32b,
  'Skein512-96': 0xb32c,
  'Skein512-104': 0xb32d,
  'Skein512-112': 0xb32e,
  'Skein512-120': 0xb32f,
  'Skein512-128': 0xb330,
  'Skein512-136': 0xb331,
  'Skein512-144': 0xb332,
  'Skein512-152': 0xb333,
  'Skein512-160': 0xb334,
  'Skein512-168': 0xb335,
  'Skein512-176': 0xb336,
  'Skein512-184': 0xb337,
  'Skein512-192': 0xb338,
  'Skein512-200': 0xb339,
  'Skein512-208': 0xb33a,
  'Skein512-216': 0xb33b,
  'Skein512-224': 0xb33c,
  'Skein512-232': 0xb33d,
  'Skein512-240': 0xb33e,
  'Skein512-248': 0xb33f,
  'Skein512-256': 0xb340,
  'Skein512-264': 0xb341,
  'Skein512-272': 0xb342,
  'Skein512-280': 0xb343,
  'Skein512-288': 0xb344,
  'Skein512-296': 0xb345,
  'Skein512-304': 0xb346,
  'Skein512-312': 0xb347,
  'Skein512-320': 0xb348,
  'Skein512-328': 0xb349,
  'Skein512-336': 0xb34a,
  'Skein512-344': 0xb34b,
  'Skein512-352': 0xb34c,
  'Skein512-360': 0xb34d,
  'Skein512-368': 0xb34e,
  'Skein512-376': 0xb34f,
  'Skein512-384': 0xb350,
  'Skein512-392': 0xb351,
  'Skein512-400': 0xb352,
  'Skein512-408': 0xb353,
  'Skein512-416': 0xb354,
  'Skein512-424': 0xb355,
  'Skein512-432': 0xb356,
  'Skein512-440': 0xb357,
  'Skein512-448': 0xb358,
  'Skein512-456': 0xb359,
  'Skein512-464': 0xb35a,
  'Skein512-472': 0xb35b,
  'Skein512-480': 0xb35c,
  'Skein512-488': 0xb35d,
  'Skein512-496': 0xb35e,
  'Skein512-504': 0xb35f,
  'Skein512-512': 0xb360,
  'Skein1024-8': 0xb361,
  'Skein1024-16': 0xb362,
  'Skein1024-24': 0xb363,
  'Skein1024-32': 0xb364,
  'Skein1024-40': 0xb365,
  'Skein1024-48': 0xb366,
  'Skein1024-56': 0xb367,
  'Skein1024-64': 0xb368,
  'Skein1024-72': 0xb369,
  'Skein1024-80': 0xb36a,
  'Skein1024-88': 0xb36b,
  'Skein1024-96': 0xb36c,
  'Skein1024-104': 0xb36d,
  'Skein1024-112': 0xb36e,
  'Skein1024-120': 0xb36f,
  'Skein1024-128': 0xb370,
  'Skein1024-136': 0xb371,
  'Skein1024-144': 0xb372,
  'Skein1024-152': 0xb373,
  'Skein1024-160': 0xb374,
  'Skein1024-168': 0xb375,
  'Skein1024-176': 0xb376,
  'Skein1024-184': 0xb377,
  'Skein1024-192': 0xb378,
  'Skein1024-200': 0xb379,
  'Skein1024-208': 0xb37a,
  'Skein1024-216': 0xb37b,
  'Skein1024-224': 0xb37c,
  'Skein1024-232': 0xb37d,
  'Skein1024-240': 0xb37e,
  'Skein1024-248': 0xb37f,
  'Skein1024-256': 0xb380,
  'Skein1024-264': 0xb381,
  'Skein1024-272': 0xb382,
  'Skein1024-280': 0xb383,
  'Skein1024-288': 0xb384,
  'Skein1024-296': 0xb385,
  'Skein1024-304': 0xb386,
  'Skein1024-312': 0xb387,
  'Skein1024-320': 0xb388,
  'Skein1024-328': 0xb389,
  'Skein1024-336': 0xb38a,
  'Skein1024-344': 0xb38b,
  'Skein1024-352': 0xb38c,
  'Skein1024-360': 0xb38d,
  'Skein1024-368': 0xb38e,
  'Skein1024-376': 0xb38f,
  'Skein1024-384': 0xb390,
  'Skein1024-392': 0xb391,
  'Skein1024-400': 0xb392,
  'Skein1024-408': 0xb393,
  'Skein1024-416': 0xb394,
  'Skein1024-424': 0xb395,
  'Skein1024-432': 0xb396,
  'Skein1024-440': 0xb397,
  'Skein1024-448': 0xb398,
  'Skein1024-456': 0xb399,
  'Skein1024-464': 0xb39a,
  'Skein1024-472': 0xb39b,
  'Skein1024-480': 0xb39c,
  'Skein1024-488': 0xb39d,
  'Skein1024-496': 0xb39e,
  'Skein1024-504': 0xb39f,
  'Skein1024-512': 0xb3a0,
  'Skein1024-520': 0xb3a1,
  'Skein1024-528': 0xb3a2,
  'Skein1024-536': 0xb3a3,
  'Skein1024-544': 0xb3a4,
  'Skein1024-552': 0xb3a5,
  'Skein1024-560': 0xb3a6,
  'Skein1024-568': 0xb3a7,
  'Skein1024-576': 0xb3a8,
  'Skein1024-584': 0xb3a9,
  'Skein1024-592': 0xb3aa,
  'Skein1024-600': 0xb3ab,
  'Skein1024-608': 0xb3ac,
  'Skein1024-616': 0xb3ad,
  'Skein1024-624': 0xb3ae,
  'Skein1024-632': 0xb3af,
  'Skein1024-640': 0xb3b0,
  'Skein1024-648': 0xb3b1,
  'Skein1024-656': 0xb3b2,
  'Skein1024-664': 0xb3b3,
  'Skein1024-672': 0xb3b4,
  'Skein1024-680': 0xb3b5,
  'Skein1024-688': 0xb3b6,
  'Skein1024-696': 0xb3b7,
  'Skein1024-704': 0xb3b8,
  'Skein1024-712': 0xb3b9,
  'Skein1024-720': 0xb3ba,
  'Skein1024-728': 0xb3bb,
  'Skein1024-736': 0xb3bc,
  'Skein1024-744': 0xb3bd,
  'Skein1024-752': 0xb3be,
  'Skein1024-760': 0xb3bf,
  'Skein1024-768': 0xb3c0,
  'Skein1024-776': 0xb3c1,
  'Skein1024-784': 0xb3c2,
  'Skein1024-792': 0xb3c3,
  'Skein1024-800': 0xb3c4,
  'Skein1024-808': 0xb3c5,
  'Skein1024-816': 0xb3c6,
  'Skein1024-824': 0xb3c7,
  'Skein1024-832': 0xb3c8,
  'Skein1024-840': 0xb3c9,
  'Skein1024-848': 0xb3ca,
  'Skein1024-856': 0xb3cb,
  'Skein1024-864': 0xb3cc,
  'Skein1024-872': 0xb3cd,
  'Skein1024-880': 0xb3ce,
  'Skein1024-888': 0xb3cf,
  'Skein1024-896': 0xb3d0,
  'Skein1024-904': 0xb3d1,
  'Skein1024-912': 0xb3d2,
  'Skein1024-920': 0xb3d3,
  'Skein1024-928': 0xb3d4,
  'Skein1024-936': 0xb3d5,
  'Skein1024-944': 0xb3d6,
  'Skein1024-952': 0xb3d7,
  'Skein1024-960': 0xb3d8,
  'Skein1024-968': 0xb3d9,
  'Skein1024-976': 0xb3da,
  'Skein1024-984': 0xb3db,
  'Skein1024-992': 0xb3dc,
  'Skein1024-1000': 0xb3dd,
  'Skein1024-1008': 0xb3de,
  'Skein1024-1016': 0xb3df,
  'Skein1024-1024': 0xb3e0
})

exports.codes = Object.freeze({
  0x0: 'identity',

  // sha family
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x56: 'dbl-sha2-256',
  0x17: 'sha3-224',
  0x16: 'sha3-256',
  0x15: 'sha3-384',
  0x14: 'sha3-512',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1A: 'keccak-224',
  0x1B: 'keccak-256',
  0x1C: 'keccak-384',
  0x1D: 'keccak-512',

  0x22: 'murmur3-128',
  0x23: 'murmur3-32',

  // blake2
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',

  // skein
  0xb301: 'Skein256-8',
  0xb302: 'Skein256-16',
  0xb303: 'Skein256-24',
  0xb304: 'Skein256-32',
  0xb305: 'Skein256-40',
  0xb306: 'Skein256-48',
  0xb307: 'Skein256-56',
  0xb308: 'Skein256-64',
  0xb309: 'Skein256-72',
  0xb30a: 'Skein256-80',
  0xb30b: 'Skein256-88',
  0xb30c: 'Skein256-96',
  0xb30d: 'Skein256-104',
  0xb30e: 'Skein256-112',
  0xb30f: 'Skein256-120',
  0xb310: 'Skein256-128',
  0xb311: 'Skein256-136',
  0xb312: 'Skein256-144',
  0xb313: 'Skein256-152',
  0xb314: 'Skein256-160',
  0xb315: 'Skein256-168',
  0xb316: 'Skein256-176',
  0xb317: 'Skein256-184',
  0xb318: 'Skein256-192',
  0xb319: 'Skein256-200',
  0xb31a: 'Skein256-208',
  0xb31b: 'Skein256-216',
  0xb31c: 'Skein256-224',
  0xb31d: 'Skein256-232',
  0xb31e: 'Skein256-240',
  0xb31f: 'Skein256-248',
  0xb320: 'Skein256-256',
  0xb321: 'Skein512-8',
  0xb322: 'Skein512-16',
  0xb323: 'Skein512-24',
  0xb324: 'Skein512-32',
  0xb325: 'Skein512-40',
  0xb326: 'Skein512-48',
  0xb327: 'Skein512-56',
  0xb328: 'Skein512-64',
  0xb329: 'Skein512-72',
  0xb32a: 'Skein512-80',
  0xb32b: 'Skein512-88',
  0xb32c: 'Skein512-96',
  0xb32d: 'Skein512-104',
  0xb32e: 'Skein512-112',
  0xb32f: 'Skein512-120',
  0xb330: 'Skein512-128',
  0xb331: 'Skein512-136',
  0xb332: 'Skein512-144',
  0xb333: 'Skein512-152',
  0xb334: 'Skein512-160',
  0xb335: 'Skein512-168',
  0xb336: 'Skein512-176',
  0xb337: 'Skein512-184',
  0xb338: 'Skein512-192',
  0xb339: 'Skein512-200',
  0xb33a: 'Skein512-208',
  0xb33b: 'Skein512-216',
  0xb33c: 'Skein512-224',
  0xb33d: 'Skein512-232',
  0xb33e: 'Skein512-240',
  0xb33f: 'Skein512-248',
  0xb340: 'Skein512-256',
  0xb341: 'Skein512-264',
  0xb342: 'Skein512-272',
  0xb343: 'Skein512-280',
  0xb344: 'Skein512-288',
  0xb345: 'Skein512-296',
  0xb346: 'Skein512-304',
  0xb347: 'Skein512-312',
  0xb348: 'Skein512-320',
  0xb349: 'Skein512-328',
  0xb34a: 'Skein512-336',
  0xb34b: 'Skein512-344',
  0xb34c: 'Skein512-352',
  0xb34d: 'Skein512-360',
  0xb34e: 'Skein512-368',
  0xb34f: 'Skein512-376',
  0xb350: 'Skein512-384',
  0xb351: 'Skein512-392',
  0xb352: 'Skein512-400',
  0xb353: 'Skein512-408',
  0xb354: 'Skein512-416',
  0xb355: 'Skein512-424',
  0xb356: 'Skein512-432',
  0xb357: 'Skein512-440',
  0xb358: 'Skein512-448',
  0xb359: 'Skein512-456',
  0xb35a: 'Skein512-464',
  0xb35b: 'Skein512-472',
  0xb35c: 'Skein512-480',
  0xb35d: 'Skein512-488',
  0xb35e: 'Skein512-496',
  0xb35f: 'Skein512-504',
  0xb360: 'Skein512-512',
  0xb361: 'Skein1024-8',
  0xb362: 'Skein1024-16',
  0xb363: 'Skein1024-24',
  0xb364: 'Skein1024-32',
  0xb365: 'Skein1024-40',
  0xb366: 'Skein1024-48',
  0xb367: 'Skein1024-56',
  0xb368: 'Skein1024-64',
  0xb369: 'Skein1024-72',
  0xb36a: 'Skein1024-80',
  0xb36b: 'Skein1024-88',
  0xb36c: 'Skein1024-96',
  0xb36d: 'Skein1024-104',
  0xb36e: 'Skein1024-112',
  0xb36f: 'Skein1024-120',
  0xb370: 'Skein1024-128',
  0xb371: 'Skein1024-136',
  0xb372: 'Skein1024-144',
  0xb373: 'Skein1024-152',
  0xb374: 'Skein1024-160',
  0xb375: 'Skein1024-168',
  0xb376: 'Skein1024-176',
  0xb377: 'Skein1024-184',
  0xb378: 'Skein1024-192',
  0xb379: 'Skein1024-200',
  0xb37a: 'Skein1024-208',
  0xb37b: 'Skein1024-216',
  0xb37c: 'Skein1024-224',
  0xb37d: 'Skein1024-232',
  0xb37e: 'Skein1024-240',
  0xb37f: 'Skein1024-248',
  0xb380: 'Skein1024-256',
  0xb381: 'Skein1024-264',
  0xb382: 'Skein1024-272',
  0xb383: 'Skein1024-280',
  0xb384: 'Skein1024-288',
  0xb385: 'Skein1024-296',
  0xb386: 'Skein1024-304',
  0xb387: 'Skein1024-312',
  0xb388: 'Skein1024-320',
  0xb389: 'Skein1024-328',
  0xb38a: 'Skein1024-336',
  0xb38b: 'Skein1024-344',
  0xb38c: 'Skein1024-352',
  0xb38d: 'Skein1024-360',
  0xb38e: 'Skein1024-368',
  0xb38f: 'Skein1024-376',
  0xb390: 'Skein1024-384',
  0xb391: 'Skein1024-392',
  0xb392: 'Skein1024-400',
  0xb393: 'Skein1024-408',
  0xb394: 'Skein1024-416',
  0xb395: 'Skein1024-424',
  0xb396: 'Skein1024-432',
  0xb397: 'Skein1024-440',
  0xb398: 'Skein1024-448',
  0xb399: 'Skein1024-456',
  0xb39a: 'Skein1024-464',
  0xb39b: 'Skein1024-472',
  0xb39c: 'Skein1024-480',
  0xb39d: 'Skein1024-488',
  0xb39e: 'Skein1024-496',
  0xb39f: 'Skein1024-504',
  0xb3a0: 'Skein1024-512',
  0xb3a1: 'Skein1024-520',
  0xb3a2: 'Skein1024-528',
  0xb3a3: 'Skein1024-536',
  0xb3a4: 'Skein1024-544',
  0xb3a5: 'Skein1024-552',
  0xb3a6: 'Skein1024-560',
  0xb3a7: 'Skein1024-568',
  0xb3a8: 'Skein1024-576',
  0xb3a9: 'Skein1024-584',
  0xb3aa: 'Skein1024-592',
  0xb3ab: 'Skein1024-600',
  0xb3ac: 'Skein1024-608',
  0xb3ad: 'Skein1024-616',
  0xb3ae: 'Skein1024-624',
  0xb3af: 'Skein1024-632',
  0xb3b0: 'Skein1024-640',
  0xb3b1: 'Skein1024-648',
  0xb3b2: 'Skein1024-656',
  0xb3b3: 'Skein1024-664',
  0xb3b4: 'Skein1024-672',
  0xb3b5: 'Skein1024-680',
  0xb3b6: 'Skein1024-688',
  0xb3b7: 'Skein1024-696',
  0xb3b8: 'Skein1024-704',
  0xb3b9: 'Skein1024-712',
  0xb3ba: 'Skein1024-720',
  0xb3bb: 'Skein1024-728',
  0xb3bc: 'Skein1024-736',
  0xb3bd: 'Skein1024-744',
  0xb3be: 'Skein1024-752',
  0xb3bf: 'Skein1024-760',
  0xb3c0: 'Skein1024-768',
  0xb3c1: 'Skein1024-776',
  0xb3c2: 'Skein1024-784',
  0xb3c3: 'Skein1024-792',
  0xb3c4: 'Skein1024-800',
  0xb3c5: 'Skein1024-808',
  0xb3c6: 'Skein1024-816',
  0xb3c7: 'Skein1024-824',
  0xb3c8: 'Skein1024-832',
  0xb3c9: 'Skein1024-840',
  0xb3ca: 'Skein1024-848',
  0xb3cb: 'Skein1024-856',
  0xb3cc: 'Skein1024-864',
  0xb3cd: 'Skein1024-872',
  0xb3ce: 'Skein1024-880',
  0xb3cf: 'Skein1024-888',
  0xb3d0: 'Skein1024-896',
  0xb3d1: 'Skein1024-904',
  0xb3d2: 'Skein1024-912',
  0xb3d3: 'Skein1024-920',
  0xb3d4: 'Skein1024-928',
  0xb3d5: 'Skein1024-936',
  0xb3d6: 'Skein1024-944',
  0xb3d7: 'Skein1024-952',
  0xb3d8: 'Skein1024-960',
  0xb3d9: 'Skein1024-968',
  0xb3da: 'Skein1024-976',
  0xb3db: 'Skein1024-984',
  0xb3dc: 'Skein1024-992',
  0xb3dd: 'Skein1024-1000',
  0xb3de: 'Skein1024-1008',
  0xb3df: 'Skein1024-1016',
  0xb3e0: 'Skein1024-1024'
})

exports.defaultLengths = Object.freeze({
  0x11: 20,
  0x12: 32,
  0x13: 64,
  0x56: 32,
  0x17: 28,
  0x16: 32,
  0x15: 48,
  0x14: 64,
  0x18: 32,
  0x19: 64,
  0x1A: 28,
  0x1B: 32,
  0x1C: 48,
  0x1D: 64,
  0x22: 32,

  0xb201: 0x01,
  0xb202: 0x02,
  0xb203: 0x03,
  0xb204: 0x04,
  0xb205: 0x05,
  0xb206: 0x06,
  0xb207: 0x07,
  0xb208: 0x08,
  0xb209: 0x09,
  0xb20a: 0x0a,
  0xb20b: 0x0b,
  0xb20c: 0x0c,
  0xb20d: 0x0d,
  0xb20e: 0x0e,
  0xb20f: 0x0f,
  0xb210: 0x10,
  0xb211: 0x11,
  0xb212: 0x12,
  0xb213: 0x13,
  0xb214: 0x14,
  0xb215: 0x15,
  0xb216: 0x16,
  0xb217: 0x17,
  0xb218: 0x18,
  0xb219: 0x19,
  0xb21a: 0x1a,
  0xb21b: 0x1b,
  0xb21c: 0x1c,
  0xb21d: 0x1d,
  0xb21e: 0x1e,
  0xb21f: 0x1f,
  0xb220: 0x20,
  0xb221: 0x21,
  0xb222: 0x22,
  0xb223: 0x23,
  0xb224: 0x24,
  0xb225: 0x25,
  0xb226: 0x26,
  0xb227: 0x27,
  0xb228: 0x28,
  0xb229: 0x29,
  0xb22a: 0x2a,
  0xb22b: 0x2b,
  0xb22c: 0x2c,
  0xb22d: 0x2d,
  0xb22e: 0x2e,
  0xb22f: 0x2f,
  0xb230: 0x30,
  0xb231: 0x31,
  0xb232: 0x32,
  0xb233: 0x33,
  0xb234: 0x34,
  0xb235: 0x35,
  0xb236: 0x36,
  0xb237: 0x37,
  0xb238: 0x38,
  0xb239: 0x39,
  0xb23a: 0x3a,
  0xb23b: 0x3b,
  0xb23c: 0x3c,
  0xb23d: 0x3d,
  0xb23e: 0x3e,
  0xb23f: 0x3f,
  0xb240: 0x40,
  0xb241: 0x01,
  0xb242: 0x02,
  0xb243: 0x03,
  0xb244: 0x04,
  0xb245: 0x05,
  0xb246: 0x06,
  0xb247: 0x07,
  0xb248: 0x08,
  0xb249: 0x09,
  0xb24a: 0x0a,
  0xb24b: 0x0b,
  0xb24c: 0x0c,
  0xb24d: 0x0d,
  0xb24e: 0x0e,
  0xb24f: 0x0f,
  0xb250: 0x10,
  0xb251: 0x11,
  0xb252: 0x12,
  0xb253: 0x13,
  0xb254: 0x14,
  0xb255: 0x15,
  0xb256: 0x16,
  0xb257: 0x17,
  0xb258: 0x18,
  0xb259: 0x19,
  0xb25a: 0x1a,
  0xb25b: 0x1b,
  0xb25c: 0x1c,
  0xb25d: 0x1d,
  0xb25e: 0x1e,
  0xb25f: 0x1f,
  0xb260: 0x20,
  0xb301: 0x01,
  0xb302: 0x02,
  0xb303: 0x03,
  0xb304: 0x04,
  0xb305: 0x05,
  0xb306: 0x06,
  0xb307: 0x07,
  0xb308: 0x08,
  0xb309: 0x09,
  0xb30a: 0x0a,
  0xb30b: 0x0b,
  0xb30c: 0x0c,
  0xb30d: 0x0d,
  0xb30e: 0x0e,
  0xb30f: 0x0f,
  0xb310: 0x10,
  0xb311: 0x11,
  0xb312: 0x12,
  0xb313: 0x13,
  0xb314: 0x14,
  0xb315: 0x15,
  0xb316: 0x16,
  0xb317: 0x17,
  0xb318: 0x18,
  0xb319: 0x19,
  0xb31a: 0x1a,
  0xb31b: 0x1b,
  0xb31c: 0x1c,
  0xb31d: 0x1d,
  0xb31e: 0x1e,
  0xb31f: 0x1f,
  0xb320: 0x20,
  0xb321: 0x01,
  0xb322: 0x02,
  0xb323: 0x03,
  0xb324: 0x04,
  0xb325: 0x05,
  0xb326: 0x06,
  0xb327: 0x07,
  0xb328: 0x08,
  0xb329: 0x09,
  0xb32a: 0x0a,
  0xb32b: 0x0b,
  0xb32c: 0x0c,
  0xb32d: 0x0d,
  0xb32e: 0x0e,
  0xb32f: 0x0f,
  0xb330: 0x10,
  0xb331: 0x11,
  0xb332: 0x12,
  0xb333: 0x13,
  0xb334: 0x14,
  0xb335: 0x15,
  0xb336: 0x16,
  0xb337: 0x17,
  0xb338: 0x18,
  0xb339: 0x19,
  0xb33a: 0x1a,
  0xb33b: 0x1b,
  0xb33c: 0x1c,
  0xb33d: 0x1d,
  0xb33e: 0x1e,
  0xb33f: 0x1f,
  0xb340: 0x20,
  0xb341: 0x21,
  0xb342: 0x22,
  0xb343: 0x23,
  0xb344: 0x24,
  0xb345: 0x25,
  0xb346: 0x26,
  0xb347: 0x27,
  0xb348: 0x28,
  0xb349: 0x29,
  0xb34a: 0x2a,
  0xb34b: 0x2b,
  0xb34c: 0x2c,
  0xb34d: 0x2d,
  0xb34e: 0x2e,
  0xb34f: 0x2f,
  0xb350: 0x30,
  0xb351: 0x31,
  0xb352: 0x32,
  0xb353: 0x33,
  0xb354: 0x34,
  0xb355: 0x35,
  0xb356: 0x36,
  0xb357: 0x37,
  0xb358: 0x38,
  0xb359: 0x39,
  0xb35a: 0x3a,
  0xb35b: 0x3b,
  0xb35c: 0x3c,
  0xb35d: 0x3d,
  0xb35e: 0x3e,
  0xb35f: 0x3f,
  0xb360: 0x40,
  0xb361: 0x01,
  0xb362: 0x02,
  0xb363: 0x03,
  0xb364: 0x04,
  0xb365: 0x05,
  0xb366: 0x06,
  0xb367: 0x07,
  0xb368: 0x08,
  0xb369: 0x09,
  0xb36a: 0x0a,
  0xb36b: 0x0b,
  0xb36c: 0x0c,
  0xb36d: 0x0d,
  0xb36e: 0x0e,
  0xb36f: 0x0f,
  0xb370: 0x10,
  0xb371: 0x11,
  0xb372: 0x12,
  0xb373: 0x13,
  0xb374: 0x14,
  0xb375: 0x15,
  0xb376: 0x16,
  0xb377: 0x17,
  0xb378: 0x18,
  0xb379: 0x19,
  0xb37a: 0x1a,
  0xb37b: 0x1b,
  0xb37c: 0x1c,
  0xb37d: 0x1d,
  0xb37e: 0x1e,
  0xb37f: 0x1f,
  0xb380: 0x20,
  0xb381: 0x21,
  0xb382: 0x22,
  0xb383: 0x23,
  0xb384: 0x24,
  0xb385: 0x25,
  0xb386: 0x26,
  0xb387: 0x27,
  0xb388: 0x28,
  0xb389: 0x29,
  0xb38a: 0x2a,
  0xb38b: 0x2b,
  0xb38c: 0x2c,
  0xb38d: 0x2d,
  0xb38e: 0x2e,
  0xb38f: 0x2f,
  0xb390: 0x30,
  0xb391: 0x31,
  0xb392: 0x32,
  0xb393: 0x33,
  0xb394: 0x34,
  0xb395: 0x35,
  0xb396: 0x36,
  0xb397: 0x37,
  0xb398: 0x38,
  0xb399: 0x39,
  0xb39a: 0x3a,
  0xb39b: 0x3b,
  0xb39c: 0x3c,
  0xb39d: 0x3d,
  0xb39e: 0x3e,
  0xb39f: 0x3f,
  0xb3a0: 0x40,
  0xb3a1: 0x41,
  0xb3a2: 0x42,
  0xb3a3: 0x43,
  0xb3a4: 0x44,
  0xb3a5: 0x45,
  0xb3a6: 0x46,
  0xb3a7: 0x47,
  0xb3a8: 0x48,
  0xb3a9: 0x49,
  0xb3aa: 0x4a,
  0xb3ab: 0x4b,
  0xb3ac: 0x4c,
  0xb3ad: 0x4d,
  0xb3ae: 0x4e,
  0xb3af: 0x4f,
  0xb3b0: 0x50,
  0xb3b1: 0x51,
  0xb3b2: 0x52,
  0xb3b3: 0x53,
  0xb3b4: 0x54,
  0xb3b5: 0x55,
  0xb3b6: 0x56,
  0xb3b7: 0x57,
  0xb3b8: 0x58,
  0xb3b9: 0x59,
  0xb3ba: 0x5a,
  0xb3bb: 0x5b,
  0xb3bc: 0x5c,
  0xb3bd: 0x5d,
  0xb3be: 0x5e,
  0xb3bf: 0x5f,
  0xb3c0: 0x60,
  0xb3c1: 0x61,
  0xb3c2: 0x62,
  0xb3c3: 0x63,
  0xb3c4: 0x64,
  0xb3c5: 0x65,
  0xb3c6: 0x66,
  0xb3c7: 0x67,
  0xb3c8: 0x68,
  0xb3c9: 0x69,
  0xb3ca: 0x6a,
  0xb3cb: 0x6b,
  0xb3cc: 0x6c,
  0xb3cd: 0x6d,
  0xb3ce: 0x6e,
  0xb3cf: 0x6f,
  0xb3d0: 0x70,
  0xb3d1: 0x71,
  0xb3d2: 0x72,
  0xb3d3: 0x73,
  0xb3d4: 0x74,
  0xb3d5: 0x75,
  0xb3d6: 0x76,
  0xb3d7: 0x77,
  0xb3d8: 0x78,
  0xb3d9: 0x79,
  0xb3da: 0x7a,
  0xb3db: 0x7b,
  0xb3dc: 0x7c,
  0xb3dd: 0x7d,
  0xb3de: 0x7e,
  0xb3df: 0x7f,
  0xb3e0: 0x80
})

      };
    };
  }
}, {package:"multihashes",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-peer-monitor\\src\\ipfs-pubsub-peer-monitor.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-peer-monitor\\src\\utils.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-pubsub-peer-monitor\src\ipfs-pubsub-peer-monitor.js
      return function (require, module, exports) {
'use strict'

const { difference} = require('./utils')
const EventEmitter = require('events')

const DEFAULT_OPTIONS = {
  start: true,
  pollInterval: 1000,
}

class IpfsPubsubPeerMonitor extends EventEmitter {
  constructor (ipfsPubsub, topic, options) {
    super()
    this._pubsub = ipfsPubsub
    this._topic = topic
    this._options = Object.assign({}, DEFAULT_OPTIONS, options)
    this._peers = []
    this._interval = null

    if (this._options.start)
      this.start()
  }

  get started () { return this._interval !== null }
  set started (val) { throw new Error("'started' is read-only") }

  start () {
    if (this._interval)
      this.stop()

    this._interval = setInterval(
      this._pollPeers.bind(this), 
      this._options.pollInterval
    )
  }

  stop () {
    clearInterval(this._interval)
    this._interval = null
    this.removeAllListeners('error')
    this.removeAllListeners('join')
    this.removeAllListeners('leave')
  }

  async getPeers () {
    this._peers = await this._pubsub.peers(this._topic)
    return this._peers.slice()
  }

  hasPeer (peer) {
    return this._peers.includes(peer)
  }

  async _pollPeers () {
    try {
      const peers = await this._pubsub.peers(this._topic)
      IpfsPubsubPeerMonitor._emitJoinsAndLeaves(new Set(this._peers), new Set(peers), this)
      this._peers = peers
    } catch (err) {
      clearInterval(this._interval)
      this.emit('error', err)
    }
  }

  static _emitJoinsAndLeaves (oldValues, newValues, events) {
    const emitJoin = addedPeer => events.emit('join', addedPeer)
    const emitLeave = removedPeer => events.emit('leave', removedPeer)
    difference(newValues, oldValues).forEach(emitJoin)
    difference(oldValues, newValues).forEach(emitLeave)
  }
}

module.exports = IpfsPubsubPeerMonitor

      };
    };
  }
}, {package:"ipfs-pubsub-peer-monitor",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-peer-monitor\\src\\ipfs-pubsub-peer-monitor.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-series\\index.js", {"@sindresorhus/is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-series\\node_modules\\@sindresorhus\\is\\dist\\index.js","p-reduce":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-reduce\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\p-series\index.js
      return function (require, module, exports) {
'use strict';
const pReduce = require('p-reduce');
const is = require('@sindresorhus/is');

module.exports = iterable => {
	const ret = [];

	for (const task of iterable) {
		const type = is(task);

		if (type !== 'Function') {
			return Promise.reject(new TypeError(`Expected task to be a \`Function\`, received \`${type}\``));
		}
	}

	return pReduce(iterable, (_, fn) => {
		return Promise.resolve().then(fn).then(val => {
			ret.push(val);
		});
	}).then(() => ret);
};

      };
    };
  }
}, {package:"p-series",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-series\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\log-errors.js
      return function (require, module, exports) {
'use strict'

const IPFSNotDefinedError = () => new Error('IPFS instance not defined')
const LogNotDefinedError = () => new Error('Log instance not defined')
const NotALogError = () => new Error('Given argument is not an instance of Log')
const CannotJoinWithDifferentId = () => new Error('Can\'t join logs with different IDs')
const LtOrLteMustBeStringOrArray = () => new Error('lt or lte must be a string or array of Entries')

module.exports = {
  IPFSNotDefinedError: IPFSNotDefinedError,
  LogNotDefinedError: LogNotDefinedError,
  NotALogError: NotALogError,
  CannotJoinWithDifferentId: CannotJoinWithDifferentId,
  LtOrLteMustBeStringOrArray: LtOrLteMustBeStringOrArray
}

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-errors.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\g-set.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\g-set.js
      return function (require, module, exports) {
'use strict'

/**
 * Interface for G-Set CRDT
 *
 * From:
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * https://hal.inria.fr/inria-00555588
 */
class GSet {
  constructor (values) {} // eslint-disable-line
  append (value) {}
  merge (set) {}
  get (value) {}
  has (value) {}
  get values () {}
  get length () {}
}

module.exports = GSet

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\g-set.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\lamport-clock.js
      return function (require, module, exports) {
'use strict'

class LamportClock {
  constructor (id, time) {
    this.id = id
    this.time = time || 0
  }

  tick () {
    return new LamportClock(this.id, ++this.time)
  }

  merge (clock) {
    this.time = Math.max(this.time, clock.time)
    return new LamportClock(this.id, this.time)
  }

  clone () {
    return new LamportClock(this.id, this.time)
  }

  static compare (a, b) {
    // Calculate the "distance" based on the clock, ie. lower or greater
    var dist = a.time - b.time

    // If the sequence number is the same (concurrent events),
    // and the IDs are different, take the one with a "lower" id
    if (dist === 0 && a.id !== b.id) return a.id < b.id ? -1 : 1

    return dist
  }
}

module.exports = LamportClock

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry-index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\entry-index.js
      return function (require, module, exports) {
'use strict'

class EntryIndex {
  constructor (entries = {}) {
    this._cache = entries
  }

  set (k, v) {
    this._cache[k] = v
  }

  get (k) {
    return this._cache[k]
  }

  delete (k) {
    return delete this._cache[k]
  }

  add (newItems) {
    this._cache = Object.assign(this._cache, newItems)
  }

  get length () {
    return Object.values(this._cache).length
  }
}

module.exports = EntryIndex

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry-index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\default-access-controller.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\default-access-controller.js
      return function (require, module, exports) {
'use strict'

class AccessController {
  async canAppend (entry, identityProvider) {
    return true
  }
}

module.exports = AccessController

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\default-access-controller.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-each-series\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\p-each-series\index.js
      return function (require, module, exports) {
'use strict';

const pEachSeries = async (iterable, iterator) => {
	let index = 0;

	for (const value of iterable) {
		// eslint-disable-next-line no-await-in-loop
		await iterator(await value, index++);
	}

	return iterable;
};

module.exports = pEachSeries;
// TODO: Remove this for the next major release
module.exports.default = pEachSeries;

      };
    };
  }
}, {package:"p-each-series",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-each-series\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-sorting.js", {"./lamport-clock":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\log-sorting.js
      return function (require, module, exports) {
'use strict'

const Clock = require('./lamport-clock')

/**
 * Sort two entries as Last-Write-Wins (LWW).
 *
 * Last Write Wins is a conflict resolution strategy for sorting elements
 * where the element with a greater clock (latest) is chosen as the winner.
 *
 * @param {Entry} a First entry
 * @param {Entry} b Second entry
 * @returns {number} 1 if a is latest, -1 if b is latest
 */
function LastWriteWins (a, b) {
  // Ultimate conflict resolution (take the first/left arg)
  const First = (a, b) => a
  // Sort two entries by their clock id, if the same always take the first
  const sortById = (a, b) => SortByClockId(a, b, First)
  // Sort two entries by their clock time, if concurrent,
  // determine sorting using provided conflict resolution function
  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById)
  // Sort entries by clock time as the primary sort criteria
  return sortByEntryClocks(a, b)
}

/**
 * Sort two entries by their hash.
 *
 * @param {Entry} a First entry
 * @param {Entry} b Second entry
 * @returns {number} 1 if a is latest, -1 if b is latest
 */
function SortByEntryHash (a, b) {
  // Ultimate conflict resolution (compare hashes)
  const compareHash = (a, b) => a.hash < b.hash ? -1 : 1
  // Sort two entries by their clock id, if the same then compare hashes
  const sortById = (a, b) => SortByClockId(a, b, compareHash)
  // Sort two entries by their clock time, if concurrent,
  // determine sorting using provided conflict resolution function
  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById)
  // Sort entries by clock time as the primary sort criteria
  return sortByEntryClocks(a, b)
}

/**
 * Sort two entries by their clock time.
 * @param {Entry} a First entry to compare
 * @param {Entry} b Second entry to compare
 * @param {function(a, b)} resolveConflict A function to call if entries are concurrent (happened at the same time). The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.
 * @returns {number} 1 if a is greater, -1 if b is greater
 */
function SortByClocks (a, b, resolveConflict) {
  // Compare the clocks
  const diff = Clock.compare(a.clock, b.clock)
  // If the clocks are concurrent, use the provided
  // conflict resolution function to determine which comes first
  return diff === 0 ? resolveConflict(a, b) : diff
}

/**
 * Sort two entries by their clock id.
 * @param {Entry} a First entry to compare
 * @param {Entry} b Second entry to compare
 * @param {function(a, b)} resolveConflict A function to call if the clocks ids are the same. The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.
 * @returns {number} 1 if a is greater, -1 if b is greater
 */
function SortByClockId (a, b, resolveConflict) {
  // Sort by ID if clocks are concurrent,
  // take the entry with a "greater" clock id
  return a.clock.id === b.clock.id
    ? resolveConflict(a, b)
    : a.clock.id < b.clock.id ? -1 : 1
}

/**
 * A wrapper function to throw an error if the results of a passed function return zero
 * @param {function(a, b)} [tiebreaker] The tiebreaker function to validate.
 * @returns {function(a, b)} 1 if a is greater, -1 if b is greater
 * @throws {Error} if func ever returns 0
 */
function NoZeroes (func) {
  const msg = `Your log's tiebreaker function, ${func.name}, has returned zero and therefore cannot be`

  const comparator = (a, b) => {
    // Validate by calling the function
    const result = func(a, b)
    if (result === 0) { throw Error(msg) }
    return result
  }

  return comparator
}

exports.SortByClocks = SortByClocks
exports.SortByClockId = SortByClockId
exports.LastWriteWins = LastWriteWins
exports.SortByEntryHash = SortByEntryHash
exports.NoZeroes = NoZeroes

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-sorting.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\index.js", {"./difference":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\difference.js","./find-uniques":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\find-uniques.js","./is-defined":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\is-defined.js","orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\utils\index.js
      return function (require, module, exports) {
'use strict'

const difference = require('./difference')
const findUniques = require('./find-uniques')
const isDefined = require('./is-defined')
const io = require('orbit-db-io')

module.exports = {
  difference,
  findUniques,
  isDefined,
  io
}

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-io.js", {"./entry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry.js","./entry-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry-io.js","./lamport-clock":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js","./log-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-errors.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\log-io.js
      return function (require, module, exports) {
'use strict'

const Entry = require('./entry')
const EntryIO = require('./entry-io')
const Clock = require('./lamport-clock')
const LogError = require('./log-errors')
const { isDefined, findUniques, difference, io } = require('./utils')

const IPLD_LINKS = ['heads']
const last = (arr, n) => arr.slice(arr.length - n, arr.length)

class LogIO {
  //
  /**
   * Get the multihash of a Log.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Log} log Log to get a multihash for
   * @returns {Promise<string>}
   * @deprecated
   */
  static async toMultihash (ipfs, log, { format } = {}) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(log)) throw LogError.LogNotDefinedError()
    if (!isDefined(format)) format = 'dag-cbor'
    if (log.values.length < 1) throw new Error(`Can't serialize an empty log`)

    return io.write(ipfs, format, log.toJSON(), { links: IPLD_LINKS })
  }

  /**
   * Create a log from a hashes.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash of the log
   * @param {Object} options
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   */
  static async fromMultihash (ipfs, hash, { length = -1, exclude, onProgressCallback, timeout } = {}) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(hash)) throw new Error(`Invalid hash: ${hash}`)

    const logData = await io.read(ipfs, hash, { links: IPLD_LINKS })
    if (!logData.heads || !logData.id) throw LogError.NotALogError()

    const entries = await EntryIO.fetchAll(ipfs, logData.heads,
      { length, exclude, onProgressCallback, timeout })

    // Find latest clock
    const clock = entries.reduce((clock, entry) => {
      if (entry.clock.time > clock.time) {
        return new Clock(entry.clock.id, entry.clock.time)
      }
      return clock
    }, new Clock(logData.id))

    const finalEntries = entries.slice().sort(Entry.compare)
    const heads = finalEntries.filter(e => logData.heads.includes(e.hash))
    return {
      id: logData.id,
      values: finalEntries,
      heads: heads,
      clock: clock
    }
  }

  /**
   * Create a log from an entry hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash of the entry
   * @param {Object} options
   * @param {number} options.length How many items to include in the log
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   * @param {number} options.timeout Timeout for fetching a log entry from IPFS
   */
  static async fromEntryHash (ipfs, hash, { length = -1, exclude, onProgressCallback, timeout }) {
    if (!isDefined(ipfs)) throw LogError.IpfsNotDefinedError()
    if (!isDefined(hash)) throw new Error("'hash' must be defined")
    // Convert input hash(s) to an array
    const hashes = Array.isArray(hash) ? hash : [hash]
    // Fetch given length, return size at least the given input entries
    length = length > -1 ? Math.max(length, 1) : length

    const entries = await EntryIO.fetchParallel(ipfs, hashes,
      { length, exclude, onProgressCallback, timeout })
    // Cap the result at the right size by taking the last n entries,
    // or if given length is -1, then take all
    const sliced = length > -1 ? last(entries, length) : entries
    return {
      values: sliced
    }
  }

  /**
   * Creates a log data from a JSON object, to be passed to a Log constructor
   *
   * @param {IPFS} ipfs An IPFS instance
   * @param {json} json A json object containing valid log data
   * @param {Object} options
   * @param {number} options.length How many entries to include
   * @param {number} options.timeout Maximum time to wait for each fetch operation, in ms
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   **/
  static async fromJSON (ipfs, json, { length = -1, timeout, onProgressCallback }) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    const headHashes = json.heads.map(e => e.hash)
    const entries = await EntryIO.fetchParallel(ipfs, headHashes,
      { length, exclude: [], concurrency: 16, timeout, onProgressCallback })
    const finalEntries = entries.slice().sort(Entry.compare)
    return {
      id: json.id,
      values: finalEntries,
      heads: json.heads
    }
  }

  /**
   * Create a new log starting from an entry.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Entry|Array<Entry>} sourceEntries An entry or an array of entries to fetch a log from
   * @param {Object} options
   * @param {number} options.length How many entries to include
   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)
   * @param {function(hash, entry, parent, depth)} options.onProgressCallback
   */
  static async fromEntry (ipfs, sourceEntries, { length = -1, exclude, onProgressCallback, timeout }) {
    if (!isDefined(ipfs)) throw LogError.IPFSNotDefinedError()
    if (!isDefined(sourceEntries)) throw new Error("'sourceEntries' must be defined")

    // Make sure we only have Entry objects as input
    if (!Array.isArray(sourceEntries) && !Entry.isEntry(sourceEntries)) {
      throw new Error(`'sourceEntries' argument must be an array of Entry instances or a single Entry`)
    }

    if (!Array.isArray(sourceEntries)) {
      sourceEntries = [sourceEntries]
    }

    // Fetch given length, return size at least the given input entries
    length = length > -1 ? Math.max(length, sourceEntries.length) : length

    // Make sure we pass hashes instead of objects to the fetcher function
    const hashes = sourceEntries.map(e => e.hash)

    // Fetch the entries
    const entries = await EntryIO.fetchParallel(ipfs, hashes,
      { length, exclude, onProgressCallback, timeout })

    // Combine the fetches with the source entries and take only uniques
    const combined = sourceEntries.concat(entries)
    const uniques = findUniques(combined, 'hash').sort(Entry.compare)

    // Cap the result at the right size by taking the last n entries
    const sliced = uniques.slice(length > -1 ? -length : -uniques.length)

    // Make sure that the given input entries are present in the result
    // in order to not lose references
    const missingSourceEntries = difference(sliced, sourceEntries, 'hash')

    const replaceInFront = (a, withEntries) => {
      var sliced = a.slice(withEntries.length, a.length)
      return withEntries.concat(sliced)
    }

    // Add the input entries at the beginning of the array and remove
    // as many elements from the array before inserting the original entries
    const result = replaceInFront(sliced, missingSourceEntries)
    return {
      id: result[result.length - 1].id,
      values: result
    }
  }
}

module.exports = LogIO

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log-io.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry.js", {"./lamport-clock":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\lamport-clock.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\utils\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","json-stringify-deterministic":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\json-stringify-deterministic\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-log\src\entry.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const Clock = require('./lamport-clock')
const { isDefined, io } = require('./utils')
const stringify = require('json-stringify-deterministic')
const IPLD_LINKS = ['next']
const IpfsNotDefinedError = () => new Error('Ipfs instance not defined')
const writeFormats = {
  0: 'dag-pb',
  1: 'dag-cbor'
}

class Entry {
  /**
   * Create an Entry
   * @param {IPFS} ipfs An IPFS instance
   * @param {Identity} identity The identity instance
   * @param {string} logId The unique identifier for this log
   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data
   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries
   * @param {LamportClock} [clock] The lamport clock
   * @returns {Promise<Entry>}
   * @example
   * const entry = await Entry.create(ipfs, identity, 'hello')
   * console.log(entry)
   * // { hash: null, payload: "hello", next: [] }
   */
  static async create (ipfs, identity, logId, data, next = [], clock) {
    if (!isDefined(ipfs)) throw IpfsNotDefinedError()
    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry')
    if (!isDefined(logId)) throw new Error('Entry requires an id')
    if (!isDefined(data)) throw new Error('Entry requires data')
    if (!isDefined(next) || !Array.isArray(next)) throw new Error("'next' argument is not an array")

    // Clean the next objects and convert to hashes
    const toEntry = (e) => e.hash ? e.hash : e
    const nexts = next.filter(isDefined).map(toEntry)

    const entry = {
      hash: null, // "zd...Foo", we'll set the hash after persisting the entry
      id: logId, // For determining a unique chain
      payload: data, // Can be any JSON.stringifyable data
      next: nexts, // Array of hashes
      v: 1, // To tag the version of this data structure
      clock: clock || new Clock(identity.publicKey)
    }

    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry))

    entry.key = identity.publicKey
    entry.identity = identity.toJSON()
    entry.sig = signature
    entry.hash = await Entry.toMultihash(ipfs, entry)

    return entry
  }

  /**
   * Verifies an entry signature.
   *
   * @param {IdentityProvider} identityProvider The identity provider to use
   * @param {Entry} entry The entry being verified
   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid
   */
  static async verify (identityProvider, entry) {
    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')
    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry')
    if (!entry.key) throw new Error("Entry doesn't have a key")
    if (!entry.sig) throw new Error("Entry doesn't have a signature")

    const e = {
      hash: null,
      id: entry.id,
      payload: entry.payload,
      next: entry.next,
      v: entry.v,
      clock: entry.clock
    }

    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), 'v' + entry.v)
  }

  /**
   * Transforms an entry into a Buffer.
   * @param {Entry} entry The entry
   * @return {Buffer} The buffer
   */
  static toBuffer (entry) {
    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry)
    return Buffer.from(stringifiedEntry)
  }

  /**
   * Get the multihash of an Entry.
   * @param {IPFS} ipfs An IPFS instance
   * @param {Entry} entry Entry to get a multihash for
   * @returns {Promise<string>}
   * @example
   * const multihash = await Entry.toMultihash(ipfs, entry)
   * console.log(multihash)
   * // "Qm...Foo"
   * @deprecated
   */
  static async toMultihash (ipfs, entry) {
    if (!ipfs) throw IpfsNotDefinedError()
    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash')

    // Ensure `entry` follows the correct format
    const e = {
      hash: null,
      id: entry.id,
      payload: entry.payload,
      next: entry.next,
      v: entry.v,
      clock: entry.clock
    }

    if (entry.key) Object.assign(e, { key: entry.key })
    if (entry.identity) Object.assign(e, { identity: entry.identity })
    if (entry.sig) Object.assign(e, { sig: entry.sig })

    return io.write(ipfs, writeFormats[e.v], e, { links: IPLD_LINKS })
  }

  /**
   * Create an Entry from a hash.
   * @param {IPFS} ipfs An IPFS instance
   * @param {string} hash The hash to create an Entry from
   * @returns {Promise<Entry>}
   * @example
   * const entry = await Entry.fromMultihash(ipfs, "zd...Foo")
   * console.log(entry)
   * // { hash: "Zd...Foo", payload: "hello", next: [] }
   */
  static async fromMultihash (ipfs, hash) {
    if (!ipfs) throw IpfsNotDefinedError()
    if (!hash) throw new Error(`Invalid hash: ${hash}`)

    const e = await io.read(ipfs, hash, { links: IPLD_LINKS })

    let entry = {
      hash: hash,
      id: e.id,
      payload: e.payload,
      next: e.next,
      v: e.v,
      clock: new Clock(e.clock.id, e.clock.time)
    }

    if (e.key) Object.assign(entry, { key: e.key })
    if (e.identity) Object.assign(entry, { identity: e.identity })
    if (e.sig) Object.assign(entry, { sig: e.sig })

    return entry
  }

  /**
   * Check if an object is an Entry.
   * @param {Entry} obj
   * @returns {boolean}
   */
  static isEntry (obj) {
    return obj && obj.id !== undefined &&
      obj.next !== undefined &&
      obj.payload !== undefined &&
      obj.v !== undefined &&
      obj.hash !== undefined &&
      obj.clock !== undefined
  }

  /**
   * Compares two entries.
   * @param {Entry} a
   * @param {Entry} b
   * @returns {number} 1 if a is greater, -1 is b is greater
   */
  static compare (a, b) {
    var distance = Clock.compare(a.clock, b.clock)
    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1
    return distance
  }

  /**
   * Check if an entry equals another entry.
   * @param {Entry} a
   * @param {Entry} b
   * @returns {boolean}
   */
  static isEqual (a, b) {
    return a.hash === b.hash
  }

  /**
   * Check if an entry is a parent to another entry.
   * @param {Entry} entry1 Entry to check
   * @param {Entry} entry2 The parent Entry
   * @returns {boolean}
   */
  static isParent (entry1, entry2) {
    return entry2.next.indexOf(entry1.hash) > -1
  }

  /**
   * Find entry's children from an Array of entries.
   * Returns entry's children as an Array up to the last know child.
   * @param {Entry} entry Entry for which to find the parents
   * @param {Array<Entry>} values Entries to search parents from
   * @returns {Array<Entry>}
   */
  static findChildren (entry, values) {
    var stack = []
    var parent = values.find((e) => Entry.isParent(entry, e))
    var prev = entry
    while (parent) {
      stack.push(parent)
      prev = parent
      parent = values.find((e) => Entry.isParent(prev, e))
    }
    stack = stack.sort((a, b) => a.clock.time > b.clock.time)
    return stack
  }
}

module.exports = Entry

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-log",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\entry.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\did-resolver\lib\resolver.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var globalObject;
var REGISTRY;
if (typeof window === 'object') {
    globalObject = window;
}
else if (typeof global === 'object') {
    globalObject = global;
}
else {
    globalObject = {
        DID_REGISTRY: {}
    };
}
if (globalObject.DID_REGISTRY) {
    REGISTRY = globalObject.DID_REGISTRY;
}
else {
    REGISTRY = globalObject.DID_REGISTRY = {};
}
function registerMethod(method, resolver) {
    REGISTRY[method] = resolver;
}
exports.registerMethod = registerMethod;
function parse(did) {
    if (did === '')
        throw new Error('Missing DID');
    var sections = did.match(/^did:([a-zA-Z0-9_]+):([[a-zA-Z0-9_.-]+)(\/[^#]*)?(#.*)?$/);
    if (sections) {
        var parts = { did: sections[0], method: sections[1], id: sections[2] };
        if (sections[3])
            parts.path = sections[3];
        if (sections[4])
            parts.fragment = sections[4].slice(1);
        return parts;
    }
    throw new Error("Invalid DID " + did);
}
exports.parse = parse;
function resolve(did) {
    return __awaiter(this, void 0, void 0, function () {
        var parsed, resolver;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    parsed = parse(did);
                    resolver = REGISTRY[parsed.method];
                    if (!resolver) return [3 /*break*/, 2];
                    return [4 /*yield*/, resolver(did, parsed)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: throw new Error("Unsupported DID method: '" + parsed.method + "'");
            }
        });
    });
}
exports.default = resolve;
//# sourceMappingURL=resolver.js.map
      };
    };
  }
}, {package:"did-resolver",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-resolver\\lib\\resolver.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\node_modules\\js-sha3\\src\\sha3.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\3box\node_modules\did-jwt\node_modules\js-sha3\src\sha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\3box\\node_modules\\did-jwt\\node_modules\\js-sha3\\src\\sha3.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@stablelib\\utf8\\lib\\utf8.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@stablelib\utf8\lib\utf8.js
      return function (require, module, exports) {
"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var INVALID_UTF16 = "utf8: invalid string";
var INVALID_UTF8 = "utf8: invalid source encoding";
/**
 * Encodes the given string into UTF-8 byte array.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encode(s) {
    // Calculate result length and allocate output array.
    // encodedLength() also validates string and throws errors,
    // so we don't need repeat validation here.
    var arr = new Uint8Array(encodedLength(s));
    var pos = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            arr[pos++] = c;
        }
        else if (c < 0x800) {
            arr[pos++] = 0xc0 | c >> 6;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else if (c < 0xd800) {
            arr[pos++] = 0xe0 | c >> 12;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
        else {
            i++; // get one more character
            c = (c & 0x3ff) << 10;
            c |= s.charCodeAt(i) & 0x3ff;
            c += 0x10000;
            arr[pos++] = 0xf0 | c >> 18;
            arr[pos++] = 0x80 | (c >> 12) & 0x3f;
            arr[pos++] = 0x80 | (c >> 6) & 0x3f;
            arr[pos++] = 0x80 | c & 0x3f;
        }
    }
    return arr;
}
exports.encode = encode;
/**
 * Returns the number of bytes required to encode the given string into UTF-8.
 * Throws if the source string has invalid UTF-16 encoding.
 */
function encodedLength(s) {
    var result = 0;
    for (var i = 0; i < s.length; i++) {
        var c = s.charCodeAt(i);
        if (c < 0x80) {
            result += 1;
        }
        else if (c < 0x800) {
            result += 2;
        }
        else if (c < 0xd800) {
            result += 3;
        }
        else if (c <= 0xdfff) {
            if (i >= s.length - 1) {
                throw new Error(INVALID_UTF16);
            }
            i++; // "eat" next character
            result += 4;
        }
        else {
            throw new Error(INVALID_UTF16);
        }
    }
    return result;
}
exports.encodedLength = encodedLength;
/**
 * Decodes the given byte array from UTF-8 into a string.
 * Throws if encoding is invalid.
 */
function decode(arr) {
    var chars = [];
    for (var i = 0; i < arr.length; i++) {
        var b = arr[i];
        if (b & 0x80) {
            var min = void 0;
            if (b < 0xe0) {
                // Need 1 more byte.
                if (i >= arr.length) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                if ((n1 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x1f) << 6 | (n1 & 0x3f);
                min = 0x80;
            }
            else if (b < 0xf0) {
                // Need 2 more bytes.
                if (i >= arr.length - 1) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);
                min = 0x800;
            }
            else if (b < 0xf8) {
                // Need 3 more bytes.
                if (i >= arr.length - 2) {
                    throw new Error(INVALID_UTF8);
                }
                var n1 = arr[++i];
                var n2 = arr[++i];
                var n3 = arr[++i];
                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {
                    throw new Error(INVALID_UTF8);
                }
                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);
                min = 0x10000;
            }
            else {
                throw new Error(INVALID_UTF8);
            }
            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {
                throw new Error(INVALID_UTF8);
            }
            if (b >= 0x10000) {
                // Surrogate pair.
                if (b > 0x10ffff) {
                    throw new Error(INVALID_UTF8);
                }
                b -= 0x10000;
                chars.push(String.fromCharCode(0xd800 | (b >> 10)));
                b = 0xdc00 | (b & 0x3ff);
            }
        }
        chars.push(String.fromCharCode(b));
    }
    return chars.join("");
}
exports.decode = decode;
//# sourceMappingURL=utf8.js.map
      };
    };
  }
}, {package:"@stablelib\\utf8",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@stablelib\\utf8\\lib\\utf8.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uport-base64url\\index.js", {"./dist/base64url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uport-base64url\\dist\\base64url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\uport-base64url\index.js
      return function (require, module, exports) {
module.exports = require('./dist/base64url').default;
module.exports.default = module.exports;

      };
    };
  }
}, {package:"uport-base64url",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uport-base64url\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\src\\identities.js", {"./identity":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\src\\identity.js","./orbit-db-identity-provider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\src\\orbit-db-identity-provider.js","orbit-db-keystore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\index-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-identity-provider\src\identities.js
      return function (require, module, exports) {
'use strict'
const Identity = require('./identity')
const OrbitDBIdentityProvider = require('./orbit-db-identity-provider')
const Keystore = require('orbit-db-keystore')
const type = 'orbitdb'
const identityKeysPath = './orbitdb/identity/identitykeys'
const supportedTypes = {
  orbitdb: OrbitDBIdentityProvider
}

const getHandlerFor = (type) => {
  if (!Identities.isSupported(type)) {
    throw new Error(`IdentityProvider type '${type}' is not supported`)
  }
  return supportedTypes[type]
}

class Identities {
  constructor (keystore) {
    this._keystore = keystore
  }

  async sign (identity, data) {
    const signingKey = await this._keystore.getKey(identity.id)
    if (!signingKey) {
      throw new Error(`Private signing key not found from Keystore`)
    }
    const sig = await this._keystore.sign(signingKey, data)
    return sig
  }

  async verify (signature, publicKey, data, verifier = 'v1') {
    return this._keystore.verify(signature, publicKey, data, verifier)
  }

  async createIdentity (options = {}) {
    const IdentityProvider = getHandlerFor(options.type)
    const identityProvider = new IdentityProvider(options)
    const id = await identityProvider.getId(options)
    if (options.migrate) {
      await options.migrate({ targetPath: this._keystore.path, targetId: id })
    }
    const { publicKey, idSignature } = await this.signId(id)
    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options)
    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, IdentityProvider.type, this)
  }

  async signId (id) {
    const keystore = this._keystore
    const key = await keystore.getKey(id) || await keystore.createKey(id)
    const publicKey = keystore.getPublic(key)
    const idSignature = await keystore.sign(key, id)
    return { publicKey, idSignature }
  }

  async verifyIdentity (identity) {
    const verified = await this._keystore.verify(
      identity.signatures.id,
      identity.publicKey,
      identity.id
    )
    return verified && Identities.verifyIdentity(identity)
  }

  static async verifyIdentity (identity) {
    const IdentityProvider = getHandlerFor(identity.type)
    return IdentityProvider.verifyIdentity(identity)
  }

  static async createIdentity (options = {}) {
    const keystore = options.keystore || Keystore.create(options.identityKeysPath || identityKeysPath)
    options = Object.assign({}, { type }, options)
    const identities = new Identities(keystore)
    return identities.createIdentity(options)
  }

  static isSupported (type) {
    return Object.keys(supportedTypes).includes(type)
  }

  static addIdentityProvider (IdentityProvider) {
    if (!IdentityProvider) {
      throw new Error('IdentityProvider class needs to be given as an option')
    }

    if (!IdentityProvider.type ||
      typeof IdentityProvider.type !== 'string') {
      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.')
    }

    supportedTypes[IdentityProvider.type] = IdentityProvider
  }

  static removeIdentityProvider (type) {
    delete supportedTypes[type]
  }
}

module.exports = Identities

      };
    };
  }
}, {package:"orbit-db-identity-provider",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-identity-provider\\src\\identities.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\lib\\XMLHttpRequest-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-mini\src\lib\XMLHttpRequest-browser.js
      return function (require, module, exports) {
const XMLHttpRequest = window.XMLHttpRequest; // eslint-disable-line

module.exports = XMLHttpRequest;

      };
    };
  }
}, {package:"ipfs-mini",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mini\\src\\lib\\XMLHttpRequest-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64url\\index.js", {"./dist/base64url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64url\\dist\\base64url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\base64url\index.js
      return function (require, module, exports) {
module.exports = require('./dist/base64url').default;
module.exports.default = module.exports;

      };
    };
  }
}, {package:"base64url",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64url\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\index.js", {"./JWT":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\JWT.js","./NaclSigner":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\NaclSigner.js","./SimpleSigner":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\SimpleSigner.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\did-jwt\lib\index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _SimpleSigner = _interopRequireDefault(require("./SimpleSigner"));

var _NaclSigner = _interopRequireDefault(require("./NaclSigner"));

var _JWT = require("./JWT");

module.exports = {
  SimpleSigner: _SimpleSigner.default,
  NaclSigner: _NaclSigner.default,
  verifyJWT: _JWT.verifyJWT,
  createJWT: _JWT.createJWT,
  decodeJWT: _JWT.decodeJWT
};
      };
    };
  }
}, {package:"did-jwt",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\did-jwt\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-manifest.js", {"orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\access-controller-manifest.js
      return function (require, module, exports) {
'use strict'
const io = require('orbit-db-io')

class AccessControllerManifest {
  constructor (type, params = {}) {
    this.type = type
    this.params = params
  }

  static async resolve (ipfs, manifestHash, options = {}) {
    if (options.skipManifest) {
      if (!options.type) {
        throw new Error(`No manifest, access-controller type required`)
      }
      return new AccessControllerManifest(options.type, { address: manifestHash })
    } else {
      // TODO: ensure this is a valid multihash
      if (manifestHash.indexOf('/ipfs') === 0) { manifestHash = manifestHash.split('/')[2] }
      const { type, params } = await io.read(ipfs, manifestHash)
      return new AccessControllerManifest(type, params)
    }
  }

  static async create (ipfs, type, params) {
    if (params.skipManifest) {
      return params.address
    }
    const manifest = {
      type: type,
      params: params
    }
    return io.write(ipfs, 'dag-cbor', manifest)
  }
}

module.exports = AccessControllerManifest

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-manifest.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\legacy-ipfs-access-controller.js", {"./access-controller-interface":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-interface.js","orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js","safe-buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\legacy-ipfs-access-controller.js
      return function (require, module, exports) {
'use strict'
const io = require('orbit-db-io')
const Buffer = require('safe-buffer/').Buffer
const AccessController = require('./access-controller-interface')
const type = 'legacy-ipfs'

class LegacyIPFSAccessController extends AccessController {
  constructor (ipfs, options) {
    super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const publicKey = entry.key
    if (this.write.includes(publicKey) ||
      this.write.includes('*')) {
      return true
    }
    return false
  }

  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      const access = await io.read(this._ipfs, address)
      this._write = access.write
    } catch (e) {
      console.log('LegacyIPFSAccessController.load ERROR:', e)
    }
  }

  async save (options) {
    let cid
    const access = { admin: [], write: this.write, read: [] }
    try {
      cid = await io.write(this._ipfs, 'raw', Buffer.from(JSON.stringify(access, null, 2)), { format: 'dag-pb'})

    } catch (e) {
      console.log('LegacyIPFSAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid, skipManifest: true }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.publicKey] } }
    return new LegacyIPFSAccessController(orbitdb._ipfs, options)
  }
}

module.exports = LegacyIPFSAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\legacy-ipfs-access-controller.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\orbitdb-access-controller.js", {"./access-controller-interface":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-interface.js","./utils/ensure-ac-address":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\utils\\ensure-ac-address.js","p-map-series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\p-map-series\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\orbitdb-access-controller.js
      return function (require, module, exports) {
'use strict'

const pMapSeries = require('p-map-series')
const AccessController = require('./access-controller-interface')
const ensureAddress = require('./utils/ensure-ac-address')

const type = 'orbitdb'

class OrbitDBAccessController extends AccessController {
  constructor (orbitdb, options) {
    super()
    this._orbitdb = orbitdb
    this._db = null
    this._options = options || {}
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Returns the address of the OrbitDB used as the AC
  get address () {
    return this._db.address
  }

  // Return true if entry is allowed to be added to the database
  async canAppend (entry, identityProvider) {
    // Write keys and admins keys are allowed
    const access = new Set([...this.get('write'), ...this.get('admin')])
    // If the ACL contains the writer's public key or it contains '*'
    if (access.has(entry.identity.id) || access.has('*')) {
      const verifiedIdentity = await identityProvider.verifyIdentity(entry.identity)
      // Allow access if identity verifies
      return verifiedIdentity
    }

    return false
  }

  get capabilities () {
    if (this._db) {
      let capabilities = this._db.index

      const toSet = (e) => {
        const key = e[0]
        capabilities[key] = new Set([...(capabilities[key] || []), ...e[1]])
      }

      // Merge with the access controller of the database
      // and make sure all values are Sets
      Object.entries({
        ...capabilities,
        // Add the root access controller's 'write' access list
        // as admins on this controller
        ...{ admin: new Set([...(capabilities.admin || []), ...this._db.access.write])
        }
      }).forEach(toSet)

      return capabilities
    }
    return {}
  }

  get (capability) {
    return this.capabilities[capability] || new Set([])
  }

  async close () {
    await this._db.close()
  }

  async load (address) {
    if (this._db) { await this._db.close() }

    // Force '<address>/_access' naming for the database
    this._db = await this._orbitdb.keyvalue(ensureAddress(address), {
      // use ipfs controller as a immutable "root controller"
      accessController: {
        type: 'ipfs',
        write: this._options.admin || [this._orbitdb.identity.id]
      },
      sync: true
    })

    this._db.events.on('ready', this._onUpdate.bind(this))
    this._db.events.on('write', this._onUpdate.bind(this))
    this._db.events.on('replicated', this._onUpdate.bind(this))

    await this._db.load()
  }

  async save () {
    // return the manifest data
    return {
      address: this._db.address.toString()
    }
  }

  async grant (capability, key) {
    // Merge current keys with the new key
    const capabilities = new Set([...(this._db.get(capability) || []), ...[key]])
    await this._db.put(capability, Array.from(capabilities.values()))
  }

  async revoke (capability, key) {
    let capabilities = new Set(this._db.get(capability) || [])
    capabilities.delete(key)
    if (capabilities.size > 0) {
      await this._db.put(capability, Array.from(capabilities.values()))
    } else {
      await this._db.del(capability)
    }
  }

  /* Private methods */
  _onUpdate () {
    this.emit('updated')
  }

  /* Factory */
  static async create (orbitdb, options = {}) {
    const ac = new OrbitDBAccessController(orbitdb, options)
    await ac.load(options.address || options.name || 'default-access-controller')

    // Add write access from options
    if (options.write && !options.address) {
      await pMapSeries(options.write, async (e) => ac.grant('write', e))
    }

    return ac
  }
}

module.exports = OrbitDBAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\orbitdb-access-controller.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\ipfs-access-controller.js", {"./access-controller-interface":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\access-controller-interface.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\utils\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\ipfs-access-controller.js
      return function (require, module, exports) {
'use strict'
const { io } = require('./utils')
const AccessController = require('./access-controller-interface')
const type = 'ipfs'

class IPFSAccessController extends AccessController {
  constructor (ipfs, options) {
    super()
    this._ipfs = ipfs
    this._write = Array.from(options.write || [])
  }

  // Returns the type of the access controller
  static get type () { return type }

  // Return a Set of keys that have `access` capability
  get write () {
    return this._write
  }

  async canAppend (entry, identityProvider) {
    // Allow if access list contain the writer's publicKey or is '*'
    const key = entry.identity.id
    if (this.write.includes(key) || this.write.includes('*')) {
      //check identity is valid
      return identityProvider.verifyIdentity(entry.identity)
    }
    return false
  }


  async load (address) {
    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'
    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }

    try {
      this._write = await io.read(this._ipfs, address)
    } catch (e) {
      console.log('IPFSAccessController.load ERROR:', e)
    }
  }

  async save () {
    let cid
    try {

      cid = await io.write(this._ipfs, 'dag-cbor', { write: JSON.stringify(this.write, null, 2) })

    } catch (e) {
      console.log('IPFSAccessController.save ERROR:', e)
    }
    // return the manifest data
    return { address: cid }
  }

  static async create (orbitdb, options = {}) {
    options = { ...options, ...{ write: options.write || [orbitdb.identity.id] } }
    return new IPFSAccessController(orbitdb._ipfs, options)
  }
}

module.exports = IPFSAccessController

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\ipfs-access-controller.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","ipld-dag-pb":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-io\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const CID = require('cids')
const dagPB = require('ipld-dag-pb')
const defaultBase = 'base58btc'

const cidifyString = (str) => {
  if (!str) {
    return str
  }

  if (Array.isArray(str)) {
    return str.map(cidifyString)
  }

  return new CID(str)
}

const stringifyCid = (cid, options) => {
  if (!cid) {
    return cid
  }

  if (Array.isArray(cid)) {
    return cid.map(stringifyCid)
  }
  
  if (cid['/']) {
    return cid['/']
  }

  const base = options.base || defaultBase
  return cid.toBaseEncodedString(base)
}

const writePb = async (ipfs, obj) => {
  const buffer = Buffer.from(JSON.stringify(obj))
  const dagNode = dagPB.DAGNode.create(buffer)
  const cid = await ipfs.dag.put(dagNode, {
    format: 'dag-pb',
    hashAlg: 'sha2-256'
  })

  return cid.toV0().toBaseEncodedString()
}

const readPb = async (ipfs, cid) => {
  const result = await ipfs.dag.get(cid)
  const dagNode = result.value

  return JSON.parse(dagNode.toJSON().data)
}

const writeCbor = async (ipfs, obj, options) => {
  const dagNode = Object.assign({}, obj)
  const links = options.links || []
  links.forEach((prop) => {
    dagNode[prop] = cidifyString(dagNode[prop])
  })

  const base = options.base || defaultBase
  const onlyHash = options.onlyHash || false
  const cid = await ipfs.dag.put(dagNode, { onlyHash })
  return cid.toBaseEncodedString(base)
}

const readCbor = async (ipfs, cid, options) => {
  const result = await ipfs.dag.get(cid)
  const obj = result.value
  const links = options.links || []
  links.forEach((prop) => {
    obj[prop] = stringifyCid(obj[prop], options)
  })

  return obj
}

const writeObj = async (ipfs, obj, options) => {
  const onlyHash = options.onlyHash || false
  const base = options.base || defaultBase
  const opts = Object.assign({}, { onlyHash: onlyHash }, options.format ? { format: options.format, hashAlg: 'sha2-256' } : {})
  if (opts.format === 'dag-pb') {
    obj = dagPB.DAGNode.create(obj)
  }

  const cid = await ipfs.dag.put(obj, opts)
  return cid.toBaseEncodedString(base)
}

const formats = {
  'dag-pb': { read: readPb, write: writePb },
  'dag-cbor': { write: writeCbor, read: readCbor },
  'raw': { write: writeObj }
}

const write = (ipfs, codec, obj, options = {}) => {
  const format = formats[codec]
  if (!format) throw new Error('Unsupported codec')

  return format.write(ipfs, obj, options)
}

const read = (ipfs, cid, options = {}) => {
  cid = new CID(cid)
  const format = formats[cid.codec]

  if (!format) throw new Error('Unsupported codec')

  return format.read(ipfs, cid, options)
}

module.exports = {
  read,
  write
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-io",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\utils\\ensure-ac-address.js", {"path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-access-controllers\src\utils\ensure-ac-address.js
      return function (require, module, exports) {
'use strict'
const path = require('path')
// Make sure the given address has '/_access' as the last part
const ensureAddress = address => {
  const suffix = address.toString().split('/').pop()
  return suffix === '_access'
    ? address
    : path.join(address, '/_access')
}
module.exports = ensureAddress

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-access-controllers\\src\\utils\\ensure-ac-address.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-feedstore\src\FeedIndex.js
      return function (require, module, exports) {
'use strict'

class FeedIndex {
  constructor() {
    this._index = {}
  }

  get() {
    return Object.keys(this._index).map((f) => this._index[f])
  }

  updateIndex(oplog) {
    this._index = {}
    oplog.values.reduce((handled, item) => {
      if(!handled.includes(item.hash)) {
        handled.push(item.hash)
        if(item.payload.op === 'ADD') {
          this._index[item.hash] = item
        } else if(item.payload.op === 'DEL') {
          delete this._index[item.payload.value]
        }
      }
      return handled
    }, [])
  }
}

module.exports = FeedIndex

      };
    };
  }
}, {package:"orbit-db-feedstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-feedstore\\src\\FeedIndex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-eventstore\src\EventIndex.js
      return function (require, module, exports) {
'use strict'

class EventIndex {
  constructor () {
    this._index = null
  }

  get () {
    return this._index ? this._index.values : []
  }

  updateIndex (oplog) {
    this._index = oplog
  }
}

module.exports = EventIndex

      };
    };
  }
}, {package:"orbit-db-eventstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-eventstore\\src\\EventIndex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js", {"./Index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Index.js","./Replicator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Replicator.js","./replication-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\replication-info.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","ipfs-log":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-log\\src\\log.js","logplease":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js","orbit-db-io":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-io\\index.js","p-each-series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\node_modules\\p-each-series\\index.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\readable-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-store\src\Store.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const EventEmitter = require('events').EventEmitter
const Readable = require('readable-stream')
const mapSeries = require('p-each-series')
const Log = require('ipfs-log')
const Index = require('./Index')
const Replicator = require('./Replicator')
const ReplicationInfo = require('./replication-info')

const Logger = require('logplease')
const logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })
Logger.setLogLevel('ERROR')
const dagNode = require('orbit-db-io')

const DefaultOptions = {
  Index: Index,
  maxHistory: -1,
  directory: './orbitdb',
  fetchEntryTimeout: null,
  replicate: true,
  referenceCount: 64,
  replicationConcurrency: 128,
  syncLocal: false,
  sortFn: undefined
}

class Store {
  constructor (ipfs, identity, address, options) {
    if (!identity) {
      throw new Error('Identity required')
    }

    // Set the options
    let opts = Object.assign({}, DefaultOptions)
    Object.assign(opts, options)
    this.options = opts

    // Default type
    this._type = 'store'

    // Create IDs, names and paths
    this.id = address.toString()
    this.identity = identity
    this.address = address
    this.dbname = address.path || ''
    this.events = new EventEmitter()

    // External dependencies
    this._ipfs = ipfs
    this._cache = options.cache

    // Access mapping
    const defaultAccess = {
      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)
    }
    this.access = options.accessController || defaultAccess

    // Create the operations log
    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })

    // Create the index
    this._index = new this.options.Index(this.address.root)

    // Replication progress info
    this._replicationStatus = new ReplicationInfo()

    // Statistics
    this._stats = {
      snapshot: {
        bytesLoaded: -1
      },
      syncRequestsReceieved: 0
    }

    try {
      this._replicator = new Replicator(this, this.options.replicationConcurrency)
      // For internal backwards compatibility,
      // to be removed in future releases
      this._loader = this._replicator
      this._replicator.on('load.added', (entry) => {
        // Update the latest entry state (latest is the entry with largest clock time)
        this._replicationStatus.queued++
        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)
        // logger.debug(`<replicate>`)
        this.events.emit('replicate', this.address.toString(), entry)
      })
      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {
        if (this._replicationStatus.buffered > bufferedLength) {
          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength)
        } else {
          this._recalculateReplicationProgress(this._oplog.length + bufferedLength)
        }
        this._replicationStatus.buffered = bufferedLength
        this._recalculateReplicationMax(this.replicationStatus.progress)
        // logger.debug(`<replicate.progress>`)
        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)
      })

      const onLoadCompleted = async (logs, have) => {
        try {
          for (let log of logs) {
            await this._oplog.join(log)
          }
          this._replicationStatus.queued -= logs.length
          this._replicationStatus.buffered = this._replicator._buffer.length
          await this._updateIndex()

          // only store heads that has been verified and merges
          const heads = this._oplog.heads
          await this._cache.set('_remoteHeads', heads)
          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)

          // logger.debug(`<replicated>`)
          this.events.emit('replicated', this.address.toString(), logs.length)
        } catch (e) {
          console.error(e)
        }
      }
      this._replicator.on('load.end', onLoadCompleted)
    } catch (e) {
      console.error('Store Error:', e)
    }
  }

  get all () {
    return Array.isArray(this._index._index)
      ? this._index._index
      : Object.keys(this._index._index).map(e => this._index._index[e])
  }

  get index () {
    return this._index._index
  }

  get type () {
    return this._type
  }

  get key () {
    return this._key
  }

  /**
   * Returns the database's current replication status information
   * @return {[Object]} [description]
   */
  get replicationStatus () {
    return this._replicationStatus
  }

  setIdentity (identity) {
    this.identity = identity
    this._oplog.setIdentity(identity)
  }

  async close () {
    if (this.options.onClose) {
      await this.options.onClose(this.address.toString())
    }

    // Replicator teardown logic
    this._replicator.stop()

    // Reset replication statistics
    this._replicationStatus.reset()

    // Reset database statistics
    this._stats = {
      snapshot: {
        bytesLoaded: -1
      },
      syncRequestsReceieved: 0
    }

    // Remove all event listeners
    this.events.removeAllListeners('load')
    this.events.removeAllListeners('load.progress')
    this.events.removeAllListeners('replicate')
    this.events.removeAllListeners('replicate.progress')
    this.events.removeAllListeners('replicated')
    this.events.removeAllListeners('ready')
    this.events.removeAllListeners('write')

    // Close cache
    await this._cache.close()

    // Database is now closed
    // TODO: afaik we don't use 'closed' event anymore,
    // to be removed in future releases
    this.events.emit('closed', this.address.toString())
    return Promise.resolve()
  }

  /**
   * Drops a database and removes local data
   * @return {[None]}
   */
  async drop () {
    await this.close()
    await this._cache.destroy()
    // Reset
    this._index = new this.options.Index(this.address.root)
    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })
    this._cache = this.options.cache
  }

  async load (amount, { fetchEntryTimeout } = {}) {
    amount = amount || this.options.maxHistory
    fetchEntryTimeout = fetchEntryTimeout || this.options.fetchEntryTimeout;

    const localHeads = await this._cache.get('_localHeads') || []
    const remoteHeads = await this._cache.get('_remoteHeads') || []
    const heads = localHeads.concat(remoteHeads)

    if (heads.length > 0) {
      this.events.emit('load', this.address.toString(), heads)
    }

    await mapSeries(heads, async (head) => {
      this._recalculateReplicationMax(head.clock.time)
      const log = await Log.fromEntryHash(this._ipfs, this.identity, head.hash, { logId: this._oplog.id, access: this.access, sortFn: this.options.sortFn, length: amount, exclude: this._oplog.values, onProgressCallback:  this._onLoadProgress.bind(this), timeout: fetchEntryTimeout })
      await this._oplog.join(log, amount)
    })

    // Update the index
    if (heads.length > 0) {
      await this._updateIndex()
    }

    this.events.emit('ready', this.address.toString(), this._oplog.heads)
  }

  sync (heads) {
    this._stats.syncRequestsReceieved += 1
    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)
    if (heads.length === 0) {
      return
    }

    // To simulate network latency, uncomment this line
    // and comment out the rest of the function
    // That way the object (received as head message from pubsub)
    // doesn't get written to IPFS and so when the Replicator is fetching
    // the log, it'll fetch it from the network instead from the disk.
    // return this._replicator.load(heads)

    const saveToIpfs = async (head) => {
      if (!head) {
        console.warn("Warning: Given input entry was 'null'.")
        return Promise.resolve(null)
      }

      const identityProvider = this.identity.provider
      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')

      const canAppend = await this.access.canAppend(head, identityProvider)
      if (!canAppend) {
        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')
        return Promise.resolve(null)
      }

      const logEntry = Object.assign({}, head)
      logEntry.hash = null
      const codec = logEntry.v === 0 ? 'dag-pb' : 'dag-cbor'
      const hash = await dagNode.write(this._ipfs, codec, logEntry, { links: ['next'], onlyHash: true })

      if (hash !== head.hash) {
        console.warn('"WARNING! Head hash didn\'t match the contents')
      }

      return head
    }

    return mapSeries(heads, saveToIpfs)
      .then(async (saved) => {
        return this._replicator.load(saved.filter(e => e !== null))
      })
  }

  loadMoreFrom (amount, entries) {
    this._replicator.load(entries)
  }

  async saveSnapshot () {
    const unfinished = this._replicator.getQueue()

    let snapshotData = this._oplog.toSnapshot()
    let header = Buffer.from(JSON.stringify({
      id: snapshotData.id,
      heads: snapshotData.heads,
      size: snapshotData.values.length,
      type: this.type
    }))
    const rs = new Readable()
    let size = new Uint16Array([header.length])
    let bytes = Buffer.from(size.buffer)
    rs.push(bytes)
    rs.push(header)

    const addToStream = (val) => {
      let str = Buffer.from(JSON.stringify(val))
      let size = new Uint16Array([str.length])
      rs.push(Buffer.from(size.buffer))
      rs.push(str)
    }

    snapshotData.values.forEach(addToStream)
    rs.push(null) // tell the stream we're finished

    const snapshot = this._ipfs.files.add ? await this._ipfs.files.add(rs) : await this._ipfs.add(rs)

    await this._cache.set('snapshot', snapshot[snapshot.length - 1])
    await this._cache.set('queue', unfinished)

    logger.debug(`Saved snapshot: ${snapshot[snapshot.length - 1].hash}, queue length: ${unfinished.length}`)

    return snapshot
  }

  async loadFromSnapshot (onProgressCallback) {
    this.events.emit('load', this.address.toString())

    const maxClock = (res, val) => Math.max(res, val.clock.time)

    const queue = await this._cache.get('queue')
    this.sync(queue || [])

    const snapshot = await this._cache.get('snapshot')

    if (snapshot) {
      const res = this._ipfs.files.catReadableStream ? await this._ipfs.files.catReadableStream(snapshot.hash) : await this._ipfs.catReadableStream(snapshot.hash)
      const loadSnapshotData = () => {
        return new Promise((resolve, reject) => {
          let buf = Buffer.alloc(0)
          let q = []

          const bufferData = (d) => {
            this._byteSize += d.length
            if (q.length < 20000) {
              q.push(d)
            } else {
              const a = Buffer.concat(q)
              buf = Buffer.concat([buf, a])
              q = []
            }
          }

          const done = () => {
            if (q.length > 0) {
              const a = Buffer.concat(q)
              buf = Buffer.concat([buf, a])
            }

            function toArrayBuffer (buf) {
              var ab = new ArrayBuffer(buf.length)
              var view = new Uint8Array(ab)
              for (var i = 0; i < buf.length; ++i) {
                view[i] = buf[i]
              }
              return ab
            }

            const headerSize = parseInt(new Uint16Array(toArrayBuffer(buf.slice(0, 2))))
            let header

            try {
              header = JSON.parse(buf.slice(2, headerSize + 2))
            } catch (e) {
              // TODO
            }

            let values = []
            let a = 2 + headerSize
            while (a < buf.length) {
              const s = parseInt(new Uint16Array(toArrayBuffer(buf.slice(a, a + 2))))
              a += 2
              const data = buf.slice(a, a + s)
              try {
                const d = JSON.parse(data)
                values.push(d)
              } catch (e) {
              }
              a += s
            }

            if (header) {
              this._type = header.type
              resolve({ values: values, id: header.id, heads: header.heads, type: header.type })
            } else {
              resolve({ values: values, id: null, heads: null, type: null })
            }
          }
          res.on('data', bufferData)
          res.on('end', done)
        })
      }

      const onProgress = (hash, entry, count, total) => {
        this._recalculateReplicationStatus(count, entry.clock.time)
        this._onLoadProgress(hash, entry)
      }

      // Fetch the entries
      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)
      const snapshotData = await loadSnapshotData()
      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))
      if (snapshotData) {
        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, { access: this.access, sortFn: this.options.sortFn, length: -1, timeout: 1000, onProgressCallback: onProgress })
        await this._oplog.join(log)
        await this._updateIndex()
        this.events.emit('replicated', this.address.toString())
      }
      this.events.emit('ready', this.address.toString(), this._oplog.heads)
    } else {
      throw new Error(`Snapshot for ${this.address} not found!`)
    }

    return this
  }

  async _updateIndex () {
    this._recalculateReplicationMax()
    await this._index.updateIndex(this._oplog)
    this._recalculateReplicationProgress()
  }

  async syncLocal () {
    const localHeads = await this._cache.get('_localHeads') || []
    const remoteHeads = await this._cache.get('_remoteHeads') || []
    const heads = localHeads.concat(remoteHeads)
    for (let i = 0; i < heads.length; i++) {
      const head = heads[i]
      if (!this._oplog.heads.includes(head)) {
        await this.load()
        break
      }
    }
  }

  async _addOperation (data, batchOperation, lastOperation, onProgressCallback) {
    if (this._oplog) {
      // check local cache?
      if (this.options.syncLocal) {
        await this.syncLocal()
      }

      const entry = await this._oplog.append(data, this.options.referenceCount)
      this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time)
      await this._cache.set('_localHeads', [entry])
      await this._updateIndex()
      this.events.emit('write', this.address.toString(), entry, this._oplog.heads)
      if (onProgressCallback) onProgressCallback(entry)
      return entry.hash
    }
  }

  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {
    throw new Error('Not implemented!')
  }

  _onLoadProgress (hash, entry, progress, total) {
    this._recalculateReplicationStatus(progress, total)
    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)
  }

  /* Replication Status state updates */

  _recalculateReplicationProgress (max) {
    this._replicationStatus.progress = Math.max.apply(null, [
      this._replicationStatus.progress,
      this._oplog.length,
      max || 0
    ])
    this._recalculateReplicationMax(this.replicationStatus.progress)
  }

  _recalculateReplicationMax (max) {
    this._replicationStatus.max = Math.max.apply(null, [
      this._replicationStatus.max,
      this._oplog.length,
      max || 0
    ])
  }

  _recalculateReplicationStatus (maxProgress, maxTotal) {
    this._recalculateReplicationProgress(maxProgress)
    this._recalculateReplicationMax(maxTotal)
  }
}

module.exports = Store

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"orbit-db-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-store\\src\\Store.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-kvstore\src\KeyValueIndex.js
      return function (require, module, exports) {
'use strict'

class KeyValueIndex {
  constructor() {
    this._index = {}
  }

  get(key) {
    return this._index[key]
  }

  updateIndex(oplog) {
    oplog.values
      .slice()
      .reverse()
      .reduce((handled, item) => {
        if(!handled.includes(item.payload.key)) {
          handled.push(item.payload.key)
          if(item.payload.op === 'PUT') {
            this._index[item.payload.key] = item.payload.value
          } else if(item.payload.op === 'DEL') {
            delete this._index[item.payload.key]
          }
        }
        return handled
      }, [])
  }
}

module.exports = KeyValueIndex

      };
    };
  }
}, {package:"orbit-db-kvstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-kvstore\\src\\KeyValueIndex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-docstore\src\DocumentIndex.js
      return function (require, module, exports) {
'use strict'

class DocumentIndex {
  constructor () {
    this._index = {}
  }

  get (key, fullOp = false) {
    return fullOp
      ? this._index[key]
      : this._index[key] ? this._index[key].payload.value : null
  }

  updateIndex (oplog, onProgressCallback) {
    const reducer = (handled, item, idx) => {
      if (handled[item.payload.key] !== true) {
        handled[item.payload.key] = true
        if(item.payload.op === 'PUT') {
          this._index[item.payload.key] = item
        } else if (item.payload.op === 'DEL') {
          delete this._index[item.payload.key]
        }
      }
      if (onProgressCallback) onProgressCallback(item, idx)
      return handled
    }

    oplog.values
      .slice()
      .reverse()
      .reduce(reducer, {})
  }
}

module.exports = DocumentIndex

      };
    };
  }
}, {package:"orbit-db-docstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\src\\DocumentIndex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\node_modules\\p-map\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-docstore\node_modules\p-map\index.js
      return function (require, module, exports) {
'use strict';
module.exports = (iterable, mapper, opts) => new Promise((resolve, reject) => {
	opts = Object.assign({
		concurrency: Infinity
	}, opts);

	const concurrency = opts.concurrency;

	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const ret = [];
	const iterator = iterable[Symbol.iterator]();
	let isRejected = false;
	let iterableDone = false;
	let resolvingCount = 0;
	let currentIdx = 0;

	const next = () => {
		if (isRejected) {
			return;
		}

		const nextItem = iterator.next();
		const i = currentIdx;
		currentIdx++;

		if (nextItem.done) {
			iterableDone = true;

			if (resolvingCount === 0) {
				resolve(ret);
			}

			return;
		}

		resolvingCount++;

		Promise.resolve(nextItem.value)
			.then(el => mapper(el, i))
			.then(
				val => {
					ret[i] = val;
					resolvingCount--;
					next();
				},
				err => {
					isRejected = true;
					reject(err);
				}
			);
	};

	for (let i = 0; i < concurrency; i++) {
		next();

		if (iterableDone) {
			break;
		}
	}
});

      };
    };
  }
}, {package:"p-map",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-docstore\\node_modules\\p-map\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\is-defined.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db\src\utils\is-defined.js
      return function (require, module, exports) {
'use strict'

const isDefined = (arg) => arg !== undefined && arg !== null

module.exports = isDefined

      };
    };
  }
}, {package:"orbit-db",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db\\src\\utils\\is-defined.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\direct-channel.js", {"./encoding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\encoding.js","./get-peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\get-peer-id.js","./protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\protocol.js","./wait-for-peers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\wait-for-peers.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-pubsub-1on1\src\direct-channel.js
      return function (require, module, exports) {
'use strict'

const path = require('path')
const EventEmitter = require('events')
const PROTOCOL = require('./protocol')
const encode = require('./encoding')
const waitForPeers = require('./wait-for-peers')
const getPeerID = require('./get-peer-id')

/**
 * Communication channel over Pubsub between two IPFS nodes
 */
class DirectChannel extends EventEmitter {
  constructor (ipfs, receiverID) {
    super()

    // IPFS instance to use internally
    this._ipfs = ipfs

    if (!ipfs.pubsub) {
      throw new Error('This IPFS node does not support pubsub.')
    }

    this._receiverID = receiverID

    if (!this._receiverID) {
      throw new Error('Receiver ID was undefined')
    }
    // See _setup() for more state initialization
  }

  /**
   * Channel ID
   * @return {[String]} Channel's ID
   */
  get id () {
    return this._id
  }

  /**
   * Peers participating in this channel
   * @return {[Array]} Array of peer IDs participating in this channel
   */
  get peers () {
    return this._peers
  }

  async connect () {
    await waitForPeers(this._ipfs, [this._receiverID], this._id)
  }

  /**
   * Send a message to the other peer
   * @param  {[Any]} message Payload
   */
  async send (message) {
    let m = encode(message)
    await this._ipfs.pubsub.publish(this._id, m)
  }

  /**
   * Close the channel
   */
  close () {
    this.removeAllListeners('message')
    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler)
  }

  async _setup () {
    this._senderID = await getPeerID(this._ipfs)

    // Channel's participants
    this._peers = Array.from([this._senderID, this._receiverID]).sort()

    // ID of the channel is "<peer1 id>/<peer 2 id>""
    this._id = '/' + '' + PROTOCOL + '/' + this._peers.join('/')

    // Function to use to handle incoming messages
    this._messageHandler = message => {
      // Make sure the message is coming from the correct peer
      const isValid = message && message.from === this._receiverID
      // Filter out all messages that didn't come from the second peer
      if (isValid) {
        this.emit('message', message)
      }
    }
  }

  async _openChannel () {
    await this._setup()
    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler)
  }

  static async open (ipfs, receiverID) {
    const channel = new DirectChannel(ipfs, receiverID)
    await channel._openChannel()
    return channel
  }
}

module.exports = DirectChannel

      };
    };
  }
}, {package:"ipfs-pubsub-1on1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-pubsub-1on1\\src\\direct-channel.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterIndex.js", {"crdts/src/G-Counter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crdts\\src\\G-Counter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-counterstore\src\CounterIndex.js
      return function (require, module, exports) {
'use strict'

const Counter = require('crdts/src/G-Counter')

class CounterIndex {
  constructor(id) {
    this._index = new Counter(id)
  }

  get() {
    return this._index
  }

  updateIndex(oplog) {
    if(this._index) {
      const createCounter = e => Counter.from(e.payload.value)
      const mergeToIndex = e => this._index.merge(e)
      oplog.values.filter(e => e && e.payload.op === 'COUNTER')
        .map(createCounter)
        .forEach(mergeToIndex)
    }
  }
}

module.exports = CounterIndex

      };
    };
  }
}, {package:"orbit-db-counterstore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-counterstore\\src\\CounterIndex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crdts\\src\\G-Counter.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crdts\\src\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\crdts\src\G-Counter.js
      return function (require, module, exports) {
'use strict'

const { deepEqual } = require('./utils')
const sum = (acc, val) => acc + val

/**
 * G-Counter
 *
 * Operation-based Increment-Only Counter CRDT
 *
 * Sources: 
 * "A comprehensive study of Convergent and Commutative Replicated Data Types"
 * http://hal.upmc.fr/inria-00555588/document, "3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)"
 */

class GCounter {
  constructor (id, counter) {
    this.id = id
    this._counters = counter ? counter : {}
    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0
  }

  get value () {
    return Object.values(this._counters).reduce(sum, 0)
  }

  increment (amount) {
    if (amount && amount < 1) 
      return

    if (amount === undefined || amount === null)
      amount = 1

    this._counters[this.id] = this._counters[this.id] + amount
  }

  merge (other) {
    // Go through each counter in the other counter
    Object.entries(other._counters).forEach(([id, value]) => {
      // Take the maximum of the counter value we have or the counter value they have
      this._counters[id] = Math.max(this._counters[id] || 0, value)
    })
  }

  toJSON () {
    return { 
      id: this.id, 
      counters: this._counters 
    }
  }

  isEqual (other) {
    return GCounter.isEqual(this, other)
  }

  static from (json) {
    return new GCounter(json.id, json.counters)
  }

  static isEqual (a, b) {
    if(a.id !== b.id)
      return false

    return deepEqual(a._counters, b._counters)
  }
}

module.exports = GCounter

      };
    };
  }
}, {package:"crdts",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crdts\\src\\G-Counter.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\Cache.js", {"logplease":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\logplease\\src\\index.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-cache\Cache.js
      return function (require, module, exports) {
'use strict'

const path = require('path')

const Logger = require('logplease')
const logger = Logger.create('cache', { color: Logger.Colors.Magenta })
Logger.setLogLevel('ERROR')

let caches = {}

class Cache {
  constructor (storage, directory) {
    this.path = directory || './orbitdb'
    this._storage = storage
    this._store = null
  }

  // Setup storage backend
  async open () {
    logger.debug('open', this.path)

    if (this.store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      const store = this._storage(this.path)
      store.open((err) => {
        if (err) {
          return reject(err)
        }
        this._store = store
        resolve()
      })
    })
  }

  async close () {
    logger.debug('close', this.path)

    if (!this._store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.close((err) => {
        if (err) {
          return reject(err)
        }
        this._store = null
        delete caches[this.path]
        resolve()
      })
    })
  }

  async destroy () {
    logger.debug('destroy', this.path)

    return new Promise((resolve, reject) => {
      this._storage.destroy(this.path, (err) => {
        if (err) {
          return reject(err)
        }
        resolve()
      })
    })
  }

  async get (key) {
    if (!this._store) {
      await this.open()
    }

    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    return new Promise((resolve, reject) => {
      this._store.get(key, (err, value) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve(value ? JSON.parse(value) : null)
      })
    })
  }

  // Set value in the cache and return the new value
  async set (key, value) {
    if (!this._store) {
      await this.open()
    }

    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.put(key, JSON.stringify(value), (err) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve()
      })
    })
  }

  // Remove a value and key from the cache
  async del (key) {
    if (!this._store) {
      await this.open()
    }

    return new Promise((resolve, reject) => {
      this._store.del(key, (err) => {
        if (err) {
          // Ignore error if key was not found
          if (err.toString().indexOf('NotFoundError: Key not found in database') === -1 &&
            err.toString().indexOf('NotFound') === -1) {
            return reject(err)
          }
        }
        resolve()
      })
    })
  }
}

module.exports = (storage, mkdir) => {
  return {
    load: async (directory, dbAddress) => {
      logger.debug('load, database:', dbAddress.toString())

      const dbPath = path.join(dbAddress.root, dbAddress.path)
      const dataPath = path.join(directory, dbPath)
      let cache = caches[dataPath]
      if (!cache) {
        if (mkdir && mkdir.sync) {
          mkdir.sync(dataPath)
        }
        cache = new Cache(storage, dataPath)
        await cache.open()
        caches[dataPath] = cache
      }
      return cache
    },
    close: async () => {
      logger.debug('close all')

      await Promise.all(Object.values(caches), cache => cache.close())
      caches = {}
    }
  }
}

      };
    };
  }
}, {package:"orbit-db-cache",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-cache\\Cache.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\index.js", {"../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","./iterator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\iterator.js","./util/immediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\util\\immediate-browser.js","./util/mixed-to-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\util\\mixed-to-buffer.js","./util/support":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\util\\support.js","abstract-leveldown":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\abstract-leveldown\\index.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\level-js\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global indexedDB */

'use strict'

module.exports = Level

var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var Iterator = require('./iterator')
var mixedToBuffer = require('./util/mixed-to-buffer')
var setImmediate = require('./util/immediate')
var support = require('./util/support')

var DEFAULT_PREFIX = 'level-js-'

function Level (location, opts) {
  if (!(this instanceof Level)) return new Level(location, opts)
  AbstractLevelDOWN.call(this)
  opts = opts || {}

  if (typeof location !== 'string') {
    throw new Error('constructor requires a location string argument')
  }

  this.location = location
  this.prefix = opts.prefix || DEFAULT_PREFIX
  this.version = parseInt(opts.version || 1, 10)
}

inherits(Level, AbstractLevelDOWN)

// Detect binary and array key support (IndexedDB Second Edition)
Level.binaryKeys = support.binaryKeys(indexedDB)
Level.arrayKeys = support.arrayKeys(indexedDB)

Level.prototype._open = function (options, callback) {
  var req = indexedDB.open(this.prefix + this.location, this.version)
  var self = this

  req.onerror = function () {
    callback(req.error || new Error('unknown error'))
  }

  req.onsuccess = function () {
    self.db = req.result
    callback()
  }

  req.onupgradeneeded = function (ev) {
    var db = ev.target.result

    if (!db.objectStoreNames.contains(self.location)) {
      db.createObjectStore(self.location)
    }
  }
}

Level.prototype.store = function (mode) {
  var transaction = this.db.transaction([this.location], mode)
  return transaction.objectStore(this.location)
}

Level.prototype.await = function (request, callback) {
  var transaction = request.transaction

  // Take advantage of the fact that a non-canceled request error aborts
  // the transaction. I.e. no need to listen for "request.onerror".
  transaction.onabort = function () {
    callback(transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback(null, request.result)
  }
}

Level.prototype._get = function (key, options, callback) {
  var store = this.store('readonly')

  try {
    var req = store.get(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, function (err, value) {
    if (err) return callback(err)

    if (value === undefined) {
      // 'NotFound' error, consistent with LevelDOWN API
      return callback(new Error('NotFound'))
    }

    if (options.asBuffer) {
      value = mixedToBuffer(value)
    }

    callback(null, value)
  })
}

Level.prototype._del = function (key, options, callback) {
  var store = this.store('readwrite')

  try {
    var req = store.delete(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

Level.prototype._put = function (key, value, options, callback) {
  var store = this.store('readwrite')

  try {
    // Will throw a DataError or DataCloneError if the environment
    // does not support serializing the key or value respectively.
    var req = store.put(value, key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

// Valid key types in IndexedDB Second Edition:
//
// - Number, except NaN. Includes Infinity and -Infinity
// - Date, except invalid (NaN)
// - String
// - ArrayBuffer or a view thereof (typed arrays). In level-js we also support
//   Buffer (which is an Uint8Array) (and the primary binary type of Level).
// - Array, except cyclical and empty (e.g. Array(10)). Elements must be valid
//   types themselves.
Level.prototype._serializeKey = function (key) {
  if (Buffer.isBuffer(key)) {
    return Level.binaryKeys ? key : key.toString()
  } else if (Array.isArray(key)) {
    return Level.arrayKeys ? key.map(this._serializeKey, this) : String(key)
  } else {
    return key
  }
}

Level.prototype._serializeValue = function (value) {
  return value
}

Level.prototype._iterator = function (options) {
  return new Iterator(this, this.location, options)
}

Level.prototype._batch = function (operations, options, callback) {
  if (operations.length === 0) return setImmediate(callback)

  var store = this.store('readwrite')
  var transaction = store.transaction
  var index = 0
  var error

  transaction.onabort = function () {
    callback(error || transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback()
  }

  // Wait for a request to complete before making the next, saving CPU.
  function loop () {
    var op = operations[index++]
    var key = op.key

    try {
      var req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)
    } catch (err) {
      error = err
      transaction.abort()
      return
    }

    if (index < operations.length) {
      req.onsuccess = loop
    }
  }

  loop()
}

Level.prototype._close = function (callback) {
  this.db.close()
  setImmediate(callback)
}

Level.destroy = function (location, prefix, callback) {
  if (typeof prefix === 'function') {
    callback = prefix
    prefix = DEFAULT_PREFIX
  }
  var request = indexedDB.deleteDatabase(prefix + location)
  request.onsuccess = function () {
    callback()
  }
  request.onerror = function (err) {
    callback(err)
  }
}

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})

      };
    };
  }
}, {package:"level-js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\level-js\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\src\\keystore.js", {"./verifiers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\src\\verifiers\\index.js","levelup":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\levelup\\lib\\levelup.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js","lru":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lru\\index.js","safe-buffer/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\orbit-db-keystore\src\keystore.js
      return function (require, module, exports) {
'use strict'
const levelup = require('levelup')
const crypto = require('libp2p-crypto')
const secp256k1 = require('secp256k1')
const LRU = require('lru')
const Buffer = require('safe-buffer/').Buffer
const { verifier } = require('./verifiers')

class Keystore {
  constructor (storage, directory) {
    this.path = directory || './orbitdb'
    this._storage = storage
    this._store = null
    this._cache = new LRU(100)
  }

  async open () {
    if (this.store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      const store = levelup(this._storage(this.path))
      store.open((err) => {
        if (err) {
          return reject(err)
        }
        this._store = store
        resolve()
      })
    })
  }

  async close () {
    if (!this._store) {
      return Promise.resolve()
    }

    return new Promise((resolve, reject) => {
      this._store.close((err) => {
        if (err) {
          return reject(err)
        }
        this._store = null
        resolve()
      })
    })
  }

  async destroy () {
    return new Promise((resolve, reject) => {
      this._storage.destroy(this.path, (err) => {
        if (err) {
          return reject(err)
        }
        resolve()
      })
    })
  }

  async hasKey (id) {
    if (!id) {
      throw new Error('id needed to check a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    let hasKey = false
    try {
      let storedKey = this._cache.get(id) || await this._store.get(id)
      hasKey = storedKey !== undefined && storedKey !== null
    } catch (e) {
      // Catches 'Error: ENOENT: no such file or directory, open <path>'
      console.error('Error: ENOENT: no such file or directory')
    }
    await this.close()

    return hasKey
  }

  async createKey (id) {
    if (!id) {
      throw new Error('id needed to create a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    const genKeyPair = () => new Promise((resolve, reject) => {
      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {
        if (!err) {
          resolve(key)
        }
        reject(err)
      })
    })

    const keys = await genKeyPair()
    const decompressedKey = secp256k1.publicKeyConvert(keys.public.marshal(), false)
    const key = {
      publicKey: decompressedKey.toString('hex'),
      privateKey: keys.marshal().toString('hex')
    }

    try {
      await this._store.put(id, JSON.stringify(key))
    } catch (e) {
      console.log(e)
    }
    await this.close()
    this._cache.set(id, key)

    return keys
  }

  async getKey (id) {
    if (!id) {
      throw new Error('id needed to get a key')
    }
    if (!this._store) {
      await this.open()
    }
    if (this._store.status && this._store.status !== 'open') {
      return Promise.resolve(null)
    }

    const cachedKey = this._cache.get(id)
    let storedKey
    try {
      storedKey = cachedKey || await this._store.get(id)
    } catch (e) {
      // ignore ENOENT error
    }
    await this.close()

    if (!storedKey) {
      return
    }

    const deserializedKey = cachedKey || JSON.parse(storedKey)
    if (!deserializedKey) {
      return
    }

    if (!cachedKey) {
      this._cache.set(id, deserializedKey)
    }


    const genPrivKey = (pk) => new Promise((resolve, reject) => {
      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {
        if (!err) {
          resolve(key)
        }
        reject(err)
      })
    })

    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'))
  }

  async sign (key, data) {
    if (!key) {
      throw new Error('No signing key given')
    }

    if (!data) {
      throw new Error('Given input data was undefined')
    }

    if (!Buffer.isBuffer(data)) {
      data = Buffer.from(data)
    }

    return new Promise((resolve, reject) => {
      key.sign(data, (err, signature) => {
        if (!err) {
          resolve(signature.toString('hex'))
        }
        reject(err)
      })
    })
  }

  getPublic(keys, options = {}) {
    const formats = ['hex', 'buffer']
    const decompress = options.decompress || true
    const format = formats[options.format || 'hex']
    let pubKey = keys.public.marshal()
    if (decompress) {
      pubKey = secp256k1.publicKeyConvert(pubKey, false)
    }
    return format === 'buffer' ? pubKey : pubKey.toString('hex')
  }

  async verify (signature, publicKey, data, v = 'v1') {
    return Keystore.verify(signature, publicKey, data, v)
  }

  static async verify (signature, publicKey, data, v = 'v1') {
    return verifier(v).verify(signature, publicKey, data)
  }
}

module.exports = (storage, mkdir) => {
  return {
    create: (directory = './keystore') => {
      // If we're in Node.js, mkdir module is expected to passed
      // and we need to make sure the directory exists
      if (mkdir && mkdir.sync) {
        mkdir.sync(directory)
      }

      return new Keystore(storage, directory)
    },
    verify: Keystore.verify
  }
}

      };
    };
  }
}, {package:"orbit-db-keystore",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\orbit-db-keystore\\src\\keystore.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js", {"multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\mafmt\src\index.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')

/*
 * Valid combinations
 */
const DNS4 = base('dns4')
const DNS6 = base('dns6')
const _DNS = or(
  base('dnsaddr'),
  DNS4,
  DNS6
)

const IP = or(base('ip4'), base('ip6'))
const TCP = or(
  and(IP, base('tcp')),
  and(_DNS, base('tcp'))
)
const UDP = and(IP, base('udp'))
const UTP = and(UDP, base('utp'))

const DNS = or(
  and(_DNS, base('tcp')),
  _DNS
)

const WebSockets = or(
  and(TCP, base('ws')),
  and(DNS, base('ws'))
)

const WebSocketsSecure = or(
  and(TCP, base('wss')),
  and(DNS, base('wss'))
)

const HTTP = or(
  and(TCP, base('http')),
  and(IP, base('http')),
  and(DNS, base('http')),
  and(DNS)
)

const HTTPS = or(
  and(TCP, base('https')),
  and(IP, base('https')),
  and(DNS, base('https'))
)

const WebRTCStar = or(
  and(WebSockets, base('p2p-webrtc-star'), base('ipfs')),
  and(WebSocketsSecure, base('p2p-webrtc-star'), base('ipfs'))
)

const WebSocketStar = or(
  and(WebSockets, base('p2p-websocket-star'), base('ipfs')),
  and(WebSocketsSecure, base('p2p-websocket-star'), base('ipfs')),
  and(WebSockets, base('p2p-websocket-star')),
  and(WebSocketsSecure, base('p2p-websocket-star'))
)

const WebRTCDirect = or(
  and(HTTP, base('p2p-webrtc-direct')),
  and(HTTPS, base('p2p-webrtc-direct'))
)

const Reliable = or(
  WebSockets,
  WebSocketsSecure,
  HTTP,
  HTTPS,
  WebRTCStar,
  WebRTCDirect,
  TCP,
  UTP
)

// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )
const Stardust = or(
  and(Reliable, base('p2p-stardust'), base('ipfs')),
  and(Reliable, base('p2p-stardust'))
)

let _IPFS = or(
  and(Reliable, base('ipfs')),
  WebRTCStar,
  base('ipfs')
)

const _Circuit = or(
  and(_IPFS, base('p2p-circuit'), _IPFS),
  and(_IPFS, base('p2p-circuit')),
  and(base('p2p-circuit'), _IPFS),
  and(Reliable, base('p2p-circuit')),
  and(base('p2p-circuit'), Reliable),
  base('p2p-circuit')
)

const CircuitRecursive = () => or(
  and(_Circuit, CircuitRecursive),
  _Circuit
)

const Circuit = CircuitRecursive()

const IPFS = or(
  and(Circuit, _IPFS, Circuit),
  and(_IPFS, Circuit),
  and(Circuit, _IPFS),
  Circuit,
  _IPFS
)

exports.DNS = DNS
exports.DNS4 = DNS4
exports.DNS6 = DNS6
exports.IP = IP
exports.TCP = TCP
exports.UDP = UDP
exports.UTP = UTP
exports.HTTP = HTTP
exports.HTTPS = HTTPS
exports.WebSockets = WebSockets
exports.WebSocketsSecure = WebSocketsSecure
exports.WebSocketStar = WebSocketStar
exports.WebRTCStar = WebRTCStar
exports.WebRTCDirect = WebRTCDirect
exports.Reliable = Reliable
exports.Stardust = Stardust
exports.Circuit = Circuit
exports.IPFS = IPFS

/*
 * Validation funcs
 */

function makeMatchesFunction (partialMatch) {
  return function matches (a) {
    if (!multiaddr.isMultiaddr(a)) {
      try {
        a = multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's propably not matching as well so return false
      }
    }
    let out = partialMatch(a.protoNames())
    if (out === null) {
      return false
    }
    return out.length === 0
  }
}

function and () {
  const args = Array.from(arguments)
  function partialMatch (a) {
    if (a.length < args.length) {
      return null
    }
    args.some((arg) => {
      a = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)

      if (a === null) {
        return true
      }
    })

    return a
  }

  return {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }
}

function or () {
  const args = Array.from(arguments)

  function partialMatch (a) {
    let out = null
    args.some((arg) => {
      const res = typeof arg === 'function'
        ? arg().partialMatch(a)
        : arg.partialMatch(a)
      if (res) {
        out = res
        return true
      }
    })

    return out
  }

  const result = {
    toString: function () { return '{ ' + args.join(' ') + ' }' },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch: partialMatch
  }

  return result
}

function base (n) {
  const name = n

  function matches (a) {
    if (typeof a === 'string') {
      try {
        a = multiaddr(a)
      } catch (err) { // catch error
        return false // also if it's invalid it's propably not matching as well so return false
      }
    }

    const pnames = a.protoNames()
    if (pnames.length === 1 && pnames[0] === name) {
      return true
    }
    return false
  }

  function partialMatch (protos) {
    if (protos.length === 0) {
      return null
    }

    if (protos[0] === name) {
      return protos.slice(1)
    }
    return null
  }

  return {
    toString: function () { return name },
    matches: matches,
    partialMatch: partialMatch
  }
}

      };
    };
  }
}, {package:"mafmt",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-plain-obj\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\is-plain-obj\index.js
      return function (require, module, exports) {
'use strict';
var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

      };
    };
  }
}, {package:"is-plain-obj",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-plain-obj\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\index.js", {"./api-addr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\api-addr.js","./backends":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\backends.js","./blockstore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\blockstore.js","./config":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\config.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\constants.js","./default-datastore":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\default-datastore.js","./default-options":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\default-options-browser.js","./errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\errors\\index.js","./lock":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\lock-memory.js","./lock-memory":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\lock-memory.js","./spec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\spec.js","./version":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\version.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","async/each":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\each.js","async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","async/series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\series.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\node_modules\\bignumber.js\\bignumber.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","dlv":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\dlv\\dist\\dlv.umd.js","path":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\path-browserify\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/reduce":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\reduce.js","timers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-repo\src\index.js
      return function (require, module, exports) {
(function (setImmediate){(function (){
'use strict'

const waterfall = require('async/waterfall')
const series = require('async/series')
const parallel = require('async/parallel')
const each = require('async/each')
const _get = require('dlv')
const assert = require('assert')
const path = require('path')
const debug = require('debug')
const Big = require('bignumber.js')
const pull = require('pull-stream/pull')
const reduce = require('pull-stream/sinks/reduce')

const backends = require('./backends')
const version = require('./version')
const config = require('./config')
const spec = require('./spec')
const apiAddr = require('./api-addr')
const blockstore = require('./blockstore')
const defaultOptions = require('./default-options')
const defaultDatastore = require('./default-datastore')
const ERRORS = require('./errors')

const log = debug('repo')

const noLimit = Number.MAX_SAFE_INTEGER

const lockers = {
  memory: require('./lock-memory'),
  fs: require('./lock')
}

const repoVersion = require('./constants').repoVersion

/**
 * IpfsRepo implements all required functionality to read and write to an ipfs repo.
 *
 */
class IpfsRepo {
  /**
   * @param {string} repoPath - path where the repo is stored
   * @param {object} options - Configuration
   */
  constructor (repoPath, options) {
    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath')

    this.options = buildOptions(options)
    this.closed = true
    this.path = repoPath

    this._locker = this._getLocker()

    this.root = backends.create('root', this.path, this.options)
    this.version = version(this.root)
    this.config = config(this.root)
    this.spec = spec(this.root)
    this.apiAddr = apiAddr(this.root)
  }

  /**
   * Initialize a new repo.
   *
   * @param {Object} config - config to write into `config`.
   * @param {function(Error)} callback
   * @returns {void}
   */
  init (config, callback) {
    log('initializing at: %s', this.path)

    series([
      (cb) => this.root.open(ignoringAlreadyOpened(cb)),
      (cb) => this.config.set(buildConfig(config), cb),
      (cb) => this.spec.set(buildDatastoreSpec(config), cb),
      (cb) => this.version.set(repoVersion, cb)
    ], callback)
  }

  /**
   * Open the repo. If the repo is already open no action will be taken.
   * If the repo is not initialized it will return an error.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  open (callback) {
    if (!this.closed) {
      setImmediate(() => callback(new Error('repo is already open')))
      return // early
    }
    log('opening at: %s', this.path)

    // check if the repo is already initialized
    waterfall([
      (cb) => this.root.open(ignoringAlreadyOpened(cb)),
      (cb) => this._isInitialized(cb),
      (cb) => this._openLock(this.path, cb),
      (lck, cb) => {
        log('aquired repo.lock')
        this.lockfile = lck
        cb()
      },
      (cb) => {
        log('creating datastore')
        this.datastore = backends.create('datastore', path.join(this.path, 'datastore'), this.options)
        log('creating blocks')
        const blocksBaseStore = backends.create('blocks', path.join(this.path, 'blocks'), this.options)
        blockstore(
          blocksBaseStore,
          this.options.storageBackendOptions.blocks,
          cb)
      },
      (blocks, cb) => {
        this.blocks = blocks
        cb()
      },
      (cb) => {
        log('creating keystore')
        this.keys = backends.create('keys', path.join(this.path, 'keys'), this.options)
        cb()
      },

      (cb) => {
        this.closed = false
        log('all opened')
        cb()
      }
    ], (err) => {
      if (err && this.lockfile) {
        this._closeLock((err2) => {
          if (!err2) {
            this.lockfile = null
          } else {
            log('error removing lock', err2)
          }
          callback(err)
        })
      } else {
        callback(err)
      }
    })
  }

  /**
   * Returns the repo locker to be used. Null will be returned if no locker is requested
   *
   * @private
   * @returns {Locker}
   */
  _getLocker () {
    if (typeof this.options.lock === 'string') {
      assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock)
      return lockers[this.options.lock]
    }

    assert(this.options.lock, 'No lock provided')
    return this.options.lock
  }

  /**
   * Creates a lock on the repo if a locker is specified. The lockfile object will
   * be returned in the callback if one has been created.
   *
   * @param {string} path
   * @param {function(Error, lockfile)} callback
   * @returns {void}
   */
  _openLock (path, callback) {
    this._locker.lock(path, (err, lockfile) => {
      if (err) {
        return callback(err, null)
      }

      assert.strictEqual(typeof lockfile.close, 'function', 'Locks must have a close method')
      callback(null, lockfile)
    })
  }

  /**
   * Closes the lock on the repo
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  _closeLock (callback) {
    if (this.lockfile) {
      return this.lockfile.close(callback)
    }
    callback()
  }

  /**
   * Check if the repo is already initialized.
   *
   * @private
   * @param {function(Error)} callback
   * @returns {void}
   */
  _isInitialized (callback) {
    log('init check')
    parallel(
      {
        config: (cb) => this.config.exists(cb),
        spec: (cb) => this.spec.exists(cb),
        version: (cb) => this.version.check(repoVersion, cb)
      },
      (err, res) => {
        log('init', err, res)
        if (err && !res.config) {
          return callback(Object.assign(new Error('repo is not initialized yet'),
            {
              code: ERRORS.ERR_REPO_NOT_INITIALIZED,
              path: this.path
            }))
        }
        callback(err)
      }
    )
  }

  /**
   * Close the repo and cleanup.
   *
   * @param {function(Error)} callback
   * @returns {void}
   */
  close (callback) {
    if (this.closed) {
      return callback(new Error('repo is already closed'))
    }

    log('closing at: %s', this.path)
    series([
      (cb) => this.apiAddr.delete(ignoringNotFound(cb)),
      (cb) => {
        each(
          [this.blocks, this.keys, this.datastore],
          (store, callback) => store.close(callback),
          cb)
      },
      (cb) => {
        log('unlocking')
        this.closed = true
        this._closeLock(cb)
      },
      (cb) => {
        this.lockfile = null
        cb()
      }
    ], (err) => callback(err))
  }

  /**
   * Check if a repo exists.
   *
   * @param {function(Error, bool)} callback
   * @returns {void}
   */
  exists (callback) {
    this.version.exists(callback)
  }

  /**
   * Get repo status.
   *
   * @param {Object}  options
   * @param {Boolean} options.human
   * @param {function(Error, Object)} callback
   * @return {void}
   */
  stat (options, callback) {
    if (typeof options === 'function') {
      callback = options
      options = {}
    }

    options = Object.assign({}, { human: false }, options)

    parallel({
      storageMax: (cb) => this.config.get('Datastore.StorageMax', (err, max) => {
        if (err) {
          cb(null, new Big(noLimit))
        } else {
          cb(null, new Big(max))
        }
      }),
      version: (cb) => this.version.get(cb),
      blocks: (cb) => this.blocks.query({}, (err, list) => {
        list = list || []

        const count = new Big(list.length)
        let size = new Big(0)

        list.forEach(block => {
          size = size
            .plus(block.value.byteLength)
            .plus(block.key._buf.byteLength)
        })

        cb(err, {
          count: count,
          size: size
        })
      }),
      datastore: (cb) => getSize(this.datastore, cb),
      keys: (cb) => getSize(this.keys, cb)
    }, (err, results) => {
      if (err) return callback(err)

      let size = results.blocks.size
        .plus(results.datastore)
        .plus(results.keys)

      if (options.human) {
        size = size.div(1048576)
      }

      callback(null, {
        repoPath: this.path,
        storageMax: results.storageMax,
        version: results.version,
        numObjects: results.blocks.count,
        repoSize: size
      })
    })
  }
}

function getSize (queryFn, callback) {
  pull(
    queryFn.query({}),
    reduce((sum, block) => {
      return sum
        .plus(block.value.byteLength)
        .plus(block.key._buf.byteLength)
    }, new Big(0), callback))
}

module.exports = IpfsRepo
module.exports.repoVersion = repoVersion
module.exports.errors = ERRORS

function ignoringIf (cond, cb) {
  return (err) => {
    cb(err && !cond(err) ? err : null)
  }
}
function ignoringAlreadyOpened (cb) {
  return ignoringIf((err) => err.message === 'Already open', cb)
}

function ignoringNotFound (cb) {
  return ignoringIf((err) => {
    return err && (err.code === ERRORS.ERR_REPO_NOT_INITIALIZED || err.message.startsWith('ENOENT'))
  }, cb)
}

function buildOptions (_options) {
  const options = Object.assign({}, defaultOptions, _options)

  options.storageBackends = Object.assign(
    {},
    defaultOptions.storageBackends,
    options.storageBackends)

  options.storageBackendOptions = Object.assign(
    {},
    defaultOptions.storageBackendOptions,
    options.storageBackendOptions)

  return options
}

// TODO this should come from js-ipfs instead
function buildConfig (_config) {
  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))

  return _config
}

function buildDatastoreSpec (_config) {
  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))

  return {
    type: spec.type,
    mounts: spec.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  }
}

}).call(this)}).call(this,require("timers").setImmediate)

      };
    };
  }
}, {package:"ipfs-repo",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-repo\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js", {"./internal/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\internal\\setImmediate.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\async\setImmediate.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setImmediate = require('./internal/setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `setImmediate`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name setImmediate
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.nextTick]{@link module:Utils.nextTick}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
exports.default = _setImmediate2.default;
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm-event\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","fsm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\fsm-event\index.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const assert = require('assert')
const fsm = require('fsm')

module.exports = fsmEvent

// create an fsmEvent instance
// obj -> fn
function fsmEvent (start, events) {
  if (typeof start === 'object') {
    events = start
    start = 'START'
  }
  assert.equal(typeof start, 'string')
  assert.equal(typeof events, 'object')
  assert.ok(events[start], 'invalid starting state ' + start)
  assert.ok(fsm.validate(events))

  const emitter = new EventEmitter()
  emit._graph = fsm.reachable(events)
  emit._emitter = emitter
  emit._events = events
  emit._state = start
  emit.emit = emit
  emit.on = on

  return emit

  // set a state listener
  // str, fn -> null
  function on (event, cb) {
    emitter.on(event, cb)
  }

  // change the state
  // str -> null
  function emit (str) {
    const nwState = emit._events[emit._state][str]
    if (!reach(emit._state, nwState, emit._graph)) {
      const err = 'invalid transition: ' + emit._state + ' -> ' + str
      return emitter.emit('error', err)
    }

    const leaveEv = emit._state + ':leave'
    const enterEv = nwState + ':enter'

    if (!emit._state) return enter()
    return leave()

    function leave () {
      if (!emitter._events[leaveEv]) enter()
      else emitter.emit(leaveEv, enter)
    }

    function enter () {
      if (!emitter._events[enterEv]) done()
      else emitter.emit(enterEv, done)
    }

    function done () {
      emit._state = nwState
      emitter.emit(nwState)
      emitter.emit('done')
    }
  }
}

// check if state can reach in reach
// str, str, obj -> bool
function reach (curr, next, reachable) {
  if (!next) return false
  if (!curr) return true

  const here = reachable[curr]
  if (!here || !here[next]) return false
  return here[next].length === 1
}

      };
    };
  }
}, {package:"fsm-event",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm-event\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\print.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\print.js
      return function (require, module, exports) {
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'
module.exports = Object.freeze({

  // serialization
  0x50: 'protobuf',
  0x51: 'cbor',
  0x60: 'rlp',
  0x63: 'bencode',
  0x0200: 'json',
  0x0201: 'messagepack',

  // multiformat
  0x30: 'multicodec',
  0x31: 'multihash',
  0x32: 'multiaddr',
  0x33: 'multibase',

  // multihash
  0x00: 'identity',
  0x11: 'sha1',
  0x12: 'sha2-256',
  0x13: 'sha2-512',
  0x14: 'sha3-512',
  0x15: 'sha3-384',
  0x16: 'sha3-256',
  0x17: 'sha3-224',
  0x18: 'shake-128',
  0x19: 'shake-256',
  0x1a: 'keccak-224',
  0x1b: 'keccak-256',
  0x1c: 'keccak-384',
  0x1d: 'keccak-512',
  0x22: 'murmur3-128',
  0x23: 'murmur3-32',
  0x56: 'dbl-sha2-256',
  0xd4: 'md4',
  0xd5: 'md5',
  0xd6: 'bmt',
  0x1100: 'x11',
  0xb201: 'blake2b-8',
  0xb202: 'blake2b-16',
  0xb203: 'blake2b-24',
  0xb204: 'blake2b-32',
  0xb205: 'blake2b-40',
  0xb206: 'blake2b-48',
  0xb207: 'blake2b-56',
  0xb208: 'blake2b-64',
  0xb209: 'blake2b-72',
  0xb20a: 'blake2b-80',
  0xb20b: 'blake2b-88',
  0xb20c: 'blake2b-96',
  0xb20d: 'blake2b-104',
  0xb20e: 'blake2b-112',
  0xb20f: 'blake2b-120',
  0xb210: 'blake2b-128',
  0xb211: 'blake2b-136',
  0xb212: 'blake2b-144',
  0xb213: 'blake2b-152',
  0xb214: 'blake2b-160',
  0xb215: 'blake2b-168',
  0xb216: 'blake2b-176',
  0xb217: 'blake2b-184',
  0xb218: 'blake2b-192',
  0xb219: 'blake2b-200',
  0xb21a: 'blake2b-208',
  0xb21b: 'blake2b-216',
  0xb21c: 'blake2b-224',
  0xb21d: 'blake2b-232',
  0xb21e: 'blake2b-240',
  0xb21f: 'blake2b-248',
  0xb220: 'blake2b-256',
  0xb221: 'blake2b-264',
  0xb222: 'blake2b-272',
  0xb223: 'blake2b-280',
  0xb224: 'blake2b-288',
  0xb225: 'blake2b-296',
  0xb226: 'blake2b-304',
  0xb227: 'blake2b-312',
  0xb228: 'blake2b-320',
  0xb229: 'blake2b-328',
  0xb22a: 'blake2b-336',
  0xb22b: 'blake2b-344',
  0xb22c: 'blake2b-352',
  0xb22d: 'blake2b-360',
  0xb22e: 'blake2b-368',
  0xb22f: 'blake2b-376',
  0xb230: 'blake2b-384',
  0xb231: 'blake2b-392',
  0xb232: 'blake2b-400',
  0xb233: 'blake2b-408',
  0xb234: 'blake2b-416',
  0xb235: 'blake2b-424',
  0xb236: 'blake2b-432',
  0xb237: 'blake2b-440',
  0xb238: 'blake2b-448',
  0xb239: 'blake2b-456',
  0xb23a: 'blake2b-464',
  0xb23b: 'blake2b-472',
  0xb23c: 'blake2b-480',
  0xb23d: 'blake2b-488',
  0xb23e: 'blake2b-496',
  0xb23f: 'blake2b-504',
  0xb240: 'blake2b-512',
  0xb241: 'blake2s-8',
  0xb242: 'blake2s-16',
  0xb243: 'blake2s-24',
  0xb244: 'blake2s-32',
  0xb245: 'blake2s-40',
  0xb246: 'blake2s-48',
  0xb247: 'blake2s-56',
  0xb248: 'blake2s-64',
  0xb249: 'blake2s-72',
  0xb24a: 'blake2s-80',
  0xb24b: 'blake2s-88',
  0xb24c: 'blake2s-96',
  0xb24d: 'blake2s-104',
  0xb24e: 'blake2s-112',
  0xb24f: 'blake2s-120',
  0xb250: 'blake2s-128',
  0xb251: 'blake2s-136',
  0xb252: 'blake2s-144',
  0xb253: 'blake2s-152',
  0xb254: 'blake2s-160',
  0xb255: 'blake2s-168',
  0xb256: 'blake2s-176',
  0xb257: 'blake2s-184',
  0xb258: 'blake2s-192',
  0xb259: 'blake2s-200',
  0xb25a: 'blake2s-208',
  0xb25b: 'blake2s-216',
  0xb25c: 'blake2s-224',
  0xb25d: 'blake2s-232',
  0xb25e: 'blake2s-240',
  0xb25f: 'blake2s-248',
  0xb260: 'blake2s-256',
  0xb301: 'skein256-8',
  0xb302: 'skein256-16',
  0xb303: 'skein256-24',
  0xb304: 'skein256-32',
  0xb305: 'skein256-40',
  0xb306: 'skein256-48',
  0xb307: 'skein256-56',
  0xb308: 'skein256-64',
  0xb309: 'skein256-72',
  0xb30a: 'skein256-80',
  0xb30b: 'skein256-88',
  0xb30c: 'skein256-96',
  0xb30d: 'skein256-104',
  0xb30e: 'skein256-112',
  0xb30f: 'skein256-120',
  0xb310: 'skein256-128',
  0xb311: 'skein256-136',
  0xb312: 'skein256-144',
  0xb313: 'skein256-152',
  0xb314: 'skein256-160',
  0xb315: 'skein256-168',
  0xb316: 'skein256-176',
  0xb317: 'skein256-184',
  0xb318: 'skein256-192',
  0xb319: 'skein256-200',
  0xb31a: 'skein256-208',
  0xb31b: 'skein256-216',
  0xb31c: 'skein256-224',
  0xb31d: 'skein256-232',
  0xb31e: 'skein256-240',
  0xb31f: 'skein256-248',
  0xb320: 'skein256-256',
  0xb321: 'skein512-8',
  0xb322: 'skein512-16',
  0xb323: 'skein512-24',
  0xb324: 'skein512-32',
  0xb325: 'skein512-40',
  0xb326: 'skein512-48',
  0xb327: 'skein512-56',
  0xb328: 'skein512-64',
  0xb329: 'skein512-72',
  0xb32a: 'skein512-80',
  0xb32b: 'skein512-88',
  0xb32c: 'skein512-96',
  0xb32d: 'skein512-104',
  0xb32e: 'skein512-112',
  0xb32f: 'skein512-120',
  0xb330: 'skein512-128',
  0xb331: 'skein512-136',
  0xb332: 'skein512-144',
  0xb333: 'skein512-152',
  0xb334: 'skein512-160',
  0xb335: 'skein512-168',
  0xb336: 'skein512-176',
  0xb337: 'skein512-184',
  0xb338: 'skein512-192',
  0xb339: 'skein512-200',
  0xb33a: 'skein512-208',
  0xb33b: 'skein512-216',
  0xb33c: 'skein512-224',
  0xb33d: 'skein512-232',
  0xb33e: 'skein512-240',
  0xb33f: 'skein512-248',
  0xb340: 'skein512-256',
  0xb341: 'skein512-264',
  0xb342: 'skein512-272',
  0xb343: 'skein512-280',
  0xb344: 'skein512-288',
  0xb345: 'skein512-296',
  0xb346: 'skein512-304',
  0xb347: 'skein512-312',
  0xb348: 'skein512-320',
  0xb349: 'skein512-328',
  0xb34a: 'skein512-336',
  0xb34b: 'skein512-344',
  0xb34c: 'skein512-352',
  0xb34d: 'skein512-360',
  0xb34e: 'skein512-368',
  0xb34f: 'skein512-376',
  0xb350: 'skein512-384',
  0xb351: 'skein512-392',
  0xb352: 'skein512-400',
  0xb353: 'skein512-408',
  0xb354: 'skein512-416',
  0xb355: 'skein512-424',
  0xb356: 'skein512-432',
  0xb357: 'skein512-440',
  0xb358: 'skein512-448',
  0xb359: 'skein512-456',
  0xb35a: 'skein512-464',
  0xb35b: 'skein512-472',
  0xb35c: 'skein512-480',
  0xb35d: 'skein512-488',
  0xb35e: 'skein512-496',
  0xb35f: 'skein512-504',
  0xb360: 'skein512-512',
  0xb361: 'skein1024-8',
  0xb362: 'skein1024-16',
  0xb363: 'skein1024-24',
  0xb364: 'skein1024-32',
  0xb365: 'skein1024-40',
  0xb366: 'skein1024-48',
  0xb367: 'skein1024-56',
  0xb368: 'skein1024-64',
  0xb369: 'skein1024-72',
  0xb36a: 'skein1024-80',
  0xb36b: 'skein1024-88',
  0xb36c: 'skein1024-96',
  0xb36d: 'skein1024-104',
  0xb36e: 'skein1024-112',
  0xb36f: 'skein1024-120',
  0xb370: 'skein1024-128',
  0xb371: 'skein1024-136',
  0xb372: 'skein1024-144',
  0xb373: 'skein1024-152',
  0xb374: 'skein1024-160',
  0xb375: 'skein1024-168',
  0xb376: 'skein1024-176',
  0xb377: 'skein1024-184',
  0xb378: 'skein1024-192',
  0xb379: 'skein1024-200',
  0xb37a: 'skein1024-208',
  0xb37b: 'skein1024-216',
  0xb37c: 'skein1024-224',
  0xb37d: 'skein1024-232',
  0xb37e: 'skein1024-240',
  0xb37f: 'skein1024-248',
  0xb380: 'skein1024-256',
  0xb381: 'skein1024-264',
  0xb382: 'skein1024-272',
  0xb383: 'skein1024-280',
  0xb384: 'skein1024-288',
  0xb385: 'skein1024-296',
  0xb386: 'skein1024-304',
  0xb387: 'skein1024-312',
  0xb388: 'skein1024-320',
  0xb389: 'skein1024-328',
  0xb38a: 'skein1024-336',
  0xb38b: 'skein1024-344',
  0xb38c: 'skein1024-352',
  0xb38d: 'skein1024-360',
  0xb38e: 'skein1024-368',
  0xb38f: 'skein1024-376',
  0xb390: 'skein1024-384',
  0xb391: 'skein1024-392',
  0xb392: 'skein1024-400',
  0xb393: 'skein1024-408',
  0xb394: 'skein1024-416',
  0xb395: 'skein1024-424',
  0xb396: 'skein1024-432',
  0xb397: 'skein1024-440',
  0xb398: 'skein1024-448',
  0xb399: 'skein1024-456',
  0xb39a: 'skein1024-464',
  0xb39b: 'skein1024-472',
  0xb39c: 'skein1024-480',
  0xb39d: 'skein1024-488',
  0xb39e: 'skein1024-496',
  0xb39f: 'skein1024-504',
  0xb3a0: 'skein1024-512',
  0xb3a1: 'skein1024-520',
  0xb3a2: 'skein1024-528',
  0xb3a3: 'skein1024-536',
  0xb3a4: 'skein1024-544',
  0xb3a5: 'skein1024-552',
  0xb3a6: 'skein1024-560',
  0xb3a7: 'skein1024-568',
  0xb3a8: 'skein1024-576',
  0xb3a9: 'skein1024-584',
  0xb3aa: 'skein1024-592',
  0xb3ab: 'skein1024-600',
  0xb3ac: 'skein1024-608',
  0xb3ad: 'skein1024-616',
  0xb3ae: 'skein1024-624',
  0xb3af: 'skein1024-632',
  0xb3b0: 'skein1024-640',
  0xb3b1: 'skein1024-648',
  0xb3b2: 'skein1024-656',
  0xb3b3: 'skein1024-664',
  0xb3b4: 'skein1024-672',
  0xb3b5: 'skein1024-680',
  0xb3b6: 'skein1024-688',
  0xb3b7: 'skein1024-696',
  0xb3b8: 'skein1024-704',
  0xb3b9: 'skein1024-712',
  0xb3ba: 'skein1024-720',
  0xb3bb: 'skein1024-728',
  0xb3bc: 'skein1024-736',
  0xb3bd: 'skein1024-744',
  0xb3be: 'skein1024-752',
  0xb3bf: 'skein1024-760',
  0xb3c0: 'skein1024-768',
  0xb3c1: 'skein1024-776',
  0xb3c2: 'skein1024-784',
  0xb3c3: 'skein1024-792',
  0xb3c4: 'skein1024-800',
  0xb3c5: 'skein1024-808',
  0xb3c6: 'skein1024-816',
  0xb3c7: 'skein1024-824',
  0xb3c8: 'skein1024-832',
  0xb3c9: 'skein1024-840',
  0xb3ca: 'skein1024-848',
  0xb3cb: 'skein1024-856',
  0xb3cc: 'skein1024-864',
  0xb3cd: 'skein1024-872',
  0xb3ce: 'skein1024-880',
  0xb3cf: 'skein1024-888',
  0xb3d0: 'skein1024-896',
  0xb3d1: 'skein1024-904',
  0xb3d2: 'skein1024-912',
  0xb3d3: 'skein1024-920',
  0xb3d4: 'skein1024-928',
  0xb3d5: 'skein1024-936',
  0xb3d6: 'skein1024-944',
  0xb3d7: 'skein1024-952',
  0xb3d8: 'skein1024-960',
  0xb3d9: 'skein1024-968',
  0xb3da: 'skein1024-976',
  0xb3db: 'skein1024-984',
  0xb3dc: 'skein1024-992',
  0xb3dd: 'skein1024-1000',
  0xb3de: 'skein1024-1008',
  0xb3df: 'skein1024-1016',
  0xb3e0: 'skein1024-1024',

  // multiaddr
  0x04: 'ip4',
  0x06: 'tcp',
  0x21: 'dccp',
  0x29: 'ip6',
  0x2a: 'ip6zone',
  0x35: 'dns',
  0x36: 'dns4',
  0x37: 'dns6',
  0x38: 'dnsaddr',
  0x84: 'sctp',
  0x0111: 'udp',
  0x0113: 'p2p-webrtc-star',
  0x0114: 'p2p-webrtc-direct',
  0x0115: 'p2p-stardust',
  0x0122: 'p2p-circuit',
  0x012d: 'udt',
  0x012e: 'utp',
  0x0190: 'unix',
  0x01a5: 'p2p',
  0x01bb: 'https',
  0x01bc: 'onion',
  0x01bd: 'onion3',
  0x01be: 'garlic64',
  0x01bf: 'garlic32',
  0x01cc: 'quic',
  0x01dd: 'ws',
  0x01de: 'wss',
  0x01df: 'p2p-websocket-star',
  0x01e0: 'http',

  // ipld
  0x55: 'raw',
  0x70: 'dag-pb',
  0x71: 'dag-cbor',
  0x72: 'libp2p-key',
  0x78: 'git-raw',
  0x7b: 'torrent-info',
  0x7c: 'torrent-file',
  0x81: 'leofcoin-block',
  0x82: 'leofcoin-tx',
  0x83: 'leofcoin-pr',
  0x90: 'eth-block',
  0x91: 'eth-block-list',
  0x92: 'eth-tx-trie',
  0x93: 'eth-tx',
  0x94: 'eth-tx-receipt-trie',
  0x95: 'eth-tx-receipt',
  0x96: 'eth-state-trie',
  0x97: 'eth-account-snapshot',
  0x98: 'eth-storage-trie',
  0xb0: 'bitcoin-block',
  0xb1: 'bitcoin-tx',
  0xc0: 'zcash-block',
  0xc1: 'zcash-tx',
  0xd0: 'stellar-block',
  0xd1: 'stellar-tx',
  0xe0: 'decred-block',
  0xe1: 'decred-tx',
  0xf0: 'dash-block',
  0xf1: 'dash-tx',
  0xfa: 'swarm-manifest',
  0xfb: 'swarm-feed',
  0x0129: 'dag-json',

  // namespace
  0x2f: 'path',
  0xe2: 'ipld-ns',
  0xe3: 'ipfs-ns',
  0xe4: 'swarm-ns',
  0xe5: 'ipns-ns',
  0xe6: 'zeronet',

  // key
  0xed: 'ed25519-pub',

  // holochain
  0x807124: 'holochain-adr-v0',
  0x817124: 'holochain-adr-v1',
  0x947124: 'holochain-key-v0',
  0x957124: 'holochain-key-v1',
  0xa27124: 'holochain-sig-v0',
  0xa37124: 'holochain-sig-v1'
})

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\print.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\constants.js
      return function (require, module, exports) {
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'
module.exports = Object.freeze({

  // serialization
  PROTOBUF: 0x50,
  CBOR: 0x51,
  RLP: 0x60,
  BENCODE: 0x63,
  JSON: 0x0200,
  MESSAGEPACK: 0x0201,

  // multiformat
  MULTICODEC: 0x30,
  MULTIHASH: 0x31,
  MULTIADDR: 0x32,
  MULTIBASE: 0x33,

  // multihash
  IDENTITY: 0x00,
  SHA1: 0x11,
  SHA2_256: 0x12,
  SHA2_512: 0x13,
  SHA3_512: 0x14,
  SHA3_384: 0x15,
  SHA3_256: 0x16,
  SHA3_224: 0x17,
  SHAKE_128: 0x18,
  SHAKE_256: 0x19,
  KECCAK_224: 0x1a,
  KECCAK_256: 0x1b,
  KECCAK_384: 0x1c,
  KECCAK_512: 0x1d,
  MURMUR3_128: 0x22,
  MURMUR3_32: 0x23,
  DBL_SHA2_256: 0x56,
  MD4: 0xd4,
  MD5: 0xd5,
  BMT: 0xd6,
  X11: 0x1100,
  BLAKE2B_8: 0xb201,
  BLAKE2B_16: 0xb202,
  BLAKE2B_24: 0xb203,
  BLAKE2B_32: 0xb204,
  BLAKE2B_40: 0xb205,
  BLAKE2B_48: 0xb206,
  BLAKE2B_56: 0xb207,
  BLAKE2B_64: 0xb208,
  BLAKE2B_72: 0xb209,
  BLAKE2B_80: 0xb20a,
  BLAKE2B_88: 0xb20b,
  BLAKE2B_96: 0xb20c,
  BLAKE2B_104: 0xb20d,
  BLAKE2B_112: 0xb20e,
  BLAKE2B_120: 0xb20f,
  BLAKE2B_128: 0xb210,
  BLAKE2B_136: 0xb211,
  BLAKE2B_144: 0xb212,
  BLAKE2B_152: 0xb213,
  BLAKE2B_160: 0xb214,
  BLAKE2B_168: 0xb215,
  BLAKE2B_176: 0xb216,
  BLAKE2B_184: 0xb217,
  BLAKE2B_192: 0xb218,
  BLAKE2B_200: 0xb219,
  BLAKE2B_208: 0xb21a,
  BLAKE2B_216: 0xb21b,
  BLAKE2B_224: 0xb21c,
  BLAKE2B_232: 0xb21d,
  BLAKE2B_240: 0xb21e,
  BLAKE2B_248: 0xb21f,
  BLAKE2B_256: 0xb220,
  BLAKE2B_264: 0xb221,
  BLAKE2B_272: 0xb222,
  BLAKE2B_280: 0xb223,
  BLAKE2B_288: 0xb224,
  BLAKE2B_296: 0xb225,
  BLAKE2B_304: 0xb226,
  BLAKE2B_312: 0xb227,
  BLAKE2B_320: 0xb228,
  BLAKE2B_328: 0xb229,
  BLAKE2B_336: 0xb22a,
  BLAKE2B_344: 0xb22b,
  BLAKE2B_352: 0xb22c,
  BLAKE2B_360: 0xb22d,
  BLAKE2B_368: 0xb22e,
  BLAKE2B_376: 0xb22f,
  BLAKE2B_384: 0xb230,
  BLAKE2B_392: 0xb231,
  BLAKE2B_400: 0xb232,
  BLAKE2B_408: 0xb233,
  BLAKE2B_416: 0xb234,
  BLAKE2B_424: 0xb235,
  BLAKE2B_432: 0xb236,
  BLAKE2B_440: 0xb237,
  BLAKE2B_448: 0xb238,
  BLAKE2B_456: 0xb239,
  BLAKE2B_464: 0xb23a,
  BLAKE2B_472: 0xb23b,
  BLAKE2B_480: 0xb23c,
  BLAKE2B_488: 0xb23d,
  BLAKE2B_496: 0xb23e,
  BLAKE2B_504: 0xb23f,
  BLAKE2B_512: 0xb240,
  BLAKE2S_8: 0xb241,
  BLAKE2S_16: 0xb242,
  BLAKE2S_24: 0xb243,
  BLAKE2S_32: 0xb244,
  BLAKE2S_40: 0xb245,
  BLAKE2S_48: 0xb246,
  BLAKE2S_56: 0xb247,
  BLAKE2S_64: 0xb248,
  BLAKE2S_72: 0xb249,
  BLAKE2S_80: 0xb24a,
  BLAKE2S_88: 0xb24b,
  BLAKE2S_96: 0xb24c,
  BLAKE2S_104: 0xb24d,
  BLAKE2S_112: 0xb24e,
  BLAKE2S_120: 0xb24f,
  BLAKE2S_128: 0xb250,
  BLAKE2S_136: 0xb251,
  BLAKE2S_144: 0xb252,
  BLAKE2S_152: 0xb253,
  BLAKE2S_160: 0xb254,
  BLAKE2S_168: 0xb255,
  BLAKE2S_176: 0xb256,
  BLAKE2S_184: 0xb257,
  BLAKE2S_192: 0xb258,
  BLAKE2S_200: 0xb259,
  BLAKE2S_208: 0xb25a,
  BLAKE2S_216: 0xb25b,
  BLAKE2S_224: 0xb25c,
  BLAKE2S_232: 0xb25d,
  BLAKE2S_240: 0xb25e,
  BLAKE2S_248: 0xb25f,
  BLAKE2S_256: 0xb260,
  SKEIN256_8: 0xb301,
  SKEIN256_16: 0xb302,
  SKEIN256_24: 0xb303,
  SKEIN256_32: 0xb304,
  SKEIN256_40: 0xb305,
  SKEIN256_48: 0xb306,
  SKEIN256_56: 0xb307,
  SKEIN256_64: 0xb308,
  SKEIN256_72: 0xb309,
  SKEIN256_80: 0xb30a,
  SKEIN256_88: 0xb30b,
  SKEIN256_96: 0xb30c,
  SKEIN256_104: 0xb30d,
  SKEIN256_112: 0xb30e,
  SKEIN256_120: 0xb30f,
  SKEIN256_128: 0xb310,
  SKEIN256_136: 0xb311,
  SKEIN256_144: 0xb312,
  SKEIN256_152: 0xb313,
  SKEIN256_160: 0xb314,
  SKEIN256_168: 0xb315,
  SKEIN256_176: 0xb316,
  SKEIN256_184: 0xb317,
  SKEIN256_192: 0xb318,
  SKEIN256_200: 0xb319,
  SKEIN256_208: 0xb31a,
  SKEIN256_216: 0xb31b,
  SKEIN256_224: 0xb31c,
  SKEIN256_232: 0xb31d,
  SKEIN256_240: 0xb31e,
  SKEIN256_248: 0xb31f,
  SKEIN256_256: 0xb320,
  SKEIN512_8: 0xb321,
  SKEIN512_16: 0xb322,
  SKEIN512_24: 0xb323,
  SKEIN512_32: 0xb324,
  SKEIN512_40: 0xb325,
  SKEIN512_48: 0xb326,
  SKEIN512_56: 0xb327,
  SKEIN512_64: 0xb328,
  SKEIN512_72: 0xb329,
  SKEIN512_80: 0xb32a,
  SKEIN512_88: 0xb32b,
  SKEIN512_96: 0xb32c,
  SKEIN512_104: 0xb32d,
  SKEIN512_112: 0xb32e,
  SKEIN512_120: 0xb32f,
  SKEIN512_128: 0xb330,
  SKEIN512_136: 0xb331,
  SKEIN512_144: 0xb332,
  SKEIN512_152: 0xb333,
  SKEIN512_160: 0xb334,
  SKEIN512_168: 0xb335,
  SKEIN512_176: 0xb336,
  SKEIN512_184: 0xb337,
  SKEIN512_192: 0xb338,
  SKEIN512_200: 0xb339,
  SKEIN512_208: 0xb33a,
  SKEIN512_216: 0xb33b,
  SKEIN512_224: 0xb33c,
  SKEIN512_232: 0xb33d,
  SKEIN512_240: 0xb33e,
  SKEIN512_248: 0xb33f,
  SKEIN512_256: 0xb340,
  SKEIN512_264: 0xb341,
  SKEIN512_272: 0xb342,
  SKEIN512_280: 0xb343,
  SKEIN512_288: 0xb344,
  SKEIN512_296: 0xb345,
  SKEIN512_304: 0xb346,
  SKEIN512_312: 0xb347,
  SKEIN512_320: 0xb348,
  SKEIN512_328: 0xb349,
  SKEIN512_336: 0xb34a,
  SKEIN512_344: 0xb34b,
  SKEIN512_352: 0xb34c,
  SKEIN512_360: 0xb34d,
  SKEIN512_368: 0xb34e,
  SKEIN512_376: 0xb34f,
  SKEIN512_384: 0xb350,
  SKEIN512_392: 0xb351,
  SKEIN512_400: 0xb352,
  SKEIN512_408: 0xb353,
  SKEIN512_416: 0xb354,
  SKEIN512_424: 0xb355,
  SKEIN512_432: 0xb356,
  SKEIN512_440: 0xb357,
  SKEIN512_448: 0xb358,
  SKEIN512_456: 0xb359,
  SKEIN512_464: 0xb35a,
  SKEIN512_472: 0xb35b,
  SKEIN512_480: 0xb35c,
  SKEIN512_488: 0xb35d,
  SKEIN512_496: 0xb35e,
  SKEIN512_504: 0xb35f,
  SKEIN512_512: 0xb360,
  SKEIN1024_8: 0xb361,
  SKEIN1024_16: 0xb362,
  SKEIN1024_24: 0xb363,
  SKEIN1024_32: 0xb364,
  SKEIN1024_40: 0xb365,
  SKEIN1024_48: 0xb366,
  SKEIN1024_56: 0xb367,
  SKEIN1024_64: 0xb368,
  SKEIN1024_72: 0xb369,
  SKEIN1024_80: 0xb36a,
  SKEIN1024_88: 0xb36b,
  SKEIN1024_96: 0xb36c,
  SKEIN1024_104: 0xb36d,
  SKEIN1024_112: 0xb36e,
  SKEIN1024_120: 0xb36f,
  SKEIN1024_128: 0xb370,
  SKEIN1024_136: 0xb371,
  SKEIN1024_144: 0xb372,
  SKEIN1024_152: 0xb373,
  SKEIN1024_160: 0xb374,
  SKEIN1024_168: 0xb375,
  SKEIN1024_176: 0xb376,
  SKEIN1024_184: 0xb377,
  SKEIN1024_192: 0xb378,
  SKEIN1024_200: 0xb379,
  SKEIN1024_208: 0xb37a,
  SKEIN1024_216: 0xb37b,
  SKEIN1024_224: 0xb37c,
  SKEIN1024_232: 0xb37d,
  SKEIN1024_240: 0xb37e,
  SKEIN1024_248: 0xb37f,
  SKEIN1024_256: 0xb380,
  SKEIN1024_264: 0xb381,
  SKEIN1024_272: 0xb382,
  SKEIN1024_280: 0xb383,
  SKEIN1024_288: 0xb384,
  SKEIN1024_296: 0xb385,
  SKEIN1024_304: 0xb386,
  SKEIN1024_312: 0xb387,
  SKEIN1024_320: 0xb388,
  SKEIN1024_328: 0xb389,
  SKEIN1024_336: 0xb38a,
  SKEIN1024_344: 0xb38b,
  SKEIN1024_352: 0xb38c,
  SKEIN1024_360: 0xb38d,
  SKEIN1024_368: 0xb38e,
  SKEIN1024_376: 0xb38f,
  SKEIN1024_384: 0xb390,
  SKEIN1024_392: 0xb391,
  SKEIN1024_400: 0xb392,
  SKEIN1024_408: 0xb393,
  SKEIN1024_416: 0xb394,
  SKEIN1024_424: 0xb395,
  SKEIN1024_432: 0xb396,
  SKEIN1024_440: 0xb397,
  SKEIN1024_448: 0xb398,
  SKEIN1024_456: 0xb399,
  SKEIN1024_464: 0xb39a,
  SKEIN1024_472: 0xb39b,
  SKEIN1024_480: 0xb39c,
  SKEIN1024_488: 0xb39d,
  SKEIN1024_496: 0xb39e,
  SKEIN1024_504: 0xb39f,
  SKEIN1024_512: 0xb3a0,
  SKEIN1024_520: 0xb3a1,
  SKEIN1024_528: 0xb3a2,
  SKEIN1024_536: 0xb3a3,
  SKEIN1024_544: 0xb3a4,
  SKEIN1024_552: 0xb3a5,
  SKEIN1024_560: 0xb3a6,
  SKEIN1024_568: 0xb3a7,
  SKEIN1024_576: 0xb3a8,
  SKEIN1024_584: 0xb3a9,
  SKEIN1024_592: 0xb3aa,
  SKEIN1024_600: 0xb3ab,
  SKEIN1024_608: 0xb3ac,
  SKEIN1024_616: 0xb3ad,
  SKEIN1024_624: 0xb3ae,
  SKEIN1024_632: 0xb3af,
  SKEIN1024_640: 0xb3b0,
  SKEIN1024_648: 0xb3b1,
  SKEIN1024_656: 0xb3b2,
  SKEIN1024_664: 0xb3b3,
  SKEIN1024_672: 0xb3b4,
  SKEIN1024_680: 0xb3b5,
  SKEIN1024_688: 0xb3b6,
  SKEIN1024_696: 0xb3b7,
  SKEIN1024_704: 0xb3b8,
  SKEIN1024_712: 0xb3b9,
  SKEIN1024_720: 0xb3ba,
  SKEIN1024_728: 0xb3bb,
  SKEIN1024_736: 0xb3bc,
  SKEIN1024_744: 0xb3bd,
  SKEIN1024_752: 0xb3be,
  SKEIN1024_760: 0xb3bf,
  SKEIN1024_768: 0xb3c0,
  SKEIN1024_776: 0xb3c1,
  SKEIN1024_784: 0xb3c2,
  SKEIN1024_792: 0xb3c3,
  SKEIN1024_800: 0xb3c4,
  SKEIN1024_808: 0xb3c5,
  SKEIN1024_816: 0xb3c6,
  SKEIN1024_824: 0xb3c7,
  SKEIN1024_832: 0xb3c8,
  SKEIN1024_840: 0xb3c9,
  SKEIN1024_848: 0xb3ca,
  SKEIN1024_856: 0xb3cb,
  SKEIN1024_864: 0xb3cc,
  SKEIN1024_872: 0xb3cd,
  SKEIN1024_880: 0xb3ce,
  SKEIN1024_888: 0xb3cf,
  SKEIN1024_896: 0xb3d0,
  SKEIN1024_904: 0xb3d1,
  SKEIN1024_912: 0xb3d2,
  SKEIN1024_920: 0xb3d3,
  SKEIN1024_928: 0xb3d4,
  SKEIN1024_936: 0xb3d5,
  SKEIN1024_944: 0xb3d6,
  SKEIN1024_952: 0xb3d7,
  SKEIN1024_960: 0xb3d8,
  SKEIN1024_968: 0xb3d9,
  SKEIN1024_976: 0xb3da,
  SKEIN1024_984: 0xb3db,
  SKEIN1024_992: 0xb3dc,
  SKEIN1024_1000: 0xb3dd,
  SKEIN1024_1008: 0xb3de,
  SKEIN1024_1016: 0xb3df,
  SKEIN1024_1024: 0xb3e0,

  // multiaddr
  IP4: 0x04,
  TCP: 0x06,
  DCCP: 0x21,
  IP6: 0x29,
  IP6ZONE: 0x2a,
  DNS: 0x35,
  DNS4: 0x36,
  DNS6: 0x37,
  DNSADDR: 0x38,
  SCTP: 0x84,
  UDP: 0x0111,
  P2P_WEBRTC_STAR: 0x0113,
  P2P_WEBRTC_DIRECT: 0x0114,
  P2P_STARDUST: 0x0115,
  P2P_CIRCUIT: 0x0122,
  UDT: 0x012d,
  UTP: 0x012e,
  UNIX: 0x0190,
  P2P: 0x01a5,
  IPFS: 0x01a5,
  HTTPS: 0x01bb,
  ONION: 0x01bc,
  ONION3: 0x01bd,
  GARLIC64: 0x01be,
  GARLIC32: 0x01bf,
  QUIC: 0x01cc,
  WS: 0x01dd,
  WSS: 0x01de,
  P2P_WEBSOCKET_STAR: 0x01df,
  HTTP: 0x01e0,

  // ipld
  RAW: 0x55,
  DAG_PB: 0x70,
  DAG_CBOR: 0x71,
  LIBP2P_KEY: 0x72,
  GIT_RAW: 0x78,
  TORRENT_INFO: 0x7b,
  TORRENT_FILE: 0x7c,
  LEOFCOIN_BLOCK: 0x81,
  LEOFCOIN_TX: 0x82,
  LEOFCOIN_PR: 0x83,
  ETH_BLOCK: 0x90,
  ETH_BLOCK_LIST: 0x91,
  ETH_TX_TRIE: 0x92,
  ETH_TX: 0x93,
  ETH_TX_RECEIPT_TRIE: 0x94,
  ETH_TX_RECEIPT: 0x95,
  ETH_STATE_TRIE: 0x96,
  ETH_ACCOUNT_SNAPSHOT: 0x97,
  ETH_STORAGE_TRIE: 0x98,
  BITCOIN_BLOCK: 0xb0,
  BITCOIN_TX: 0xb1,
  ZCASH_BLOCK: 0xc0,
  ZCASH_TX: 0xc1,
  STELLAR_BLOCK: 0xd0,
  STELLAR_TX: 0xd1,
  DECRED_BLOCK: 0xe0,
  DECRED_TX: 0xe1,
  DASH_BLOCK: 0xf0,
  DASH_TX: 0xf1,
  SWARM_MANIFEST: 0xfa,
  SWARM_FEED: 0xfb,
  DAG_JSON: 0x0129,

  // namespace
  PATH: 0x2f,
  IPLD_NS: 0xe2,
  IPFS_NS: 0xe3,
  SWARM_NS: 0xe4,
  IPNS_NS: 0xe5,
  ZERONET: 0xe6,

  // key
  ED25519_PUB: 0xed,

  // holochain
  HOLOCHAIN_ADR_V0: 0x807124,
  HOLOCHAIN_ADR_V1: 0x817124,
  HOLOCHAIN_KEY_V0: 0x947124,
  HOLOCHAIN_KEY_V1: 0x957124,
  HOLOCHAIN_SIG_V0: 0xa27124,
  HOLOCHAIN_SIG_V1: 0xa37124
})

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\varint-table.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\base-table.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\varint-table.js
      return function (require, module, exports) {
'use strict'
const baseTable = require('./base-table')
const varintBufferEncode = require('./util').varintBufferEncode

// this creates a map for codecName -> codeVarintBuffer

const varintTable = {}
module.exports = varintTable

for (let encodingName in baseTable) {
  let code = baseTable[encodingName]
  varintTable[encodingName] = varintBufferEncode(code)
}

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\varint-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\name-table.js", {"./base-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\name-table.js
      return function (require, module, exports) {
'use strict'
const baseTable = require('./base-table')

// this creates a map for code as hexString -> codecName

const nameTable = {}
module.exports = nameTable

for (let encodingName in baseTable) {
  let code = baseTable[encodingName]
  nameTable[code.toString('hex')] = encodingName
}

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\name-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\util.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
const varint = require('varint')

module.exports = {
  numberToBuffer,
  bufferToNumber,
  varintBufferEncode,
  varintBufferDecode
}

function bufferToNumber (buf) {
  return parseInt(buf.toString('hex'), 16)
}

function numberToBuffer (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return Buffer.from(hexString, 'hex')
}

function varintBufferEncode (input) {
  return Buffer.from(varint.encode(bufferToNumber(input)))
}

function varintBufferDecode (input) {
  return numberToBuffer(varint.decode(input))
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\class-is\index.js
      return function (require, module, exports) {
'use strict';

function withIs(Class, { className, symbolName }) {
    const symbol = Symbol.for(symbolName);

    const ClassIsWrapper = {
        // The code below assigns the class wrapper to an object to trick
        // JavaScript engines to show the name of the extended class when
        // logging an instances.
        // We are assigning an anonymous class (class wrapper) to the object
        // with key `className` to keep the correct name.
        // If this is not supported it falls back to logging `ClassIsWrapper`.
        [className]: class extends Class {
            constructor(...args) {
                super(...args);
                Object.defineProperty(this, symbol, { value: true });
            }

            get [Symbol.toStringTag]() {
                return className;
            }
        },
    }[className];

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

function withIsProto(Class, { className, symbolName, withoutNew }) {
    const symbol = Symbol.for(symbolName);

    /* eslint-disable object-shorthand */
    const ClassIsWrapper = {
        [className]: function (...args) {
            if (withoutNew && !(this instanceof ClassIsWrapper)) {
                return new ClassIsWrapper(...args);
            }

            const _this = Class.call(this, ...args) || this;

            if (_this && !_this[symbol]) {
                Object.defineProperty(_this, symbol, { value: true });
            }

            return _this;
        },
    }[className];
    /* eslint-enable object-shorthand */

    ClassIsWrapper.prototype = Object.create(Class.prototype);
    ClassIsWrapper.prototype.constructor = ClassIsWrapper;

    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
            return className;
        },
    });

    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

    return ClassIsWrapper;
}

module.exports = withIs;
module.exports.proto = withIsProto;

      };
    };
  }
}, {package:"class-is",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\base-table.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multicodec\src\base-table.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// THIS FILE IS GENERATED, DO NO EDIT MANUALLY
// For more information see the README.md
/* eslint-disable dot-notation */
'use strict'

// serialization
exports['protobuf'] = Buffer.from('50', 'hex')
exports['cbor'] = Buffer.from('51', 'hex')
exports['rlp'] = Buffer.from('60', 'hex')
exports['bencode'] = Buffer.from('63', 'hex')
exports['json'] = Buffer.from('0200', 'hex')
exports['messagepack'] = Buffer.from('0201', 'hex')

// multiformat
exports['multicodec'] = Buffer.from('30', 'hex')
exports['multihash'] = Buffer.from('31', 'hex')
exports['multiaddr'] = Buffer.from('32', 'hex')
exports['multibase'] = Buffer.from('33', 'hex')

// multihash
exports['identity'] = Buffer.from('00', 'hex')
exports['sha1'] = Buffer.from('11', 'hex')
exports['sha2-256'] = Buffer.from('12', 'hex')
exports['sha2-512'] = Buffer.from('13', 'hex')
exports['sha3-512'] = Buffer.from('14', 'hex')
exports['sha3-384'] = Buffer.from('15', 'hex')
exports['sha3-256'] = Buffer.from('16', 'hex')
exports['sha3-224'] = Buffer.from('17', 'hex')
exports['shake-128'] = Buffer.from('18', 'hex')
exports['shake-256'] = Buffer.from('19', 'hex')
exports['keccak-224'] = Buffer.from('1a', 'hex')
exports['keccak-256'] = Buffer.from('1b', 'hex')
exports['keccak-384'] = Buffer.from('1c', 'hex')
exports['keccak-512'] = Buffer.from('1d', 'hex')
exports['murmur3-128'] = Buffer.from('22', 'hex')
exports['murmur3-32'] = Buffer.from('23', 'hex')
exports['dbl-sha2-256'] = Buffer.from('56', 'hex')
exports['md4'] = Buffer.from('d4', 'hex')
exports['md5'] = Buffer.from('d5', 'hex')
exports['bmt'] = Buffer.from('d6', 'hex')
exports['x11'] = Buffer.from('1100', 'hex')
exports['blake2b-8'] = Buffer.from('b201', 'hex')
exports['blake2b-16'] = Buffer.from('b202', 'hex')
exports['blake2b-24'] = Buffer.from('b203', 'hex')
exports['blake2b-32'] = Buffer.from('b204', 'hex')
exports['blake2b-40'] = Buffer.from('b205', 'hex')
exports['blake2b-48'] = Buffer.from('b206', 'hex')
exports['blake2b-56'] = Buffer.from('b207', 'hex')
exports['blake2b-64'] = Buffer.from('b208', 'hex')
exports['blake2b-72'] = Buffer.from('b209', 'hex')
exports['blake2b-80'] = Buffer.from('b20a', 'hex')
exports['blake2b-88'] = Buffer.from('b20b', 'hex')
exports['blake2b-96'] = Buffer.from('b20c', 'hex')
exports['blake2b-104'] = Buffer.from('b20d', 'hex')
exports['blake2b-112'] = Buffer.from('b20e', 'hex')
exports['blake2b-120'] = Buffer.from('b20f', 'hex')
exports['blake2b-128'] = Buffer.from('b210', 'hex')
exports['blake2b-136'] = Buffer.from('b211', 'hex')
exports['blake2b-144'] = Buffer.from('b212', 'hex')
exports['blake2b-152'] = Buffer.from('b213', 'hex')
exports['blake2b-160'] = Buffer.from('b214', 'hex')
exports['blake2b-168'] = Buffer.from('b215', 'hex')
exports['blake2b-176'] = Buffer.from('b216', 'hex')
exports['blake2b-184'] = Buffer.from('b217', 'hex')
exports['blake2b-192'] = Buffer.from('b218', 'hex')
exports['blake2b-200'] = Buffer.from('b219', 'hex')
exports['blake2b-208'] = Buffer.from('b21a', 'hex')
exports['blake2b-216'] = Buffer.from('b21b', 'hex')
exports['blake2b-224'] = Buffer.from('b21c', 'hex')
exports['blake2b-232'] = Buffer.from('b21d', 'hex')
exports['blake2b-240'] = Buffer.from('b21e', 'hex')
exports['blake2b-248'] = Buffer.from('b21f', 'hex')
exports['blake2b-256'] = Buffer.from('b220', 'hex')
exports['blake2b-264'] = Buffer.from('b221', 'hex')
exports['blake2b-272'] = Buffer.from('b222', 'hex')
exports['blake2b-280'] = Buffer.from('b223', 'hex')
exports['blake2b-288'] = Buffer.from('b224', 'hex')
exports['blake2b-296'] = Buffer.from('b225', 'hex')
exports['blake2b-304'] = Buffer.from('b226', 'hex')
exports['blake2b-312'] = Buffer.from('b227', 'hex')
exports['blake2b-320'] = Buffer.from('b228', 'hex')
exports['blake2b-328'] = Buffer.from('b229', 'hex')
exports['blake2b-336'] = Buffer.from('b22a', 'hex')
exports['blake2b-344'] = Buffer.from('b22b', 'hex')
exports['blake2b-352'] = Buffer.from('b22c', 'hex')
exports['blake2b-360'] = Buffer.from('b22d', 'hex')
exports['blake2b-368'] = Buffer.from('b22e', 'hex')
exports['blake2b-376'] = Buffer.from('b22f', 'hex')
exports['blake2b-384'] = Buffer.from('b230', 'hex')
exports['blake2b-392'] = Buffer.from('b231', 'hex')
exports['blake2b-400'] = Buffer.from('b232', 'hex')
exports['blake2b-408'] = Buffer.from('b233', 'hex')
exports['blake2b-416'] = Buffer.from('b234', 'hex')
exports['blake2b-424'] = Buffer.from('b235', 'hex')
exports['blake2b-432'] = Buffer.from('b236', 'hex')
exports['blake2b-440'] = Buffer.from('b237', 'hex')
exports['blake2b-448'] = Buffer.from('b238', 'hex')
exports['blake2b-456'] = Buffer.from('b239', 'hex')
exports['blake2b-464'] = Buffer.from('b23a', 'hex')
exports['blake2b-472'] = Buffer.from('b23b', 'hex')
exports['blake2b-480'] = Buffer.from('b23c', 'hex')
exports['blake2b-488'] = Buffer.from('b23d', 'hex')
exports['blake2b-496'] = Buffer.from('b23e', 'hex')
exports['blake2b-504'] = Buffer.from('b23f', 'hex')
exports['blake2b-512'] = Buffer.from('b240', 'hex')
exports['blake2s-8'] = Buffer.from('b241', 'hex')
exports['blake2s-16'] = Buffer.from('b242', 'hex')
exports['blake2s-24'] = Buffer.from('b243', 'hex')
exports['blake2s-32'] = Buffer.from('b244', 'hex')
exports['blake2s-40'] = Buffer.from('b245', 'hex')
exports['blake2s-48'] = Buffer.from('b246', 'hex')
exports['blake2s-56'] = Buffer.from('b247', 'hex')
exports['blake2s-64'] = Buffer.from('b248', 'hex')
exports['blake2s-72'] = Buffer.from('b249', 'hex')
exports['blake2s-80'] = Buffer.from('b24a', 'hex')
exports['blake2s-88'] = Buffer.from('b24b', 'hex')
exports['blake2s-96'] = Buffer.from('b24c', 'hex')
exports['blake2s-104'] = Buffer.from('b24d', 'hex')
exports['blake2s-112'] = Buffer.from('b24e', 'hex')
exports['blake2s-120'] = Buffer.from('b24f', 'hex')
exports['blake2s-128'] = Buffer.from('b250', 'hex')
exports['blake2s-136'] = Buffer.from('b251', 'hex')
exports['blake2s-144'] = Buffer.from('b252', 'hex')
exports['blake2s-152'] = Buffer.from('b253', 'hex')
exports['blake2s-160'] = Buffer.from('b254', 'hex')
exports['blake2s-168'] = Buffer.from('b255', 'hex')
exports['blake2s-176'] = Buffer.from('b256', 'hex')
exports['blake2s-184'] = Buffer.from('b257', 'hex')
exports['blake2s-192'] = Buffer.from('b258', 'hex')
exports['blake2s-200'] = Buffer.from('b259', 'hex')
exports['blake2s-208'] = Buffer.from('b25a', 'hex')
exports['blake2s-216'] = Buffer.from('b25b', 'hex')
exports['blake2s-224'] = Buffer.from('b25c', 'hex')
exports['blake2s-232'] = Buffer.from('b25d', 'hex')
exports['blake2s-240'] = Buffer.from('b25e', 'hex')
exports['blake2s-248'] = Buffer.from('b25f', 'hex')
exports['blake2s-256'] = Buffer.from('b260', 'hex')
exports['skein256-8'] = Buffer.from('b301', 'hex')
exports['skein256-16'] = Buffer.from('b302', 'hex')
exports['skein256-24'] = Buffer.from('b303', 'hex')
exports['skein256-32'] = Buffer.from('b304', 'hex')
exports['skein256-40'] = Buffer.from('b305', 'hex')
exports['skein256-48'] = Buffer.from('b306', 'hex')
exports['skein256-56'] = Buffer.from('b307', 'hex')
exports['skein256-64'] = Buffer.from('b308', 'hex')
exports['skein256-72'] = Buffer.from('b309', 'hex')
exports['skein256-80'] = Buffer.from('b30a', 'hex')
exports['skein256-88'] = Buffer.from('b30b', 'hex')
exports['skein256-96'] = Buffer.from('b30c', 'hex')
exports['skein256-104'] = Buffer.from('b30d', 'hex')
exports['skein256-112'] = Buffer.from('b30e', 'hex')
exports['skein256-120'] = Buffer.from('b30f', 'hex')
exports['skein256-128'] = Buffer.from('b310', 'hex')
exports['skein256-136'] = Buffer.from('b311', 'hex')
exports['skein256-144'] = Buffer.from('b312', 'hex')
exports['skein256-152'] = Buffer.from('b313', 'hex')
exports['skein256-160'] = Buffer.from('b314', 'hex')
exports['skein256-168'] = Buffer.from('b315', 'hex')
exports['skein256-176'] = Buffer.from('b316', 'hex')
exports['skein256-184'] = Buffer.from('b317', 'hex')
exports['skein256-192'] = Buffer.from('b318', 'hex')
exports['skein256-200'] = Buffer.from('b319', 'hex')
exports['skein256-208'] = Buffer.from('b31a', 'hex')
exports['skein256-216'] = Buffer.from('b31b', 'hex')
exports['skein256-224'] = Buffer.from('b31c', 'hex')
exports['skein256-232'] = Buffer.from('b31d', 'hex')
exports['skein256-240'] = Buffer.from('b31e', 'hex')
exports['skein256-248'] = Buffer.from('b31f', 'hex')
exports['skein256-256'] = Buffer.from('b320', 'hex')
exports['skein512-8'] = Buffer.from('b321', 'hex')
exports['skein512-16'] = Buffer.from('b322', 'hex')
exports['skein512-24'] = Buffer.from('b323', 'hex')
exports['skein512-32'] = Buffer.from('b324', 'hex')
exports['skein512-40'] = Buffer.from('b325', 'hex')
exports['skein512-48'] = Buffer.from('b326', 'hex')
exports['skein512-56'] = Buffer.from('b327', 'hex')
exports['skein512-64'] = Buffer.from('b328', 'hex')
exports['skein512-72'] = Buffer.from('b329', 'hex')
exports['skein512-80'] = Buffer.from('b32a', 'hex')
exports['skein512-88'] = Buffer.from('b32b', 'hex')
exports['skein512-96'] = Buffer.from('b32c', 'hex')
exports['skein512-104'] = Buffer.from('b32d', 'hex')
exports['skein512-112'] = Buffer.from('b32e', 'hex')
exports['skein512-120'] = Buffer.from('b32f', 'hex')
exports['skein512-128'] = Buffer.from('b330', 'hex')
exports['skein512-136'] = Buffer.from('b331', 'hex')
exports['skein512-144'] = Buffer.from('b332', 'hex')
exports['skein512-152'] = Buffer.from('b333', 'hex')
exports['skein512-160'] = Buffer.from('b334', 'hex')
exports['skein512-168'] = Buffer.from('b335', 'hex')
exports['skein512-176'] = Buffer.from('b336', 'hex')
exports['skein512-184'] = Buffer.from('b337', 'hex')
exports['skein512-192'] = Buffer.from('b338', 'hex')
exports['skein512-200'] = Buffer.from('b339', 'hex')
exports['skein512-208'] = Buffer.from('b33a', 'hex')
exports['skein512-216'] = Buffer.from('b33b', 'hex')
exports['skein512-224'] = Buffer.from('b33c', 'hex')
exports['skein512-232'] = Buffer.from('b33d', 'hex')
exports['skein512-240'] = Buffer.from('b33e', 'hex')
exports['skein512-248'] = Buffer.from('b33f', 'hex')
exports['skein512-256'] = Buffer.from('b340', 'hex')
exports['skein512-264'] = Buffer.from('b341', 'hex')
exports['skein512-272'] = Buffer.from('b342', 'hex')
exports['skein512-280'] = Buffer.from('b343', 'hex')
exports['skein512-288'] = Buffer.from('b344', 'hex')
exports['skein512-296'] = Buffer.from('b345', 'hex')
exports['skein512-304'] = Buffer.from('b346', 'hex')
exports['skein512-312'] = Buffer.from('b347', 'hex')
exports['skein512-320'] = Buffer.from('b348', 'hex')
exports['skein512-328'] = Buffer.from('b349', 'hex')
exports['skein512-336'] = Buffer.from('b34a', 'hex')
exports['skein512-344'] = Buffer.from('b34b', 'hex')
exports['skein512-352'] = Buffer.from('b34c', 'hex')
exports['skein512-360'] = Buffer.from('b34d', 'hex')
exports['skein512-368'] = Buffer.from('b34e', 'hex')
exports['skein512-376'] = Buffer.from('b34f', 'hex')
exports['skein512-384'] = Buffer.from('b350', 'hex')
exports['skein512-392'] = Buffer.from('b351', 'hex')
exports['skein512-400'] = Buffer.from('b352', 'hex')
exports['skein512-408'] = Buffer.from('b353', 'hex')
exports['skein512-416'] = Buffer.from('b354', 'hex')
exports['skein512-424'] = Buffer.from('b355', 'hex')
exports['skein512-432'] = Buffer.from('b356', 'hex')
exports['skein512-440'] = Buffer.from('b357', 'hex')
exports['skein512-448'] = Buffer.from('b358', 'hex')
exports['skein512-456'] = Buffer.from('b359', 'hex')
exports['skein512-464'] = Buffer.from('b35a', 'hex')
exports['skein512-472'] = Buffer.from('b35b', 'hex')
exports['skein512-480'] = Buffer.from('b35c', 'hex')
exports['skein512-488'] = Buffer.from('b35d', 'hex')
exports['skein512-496'] = Buffer.from('b35e', 'hex')
exports['skein512-504'] = Buffer.from('b35f', 'hex')
exports['skein512-512'] = Buffer.from('b360', 'hex')
exports['skein1024-8'] = Buffer.from('b361', 'hex')
exports['skein1024-16'] = Buffer.from('b362', 'hex')
exports['skein1024-24'] = Buffer.from('b363', 'hex')
exports['skein1024-32'] = Buffer.from('b364', 'hex')
exports['skein1024-40'] = Buffer.from('b365', 'hex')
exports['skein1024-48'] = Buffer.from('b366', 'hex')
exports['skein1024-56'] = Buffer.from('b367', 'hex')
exports['skein1024-64'] = Buffer.from('b368', 'hex')
exports['skein1024-72'] = Buffer.from('b369', 'hex')
exports['skein1024-80'] = Buffer.from('b36a', 'hex')
exports['skein1024-88'] = Buffer.from('b36b', 'hex')
exports['skein1024-96'] = Buffer.from('b36c', 'hex')
exports['skein1024-104'] = Buffer.from('b36d', 'hex')
exports['skein1024-112'] = Buffer.from('b36e', 'hex')
exports['skein1024-120'] = Buffer.from('b36f', 'hex')
exports['skein1024-128'] = Buffer.from('b370', 'hex')
exports['skein1024-136'] = Buffer.from('b371', 'hex')
exports['skein1024-144'] = Buffer.from('b372', 'hex')
exports['skein1024-152'] = Buffer.from('b373', 'hex')
exports['skein1024-160'] = Buffer.from('b374', 'hex')
exports['skein1024-168'] = Buffer.from('b375', 'hex')
exports['skein1024-176'] = Buffer.from('b376', 'hex')
exports['skein1024-184'] = Buffer.from('b377', 'hex')
exports['skein1024-192'] = Buffer.from('b378', 'hex')
exports['skein1024-200'] = Buffer.from('b379', 'hex')
exports['skein1024-208'] = Buffer.from('b37a', 'hex')
exports['skein1024-216'] = Buffer.from('b37b', 'hex')
exports['skein1024-224'] = Buffer.from('b37c', 'hex')
exports['skein1024-232'] = Buffer.from('b37d', 'hex')
exports['skein1024-240'] = Buffer.from('b37e', 'hex')
exports['skein1024-248'] = Buffer.from('b37f', 'hex')
exports['skein1024-256'] = Buffer.from('b380', 'hex')
exports['skein1024-264'] = Buffer.from('b381', 'hex')
exports['skein1024-272'] = Buffer.from('b382', 'hex')
exports['skein1024-280'] = Buffer.from('b383', 'hex')
exports['skein1024-288'] = Buffer.from('b384', 'hex')
exports['skein1024-296'] = Buffer.from('b385', 'hex')
exports['skein1024-304'] = Buffer.from('b386', 'hex')
exports['skein1024-312'] = Buffer.from('b387', 'hex')
exports['skein1024-320'] = Buffer.from('b388', 'hex')
exports['skein1024-328'] = Buffer.from('b389', 'hex')
exports['skein1024-336'] = Buffer.from('b38a', 'hex')
exports['skein1024-344'] = Buffer.from('b38b', 'hex')
exports['skein1024-352'] = Buffer.from('b38c', 'hex')
exports['skein1024-360'] = Buffer.from('b38d', 'hex')
exports['skein1024-368'] = Buffer.from('b38e', 'hex')
exports['skein1024-376'] = Buffer.from('b38f', 'hex')
exports['skein1024-384'] = Buffer.from('b390', 'hex')
exports['skein1024-392'] = Buffer.from('b391', 'hex')
exports['skein1024-400'] = Buffer.from('b392', 'hex')
exports['skein1024-408'] = Buffer.from('b393', 'hex')
exports['skein1024-416'] = Buffer.from('b394', 'hex')
exports['skein1024-424'] = Buffer.from('b395', 'hex')
exports['skein1024-432'] = Buffer.from('b396', 'hex')
exports['skein1024-440'] = Buffer.from('b397', 'hex')
exports['skein1024-448'] = Buffer.from('b398', 'hex')
exports['skein1024-456'] = Buffer.from('b399', 'hex')
exports['skein1024-464'] = Buffer.from('b39a', 'hex')
exports['skein1024-472'] = Buffer.from('b39b', 'hex')
exports['skein1024-480'] = Buffer.from('b39c', 'hex')
exports['skein1024-488'] = Buffer.from('b39d', 'hex')
exports['skein1024-496'] = Buffer.from('b39e', 'hex')
exports['skein1024-504'] = Buffer.from('b39f', 'hex')
exports['skein1024-512'] = Buffer.from('b3a0', 'hex')
exports['skein1024-520'] = Buffer.from('b3a1', 'hex')
exports['skein1024-528'] = Buffer.from('b3a2', 'hex')
exports['skein1024-536'] = Buffer.from('b3a3', 'hex')
exports['skein1024-544'] = Buffer.from('b3a4', 'hex')
exports['skein1024-552'] = Buffer.from('b3a5', 'hex')
exports['skein1024-560'] = Buffer.from('b3a6', 'hex')
exports['skein1024-568'] = Buffer.from('b3a7', 'hex')
exports['skein1024-576'] = Buffer.from('b3a8', 'hex')
exports['skein1024-584'] = Buffer.from('b3a9', 'hex')
exports['skein1024-592'] = Buffer.from('b3aa', 'hex')
exports['skein1024-600'] = Buffer.from('b3ab', 'hex')
exports['skein1024-608'] = Buffer.from('b3ac', 'hex')
exports['skein1024-616'] = Buffer.from('b3ad', 'hex')
exports['skein1024-624'] = Buffer.from('b3ae', 'hex')
exports['skein1024-632'] = Buffer.from('b3af', 'hex')
exports['skein1024-640'] = Buffer.from('b3b0', 'hex')
exports['skein1024-648'] = Buffer.from('b3b1', 'hex')
exports['skein1024-656'] = Buffer.from('b3b2', 'hex')
exports['skein1024-664'] = Buffer.from('b3b3', 'hex')
exports['skein1024-672'] = Buffer.from('b3b4', 'hex')
exports['skein1024-680'] = Buffer.from('b3b5', 'hex')
exports['skein1024-688'] = Buffer.from('b3b6', 'hex')
exports['skein1024-696'] = Buffer.from('b3b7', 'hex')
exports['skein1024-704'] = Buffer.from('b3b8', 'hex')
exports['skein1024-712'] = Buffer.from('b3b9', 'hex')
exports['skein1024-720'] = Buffer.from('b3ba', 'hex')
exports['skein1024-728'] = Buffer.from('b3bb', 'hex')
exports['skein1024-736'] = Buffer.from('b3bc', 'hex')
exports['skein1024-744'] = Buffer.from('b3bd', 'hex')
exports['skein1024-752'] = Buffer.from('b3be', 'hex')
exports['skein1024-760'] = Buffer.from('b3bf', 'hex')
exports['skein1024-768'] = Buffer.from('b3c0', 'hex')
exports['skein1024-776'] = Buffer.from('b3c1', 'hex')
exports['skein1024-784'] = Buffer.from('b3c2', 'hex')
exports['skein1024-792'] = Buffer.from('b3c3', 'hex')
exports['skein1024-800'] = Buffer.from('b3c4', 'hex')
exports['skein1024-808'] = Buffer.from('b3c5', 'hex')
exports['skein1024-816'] = Buffer.from('b3c6', 'hex')
exports['skein1024-824'] = Buffer.from('b3c7', 'hex')
exports['skein1024-832'] = Buffer.from('b3c8', 'hex')
exports['skein1024-840'] = Buffer.from('b3c9', 'hex')
exports['skein1024-848'] = Buffer.from('b3ca', 'hex')
exports['skein1024-856'] = Buffer.from('b3cb', 'hex')
exports['skein1024-864'] = Buffer.from('b3cc', 'hex')
exports['skein1024-872'] = Buffer.from('b3cd', 'hex')
exports['skein1024-880'] = Buffer.from('b3ce', 'hex')
exports['skein1024-888'] = Buffer.from('b3cf', 'hex')
exports['skein1024-896'] = Buffer.from('b3d0', 'hex')
exports['skein1024-904'] = Buffer.from('b3d1', 'hex')
exports['skein1024-912'] = Buffer.from('b3d2', 'hex')
exports['skein1024-920'] = Buffer.from('b3d3', 'hex')
exports['skein1024-928'] = Buffer.from('b3d4', 'hex')
exports['skein1024-936'] = Buffer.from('b3d5', 'hex')
exports['skein1024-944'] = Buffer.from('b3d6', 'hex')
exports['skein1024-952'] = Buffer.from('b3d7', 'hex')
exports['skein1024-960'] = Buffer.from('b3d8', 'hex')
exports['skein1024-968'] = Buffer.from('b3d9', 'hex')
exports['skein1024-976'] = Buffer.from('b3da', 'hex')
exports['skein1024-984'] = Buffer.from('b3db', 'hex')
exports['skein1024-992'] = Buffer.from('b3dc', 'hex')
exports['skein1024-1000'] = Buffer.from('b3dd', 'hex')
exports['skein1024-1008'] = Buffer.from('b3de', 'hex')
exports['skein1024-1016'] = Buffer.from('b3df', 'hex')
exports['skein1024-1024'] = Buffer.from('b3e0', 'hex')

// multiaddr
exports['ip4'] = Buffer.from('04', 'hex')
exports['tcp'] = Buffer.from('06', 'hex')
exports['dccp'] = Buffer.from('21', 'hex')
exports['ip6'] = Buffer.from('29', 'hex')
exports['ip6zone'] = Buffer.from('2a', 'hex')
exports['dns'] = Buffer.from('35', 'hex')
exports['dns4'] = Buffer.from('36', 'hex')
exports['dns6'] = Buffer.from('37', 'hex')
exports['dnsaddr'] = Buffer.from('38', 'hex')
exports['sctp'] = Buffer.from('84', 'hex')
exports['udp'] = Buffer.from('0111', 'hex')
exports['p2p-webrtc-star'] = Buffer.from('0113', 'hex')
exports['p2p-webrtc-direct'] = Buffer.from('0114', 'hex')
exports['p2p-stardust'] = Buffer.from('0115', 'hex')
exports['p2p-circuit'] = Buffer.from('0122', 'hex')
exports['udt'] = Buffer.from('012d', 'hex')
exports['utp'] = Buffer.from('012e', 'hex')
exports['unix'] = Buffer.from('0190', 'hex')
exports['p2p'] = Buffer.from('01a5', 'hex')
exports['ipfs'] = Buffer.from('01a5', 'hex')
exports['https'] = Buffer.from('01bb', 'hex')
exports['onion'] = Buffer.from('01bc', 'hex')
exports['onion3'] = Buffer.from('01bd', 'hex')
exports['garlic64'] = Buffer.from('01be', 'hex')
exports['garlic32'] = Buffer.from('01bf', 'hex')
exports['quic'] = Buffer.from('01cc', 'hex')
exports['ws'] = Buffer.from('01dd', 'hex')
exports['wss'] = Buffer.from('01de', 'hex')
exports['p2p-websocket-star'] = Buffer.from('01df', 'hex')
exports['http'] = Buffer.from('01e0', 'hex')

// ipld
exports['raw'] = Buffer.from('55', 'hex')
exports['dag-pb'] = Buffer.from('70', 'hex')
exports['dag-cbor'] = Buffer.from('71', 'hex')
exports['libp2p-key'] = Buffer.from('72', 'hex')
exports['git-raw'] = Buffer.from('78', 'hex')
exports['torrent-info'] = Buffer.from('7b', 'hex')
exports['torrent-file'] = Buffer.from('7c', 'hex')
exports['leofcoin-block'] = Buffer.from('81', 'hex')
exports['leofcoin-tx'] = Buffer.from('82', 'hex')
exports['leofcoin-pr'] = Buffer.from('83', 'hex')
exports['eth-block'] = Buffer.from('90', 'hex')
exports['eth-block-list'] = Buffer.from('91', 'hex')
exports['eth-tx-trie'] = Buffer.from('92', 'hex')
exports['eth-tx'] = Buffer.from('93', 'hex')
exports['eth-tx-receipt-trie'] = Buffer.from('94', 'hex')
exports['eth-tx-receipt'] = Buffer.from('95', 'hex')
exports['eth-state-trie'] = Buffer.from('96', 'hex')
exports['eth-account-snapshot'] = Buffer.from('97', 'hex')
exports['eth-storage-trie'] = Buffer.from('98', 'hex')
exports['bitcoin-block'] = Buffer.from('b0', 'hex')
exports['bitcoin-tx'] = Buffer.from('b1', 'hex')
exports['zcash-block'] = Buffer.from('c0', 'hex')
exports['zcash-tx'] = Buffer.from('c1', 'hex')
exports['stellar-block'] = Buffer.from('d0', 'hex')
exports['stellar-tx'] = Buffer.from('d1', 'hex')
exports['decred-block'] = Buffer.from('e0', 'hex')
exports['decred-tx'] = Buffer.from('e1', 'hex')
exports['dash-block'] = Buffer.from('f0', 'hex')
exports['dash-tx'] = Buffer.from('f1', 'hex')
exports['swarm-manifest'] = Buffer.from('fa', 'hex')
exports['swarm-feed'] = Buffer.from('fb', 'hex')
exports['dag-json'] = Buffer.from('0129', 'hex')

// namespace
exports['path'] = Buffer.from('2f', 'hex')
exports['ipld-ns'] = Buffer.from('e2', 'hex')
exports['ipfs-ns'] = Buffer.from('e3', 'hex')
exports['swarm-ns'] = Buffer.from('e4', 'hex')
exports['ipns-ns'] = Buffer.from('e5', 'hex')
exports['zeronet'] = Buffer.from('e6', 'hex')

// key
exports['ed25519-pub'] = Buffer.from('ed', 'hex')

// holochain
exports['holochain-adr-v0'] = Buffer.from('807124', 'hex')
exports['holochain-adr-v1'] = Buffer.from('817124', 'hex')
exports['holochain-key-v0'] = Buffer.from('947124', 'hex')
exports['holochain-key-v1'] = Buffer.from('957124', 'hex')
exports['holochain-sig-v0'] = Buffer.from('a27124', 'hex')
exports['holochain-sig-v1'] = Buffer.from('a37124', 'hex')

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multicodec",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\base-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\cid-util.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\cids\src\cid-util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashes')

var CIDUtil = {
  /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string}
   */
  checkCIDComponents: function (other) {
    if (other == null) {
      return 'null values are not valid CIDs'
    }

    if (!(other.version === 0 || other.version === 1)) {
      return 'Invalid version, must be a number equal to 1 or 0'
    }

    if (typeof other.codec !== 'string') {
      return 'codec must be string'
    }

    if (other.version === 0) {
      if (other.codec !== 'dag-pb') {
        return `codec must be 'dag-pb' for CIDv0`
      }
      if (other.multibaseName !== 'base58btc') {
        return `multibaseName must be 'base58btc' for CIDv0`
      }
    }

    if (!Buffer.isBuffer(other.multihash)) {
      return 'multihash must be a Buffer'
    }

    try {
      mh.validate(other.multihash)
    } catch (err) {
      let errorMsg = err.message
      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
        errorMsg = 'Multihash validation failed'
      }
      return errorMsg
    }
  }
}

module.exports = CIDUtil

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"cids",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\cid-util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\utils.js", {"multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peer-info\src\utils.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')

function ensureMultiaddr (ma) {
  if (multiaddr.isMultiaddr(ma)) {
    return ma
  }

  return multiaddr(ma)
}

module.exports = {
  ensureMultiaddr: ensureMultiaddr
}

      };
    };
  }
}, {package:"peer-info",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\multiaddr-set.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\utils.js","unique-by":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\unique-by\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\peer-info\src\multiaddr-set.js
      return function (require, module, exports) {
'use strict'

const { ensureMultiaddr } = require('./utils')
const uniqBy = require('unique-by')

// Because JavaScript doesn't let you overload the compare in Set()..
class MultiaddrSet {
  constructor (multiaddrs) {
    this._multiaddrs = multiaddrs || []
    this._observedMultiaddrs = []
  }

  add (ma) {
    ma = ensureMultiaddr(ma)

    if (!this.has(ma)) {
      this._multiaddrs.push(ma)
    }
  }

  // addSafe - prevent multiaddr explosion™
  // Multiaddr explosion is when you dial to a bunch of nodes and every node
  // gives you a different observed address and you start storing them all to
  // share with other peers. This seems like a good idea until you realize that
  // most of those addresses are unique to the subnet that peer is in and so,
  // they are completely worthless for all the other peers. This method is
  // exclusively used by identify.
  addSafe (ma) {
    ma = ensureMultiaddr(ma)

    const check = this._observedMultiaddrs.some((m, i) => {
      if (m.equals(ma)) {
        this.add(ma)
        this._observedMultiaddrs.splice(i, 1)
        return true
      }
    })
    if (!check) {
      this._observedMultiaddrs.push(ma)
    }
  }

  toArray () {
    return this._multiaddrs.slice()
  }

  get size () {
    return this._multiaddrs.length
  }

  forEach (fn) {
    return this._multiaddrs.forEach(fn)
  }

  filterBy (maFmt) {
    if (typeof maFmt !== 'object' ||
      typeof maFmt.matches !== 'function' ||
      typeof maFmt.partialMatch !== 'function' ||
      typeof maFmt.toString !== 'function') return []

    return this._multiaddrs.filter((ma) => maFmt.matches(ma))
  }

  has (ma) {
    ma = ensureMultiaddr(ma)
    return this._multiaddrs.some((m) => m.equals(ma))
  }

  delete (ma) {
    ma = ensureMultiaddr(ma)

    this._multiaddrs.some((m, i) => {
      if (m.equals(ma)) {
        this._multiaddrs.splice(i, 1)
        return true
      }
    })
  }

  // replaces selected existing multiaddrs with new ones
  replace (existing, fresh) {
    if (!Array.isArray(existing)) {
      existing = [existing]
    }
    if (!Array.isArray(fresh)) {
      fresh = [fresh]
    }
    existing.forEach((m) => this.delete(m))
    fresh.forEach((m) => this.add(m))
  }

  clear () {
    this._multiaddrs = []
  }

  // this only really helps make ip6 and ip4 multiaddrs distinct if they are
  // different
  // TODO this is not an ideal solution, probably this code should just be
  // in libp2p-tcp
  distinct () {
    return uniqBy(this._multiaddrs, (ma) => {
      return [ma.toOptions().port, ma.toOptions().transport].join()
    })
  }
}

module.exports = MultiaddrSet

      };
    };
  }
}, {package:"peer-info",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\multiaddr-set.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superstruct\\lib\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\superstruct\lib\index.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Define a struct error.
 *
 * @type {StructError}
 */

class StructError extends TypeError {
  static format(attrs) {
    const { type, path, value } = attrs;
    const message = `Expected a value of type \`${type}\`${path.length ? ` for \`${path.join('.')}\`` : ''} but received \`${JSON.stringify(value)}\`.`;
    return message;
  }

  constructor(attrs) {
    const message = StructError.format(attrs);
    super(message);

    const { data, path, value, reason, type, errors = [] } = attrs;
    this.data = data;
    this.path = path;
    this.value = value;
    this.reason = reason;
    this.type = type;
    this.errors = errors;

    if (!errors.length) {
      errors.push(this);
    }

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
}

var toString = Object.prototype.toString;

var kindOf = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return val.constructor ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

/**
 * A private string to identify structs by.
 *
 * @type {String}
 */

const IS_STRUCT = '@@__STRUCT__@@';

/**
 * A private string to refer to a struct's kind.
 *
 * @type {String}
 */

const KIND = '@@__KIND__@@';

/**
 * Check if a `value` is a struct.
 *
 * @param {Any} value
 * @return {Boolean}
 */

function isStruct(value) {
  return !!(value && value[IS_STRUCT]);
}

/**
 * Resolve `defaults`, for an optional `value`.
 *
 * @param {Function|Any} defaults
 * @param {Any} value
 * @return {Any}
 */

function resolveDefaults(defaults, value) {
  return typeof defaults === 'function' ? defaults(value) : defaults;
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Kind.
 *
 * @type {Kind}
 */

class Kind {
  constructor(name, type, validate) {
    this.name = name;
    this.type = type;
    this.validate = validate;
  }
}

/**
 * Any.
 *
 * @param {Array|Function|Object|String} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function any(schema, defaults$$1, options) {
  if (isStruct(schema)) {
    return schema[KIND];
  }

  if (schema instanceof Kind) {
    return schema;
  }

  switch (kindOf(schema)) {
    case 'array':
      {
        return schema.length > 1 ? tuple(schema, defaults$$1, options) : list(schema, defaults$$1, options);
      }

    case 'function':
      {
        return func(schema, defaults$$1, options);
      }

    case 'object':
      {
        return object(schema, defaults$$1, options);
      }

    case 'string':
      {
        let required = true;
        let type;

        if (schema.endsWith('?')) {
          required = false;
          schema = schema.slice(0, -1);
        }

        if (schema.includes('|')) {
          const scalars = schema.split(/\s*\|\s*/g);
          type = union(scalars, defaults$$1, options);
        } else if (schema.includes('&')) {
          const scalars = schema.split(/\s*&\s*/g);
          type = intersection(scalars, defaults$$1, options);
        } else {
          type = scalar(schema, defaults$$1, options);
        }

        if (!required) {
          type = optional(type, undefined, options);
        }

        return type;
      }
  }

  if ("development" !== 'production') {
    throw new Error(`A schema definition must be an object, array, string or function, but you passed: ${schema}`);
  } else {
    throw new Error(`Invalid schema: ${schema}`);
  }
}

/**
 * Dict.
 *
 * @param {Array} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function dict(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array' || schema.length !== 2) {
    if ("development" !== 'production') {
      throw new Error(`Dict structs must be defined as an array with two elements, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const keys = any(schema[0], undefined, options);
  const values = any(schema[1], undefined, options);
  const name = 'dict';
  const type = `dict<${keys.type},${values.type}>`;
  const validate = value => {
    const resolved = resolveDefaults(defaults$$1);
    value = resolved ? _extends({}, resolved, value) : value;
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const ret = {};
    const errors = [];

    for (let k in value) {
      const v = value[k];
      const [e, r] = keys.validate(k);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [k].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      k = r;
      const [e2, r2] = values.validate(v);

      if (e2) {
        const allE2 = e2.errors || [e2];
        allE2.forEach(singleE => {
          singleE.path = [k].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[k] = r2;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Enum.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function en(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Enum structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const name = 'enum';
  const type = schema.map(s => {
    try {
      return JSON.stringify(s);
    } catch (e) {
      return String(s);
    }
  }).join(' | ');

  const validate = (value = resolveDefaults(defaults$$1)) => {
    return schema.includes(value) ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Enums.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function enums(schema, defaults$$1, options) {
  const e = en(schema, undefined, options);
  const l = list([e], defaults$$1, options);
  return l;
}

/**
 * Function.
 *
 * @param {Function} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function func(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Function structs must be defined as a function, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const name = 'function';
  const type = '<function>';
  const validate = (value = resolveDefaults(defaults$$1), data) => {
    const result = schema(value, data);
    let failure = { path: [], reason: null };
    let isValid;

    switch (kindOf(result)) {
      case 'boolean':
        {
          isValid = result;
          break;
        }
      case 'string':
        {
          isValid = false;
          failure.reason = result;
          break;
        }
      case 'object':
        {
          isValid = false;
          failure = _extends({}, failure, result);
          break;
        }
      default:
        {
          if ("development" !== 'production') {
            throw new Error(`Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`);
          } else {
            throw new Error(`Invalid result: ${result}`);
          }
        }
    }

    return isValid ? [undefined, value] : [_extends({ type, value, data: value }, failure)];
  };

  return new Kind(name, type, validate);
}

/**
 * Instance.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function instance(schema, defaults$$1, options) {
  const name = 'instance';
  const type = `instance<${schema.name}>`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    return value instanceof schema ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Interface.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function inter(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Interface structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'interface';
  const type = `{${ks.join()}}`;
  const validate = value => {
    const resolved = resolveDefaults(defaults$$1);
    value = resolved ? _extends({}, resolved, value) : value;
    const errors = [];
    const ret = value;

    for (const key in properties) {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Lazy.
 *
 * @param {Function} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function lazy(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  let kind;
  let struct;
  const name = 'lazy';
  const type = `lazy...`;
  const compile = value => {
    struct = schema();
    kind.name = struct.kind;
    kind.type = struct.type;
    kind.validate = struct.validate;
    return kind.validate(value);
  };

  kind = new Kind(name, type, compile);
  return kind;
}

/**
 * Dynamic.
 *
 * @param {Function} createSchema
 * @param {Any} defaults
 * @param {Object} options
 */

function dynamic(createSchema, defaults$$1, options) {
  if (kindOf(createSchema) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`Dynamic structs must be defined as a function, but you passed: ${createSchema}`);
    } else {
      throw new Error(`Invalid schema: ${createSchema}`);
    }
  }

  const name = 'dynamic';
  const type = 'dynamic...';
  const validate = (value = resolveDefaults(defaults$$1), data) => {
    const schema = createSchema(value, data);

    if (kindOf(schema) !== 'function') {
      if ("development" !== 'production') {
        throw new Error(`Dynamic structs must return a schema, but you passed: ${schema}`);
      } else {
        throw new Error(`Invalid schema: ${schema}`);
      }
    }

    const [error, result] = schema.validate(value);

    if (error) {
      return [error];
    }

    return [undefined, result];
  };

  return new Kind(name, type, validate);
}

/**
 * List.
 *
 * @param {Array} schema
 * @param {Array} defaults
 * @param {Object} options
 */

function list(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array' || schema.length !== 1) {
    if ("development" !== 'production') {
      throw new Error(`List structs must be defined as an array with a single element, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const array = scalar('array', undefined, options);
  const element = any(schema[0], undefined, options);
  const name = 'list';
  const type = `[${element.type}]`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error, result] = array.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    value = result;
    const errors = [];
    const ret = [];

    for (let i = 0; i < value.length; i++) {
      const v = value[i];
      const [e, r] = element.validate(v);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [i].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[i] = r;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Literal.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function literal(schema, defaults$$1, options) {
  const name = 'literal';
  const type = `literal: ${JSON.stringify(schema)}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    return value === schema ? [undefined, value] : [{ data: value, path: [], value, type }];
  };

  return new Kind(name, type, validate);
}

/**
 * Object.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function object(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Object structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'object';
  const type = `{${ks.join()}}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const errors = [];
    const ret = {};
    const valueKeys = Object.keys(value);
    const propertiesKeys = Object.keys(properties);
    const keys = new Set(valueKeys.concat(propertiesKeys));

    keys.forEach(key => {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      if (!kind) {
        const e = { data: value, path: [key], value: v };
        errors.push(e);
        return;
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        return;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    });

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Optional.
 *
 * @param {Any} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function optional(schema, defaults$$1, options) {
  return union([schema, 'undefined'], defaults$$1, options);
}

/**
 * Partial.
 *
 * @param {Object} schema
 * @param {Object} defaults
 * @param {Object} options
 */

function partial(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'object') {
    if ("development" !== 'production') {
      throw new Error(`Partial structs must be defined as an object, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const obj = scalar('object', undefined, options);
  const ks = [];
  const properties = {};

  for (const key in schema) {
    ks.push(key);
    const s = schema[key];
    const kind = any(s, undefined, options);
    properties[key] = kind;
  }

  const name = 'partial';
  const type = `{${ks.join()},...}`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = obj.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const errors = [];
    const ret = {};

    for (const key in properties) {
      let v = value[key];
      const kind = properties[key];

      if (v === undefined) {
        const d = defaults$$1 && defaults$$1[key];
        v = resolveDefaults(d, value);
      }

      const [e, r] = kind.validate(v, value);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [key].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      if (key in value || r !== undefined) {
        ret[key] = r;
      }
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Scalar.
 *
 * @param {String} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function scalar(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'string') {
    if ("development" !== 'production') {
      throw new Error(`Scalar structs must be defined as a string, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const { types } = options;
  const fn = types[schema];

  if (kindOf(fn) !== 'function') {
    if ("development" !== 'production') {
      throw new Error(`No struct validator function found for type "${schema}".`);
    } else {
      throw new Error(`Invalid type: ${schema}`);
    }
  }

  const kind = func(fn, defaults$$1, options);
  const name = 'scalar';
  const type = schema;
  const validate = value => {
    const [error, result] = kind.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    return [undefined, result];
  };

  return new Kind(name, type, validate);
}

/**
 * Tuple.
 *
 * @param {Array} schema
 * @param {Array} defaults
 * @param {Object} options
 */

function tuple(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Tuple structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const kinds = schema.map(s => any(s, undefined, options));
  const array = scalar('array', undefined, options);
  const name = 'tuple';
  const type = `[${kinds.map(k => k.type).join()}]`;
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const [error] = array.validate(value);

    if (error) {
      error.type = type;
      return [error];
    }

    const ret = [];
    const errors = [];
    const length = Math.max(value.length, kinds.length);

    for (let i = 0; i < length; i++) {
      const kind = kinds[i];
      const v = value[i];

      if (!kind) {
        const e = { data: value, path: [i], value: v };
        errors.push(e);
        continue;
      }

      const [e, r] = kind.validate(v);

      if (e) {
        const allE = e.errors || [e];
        allE.forEach(singleE => {
          singleE.path = [i].concat(singleE.path);
          singleE.data = value;
          errors.push(singleE);
        });
        continue;
      }

      ret[i] = r;
    }

    if (errors.length) {
      const first = errors[0];
      first.errors = errors;
      return [first];
    }

    return [undefined, ret];
  };

  return new Kind(name, type, validate);
}

/**
 * Union.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function union(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Union structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const kinds = schema.map(s => any(s, undefined, options));
  const name = 'union';
  const type = kinds.map(k => k.type).join(' | ');
  const validate = (value = resolveDefaults(defaults$$1)) => {
    const errors = [];

    for (const k of kinds) {
      const [e, r] = k.validate(value);

      if (!e) {
        return [undefined, r];
      }

      errors.push(e);
    }
    errors[0].type = type;
    return errors;
  };

  return new Kind(name, type, validate);
}

/**
 * Intersection.
 *
 * @param {Array} schema
 * @param {Any} defaults
 * @param {Object} options
 */

function intersection(schema, defaults$$1, options) {
  if (kindOf(schema) !== 'array') {
    if ("development" !== 'production') {
      throw new Error(`Intersection structs must be defined as an array, but you passed: ${schema}`);
    } else {
      throw new Error(`Invalid schema: ${schema}`);
    }
  }

  const types = schema.map(s => any(s, undefined, options));
  const name = 'intersection';
  const type = types.map(t => t.type).join(' & ');
  const validate = (value = resolveDefaults(defaults$$1)) => {
    let v = value;

    for (const t of types) {
      const [e, r] = t.validate(v);

      if (e) {
        e.type = type;
        return [e];
      }

      v = r;
    }

    return [undefined, v];
  };

  return new Kind(name, type, validate);
}

/**
 * Kinds.
 *
 * @type {Object}
 */

const Kinds = {
  any,
  dict,
  enum: en,
  enums,
  function: func,
  instance,
  interface: inter,
  lazy,
  list,
  literal,
  object,
  optional,
  partial,
  scalar,
  tuple,
  union,
  intersection,
  dynamic

  /**
   * Export.
   *
   * @type {Object}
   */

};

/**
 * The types that `kind-of` supports.
 *
 * @type {Array}
 */

const TYPES = ['arguments', 'array', 'boolean', 'buffer', 'error', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'promise', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];

/**
 * The default types that Superstruct ships with.
 *
 * @type {Object}
 */

const Types = {
  any: value => value !== undefined
};

TYPES.forEach(type => {
  Types[type] = value => kindOf(value) === type;
});

/**
 * Handle the 'date' case specially, to throw out invalid `Date` objects.
 *
 * @param {Mixed} value
 * @return {Boolean}
 */

Types.date = value => kindOf(value) === 'date' && !isNaN(value);

/**
 * Create a struct factory with a `config`.
 *
 * @param {Object} config
 * @return {Function}
 */

function superstruct(config = {}) {
  const types = _extends({}, Types, config.types || {});

  /**
   * Create a `kind` struct with `schema`, `defaults` and `options`.
   *
   * @param {Any} schema
   * @param {Any} defaults
   * @param {Object} options
   * @return {Function}
   */

  function struct(schema, defaults$$1, options = {}) {
    if (isStruct(schema)) {
      schema = schema.schema;
    }

    const kind = Kinds.any(schema, defaults$$1, _extends({}, options, { types }));

    function Struct(data) {
      if (this instanceof Struct) {
        if ("development" !== 'production') {
          throw new Error('The `Struct` creation function should not be used with the `new` keyword.');
        } else {
          throw new Error('Invalid `new` keyword!');
        }
      }

      return Struct.assert(data);
    }

    Object.defineProperty(Struct, IS_STRUCT, { value: true });
    Object.defineProperty(Struct, KIND, { value: kind });

    Struct.kind = kind.name;
    Struct.type = kind.type;
    Struct.schema = schema;
    Struct.defaults = defaults$$1;
    Struct.options = options;

    Struct.assert = value => {
      const [error, result] = kind.validate(value);

      if (error) {
        throw new StructError(error);
      }

      return result;
    };

    Struct.test = value => {
      const [error] = kind.validate(value);
      return !error;
    };

    Struct.validate = value => {
      const [error, result] = kind.validate(value);

      if (error) {
        return [new StructError(error)];
      }

      return [undefined, result];
    };

    return Struct;
  }

  /**
   * Mix in a factory for each specific kind of struct.
   */

  Object.keys(Kinds).forEach(name => {
    const kind = Kinds[name];

    struct[name] = (schema, defaults$$1, options) => {
      const type = kind(schema, defaults$$1, _extends({}, options, { types }));
      const s = struct(type, defaults$$1, options);
      return s;
    };
  });

  /**
   * Return the struct factory.
   */

  return struct;
}

/**
 * Create a convenience `struct` factory for the default types.
 *
 * @type {Function}
 */

const struct = superstruct();

exports.struct = struct;
exports.superstruct = superstruct;
exports.isStruct = isStruct;
exports.StructError = StructError;
//# sourceMappingURL=index.js.map

      };
    };
  }
}, {package:"superstruct",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\superstruct\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\index.js", {"../random-bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\random-bytes.js","./ed25519-class":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\ed25519-class.js","./ephemeral-keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\ephemeral-keys.js","./key-stretcher":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\key-stretcher.js","./keys.proto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\keys.proto.js","./rsa-class":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\rsa-class.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","libp2p-crypto-secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\libp2p-crypto-secp256k1\\src\\index.js","node-forge/lib/asn1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\asn1.js","node-forge/lib/forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","node-forge/lib/pbe":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pbe.js","node-forge/lib/rsa":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\rsa.js","protons":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\protons\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-crypto\src\keys\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const protobuf = require('protons')
const keysPBM = protobuf(require('./keys.proto'))
require('node-forge/lib/asn1')
require('node-forge/lib/rsa')
require('node-forge/lib/pbe')
const forge = require('node-forge/lib/forge')

exports = module.exports

const supportedKeys = {
  rsa: require('./rsa-class'),
  ed25519: require('./ed25519-class'),
  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))
}

exports.supportedKeys = supportedKeys
exports.keysPBM = keysPBM

function isValidKeyType (keyType) {
  const key = supportedKeys[keyType.toLowerCase()]
  return key !== undefined
}

exports.keyStretcher = require('./key-stretcher')
exports.generateEphemeralKeyPair = require('./ephemeral-keys')

// Generates a keypair of the given type and bitsize
exports.generateKeyPair = (type, bits, cb) => {
  let key = supportedKeys[type.toLowerCase()]

  if (!key) {
    return cb(new Error('invalid or unsupported key type'))
  }

  key.generateKeyPair(bits, cb)
}

// Generates a keypair of the given type and bitsize
// seed is a 32 byte uint8array
exports.generateKeyPairFromSeed = (type, seed, bits, cb) => {
  let key = supportedKeys[type.toLowerCase()]
  if (!key) {
    return cb(new Error('invalid or unsupported key type'))
  }
  if (type.toLowerCase() !== 'ed25519') {
    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'))
  }
  key.generateKeyPairFromSeed(seed, bits, cb)
}

// Converts a protobuf serialized public key into its
// representative object
exports.unmarshalPublicKey = (buf) => {
  const decoded = keysPBM.PublicKey.decode(buf)
  const data = decoded.Data

  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data)
    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)
    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)
      } else {
        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package')
      }
    default:
      throw new Error('invalid or unsupported key type')
  }
}

// Converts a public key object into a protobuf serialized public key
exports.marshalPublicKey = (key, type) => {
  type = (type || 'rsa').toLowerCase()
  if (!isValidKeyType(type)) {
    throw new Error('invalid or unsupported key type')
  }

  return key.bytes
}

// Converts a protobuf serialized private key into its
// representative object
exports.unmarshalPrivateKey = (buf, callback) => {
  let decoded
  try {
    decoded = keysPBM.PrivateKey.decode(buf)
  } catch (err) {
    return callback(err)
  }

  const data = decoded.Data

  switch (decoded.Type) {
    case keysPBM.KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback)
    case keysPBM.KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback)
    case keysPBM.KeyType.Secp256k1:
      if (supportedKeys.secp256k1) {
        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback)
      } else {
        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'))
      }
    default:
      callback(new Error('invalid or unsupported key type'))
  }
}

// Converts a private key object into a protobuf serialized private key
exports.marshalPrivateKey = (key, type) => {
  type = (type || 'rsa').toLowerCase()
  if (!isValidKeyType(type)) {
    throw new Error('invalid or unsupported key type')
  }

  return key.bytes
}

exports.import = (pem, password, callback) => {
  try {
    const key = forge.pki.decryptRsaPrivateKey(pem, password)
    if (key === null) {
      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key')
    }
    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))
    der = Buffer.from(der.getBytes(), 'binary')
    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback)
  } catch (err) {
    callback(err)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-crypto",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\keys\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\util.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipld\src\util.js
      return function (require, module, exports) {
'use strict'

exports.first = async (iterator) => {
  for await (const value of iterator) {
    return value
  }
}

exports.last = async (iterator) => {
  let value
  for await (value of iterator) {
    // Intentionally empty
  }
  return value
}

exports.all = async (iterator) => {
  const values = []
  for await (const value of iterator) {
    values.push(value)
  }
  return values
}

exports.extendIterator = (iterator) => {
  iterator.first = () => exports.first(iterator)
  iterator.last = () => exports.last(iterator)
  iterator.all = () => exports.all(iterator)
  return iterator
}

      };
    };
  }
}, {package:"ipld",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js", {"./dag-link":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\dag-link\\index.js","./dag-node":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\dag-node\\index.js","./resolver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\resolver.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipld-dag-pb\src\index.js
      return function (require, module, exports) {
'use strict'

exports.DAGNode = require('./dag-node')
exports.DAGLink = require('./dag-link')

/*
 * Functions to fulfil IPLD Format interface
 * https://github.com/ipld/interface-ipld-format
 */
exports.resolver = require('./resolver')
exports.util = require('./util')
exports.codec = exports.util.codec
exports.defaultHashAlg = exports.util.defaultHashAlg

      };
    };
  }
}, {package:"ipld-dag-pb",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\index.js", {"./resolver.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\resolver.js","./util.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipld-dag-cbor\src\index.js
      return function (require, module, exports) {
'use strict'

exports.util = require('./util.js')
exports.resolver = require('./resolver.js')
exports.codec = exports.util.codec
exports.defaultHashAlg = exports.util.defaultHashAlg

      };
    };
  }
}, {package:"ipld-dag-cbor",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-cbor\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-raw\\src\\index.js", {"cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","multihashing-async":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashing-async\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipld-raw\src\index.js
      return function (require, module, exports) {
'use strict'
const CID = require('cids')
const multihashing = require('multihashing-async')
const multicodec = require('multicodec')

// binary resolver
module.exports = {
  codec: multicodec.RAW,
  defaultHashAlg: multicodec.SHA2_256,
  resolver: {
    /**
     * Resolves a path within a Raw block.
     *
     * Always returns the raw data as value without any remainderPath.
     *
     * @param {Buffer} binaryBlob - Binary representation of a PB block
     * @param {string} [path='/'] - Path that should be resolved (that value is ignored)
     * @returns {Object} result - Result of the path it it was resolved successfully
     * @returns {*} result.value - The raw data
     * @returns {string} result.remainderPath - An empty string
     */
    resolve: (binaryBlob, path) => {
      return {
        value: binaryBlob,
        remainderPath: ''
      }
    },
    /**
     * Return all available paths of a block.
     *
     * @generator
     * @param {Buffer} binaryBlob - The raw data
     * @returns {Object} - Finished generator with `done: true`
     */
    tree: (binaryBlob) => {
      return {
        done: true
      }
    }
  },
  util: {
    deserialize: (data) => {
      return data
    },
    serialize: (data) => {
      return data
    },
    /**
     * Calculate the CID of the binary blob.
     *
     * @param {Object} binaryBlob - Encoded IPLD Node
     * @param {Object} [userOptions] - Options to create the CID
     * @param {number} [userOptions.cidVersion=1] - CID version number
     * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format
     * @returns {Promise.<CID>}
     */
    cid: async (binaryBlob, userOptions) => {
      const defaultOptions = { cidVersion: 1, hashAlg: module.exports.defaultHashAlg }
      const options = Object.assign(defaultOptions, userOptions)

      const multihash = await multihashing(binaryBlob, options.hashAlg)
      const codecName = multicodec.print[module.exports.codec]
      const cid = new CID(options.cidVersion, codecName, multihash)

      return cid
    }
  }
}

      };
    };
  }
}, {package:"ipld-raw",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-raw\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promisify-es6\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\promisify-es6\index.js
      return function (require, module, exports) {
/** PROMISIFY CALLBACK-STYLE FUNCTIONS TO ES6 PROMISES
*
* EXAMPLE:
* const fn = promisify( (callback) => callback(null, "Hello world!") );
* fn((err, str) => console.log(str));
* fn().then((str) => console.log(str));
* //Both functions, will log 'Hello world!'
*
* Note: The function you pass, may have any arguments you want, but the latest
* have to be the callback, which you will call with: next(err, value)
*
* @param method: Function/Array/Map = The function(s) to promisify
* @param options: Map =
*  "context" (default is function): The context which to apply the called function
*  "replace" (default is falsy): When passed an array/map, if to replace the original object
*
* @return: A promise if passed a function, otherwise the object with the promises
*
* @license: MIT
* @version: 1.0.3
* @author: Manuel Di Iorio
**/

var createCallback = function (method, context) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        var lastIndex = args.length - 1;
        var lastArg = args && args.length > 0 ? args[lastIndex] : null;
        var cb = typeof lastArg === 'function' ? lastArg : null;

        if (cb) {
            return method.apply(context, args);
        }

        return new Promise(function (resolve, reject) {
            args.push(function (err, val) {
                if (err) return reject(err);
                resolve(val);
            });

            method.apply(context, args);
        });
    };
};

if (typeof module === "undefined") module = {}; // Browserify this module

module.exports = function (methods, options) {
    options = options || {};
    var type = Object.prototype.toString.call(methods);

    if (type === "[object Object]" || type === "[object Array]") {
        var obj = options.replace ? methods : {};

        for (var key in methods) {
            if (methods.hasOwnProperty(key)) obj[key] = createCallback(methods[key]);
        }return obj;
    }

    return createCallback(methods, options.context || methods);
};

// Browserify this module
if (typeof exports === "undefined") {
    this["promisify"] = module.exports;
}

      };
    };
  }
}, {package:"promisify-es6",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promisify-es6\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\typical\\dist\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\typical\dist\index.js
      return function (require, module, exports) {
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.typical = {}));
}(this, function (exports) { 'use strict';

  /**
   * For type-checking Javascript values.
   * @module typical
   * @typicalname t
   * @example
   * const t = require('typical')
   */

  /**
   * Returns true if input is a number
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isNumber(0)
   * true
   * > t.isNumber(1)
   * true
   * > t.isNumber(1.1)
   * true
   * > t.isNumber(0xff)
   * true
   * > t.isNumber(0644)
   * true
   * > t.isNumber(6.2e5)
   * true
   * > t.isNumber(NaN)
   * false
   * > t.isNumber(Infinity)
   * false
   */
  function isNumber (n) {
    return !isNaN(parseFloat(n)) && isFinite(n)
  }

  /**
   * A plain object is a simple object literal, it is not an instance of a class. Returns true if the input `typeof` is `object` and directly decends from `Object`.
   *
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isPlainObject({ something: 'one' })
   * true
   * > t.isPlainObject(new Date())
   * false
   * > t.isPlainObject([ 0, 1 ])
   * false
   * > t.isPlainObject(/test/)
   * false
   * > t.isPlainObject(1)
   * false
   * > t.isPlainObject('one')
   * false
   * > t.isPlainObject(null)
   * false
   * > t.isPlainObject((function * () {})())
   * false
   * > t.isPlainObject(function * () {})
   * false
   */
  function isPlainObject (input) {
    return input !== null && typeof input === 'object' && input.constructor === Object
  }

  /**
   * An array-like value has all the properties of an array, but is not an array instance. Examples in the `arguments` object. Returns true if the input value is an object, not null and has a `length` property with a numeric value.
   *
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * function sum(x, y){
   *   console.log(t.isArrayLike(arguments))
   *   // prints `true`
   * }
   */
  function isArrayLike (input) {
    return isObject(input) && typeof input.length === 'number'
  }

  /**
   * Returns true if the typeof input is `'object'` but not null.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isObject (input) {
    return typeof input === 'object' && input !== null
  }

  /**
   * Returns true if the input value is defined.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isDefined (input) {
    return typeof input !== 'undefined'
  }

  /**
   * Returns true if the input value is an ES2015 `class`.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isClass (input) {
    if (typeof input === 'function') {
      return /^class /.test(Function.prototype.toString.call(input))
    } else {
      return false
    }
  }

  /**
   * Returns true if the input is a string, number, symbol, boolean, null or undefined value.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isPrimitive (input) {
    if (input === null) return true
    switch (typeof input) {
      case 'string':
      case 'number':
      case 'symbol':
      case 'undefined':
      case 'boolean':
        return true
      default:
        return false
    }
  }

  /**
   * Returns true if the input is a Promise.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isPromise (input) {
    if (input) {
      const isPromise = isDefined(Promise) && input instanceof Promise;
      const isThenable = input.then && typeof input.then === 'function';
      return !!(isPromise || isThenable)
    } else {
      return false
    }
  }

  /**
   * Returns true if the input is an iterable (`Map`, `Set`, `Array`, Generator etc.).
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   * @example
   * > t.isIterable('string')
   * true
   * > t.isIterable(new Map())
   * true
   * > t.isIterable([])
   * true
   * > t.isIterable((function * () {})())
   * true
   * > t.isIterable(Promise.resolve())
   * false
   * > t.isIterable(Promise)
   * false
   * > t.isIterable(true)
   * false
   * > t.isIterable({})
   * false
   * > t.isIterable(0)
   * false
   * > t.isIterable(1.1)
   * false
   * > t.isIterable(NaN)
   * false
   * > t.isIterable(Infinity)
   * false
   * > t.isIterable(function () {})
   * false
   * > t.isIterable(Date)
   * false
   * > t.isIterable()
   * false
   * > t.isIterable({ then: function () {} })
   * false
   */
  function isIterable (input) {
    if (input === null || !isDefined(input)) {
      return false
    } else {
      return (
        typeof input[Symbol.iterator] === 'function' ||
        typeof input[Symbol.asyncIterator] === 'function'
      )
    }
  }

  /**
   * Returns true if the input value is a string. The equivalent of `typeof input === 'string'`` for use in funcitonal contexts.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isString (input) {
    return typeof input === 'string'
  }

  /**
   * Returns true if the input value is a function. The equivalent of `typeof input === 'function'`` for use in funcitonal contexts.
   * @param {*} - the input to test
   * @returns {boolean}
   * @static
   */
  function isFunction (input) {
    return typeof input === 'function'
  }

  var index = {
    isNumber,
    isPlainObject,
    isArrayLike,
    isObject,
    isDefined,
    isClass,
    isPrimitive,
    isPromise,
    isIterable,
    isString,
    isFunction
  };

  exports.default = index;
  exports.isArrayLike = isArrayLike;
  exports.isClass = isClass;
  exports.isDefined = isDefined;
  exports.isFunction = isFunction;
  exports.isIterable = isIterable;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPlainObject = isPlainObject;
  exports.isPrimitive = isPrimitive;
  exports.isPromise = isPromise;
  exports.isString = isString;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

      };
    };
  }
}, {package:"typical",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\typical\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block\\src\\index.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-block\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const CID = require('cids')
const withIs = require('class-is')

/**
 * Represents an immutable block of data that is uniquely referenced with a cid.
 *
 * @constructor
 * @param {Buffer} data - The data to be stored in the block as a buffer.
 * @param {CID} cid - The cid of the data
 *
 * @example
 * const block = new Block(new Buffer('a012d83b20f9371...'))
 */
class Block {
  constructor (data, cid) {
    if (!data || !Buffer.isBuffer(data)) {
      throw new Error('first argument  must be a buffer')
    }

    if (!cid || !CID.isCID(cid)) {
      throw new Error('second argument must be a CID')
    }

    this._data = data
    this._cid = cid
  }

  /**
   * The data of this block.
   *
   * @type {Buffer}
   */
  get data () {
    return this._data
  }

  set data (val) {
    throw new Error('Tried to change an immutable block')
  }

  /**
   * The cid of the data this block represents.
   *
   * @type {CID}
   */
  get cid () {
    return this._cid
  }

  set cid (val) {
    throw new Error('Tried to change an immutable block')
  }
}

module.exports = withIs(Block, { className: 'Block', symbolName: '@ipfs/js-ipfs-block/block' })

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs-block",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-block\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\constants.js", {"./base.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\base.js","./base16":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\base16.js","./base32":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\base32.js","./base64":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\base64.js","base-x":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\node_modules\\base-x\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multibase\src\constants.js
      return function (require, module, exports) {
'use strict'

const Base = require('./base.js')
const baseX = require('base-x')
const base16 = require('./base16')
const base32 = require('./base32')
const base64 = require('./base64')

// name, code, implementation, alphabet
const constants = [
  ['base1', '1', '', '1'],
  ['base2', '0', baseX, '01'],
  ['base8', '7', baseX, '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', base16, '0123456789abcdef'],
  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names: names,
  codes: codes
}

      };
    };
  }
}, {package:"multibase",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multibase\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\protocols-table.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multiaddr\src\protocols-table.js
      return function (require, module, exports) {
'use strict'

function Protocols (proto) {
  if (typeof (proto) === 'number') {
    if (Protocols.codes[proto]) {
      return Protocols.codes[proto]
    }

    throw new Error('no protocol with code: ' + proto)
  } else if (typeof (proto) === 'string' || proto instanceof String) {
    if (Protocols.names[proto]) {
      return Protocols.names[proto]
    }

    throw new Error('no protocol with name: ' + proto)
  }

  throw new Error('invalid protocol id type: ' + proto)
}

const V = -1
Protocols.lengthPrefixedVarSize = V
Protocols.V = V

Protocols.table = [
  [4, 32, 'ip4'],
  [6, 16, 'tcp'],
  [33, 16, 'dccp'],
  [41, 128, 'ip6'],
  [42, V, 'ip6zone'],
  [53, V, 'dns', 'resolvable'],
  [54, V, 'dns4', 'resolvable'],
  [55, V, 'dns6', 'resolvable'],
  [56, V, 'dnsaddr', 'resolvable'],
  [132, 16, 'sctp'],
  [273, 16, 'udp'],
  [275, 0, 'p2p-webrtc-star'],
  [276, 0, 'p2p-webrtc-direct'],
  [277, 0, 'p2p-stardust'],
  [290, 0, 'p2p-circuit'],
  [301, 0, 'udt'],
  [302, 0, 'utp'],
  [400, V, 'unix', false, 'path'],
  // `p2p` is the preferred name for 421
  [421, V, 'p2p'],
  // `ipfs` has been added after `p2p` so that it is used by default.
  // The reason for this is to provide better backwards support for
  // code bases that do not yet support the `p2p` proto name. Eventually
  // `p2p` should become the default.
  [421, V, 'ipfs'],
  [443, 0, 'https'],
  [444, 96, 'onion'],
  [445, 296, 'onion3'],
  [446, V, 'garlic64'],
  [460, 0, 'quic'],
  [477, 0, 'ws'],
  [478, 0, 'wss'],
  [479, 0, 'p2p-websocket-star'],
  [480, 0, 'http']
]

Protocols.names = {}
Protocols.codes = {}

// populate tables
Protocols.table.map(row => {
  const proto = p.apply(null, row)
  Protocols.codes[proto.code] = proto
  Protocols.names[proto.name] = proto
})

Protocols.object = p

function p (code, size, name, resolvable, path) {
  return {
    code: code,
    size: size,
    name: name,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  }
}

module.exports = Protocols

      };
    };
  }
}, {package:"multiaddr",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\protocols-table.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\codec.js", {"./convert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\convert.js","./protocols-table":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\protocols-table.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multiaddr\src\codec.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const convert = require('./convert')
const protocols = require('./protocols-table')
const varint = require('varint')

// export codec
module.exports = {
  stringToStringTuples: stringToStringTuples,
  stringTuplesToString: stringTuplesToString,

  tuplesToStringTuples: tuplesToStringTuples,
  stringTuplesToTuples: stringTuplesToTuples,

  bufferToTuples: bufferToTuples,
  tuplesToBuffer: tuplesToBuffer,

  bufferToString: bufferToString,
  stringToBuffer: stringToBuffer,

  fromString: fromString,
  fromBuffer: fromBuffer,
  validateBuffer: validateBuffer,
  isValidBuffer: isValidBuffer,
  cleanPath: cleanPath,

  ParseError: ParseError,
  protoFromTuple: protoFromTuple,

  sizeForAddr: sizeForAddr
}

// string -> [[str name, str addr]... ]
function stringToStringTuples (str) {
  const tuples = []
  const parts = str.split('/').slice(1) // skip first empty elem
  if (parts.length === 1 && parts[0] === '') {
    return []
  }

  for (let p = 0; p < parts.length; p++) {
    const part = parts[p]
    const proto = protocols(part)

    if (proto.size === 0) {
      tuples.push([part])
      continue
    }

    p++ // advance addr part
    if (p >= parts.length) {
      throw ParseError('invalid address: ' + str)
    }

    // if it's a path proto, take the rest
    if (proto.path) {
      tuples.push([
        part,
        // TODO: should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join('/'))
      ])
      break
    }

    tuples.push([part, parts[p]])
  }

  return tuples
}

// [[str name, str addr]... ] -> string
function stringTuplesToString (tuples) {
  const parts = []
  tuples.map(tup => {
    const proto = protoFromTuple(tup)
    parts.push(proto.name)
    if (tup.length > 1) {
      parts.push(tup[1])
    }
  })

  return cleanPath(parts.join('/'))
}

// [[str name, str addr]... ] -> [[int code, Buffer]... ]
function stringTuplesToTuples (tuples) {
  return tuples.map(tup => {
    if (!Array.isArray(tup)) {
      tup = [tup]
    }
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toBuffer(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Buffer]... ] -> [[str name, str addr]... ]
function tuplesToStringTuples (tuples) {
  return tuples.map(tup => {
    const proto = protoFromTuple(tup)
    if (tup.length > 1) {
      return [proto.code, convert.toString(proto.code, tup[1])]
    }
    return [proto.code]
  })
}

// [[int code, Buffer ]... ] -> Buffer
function tuplesToBuffer (tuples) {
  return fromBuffer(Buffer.concat(tuples.map(tup => {
    const proto = protoFromTuple(tup)
    let buf = Buffer.from(varint.encode(proto.code))

    if (tup.length > 1) {
      buf = Buffer.concat([buf, tup[1]]) // add address buffer
    }

    return buf
  })))
}

function sizeForAddr (p, addr) {
  if (p.size > 0) {
    return p.size / 8
  } else if (p.size === 0) {
    return 0
  } else {
    const size = varint.decode(addr)
    return size + varint.decode.bytes
  }
}

// Buffer -> [[int code, Buffer ]... ]
function bufferToTuples (buf) {
  const tuples = []
  let i = 0
  while (i < buf.length) {
    const code = varint.decode(buf, i)
    const n = varint.decode.bytes

    const p = protocols(code)

    const size = sizeForAddr(p, buf.slice(i + n))

    if (size === 0) {
      tuples.push([code])
      i += n
      continue
    }

    const addr = buf.slice(i + n, i + n + size)

    i += (size + n)

    if (i > buf.length) { // did not end _exactly_ at buffer.length
      throw ParseError('Invalid address buffer: ' + buf.toString('hex'))
    }

    // ok, tuple seems good.
    tuples.push([code, addr])
  }

  return tuples
}

// Buffer -> String
function bufferToString (buf) {
  const a = bufferToTuples(buf)
  const b = tuplesToStringTuples(a)
  return stringTuplesToString(b)
}

// String -> Buffer
function stringToBuffer (str) {
  str = cleanPath(str)
  const a = stringToStringTuples(str)
  const b = stringTuplesToTuples(a)

  return tuplesToBuffer(b)
}

// String -> Buffer
function fromString (str) {
  return stringToBuffer(str)
}

// Buffer -> Buffer
function fromBuffer (buf) {
  const err = validateBuffer(buf)
  if (err) throw err
  return Buffer.from(buf) // copy
}

function validateBuffer (buf) {
  try {
    bufferToTuples(buf) // try to parse. will throw if breaks
  } catch (err) {
    return err
  }
}

function isValidBuffer (buf) {
  return validateBuffer(buf) === undefined
}

function cleanPath (str) {
  return '/' + str.trim().split('/').filter(a => a).join('/')
}

function ParseError (str) {
  return new Error('Error parsing address: ' + str)
}

function protoFromTuple (tup) {
  const proto = protocols(tup[0])
  return proto
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multiaddr",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\codec.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr-to-uri\\index.js", {"multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multiaddr-to-uri\index.js
      return function (require, module, exports) {
const Multiaddr = require('multiaddr')
const reduceValue = (_, v) => v

const Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i, parts) => (
    parts.length === 1 && parts[0].protocol === 'ip6'
      ? content
      : `[${content}]`
  ),
  tcp: (str, content, i, parts) => (
    parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))
      ? `${str}:${content}`
      : `tcp://${str}:${content}`
  ),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: str => `http://${str}`,
  https: str => `https://${str}`,
  ws: str => `ws://${str}`,
  wss: str => `wss://${str}`,
  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,
  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,
  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`
}

module.exports = (multiaddr) => (
  Multiaddr(multiaddr)
    .stringTuples()
    .map(tuple => ({
      protocol: Multiaddr.protocols.codes[tuple[0]].name,
      content: tuple[1]
    }))
    .reduce((str, part, i, parts) => {
      const reduce = Reducers[part.protocol]
      if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`)
      return reduce(str, part.content, i, parts)
    }, '')
)

      };
    };
  }
}, {package:"multiaddr-to-uri",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr-to-uri\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\preload-browser.js", {"debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs\src\core\runtime\preload-browser.js
      return function (require, module, exports) {
/* eslint-env browser */
'use strict'

const debug = require('debug')

const log = debug('ipfs:preload')
log.error = debug('ipfs:preload:error')

module.exports = function preload (url, callback) {
  log(url)

  const controller = new AbortController()
  const signal = controller.signal

  fetch(url, { signal })
    .then(res => {
      if (!res.ok) {
        log.error('failed to preload', url, res.status, res.statusText)
        throw new Error(`failed to preload ${url}`)
      }
      return res.text()
    })
    .then(() => callback())
    .catch(callback)

  return {
    cancel: () => controller.abort()
  }
}

      };
    };
  }
}, {package:"ipfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs\\src\\core\\runtime\\preload-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\retry.js", {"./internal/wrapAsync":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\internal\\wrapAsync.js","lodash/constant":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\constant.js","lodash/noop":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\async\retry.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = retry;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

var _constant = require('lodash/constant');

var _constant2 = _interopRequireDefault(_constant);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || _noop2.default;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || _noop2.default;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = (0, _wrapAsync2.default)(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\retry.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NuYXBzL2pzb24tc2NoZW1hcy92YWxpZGF0ZU5wbVNuYXBQYWNrYWdlSnNvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtd2ViLXRvLW5vZGUtc3RyZWFtL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvY29uY2F0LXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90YXItc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2d1bnppcC1tYXliZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JqZWN0LW11bHRpcGxleC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLXdvcmtlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9kaXN0L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9ldGgtYWNjb3VudHMuanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL3dhdGNoLWFzc2V0LmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9sb2ctd2ViMy1zaGltLXVzYWdlLmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9yZXF1ZXN0LWFjY291bnRzLmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9zd2l0Y2gtZXRoZXJldW0tY2hhaW4uanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL2FkZC1ldGhlcmV1bS1jaGFpbi5qcyIsImFwcC9zY3JpcHRzL2xpYi9ycGMtbWV0aG9kLW1pZGRsZXdhcmUvaGFuZGxlcnMvZ2V0LXByb3ZpZGVyLXN0YXRlLmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9oYW5kbGVycy9zZW5kLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Blcm1pdHRlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9yZXN0cmljdGVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9PYnNlcnZhYmxlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvZGlzdC9iYXNlLWV0aC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL25ldHdvcmsvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi9rZXlWYWx1ZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy9zdG9yZS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvcGx1Z2lucy9qc29uMi5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9hbGwuanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvdXRpbHMvdmVyaWZpZXIuanMiLCJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L2Rpc3Qvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiL3NyYy9vcmJpdC1kYi1hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliL3RocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L25vZGVfbW9kdWxlcy9ldGhlcnMvZGlzdC9ldGhlcnMubWluLmpzIiwibm9kZV9tb2R1bGVzL2pzLXNoYTI1Ni9zcmMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1wdWJzdWIvc3JjL2lwZnMtcHVic3ViLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9sb2cuanMiLCJub2RlX21vZHVsZXMvM2JveC9ub2RlX21vZHVsZXMvZGlkLWp3dC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1kaWQtZG9jdW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1taW5pL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8zaWQtcmVzb2x2ZXIvbGliL3JlZ2lzdGVyLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliLzNpZC9rZXlyaW5nLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvYWNjZXNzLWNvbnRyb2xsZXJzLmpzIiwibm9kZV9tb2R1bGVzLzNib3gtb3JiaXRkYi1wbHVnaW5zL3NyYy9tb2RlcmF0b3JBY2Nlc3NDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzLzNib3gtb3JiaXRkYi1wbHVnaW5zL3NyYy9sZWdhY3lJcGZzM2JveEFjY2Vzc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvM2JveC1vcmJpdGRiLXBsdWdpbnMvc3JjL3RocmVhZEFjY2Vzc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvM2JveC1vcmJpdGRiLXBsdWdpbnMvc3JjL29kYklkZW50aXR5UHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGIvc3JjL2RiLW1hbmlmZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZ3BsZWFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItZmVlZHN0b3JlL3NyYy9GZWVkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItZXZlbnRzdG9yZS9zcmMvRXZlbnRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rdnN0b3JlL3NyYy9LZXlWYWx1ZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWRvY3N0b3JlL3NyYy9Eb2N1bWVudFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiL3NyYy91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi9zcmMvZXhjaGFuZ2UtaGVhZHMuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItY291bnRlcnN0b3JlL3NyYy9Db3VudGVyU3RvcmUuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItY2FjaGUvaW5kZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rZXlzdG9yZS9pbmRleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWlwZnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLW9wdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9ydW50aW1lL3JlcG8tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL21mcy1wcmVsb2FkLmpzIiwibm9kZV9tb2R1bGVzL3BlZXItYm9vay9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1ibG9jay1zZXJ2aWNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL3NyYy9jb3JlL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NpZHMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BlZXItaW5mby9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9jb25maWcuanMiLCJub2RlX21vZHVsZXMvcGVlci1pZC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBsZC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcHJlbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvcnVudGltZS9pcGxkLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9ib290LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvY29tcG9uZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL2NpZHMvc3JjL2NpZC11dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvY2lkcy9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9iYXNlLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZnJvbS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvaXMtcmV0cnktYWxsb3dlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWxpYi9kZXIuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWxpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L1BvbGxpbmdCbG9ja1RyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9CYXNlQmxvY2tUcmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL21lc3NhZ2VzLmpzb24iLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9rZWNjYWsuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9rZWNjYWsvanMuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9jb21tb25qcy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2NvbW1vbmpzL2NvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvY29tbW9uanMvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9iaXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvbmliYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHdpc2UvaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR3aXNlL2J5dGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmxwLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWVpcDcxMi11dGlsLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYm9yYy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JpZHBsdXMtc2RrL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvbWVzc2FnZXMuanNvbiIsIm5vZGVfbW9kdWxlcy9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2V0aC10cmV6b3Ita2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9kZXIuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL3RyZXpvci9wcm90b2J1Zi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdXRpbHMvZGVmZXJyZWQuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2Vudi9icm93c2VyL25ldHdvcmtVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvcG9wdXAvc2hvd1BvcHVwUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvaWZyYW1lL2lubGluZS1zdHlsZXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoanMtdXRpbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L01lcmdlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvQ29tcG9zZWRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvbmFub2lkL3VybC1hbHBoYWJldC9pbmRleC5janMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS13ZWItdG8tbm9kZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9jb25jYXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90YXItc3RyZWFtL2V4dHJhY3QuanMiLCJub2RlX21vZHVsZXMvdGFyLXN0cmVhbS9wYWNrLmpzIiwibm9kZV9tb2R1bGVzL2lzLWRlZmxhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZ3ppcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ndW56aXAtbWF5YmUvbm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwibm9kZV9tb2R1bGVzL2d1bnppcC1tYXliZS9ub2RlX21vZHVsZXMvcHVtcGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wZWVrLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ndW56aXAtbWF5YmUvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29iamVjdC1tdWx0aXBsZXgvZGlzdC9PYmplY3RNdWx0aXBsZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtd29ya2Vycy9kaXN0L2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9kaXN0L2NyZWF0ZUVuZ2luZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZGlzdC9jcmVhdGVTdHJlYW1NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL2Rpc3QvV2luZG93UG9zdE1lc3NhZ2VTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3Bvc3QtbWVzc2FnZS1zdHJlYW0vZGlzdC9Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbS9kaXN0L1dvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Blcm1pdHRlZC9nZXRTbmFwcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvZ2V0QXBwS2V5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Blcm1pdHRlZC9lbmFibGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcGVybWl0dGVkL2ludm9rZVNuYXBTdWdhci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9wZXJtaXR0ZWQvaW5zdGFsbFNuYXBzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Jlc3RyaWN0ZWQvbWFuYWdlU3RhdGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvcmVzdHJpY3RlZC9pbnZva2VTbmFwLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L3Jlc3RyaWN0ZWQvY29uZmlybS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLW1ldGhvZHMvZGlzdC9yZXN0cmljdGVkL2dldEJpcDQ0RW50cm9weS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdHgvZGlzdC5icm93c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2xpYi9qc29uMi5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9tZW1vcnlTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2Nvb2tpZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkRkYtZ2xvYmFsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9sb2NhbFN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkSUUtdXNlckRhdGFTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL3Nlc3Npb25TdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWRpZC1yZXNvbHZlci9saWIvcmVnaXN0ZXIuanMiLCJub2RlX21vZHVsZXMvbXVwb3J0LWRpZC1yZXNvbHZlci9saWIvcmVnaXN0ZXIuanMiLCJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L2Rpc3Qvc3JjL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2dyYXBocWwtcmVxdWVzdC9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1wdWJzdWItcGVlci1tb25pdG9yL3NyYy9pcGZzLXB1YnN1Yi1wZWVyLW1vbml0b3IuanMiLCJub2RlX21vZHVsZXMvcC1zZXJpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2xvZy1lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2ctc2V0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9sYW1wb3J0LWNsb2NrLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9lbnRyeS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvZGVmYXVsdC1hY2Nlc3MtY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9wLWVhY2gtc2VyaWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtbG9nL3NyYy9sb2ctc29ydGluZy5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy1sb2cvc3JjL2xvZy1pby5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWxvZy9zcmMvZW50cnkuanMiLCJub2RlX21vZHVsZXMvZGlkLXJlc29sdmVyL2xpYi9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9qcy1zaGEzL3NyYy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvdXRmOC9saWIvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy91cG9ydC1iYXNlNjR1cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXIvc3JjL2lkZW50aXRpZXMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1taW5pL3NyYy9saWIvWE1MSHR0cFJlcXVlc3QtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjR1cmwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGlkLWp3dC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy9hY2Nlc3MtY29udHJvbGxlci1tYW5pZmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL2xlZ2FjeS1pcGZzLWFjY2Vzcy1jb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvb3JiaXRkYi1hY2Nlc3MtY29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvc3JjL2lwZnMtYWNjZXNzLWNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItaW8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzL3NyYy91dGlscy9lbnN1cmUtYWMtYWRkcmVzcy5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1mZWVkc3RvcmUvc3JjL0ZlZWRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1ldmVudHN0b3JlL3NyYy9FdmVudEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLXN0b3JlL3NyYy9TdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1rdnN0b3JlL3NyYy9LZXlWYWx1ZUluZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWRvY3N0b3JlL3NyYy9Eb2N1bWVudEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWRvY3N0b3JlL25vZGVfbW9kdWxlcy9wLW1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi9zcmMvdXRpbHMvaXMtZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXB1YnN1Yi0xb24xL3NyYy9kaXJlY3QtY2hhbm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1jb3VudGVyc3RvcmUvc3JjL0NvdW50ZXJJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jcmR0cy9zcmMvRy1Db3VudGVyLmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWNhY2hlL0NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xldmVsLWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiLWtleXN0b3JlL3NyYy9rZXlzdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9tYWZtdC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtcmVwby9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMvc2V0SW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2ZzbS1ldmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdmFyaW50LXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL25hbWUtdGFibGUuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzcy1pcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9iYXNlLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NpZHMvc3JjL2NpZC11dGlsLmpzIiwibm9kZV9tb2R1bGVzL3BlZXItaW5mby9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcGVlci1pbmZvL3NyYy9tdWx0aWFkZHItc2V0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY3J5cHRvL3NyYy9rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaXBsZC1kYWctcGIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtZGFnLWNib3Ivc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lwbGQtcmF3L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNpZnktZXM2L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R5cGljYWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJsb2NrL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL3Byb3RvY29scy10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWFkZHIvc3JjL2NvZGVjLmpzIiwibm9kZV9tb2R1bGVzL211bHRpYWRkci10by11cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXBmcy9zcmMvY29yZS9ydW50aW1lL3ByZWxvYWQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9yZXRyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RBOztBQUVBO0FBQ0E7QUFDQTtBQUVBLE1BQU0sdUJBQXVCLEdBQUc7QUFDOUIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxZQUFkLENBRGlCO0FBRTlCLEVBQUEsY0FBYyxFQUFFLGtCQUZjO0FBRzlCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxXQUFXLEVBQUU7QUFESjtBQUhtQixDQUFoQztlQU9lLHVCO0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsZUFBZSxrQkFBZixDQUFrQyxJQUFsQyxFQUF3QyxHQUF4QyxFQUE2QyxLQUE3QyxFQUFvRCxHQUFwRCxFQUF5RDtBQUFFLEVBQUE7QUFBRixDQUF6RCxFQUEwRTtBQUN4RSxFQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsTUFBTSxXQUFXLEVBQTlCO0FBQ0EsU0FBTyxHQUFHLEVBQVY7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDRDs7QUFFQSxNQUFNLFVBQVUsR0FBRztBQUNqQixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLFdBQWQsRUFBMkIsa0JBQWEsa0JBQXhDLENBREk7QUFFakIsRUFBQSxjQUFjLEVBQUUsaUJBRkM7QUFHakIsRUFBQSxTQUFTLEVBQUU7QUFDVCxJQUFBLHVCQUF1QixFQUFFO0FBRGhCO0FBSE0sQ0FBbkI7ZUFPZSxVO0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBLGVBQWUsaUJBQWYsQ0FDRSxHQURGLEVBRUUsR0FGRixFQUdFLEtBSEYsRUFJRSxHQUpGLEVBS0U7QUFBRSxFQUFBO0FBQUYsQ0FMRixFQU1FO0FBQ0EsTUFBSTtBQUNGLFVBQU07QUFBRSxNQUFBLE9BQU8sRUFBRSxLQUFYO0FBQWtCLE1BQUE7QUFBbEIsUUFBMkIsR0FBRyxDQUFDLE1BQXJDO0FBQ0EsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLE1BQU0sdUJBQXVCLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBMUM7QUFDQSxXQUFPLEdBQUcsRUFBVjtBQUNELEdBSkQsQ0FJRSxPQUFPLEtBQVAsRUFBYztBQUNkLFdBQU8sR0FBRyxDQUFDLEtBQUQsQ0FBVjtBQUNEO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSxnQkFBZ0IsR0FBRztBQUN2QixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLG1CQUFkLENBRFU7QUFFdkIsRUFBQSxjQUFjLEVBQUUsdUJBRk87QUFHdkIsRUFBQSxTQUFTLEVBQUU7QUFDVCxJQUFBLFdBQVcsRUFBRSxJQURKO0FBRVQsSUFBQSxxQkFBcUIsRUFBRSxJQUZkO0FBR1QsSUFBQSx3QkFBd0IsRUFBRTtBQUhqQjtBQUhZLENBQXpCO2VBU2UsZ0I7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsU0FBUyx1QkFBVCxDQUNFLEdBREYsRUFFRSxHQUZGLEVBR0UsS0FIRixFQUlFLEdBSkYsRUFLRTtBQUFFLEVBQUEsV0FBRjtBQUFlLEVBQUEscUJBQWY7QUFBc0MsRUFBQTtBQUF0QyxDQUxGLEVBTUU7QUFDQSxRQUFNO0FBQUUsSUFBQTtBQUFGLE1BQWEsR0FBbkI7O0FBQ0EsTUFBSSxxQkFBcUIsQ0FBQyxNQUFELENBQXJCLEtBQWtDLFNBQXRDLEVBQWlEO0FBQy9DLElBQUEsd0JBQXdCLENBQUMsTUFBRCxDQUF4QjtBQUVBLElBQUEsV0FBVyxDQUNUO0FBQ0UsTUFBQSxLQUFLLEVBQUcsbUNBRFY7QUFFRSxNQUFBLFFBQVEsRUFBRSxpQkFGWjtBQUdFLE1BQUEsUUFBUSxFQUFFO0FBQ1IsUUFBQSxHQUFHLEVBQUU7QUFERztBQUhaLEtBRFMsRUFRVDtBQUNFLE1BQUEsb0JBQW9CLEVBQUU7QUFEeEIsS0FSUyxDQUFYO0FBWUQ7O0FBRUQsRUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFDQSxTQUFPLEdBQUcsRUFBVjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0REOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSx1QkFBdUIsR0FBRztBQUM5QixFQUFBLFdBQVcsRUFBRSxDQUFDLGtCQUFhLG9CQUFkLENBRGlCO0FBRTlCLEVBQUEsY0FBYyxFQUFFLDhCQUZjO0FBRzlCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxNQUFNLEVBQUUsSUFEQztBQUVULElBQUEsV0FBVyxFQUFFLElBRko7QUFHVCxJQUFBLGdCQUFnQixFQUFFLElBSFQ7QUFJVCxJQUFBLGFBQWEsRUFBRSxJQUpOO0FBS1QsSUFBQSx5QkFBeUIsRUFBRTtBQUxsQjtBQUhtQixDQUFoQztlQVdlLHVCLEVBRWY7OztBQUNBLE1BQU0sS0FBSyxHQUFHLElBQUksR0FBSixFQUFkO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZUFBZSw4QkFBZixDQUNFLElBREYsRUFFRSxHQUZGLEVBR0UsS0FIRixFQUlFLEdBSkYsRUFLRTtBQUNFLEVBQUEsTUFERjtBQUVFLEVBQUEsV0FGRjtBQUdFLEVBQUEsZ0JBSEY7QUFJRSxFQUFBLGFBSkY7QUFLRSxFQUFBO0FBTEYsQ0FMRixFQVlFO0FBQ0EsTUFBSSxLQUFLLENBQUMsR0FBTixDQUFVLE1BQVYsQ0FBSixFQUF1QjtBQUNyQixJQUFBLEdBQUcsQ0FBQyxLQUFKLEdBQVksd0JBQVUsR0FBVixDQUFjLG1CQUFkLENBQ1Qsc0JBQXFCLGtCQUFhLG9CQUFxQixnQkFEOUMsQ0FBWjtBQUdBLFdBQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBRUQsTUFBSSxhQUFhLENBQUMsa0JBQWEsWUFBZCxDQUFqQixFQUE4QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFJO0FBQ0YsTUFBQSxLQUFLLENBQUMsR0FBTixDQUFVLE1BQVY7QUFDQSxZQUFNLGdCQUFnQixDQUFDLElBQUQsQ0FBdEI7QUFDQSxNQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsTUFBTSxXQUFXLEVBQTlCO0FBQ0EsTUFBQSxHQUFHO0FBQ0osS0FMRCxDQUtFLE9BQU8sS0FBUCxFQUFjO0FBQ2QsTUFBQSxHQUFHLENBQUMsS0FBRCxDQUFIO0FBQ0QsS0FQRCxTQU9VO0FBQ1IsTUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLE1BQWI7QUFDRDs7QUFDRCxXQUFPLFNBQVA7QUFDRCxHQXZCRCxDQXlCQTs7O0FBQ0EsTUFBSTtBQUNGLFVBQU0seUJBQXlCLEVBQS9CO0FBQ0QsR0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1osSUFBQSxHQUFHLENBQUMsS0FBSixHQUFZLEdBQVo7QUFDQSxXQUFPLEdBQUcsRUFBVjtBQUNELEdBL0JELENBaUNBOzs7QUFDQSxRQUFNLFFBQVEsR0FBRyxNQUFNLFdBQVcsRUFBbEM7QUFDQTs7QUFDQSxNQUFJLFFBQVEsQ0FBQyxNQUFULEdBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLElBQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxRQUFiO0FBQ0QsR0FGRCxNQUVPO0FBQ0w7QUFDQTtBQUNBLElBQUEsR0FBRyxDQUFDLEtBQUosR0FBWSx3QkFBVSxHQUFWLENBQWMsUUFBZCxDQUNWLDREQURVLENBQVo7QUFHRDs7QUFFRCxTQUFPLEdBQUcsRUFBVjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0dEOztBQUNBOztBQUNBOztBQUNBOztBQU1BOztBQUtBLE1BQU0sbUJBQW1CLEdBQUc7QUFDMUIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxxQkFBZCxDQURhO0FBRTFCLEVBQUEsY0FBYyxFQUFFLDBCQUZVO0FBRzFCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxpQkFBaUIsRUFBRSxJQURWO0FBRVQsSUFBQSxlQUFlLEVBQUUsSUFGUjtBQUdULElBQUEsZUFBZSxFQUFFLElBSFI7QUFJVCxJQUFBLGVBQWUsRUFBRSxJQUpSO0FBS1QsSUFBQSxtQkFBbUIsRUFBRTtBQUxaO0FBSGUsQ0FBNUI7ZUFXZSxtQjs7O0FBRWYsU0FBUyxtQkFBVCxDQUE2QixPQUE3QixFQUFzQyxlQUF0QyxFQUF1RDtBQUNyRCxNQUFJLE9BQU8sSUFBSSw2QkFBZixFQUFxQztBQUNuQyxXQUFPO0FBQ0wsTUFBQSxPQURLO0FBRUwsTUFBQSxNQUFNLEVBQUUsbUJBRkg7QUFHTCxNQUFBLFFBQVEsRUFBRSw2QkFBb0IsT0FBcEIsQ0FITDtBQUlMLE1BQUEsTUFBTSxFQUFFLGlDQUF3QixPQUF4QixDQUpIO0FBS0wsTUFBQSxJQUFJLEVBQUUsOEJBQXFCLE9BQXJCO0FBTEQsS0FBUDtBQU9EOztBQUVELFNBQU8sZUFBZSxDQUFDO0FBQUUsSUFBQTtBQUFGLEdBQUQsQ0FBdEI7QUFDRDs7QUFFRCxlQUFlLDBCQUFmLENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQ0UsRUFBQSxpQkFERjtBQUVFLEVBQUEsZUFGRjtBQUdFLEVBQUEsZUFIRjtBQUlFLEVBQUEsZUFKRjtBQUtFLEVBQUE7QUFMRixDQUxGLEVBWUU7QUFBQTs7QUFDQSxNQUFJLGlCQUFDLEdBQUcsQ0FBQyxNQUFMLHdDQUFDLFlBQWEsQ0FBYixDQUFELEtBQW9CLE9BQU8sR0FBRyxDQUFDLE1BQUosQ0FBVyxDQUFYLENBQVAsS0FBeUIsUUFBakQsRUFBMkQ7QUFDekQsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcsaURBQWdELElBQUksQ0FBQyxTQUFMLENBQ3hELEdBQUcsQ0FBQyxNQURvRCxDQUV4RDtBQUh3QixLQUE1QixDQURRLENBQVY7QUFPRDs7QUFFRCxRQUFNO0FBQUUsSUFBQTtBQUFGLE1BQWEsR0FBbkI7QUFFQSxRQUFNO0FBQUUsSUFBQTtBQUFGLE1BQWMsR0FBRyxDQUFDLE1BQUosQ0FBVyxDQUFYLENBQXBCO0FBRUEsUUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxrQkFBSyxHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsQ0FBTCxFQUFvQixDQUFDLFNBQUQsQ0FBcEIsQ0FBWixDQUFsQjs7QUFFQSxNQUFJLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLG9FQUFtRSxTQUFVO0FBRDdELEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELFFBQU0sUUFBUSxHQUFHLE9BQU8sT0FBUCxLQUFtQixRQUFuQixJQUErQixPQUFPLENBQUMsV0FBUixFQUFoRDs7QUFFQSxNQUFJLENBQUMsNENBQTZCLFFBQTdCLENBQUwsRUFBNkM7QUFDM0MsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcscUZBQW9GLE9BQVE7QUFENUUsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsTUFBSSxDQUFDLDZCQUFjLFFBQVEsQ0FBQyxRQUFELEVBQVcsRUFBWCxDQUF0QixDQUFMLEVBQTRDO0FBQzFDLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLHFCQUFvQixRQUFTLDhEQUE2RCxPQUFRO0FBRGxGLEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELFFBQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDLFFBQUQsRUFBVyxlQUFYLENBQXZDOztBQUNBLE1BQUksV0FBSixFQUFpQjtBQUNmLFVBQU0sY0FBYyxHQUFHLGlCQUFpQixFQUF4Qzs7QUFDQSxRQUFJLGNBQWMsS0FBSyxRQUF2QixFQUFpQztBQUMvQixNQUFBLEdBQUcsQ0FBQyxNQUFKLEdBQWEsSUFBYjtBQUNBLGFBQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBQ0QsUUFBSTtBQUNGLFlBQU0sbUJBQW1CLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxRQUFBLE1BRG9EO0FBRXBELFFBQUEsSUFBSSxFQUFFLGtCQUFhLHFCQUZpQztBQUdwRCxRQUFBO0FBSG9ELE9BQUQsQ0FBckQ7O0FBS0EsVUFBSSxPQUFPLElBQUksNkJBQWYsRUFBcUM7QUFDbkMsUUFBQSxlQUFlLENBQUMsbUJBQW1CLENBQUMsSUFBckIsQ0FBZjtBQUNELE9BRkQsTUFFTztBQUNMLGNBQU0sZUFBZSxDQUFDLG1CQUFELENBQXJCO0FBQ0Q7O0FBQ0QsTUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFDRCxLQVpELENBWUUsT0FBTyxLQUFQLEVBQWM7QUFDZCxhQUFPLEdBQUcsQ0FBQyxLQUFELENBQVY7QUFDRDs7QUFDRCxXQUFPLEdBQUcsRUFBVjtBQUNEOztBQUNELFNBQU8sR0FBRyxDQUNSLHdCQUFVLFFBQVYsQ0FBbUIsTUFBbkIsQ0FBMEI7QUFDeEIsSUFBQSxJQUFJLEVBQUUsSUFEa0I7QUFDWjtBQUNaLElBQUEsT0FBTyxFQUFHLDBCQUF5QixPQUFRLGlDQUFnQyxrQkFBYSxrQkFBbUI7QUFGbkYsR0FBMUIsQ0FEUSxDQUFWO0FBTUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlIRDs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFFQSxNQUFNLGdCQUFnQixHQUFHO0FBQ3ZCLEVBQUEsV0FBVyxFQUFFLENBQUMsa0JBQWEsa0JBQWQsQ0FEVTtBQUV2QixFQUFBLGNBQWMsRUFBRSx1QkFGTztBQUd2QixFQUFBLFNBQVMsRUFBRTtBQUNULElBQUEsWUFBWSxFQUFFLElBREw7QUFFVCxJQUFBLGlCQUFpQixFQUFFLElBRlY7QUFHVCxJQUFBLGVBQWUsRUFBRSxJQUhSO0FBSVQsSUFBQSxlQUFlLEVBQUUsSUFKUjtBQUtULElBQUEsbUJBQW1CLEVBQUUsSUFMWjtBQU1ULElBQUEsV0FBVyxFQUFFO0FBTko7QUFIWSxDQUF6QjtlQVllLGdCOzs7QUFFZixlQUFlLHVCQUFmLENBQ0UsR0FERixFQUVFLEdBRkYsRUFHRSxLQUhGLEVBSUUsR0FKRixFQUtFO0FBQ0UsRUFBQSxZQURGO0FBRUUsRUFBQSxpQkFGRjtBQUdFLEVBQUEsZUFIRjtBQUlFLEVBQUEsZUFKRjtBQUtFLEVBQUEsbUJBTEY7QUFNRSxFQUFBO0FBTkYsQ0FMRixFQWFFO0FBQUE7O0FBQ0EsTUFBSSxpQkFBQyxHQUFHLENBQUMsTUFBTCx3Q0FBQyxZQUFhLENBQWIsQ0FBRCxLQUFvQixPQUFPLEdBQUcsQ0FBQyxNQUFKLENBQVcsQ0FBWCxDQUFQLEtBQXlCLFFBQWpELEVBQTJEO0FBQ3pELFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLGlEQUFnRCxJQUFJLENBQUMsU0FBTCxDQUN4RCxHQUFHLENBQUMsTUFEb0QsQ0FFeEQ7QUFId0IsS0FBNUIsQ0FEUSxDQUFWO0FBT0Q7O0FBRUQsUUFBTTtBQUFFLElBQUE7QUFBRixNQUFhLEdBQW5CO0FBRUEsUUFBTTtBQUNKLElBQUEsT0FESTtBQUVKLElBQUEsU0FBUyxHQUFHLElBRlI7QUFHSixJQUFBLGlCQUFpQixHQUFHLElBSGhCO0FBSUosSUFBQSxjQUFjLEdBQUcsSUFKYjtBQUtKLElBQUE7QUFMSSxNQU1GLEdBQUcsQ0FBQyxNQUFKLENBQVcsQ0FBWCxDQU5KO0FBUUEsUUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FDaEIsa0JBQUssR0FBRyxDQUFDLE1BQUosQ0FBVyxDQUFYLENBQUwsRUFBb0IsQ0FDbEIsU0FEa0IsRUFFbEIsV0FGa0IsRUFHbEIsbUJBSGtCLEVBSWxCLFVBSmtCLEVBS2xCLFNBTGtCLEVBTWxCLGdCQU5rQixDQUFwQixDQURnQixDQUFsQjs7QUFXQSxNQUFJLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLG9FQUFtRSxTQUFVO0FBRDdELEtBQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELFFBQU0sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBYyxPQUFkLElBQ3JCLE9BQU8sQ0FBQyxJQUFSLENBQWMsTUFBRCxJQUFZLGtCQUFTLFVBQVQsQ0FBb0IsTUFBcEIsQ0FBekIsQ0FEcUIsR0FFckIsSUFGSjtBQUlBLFFBQU0sMEJBQTBCLEdBQzlCLGlCQUFpQixLQUFLLElBQXRCLElBQThCLEtBQUssQ0FBQyxPQUFOLENBQWMsaUJBQWQsQ0FBOUIsR0FDSSxpQkFBaUIsQ0FBQyxJQUFsQixDQUF3QixnQkFBRCxJQUNyQixrQkFBUyxVQUFULENBQW9CLGdCQUFwQixDQURGLENBREosR0FJSSxJQUxOOztBQU9BLE1BQUksQ0FBQyxnQkFBTCxFQUF1QjtBQUNyQixXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxvRkFBbUYsT0FBUTtBQUQzRSxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxNQUFJLGlCQUFpQixLQUFLLElBQXRCLElBQThCLENBQUMsMEJBQW5DLEVBQStEO0FBQzdELFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLGlHQUFnRyxpQkFBa0I7QUFEbEcsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsUUFBTSxRQUFRLEdBQUcsT0FBTyxPQUFQLEtBQW1CLFFBQW5CLElBQStCLE9BQU8sQ0FBQyxXQUFSLEVBQWhEOztBQUVBLE1BQUksQ0FBQywyQ0FBNkIsUUFBN0IsQ0FBTCxFQUE2QztBQUMzQyxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRyxxRkFBb0YsT0FBUTtBQUQ1RSxLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxNQUFJLENBQUMsNEJBQWMsUUFBUSxDQUFDLFFBQUQsRUFBVyxFQUFYLENBQXRCLENBQUwsRUFBNEM7QUFDMUMsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcscUJBQW9CLFFBQVMsOERBQTZELE9BQVE7QUFEbEYsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsTUFBSSxxQ0FBMkIsUUFBM0IsQ0FBSixFQUEwQztBQUN4QyxXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsYUFBZCxDQUE0QjtBQUMxQixNQUFBLE9BQU8sRUFBRztBQURnQixLQUE1QixDQURRLENBQVY7QUFLRDs7QUFFRCxRQUFNLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFBRSxJQUFBLE9BQU8sRUFBRTtBQUFYLEdBQUQsQ0FBdkM7O0FBRUEsTUFBSSxlQUFKLEVBQXFCO0FBQ25CO0FBQ0EsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFFQSxVQUFNLGNBQWMsR0FBRyxpQkFBaUIsRUFBeEM7O0FBQ0EsUUFBSSxjQUFjLEtBQUssUUFBdkIsRUFBaUM7QUFDL0IsYUFBTyxHQUFHLEVBQVY7QUFDRCxLQVBrQixDQVNuQjs7O0FBQ0EsUUFBSTtBQUNGLFlBQU0sZUFBZSxDQUNuQixNQUFNLG1CQUFtQixDQUFDO0FBQ3hCLFFBQUEsTUFEd0I7QUFFeEIsUUFBQSxJQUFJLEVBQUUsa0JBQWEscUJBRks7QUFHeEIsUUFBQSxXQUFXLEVBQUU7QUFDWCxVQUFBLE1BQU0sRUFBRSxlQUFlLENBQUMsTUFEYjtBQUVYLFVBQUEsT0FBTyxFQUFFLGVBQWUsQ0FBQyxPQUZkO0FBR1gsVUFBQSxRQUFRLEVBQUUsZUFBZSxDQUFDLFFBSGY7QUFJWCxVQUFBLE1BQU0sRUFBRSxlQUFlLENBQUM7QUFKYjtBQUhXLE9BQUQsQ0FETixDQUFyQjtBQVlBLE1BQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxJQUFiO0FBQ0QsS0FkRCxDQWNFLE9BQU8sS0FBUCxFQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBSSxLQUFLLENBQUMsSUFBTixLQUFlLHlCQUFXLFFBQVgsQ0FBb0IsbUJBQXZDLEVBQTREO0FBQzFELGVBQU8sR0FBRyxDQUFDLEtBQUQsQ0FBVjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTyxHQUFHLEVBQVY7QUFDRDs7QUFFRCxNQUFJLGVBQUo7O0FBRUEsTUFBSTtBQUNGLElBQUEsZUFBZSxHQUFHLE1BQU0seUJBQWUsZ0JBQWYsRUFBaUMsYUFBakMsQ0FBeEI7QUFDRCxHQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixXQUFPLEdBQUcsQ0FDUix3QkFBVSxHQUFWLENBQWMsUUFBZCxDQUF1QjtBQUNyQixNQUFBLE9BQU8sRUFBRyxzQ0FBcUMsZ0JBQWlCLFNBRDNDO0FBRXJCLE1BQUEsSUFBSSxFQUFFO0FBQUUsUUFBQSxVQUFVLEVBQUU7QUFBZDtBQUZlLEtBQXZCLENBRFEsQ0FBVjtBQU1EOztBQUVELE1BQUksUUFBUSxLQUFLLGVBQWpCLEVBQWtDO0FBQ2hDLFdBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLE1BQUEsT0FBTyxFQUFHLGdDQUErQixnQkFBaUIsbUJBQWtCLFFBQVMsRUFEM0Q7QUFFMUIsTUFBQSxJQUFJLEVBQUU7QUFBRSxRQUFBLE9BQU8sRUFBRTtBQUFYO0FBRm9CLEtBQTVCLENBRFEsQ0FBVjtBQU1EOztBQUVELE1BQUksT0FBTyxTQUFQLEtBQXFCLFFBQXJCLElBQWlDLENBQUMsU0FBdEMsRUFBaUQ7QUFDL0MsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcscURBQW9ELFNBQVU7QUFEOUMsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBQ0QsUUFBTSxVQUFVLEdBQ2QsU0FBUyxDQUFDLE1BQVYsR0FBbUIsR0FBbkIsR0FBeUIsU0FBUyxDQUFDLFNBQVYsQ0FBb0IsQ0FBcEIsRUFBdUIsR0FBdkIsQ0FBekIsR0FBdUQsU0FEekQ7O0FBR0EsTUFBSSxjQUFjLEtBQUssSUFBdkIsRUFBNkI7QUFDM0IsUUFBSSxPQUFPLGNBQVAsS0FBMEIsUUFBMUIsSUFBc0MsS0FBSyxDQUFDLE9BQU4sQ0FBYyxjQUFkLENBQTFDLEVBQXlFO0FBQ3ZFLGFBQU8sR0FBRyxDQUNSLHdCQUFVLEdBQVYsQ0FBYyxhQUFkLENBQTRCO0FBQzFCLFFBQUEsT0FBTyxFQUFHLHdEQUF1RCxjQUFlO0FBRHRELE9BQTVCLENBRFEsQ0FBVjtBQUtEOztBQUNELFFBQUksY0FBYyxDQUFDLFFBQWYsS0FBNEIsRUFBaEMsRUFBb0M7QUFDbEMsYUFBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsUUFBQSxPQUFPLEVBQUcscUdBQW9HLGNBQWMsQ0FBQyxRQUFTO0FBRDVHLE9BQTVCLENBRFEsQ0FBVjtBQUtEOztBQUVELFFBQUksQ0FBQyxjQUFjLENBQUMsTUFBaEIsSUFBMEIsT0FBTyxjQUFjLENBQUMsTUFBdEIsS0FBaUMsUUFBL0QsRUFBeUU7QUFDdkUsYUFBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsUUFBQSxPQUFPLEVBQUcsd0RBQXVELGNBQWMsQ0FBQyxNQUFPO0FBRDdELE9BQTVCLENBRFEsQ0FBVjtBQUtEO0FBQ0Y7O0FBQ0QsUUFBTSxNQUFNLEdBQUcsQ0FBQSxjQUFjLFNBQWQsSUFBQSxjQUFjLFdBQWQsWUFBQSxjQUFjLENBQUUsTUFBaEIsS0FBMEIsS0FBekM7O0FBRUEsTUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBOUMsSUFBbUQsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBdkUsRUFBMEU7QUFDeEUsV0FBTyxHQUFHLENBQ1Isd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFDMUIsTUFBQSxPQUFPLEVBQUcscUVBQW9FLE1BQU87QUFEM0QsS0FBNUIsQ0FEUSxDQUFWO0FBS0Q7O0FBRUQsTUFBSTtBQUNGLFVBQU0sWUFBWSxDQUNoQixNQUFNLG1CQUFtQixDQUFDO0FBQ3hCLE1BQUEsTUFEd0I7QUFFeEIsTUFBQSxJQUFJLEVBQUUsa0JBQWEsa0JBRks7QUFHeEIsTUFBQSxXQUFXLEVBQUU7QUFDWCxRQUFBLE9BQU8sRUFBRSxRQURFO0FBRVgsUUFBQSxnQkFBZ0IsRUFBRSwwQkFGUDtBQUdYLFFBQUEsU0FBUyxFQUFFLFVBSEE7QUFJWCxRQUFBLE1BQU0sRUFBRSxnQkFKRztBQUtYLFFBQUE7QUFMVztBQUhXLEtBQUQsQ0FEVCxDQUFsQjtBQWNBLElBQUEsV0FBVyxDQUFDO0FBQ1YsTUFBQSxLQUFLLEVBQUUsc0JBREc7QUFFVixNQUFBLFFBQVEsRUFBRSxTQUZBO0FBR1YsTUFBQSxRQUFRLEVBQUU7QUFDUixRQUFBLEdBQUcsRUFBRTtBQURHLE9BSEE7QUFNVixNQUFBLG1CQUFtQixFQUFFO0FBQ25CLFFBQUEsUUFBUSxFQUFFLFFBRFM7QUFFbkIsUUFBQSxPQUFPLEVBQUUsZ0JBRlU7QUFHbkIsUUFBQSxZQUFZLEVBQUUsVUFISztBQUluQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUEsT0FBTyxFQUFFLGdCQVJVO0FBU25CLFFBQUEsTUFBTSxFQUFFLE1BVFc7QUFVbkIsUUFBQSxrQkFBa0IsRUFBRSwwQkFWRDtBQVduQixRQUFBLE1BQU0sRUFBRTtBQVhXO0FBTlgsS0FBRCxDQUFYLENBZkUsQ0FvQ0Y7O0FBQ0EsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLElBQWI7QUFDRCxHQXRDRCxDQXNDRSxPQUFPLEtBQVAsRUFBYztBQUNkLFdBQU8sR0FBRyxDQUFDLEtBQUQsQ0FBVjtBQUNELEdBNU9ELENBOE9BOzs7QUFDQSxNQUFJO0FBQ0YsVUFBTSxlQUFlLENBQ25CLE1BQU0sbUJBQW1CLENBQUM7QUFDeEIsTUFBQSxNQUR3QjtBQUV4QixNQUFBLElBQUksRUFBRSxrQkFBYSxxQkFGSztBQUd4QixNQUFBLFdBQVcsRUFBRTtBQUNYLFFBQUEsTUFBTSxFQUFFLGdCQURHO0FBRVgsUUFBQSxPQUFPLEVBQUUsUUFGRTtBQUdYLFFBQUEsUUFBUSxFQUFFLFVBSEM7QUFJWCxRQUFBO0FBSlc7QUFIVyxLQUFELENBRE4sQ0FBckI7QUFZRCxHQWJELENBYUUsT0FBTyxLQUFQLEVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFJLEtBQUssQ0FBQyxJQUFOLEtBQWUseUJBQVcsUUFBWCxDQUFvQixtQkFBdkMsRUFBNEQ7QUFDMUQsYUFBTyxHQUFHLENBQUMsS0FBRCxDQUFWO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPLEdBQUcsRUFBVjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNTRDs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU0sZ0JBQWdCLEdBQUc7QUFDdkIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxrQkFBZCxDQURVO0FBRXZCLEVBQUEsY0FBYyxFQUFFLHVCQUZPO0FBR3ZCLEVBQUEsU0FBUyxFQUFFO0FBQ1QsSUFBQSxnQkFBZ0IsRUFBRTtBQURUO0FBSFksQ0FBekI7ZUFPZSxnQjtBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsZUFBZSx1QkFBZixDQUNFLEdBREYsRUFFRSxHQUZGLEVBR0UsS0FIRixFQUlFLEdBSkYsRUFLRTtBQUFFLEVBQUEsZ0JBQWdCLEVBQUU7QUFBcEIsQ0FMRixFQU1FO0FBQ0EsRUFBQSxHQUFHLENBQUMsTUFBSixxQkFDTSxNQUFNLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFMLENBRDdCO0FBR0EsU0FBTyxHQUFHLEVBQVY7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hERDs7QUFDQTs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSxZQUFZLEdBQUc7QUFDbkIsRUFBQSxXQUFXLEVBQUUsQ0FBQyxrQkFBYSxhQUFkLENBRE07QUFFbkIsRUFBQSxjQUFjLEVBQUUsbUJBRkc7QUFHbkIsRUFBQSxTQUFTLEVBQUU7QUFDVCxJQUFBLGtCQUFrQixFQUFFLElBRFg7QUFFVCxJQUFBLFdBQVcsRUFBRTtBQUZKO0FBSFEsQ0FBckI7ZUFRZSxZO0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0EsU0FBUyxtQkFBVCxDQUNFLEdBREYsRUFFRSxHQUZGLEVBR0UsS0FIRixFQUlFLEdBSkYsRUFLRTtBQUFFLEVBQUEsa0JBQUY7QUFBc0IsRUFBQTtBQUF0QixDQUxGLEVBTUU7QUFDQSxRQUFNO0FBQUUsSUFBQSxNQUFGO0FBQVUsSUFBQTtBQUFWLE1BQXFCLEdBQTNCOztBQUNBLE1BQUksTUFBTSxJQUFJLE9BQU8sTUFBUCxLQUFrQixRQUE1QixJQUF3QyxDQUFDLEtBQUssQ0FBQyxPQUFOLENBQWMsTUFBZCxDQUE3QyxFQUFvRTtBQUNsRSxVQUFNO0FBQUUsTUFBQSxJQUFJLEdBQUcsSUFBVDtBQUFlLE1BQUEsSUFBSSxHQUFHO0FBQXRCLFFBQW1ELE1BQXpEO0FBQUEsVUFBcUMsZUFBckMsMENBQXlELE1BQXpEO0FBRUEsSUFBQSxrQkFBa0IsaUNBQ2IsZUFEYTtBQUVoQixNQUFBLE9BQU8sRUFBRSxJQUZPO0FBR2hCLE1BQUEsSUFIZ0I7QUFJaEIsTUFBQSxXQUpnQjtBQUtoQixNQUFBO0FBTGdCLE9BQWxCO0FBT0QsR0FWRCxNQVVPO0FBQ0wsV0FBTyxHQUFHLENBQUMsd0JBQVUsR0FBVixDQUFjLGFBQWQsQ0FBNEI7QUFBRSxNQUFBLElBQUksRUFBRTtBQUFSLEtBQTVCLENBQUQsQ0FBVjtBQUNEOztBQUVELEVBQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxJQUFiO0FBQ0EsU0FBTyxHQUFHLEVBQVY7QUFDRDs7Ozs7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2ZkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTs7QUFDQTs7QUFFTyxNQUFNLHFCQUFxQixHQUFJLEdBQUQsSUFBUyw2QkFBb0IsR0FBcEIsQ0FBdkM7Ozs7QUFFQSxTQUFTLHdCQUFULENBQWtDLE1BQWxDLEVBQTBDO0FBQy9DLFFBQU07QUFBRSxJQUFBLENBQUY7QUFBSyxJQUFBLENBQUw7QUFBUSxJQUFBLENBQVI7QUFBVyxJQUFBLElBQVg7QUFBaUIsSUFBQSxTQUFqQjtBQUE0QixJQUFBO0FBQTVCLE1BQXlDLE1BQS9DO0FBQ0EsUUFBTTtBQUNKLElBQUEsRUFESTtBQUVKLElBQUEsSUFGSTtBQUdKLElBQUEsS0FISTtBQUlKLElBQUEsR0FKSTtBQUtKLElBQUEsSUFMSTtBQU1KLElBQUEsS0FOSTtBQU9KLElBQUEsUUFQSTtBQVFKLElBQUEsVUFSSTtBQVNKLElBQUEsWUFUSTtBQVVKLElBQUE7QUFWSSxNQVdGLFFBWEo7QUFhQSxRQUFNLGVBQWUsR0FBRztBQUN0QixJQUFBLENBRHNCO0FBRXRCLElBQUEsQ0FGc0I7QUFHdEIsSUFBQSxDQUhzQjtBQUl0QixJQUFBLEVBSnNCO0FBS3RCLElBQUEsR0FMc0I7QUFNdEIsSUFBQSxJQU5zQjtBQU90QixJQUFBLElBUHNCO0FBUXRCLElBQUEsS0FSc0I7QUFTdEIsSUFBQSxLQUFLLEVBQUUsSUFBSSxJQUFJLElBVE87QUFVdEIsSUFBQSxLQUFLLEVBQUUsS0FBSyxJQUFJLEtBVk07QUFXdEIsSUFBQSxVQUFVLEVBQUUsVUFBVSxJQUFJLElBWEo7QUFZdEIsSUFBQSxTQUFTLEVBQUUsQ0FBQSxTQUFTLFNBQVQsSUFBQSxTQUFTLFdBQVQsWUFBQSxTQUFTLENBQUUsU0FBWCxLQUF3QixJQVpiO0FBYXRCLElBQUEsV0FBVyxFQUFFLENBQUEsU0FBUyxTQUFULElBQUEsU0FBUyxXQUFULFlBQUEsU0FBUyxDQUFFLFdBQVgsS0FBMEIsSUFiakI7QUFjdEIsSUFBQSxnQkFBZ0IsRUFBRSxDQUFBLFNBQVMsU0FBVCxJQUFBLFNBQVMsV0FBVCxZQUFBLFNBQVMsQ0FBRSxnQkFBWCxLQUErQjtBQWQzQixHQUF4Qjs7QUFpQkEsTUFBSSxZQUFZLElBQUksb0JBQXBCLEVBQTBDO0FBQ3hDLElBQUEsZUFBZSxDQUFDLFFBQWhCLEdBQTJCLFlBQTNCO0FBQ0EsSUFBQSxlQUFlLENBQUMsWUFBaEIsR0FBK0IsWUFBL0I7QUFDQSxJQUFBLGVBQWUsQ0FBQyxvQkFBaEIsR0FBdUMsb0JBQXZDO0FBQ0EsSUFBQSxlQUFlLENBQUMsSUFBaEIsR0FBdUIsd0NBQTJCLFVBQWxEO0FBQ0QsR0FMRCxNQUtPO0FBQ0wsSUFBQSxlQUFlLENBQUMsUUFBaEIsR0FBMkIsUUFBM0I7QUFDQSxJQUFBLGVBQWUsQ0FBQyxJQUFoQixHQUF1Qix3Q0FBMkIsTUFBbEQ7QUFDRDs7QUFFRCxTQUFPLGVBQVA7QUFDRDs7Ozs7Ozs7Ozs7O0FDaEREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hvQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxc0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3puQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdDFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcmdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNocEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakpBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGUyMDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZTIwO1xuY29uc3Qgc2NoZW1hMjIgPSB7IFwidGl0bGVcIjogXCJucG0gU25hcCBwYWNrYWdlLmpzb25cIiwgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwicmVxdWlyZWRcIjogW1widmVyc2lvblwiLCBcIm5hbWVcIl0sIFwicHJvcGVydGllc1wiOiB7IFwidmVyc2lvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiVmVyc2lvblwiLCBcInBhdHRlcm5cIjogXCJeKDB8WzEtOV1cXFxcZCopXFxcXC4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKSg/Oi0oKD86MHxbMS05XVxcXFxkKnxcXFxcZCpbYS16QS1aLV1bMC05YS16QS1aLV0qKSg/OlxcXFwuKD86MHxbMS05XVxcXFxkKnxcXFxcZCpbYS16QS1aLV1bMC05YS16QS1aLV0qKSkqKSk/KD86XFxcXCsoWzAtOWEtekEtWi1dKyg/OlxcXFwuWzAtOWEtekEtWi1dKykqKSk/JFwiIH0sIFwibmFtZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiUGFja2FnZSBOYW1lXCIsIFwibWluTGVuZ3RoXCI6IDEsIFwibWF4TGVuZ3RoXCI6IDIxNCwgXCJwYXR0ZXJuXCI6IFwiXig/OkBbYS16MC05LSp+XVthLXowLTktKi5ffl0qLyk/W2EtejAtOS1+XVthLXowLTktLl9+XSokXCIgfSwgXCJwcml2YXRlXCI6IHsgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLCBcInRpdGxlXCI6IFwiUHJpdmF0ZVwiIH0sIFwibWFpblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiLCBcInRpdGxlXCI6IFwiTWFpblwiLCBcIm1pbkxlbmd0aFwiOiAxIH0sIFwicHVibGlzaENvbmZpZ1wiOiB7IFwidHlwZVwiOiBcIm9iamVjdFwiLCBcInRpdGxlXCI6IFwiUHVibGlzaCBDb25maWdcIiwgXCJyZXF1aXJlZFwiOiBbXCJyZWdpc3RyeVwiXSwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJhY2Nlc3NcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJtaW5MZW5ndGhcIjogMSB9LCBcInJlZ2lzdHJ5XCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwiZW51bVwiOiBbXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZ1wiLCBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL1wiXSB9IH0gfSwgXCJyZXBvc2l0b3J5XCI6IHsgXCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwidGl0bGVcIjogXCJSZXBvc2l0b3J5XCIsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsIFwicmVxdWlyZWRcIjogW1widHlwZVwiLCBcInVybFwiXSwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJ0eXBlXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwibWluTGVuZ3RoXCI6IDEgfSwgXCJ1cmxcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJtaW5MZW5ndGhcIjogMSB9IH0gfSB9IH07XG5jb25zdCBwYXR0ZXJuMCA9IG5ldyBSZWdFeHAoXCJeKDB8WzEtOV1cXFxcZCopXFxcXC4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKSg/Oi0oKD86MHxbMS05XVxcXFxkKnxcXFxcZCpbYS16QS1aLV1bMC05YS16QS1aLV0qKSg/OlxcXFwuKD86MHxbMS05XVxcXFxkKnxcXFxcZCpbYS16QS1aLV1bMC05YS16QS1aLV0qKSkqKSk/KD86XFxcXCsoWzAtOWEtekEtWi1dKyg/OlxcXFwuWzAtOWEtekEtWi1dKykqKSk/JFwiLCBcInVcIik7XG5jb25zdCBwYXR0ZXJuMSA9IG5ldyBSZWdFeHAoXCJeKD86QFthLXowLTktKn5dW2EtejAtOS0qLl9+XSovKT9bYS16MC05LX5dW2EtejAtOS0uX35dKiRcIiwgXCJ1XCIpO1xuY29uc3QgZnVuYzggPSByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQ7XG5jb25zdCBmdW5jMCA9IHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQ7XG5mdW5jdGlvbiB2YWxpZGF0ZTIwKGRhdGEsIHsgaW5zdGFuY2VQYXRoID0gXCJcIiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5LCByb290RGF0YSA9IGRhdGEgfSA9IHt9KSB7IGxldCB2RXJyb3JzID0gbnVsbDsgbGV0IGVycm9ycyA9IDA7IGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBpZiAoZGF0YS52ZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyMCA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInZlcnNpb25cIiB9LCBtZXNzYWdlOiBcIm11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnXCIgKyBcInZlcnNpb25cIiArIFwiJ1wiIH07XG4gICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICB2RXJyb3JzID0gW2VycjBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjApO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycysrO1xuICAgIH1cbiAgICBpZiAoZGF0YS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZXJyMSA9IHsgaW5zdGFuY2VQYXRoLCBzY2hlbWFQYXRoOiBcIiMvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcIm5hbWVcIiB9LCBtZXNzYWdlOiBcIm11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnXCIgKyBcIm5hbWVcIiArIFwiJ1wiIH07XG4gICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICB2RXJyb3JzID0gW2VycjFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycysrO1xuICAgIH1cbiAgICBpZiAoZGF0YS52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGEwID0gZGF0YS52ZXJzaW9uO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4wLnRlc3QoZGF0YTApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyMiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi92ZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3ZlcnNpb24vcGF0dGVyblwiLCBrZXl3b3JkOiBcInBhdHRlcm5cIiwgcGFyYW1zOiB7IHBhdHRlcm46IFwiXigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopXFxcXC4oMHxbMS05XVxcXFxkKikoPzotKCg/OjB8WzEtOV1cXFxcZCp8XFxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikoPzpcXFxcLig/OjB8WzEtOV1cXFxcZCp8XFxcXGQqW2EtekEtWi1dWzAtOWEtekEtWi1dKikpKikpPyg/OlxcXFwrKFswLTlhLXpBLVotXSsoPzpcXFxcLlswLTlhLXpBLVotXSspKikpPyRcIiB9LCBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggcGF0dGVybiBcXFwiXCIgKyBcIl4oMHxbMS05XVxcXFxkKilcXFxcLigwfFsxLTldXFxcXGQqKVxcXFwuKDB8WzEtOV1cXFxcZCopKD86LSgoPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKD86XFxcXC4oPzowfFsxLTldXFxcXGQqfFxcXFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKSopKT8oPzpcXFxcKyhbMC05YS16QS1aLV0rKD86XFxcXC5bMC05YS16QS1aLV0rKSopKT8kXCIgKyBcIlxcXCJcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyMyA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi92ZXJzaW9uXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3ZlcnNpb24vdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGExID0gZGF0YS5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGExID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZnVuYzgoZGF0YTEpID4gMjE0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyNCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9uYW1lXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL25hbWUvbWF4TGVuZ3RoXCIsIGtleXdvcmQ6IFwibWF4TGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMjE0IH0sIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gMjE0IGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyNF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmM4KGRhdGExKSA8IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnI1ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL25hbWVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvbmFtZS9taW5MZW5ndGhcIiwga2V5d29yZDogXCJtaW5MZW5ndGhcIiwgcGFyYW1zOiB7IGxpbWl0OiAxIH0sIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBmZXdlciB0aGFuIDEgY2hhcmFjdGVyc1wiIH07XG4gICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4xLnRlc3QoZGF0YTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyNiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9uYW1lXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL25hbWUvcGF0dGVyblwiLCBrZXl3b3JkOiBcInBhdHRlcm5cIiwgcGFyYW1zOiB7IHBhdHRlcm46IFwiXig/OkBbYS16MC05LSp+XVthLXowLTktKi5ffl0qLyk/W2EtejAtOS1+XVthLXowLTktLl9+XSokXCIgfSwgbWVzc2FnZTogXCJtdXN0IG1hdGNoIHBhdHRlcm4gXFxcIlwiICsgXCJeKD86QFthLXowLTktKn5dW2EtejAtOS0qLl9+XSovKT9bYS16MC05LX5dW2EtejAtOS0uX35dKiRcIiArIFwiXFxcIlwiIH07XG4gICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnI3ID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL25hbWVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvbmFtZS90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnI3XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnI3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLnByaXZhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEucHJpdmF0ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycjggPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcHJpdmF0ZVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9wcml2YXRlL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcImJvb2xlYW5cIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgYm9vbGVhblwiIH07XG4gICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyOF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5tYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGEzID0gZGF0YS5tYWluO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZnVuYzgoZGF0YTMpIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycjkgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvbWFpblwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9tYWluL21pbkxlbmd0aFwiLCBrZXl3b3JkOiBcIm1pbkxlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDEgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGZld2VyIHRoYW4gMSBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycjEwID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL21haW5cIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvbWFpbi90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIxMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEucHVibGlzaENvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBkYXRhNCA9IGRhdGEucHVibGlzaENvbmZpZztcbiAgICAgICAgaWYgKGRhdGE0ICYmIHR5cGVvZiBkYXRhNCA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGE0KSkge1xuICAgICAgICAgICAgaWYgKGRhdGE0LnJlZ2lzdHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIxMSA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9wdWJsaXNoQ29uZmlnXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3B1Ymxpc2hDb25maWcvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInJlZ2lzdHJ5XCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJyZWdpc3RyeVwiICsgXCInXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjExXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGE0LmFjY2VzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE1ID0gZGF0YTQuYWNjZXNzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YTUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmM4KGRhdGE1KSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjEyID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3B1Ymxpc2hDb25maWcvYWNjZXNzXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3B1Ymxpc2hDb25maWcvcHJvcGVydGllcy9hY2Nlc3MvbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMSB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgZmV3ZXIgdGhhbiAxIGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMTMgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcHVibGlzaENvbmZpZy9hY2Nlc3NcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcHVibGlzaENvbmZpZy9wcm9wZXJ0aWVzL2FjY2Vzcy90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaW5nXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjEzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTQucmVnaXN0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhNiA9IGRhdGE0LnJlZ2lzdHJ5O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YTYgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMTQgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcHVibGlzaENvbmZpZy9yZWdpc3RyeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9wdWJsaXNoQ29uZmlnL3Byb3BlcnRpZXMvcmVnaXN0cnkvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKChkYXRhNiA9PT0gXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZ1wiKSB8fCAoZGF0YTYgPT09IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIxNSA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9wdWJsaXNoQ29uZmlnL3JlZ2lzdHJ5XCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3B1Ymxpc2hDb25maWcvcHJvcGVydGllcy9yZWdpc3RyeS9lbnVtXCIsIGtleXdvcmQ6IFwiZW51bVwiLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlczogc2NoZW1hMjIucHJvcGVydGllcy5wdWJsaXNoQ29uZmlnLnByb3BlcnRpZXMucmVnaXN0cnkuZW51bSB9LCBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE1XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyMTYgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcHVibGlzaENvbmZpZ1wiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9wdWJsaXNoQ29uZmlnL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcIm9iamVjdFwiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBvYmplY3RcIiB9O1xuICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5yZXBvc2l0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGRhdGE3ID0gZGF0YS5yZXBvc2l0b3J5O1xuICAgICAgICBpZiAoZGF0YTcgJiYgdHlwZW9mIGRhdGE3ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YTcpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YTcudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyMTcgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L3JlcXVpcmVkXCIsIGtleXdvcmQ6IFwicmVxdWlyZWRcIiwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXCJ0eXBlXCIgfSwgbWVzc2FnZTogXCJtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJ1wiICsgXCJ0eXBlXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjE3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTcudXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIxOCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5XCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvcmVxdWlyZWRcIiwga2V5d29yZDogXCJyZXF1aXJlZFwiLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcInVybFwiIH0sIG1lc3NhZ2U6IFwibXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICdcIiArIFwidXJsXCIgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMThdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjE4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleTAgaW4gZGF0YTcpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoa2V5MCA9PT0gXCJ0eXBlXCIpIHx8IChrZXkwID09PSBcInVybFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMTkgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5MCB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMgPSBbZXJyMTldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycy5wdXNoKGVycjE5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTcudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE4ID0gZGF0YTcudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGE4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jOChkYXRhOCkgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIyMCA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5L3R5cGVcIiwgc2NoZW1hUGF0aDogXCIjL3Byb3BlcnRpZXMvcmVwb3NpdG9yeS9wcm9wZXJ0aWVzL3R5cGUvbWluTGVuZ3RoXCIsIGtleXdvcmQ6IFwibWluTGVuZ3RoXCIsIHBhcmFtczogeyBsaW1pdDogMSB9LCBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgZmV3ZXIgdGhhbiAxIGNoYXJhY3RlcnNcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjIwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyMjEgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeS90eXBlXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvcHJvcGVydGllcy90eXBlL3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcInN0cmluZ1wiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBzdHJpbmdcIiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIyMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMjEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhNy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhOSA9IGRhdGE3LnVybDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGE5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jOChkYXRhOSkgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIyMiA9IHsgaW5zdGFuY2VQYXRoOiBpbnN0YW5jZVBhdGggKyBcIi9yZXBvc2l0b3J5L3VybFwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L3Byb3BlcnRpZXMvdXJsL21pbkxlbmd0aFwiLCBrZXl3b3JkOiBcIm1pbkxlbmd0aFwiLCBwYXJhbXM6IHsgbGltaXQ6IDEgfSwgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGZld2VyIHRoYW4gMSBjaGFyYWN0ZXJzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdkVycm9ycyA9IFtlcnIyMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzLnB1c2goZXJyMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycjIzID0geyBpbnN0YW5jZVBhdGg6IGluc3RhbmNlUGF0aCArIFwiL3JlcG9zaXRvcnkvdXJsXCIsIHNjaGVtYVBhdGg6IFwiIy9wcm9wZXJ0aWVzL3JlcG9zaXRvcnkvcHJvcGVydGllcy91cmwvdHlwZVwiLCBrZXl3b3JkOiBcInR5cGVcIiwgcGFyYW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSwgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmluZ1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2RXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjIzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyMjQgPSB7IGluc3RhbmNlUGF0aDogaW5zdGFuY2VQYXRoICsgXCIvcmVwb3NpdG9yeVwiLCBzY2hlbWFQYXRoOiBcIiMvcHJvcGVydGllcy9yZXBvc2l0b3J5L3R5cGVcIiwga2V5d29yZDogXCJ0eXBlXCIsIHBhcmFtczogeyB0eXBlOiBcIm9iamVjdFwiIH0sIG1lc3NhZ2U6IFwibXVzdCBiZSBvYmplY3RcIiB9O1xuICAgICAgICAgICAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2RXJyb3JzID0gW2VycjI0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZFcnJvcnMucHVzaChlcnIyNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMrKztcbiAgICAgICAgfVxuICAgIH1cbn1cbmVsc2Uge1xuICAgIGNvbnN0IGVycjI1ID0geyBpbnN0YW5jZVBhdGgsIHNjaGVtYVBhdGg6IFwiIy90eXBlXCIsIGtleXdvcmQ6IFwidHlwZVwiLCBwYXJhbXM6IHsgdHlwZTogXCJvYmplY3RcIiB9LCBtZXNzYWdlOiBcIm11c3QgYmUgb2JqZWN0XCIgfTtcbiAgICBpZiAodkVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICB2RXJyb3JzID0gW2VycjI1XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZFcnJvcnMucHVzaChlcnIyNSk7XG4gICAgfVxuICAgIGVycm9ycysrO1xufSB2YWxpZGF0ZTIwLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiB2RXJyb3JzOyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZU5wbVNuYXBQYWNrYWdlSnNvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkYWJsZVdlYlRvTm9kZVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbi8qKlxuICogQ29udmVydHMgYSBXZWItQVBJIHN0cmVhbSBpbnRvIE5vZGUgc3RyZWFtLlJlYWRhYmxlIGNsYXNzXG4gKiBOb2RlIHN0cmVhbSByZWFkYWJsZTogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfc3RyZWFtc1xuICogV2ViIEFQSSByZWFkYWJsZS1zdHJlYW06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZWFkYWJsZVN0cmVhbVxuICogTm9kZSByZWFkYWJsZSBzdHJlYW06IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3N0cmVhbXNcbiAqL1xuY2xhc3MgUmVhZGFibGVXZWJUb05vZGVTdHJlYW0gZXh0ZW5kcyByZWFkYWJsZV9zdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyZWFtIFJlYWRhYmxl4oCLU3RyZWFtOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ieXRlc1JlYWQgPSAwO1xuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiByZWFkYWJsZS5fcmVhZChzaXplKS5cbiAgICAgKiBXaGVuIHJlYWRhYmxlLl9yZWFkKCkgaXMgY2FsbGVkLCBpZiBkYXRhIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSByZXNvdXJjZSxcbiAgICAgKiB0aGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlZ2luIHB1c2hpbmcgdGhhdCBkYXRhIGludG8gdGhlIHJlYWQgcXVldWVcbiAgICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9yZWFkX3NpemVfMVxuICAgICAqL1xuICAgIGFzeW5jIF9yZWFkKCkge1xuICAgICAgICAvLyBTaG91bGQgc3RhcnQgcHVzaGluZyBkYXRhIGludG8gdGhlIHF1ZXVlXG4gICAgICAgIC8vIFJlYWQgZGF0YSBmcm9tIHRoZSB1bmRlcmx5aW5nIFdlYi1BUEktcmVhZGFibGUtc3RyZWFtXG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7IC8vIFNpZ25hbCBFT0ZcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdSZWFkID0gdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5wZW5kaW5nUmVhZDtcbiAgICAgICAgLy8gY2xlYXIgdGhlIHByb21pc2UgYmVmb3JlIHB1c2hpbmcgcHVzaGluZyBuZXcgZGF0YSB0byB0aGUgcXVldWUgYW5kIGFsbG93IHNlcXVlbnRpYWwgY2FsbHMgdG8gX3JlYWQoKVxuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVhZDtcbiAgICAgICAgaWYgKGRhdGEuZG9uZSB8fCB0aGlzLnJlbGVhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7IC8vIFNpZ25hbCBFT0ZcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNSZWFkICs9IGRhdGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEudmFsdWUpOyAvLyBQdXNoIG5ldyBkYXRhIHRvIHRoZSBxdWV1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIHVucmVzb2x2ZWQgcmVhZCBjYWxsIHRvIFdlYi1BUEkgUmVhZGFibGXigItTdHJlYW0gaW1tZWRpYXRlbHkgcmV0dXJucztcbiAgICAgKiBvdGhlcndpc2Ugd2lsbCB3YWl0IHVudGlsIHRoZSByZWFkIGlzIHJlc29sdmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JSZWFkVG9Db21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1JlYWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVuZGluZ1JlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2Ugd3JhcHBlclxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnN5bmNBbmRSZWxlYXNlKCk7XG4gICAgfVxuICAgIGFzeW5jIHN5bmNBbmRSZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yUmVhZFRvQ29tcGxldGUoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlV2ViVG9Ob2RlU3RyZWFtID0gUmVhZGFibGVXZWJUb05vZGVTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5Xcml0YWJsZVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgVTggPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIENvbmNhdFN0cmVhbShvcHRzLCBjYikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29uY2F0U3RyZWFtKSkgcmV0dXJuIG5ldyBDb25jYXRTdHJlYW0ob3B0cywgY2IpXG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nXG4gIHZhciBzaG91bGRJbmZlckVuY29kaW5nID0gZmFsc2VcblxuICBpZiAoIWVuY29kaW5nKSB7XG4gICAgc2hvdWxkSW5mZXJFbmNvZGluZyA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZyA9ICBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1OCcgfHwgZW5jb2RpbmcgPT09ICd1aW50OCcpIHtcbiAgICAgIGVuY29kaW5nID0gJ3VpbnQ4YXJyYXknXG4gICAgfVxuICB9XG5cbiAgV3JpdGFibGUuY2FsbCh0aGlzLCB7IG9iamVjdE1vZGU6IHRydWUgfSlcblxuICB0aGlzLmVuY29kaW5nID0gZW5jb2RpbmdcbiAgdGhpcy5zaG91bGRJbmZlckVuY29kaW5nID0gc2hvdWxkSW5mZXJFbmNvZGluZ1xuXG4gIGlmIChjYikgdGhpcy5vbignZmluaXNoJywgZnVuY3Rpb24gKCkgeyBjYih0aGlzLmdldEJvZHkoKSkgfSlcbiAgdGhpcy5ib2R5ID0gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb25jYXRTdHJlYW1cbmluaGVyaXRzKENvbmNhdFN0cmVhbSwgV3JpdGFibGUpXG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuYywgbmV4dCkge1xuICB0aGlzLmJvZHkucHVzaChjaHVuaylcbiAgbmV4dCgpXG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuaW5mZXJFbmNvZGluZyA9IGZ1bmN0aW9uIChidWZmKSB7XG4gIHZhciBmaXJzdEJ1ZmZlciA9IGJ1ZmYgPT09IHVuZGVmaW5lZCA/IHRoaXMuYm9keVswXSA6IGJ1ZmY7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZmlyc3RCdWZmZXIpKSByZXR1cm4gJ2J1ZmZlcidcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBmaXJzdEJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiAndWludDhhcnJheSdcbiAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RCdWZmZXIpKSByZXR1cm4gJ2FycmF5J1xuICBpZiAodHlwZW9mIGZpcnN0QnVmZmVyID09PSAnc3RyaW5nJykgcmV0dXJuICdzdHJpbmcnXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZmlyc3RCdWZmZXIpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gJ29iamVjdCdcbiAgcmV0dXJuICdidWZmZXInXG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuZ2V0Qm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmVuY29kaW5nICYmIHRoaXMuYm9keS5sZW5ndGggPT09IDApIHJldHVybiBbXVxuICBpZiAodGhpcy5zaG91bGRJbmZlckVuY29kaW5nKSB0aGlzLmVuY29kaW5nID0gdGhpcy5pbmZlckVuY29kaW5nKClcbiAgaWYgKHRoaXMuZW5jb2RpbmcgPT09ICdhcnJheScpIHJldHVybiBhcnJheUNvbmNhdCh0aGlzLmJvZHkpXG4gIGlmICh0aGlzLmVuY29kaW5nID09PSAnc3RyaW5nJykgcmV0dXJuIHN0cmluZ0NvbmNhdCh0aGlzLmJvZHkpXG4gIGlmICh0aGlzLmVuY29kaW5nID09PSAnYnVmZmVyJykgcmV0dXJuIGJ1ZmZlckNvbmNhdCh0aGlzLmJvZHkpXG4gIGlmICh0aGlzLmVuY29kaW5nID09PSAndWludDhhcnJheScpIHJldHVybiB1OENvbmNhdCh0aGlzLmJvZHkpXG4gIHJldHVybiB0aGlzLmJvZHlcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoYXJyKSB7XG4gIHJldHVybiAvQXJyYXlcXF0kLy50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlcmlzaCAocCkge1xuICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXlpc2gocCkgfHwgKHAgJiYgdHlwZW9mIHAuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvbmNhdCAocGFydHMpIHtcbiAgdmFyIHN0cmluZ3MgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXJ0c1tpXVxuICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmluZ3MucHVzaChwKVxuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHApKSB7XG4gICAgICBzdHJpbmdzLnB1c2gocClcbiAgICB9IGVsc2UgaWYgKGlzQnVmZmVyaXNoKHApKSB7XG4gICAgICBzdHJpbmdzLnB1c2goQnVmZmVyLmZyb20ocCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmluZ3MucHVzaChCdWZmZXIuZnJvbShTdHJpbmcocCkpKVxuICAgIH1cbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhcnRzWzBdKSkge1xuICAgIHN0cmluZ3MgPSBCdWZmZXIuY29uY2F0KHN0cmluZ3MpXG4gICAgc3RyaW5ncyA9IHN0cmluZ3MudG9TdHJpbmcoJ3V0ZjgnKVxuICB9IGVsc2Uge1xuICAgIHN0cmluZ3MgPSBzdHJpbmdzLmpvaW4oJycpXG4gIH1cbiAgcmV0dXJuIHN0cmluZ3Ncbn1cblxuZnVuY3Rpb24gYnVmZmVyQ29uY2F0IChwYXJ0cykge1xuICB2YXIgYnVmcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhcnRzW2ldXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwKSkge1xuICAgICAgYnVmcy5wdXNoKHApXG4gICAgfSBlbHNlIGlmIChpc0J1ZmZlcmlzaChwKSkge1xuICAgICAgYnVmcy5wdXNoKEJ1ZmZlci5mcm9tKHApKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZzLnB1c2goQnVmZmVyLmZyb20oU3RyaW5nKHApKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmcylcbn1cblxuZnVuY3Rpb24gYXJyYXlDb25jYXQgKHBhcnRzKSB7XG4gIHZhciByZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2guYXBwbHkocmVzLCBwYXJ0c1tpXSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHU4Q29uY2F0IChwYXJ0cykge1xuICB2YXIgbGVuID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0c1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcnRzW2ldID0gQnVmZmVyLmZyb20ocGFydHNbaV0pXG4gICAgfVxuICAgIGxlbiArPSBwYXJ0c1tpXS5sZW5ndGhcbiAgfVxuICB2YXIgdTggPSBuZXcgVTgobGVuKVxuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydC5sZW5ndGg7IGorKykge1xuICAgICAgdThbb2Zmc2V0KytdID0gcGFydFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdThcbn1cbiIsImV4cG9ydHMuZXh0cmFjdCA9IHJlcXVpcmUoJy4vZXh0cmFjdCcpXG5leHBvcnRzLnBhY2sgPSByZXF1aXJlKCcuL3BhY2snKVxuIiwidmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJylcbnZhciBwZWVrID0gcmVxdWlyZSgncGVlay1zdHJlYW0nKVxudmFyIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoMicpXG52YXIgcHVtcGlmeSA9IHJlcXVpcmUoJ3B1bXBpZnknKVxudmFyIGlzR3ppcCA9IHJlcXVpcmUoJ2lzLWd6aXAnKVxudmFyIGlzRGVmbGF0ZSA9IHJlcXVpcmUoJ2lzLWRlZmxhdGUnKVxuXG52YXIgaXNDb21wcmVzc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKGlzR3ppcChkYXRhKSkgcmV0dXJuIDFcbiAgaWYgKGlzRGVmbGF0ZShkYXRhKSkgcmV0dXJuIDJcbiAgcmV0dXJuIDBcbn1cblxudmFyIGd1bnppcCA9IGZ1bmN0aW9uIChtYXhSZWN1cnNpb24pIHtcbiAgaWYgKG1heFJlY3Vyc2lvbiA9PT0gdW5kZWZpbmVkKSBtYXhSZWN1cnNpb24gPSAzXG5cbiAgcmV0dXJuIHBlZWsoe25ld2xpbmU6IGZhbHNlLCBtYXhCdWZmZXI6IDEwfSwgZnVuY3Rpb24gKGRhdGEsIHN3YXApIHtcbiAgICBpZiAobWF4UmVjdXJzaW9uIDwgMCkgcmV0dXJuIHN3YXAobmV3IEVycm9yKCdNYXhpbXVtIHJlY3Vyc2lvbiByZWFjaGVkJykpXG4gICAgc3dpdGNoIChpc0NvbXByZXNzZWQoZGF0YSkpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc3dhcChudWxsLCBwdW1waWZ5KHpsaWIuY3JlYXRlR3VuemlwKCksIGd1bnppcChtYXhSZWN1cnNpb24gLSAxKSkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHN3YXAobnVsbCwgcHVtcGlmeSh6bGliLmNyZWF0ZUluZmxhdGUoKSwgZ3VuemlwKG1heFJlY3Vyc2lvbiAtIDEpKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3YXAobnVsbCwgdGhyb3VnaCgpKVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBndW56aXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgT2JqZWN0TXVsdGlwbGV4XzEgPSByZXF1aXJlKFwiLi9PYmplY3RNdWx0aXBsZXhcIik7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdE11bHRpcGxleF8xLk9iamVjdE11bHRpcGxleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TTkFQX1NUUkVBTV9OQU1FUyA9IHZvaWQgMDtcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTTkFQX1NUUkVBTV9OQU1FU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5TVFJFQU1fTkFNRVM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtTWlkZGxld2FyZSA9IGV4cG9ydHMuY3JlYXRlRW5naW5lU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgY3JlYXRlRW5naW5lU3RyZWFtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlRW5naW5lU3RyZWFtXCIpKTtcbmV4cG9ydHMuY3JlYXRlRW5naW5lU3RyZWFtID0gY3JlYXRlRW5naW5lU3RyZWFtXzEuZGVmYXVsdDtcbmNvbnN0IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVTdHJlYW1NaWRkbGV3YXJlXCIpKTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtTWlkZGxld2FyZSA9IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmVfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtID0gZXhwb3J0cy5Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbSA9IGV4cG9ydHMuV2luZG93UG9zdE1lc3NhZ2VTdHJlYW0gPSB2b2lkIDA7XG52YXIgV2luZG93UG9zdE1lc3NhZ2VTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1dpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2luZG93UG9zdE1lc3NhZ2VTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtXzEuV2luZG93UG9zdE1lc3NhZ2VTdHJlYW07IH0gfSk7XG52YXIgV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1dvcmtlclBvc3RNZXNzYWdlU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdvcmtlclBvc3RNZXNzYWdlU3RyZWFtXzEuV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW07IH0gfSk7XG52YXIgV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1dvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtXzEuV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW07IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciBgZXRoX2FjY291bnRzYCB0aGF0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkgd2hlbiBwZXJtaXNzaW9uIGlzIGRlbmllZC5cbiAqL1xuXG5jb25zdCByZXF1ZXN0RXRoZXJldW1BY2NvdW50cyA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuRVRIX0FDQ09VTlRTXSxcbiAgaW1wbGVtZW50YXRpb246IGV0aEFjY291bnRzSGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgZ2V0QWNjb3VudHM6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgcmVxdWVzdEV0aGVyZXVtQWNjb3VudHM7XG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uPn0gRXRoQWNjb3VudHNPcHRpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRBY2NvdW50cyAtIEdldHMgdGhlIGFjY291bnRzIGZvciB0aGUgcmVxdWVzdGluZ1xuICogb3JpZ2luLlxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVxdWVzdDx1bmtub3duPn0gX3JlcSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVzcG9uc2U8dHJ1ZT59IHJlcyAtIFRoZSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBfbmV4dCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ25leHQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kIC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnZW5kJyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7RXRoQWNjb3VudHNPcHRpb25zfSBvcHRpb25zIC0gVGhlIFJQQyBtZXRob2QgaG9va3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV0aEFjY291bnRzSGFuZGxlcihfcmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgZ2V0QWNjb3VudHMgfSkge1xuICByZXMucmVzdWx0ID0gYXdhaXQgZ2V0QWNjb3VudHMoKTtcbiAgcmV0dXJuIGVuZCgpO1xufVxuIiwiaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xuXG5jb25zdCB3YXRjaEFzc2V0ID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5XQVRDSF9BU1NFVCwgTUVTU0FHRV9UWVBFLldBVENIX0FTU0VUX0xFR0FDWV0sXG4gIGltcGxlbWVudGF0aW9uOiB3YXRjaEFzc2V0SGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgaGFuZGxlV2F0Y2hBc3NldFJlcXVlc3Q6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgd2F0Y2hBc3NldDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXYXRjaEFzc2V0T3B0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaGFuZGxlV2F0Y2hBc3NldFJlcXVlc3QgLSBUaGUgd2FsbGV0X3dhdGNoQXNzZXQgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2F0Y2hBc3NldFBhcmFtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhc3NldCB0byB3YXRjaC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zIC0gV2F0Y2ggb3B0aW9ucyBmb3IgdGhlIGFzc2V0LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PFdhdGNoQXNzZXRQYXJhbT59IHJlcSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVzcG9uc2U8dHJ1ZT59IHJlcyAtIFRoZSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBfbmV4dCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ25leHQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5kIC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnZW5kJyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7V2F0Y2hBc3NldE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd2F0Y2hBc3NldEhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7IGhhbmRsZVdhdGNoQXNzZXRSZXF1ZXN0IH0sXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IGFzc2V0LCB0eXBlIH0gPSByZXEucGFyYW1zO1xuICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBoYW5kbGVXYXRjaEFzc2V0UmVxdWVzdChhc3NldCwgdHlwZSk7XG4gICAgcmV0dXJuIGVuZCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5cbi8qKlxuICogVGhpcyBSUEMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgaW5wYWdlIHByb3ZpZGVyIHdoZW5ldmVyIGl0IGRldGVjdHMgdGhlXG4gKiBhY2Nlc3Npbmcgb2YgYSBub24tZXhpc3RlbnQgcHJvcGVydHkgb24gb3VyIHdpbmRvdy53ZWIzIHNoaW0uXG4gKiBXZSBjb2xsZWN0IHRoaXMgZGF0YSB0byB1bmRlcnN0YW5kIHdoaWNoIHNpdGVzIGFyZSBicmVha2luZyBkdWUgdG8gdGhlXG4gKiByZW1vdmFsIG9mIG91ciB3aW5kb3cud2ViMy5cbiAqL1xuXG5jb25zdCBsb2dXZWIzU2hpbVVzYWdlID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5MT0dfV0VCM19TSElNX1VTQUdFXSxcbiAgaW1wbGVtZW50YXRpb246IGxvZ1dlYjNTaGltVXNhZ2VIYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBzZW5kTWV0cmljczogdHJ1ZSxcbiAgICBnZXRXZWIzU2hpbVVzYWdlU3RhdGU6IHRydWUsXG4gICAgc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkOiB0cnVlLFxuICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IGxvZ1dlYjNTaGltVXNhZ2U7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTG9nV2ViM1NoaW1Vc2FnZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNlbmRNZXRyaWNzIC0gQSBmdW5jdGlvbiB0aGF0IHJlZ2lzdGVycyBhIG1ldHJpY3MgZXZlbnQuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRXZWIzU2hpbVVzYWdlU3RhdGUgLSBBIGZ1bmN0aW9uIHRoYXQgZ2V0cyB3ZWIzIHNoaW1cbiAqIHVzYWdlIHN0YXRlIGZvciB0aGUgZ2l2ZW4gb3JpZ2luLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkIC0gQSBmdW5jdGlvbiB0aGF0IHJlY29yZHMgd2ViMyBzaGltXG4gKiB1c2FnZSBmb3IgYSBwYXJ0aWN1bGFyIG9yaWdpbi5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdqc29uLXJwYy1lbmdpbmUnKS5Kc29uUnBjUmVxdWVzdDx1bmtub3duPn0gcmVxIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXNwb25zZTx0cnVlPn0gcmVzIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IF9uZXh0IC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnbmV4dCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmQgLSBUaGUganNvbi1ycGMtZW5naW5lICdlbmQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtMb2dXZWIzU2hpbVVzYWdlT3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBsb2dXZWIzU2hpbVVzYWdlSGFuZGxlcihcbiAgcmVxLFxuICByZXMsXG4gIF9uZXh0LFxuICBlbmQsXG4gIHsgc2VuZE1ldHJpY3MsIGdldFdlYjNTaGltVXNhZ2VTdGF0ZSwgc2V0V2ViM1NoaW1Vc2FnZVJlY29yZGVkIH0sXG4pIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IHJlcTtcbiAgaWYgKGdldFdlYjNTaGltVXNhZ2VTdGF0ZShvcmlnaW4pID09PSB1bmRlZmluZWQpIHtcbiAgICBzZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQob3JpZ2luKTtcblxuICAgIHNlbmRNZXRyaWNzKFxuICAgICAge1xuICAgICAgICBldmVudDogYFdlYnNpdGUgQWNjZXNzZWQgd2luZG93LndlYjMgU2hpbWAsXG4gICAgICAgIGNhdGVnb3J5OiAnaW5wYWdlX3Byb3ZpZGVyJyxcbiAgICAgICAgcmVmZXJyZXI6IHtcbiAgICAgICAgICB1cmw6IG9yaWdpbixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGV4Y2x1ZGVNZXRhTWV0cmljc0lkOiB0cnVlLFxuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgcmVzLnJlc3VsdCA9IHRydWU7XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byByZXRyaWV2ZSB0aGUgRXRoZXJldW0gYWNjb3VudHMgYXZhaWxhYmxlIHRvIHRoZVxuICogcmVxdWVzdGVyLCBvciBpbml0aWF0ZSBhIHJlcXVlc3QgZm9yIGFjY291bnQgYWNjZXNzIGlmIG5vbmUgYXJlIGN1cnJlbnRseVxuICogYXZhaWxhYmxlLiBJdCBpcyBlc3NlbnRpYWxseSBhIHdyYXBwZXIgb2Ygd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9ucyB0aGF0XG4gKiBvbmx5IGVycm9ycyBpZiB0aGUgdXNlciByZWplY3RzIHRoZSByZXF1ZXN0LiBXZSBtYWludGFpbiB0aGUgbWV0aG9kIGZvclxuICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAqL1xuXG5jb25zdCByZXF1ZXN0RXRoZXJldW1BY2NvdW50cyA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuRVRIX1JFUVVFU1RfQUNDT1VOVFNdLFxuICBpbXBsZW1lbnRhdGlvbjogcmVxdWVzdEV0aGVyZXVtQWNjb3VudHNIYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBvcmlnaW46IHRydWUsXG4gICAgZ2V0QWNjb3VudHM6IHRydWUsXG4gICAgZ2V0VW5sb2NrUHJvbWlzZTogdHJ1ZSxcbiAgICBoYXNQZXJtaXNzaW9uOiB0cnVlLFxuICAgIHJlcXVlc3RBY2NvdW50c1Blcm1pc3Npb246IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgcmVxdWVzdEV0aGVyZXVtQWNjb3VudHM7XG5cbi8vIFVzZWQgdG8gcmF0ZS1saW1pdCBwZW5kaW5nIHJlcXVlc3RzIHRvIG9uZSBwZXIgb3JpZ2luXG5jb25zdCBsb2NrcyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgRnVuY3Rpb24+fSBSZXF1ZXN0RXRoZXJldW1BY2NvdW50c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgcmVxdWVzdGluZyBvcmlnaW4uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBnZXRBY2NvdW50cyAtIEdldHMgdGhlIGFjY291bnRzIGZvciB0aGUgcmVxdWVzdGluZ1xuICogb3JpZ2luLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0VW5sb2NrUHJvbWlzZSAtIEdldHMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlblxuICogdGhlIGV4dGVuc2lvbiB1bmxvY2tzLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaGFzUGVybWlzc2lvbiAtIFJldHVybnMgd2hldGhlciB0aGUgcmVxdWVzdGluZyBvcmlnaW5cbiAqIGhhcyB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uIC0gUmVxdWVzdHMgdGhlIGBldGhfYWNjb3VudHNgXG4gKiBwZXJtaXNzaW9uIGZvciB0aGUgcmVxdWVzdGluZyBvcmlnaW4uXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PHVua25vd24+fSBfcmVxIC0gVGhlIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXNwb25zZTx0cnVlPn0gcmVzIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IF9uZXh0IC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnbmV4dCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmQgLSBUaGUganNvbi1ycGMtZW5naW5lICdlbmQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZXF1ZXN0RXRoZXJldW1BY2NvdW50c09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgUlBDIG1ldGhvZCBob29rcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEV0aGVyZXVtQWNjb3VudHNIYW5kbGVyKFxuICBfcmVxLFxuICByZXMsXG4gIF9uZXh0LFxuICBlbmQsXG4gIHtcbiAgICBvcmlnaW4sXG4gICAgZ2V0QWNjb3VudHMsXG4gICAgZ2V0VW5sb2NrUHJvbWlzZSxcbiAgICBoYXNQZXJtaXNzaW9uLFxuICAgIHJlcXVlc3RBY2NvdW50c1Blcm1pc3Npb24sXG4gIH0sXG4pIHtcbiAgaWYgKGxvY2tzLmhhcyhvcmlnaW4pKSB7XG4gICAgcmVzLmVycm9yID0gZXRoRXJyb3JzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlKFxuICAgICAgYEFscmVhZHkgcHJvY2Vzc2luZyAke01FU1NBR0VfVFlQRS5FVEhfUkVRVUVTVF9BQ0NPVU5UU30uIFBsZWFzZSB3YWl0LmAsXG4gICAgKTtcbiAgICByZXR1cm4gZW5kKCk7XG4gIH1cblxuICBpZiAoaGFzUGVybWlzc2lvbihNRVNTQUdFX1RZUEUuRVRIX0FDQ09VTlRTKSkge1xuICAgIC8vIFdlIHdhaXQgZm9yIHRoZSBleHRlbnNpb24gdG8gdW5sb2NrIGluIHRoaXMgY2FzZSBvbmx5LCBiZWNhdXNlIHBlcm1pc3Npb25cbiAgICAvLyByZXF1ZXN0cyBhcmUgaGFuZGxlZCB3aGVuIHRoZSBleHRlbnNpb24gaXMgdW5sb2NrZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgLy8gbG9jayBzdGF0ZSB3aGVuIHRoZXkgd2VyZSByZWNlaXZlZC5cbiAgICB0cnkge1xuICAgICAgbG9ja3MuYWRkKG9yaWdpbik7XG4gICAgICBhd2FpdCBnZXRVbmxvY2tQcm9taXNlKHRydWUpO1xuICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKCk7XG4gICAgICBlbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZW5kKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbG9ja3MuZGVsZXRlKG9yaWdpbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiBubyBhY2NvdW50cywgcmVxdWVzdCB0aGUgYWNjb3VudHMgcGVybWlzc2lvblxuICB0cnkge1xuICAgIGF3YWl0IHJlcXVlc3RBY2NvdW50c1Blcm1pc3Npb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmVzLmVycm9yID0gZXJyO1xuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgYXBwcm92ZWQgYWNjb3VudHNcbiAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cygpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogdG9vIGhhcmQgdG8gaW5kdWNlLCBzZWUgYmVsb3cgY29tbWVudCAqL1xuICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgIHJlcy5yZXN1bHQgPSBhY2NvdW50cztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGNhdWdodCBpbiB0aGVcbiAgICAvLyBhYm92ZSBjYXRjaCBjbGF1c2VcbiAgICByZXMuZXJyb3IgPSBldGhFcnJvcnMucnBjLmludGVybmFsKFxuICAgICAgJ0FjY291bnRzIHVuZXhwZWN0ZWRseSB1bmF2YWlsYWJsZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZW5kKCk7XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7XG4gIEVUSF9TWU1CT0wsXG4gIENIQUlOX0lEX1RPX1RZUEVfTUFQLFxuICBORVRXT1JLX1RPX05BTUVfTUFQLFxuICBDSEFJTl9JRF9UT19SUENfVVJMX01BUCxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcsXG4gIGlzU2FmZUNoYWluSWQsXG59IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL25ldHdvcmsudXRpbHMnO1xuXG5jb25zdCBzd2l0Y2hFdGhlcmV1bUNoYWluID0ge1xuICBtZXRob2ROYW1lczogW01FU1NBR0VfVFlQRS5TV0lUQ0hfRVRIRVJFVU1fQ0hBSU5dLFxuICBpbXBsZW1lbnRhdGlvbjogc3dpdGNoRXRoZXJldW1DaGFpbkhhbmRsZXIsXG4gIGhvb2tOYW1lczoge1xuICAgIGdldEN1cnJlbnRDaGFpbklkOiB0cnVlLFxuICAgIGZpbmRDdXN0b21ScGNCeTogdHJ1ZSxcbiAgICBzZXRQcm92aWRlclR5cGU6IHRydWUsXG4gICAgdXBkYXRlUnBjVGFyZ2V0OiB0cnVlLFxuICAgIHJlcXVlc3RVc2VyQXBwcm92YWw6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgc3dpdGNoRXRoZXJldW1DaGFpbjtcblxuZnVuY3Rpb24gZmluZEV4aXN0aW5nTmV0d29yayhjaGFpbklkLCBmaW5kQ3VzdG9tUnBjQnkpIHtcbiAgaWYgKGNoYWluSWQgaW4gQ0hBSU5fSURfVE9fVFlQRV9NQVApIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhaW5JZCxcbiAgICAgIHRpY2tlcjogRVRIX1NZTUJPTCxcbiAgICAgIG5pY2tuYW1lOiBORVRXT1JLX1RPX05BTUVfTUFQW2NoYWluSWRdLFxuICAgICAgcnBjVXJsOiBDSEFJTl9JRF9UT19SUENfVVJMX01BUFtjaGFpbklkXSxcbiAgICAgIHR5cGU6IENIQUlOX0lEX1RPX1RZUEVfTUFQW2NoYWluSWRdLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmluZEN1c3RvbVJwY0J5KHsgY2hhaW5JZCB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc3dpdGNoRXRoZXJldW1DaGFpbkhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7XG4gICAgZ2V0Q3VycmVudENoYWluSWQsXG4gICAgZmluZEN1c3RvbVJwY0J5LFxuICAgIHNldFByb3ZpZGVyVHlwZSxcbiAgICB1cGRhdGVScGNUYXJnZXQsXG4gICAgcmVxdWVzdFVzZXJBcHByb3ZhbCxcbiAgfSxcbikge1xuICBpZiAoIXJlcS5wYXJhbXM/LlswXSB8fCB0eXBlb2YgcmVxLnBhcmFtc1swXSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIHNpbmdsZSwgb2JqZWN0IHBhcmFtZXRlci4gUmVjZWl2ZWQ6XFxuJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICByZXEucGFyYW1zLFxuICAgICAgICApfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgeyBvcmlnaW4gfSA9IHJlcTtcblxuICBjb25zdCB7IGNoYWluSWQgfSA9IHJlcS5wYXJhbXNbMF07XG5cbiAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob21pdChyZXEucGFyYW1zWzBdLCBbJ2NoYWluSWQnXSkpO1xuXG4gIGlmIChvdGhlcktleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdW5leHBlY3RlZCBrZXlzIG9uIG9iamVjdCBwYXJhbWV0ZXIuIFVuc3VwcG9ydGVkIGtleXM6XFxuJHtvdGhlcktleXN9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBfY2hhaW5JZCA9IHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyAmJiBjaGFpbklkLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCFpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKF9jaGFpbklkKSkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgMHgtcHJlZml4ZWQsIHVucGFkZGVkLCBub24temVybyBoZXhhZGVjaW1hbCBzdHJpbmcgJ2NoYWluSWQnLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoIWlzU2FmZUNoYWluSWQocGFyc2VJbnQoX2NoYWluSWQsIDE2KSkpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgY2hhaW4gSUQgXCIke19jaGFpbklkfVwiOiBudW1lcmljYWwgdmFsdWUgZ3JlYXRlciB0aGFuIG1heCBzYWZlIHZhbHVlLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0RGF0YSA9IGZpbmRFeGlzdGluZ05ldHdvcmsoX2NoYWluSWQsIGZpbmRDdXN0b21ScGNCeSk7XG4gIGlmIChyZXF1ZXN0RGF0YSkge1xuICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gZ2V0Q3VycmVudENoYWluSWQoKTtcbiAgICBpZiAoY3VycmVudENoYWluSWQgPT09IF9jaGFpbklkKSB7XG4gICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFwcHJvdmVkUmVxdWVzdERhdGEgPSBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOLFxuICAgICAgICByZXF1ZXN0RGF0YSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGNoYWluSWQgaW4gQ0hBSU5fSURfVE9fVFlQRV9NQVApIHtcbiAgICAgICAgc2V0UHJvdmlkZXJUeXBlKGFwcHJvdmVkUmVxdWVzdERhdGEudHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB1cGRhdGVScGNUYXJnZXQoYXBwcm92ZWRSZXF1ZXN0RGF0YSk7XG4gICAgICB9XG4gICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuICByZXR1cm4gZW5kKFxuICAgIGV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgY29kZTogNDkwMiwgLy8gVG8tYmUtc3RhbmRhcmRpemVkIFwidW5yZWNvZ25pemVkIGNoYWluIElEXCIgZXJyb3JcbiAgICAgIG1lc3NhZ2U6IGBVbnJlY29nbml6ZWQgY2hhaW4gSUQgXCIke2NoYWluSWR9XCIuIFRyeSBhZGRpbmcgdGhlIGNoYWluIHVzaW5nICR7TUVTU0FHRV9UWVBFLkFERF9FVEhFUkVVTV9DSEFJTn0gZmlyc3QuYCxcbiAgICB9KSxcbiAgKTtcbn1cbiIsImltcG9ydCB7IGV0aEVycm9ycywgZXJyb3JDb2RlcyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCB2YWxpZFVybCBmcm9tICd2YWxpZC11cmwnO1xuaW1wb3J0IHsgb21pdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQge1xuICBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nLFxuICBpc1NhZmVDaGFpbklkLFxufSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzJztcbmltcG9ydCB7IGpzb25ScGNSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcnBjLnV0aWxzJztcbmltcG9ydCB7IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuQUREX0VUSEVSRVVNX0NIQUlOXSxcbiAgaW1wbGVtZW50YXRpb246IGFkZEV0aGVyZXVtQ2hhaW5IYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBhZGRDdXN0b21ScGM6IHRydWUsXG4gICAgZ2V0Q3VycmVudENoYWluSWQ6IHRydWUsXG4gICAgZmluZEN1c3RvbVJwY0J5OiB0cnVlLFxuICAgIHVwZGF0ZVJwY1RhcmdldDogdHJ1ZSxcbiAgICByZXF1ZXN0VXNlckFwcHJvdmFsOiB0cnVlLFxuICAgIHNlbmRNZXRyaWNzOiB0cnVlLFxuICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFkZEV0aGVyZXVtQ2hhaW47XG5cbmFzeW5jIGZ1bmN0aW9uIGFkZEV0aGVyZXVtQ2hhaW5IYW5kbGVyKFxuICByZXEsXG4gIHJlcyxcbiAgX25leHQsXG4gIGVuZCxcbiAge1xuICAgIGFkZEN1c3RvbVJwYyxcbiAgICBnZXRDdXJyZW50Q2hhaW5JZCxcbiAgICBmaW5kQ3VzdG9tUnBjQnksXG4gICAgdXBkYXRlUnBjVGFyZ2V0LFxuICAgIHJlcXVlc3RVc2VyQXBwcm92YWwsXG4gICAgc2VuZE1ldHJpY3MsXG4gIH0sXG4pIHtcbiAgaWYgKCFyZXEucGFyYW1zPy5bMF0gfHwgdHlwZW9mIHJlcS5wYXJhbXNbMF0gIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBzaW5nbGUsIG9iamVjdCBwYXJhbWV0ZXIuIFJlY2VpdmVkOlxcbiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcmVxLnBhcmFtcyxcbiAgICAgICAgKX1gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHsgb3JpZ2luIH0gPSByZXE7XG5cbiAgY29uc3Qge1xuICAgIGNoYWluSWQsXG4gICAgY2hhaW5OYW1lID0gbnVsbCxcbiAgICBibG9ja0V4cGxvcmVyVXJscyA9IG51bGwsXG4gICAgbmF0aXZlQ3VycmVuY3kgPSBudWxsLFxuICAgIHJwY1VybHMsXG4gIH0gPSByZXEucGFyYW1zWzBdO1xuXG4gIGNvbnN0IG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKFxuICAgIG9taXQocmVxLnBhcmFtc1swXSwgW1xuICAgICAgJ2NoYWluSWQnLFxuICAgICAgJ2NoYWluTmFtZScsXG4gICAgICAnYmxvY2tFeHBsb3JlclVybHMnLFxuICAgICAgJ2ljb25VcmxzJyxcbiAgICAgICdycGNVcmxzJyxcbiAgICAgICduYXRpdmVDdXJyZW5jeScsXG4gICAgXSksXG4gICk7XG5cbiAgaWYgKG90aGVyS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCB1bmV4cGVjdGVkIGtleXMgb24gb2JqZWN0IHBhcmFtZXRlci4gVW5zdXBwb3J0ZWQga2V5czpcXG4ke290aGVyS2V5c31gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0VmFsaWRSUENVcmwgPSBBcnJheS5pc0FycmF5KHJwY1VybHMpXG4gICAgPyBycGNVcmxzLmZpbmQoKHJwY1VybCkgPT4gdmFsaWRVcmwuaXNIdHRwc1VyaShycGNVcmwpKVxuICAgIDogbnVsbDtcblxuICBjb25zdCBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCA9XG4gICAgYmxvY2tFeHBsb3JlclVybHMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShibG9ja0V4cGxvcmVyVXJscylcbiAgICAgID8gYmxvY2tFeHBsb3JlclVybHMuZmluZCgoYmxvY2tFeHBsb3JlclVybCkgPT5cbiAgICAgICAgICB2YWxpZFVybC5pc0h0dHBzVXJpKGJsb2NrRXhwbG9yZXJVcmwpLFxuICAgICAgICApXG4gICAgICA6IG51bGw7XG5cbiAgaWYgKCFmaXJzdFZhbGlkUlBDVXJsKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSB2YWxpZCBzdHJpbmcgSFRUUFMgdXJsICdycGNVcmxzJywgUmVjZWl2ZWQ6XFxuJHtycGNVcmxzfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGJsb2NrRXhwbG9yZXJVcmxzICE9PSBudWxsICYmICFmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgbnVsbCBvciBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSB2YWxpZCBzdHJpbmcgSFRUUFMgVVJMICdibG9ja0V4cGxvcmVyVXJsJy4gUmVjZWl2ZWQ6ICR7YmxvY2tFeHBsb3JlclVybHN9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBfY2hhaW5JZCA9IHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyAmJiBjaGFpbklkLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCFpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKF9jaGFpbklkKSkge1xuICAgIHJldHVybiBlbmQoXG4gICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgMHgtcHJlZml4ZWQsIHVucGFkZGVkLCBub24temVybyBoZXhhZGVjaW1hbCBzdHJpbmcgJ2NoYWluSWQnLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoIWlzU2FmZUNoYWluSWQocGFyc2VJbnQoX2NoYWluSWQsIDE2KSkpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgY2hhaW4gSUQgXCIke19jaGFpbklkfVwiOiBudW1lcmljYWwgdmFsdWUgZ3JlYXRlciB0aGFuIG1heCBzYWZlIHZhbHVlLiBSZWNlaXZlZDpcXG4ke2NoYWluSWR9YCxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBpZiAoQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbX2NoYWluSWRdKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIG1lc3NhZ2U6IGBNYXkgbm90IHNwZWNpZnkgZGVmYXVsdCBNZXRhTWFzayBjaGFpbi5gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nTmV0d29yayA9IGZpbmRDdXN0b21ScGNCeSh7IGNoYWluSWQ6IF9jaGFpbklkIH0pO1xuXG4gIGlmIChleGlzdGluZ05ldHdvcmspIHtcbiAgICAvLyBJZiB0aGUgbmV0d29yayBhbHJlYWR5IGV4aXN0cywgdGhlIHJlcXVlc3QgaXMgY29uc2lkZXJlZCBzdWNjZXNzZnVsXG4gICAgcmVzLnJlc3VsdCA9IG51bGw7XG5cbiAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBfY2hhaW5JZCkge1xuICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH1cblxuICAgIC8vIEFzayB0aGUgdXNlciB0byBzd2l0Y2ggdGhlIG5ldHdvcmtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdXBkYXRlUnBjVGFyZ2V0KFxuICAgICAgICBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLlNXSVRDSF9FVEhFUkVVTV9DSEFJTixcbiAgICAgICAgICByZXF1ZXN0RGF0YToge1xuICAgICAgICAgICAgcnBjVXJsOiBleGlzdGluZ05ldHdvcmsucnBjVXJsLFxuICAgICAgICAgICAgY2hhaW5JZDogZXhpc3RpbmdOZXR3b3JrLmNoYWluSWQsXG4gICAgICAgICAgICBuaWNrbmFtZTogZXhpc3RpbmdOZXR3b3JrLm5pY2tuYW1lLFxuICAgICAgICAgICAgdGlja2VyOiBleGlzdGluZ05ldHdvcmsudGlja2VyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIHJlcy5yZXN1bHQgPSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgbWV0aG9kLCBpdCBkb2VzIG5vdCBtYXR0ZXIgaWYgdGhlIHVzZXJcbiAgICAgIC8vIGRlY2xpbmVzIHRvIHN3aXRjaCB0aGUgc2VsZWN0ZWQgbmV0d29yay4gSG93ZXZlciwgb3RoZXIgZXJyb3JzIGluZGljYXRlXG4gICAgICAvLyB0aGF0IHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgIGlmIChlcnJvci5jb2RlICE9PSBlcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQoKTtcbiAgfVxuXG4gIGxldCBlbmRwb2ludENoYWluSWQ7XG5cbiAgdHJ5IHtcbiAgICBlbmRwb2ludENoYWluSWQgPSBhd2FpdCBqc29uUnBjUmVxdWVzdChmaXJzdFZhbGlkUlBDVXJsLCAnZXRoX2NoYWluSWQnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVuZChcbiAgICAgIGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICBtZXNzYWdlOiBgUmVxdWVzdCBmb3IgbWV0aG9kICdldGhfY2hhaW5JZCBvbiAke2ZpcnN0VmFsaWRSUENVcmx9IGZhaWxlZGAsXG4gICAgICAgIGRhdGE6IHsgbmV0d29ya0VycjogZXJyIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKF9jaGFpbklkICE9PSBlbmRwb2ludENoYWluSWQpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYENoYWluIElEIHJldHVybmVkIGJ5IFJQQyBVUkwgJHtmaXJzdFZhbGlkUlBDVXJsfSBkb2VzIG5vdCBtYXRjaCAke19jaGFpbklkfWAsXG4gICAgICAgIGRhdGE6IHsgY2hhaW5JZDogZW5kcG9pbnRDaGFpbklkIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGFpbk5hbWUgIT09ICdzdHJpbmcnIHx8ICFjaGFpbk5hbWUpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIG5vbi1lbXB0eSBzdHJpbmcgJ2NoYWluTmFtZScuIFJlY2VpdmVkOlxcbiR7Y2hhaW5OYW1lfWAsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG4gIGNvbnN0IF9jaGFpbk5hbWUgPVxuICAgIGNoYWluTmFtZS5sZW5ndGggPiAxMDAgPyBjaGFpbk5hbWUuc3Vic3RyaW5nKDAsIDEwMCkgOiBjaGFpbk5hbWU7XG5cbiAgaWYgKG5hdGl2ZUN1cnJlbmN5ICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVDdXJyZW5jeSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShuYXRpdmVDdXJyZW5jeSkpIHtcbiAgICAgIHJldHVybiBlbmQoXG4gICAgICAgIGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIG51bGwgb3Igb2JqZWN0ICduYXRpdmVDdXJyZW5jeScuIFJlY2VpdmVkOlxcbiR7bmF0aXZlQ3VycmVuY3l9YCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMgIT09IDE4KSB7XG4gICAgICByZXR1cm4gZW5kKFxuICAgICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCB0aGUgbnVtYmVyIDE4IGZvciAnbmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMnIHdoZW4gJ25hdGl2ZUN1cnJlbmN5JyBpcyBwcm92aWRlZC4gUmVjZWl2ZWQ6ICR7bmF0aXZlQ3VycmVuY3kuZGVjaW1hbHN9YCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghbmF0aXZlQ3VycmVuY3kuc3ltYm9sIHx8IHR5cGVvZiBuYXRpdmVDdXJyZW5jeS5zeW1ib2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZW5kKFxuICAgICAgICBldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCBhIHN0cmluZyAnbmF0aXZlQ3VycmVuY3kuc3ltYm9sJy4gUmVjZWl2ZWQ6ICR7bmF0aXZlQ3VycmVuY3kuc3ltYm9sfWAsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGlja2VyID0gbmF0aXZlQ3VycmVuY3k/LnN5bWJvbCB8fCAnRVRIJztcblxuICBpZiAodHlwZW9mIHRpY2tlciAhPT0gJ3N0cmluZycgfHwgdGlja2VyLmxlbmd0aCA8IDIgfHwgdGlja2VyLmxlbmd0aCA+IDYpIHtcbiAgICByZXR1cm4gZW5kKFxuICAgICAgZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkIDItNiBjaGFyYWN0ZXIgc3RyaW5nICduYXRpdmVDdXJyZW5jeS5zeW1ib2wnLiBSZWNlaXZlZDpcXG4ke3RpY2tlcn1gLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgYWRkQ3VzdG9tUnBjKFxuICAgICAgYXdhaXQgcmVxdWVzdFVzZXJBcHByb3ZhbCh7XG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgdHlwZTogTUVTU0FHRV9UWVBFLkFERF9FVEhFUkVVTV9DSEFJTixcbiAgICAgICAgcmVxdWVzdERhdGE6IHtcbiAgICAgICAgICBjaGFpbklkOiBfY2hhaW5JZCxcbiAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsOiBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICBjaGFpbk5hbWU6IF9jaGFpbk5hbWUsXG4gICAgICAgICAgcnBjVXJsOiBmaXJzdFZhbGlkUlBDVXJsLFxuICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBzZW5kTWV0cmljcyh7XG4gICAgICBldmVudDogJ0N1c3RvbSBOZXR3b3JrIEFkZGVkJyxcbiAgICAgIGNhdGVnb3J5OiAnTmV0d29yaycsXG4gICAgICByZWZlcnJlcjoge1xuICAgICAgICB1cmw6IG9yaWdpbixcbiAgICAgIH0sXG4gICAgICBzZW5zaXRpdmVQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNoYWluX2lkOiBfY2hhaW5JZCxcbiAgICAgICAgcnBjX3VybDogZmlyc3RWYWxpZFJQQ1VybCxcbiAgICAgICAgbmV0d29ya19uYW1lOiBfY2hhaW5OYW1lLFxuICAgICAgICAvLyBJbmNsdWRpbmcgbmV0d29yayB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIC8vIHByb3BlcnR5IGluY2x1ZGVkIGluIGFsbCBldmVudHMuIEZvciBSUEMgdHlwZSBuZXR3b3Jrc1xuICAgICAgICAvLyB0aGUgTWV0YU1ldHJpY3MgY29udHJvbGxlciB1c2VzIHRoZSBycGNVcmwgZm9yIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBuZXR3b3JrOiBmaXJzdFZhbGlkUlBDVXJsLFxuICAgICAgICBzeW1ib2w6IHRpY2tlcixcbiAgICAgICAgYmxvY2tfZXhwbG9yZXJfdXJsOiBmaXJzdFZhbGlkQmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgc291cmNlOiAnZGFwcCcsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gT25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBhZGRlZCwgdGhlIHJlcXVlc3RlZCBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWxcbiAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgfVxuXG4gIC8vIEFzayB0aGUgdXNlciB0byBzd2l0Y2ggdGhlIG5ldHdvcmtcbiAgdHJ5IHtcbiAgICBhd2FpdCB1cGRhdGVScGNUYXJnZXQoXG4gICAgICBhd2FpdCByZXF1ZXN0VXNlckFwcHJvdmFsKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICB0eXBlOiBNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOLFxuICAgICAgICByZXF1ZXN0RGF0YToge1xuICAgICAgICAgIHJwY1VybDogZmlyc3RWYWxpZFJQQ1VybCxcbiAgICAgICAgICBjaGFpbklkOiBfY2hhaW5JZCxcbiAgICAgICAgICBuaWNrbmFtZTogX2NoYWluTmFtZSxcbiAgICAgICAgICB0aWNrZXIsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBtZXRob2QsIGl0IGRvZXMgbm90IG1hdHRlciBpZiB0aGUgdXNlclxuICAgIC8vIGRlY2xpbmVzIHRvIHN3aXRjaCB0aGUgc2VsZWN0ZWQgbmV0d29yay4gSG93ZXZlciwgb3RoZXIgZXJyb3JzIGluZGljYXRlXG4gICAgLy8gdGhhdCBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IGVycm9yQ29kZXMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcblxuLyoqXG4gKiBUaGlzIFJQQyBtZXRob2QgZ2V0cyBiYWNrZ3JvdW5kIHN0YXRlIHJlbGV2YW50IHRvIHRoZSBwcm92aWRlci5cbiAqIFRoZSBiYWNrZ3JvdW5kIHNlbmRzIFJQQyBub3RpZmljYXRpb25zIG9uIHN0YXRlIGNoYW5nZXMsIGJ1dCB0aGUgcHJvdmlkZXJcbiAqIGZpcnN0IHJlcXVlc3RzIHN0YXRlIG9uIGluaXRpYWxpemF0aW9uLlxuICovXG5cbmNvbnN0IGdldFByb3ZpZGVyU3RhdGUgPSB7XG4gIG1ldGhvZE5hbWVzOiBbTUVTU0FHRV9UWVBFLkdFVF9QUk9WSURFUl9TVEFURV0sXG4gIGltcGxlbWVudGF0aW9uOiBnZXRQcm92aWRlclN0YXRlSGFuZGxlcixcbiAgaG9va05hbWVzOiB7XG4gICAgZ2V0UHJvdmlkZXJTdGF0ZTogdHJ1ZSxcbiAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBnZXRQcm92aWRlclN0YXRlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3ZpZGVyU3RhdGVIYW5kbGVyUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9ja2VkIC0gV2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkIG9yIG5vdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuZXR3b3JrVmVyc2lvbiAtIFRoZSBjdXJyZW50IG5ldHdvcmsgSUQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm92aWRlclN0YXRlSGFuZGxlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gUHJvdmlkZXJTdGF0ZUhhbmRsZXJSZXN1bHR9IGdldFByb3ZpZGVyU3RhdGUgLSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGdldHMgdGhlIGN1cnJlbnQgcHJvdmlkZXIgc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1JlcXVlc3Q8W10+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPFByb3ZpZGVyU3RhdGVIYW5kbGVyUmVzdWx0Pn0gcmVzIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IF9uZXh0IC0gVGhlIGpzb24tcnBjLWVuZ2luZSAnbmV4dCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmQgLSBUaGUganNvbi1ycGMtZW5naW5lICdlbmQnIGNhbGxiYWNrLlxuICogQHBhcmFtIHtQcm92aWRlclN0YXRlSGFuZGxlck9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXJTdGF0ZUhhbmRsZXIoXG4gIHJlcSxcbiAgcmVzLFxuICBfbmV4dCxcbiAgZW5kLFxuICB7IGdldFByb3ZpZGVyU3RhdGU6IF9nZXRQcm92aWRlclN0YXRlIH0sXG4pIHtcbiAgcmVzLnJlc3VsdCA9IHtcbiAgICAuLi4oYXdhaXQgX2dldFByb3ZpZGVyU3RhdGUocmVxLm9yaWdpbikpLFxuICB9O1xuICByZXR1cm4gZW5kKCk7XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5cbi8qKlxuICogVGhpcyBpbnRlcm5hbCBtZXRob2QgaXMgdXNlZCBieSBvdXIgZXh0ZXJuYWwgcHJvdmlkZXIgdG8gc2VuZCBtZXRhZGF0YSBhYm91dFxuICogcGVybWlzc2lvbiBzdWJqZWN0cyBzbyB0aGF0IHdlIGNhbiBlLmcuIGRpc3BsYXkgYSBwcm9wZXIgbmFtZSBhbmQgaWNvbiBpblxuICogb3VyIFVJLlxuICovXG5cbmNvbnN0IHNlbmRNZXRhZGF0YSA9IHtcbiAgbWV0aG9kTmFtZXM6IFtNRVNTQUdFX1RZUEUuU0VORF9NRVRBREFUQV0sXG4gIGltcGxlbWVudGF0aW9uOiBzZW5kTWV0YWRhdGFIYW5kbGVyLFxuICBob29rTmFtZXM6IHtcbiAgICBhZGRTdWJqZWN0TWV0YWRhdGE6IHRydWUsXG4gICAgc3ViamVjdFR5cGU6IHRydWUsXG4gIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgc2VuZE1ldGFkYXRhO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbj59IFNlbmRNZXRhZGF0YU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFkZFN1YmplY3RNZXRhZGF0YSAtIEEgZnVuY3Rpb24gdGhhdCByZWNvcmRzIHN1YmplY3RcbiAqIG1ldGFkYXRhLCBib3VuZCB0byB0aGUgcmVxdWVzdGluZyBvcmlnaW4uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3ViamVjdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcmVxdWVzdGluZyBvcmlnaW4gLyBzdWJqZWN0LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2pzb24tcnBjLWVuZ2luZScpLkpzb25ScGNSZXF1ZXN0PHVua25vd24+fSByZXEgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydCgnanNvbi1ycGMtZW5naW5lJykuSnNvblJwY1Jlc3BvbnNlPHRydWU+fSByZXMgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gX25leHQgLSBUaGUganNvbi1ycGMtZW5naW5lICduZXh0JyBjYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZCAtIFRoZSBqc29uLXJwYy1lbmdpbmUgJ2VuZCcgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1NlbmRNZXRhZGF0YU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gc2VuZE1ldGFkYXRhSGFuZGxlcihcbiAgcmVxLFxuICByZXMsXG4gIF9uZXh0LFxuICBlbmQsXG4gIHsgYWRkU3ViamVjdE1ldGFkYXRhLCBzdWJqZWN0VHlwZSB9LFxuKSB7XG4gIGNvbnN0IHsgb3JpZ2luLCBwYXJhbXMgfSA9IHJlcTtcbiAgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgY29uc3QgeyBpY29uID0gbnVsbCwgbmFtZSA9IG51bGwsIC4uLnJlbWFpbmluZ1BhcmFtcyB9ID0gcGFyYW1zO1xuXG4gICAgYWRkU3ViamVjdE1ldGFkYXRhKHtcbiAgICAgIC4uLnJlbWFpbmluZ1BhcmFtcyxcbiAgICAgIGljb25Vcmw6IGljb24sXG4gICAgICBuYW1lLFxuICAgICAgc3ViamVjdFR5cGUsXG4gICAgICBvcmlnaW4sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuZChldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoeyBkYXRhOiBwYXJhbXMgfSkpO1xuICB9XG5cbiAgcmVzLnJlc3VsdCA9IHRydWU7XG4gIHJldHVybiBlbmQoKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWxlY3RIb29rcyA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWJzZXQgb2YgdGhlIHNwZWNpZmllZCBgaG9va3NgIHRoYXQgYXJlIGluY2x1ZGVkIGluIHRoZVxuICogYGhvb2tOYW1lc2Agb2JqZWN0LiBUaGlzIGlzIGEgUHJpbmNpcGxlIG9mIExlYXN0IEF1dGhvcml0eSAoUE9MQSkgbWVhc3VyZVxuICogdG8gZW5zdXJlIHRoYXQgZWFjaCBSUEMgbWV0aG9kIGltcGxlbWVudGF0aW9uIG9ubHkgaGFzIGFjY2VzcyB0byB0aGVcbiAqIEFQSSBcImhvb2tzXCIgaXQgbmVlZHMgdG8gZG8gaXRzIGpvYi5cbiAqXG4gKiBAcGFyYW0gaG9va3MgLSBUaGUgaG9va3MgdG8gc2VsZWN0IGZyb20uXG4gKiBAcGFyYW0gaG9va05hbWVzIC0gVGhlIG5hbWVzIG9mIHRoZSBob29rcyB0byBzZWxlY3QuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgaG9va3MuXG4gKiBAdGVtcGxhdGUgSG9va3MgLSBUaGUgaG9va3MgdG8gc2VsZWN0IGZyb20uXG4gKiBAdGVtcGxhdGUgSG9va05hbWUgLSBUaGUgbmFtZXMgb2YgdGhlIGhvb2tzIHRvIHNlbGVjdC5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0SG9va3MoaG9va3MsIGhvb2tOYW1lcykge1xuICAgIGlmIChob29rTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGhvb2tOYW1lcykucmVkdWNlKChob29rU3Vic2V0LCBfaG9va05hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhvb2tOYW1lID0gX2hvb2tOYW1lO1xuICAgICAgICAgICAgaG9va1N1YnNldFtob29rTmFtZV0gPSBob29rc1tob29rTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gaG9va1N1YnNldDtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5zZWxlY3RIb29rcyA9IHNlbGVjdEhvb2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhbmRsZXJzID0gdm9pZCAwO1xuY29uc3QgZW5hYmxlXzEgPSByZXF1aXJlKFwiLi9lbmFibGVcIik7XG5jb25zdCBnZXRBcHBLZXlfMSA9IHJlcXVpcmUoXCIuL2dldEFwcEtleVwiKTtcbmNvbnN0IGdldFNuYXBzXzEgPSByZXF1aXJlKFwiLi9nZXRTbmFwc1wiKTtcbmNvbnN0IGluc3RhbGxTbmFwc18xID0gcmVxdWlyZShcIi4vaW5zdGFsbFNuYXBzXCIpO1xuY29uc3QgaW52b2tlU25hcFN1Z2FyXzEgPSByZXF1aXJlKFwiLi9pbnZva2VTbmFwU3VnYXJcIik7XG5leHBvcnRzLmhhbmRsZXJzID0gW1xuICAgIGVuYWJsZV8xLmVuYWJsZVdhbGxldEhhbmRsZXIsXG4gICAgZ2V0QXBwS2V5XzEuZ2V0QXBwS2V5SGFuZGxlcixcbiAgICBnZXRTbmFwc18xLmdldFNuYXBzSGFuZGxlcixcbiAgICBpbnN0YWxsU25hcHNfMS5pbnN0YWxsU25hcHNIYW5kbGVyLFxuICAgIGludm9rZVNuYXBTdWdhcl8xLmludm9rZVNuYXBTdWdhckhhbmRsZXIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkZXJzID0gZXhwb3J0cy5NYW5hZ2VTdGF0ZU9wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbmZpcm1fMSA9IHJlcXVpcmUoXCIuL2NvbmZpcm1cIik7XG5jb25zdCBnZXRCaXA0NEVudHJvcHlfMSA9IHJlcXVpcmUoXCIuL2dldEJpcDQ0RW50cm9weVwiKTtcbmNvbnN0IGludm9rZVNuYXBfMSA9IHJlcXVpcmUoXCIuL2ludm9rZVNuYXBcIik7XG5jb25zdCBtYW5hZ2VTdGF0ZV8xID0gcmVxdWlyZShcIi4vbWFuYWdlU3RhdGVcIik7XG52YXIgbWFuYWdlU3RhdGVfMiA9IHJlcXVpcmUoXCIuL21hbmFnZVN0YXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFuYWdlU3RhdGVPcGVyYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hbmFnZVN0YXRlXzIuTWFuYWdlU3RhdGVPcGVyYXRpb247IH0gfSk7XG5leHBvcnRzLmJ1aWxkZXJzID0ge1xuICAgIFtjb25maXJtXzEuY29uZmlybUJ1aWxkZXIudGFyZ2V0S2V5XTogY29uZmlybV8xLmNvbmZpcm1CdWlsZGVyLFxuICAgIFtnZXRCaXA0NEVudHJvcHlfMS5nZXRCaXA0NEVudHJvcHlCdWlsZGVyLnRhcmdldEtleV06IGdldEJpcDQ0RW50cm9weV8xLmdldEJpcDQ0RW50cm9weUJ1aWxkZXIsXG4gICAgW2ludm9rZVNuYXBfMS5pbnZva2VTbmFwQnVpbGRlci50YXJnZXRLZXldOiBpbnZva2VTbmFwXzEuaW52b2tlU25hcEJ1aWxkZXIsXG4gICAgW21hbmFnZVN0YXRlXzEubWFuYWdlU3RhdGVCdWlsZGVyLnRhcmdldEtleV06IG1hbmFnZVN0YXRlXzEubWFuYWdlU3RhdGVCdWlsZGVyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW4gfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKS5mb3JFYWNoKChjaGlsZEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltjaGlsZEtleV07XG4gICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVGcm9tQ2hpbGQgPSAoY2hpbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdGF0ZVtjaGlsZEtleV0gPSBjaGlsZFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSh1cGRhdGVGcm9tQ2hpbGQpO1xuICAgICAgICB1cGRhdGVGcm9tQ2hpbGQoY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gQ29tcG9zZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBNZXJnZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaW5pdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0L2RlZmF1bHQgc3RhdGU6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBwdXRTdGF0ZVxuICAgIHB1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgcGFydGlhbFN0YXRlKSk7XG4gICAgICAgICAgICAvLyBpZiBub3Qgb2JqZWN0LCB1c2UgbmV3IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gcHJpdmF0ZVxuICAgIC8vXG4gICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gICAgX3B1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSBPYnNlcnZhYmxlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgdGhyb3VnaDJfMSA9IHJlcXVpcmUoXCJ0aHJvdWdoMlwiKTtcbmZ1bmN0aW9uIHN0b3JlVHJhbnNmb3JtU3RyZWFtKHN5bmNUcmFuc2Zvcm1Gbikge1xuICAgIHJldHVybiB0aHJvdWdoMl8xLm9iaigoc3RhdGUsIF9lbmNvZGluZywgY2IpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3luY1RyYW5zZm9ybUZuKHN0YXRlKTtcbiAgICAgICAgICAgIGNiKG51bGwsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSBzdG9yZVRyYW5zZm9ybVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmNVclJlZ2lzdHJ5ID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnknKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG5cbmNvbnN0IHtcbiAgUmVnaXN0cnlUeXBlXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbmNvbnN0IEV4dGVuZGVkUmVnaXN0cnlUeXBlcyA9IHtcbiAgRVRIX1NJR05fUkVRVUVTVDogLyojX19QVVJFX18qL25ldyBSZWdpc3RyeVR5cGUoJ2V0aC1zaWduLXJlcXVlc3QnLCA0MDEpLFxuICBFVEhfU0lHTkFUQVVSRTogLyojX19QVVJFX18qL25ldyBSZWdpc3RyeVR5cGUoJ2V0aC1zaWduYXR1cmUnLCA0MDIpXG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW0sXG4gIFJlZ2lzdHJ5VHlwZXNcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXM7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJyZXF1ZXN0SWRcIl0gPSAxXSA9IFwicmVxdWVzdElkXCI7XG4gIEtleXNbS2V5c1tcInNpZ25EYXRhXCJdID0gMl0gPSBcInNpZ25EYXRhXCI7XG4gIEtleXNbS2V5c1tcImRhdGFUeXBlXCJdID0gM10gPSBcImRhdGFUeXBlXCI7XG4gIEtleXNbS2V5c1tcImNoYWluSWRcIl0gPSA0XSA9IFwiY2hhaW5JZFwiO1xuICBLZXlzW0tleXNbXCJkZXJpdmF0aW9uUGF0aFwiXSA9IDVdID0gXCJkZXJpdmF0aW9uUGF0aFwiO1xuICBLZXlzW0tleXNbXCJhZGRyZXNzXCJdID0gNl0gPSBcImFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gN10gPSBcIm9yaWdpblwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0cmFuc2FjdGlvblwiXSA9IDFdID0gXCJ0cmFuc2FjdGlvblwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInR5cGVkRGF0YVwiXSA9IDJdID0gXCJ0eXBlZERhdGFcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJwZXJzb25hbE1lc3NhZ2VcIl0gPSAzXSA9IFwicGVyc29uYWxNZXNzYWdlXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWRUcmFuc2FjdGlvblwiXSA9IDRdID0gXCJ0eXBlZFRyYW5zYWN0aW9uXCI7XG59KShleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcblxuY2xhc3MgRXRoU2lnblJlcXVlc3QgZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTl9SRVFVRVNUO1xuXG4gICAgdGhpcy5zZXR1cERhdGEgPSBhcmdzID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdElkID0gYXJncy5yZXF1ZXN0SWQ7XG4gICAgICB0aGlzLnNpZ25EYXRhID0gYXJncy5zaWduRGF0YTtcbiAgICAgIHRoaXMuZGF0YVR5cGUgPSBhcmdzLmRhdGFUeXBlO1xuICAgICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgICAgdGhpcy5kZXJpdmF0aW9uUGF0aCA9IGFyZ3MuZGVyaXZhdGlvblBhdGg7XG4gICAgICB0aGlzLmFkZHJlc3MgPSBhcmdzLmFkZHJlc3M7XG4gICAgICB0aGlzLm9yaWdpbiA9IGFyZ3Mub3JpZ2luO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduRGF0YSA9ICgpID0+IHRoaXMuc2lnbkRhdGE7XG5cbiAgICB0aGlzLmdldERhdGFUeXBlID0gKCkgPT4gdGhpcy5kYXRhVHlwZTtcblxuICAgIHRoaXMuZ2V0Q2hhaW5JZCA9ICgpID0+IHRoaXMuY2hhaW5JZDtcblxuICAgIHRoaXMuZ2V0RGVyaXZhdGlvblBhdGggPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKTtcblxuICAgIHRoaXMuZ2V0U2lnblJlcXVlc3RBZGRyZXNzID0gKCkgPT4gdGhpcy5hZGRyZXNzO1xuXG4gICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcblxuICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgbWFwW0tleXMucmVxdWVzdElkXSA9IG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsIFJlZ2lzdHJ5VHlwZXMuVVVJRC5nZXRUYWcoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFkZHJlc3MpIHtcbiAgICAgICAgbWFwW0tleXMuYWRkcmVzc10gPSB0aGlzLmFkZHJlc3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYWluSWQpIHtcbiAgICAgICAgbWFwW0tleXMuY2hhaW5JZF0gPSB0aGlzLmNoYWluSWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICBtYXBbS2V5cy5vcmlnaW5dID0gdGhpcy5vcmlnaW47XG4gICAgICB9XG5cbiAgICAgIG1hcFtLZXlzLnNpZ25EYXRhXSA9IHRoaXMuc2lnbkRhdGE7XG4gICAgICBtYXBbS2V5cy5kYXRhVHlwZV0gPSB0aGlzLmRhdGFUeXBlO1xuICAgICAgY29uc3Qga2V5UGF0aCA9IHRoaXMuZGVyaXZhdGlvblBhdGgudG9EYXRhSXRlbSgpO1xuICAgICAga2V5UGF0aC5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICBtYXBbS2V5cy5kZXJpdmF0aW9uUGF0aF0gPSBrZXlQYXRoO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXR1cERhdGEoYXJncyk7XG4gIH1cblxuICBzdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdChzaWduRGF0YSwgc2lnbkRhdGFUeXBlLCBoZFBhdGgsIHhmcCwgdXVpZFN0cmluZywgY2hhaW5JZCwgYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgY29uc3QgcGF0aHMgPSBoZFBhdGgucmVwbGFjZSgvW218TV1cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBoZHBhdGhPYmplY3QgPSBuZXcgYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGgocGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChwYXRoLnJlcGxhY2UoXCInXCIsICcnKSk7XG4gICAgICBsZXQgaXNIYXJkZW5lZCA9IGZhbHNlO1xuXG4gICAgICBpZiAocGF0aC5lbmRzV2l0aChcIidcIikpIHtcbiAgICAgICAgaXNIYXJkZW5lZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LlBhdGhDb21wb25lbnQoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgaGFyZGVuZWQ6IGlzSGFyZGVuZWRcbiAgICAgIH0pO1xuICAgIH0pLCBCdWZmZXIuZnJvbSh4ZnAsICdoZXgnKSk7XG4gICAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgICByZXF1ZXN0SWQ6IHV1aWRTdHJpbmcgPyBCdWZmZXIuZnJvbSh1dWlkLnBhcnNlKHV1aWRTdHJpbmcpKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25EYXRhLFxuICAgICAgZGF0YVR5cGU6IHNpZ25EYXRhVHlwZSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBoZHBhdGhPYmplY3QsXG4gICAgICBjaGFpbklkLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyA/IEJ1ZmZlci5mcm9tKGFkZHJlc3MucmVwbGFjZSgnMHgnLCAnJyksICdoZXgnKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9yaWdpbjogb3JpZ2luIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbn1cblxuRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25EYXRhID0gbWFwW0tleXMuc2lnbkRhdGFdO1xuICBjb25zdCBkYXRhVHlwZSA9IG1hcFtLZXlzLmRhdGFUeXBlXTtcbiAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0obWFwW0tleXMuZGVyaXZhdGlvblBhdGhdKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzLmNoYWluSWRdID8gbWFwW0tleXMuY2hhaW5JZF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGFkZHJlc3MgPSBtYXBbS2V5cy5hZGRyZXNzXSA/IG1hcFtLZXlzLmFkZHJlc3NdIDogdW5kZWZpbmVkO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cy5yZXF1ZXN0SWRdID8gbWFwW0tleXMucmVxdWVzdElkXS5nZXREYXRhKCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWdpbiA9IG1hcFtLZXlzLm9yaWdpbl0gPyBtYXBbS2V5cy5vcmlnaW5dIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEV0aFNpZ25SZXF1ZXN0KHtcbiAgICByZXF1ZXN0SWQsXG4gICAgc2lnbkRhdGEsXG4gICAgZGF0YVR5cGUsXG4gICAgY2hhaW5JZCxcbiAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICBhZGRyZXNzLFxuICAgIG9yaWdpblxuICB9KTtcbn07XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFdGhTaWduUmVxdWVzdC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuY29uc3Qge1xuICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVzJDEsXG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMVxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQxO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wicmVxdWVzdElkXCJdID0gMV0gPSBcInJlcXVlc3RJZFwiO1xuICBLZXlzW0tleXNbXCJzaWduYXR1cmVcIl0gPSAyXSA9IFwic2lnbmF0dXJlXCI7XG59KShLZXlzJDEgfHwgKEtleXMkMSA9IHt9KSk7XG5cbmNsYXNzIEVUSFNpZ25hdHVyZSBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHJlcXVlc3RJZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTkFUQVVSRTtcblxuICAgIHRoaXMuZ2V0UmVxdWVzdElkID0gKCkgPT4gdGhpcy5yZXF1ZXN0SWQ7XG5cbiAgICB0aGlzLmdldFNpZ25hdHVyZSA9ICgpID0+IHRoaXMuc2lnbmF0dXJlO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG5cbiAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICBtYXBbS2V5cyQxLnJlcXVlc3RJZF0gPSBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLCBSZWdpc3RyeVR5cGVzJDEuVVVJRC5nZXRUYWcoKSk7XG4gICAgICB9XG5cbiAgICAgIG1hcFtLZXlzJDEuc2lnbmF0dXJlXSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gIH1cblxufVxuXG5FVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IG1hcFtLZXlzJDEuc2lnbmF0dXJlXTtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMkMS5yZXF1ZXN0SWRdID8gbWFwW0tleXMkMS5yZXF1ZXN0SWRdLmdldERhdGEoKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFVEhTaWduYXR1cmUoc2lnbmF0dXJlLCByZXF1ZXN0SWQpO1xufTtcblxuRVRIU2lnbmF0dXJlLmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtJDEoX2Nib3JQYXlsb2FkKTtcbiAgcmV0dXJuIEVUSFNpZ25hdHVyZS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZ2VuZXJhdGVBZGRyZXNzZnJvbVhwdWIgPSAoeHB1YiwgZGVyaXZlUGF0aCkgPT4ge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG5vZGUgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkoeHB1Yik7XG4gIGNvbnN0IHB1YmxpY0tleSA9IG5vZGUuZGVyaXZlKGRlcml2ZVBhdGgpO1xuICBjb25zdCBhZGRyZXNzID0gJzB4JyArIGV0aGVyZXVtanNVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkucHVibGljS2V5LCB0cnVlKS50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbn07XG5jb25zdCBmaW5kSERwYXRmcm9tQWRkcmVzcyA9IChhZGRyZXNzLCB4cHViLCBudW1iZXJMaW1pdCwgcm9vdFBhdGgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJMaW1pdDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IGBNLzAvJHtpfWA7XG4gICAgY29uc3QgY2FjdWxhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzZnJvbVhwdWIoeHB1YiwgcGF0aCk7XG5cbiAgICBpZiAoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09IGNhY3VsYXRlQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gYCR7cm9vdFBhdGh9LzAvJHtpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCB7XG4gIGNib3Jcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xuY2Jvci5wYXRjaFRhZ3MoT2JqZWN0LnZhbHVlcyhFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMpLmZpbHRlcihydCA9PiAhIXJ0LmdldFRhZygpKS5tYXAocnQgPT4gcnQuZ2V0VGFnKCkpKTtcblxuT2JqZWN0LmtleXMoYmNVclJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmNVclJlZ2lzdHJ5W2tdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmV4cG9ydHMuRVRIU2lnbmF0dXJlID0gRVRIU2lnbmF0dXJlO1xuZXhwb3J0cy5FdGhTaWduUmVxdWVzdCA9IEV0aFNpZ25SZXF1ZXN0O1xuZXhwb3J0cy5maW5kSERwYXRmcm9tQWRkcmVzcyA9IGZpbmRIRHBhdGZyb21BZGRyZXNzO1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3Nmcm9tWHB1YiA9IGdlbmVyYXRlQWRkcmVzc2Zyb21YcHViO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LGU9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5XCIpLHM9cmVxdWlyZShcInV1aWRcIiksYT0odD1yZXF1aXJlKFwiaGRrZXlcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJkZWZhdWx0XCJpbiB0P3QuZGVmYXVsdDp0LGk9cmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtjb25zdHtSZWdpc3RyeVR5cGU6cn09ZS5leHRlbmQsbj17RVRIX1NJR05fUkVRVUVTVDpuZXcgcihcImV0aC1zaWduLXJlcXVlc3RcIiw0MDEpLEVUSF9TSUdOQVRBVVJFOm5ldyByKFwiZXRoLXNpZ25hdHVyZVwiLDQwMil9LHtkZWNvZGVUb0RhdGFJdGVtOmQsUmVnaXN0cnlUeXBlczpvfT1lLmV4dGVuZDt2YXIgaCx1OyFmdW5jdGlvbih0KXt0W3QucmVxdWVzdElkPTFdPVwicmVxdWVzdElkXCIsdFt0LnNpZ25EYXRhPTJdPVwic2lnbkRhdGFcIix0W3QuZGF0YVR5cGU9M109XCJkYXRhVHlwZVwiLHRbdC5jaGFpbklkPTRdPVwiY2hhaW5JZFwiLHRbdC5kZXJpdmF0aW9uUGF0aD01XT1cImRlcml2YXRpb25QYXRoXCIsdFt0LmFkZHJlc3M9Nl09XCJhZGRyZXNzXCIsdFt0Lm9yaWdpbj03XT1cIm9yaWdpblwifShofHwoaD17fSkpLCh1PWV4cG9ydHMuRGF0YVR5cGV8fChleHBvcnRzLkRhdGFUeXBlPXt9KSlbdS50cmFuc2FjdGlvbj0xXT1cInRyYW5zYWN0aW9uXCIsdVt1LnR5cGVkRGF0YT0yXT1cInR5cGVkRGF0YVwiLHVbdS5wZXJzb25hbE1lc3NhZ2U9M109XCJwZXJzb25hbE1lc3NhZ2VcIix1W3UudHlwZWRUcmFuc2FjdGlvbj00XT1cInR5cGVkVHJhbnNhY3Rpb25cIjtjbGFzcyBnIGV4dGVuZHMgZS5SZWdpc3RyeUl0ZW17Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTl9SRVFVRVNULHRoaXMuc2V0dXBEYXRhPXQ9Pnt0aGlzLnJlcXVlc3RJZD10LnJlcXVlc3RJZCx0aGlzLnNpZ25EYXRhPXQuc2lnbkRhdGEsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5kZXJpdmF0aW9uUGF0aD10LmRlcml2YXRpb25QYXRoLHRoaXMuYWRkcmVzcz10LmFkZHJlc3MsdGhpcy5vcmlnaW49dC5vcmlnaW59LHRoaXMuZ2V0UmVxdWVzdElkPSgpPT50aGlzLnJlcXVlc3RJZCx0aGlzLmdldFNpZ25EYXRhPSgpPT50aGlzLnNpZ25EYXRhLHRoaXMuZ2V0RGF0YVR5cGU9KCk9PnRoaXMuZGF0YVR5cGUsdGhpcy5nZXRDaGFpbklkPSgpPT50aGlzLmNoYWluSWQsdGhpcy5nZXREZXJpdmF0aW9uUGF0aD0oKT0+dGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCksdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3M9KCk9PnRoaXMuYWRkcmVzcyx0aGlzLmdldE9yaWdpbj0oKT0+dGhpcy5vcmlnaW4sdGhpcy50b0RhdGFJdGVtPSgpPT57Y29uc3QgdD17fTt0aGlzLnJlcXVlc3RJZCYmKHRbaC5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLG8uVVVJRC5nZXRUYWcoKSkpLHRoaXMuYWRkcmVzcyYmKHRbaC5hZGRyZXNzXT10aGlzLmFkZHJlc3MpLHRoaXMuY2hhaW5JZCYmKHRbaC5jaGFpbklkXT10aGlzLmNoYWluSWQpLHRoaXMub3JpZ2luJiYodFtoLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbaC5zaWduRGF0YV09dGhpcy5zaWduRGF0YSx0W2guZGF0YVR5cGVdPXRoaXMuZGF0YVR5cGU7Y29uc3Qgcz10aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtyZXR1cm4gcy5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSksdFtoLmRlcml2YXRpb25QYXRoXT1zLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnNldHVwRGF0YSh0KX1zdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdCh0LGEsaSxyLG4sZCxvLGgpe2NvbnN0IHU9aS5yZXBsYWNlKC9bbXxNXVxcLy8sXCJcIikuc3BsaXQoXCIvXCIpLGM9bmV3IGUuQ3J5cHRvS2V5cGF0aCh1Lm1hcCh0PT57Y29uc3Qgcz1wYXJzZUludCh0LnJlcGxhY2UoXCInXCIsXCJcIikpO2xldCBhPSExO3JldHVybiB0LmVuZHNXaXRoKFwiJ1wiKSYmKGE9ITApLG5ldyBlLlBhdGhDb21wb25lbnQoe2luZGV4OnMsaGFyZGVuZWQ6YX0pfSksQnVmZmVyLmZyb20ocixcImhleFwiKSk7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6bj9CdWZmZXIuZnJvbShzLnBhcnNlKG4pKTp2b2lkIDAsc2lnbkRhdGE6dCxkYXRhVHlwZTphLGRlcml2YXRpb25QYXRoOmMsY2hhaW5JZDpkLGFkZHJlc3M6bz9CdWZmZXIuZnJvbShvLnJlcGxhY2UoXCIweFwiLFwiXCIpLFwiaGV4XCIpOnZvaWQgMCxvcmlnaW46aHx8dm9pZCAwfSl9fWcuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBzPXQuZ2V0RGF0YSgpLGE9c1toLnNpZ25EYXRhXSxpPXNbaC5kYXRhVHlwZV0scj1lLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKHNbaC5kZXJpdmF0aW9uUGF0aF0pLG49c1toLmNoYWluSWRdP3NbaC5jaGFpbklkXTp2b2lkIDAsZD1zW2guYWRkcmVzc10/c1toLmFkZHJlc3NdOnZvaWQgMCxvPXNbaC5yZXF1ZXN0SWRdP3NbaC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6byxzaWduRGF0YTphLGRhdGFUeXBlOmksY2hhaW5JZDpuLGRlcml2YXRpb25QYXRoOnIsYWRkcmVzczpkLG9yaWdpbjpzW2gub3JpZ2luXT9zW2gub3JpZ2luXTp2b2lkIDB9KX0sZy5mcm9tQ0JPUj10PT57Y29uc3QgZT1kKHQpO3JldHVybiBnLmZyb21EYXRhSXRlbShlKX07Y29uc3R7UmVnaXN0cnlUeXBlczpjLGRlY29kZVRvRGF0YUl0ZW06SX09ZS5leHRlbmQ7dmFyIHA7IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbmF0dXJlPTJdPVwic2lnbmF0dXJlXCJ9KHB8fChwPXt9KSk7Y2xhc3MgeSBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQscyl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTkFUQVVSRSx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduYXR1cmU9KCk9PnRoaXMuc2lnbmF0dXJlLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRoaXMucmVxdWVzdElkJiYodFtwLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsYy5VVUlELmdldFRhZygpKSksdFtwLnNpZ25hdHVyZV09dGhpcy5zaWduYXR1cmUsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuc2lnbmF0dXJlPXQsdGhpcy5yZXF1ZXN0SWQ9c319eS5mcm9tRGF0YUl0ZW09dD0+e2NvbnN0IGU9dC5nZXREYXRhKCkscz1lW3Auc2lnbmF0dXJlXSxhPWVbcC5yZXF1ZXN0SWRdP2VbcC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyB5KHMsYSl9LHkuZnJvbUNCT1I9dD0+e2NvbnN0IGU9SSh0KTtyZXR1cm4geS5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0IFQ9KHQsZSk9Pntjb25zdCBzPWEuZnJvbUV4dGVuZGVkS2V5KHQpLmRlcml2ZShlKSxyPVwiMHhcIitpLnB1YmxpY1RvQWRkcmVzcyhzLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIGkudG9DaGVja3N1bUFkZHJlc3Mocil9LHtjYm9yOkR9PWUuZXh0ZW5kO0QucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMobikuZmlsdGVyKHQ9PiEhdC5nZXRUYWcoKSkubWFwKHQ9PnQuZ2V0VGFnKCkpKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSl9KSksZXhwb3J0cy5FVEhTaWduYXR1cmU9eSxleHBvcnRzLkV0aFNpZ25SZXF1ZXN0PWcsZXhwb3J0cy5maW5kSERwYXRmcm9tQWRkcmVzcz0odCxlLHMsYSk9Pntmb3IobGV0IGk9MDtpPHM7aSsrKXtjb25zdCBzPVQoZSxcIk0vMC9cIitpKTtpZih0LnRvTG93ZXJDYXNlKCk9PXMudG9Mb3dlckNhc2UoKSlyZXR1cm5gJHthfS8wLyR7aX1gfXJldHVybiBudWxsfSxleHBvcnRzLmdlbmVyYXRlQWRkcmVzc2Zyb21YcHViPVQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgdHggPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xudmFyIGJjVXJSZWdpc3RyeUV0aCA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aCcpO1xudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG5cbmNvbnN0IGtleXJpbmdUeXBlID0gJ1FSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2UnO1xuY29uc3QgcGF0aEJhc2UgPSAnbSc7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DSElMRFJFTl9QQVRIID0gJzAvKic7XG52YXIgS0VZUklOR19NT0RFO1xuXG4oZnVuY3Rpb24gKEtFWVJJTkdfTU9ERSkge1xuICBLRVlSSU5HX01PREVbXCJoZFwiXSA9IFwiaGRcIjtcbiAgS0VZUklOR19NT0RFW1wicHVia2V5XCJdID0gXCJwdWJrZXlcIjtcbn0pKEtFWVJJTkdfTU9ERSB8fCAoS0VZUklOR19NT0RFID0ge30pKTtcblxudmFyIEtFWVJJTkdfQUNDT1VOVDtcblxuKGZ1bmN0aW9uIChLRVlSSU5HX0FDQ09VTlQpIHtcbiAgS0VZUklOR19BQ0NPVU5UW1wic3RhbmRhcmRcIl0gPSBcImFjY291bnQuc3RhbmRhcmRcIjtcbiAgS0VZUklOR19BQ0NPVU5UW1wibGVkZ2VyX2xpdmVcIl0gPSBcImFjY291bnQubGVkZ2VyX2xpdmVcIjtcbiAgS0VZUklOR19BQ0NPVU5UW1wibGVkZ2VyX2xlZ2FjeVwiXSA9IFwiYWNjb3VudC5sZWRnZXJfbGVnYWN5XCI7XG59KShLRVlSSU5HX0FDQ09VTlQgfHwgKEtFWVJJTkdfQUNDT1VOVCA9IHt9KSk7XG5cbmNsYXNzIEJhc2VLZXlyaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuXG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbiA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuJyk7XG4gICAgfTtcblxuICAgIHRoaXMudHlwZSA9IGtleXJpbmdUeXBlO1xuXG4gICAgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlID0gYXN5bmMgKF9yZXF1ZXN0SWQsIHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUoc2lnblJlcXVlc3QsIHJlcXVlc3RUaXRsZSwgcmVxdWVzdERlc2NyaXB0aW9uKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZEJ1ZmZlciA9IGV0aFNpZ25hdHVyZS5nZXRSZXF1ZXN0SWQoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFNpZ25hdHVyZS5nZXRTaWduYXR1cmUoKTtcblxuICAgICAgaWYgKHJlcXVlc3RJZEJ1ZmZlcikge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnN0cmluZ2lmeShyZXF1ZXN0SWRCdWZmZXIpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0SWQgIT09IF9yZXF1ZXN0SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiByZWFkIHNpZ25hdHVyZSBlcnJvcjogbWlzbWF0Y2hlZCByZXF1ZXN0SWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUuc2xpY2UoNjQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9IREtleSA9IGNyeXB0b0hES2V5ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvSERLZXkkZ2V0T3JpZ2ksIF9jcnlwdG9IREtleSRnZXRDaGlsZDtcblxuICAgICAgY29uc3QgaGRQYXRoID0gYG0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvSERLZXkkZ2V0T3JpZ2kgPSBjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldE9yaWdpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9ICgoX2NyeXB0b0hES2V5JGdldENoaWxkID0gY3J5cHRvSERLZXkuZ2V0Q2hpbGRyZW4oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9IREtleSRnZXRDaGlsZC5nZXRQYXRoKCkpIHx8IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICAgIGNvbnN0IG5hbWUgPSBjcnlwdG9IREtleS5nZXROYW1lKCk7XG5cbiAgICAgIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZCkge1xuICAgICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgICAgfSBlbHNlIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGVnYWN5KSB7XG4gICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xlZ2FjeTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF4ZnApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhwdWIgPSBjcnlwdG9IREtleS5nZXRCaXAzMktleSgpO1xuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLnhwdWIgPSB4cHViO1xuICAgICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IGNoaWxkcmVuUGF0aDtcblxuICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSAnJykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50ID0gY3J5cHRvQWNjb3VudCA9PiB7XG4gICAgICB2YXIgX2NyeXB0b0FjY291bnQkZ2V0TWFzLCBfY3J5cHRvQWNjb3VudCRnZXRPdXQ7XG5cbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvQWNjb3VudCRnZXRNYXMgPSBjcnlwdG9BY2NvdW50LmdldE1hc3RlckZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRNYXMudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICBpZiAoIXhmcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnhmcCA9IHhmcDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBjcnlwdG9BY2NvdW50LmdldE91dHB1dERlc2NyaXB0b3JzKCk7XG5cbiAgICAgIGlmICghb3V0cHV0cyB8fCBvdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBubyBjcnlwdG8gb3V0cHV0IGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRzLmxlbmd0aCAlIDUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93Jyk7XG4gICAgICB9XG5cbiAgICAgIChfY3J5cHRvQWNjb3VudCRnZXRPdXQgPSBjcnlwdG9BY2NvdW50LmdldE91dHB1dERlc2NyaXB0b3JzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRPdXQuZm9yRWFjaChvZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3J5cHRvSERLZXkgPSBvZC5nZXRIREtleSgpO1xuXG4gICAgICAgICAgaWYgKGNyeXB0b0hES2V5KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG9IREtleS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBgTS8ke2NyeXB0b0hES2V5LmdldE9yaWdpbigpLmdldFBhdGgoKX1gO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICcweCcgKyBldGhlcmV1bWpzVXRpbC5wdWJsaWNUb0FkZHJlc3Moa2V5LCB0cnVlKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBjcnlwdG9IREtleS5nZXROYW1lKCk7XG5cbiAgICAgICAgICAgIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9saXZlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXRoc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9OyAvLyBwcml2YXRlIF9fcmVhZExlZGdlckxpdmVBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIC8vICAgICBpZiAocmVzdWx0LmdldFJlZ2lzdHJ5VHlwZSgpID09PSBleHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVCkge1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQgYXMgQ3J5cHRvQWNjb3VudCk7XG4gICAgLy8gICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX25ld19hY2NvdW50YCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQudW5leHBlY3RlZF91cnR5cGVgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG5cblxuICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0Tm9ybWFsUGFnZSA9IGluY3JlbWVudCA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuXG4gICAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcbiAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoYWNjb3VudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX2dldExlZGdlckxpdmVQYWdlID0gaW5jcmVtZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdGhpcy5wYWdlICsgaW5jcmVtZW50O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKG5leHRQYWdlIC0gMSkgKiB0aGlzLnBlclBhZ2U7XG4gICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgcmVzb2x2ZShhY2NvdW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleCA9IGFzeW5jIChwYiwgaSkgPT4ge1xuICAgICAgaWYgKHRoaXMua2V5cmluZ01vZGUgPT09IEtFWVJJTkdfTU9ERS5oZCkge1xuICAgICAgICB0aGlzLmNoZWNrS2V5cmluZygpO1xuXG4gICAgICAgIGlmICghdGhpcy5oZGspIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5oZGsgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkodGhpcy54cHViKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoJyonLCBTdHJpbmcoaSkpLnJlcGxhY2VBbGwoJyonLCAnMCcpO1xuICAgICAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BifS8ke2NoaWxkcmVuUGF0aH1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9ICcweCcgKyBldGhlcmV1bWpzVXRpbC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGV0aGVyZXVtanNVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModGhpcy5wYXRocylbaV07XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvL2NvbW1vbiBwcm9wc1xuXG5cbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5hbWUgPSAnUVIgSGFyZHdhcmUnO1xuICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUuaGQ7XG4gICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZDtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7IC8vaGQgcHJvcHM7XG5cbiAgICB0aGlzLnhmcCA9ICcnO1xuICAgIHRoaXMueHB1YiA9ICcnO1xuICAgIHRoaXMuaGRQYXRoID0gJyc7XG4gICAgdGhpcy5jaGlsZHJlblBhdGggPSBERUZBVUxUX0NISUxEUkVOX1BBVEg7XG4gICAgdGhpcy5pbmRleGVzID0ge307IC8vcHVia2V5IHByb3BzO1xuXG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIHRoaXMuZGVzZXJpYWxpemUob3B0cyk7XG4gIH0gLy9pbml0aWFsIHJlYWRcblxuXG4gIGFzeW5jIHJlYWRLZXlyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQoKTtcblxuICAgIGlmIChyZXN1bHQuZ2V0UmVnaXN0cnlUeXBlKCkgPT09IGJjVXJSZWdpc3RyeUV0aC5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkpIHtcbiAgICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUuaGQ7XG5cbiAgICAgIHRoaXMuX19yZWFkQ3J5cHRvSERLZXkocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlyaW5nTW9kZSA9IEtFWVJJTkdfTU9ERS5wdWJrZXk7XG5cbiAgICAgIHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrS2V5cmluZygpIHtcbiAgICBpZiAoIXRoaXMueGZwIHx8ICF0aGlzLnhwdWIgfHwgIXRoaXMuaGRQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9rZXlyaW5nOiBrZXlyaW5nIG5vdCBmdWxmaWxsZWQsIHBsZWFzZSBjYWxsIGZ1bmN0aW9uIGByZWFkS2V5cmluZ2AgZmlyc3RseScpO1xuICAgIH1cbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC8vY29tbW9uXG4gICAgICBpbml0aWFsaXplZDogdGhpcy5pbml0aWFsaXplZCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgY3VycmVudEFjY291bnQ6IHRoaXMuY3VycmVudEFjY291bnQsXG4gICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICBwZXJQYWdlOiB0aGlzLnBlclBhZ2UsXG4gICAgICBrZXlyaW5nQWNjb3VudDogdGhpcy5rZXlyaW5nQWNjb3VudCxcbiAgICAgIGtleXJpbmdNb2RlOiB0aGlzLmtleXJpbmdNb2RlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgeGZwOiB0aGlzLnhmcCxcbiAgICAgIC8vaGRcbiAgICAgIHhwdWI6IHRoaXMueHB1YixcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgICBjaGlsZHJlblBhdGg6IHRoaXMuY2hpbGRyZW5QYXRoLFxuICAgICAgaW5kZXhlczogdGhpcy5pbmRleGVzLFxuICAgICAgLy9wdWJrZXlcbiAgICAgIHBhdGhzOiB0aGlzLnBhdGhzXG4gICAgfSk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIC8vY29tbW9uIHByb3BzO1xuICAgICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHM7XG4gICAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gb3B0cy5jdXJyZW50QWNjb3VudDtcbiAgICAgIHRoaXMucGFnZSA9IG9wdHMucGFnZTtcbiAgICAgIHRoaXMucGVyUGFnZSA9IG9wdHMucGVyUGFnZTtcbiAgICAgIHRoaXMubmFtZSA9IG9wdHMubmFtZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRzLmluaXRpYWxpemVkO1xuICAgICAgdGhpcy5rZXlyaW5nTW9kZSA9IG9wdHMua2V5cmluZ01vZGUgfHwgS0VZUklOR19NT0RFLmhkO1xuICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IG9wdHMua2V5cmluZ0FjY291bnQgfHwgS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgICAgdGhpcy54ZnAgPSBvcHRzLnhmcDsgLy9oZCBwcm9wcztcblxuICAgICAgdGhpcy54cHViID0gb3B0cy54cHViO1xuICAgICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aDtcbiAgICAgIHRoaXMuaW5kZXhlcyA9IG9wdHMuaW5kZXhlcztcbiAgICAgIHRoaXMucGF0aHMgPSBvcHRzLnBhdGhzO1xuICAgICAgdGhpcy5jaGlsZHJlblBhdGggPSBvcHRzLmNoaWxkcmVuUGF0aCB8fCBERUZBVUxUX0NISUxEUkVOX1BBVEg7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudEFjY291bnQoaW5kZXgpIHtcbiAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gaW5kZXg7XG4gIH1cblxuICBnZXRDdXJyZW50QWNjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QWNjb3VudDtcbiAgfVxuXG4gIGdldEN1cnJlbnRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRzW3RoaXMuY3VycmVudEFjY291bnRdO1xuICB9XG5cbiAgYWRkQWNjb3VudHMobiA9IDEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMudW5sb2NrZWRBY2NvdW50O1xuICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuICAgICAgICBjb25zdCBuZXdBY2NvdW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgbmV3QWNjb3VudHMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgICAgIHRoaXMudW5sb2NrZWRBY2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5jb25jYXQobmV3QWNjb3VudHMpO1xuICAgICAgICByZXNvbHZlKHRoaXMuYWNjb3VudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRGaXJzdFBhZ2UoKSB7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoMSk7XG4gIH1cblxuICBnZXROZXh0UGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoMSk7XG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKC0xKTtcbiAgfVxuXG4gIGFzeW5jIF9fZ2V0UGFnZShpbmNyZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVhZEtleXJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlyaW5nTW9kZSA9PT0gS0VZUklOR19NT0RFLmhkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldE5vcm1hbFBhZ2UoaW5jcmVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZShpbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFjY291bnRzKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hY2NvdW50cyk7XG4gIH1cblxuICByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKGEgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICB9IC8vIHR4IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBldGhlcmV1bWpzLXRyYW5zYWN0aW9uIGNsYXNzLlxuXG5cbiAgc3RhdGljIHNlcmlhbGl6ZVR4KHR4KSB7XG4gICAgLy8gbmVlZCB1c2UgRUlQLTE1NVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eC52ID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKHR4LmNvbW1vbi5jaGFpbklkKCkpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0eC5yID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKDApOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0eC5zID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKDApO1xuICAgIHJldHVybiB0eC5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCQxKSB7XG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0eCQxLmNvbW1vbi5jaGFpbklkKCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQmFzZUtleXJpbmcuc2VyaWFsaXplVHgodHgkMSksIGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50cmFuc2FjdGlvbiwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCBjaGFpbklkKTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsICdTY2FuIHdpdGggeW91ciBLZXlzdG9uZScsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eCQxLnRvSlNPTigpO1xuICAgIHJldHVybiB0eC5UcmFuc2FjdGlvbi5mcm9tVHhEYXRhKHtcbiAgICAgIHRvOiB0eEpzb25bJ3RvJ10sXG4gICAgICBnYXNMaW1pdDogdHhKc29uWydnYXNMaW1pdCddLFxuICAgICAgZ2FzUHJpY2U6IHR4SnNvblsnZ2FzUHJpY2UnXSxcbiAgICAgIGRhdGE6IHR4SnNvblsnZGF0YSddLFxuICAgICAgbm9uY2U6IHR4SnNvblsnbm9uY2UnXSxcbiAgICAgIHZhbHVlOiB0eEpzb25bJ3ZhbHVlJ10sXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9LCB7XG4gICAgICBjb21tb246IHR4JDEuY29tbW9uXG4gICAgfSk7XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZSh3aXRoQWNjb3VudCwgbWVzc2FnZUhleCkge1xuICAgIGNvbnN0IHVzaWduZWRIZXggPSBldGhlcmV1bWpzVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlSGV4KTtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHVzaWduZWRIZXgsICdoZXgnKSwgYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnBlcnNvbmFsTWVzc2FnZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCB1bmRlZmluZWQsIHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsICdTY2FuIHdpdGggeW91ciBLZXlzdG9uZScsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gJzB4JyArIEJ1ZmZlci5jb25jYXQoW3IsIHMsIHZdKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhKHdpdGhBY2NvdW50LCB0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHR5cGVkRGF0YSksICd1dGYtOCcpLCBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWREYXRhLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIHVuZGVmaW5lZCwgd2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgJ1NjYW4gd2l0aCB5b3VyIEtleXN0b25lJywgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiAnMHgnICsgQnVmZmVyLmNvbmNhdChbciwgcywgdl0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIGFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aGVyZXVtanNVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleGVzW2NoZWNrc3VtbWVkQWRkcmVzc107XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hlY2tzdW1tZWRBZGRyZXNzID09PSAoYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpKSkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKCcqJywgaW5kZXgudG9TdHJpbmcoKSkucmVwbGFjZUFsbCgnKicsICcwJyl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gZXRoZXJldW1qc1V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxuXG59XG5CYXNlS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGU7XG5cbmV4cG9ydHMuQmFzZUtleXJpbmcgPSBCYXNlS2V5cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGUsdCxyLGk9KGU9cmVxdWlyZShcImhka2V5XCIpKSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZSxzPXJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIiksbj1yZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIiksYT1yZXF1aXJlKFwiQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoXCIpLG89cmVxdWlyZShcInV1aWRcIik7IWZ1bmN0aW9uKGUpe2UuaGQ9XCJoZFwiLGUucHVia2V5PVwicHVia2V5XCJ9KHR8fCh0PXt9KSksZnVuY3Rpb24oZSl7ZS5zdGFuZGFyZD1cImFjY291bnQuc3RhbmRhcmRcIixlLmxlZGdlcl9saXZlPVwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiLGUubGVkZ2VyX2xlZ2FjeT1cImFjY291bnQubGVkZ2VyX2xlZ2FjeVwifShyfHwocj17fSkpO2NsYXNzIGh7Y29uc3RydWN0b3IoZSl7dGhpcy52ZXJzaW9uPTEsdGhpcy5nZXRJbnRlcmFjdGlvbj0oKT0+e3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9leHRlbmRzOiBtZXRob2QgZ2V0SW50ZXJhY3Rpb24gbm90IGltcGxlbWVudGVkLCBwbGVhc2UgZXh0ZW5kIEJhc2VLZXlyaW5nIGJ5IG92ZXJ3cml0aW5nIHRoaXMgbWV0aG9kLlwiKX0sdGhpcy50eXBlPVwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiLHRoaXMucmVxdWVzdFNpZ25hdHVyZT1hc3luYyhlLHQscixpKT0+e2NvbnN0IHM9YXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUodCxyLGkpLG49cy5nZXRSZXF1ZXN0SWQoKSxhPXMuZ2V0U2lnbmF0dXJlKCk7aWYobiYmby5zdHJpbmdpZnkobikhPT1lKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiByZWFkIHNpZ25hdHVyZSBlcnJvcjogbWlzbWF0Y2hlZCByZXF1ZXN0SWRcIik7cmV0dXJue3I6YS5zbGljZSgwLDMyKSxzOmEuc2xpY2UoMzIsNjQpLHY6YS5zbGljZSg2NCl9fSx0aGlzLl9fcmVhZENyeXB0b0hES2V5PWU9Pnt2YXIgdCxpO2NvbnN0IHM9XCJtL1wiK2UuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpLG49bnVsbD09KHQ9ZS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKSxhPShudWxsPT0oaT1lLmdldENoaWxkcmVuKCkpP3ZvaWQgMDppLmdldFBhdGgoKSl8fFwiMC8qXCIsbz1lLmdldE5hbWUoKTtpZihlLmdldE5vdGUoKT09PXIuc3RhbmRhcmQ/dGhpcy5rZXlyaW5nQWNjb3VudD1yLnN0YW5kYXJkOmUuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGVnYWN5JiYodGhpcy5rZXlyaW5nQWNjb3VudD1yLmxlZGdlcl9sZWdhY3kpLCFuKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1oZGtleSwgY2Fubm90IGdldCBzb3VyY2UgZmluZ2VycHJpbnRcIik7Y29uc3QgaD1lLmdldEJpcDMyS2V5KCk7dGhpcy54ZnA9bix0aGlzLnhwdWI9aCx0aGlzLmhkUGF0aD1zLHRoaXMuY2hpbGRyZW5QYXRoPWEsdm9pZCAwIT09byYmXCJcIiE9PW8mJih0aGlzLm5hbWU9byksdGhpcy5pbml0aWFsaXplZD0hMH0sdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50PWU9Pnt2YXIgdCxpO2NvbnN0IG49bnVsbD09KHQ9ZS5nZXRNYXN0ZXJGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgY2Fubm90IGdldCBtYXN0ZXIgZmluZ2VycHJpbnRcIik7dGhpcy54ZnA9bix0aGlzLmluaXRpYWxpemVkPSEwO2xldCBhPSExO2NvbnN0IG89ZS5nZXRPdXRwdXREZXNjcmlwdG9ycygpO2lmKCFvfHwwPT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7aWYoby5sZW5ndGglNSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93XCIpO3JldHVybiBudWxsPT0oaT1lLmdldE91dHB1dERlc2NyaXB0b3JzKCkpfHxpLmZvckVhY2goZT0+e3RyeXtjb25zdCB0PWUuZ2V0SERLZXkoKTtpZih0KXtjb25zdCBlPXQuZ2V0S2V5KCksaT1cIk0vXCIrdC5nZXRPcmlnaW4oKS5nZXRQYXRoKCksbj1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3MoZSwhMCkudG9TdHJpbmcoXCJoZXhcIik7dGhpcy5uYW1lPXQuZ2V0TmFtZSgpLHQuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGl2ZSYmKHRoaXMua2V5cmluZ0FjY291bnQ9ci5sZWRnZXJfbGl2ZSksdm9pZCAwPT09dGhpcy5wYXRoc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKG4pXSYmKGE9ITApLHRoaXMucGF0aHNbcy50b0NoZWNrc3VtQWRkcmVzcyhuKV09aX19Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IFwiK2UpfX0pLGF9LHRoaXMuZ2V0TmFtZT0oKT0+dGhpcy5uYW1lLHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrPWU9Pnt0aGlzLnVubG9ja2VkQWNjb3VudD1wYXJzZUludChlLDEwKX0sdGhpcy5fX2dldE5vcm1hbFBhZ2U9ZT0+KHRoaXMucGFnZSs9ZSx0aGlzLnBhZ2U8PTAmJih0aGlzLnBhZ2U9MSksbmV3IFByb21pc2UoYXN5bmMoZSx0KT0+e3RyeXtjb25zdCB0PSh0aGlzLnBhZ2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSksdGhpcy5pbmRleGVzW3MudG9DaGVja3N1bUFkZHJlc3ModCldPWV9ZShpKX1jYXRjaChlKXt0KGUpfX0pKSx0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2U9ZT0+e2NvbnN0IHQ9dGhpcy5wYWdlK2U7cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKHIsaSk9Pnt0cnl7Y29uc3QgaT0odC0xKSp0aGlzLnBlclBhZ2Uscz1pK3RoaXMucGVyUGFnZSxuPVtdO2ZvcihsZXQgZT1pO2U8cztlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7bi5wdXNoKHthZGRyZXNzOnQsYmFsYW5jZTpudWxsLGluZGV4OmV9KX10aGlzLnBhZ2UrPWUscihuKX1jYXRjaChlKXtpKGUpfX0pfSx0aGlzLl9fYWRkcmVzc0Zyb21JbmRleD1hc3luYyhlLHIpPT57aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe3RoaXMuY2hlY2tLZXlyaW5nKCksdGhpcy5oZGt8fCh0aGlzLmhkaz1pLmZyb21FeHRlbmRlZEtleSh0aGlzLnhwdWIpKTtjb25zdCB0PXRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsU3RyaW5nKHIpKS5yZXBsYWNlQWxsKFwiKlwiLFwiMFwiKSxuPXRoaXMuaGRrLmRlcml2ZShgJHtlfS8ke3R9YCksYT1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3Mobi5wdWJsaWNLZXksITApLnRvU3RyaW5nKFwiaGV4XCIpO3JldHVybiBzLnRvQ2hlY2tzdW1BZGRyZXNzKGEpfXtjb25zdCBlPU9iamVjdC5rZXlzKHRoaXMucGF0aHMpW3JdO2lmKGUpcmV0dXJuIHMudG9DaGVja3N1bUFkZHJlc3MoZSk7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50XCIpfX0sdGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy51bmxvY2tlZEFjY291bnQ9MCx0aGlzLm5hbWU9XCJRUiBIYXJkd2FyZVwiLHRoaXMua2V5cmluZ01vZGU9dC5oZCx0aGlzLmtleXJpbmdBY2NvdW50PXIuc3RhbmRhcmQsdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLnhmcD1cIlwiLHRoaXMueHB1Yj1cIlwiLHRoaXMuaGRQYXRoPVwiXCIsdGhpcy5jaGlsZHJlblBhdGg9XCIwLypcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5wYXRocz17fSx0aGlzLmRlc2VyaWFsaXplKGUpfWFzeW5jIHJlYWRLZXlyaW5nKCl7Y29uc3QgZT1hd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50KCk7ZS5nZXRSZWdpc3RyeVR5cGUoKT09PWEuZXh0ZW5kLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZPyh0aGlzLmtleXJpbmdNb2RlPXQuaGQsdGhpcy5fX3JlYWRDcnlwdG9IREtleShlKSk6KHRoaXMua2V5cmluZ01vZGU9dC5wdWJrZXksdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGUpKX1jaGVja0tleXJpbmcoKXtpZighdGhpcy54ZnB8fCF0aGlzLnhwdWJ8fCF0aGlzLmhkUGF0aCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIil9c2VyaWFsaXplKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7aW5pdGlhbGl6ZWQ6dGhpcy5pbml0aWFsaXplZCxhY2NvdW50czp0aGlzLmFjY291bnRzLGN1cnJlbnRBY2NvdW50OnRoaXMuY3VycmVudEFjY291bnQscGFnZTp0aGlzLnBhZ2UscGVyUGFnZTp0aGlzLnBlclBhZ2Usa2V5cmluZ0FjY291bnQ6dGhpcy5rZXlyaW5nQWNjb3VudCxrZXlyaW5nTW9kZTp0aGlzLmtleXJpbmdNb2RlLG5hbWU6dGhpcy5uYW1lLHZlcnNpb246dGhpcy52ZXJzaW9uLHhmcDp0aGlzLnhmcCx4cHViOnRoaXMueHB1YixoZFBhdGg6dGhpcy5oZFBhdGgsY2hpbGRyZW5QYXRoOnRoaXMuY2hpbGRyZW5QYXRoLGluZGV4ZXM6dGhpcy5pbmRleGVzLHBhdGhzOnRoaXMucGF0aHN9KX1kZXNlcmlhbGl6ZShlKXtlJiYodGhpcy5hY2NvdW50cz1lLmFjY291bnRzLHRoaXMuY3VycmVudEFjY291bnQ9ZS5jdXJyZW50QWNjb3VudCx0aGlzLnBhZ2U9ZS5wYWdlLHRoaXMucGVyUGFnZT1lLnBlclBhZ2UsdGhpcy5uYW1lPWUubmFtZSx0aGlzLmluaXRpYWxpemVkPWUuaW5pdGlhbGl6ZWQsdGhpcy5rZXlyaW5nTW9kZT1lLmtleXJpbmdNb2RlfHx0LmhkLHRoaXMua2V5cmluZ0FjY291bnQ9ZS5rZXlyaW5nQWNjb3VudHx8ci5zdGFuZGFyZCx0aGlzLnhmcD1lLnhmcCx0aGlzLnhwdWI9ZS54cHViLHRoaXMuaGRQYXRoPWUuaGRQYXRoLHRoaXMuaW5kZXhlcz1lLmluZGV4ZXMsdGhpcy5wYXRocz1lLnBhdGhzLHRoaXMuY2hpbGRyZW5QYXRoPWUuY2hpbGRyZW5QYXRofHxcIjAvKlwiKX1zZXRDdXJyZW50QWNjb3VudChlKXt0aGlzLmN1cnJlbnRBY2NvdW50PWV9Z2V0Q3VycmVudEFjY291bnQoKXtyZXR1cm4gdGhpcy5jdXJyZW50QWNjb3VudH1nZXRDdXJyZW50QWRkcmVzcygpe3JldHVybiB0aGlzLmFjY291bnRzW3RoaXMuY3VycmVudEFjY291bnRdfWFkZEFjY291bnRzKGU9MSl7cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKHQscik9Pnt0cnl7Y29uc3Qgcj10aGlzLnVubG9ja2VkQWNjb3VudCxpPXIrZSxzPVtdO2ZvcihsZXQgZT1yO2U8aTtlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7cy5wdXNoKHQpLHRoaXMucGFnZT0wLHRoaXMudW5sb2NrZWRBY2NvdW50Kyt9dGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmNvbmNhdChzKSx0KHRoaXMuYWNjb3VudHMpfWNhdGNoKGUpe3IoZSl9fSl9Z2V0Rmlyc3RQYWdlKCl7cmV0dXJuIHRoaXMucGFnZT0wLHRoaXMuX19nZXRQYWdlKDEpfWdldE5leHRQYWdlKCl7cmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpfWdldFByZXZpb3VzUGFnZSgpe3JldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSl9YXN5bmMgX19nZXRQYWdlKGUpe3JldHVybiB0aGlzLmluaXRpYWxpemVkfHxhd2FpdCB0aGlzLnJlYWRLZXlyaW5nKCksdGhpcy5rZXlyaW5nTW9kZT09PXQuaGQ/dGhpcy5fX2dldE5vcm1hbFBhZ2UoZSk6dGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGUpfWdldEFjY291bnRzKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKX1yZW1vdmVBY2NvdW50KGUpe2lmKCF0aGlzLmFjY291bnRzLm1hcChlPT5lLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGUudG9Mb3dlckNhc2UoKSkpdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7ZX0gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO3RoaXMuYWNjb3VudHM9dGhpcy5hY2NvdW50cy5maWx0ZXIodD0+dC50b0xvd2VyQ2FzZSgpIT09ZS50b0xvd2VyQ2FzZSgpKX1zdGF0aWMgc2VyaWFsaXplVHgoZSl7cmV0dXJuIGUudj1uZXcgcy5CTihlLmNvbW1vbi5jaGFpbklkKCkpLGUucj1uZXcgcy5CTigwKSxlLnM9bmV3IHMuQk4oMCksZS5zZXJpYWxpemUoKX1hc3luYyBzaWduVHJhbnNhY3Rpb24oZSx0KXtjb25zdCByPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxpPXQuY29tbW9uLmNoYWluSWQoKSxzPW8udjQoKSxjPWEuRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChoLnNlcmlhbGl6ZVR4KHQpLGEuRGF0YVR5cGUudHJhbnNhY3Rpb24scix0aGlzLnhmcCxzLGkpLHtyOmQsczp1LHY6Z309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHMsYyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpLGw9dC50b0pTT04oKTtyZXR1cm4gbi5UcmFuc2FjdGlvbi5mcm9tVHhEYXRhKHt0bzpsLnRvLGdhc0xpbWl0OmwuZ2FzTGltaXQsZ2FzUHJpY2U6bC5nYXNQcmljZSxkYXRhOmwuZGF0YSxub25jZTpsLm5vbmNlLHZhbHVlOmwudmFsdWUscjpkLHM6dSx2Omd9LHtjb21tb246dC5jb21tb259KX1zaWduTWVzc2FnZShlLHQpe3JldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KX1hc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKGUsdCl7Y29uc3Qgcj1zLnN0cmlwSGV4UHJlZml4KHQpLGk9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLG49by52NCgpLGg9YS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHIsXCJoZXhcIiksYS5EYXRhVHlwZS5wZXJzb25hbE1lc3NhZ2UsaSx0aGlzLnhmcCxuLHZvaWQgMCxlKSx7cjpjLHM6ZCx2OnV9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShuLGgsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm5cIjB4XCIrQnVmZmVyLmNvbmNhdChbYyxkLHVdKS50b1N0cmluZyhcImhleFwiKX1hc3luYyBzaWduVHlwZWREYXRhKGUsdCl7Y29uc3Qgcj1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksaT1vLnY0KCkscz1hLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodCksXCJ1dGYtOFwiKSxhLkRhdGFUeXBlLnR5cGVkRGF0YSxyLHRoaXMueGZwLGksdm9pZCAwLGUpLHtyOm4sczpoLHY6Y309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKGkscyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtuLGgsY10pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoZSl7aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKTtsZXQgcj10aGlzLmluZGV4ZXNbdF07aWYodm9pZCAwPT09cilmb3IobGV0IGU9MDtlPDFlMztlKyspaWYodD09PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpKXtyPWU7YnJlYWt9aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuYCR7dGhpcy5oZFBhdGh9LyR7dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIixyLnRvU3RyaW5nKCkpLnJlcGxhY2VBbGwoXCIqXCIsXCIwXCIpfWB9e2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKSxyPXRoaXMucGF0aHNbdF07aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuIHJ9fX1oLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsZXhwb3J0cy5CYXNlS2V5cmluZz1oO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1ldGgta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCJpbXBvcnQgeyBORVRXT1JLX1RPX05BTUVfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmV4cG9ydCBjb25zdCBnZXROZXR3b3JrRGlzcGxheU5hbWUgPSAoa2V5KSA9PiBORVRXT1JLX1RPX05BTUVfTUFQW2tleV07XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUeE1ldGFGb3JScGNSZXN1bHQodHhNZXRhKSB7XG4gIGNvbnN0IHsgciwgcywgdiwgaGFzaCwgdHhSZWNlaXB0LCB0eFBhcmFtcyB9ID0gdHhNZXRhO1xuICBjb25zdCB7XG4gICAgdG8sXG4gICAgZGF0YSxcbiAgICBub25jZSxcbiAgICBnYXMsXG4gICAgZnJvbSxcbiAgICB2YWx1ZSxcbiAgICBnYXNQcmljZSxcbiAgICBhY2Nlc3NMaXN0LFxuICAgIG1heEZlZVBlckdhcyxcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgfSA9IHR4UGFyYW1zO1xuXG4gIGNvbnN0IGZvcm1hdHRlZFR4TWV0YSA9IHtcbiAgICB2LFxuICAgIHIsXG4gICAgcyxcbiAgICB0byxcbiAgICBnYXMsXG4gICAgZnJvbSxcbiAgICBoYXNoLFxuICAgIG5vbmNlLFxuICAgIGlucHV0OiBkYXRhIHx8ICcweCcsXG4gICAgdmFsdWU6IHZhbHVlIHx8ICcweDAnLFxuICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3QgfHwgbnVsbCxcbiAgICBibG9ja0hhc2g6IHR4UmVjZWlwdD8uYmxvY2tIYXNoIHx8IG51bGwsXG4gICAgYmxvY2tOdW1iZXI6IHR4UmVjZWlwdD8uYmxvY2tOdW1iZXIgfHwgbnVsbCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiB0eFJlY2VpcHQ/LnRyYW5zYWN0aW9uSW5kZXggfHwgbnVsbCxcbiAgfTtcblxuICBpZiAobWF4RmVlUGVyR2FzICYmIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgZm9ybWF0dGVkVHhNZXRhLmdhc1ByaWNlID0gbWF4RmVlUGVyR2FzO1xuICAgIGZvcm1hdHRlZFR4TWV0YS5tYXhGZWVQZXJHYXMgPSBtYXhGZWVQZXJHYXM7XG4gICAgZm9ybWF0dGVkVHhNZXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID0gbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgZm9ybWF0dGVkVHhNZXRhLnR5cGUgPSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdHRlZFR4TWV0YS5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgIGZvcm1hdHRlZFR4TWV0YS50eXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZFR4TWV0YTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2luZGV4JyksXG4gICAgdGhyb3dJZlVuZGVmaW5lZCA9IF9yZXF1aXJlLnRocm93SWZVbmRlZmluZWQsXG4gICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzID0gX3JlcXVpcmUudGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIE9SQklUREJfT1BUUyA9IGNvbmZpZy5vcmJpdGRiX29wdGlvbnM7XG5cbnZhciBLZXlWYWx1ZVN0b3JlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFBsZWFzZSB1c2UgKipib3gucHVibGljKiogb3IgKipib3gucHJpdmF0ZSoqIHRvIGdldCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gS2V5VmFsdWVTdG9yZShvcmJpdGRiLCBuYW1lLCBlbnN1cmVDb25uZWN0ZWQsIHRocmVlSWQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEtleVZhbHVlU3RvcmUpO1xuICAgIHRoaXMuX29yYml0ZGIgPSBvcmJpdGRiO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuXG4gICAgaWYgKHRoaXMuX25hbWUuc3RhcnRzV2l0aCgnM2JveC5zcGFjZS4nKSkge1xuICAgICAgdGhpcy5fc3BhY2UgPSB0aGlzLl9uYW1lLnNwbGl0KCcuJylbMl07XG4gICAgfVxuXG4gICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkID0gZW5zdXJlQ29ubmVjdGVkO1xuICAgIHRoaXMuXzNpZCA9IHRocmVlSWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgYW5kIG9wdGlvbmFsbHkgbWV0YWRhdGEgb2YgdGhlIGdpdmVuIGtleVxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGtleSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubWV0YWRhdGEgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdGggdmFsdWUgYW5kIG1ldGFkYXRhXG4gICAqIEByZXR1cm4gICAge1N0cmluZ3x7dmFsdWU6IFN0cmluZywgdGltZXN0YW1wOiBOdW1iZXJ9fSB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIHVuZGVmaW5lZCBpZiB0aGVyZSdzIG5vIHN1Y2gga2V5XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShLZXlWYWx1ZVN0b3JlLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5KSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDoge307XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB4ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgeCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGlmICghb3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRoaXMuX2V4dHJhY3RNZXRhZGF0YSh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9vYmplY3RTcHJlYWQoe30sIG1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogeC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB4LnZhbHVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXQoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IG1ldGFkYXRhIGZvciBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge01ldGFkYXRhfSAgICAgICAgICAgICAgICAgICAgICAgICAgTWV0YWRhdGEgZm9yIHRoZSBrZXksIHVuZGVmaW5lZCBpZiB0aGVyZSdzIG5vIHN1Y2gga2V5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1ldGFkYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSkge1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoa2V5KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgeCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLl9leHRyYWN0TWV0YWRhdGEoeCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRNZXRhZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TWV0YWRhdGE7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogU2V0IGEgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgdmFsdWUgICAgICAgICAgICAgICAgICAgdGhlIHZhbHVlXG4gICAgICogQHJldHVybiAgICB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHN1Y2Nlc3NmdWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0aW1lU3RhbXA7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKCk7XG5cbiAgICAgICAgICAgICAgICB0aW1lU3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLnB1dChrZXksIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXQoX3gzLCBfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9KClcbiAgICAvKipcbiAgICAqIFNldCBtdWx0aXBsZSB2YWx1ZXMgZm9yIG11bHRpcGxlIGtleXNcbiAgICAqXG4gICAgKiBAcGFyYW0gICAgIHtBcnJheTxTdHJpbmc+fSAgICBrZXlzICAgICAgICAgICAgICAgICAgICAgdGhlIGtleXNcbiAgICAqIEBwYXJhbSAgICAge0FycmF5PFN0cmluZz59ICAgIHZhbHVlcyAgICAgICAgICAgICAgICAgICB0aGUgdmFsdWVzXG4gICAgKiBAcmV0dXJuICAgIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHN1Y2Nlc3NmdWwsIHRocm93IGVycm9yIGlmIG5vdFxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdWx0aXBsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldE11bHRpcGxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZOb3RFcXVhbExlbkFycmF5cyhrZXlzLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUNvbm5lY3RlZCgpO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHByZXZpb3VzUHJvbWlzZSwgbmV4dEtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQobmV4dEtleSwgJ2tleScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF90aGlzLl9kYi5wdXQobmV4dEtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU0KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDcsIF94OCwgX3g5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzMsIDldXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldE11bHRpcGxlKF94NSwgX3g2KSB7XG4gICAgICAgIHJldHVybiBfc2V0TXVsdGlwbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldE11bHRpcGxlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSBpZiBzdWNjZXNzZnVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKCk7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLmRlbChrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlKF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IG1ldGFkYXRhIGZyb20gc3RvcmUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geCB7T2JqZWN0fSBkYXRhIGZyb20gc3RvcmVcbiAgICAgKiBAcmV0dXJuIHtNZXRhZGF0YX0gc3RvcmUgbWV0YWRhdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9leHRyYWN0TWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhY3RNZXRhZGF0YSh4KSB7XG4gICAgICAvLyBtcyAtPiBzZWNvbmRzLCBzZWUgaXNzdWUgIzM5NiBmb3IgZGV0YWlsc1xuICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoeC50aW1lU3RhbXAgLyAxMDAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJhdyB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0MyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmdldChrZXkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2dldChfeDExKSB7XG4gICAgICAgIHJldHVybiBfZ2V0My5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N5bmMyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KG51bVJlbW90ZUVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG51bUVudHJpZXNEZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpOyAvLyBsZXQgdG9pZCA9IG51bGxcblxuXG4gICAgICAgICAgICAgICAgbnVtRW50cmllc0RlZmluZWQgPSAhKG51bVJlbW90ZUVudHJpZXMgPT09IG51bGwgfHwgbnVtUmVtb3RlRW50cmllcyA9PT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgIGlmICghKG51bUVudHJpZXNEZWZpbmVkICYmIG51bVJlbW90ZUVudHJpZXMgPD0gdGhpcy5fZGIuX29wbG9nLnZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLnJlc29sdmUoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFudW1SZW1vdGVFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5fZGIuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVwbGljYXRlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9kYi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXBsaWNhdGUucHJvZ3Jlc3MnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtUmVtb3RlRW50cmllcyA8PSBfdGhpczIuX2RiLl9vcGxvZy52YWx1ZXMubGVuZ3RoKSByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYi5ldmVudHMub24oJ3JlcGxpY2F0ZS5wcm9ncmVzcycsIChfeCwgX3ksIF96LCBudW0sIG1heCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b2lkKVxuICAgICAgICAgICAgICAgICAgICAgIHRvaWQgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBudW1SZW1vdGVFbnRyaWVzIHx8IG1heFxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFkZGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hZGRyZXNzLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfc3luYyhfeDEyKSB7XG4gICAgICAgIHJldHVybiBfc3luYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zeW5jO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9hZDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkob2RiQWRkcmVzcykge1xuICAgICAgICB2YXIga2V5LCBvcHRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLl8zaWQuZ2V0S2V5cmluZ0J5U3BhY2VOYW1lKHRoaXMuX25hbWUpLmdldFB1YmxpY0tleXModHJ1ZSkuc2lnbmluZ0tleTtcbiAgICAgICAgICAgICAgICBvcHRzID0gX29iamVjdFNwcmVhZCh7fSwgT1JCSVREQl9PUFRTLCB7XG4gICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdkYWctcGInLFxuICAgICAgICAgICAgICAgICAgYWNjZXNzQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZTogW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsZWdhY3ktaXBmcy0zYm94JyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE1hbmlmZXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5nZXRPZGJJZCh0aGlzLl9zcGFjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG9wdHMuaWRlbnRpdHkgPSBfY29udGV4dDkuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmJpdGRiLmtleXZhbHVlKG9kYkFkZHJlc3MgfHwgdGhpcy5fbmFtZSwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RiID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGIubG9hZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZGIuYWRkcmVzcy50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9sb2FkKF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xvYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVpcmVMb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1aXJlTG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy5fZGIpIHRocm93IG5ldyBFcnJvcignX2xvYWQgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGludGVyYWN0aW5nIHdpdGggdGhlIHN0b3JlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdmFsdWVzIGFuZCBvcHRpb25hbGx5IG1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLm1ldGFkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdGggdmFsdWVzIGFuZCBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gICAge0FycmF5PFN0cmluZ3x7dmFsdWU6IFN0cmluZywgdGltZXN0YW1wOiBOdW1iZXJ9Pn0gIHRoZSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FsbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIGFsbFNpbXBsZSxcbiAgICAgICAgICAgIF9hcmdzMTEgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxMS5sZW5ndGggPiAwICYmIF9hcmdzMTFbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTFbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5fZGIuYWxsO1xuICAgICAgICAgICAgICAgIGFsbFNpbXBsZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJpZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2tleV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFNpbXBsZVtrZXldID0gX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLl9leHRyYWN0TWV0YWRhdGEoZW50cnkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsU2ltcGxlW2tleV0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgYWxsU2ltcGxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhbGwoKSB7XG4gICAgICAgIHJldHVybiBfYWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiB1bmRlcmx5aW5nIGxvZyBlbnRyaWVzLiBJbiBsaW5lYXJpemVkIG9yZGVyIGFjY29yZGluZyB0byB0aGVpciBMYW1wb3J0IGNsb2Nrcy5cbiAgICAgKiBVc2VmdWwgZm9yIGdlbmVyYXRpbmcgYSBjb21wbGV0ZSBoaXN0b3J5IG9mIGFsbCBvcGVyYXRpb25zIG9uIHN0b3JlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlXG4gICAgICogIGNvbnN0IGxvZyA9IHN0b3JlLmxvZ1xuICAgICAqICBjb25zdCBlbnRyeSA9IGxvZ1swXVxuICAgICAqICBjb25zb2xlLmxvZyhlbnRyeSlcbiAgICAgKiAgLy8geyBvcDogJ1BVVCcsIGtleTogJ05hbWUnLCB2YWx1ZTogJ0JvdGJvdCcsIHRpbWVTdGFtcDogJzE1Mzg1NzU0MTYwNjgnIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICBBcnJheSBvZiBvcmRlcmVkIGxvZyBlbnRyeSBvYmplY3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2dcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYi5fb3Bsb2cudmFsdWVzLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IG9iai5wYXlsb2FkLm9wLFxuICAgICAgICAgIGtleTogb2JqLnBheWxvYWQua2V5LFxuICAgICAgICAgIHZhbHVlOiBvYmoucGF5bG9hZC52YWx1ZSA/IG9iai5wYXlsb2FkLnZhbHVlLnZhbHVlIDogbnVsbCxcbiAgICAgICAgICB0aW1lU3RhbXA6IG9iai5wYXlsb2FkLnZhbHVlID8gb2JqLnBheWxvYWQudmFsdWUudGltZVN0YW1wIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLZXlWYWx1ZVN0b3JlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVZhbHVlU3RvcmU7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxudmFyIHNsaWNlID0gdXRpbC5zbGljZVxudmFyIHBsdWNrID0gdXRpbC5wbHVja1xudmFyIGVhY2ggPSB1dGlsLmVhY2hcbnZhciBiaW5kID0gdXRpbC5iaW5kXG52YXIgY3JlYXRlID0gdXRpbC5jcmVhdGVcbnZhciBpc0xpc3QgPSB1dGlsLmlzTGlzdFxudmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb25cbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3RcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZVN0b3JlOiBjcmVhdGVTdG9yZVxufVxuXG52YXIgc3RvcmVBUEkgPSB7XG5cdHZlcnNpb246ICcyLjAuMTInLFxuXHRlbmFibGVkOiBmYWxzZSxcblx0XG5cdC8vIGdldCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5LiBJZiB0aGF0IHZhbHVlXG5cdC8vIGlzIHVuZGVmaW5lZCwgaXQgcmV0dXJucyBvcHRpb25hbERlZmF1bHRWYWx1ZSBpbnN0ZWFkLlxuXHRnZXQ6IGZ1bmN0aW9uKGtleSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuc3RvcmFnZS5yZWFkKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSlcblx0XHRyZXR1cm4gdGhpcy5fZGVzZXJpYWxpemUoZGF0YSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpXG5cdH0sXG5cblx0Ly8gc2V0IHdpbGwgc3RvcmUgdGhlIGdpdmVuIHZhbHVlIGF0IGtleSBhbmQgcmV0dXJucyB2YWx1ZS5cblx0Ly8gQ2FsbGluZyBzZXQgd2l0aCB2YWx1ZSA9PT0gdW5kZWZpbmVkIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyByZW1vdmUuXG5cdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoa2V5KVxuXHRcdH1cblx0XHR0aGlzLnN0b3JhZ2Uud3JpdGUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5LCB0aGlzLl9zZXJpYWxpemUodmFsdWUpKVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXG5cdC8vIHJlbW92ZSBkZWxldGVzIHRoZSBrZXkgYW5kIHZhbHVlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4ga2V5LlxuXHRyZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5KVxuXHR9LFxuXG5cdC8vIGVhY2ggd2lsbCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyXG5cdC8vIGluIHRoaXMgc3RvcmUuXG5cdGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0dGhpcy5zdG9yYWdlLmVhY2goZnVuY3Rpb24odmFsLCBuYW1lc3BhY2VkS2V5KSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYsIHNlbGYuX2Rlc2VyaWFsaXplKHZhbCksIChuYW1lc3BhY2VkS2V5IHx8ICcnKS5yZXBsYWNlKHNlbGYuX25hbWVzcGFjZVJlZ2V4cCwgJycpKVxuXHRcdH0pXG5cdH0sXG5cblx0Ly8gY2xlYXJBbGwgd2lsbCByZW1vdmUgYWxsIHRoZSBzdG9yZWQga2V5LXZhbHVlIHBhaXJzIGluIHRoaXMgc3RvcmUuXG5cdGNsZWFyQWxsOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3JhZ2UuY2xlYXJBbGwoKVxuXHR9LFxuXG5cdC8vIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbid0IGxpdmUgaW4gcGx1Z2luc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQvLyBoYXNOYW1lc3BhY2UgcmV0dXJucyB0cnVlIGlmIHRoaXMgc3RvcmUgaW5zdGFuY2UgaGFzIHRoZSBnaXZlbiBuYW1lc3BhY2UuXG5cdGhhc05hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9uYW1lc3BhY2VQcmVmaXggPT0gJ19fc3RvcmVqc18nK25hbWVzcGFjZSsnXycpXG5cdH0sXG5cblx0Ly8gY3JlYXRlU3RvcmUgY3JlYXRlcyBhIHN0b3JlLmpzIGluc3RhbmNlIHdpdGggdGhlIGZpcnN0XG5cdC8vIGZ1bmN0aW9uaW5nIHN0b3JhZ2UgaW4gdGhlIGxpc3Qgb2Ygc3RvcmFnZSBjYW5kaWRhdGVzLFxuXHQvLyBhbmQgYXBwbGllcyB0aGUgdGhlIGdpdmVuIG1peGlucyB0byB0aGUgaW5zdGFuY2UuXG5cdGNyZWF0ZVN0b3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9LFxuXHRcblx0YWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHR0aGlzLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHR9LFxuXHRcblx0bmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUodGhpcy5zdG9yYWdlLCB0aGlzLnBsdWdpbnMsIG5hbWVzcGFjZSlcblx0fVxufVxuXG5mdW5jdGlvbiBfd2FybigpIHtcblx0dmFyIF9jb25zb2xlID0gKHR5cGVvZiBjb25zb2xlID09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNvbnNvbGUpXG5cdGlmICghX2NvbnNvbGUpIHsgcmV0dXJuIH1cblx0dmFyIGZuID0gKF9jb25zb2xlLndhcm4gPyBfY29uc29sZS53YXJuIDogX2NvbnNvbGUubG9nKVxuXHRmbi5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShzdG9yYWdlcywgcGx1Z2lucywgbmFtZXNwYWNlKSB7XG5cdGlmICghbmFtZXNwYWNlKSB7XG5cdFx0bmFtZXNwYWNlID0gJydcblx0fVxuXHRpZiAoc3RvcmFnZXMgJiYgIWlzTGlzdChzdG9yYWdlcykpIHtcblx0XHRzdG9yYWdlcyA9IFtzdG9yYWdlc11cblx0fVxuXHRpZiAocGx1Z2lucyAmJiAhaXNMaXN0KHBsdWdpbnMpKSB7XG5cdFx0cGx1Z2lucyA9IFtwbHVnaW5zXVxuXHR9XG5cblx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IChuYW1lc3BhY2UgPyAnX19zdG9yZWpzXycrbmFtZXNwYWNlKydfJyA6ICcnKVxuXHR2YXIgbmFtZXNwYWNlUmVnZXhwID0gKG5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoJ14nK25hbWVzcGFjZVByZWZpeCkgOiBudWxsKVxuXHR2YXIgbGVnYWxOYW1lc3BhY2VzID0gL15bYS16QS1aMC05X1xcLV0qJC8gLy8gYWxwaGEtbnVtZXJpYyArIHVuZGVyc2NvcmUgYW5kIGRhc2hcblx0aWYgKCFsZWdhbE5hbWVzcGFjZXMudGVzdChuYW1lc3BhY2UpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdzdG9yZS5qcyBuYW1lc3BhY2VzIGNhbiBvbmx5IGhhdmUgYWxwaGFudW1lcmljcyArIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMnKVxuXHR9XG5cdFxuXHR2YXIgX3ByaXZhdGVTdG9yZVByb3BzID0ge1xuXHRcdF9uYW1lc3BhY2VQcmVmaXg6IG5hbWVzcGFjZVByZWZpeCxcblx0XHRfbmFtZXNwYWNlUmVnZXhwOiBuYW1lc3BhY2VSZWdleHAsXG5cblx0XHRfdGVzdFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB0ZXN0U3RyID0gJ19fc3RvcmVqc19fdGVzdF9fJ1xuXHRcdFx0XHRzdG9yYWdlLndyaXRlKHRlc3RTdHIsIHRlc3RTdHIpXG5cdFx0XHRcdHZhciBvayA9IChzdG9yYWdlLnJlYWQodGVzdFN0cikgPT09IHRlc3RTdHIpXG5cdFx0XHRcdHN0b3JhZ2UucmVtb3ZlKHRlc3RTdHIpXG5cdFx0XHRcdHJldHVybiBva1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYXNzaWduUGx1Z2luRm5Qcm9wOiBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHR2YXIgb2xkRm4gPSB0aGlzW3Byb3BOYW1lXVxuXHRcdFx0dGhpc1twcm9wTmFtZV0gPSBmdW5jdGlvbiBwbHVnaW5GbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDApXG5cdFx0XHRcdHZhciBzZWxmID0gdGhpc1xuXG5cdFx0XHRcdC8vIHN1cGVyX2ZuIGNhbGxzIHRoZSBvbGQgZnVuY3Rpb24gd2hpY2ggd2FzIG92ZXJ3cml0dGVuIGJ5XG5cdFx0XHRcdC8vIHRoaXMgbWl4aW4uXG5cdFx0XHRcdGZ1bmN0aW9uIHN1cGVyX2ZuKCkge1xuXHRcdFx0XHRcdGlmICghb2xkRm4pIHsgcmV0dXJuIH1cblx0XHRcdFx0XHRlYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnLCBpKSB7XG5cdFx0XHRcdFx0XHRhcmdzW2ldID0gYXJnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm4gb2xkRm4uYXBwbHkoc2VsZiwgYXJncylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdpdmUgbWl4aW5nIGZ1bmN0aW9uIGFjY2VzcyB0byBzdXBlcl9mbiBieSBwcmVmaXhpbmcgYWxsIG1peGluIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGFyZ3VtZW50cyB3aXRoIHN1cGVyX2ZuLlxuXHRcdFx0XHR2YXIgbmV3Rm5BcmdzID0gW3N1cGVyX2ZuXS5jb25jYXQoYXJncylcblxuXHRcdFx0XHRyZXR1cm4gcGx1Z2luRm5Qcm9wLmFwcGx5KHNlbGYsIG5ld0ZuQXJncylcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKVxuXHRcdH0sXG5cblx0XHRfZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHN0clZhbCwgZGVmYXVsdFZhbCkge1xuXHRcdFx0aWYgKCFzdHJWYWwpIHsgcmV0dXJuIGRlZmF1bHRWYWwgfVxuXHRcdFx0Ly8gSXQgaXMgcG9zc2libGUgdGhhdCBhIHJhdyBzdHJpbmcgdmFsdWUgaGFzIGJlZW4gcHJldmlvdXNseSBzdG9yZWRcblx0XHRcdC8vIGluIGEgc3RvcmFnZSB3aXRob3V0IHVzaW5nIHN0b3JlLmpzLCBtZWFuaW5nIGl0IHdpbGwgYmUgYSByYXdcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBpbnN0ZWFkIG9mIGEgSlNPTiBzZXJpYWxpemVkIHN0cmluZy4gQnkgZGVmYXVsdGluZ1xuXHRcdFx0Ly8gdG8gdGhlIHJhdyBzdHJpbmcgdmFsdWUgaW4gY2FzZSBvZiBhIEpTT04gcGFyc2UgZXJyb3IsIHdlIGFsbG93XG5cdFx0XHQvLyBmb3IgcGFzdCBzdG9yZWQgdmFsdWVzIHRvIGJlIGZvcndhcmRzLWNvbXBhdGlibGUgd2l0aCBzdG9yZS5qc1xuXHRcdFx0dmFyIHZhbCA9ICcnXG5cdFx0XHR0cnkgeyB2YWwgPSBKU09OLnBhcnNlKHN0clZhbCkgfVxuXHRcdFx0Y2F0Y2goZSkgeyB2YWwgPSBzdHJWYWwgfVxuXG5cdFx0XHRyZXR1cm4gKHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmYXVsdFZhbClcblx0XHR9LFxuXHRcdFxuXHRcdF9hZGRTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHRpZiAodGhpcy5lbmFibGVkKSB7IHJldHVybiB9XG5cdFx0XHRpZiAodGhpcy5fdGVzdFN0b3JhZ2Uoc3RvcmFnZSkpIHtcblx0XHRcdFx0dGhpcy5zdG9yYWdlID0gc3RvcmFnZVxuXHRcdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9hZGRQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cblx0XHRcdC8vIElmIHRoZSBwbHVnaW4gaXMgYW4gYXJyYXksIHRoZW4gYWRkIGFsbCBwbHVnaW5zIGluIHRoZSBhcnJheS5cblx0XHRcdC8vIFRoaXMgYWxsb3dzIGZvciBhIHBsdWdpbiB0byBkZXBlbmQgb24gb3RoZXIgcGx1Z2lucy5cblx0XHRcdGlmIChpc0xpc3QocGx1Z2luKSkge1xuXHRcdFx0XHRlYWNoKHBsdWdpbiwgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdFx0c2VsZi5fYWRkUGx1Z2luKHBsdWdpbilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHBsdWdpbnMgd2UndmUgc2VlbiBzbyBmYXIsIHNvIHRoYXQgd2Vcblx0XHRcdC8vIGRvbid0IGFkZCBhbnkgb2YgdGhlbSB0d2ljZS5cblx0XHRcdHZhciBzZWVuUGx1Z2luID0gcGx1Y2sodGhpcy5wbHVnaW5zLCBmdW5jdGlvbihzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiAocGx1Z2luID09PSBzZWVuUGx1Z2luKVxuXHRcdFx0fSlcblx0XHRcdGlmIChzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKVxuXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwbHVnaW4gaXMgcHJvcGVybHkgZm9ybWVkXG5cdFx0XHRpZiAoIWlzRnVuY3Rpb24ocGx1Z2luKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbnMgbXVzdCBiZSBmdW5jdGlvbiB2YWx1ZXMgdGhhdCByZXR1cm4gb2JqZWN0cycpXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwbHVnaW5Qcm9wZXJ0aWVzID0gcGx1Z2luLmNhbGwodGhpcylcblx0XHRcdGlmICghaXNPYmplY3QocGx1Z2luUHJvcGVydGllcykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW5zIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzJylcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRoZSBwbHVnaW4gZnVuY3Rpb24gcHJvcGVydGllcyB0byB0aGlzIHN0b3JlIGluc3RhbmNlLlxuXHRcdFx0ZWFjaChwbHVnaW5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHRcdGlmICghaXNGdW5jdGlvbihwbHVnaW5GblByb3ApKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgcGx1Z2luIHByb3BlcnR5OiAnK3Byb3BOYW1lKycgZnJvbSBwbHVnaW4gJytwbHVnaW4ubmFtZSsnLiBQbHVnaW5zIHNob3VsZCBvbmx5IHJldHVybiBmdW5jdGlvbnMuJylcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9hc3NpZ25QbHVnaW5GblByb3AocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSlcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRcblx0XHQvLyBQdXQgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGluIHRoZSBwcml2YXRlIEFQSSwgc28gYXMgdG8gbm90IGV4cG9zZSBpdCB0byBhY2NpZGVudGlhbFxuXHRcdC8vIGRpc2NvdmVyeSB0aHJvdWdoIGluc3BlY3Rpb24gb2YgdGhlIHN0b3JlIG9iamVjdC5cblx0XHRcblx0XHQvLyBEZXByZWNhdGVkOiBhZGRTdG9yYWdlXG5cdFx0YWRkU3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0X3dhcm4oJ3N0b3JlLmFkZFN0b3JhZ2Uoc3RvcmFnZSkgaXMgZGVwcmVjYXRlZC4gVXNlIGNyZWF0ZVN0b3JlKFtzdG9yYWdlc10pJylcblx0XHRcdHRoaXMuX2FkZFN0b3JhZ2Uoc3RvcmFnZSlcblx0XHR9XG5cdH1cblxuXHR2YXIgc3RvcmUgPSBjcmVhdGUoX3ByaXZhdGVTdG9yZVByb3BzLCBzdG9yZUFQSSwge1xuXHRcdHBsdWdpbnM6IFtdXG5cdH0pXG5cdHN0b3JlLnJhdyA9IHt9XG5cdGVhY2goc3RvcmUsIGZ1bmN0aW9uKHByb3AsIHByb3BOYW1lKSB7XG5cdFx0aWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcblx0XHRcdHN0b3JlLnJhd1twcm9wTmFtZV0gPSBiaW5kKHN0b3JlLCBwcm9wKVx0XHRcdFxuXHRcdH1cblx0fSlcblx0ZWFjaChzdG9yYWdlcywgZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdHN0b3JlLl9hZGRTdG9yYWdlKHN0b3JhZ2UpXG5cdH0pXG5cdGVhY2gocGx1Z2lucywgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0c3RvcmUuX2FkZFBsdWdpbihwbHVnaW4pXG5cdH0pXG5cdHJldHVybiBzdG9yZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBqc29uMlBsdWdpblxuXG5mdW5jdGlvbiBqc29uMlBsdWdpbigpIHtcblx0cmVxdWlyZSgnLi9saWIvanNvbjInKVxuXHRyZXR1cm4ge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuXHQvLyBMaXN0ZWQgaW4gb3JkZXIgb2YgdXNhZ2UgcHJlZmVyZW5jZVxuXHRyZXF1aXJlKCcuL2xvY2FsU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL29sZEZGLWdsb2JhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRJRS11c2VyRGF0YVN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9jb29raWVTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vc2Vzc2lvblN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9tZW1vcnlTdG9yYWdlJylcbl1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW5kZXgnKSxcbiAgICBmZXRjaFRleHQgPSBfcmVxdWlyZS5mZXRjaFRleHQsXG4gICAgZ2V0TWVzc2FnZUNvbnNlbnQgPSBfcmVxdWlyZS5nZXRNZXNzYWdlQ29uc2VudDtcblxudmFyIGRpZEpXVCA9IHJlcXVpcmUoJ2RpZC1qd3QnKTtcblxudmFyIGV0aGVycyA9IHJlcXVpcmUoJ2V0aGVycycpO1xuXG5yZXF1aXJlKCdodHRwcy1kaWQtcmVzb2x2ZXInKVtcImRlZmF1bHRcIl0oKTtcblxucmVxdWlyZSgnbXVwb3J0LWRpZC1yZXNvbHZlcicpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgZ2lzdCBjb250YWlucyB0aGUgZ2l2ZW4gbXVwb3J0RElEIGFuZCByZXR1cm5zIHRoZSB1c2VycyBnaXRodWIgdXNlcm5hbWUuXG4gICAqIFRocm93cyBhbiBlcnJvciBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBkaWQgICAgICAgICAgICAgICAgICAgICBUaGUgbXVwb3J0IERJRCBvZiB0aGUgdXNlclxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgZ2lzdFVybCAgICAgICAgICAgICAgICAgVVJMIG9mIHRoZSBwcm9vZlxuICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdXNlcm5hbWUsIGFuZCBwcm9vZlxuICAgKi9cbiAgdmVyaWZ5R2l0aHViOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlHaXRodWIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRpZCwgZ2lzdFVybCkge1xuICAgICAgdmFyIGdpc3RGaWxlQ29udGVudCwgdXNlcm5hbWU7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISghZ2lzdFVybCB8fCBnaXN0VXJsLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hUZXh0KGdpc3RVcmwpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGdpc3RGaWxlQ29udGVudCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEoZ2lzdEZpbGVDb250ZW50LmluZGV4T2YoZGlkKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpc3QgRmlsZSBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIHRoZSBjb3JyZWN0IERJRCBvZiB0aGUgdXNlcicpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHVzZXJuYW1lID0gZ2lzdFVybC5zcGxpdCgnLycpWzNdO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGdpc3RVcmxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeUdpdGh1YihfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeUdpdGh1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZnlHaXRodWI7XG4gIH0oKSxcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgdHdlZXQgY29udGFpbnMgdGhlIGdpdmVuIG11cG9ydERJRCBhbmQgcmV0dXJucyB0aGUgdXNlcnMgdHdpdHRlciB1c2VybmFtZS5cbiAgICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIGRpZCAgICAgICAgICAgICBUaGUgbXVwb3J0IERJRCBvZiB0aGUgdXNlclxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgY2xhaW0gICAgICAgICAgIEEgZGlkLUpXVCB3aXRoIGNsYWltXG4gICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdXNlcm5hbWUsIHByb29mLCBhbmQgdGhlIHZlcmlmaWVyXG4gICAqL1xuICB2ZXJpZnlUd2l0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlUd2l0dGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGlkLCBjbGFpbSkge1xuICAgICAgdmFyIHZlcmlmaWVkLCBjbGFpbURhdGE7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKGNsYWltKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZGlkSldULnZlcmlmeUpXVChjbGFpbSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdmVyaWZpZWQgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoISh2ZXJpZmllZC5wYXlsb2FkLnN1YiAhPT0gZGlkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVyaWZpY2F0aW9uIG5vdCB2YWxpZCBmb3IgZ2l2ZW4gdXNlcicpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNsYWltRGF0YSA9IHZlcmlmaWVkLnBheWxvYWQuY2xhaW07XG5cbiAgICAgICAgICAgICAgaWYgKCEoIWNsYWltRGF0YS50d2l0dGVyX2hhbmRsZSB8fCAhY2xhaW1EYXRhLnR3aXR0ZXJfcHJvb2YpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsYWltIGZvciB5b3VyIHR3aXR0ZXIgaXMgbm90IGNvcnJlY3QnKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBjbGFpbURhdGEudHdpdHRlcl9oYW5kbGUsXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGNsYWltRGF0YS50d2l0dGVyX3Byb29mLFxuICAgICAgICAgICAgICAgIHZlcmlmaWVkQnk6IHZlcmlmaWVkLnBheWxvYWQuaXNzXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlUd2l0dGVyKF94MywgX3g0KSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeVR3aXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5VHdpdHRlcjtcbiAgfSgpLFxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjb2RlIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgdGhlIHNhbWUgb25lIHRoYXQgd2FzIHNlbnQgdmlhIGVtYWlsLlxuICAgKiBUaHJvd3MgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgZGlkICAgICAgICAgICAgIFRoZSBtdXBvcnQgRElEIG9mIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBjbGFpbSAgICAgICAgICAgQSBkaWQtSldUIHdpdGggY2xhaW1cbiAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICovXG4gIHZlcmlmeUVtYWlsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlFbWFpbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGRpZCwgY2xhaW0pIHtcbiAgICAgIHZhciB2ZXJpZmllZCwgY2xhaW1EYXRhO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmIChjbGFpbSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZEpXVC52ZXJpZnlKV1QoY2xhaW0pO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHZlcmlmaWVkID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEodmVyaWZpZWQucGF5bG9hZC5zdWIgIT09IGRpZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcmlmaWNhdGlvbiBub3QgdmFsaWQgZm9yIGdpdmVuIHVzZXInKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjbGFpbURhdGEgPSB2ZXJpZmllZC5wYXlsb2FkLmNsYWltO1xuXG4gICAgICAgICAgICAgIGlmIChjbGFpbURhdGEuZW1haWxfYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGFpbSBmb3IgeW91ciBlbWFpbCBhZGRyZXNzIGlzIG5vdCBjb3JyZWN0Jyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBlbWFpbF9hZGRyZXNzOiBjbGFpbURhdGEuZW1haWxfYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB2ZXJpZmllZEJ5OiB2ZXJpZmllZC5wYXlsb2FkLmlzc1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdmVyaWZ5RW1haWwoX3g1LCBfeDYpIHtcbiAgICAgIHJldHVybiBfdmVyaWZ5RW1haWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5RW1haWw7XG4gIH0oKSxcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgcHJvb2YgZm9yIGEgZGlkIGlzIGNvcnJlY3RcbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIGNsYWltICAgICAgICAgICBBIGRpZC1KV1Qgd2l0aCBjbGFpbVxuICAgKiBAcmV0dXJuICAgIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBESUQgb2YgdGhlIHVzZXJcbiAgICovXG4gIHZlcmlmeURJRDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdmVyaWZ5RElEID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoY2xhaW0pIHtcbiAgICAgIHZhciB2ZXJpZmllZDtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBkaWRKV1QudmVyaWZ5SldUKGNsYWltKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB2ZXJpZmllZCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB2ZXJpZmllZC5wYXlsb2FkLmlzcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdmVyaWZ5RElEKF94Nykge1xuICAgICAgcmV0dXJuIF92ZXJpZnlESUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5RElEO1xuICB9KCksXG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgdGhlIHByb29mIGZvciBhbiBldGhlcmV1bSBhZGRyZXNzIGlzIGNvcnJlY3RcbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBldGhQcm9vZiAgICAgICAgICAgICAgICAgICAgICBUaGUgY2xhaW0gZ2VuZXJhdGVkIGJ5IGdldExpbmtDb25zZW50XG4gICAqIEBwYXJhbSAgICAge3N0cmluZ30gICAgZXRoUHJvb2YuY29uc2VudF9tc2dcbiAgICogQHBhcmFtICAgICB7c3RyaW5nfSAgICBldGhQcm9vZi5jb25zZW50X3NpZ25hdHVyZVxuICAgKiBAcGFyYW0gICAgIHtzdHJpbmd9ICAgIGV0aFByb29mLmxpbmtlZF9kaWRcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBkaWQgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYm94JyBkaWRcbiAgICogQHJldHVybiAgICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXRoZXJldW0gYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIG1lc3NhZ2VcbiAgICovXG4gIHZlcmlmeUV0aGVyZXVtOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlFdGhlcmV1bSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGV0aFByb29mLCBkaWQpIHtcbiAgICAgIHZhciBjb25zZW50TXNnLCBjb25zZW50U2lnLCBleHBlY3RlZDtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjb25zZW50TXNnID0gZXRoUHJvb2YudmVyc2lvbiA/IGV0aFByb29mLm1lc3NhZ2UgOiBldGhQcm9vZlsnY29uc2VudF9tc2cnXTtcbiAgICAgICAgICAgICAgY29uc2VudFNpZyA9IGV0aFByb29mLnZlcnNpb24gPyBldGhQcm9vZi5zaWduYXR1cmUgOiBldGhQcm9vZlsnY29uc2VudF9zaWduYXR1cmUnXTsgLy8gTWFrZSBzdXJlIHRoZSBtZXNzYWdlIG1hdGNoZXMgb3VyIGV4cGVjdGF0aW9uXG5cbiAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBnZXRNZXNzYWdlQ29uc2VudChkaWQpO1xuXG4gICAgICAgICAgICAgIGlmICghKGNvbnNlbnRNc2cgIT09IGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uc2VudCBtZXNzYWdlLCBnb3Q6IFxcXCJcIi5jb25jYXQoY29uc2VudE1zZywgXCJcXFwiLCBleHBlY3RlZDogXFxcIlwiKS5jb25jYXQoZXhwZWN0ZWQsIFwiXFxcIlwiKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZXRoZXJzLnV0aWxzLnZlcmlmeU1lc3NhZ2UoY29uc2VudE1zZywgY29uc2VudFNpZykpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeUV0aGVyZXVtKF94OCwgX3g5KSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeUV0aGVyZXVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcmlmeUV0aGVyZXVtO1xuICB9KClcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIHR5cGVzXzIgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuQ2xpZW50RXJyb3IgPSB0eXBlc18yLkNsaWVudEVycm9yO1xucmVxdWlyZShcImNyb3NzLWZldGNoL3BvbHlmaWxsXCIpO1xudmFyIEdyYXBoUUxDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhRTENsaWVudCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIEdyYXBoUUxDbGllbnQucHJvdG90eXBlLnJhd1JlcXVlc3QgPSBmdW5jdGlvbiAocXVlcnksIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGhlYWRlcnMsIG90aGVycywgYm9keSwgcmVzcG9uc2UsIHJlc3VsdCwgaGVhZGVyc18xLCBzdGF0dXNfMSwgZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMub3B0aW9ucywgaGVhZGVycyA9IF9hLmhlYWRlcnMsIG90aGVycyA9IF9fcmVzdChfYSwgW1wiaGVhZGVyc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyA/IHZhcmlhYmxlcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2godGhpcy51cmwsIF9fYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sIGhlYWRlcnMpLCBib2R5OiBib2R5IH0sIG90aGVycykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRSZXN1bHQocmVzcG9uc2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmICFyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc18xID0gcmVzcG9uc2UuaGVhZGVycywgc3RhdHVzXzEgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKHt9LCByZXN1bHQsIHsgaGVhZGVyczogaGVhZGVyc18xLCBzdGF0dXM6IHN0YXR1c18xIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVzdWx0ID0gdHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgPyB7IGVycm9yOiByZXN1bHQgfSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5DbGllbnRFcnJvcihfX2Fzc2lnbih7fSwgZXJyb3JSZXN1bHQsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMgfSksIHsgcXVlcnk6IHF1ZXJ5LCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaFFMQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBoZWFkZXJzLCBvdGhlcnMsIGJvZHksIHJlc3BvbnNlLCByZXN1bHQsIGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLm9wdGlvbnMsIGhlYWRlcnMgPSBfYS5oZWFkZXJzLCBvdGhlcnMgPSBfX3Jlc3QoX2EsIFtcImhlYWRlcnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMgPyB2YXJpYWJsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHRoaXMudXJsLCBfX2Fzc2lnbih7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCBoZWFkZXJzKSwgYm9keTogYm9keSB9LCBvdGhlcnMpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0UmVzdWx0KHJlc3BvbnNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAhcmVzdWx0LmVycm9ycyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnID8geyBlcnJvcjogcmVzdWx0IH0gOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuQ2xpZW50RXJyb3IoX19hc3NpZ24oe30sIGVycm9yUmVzdWx0LCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH0pLCB7IHF1ZXJ5OiBxdWVyeSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhRTENsaWVudC5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHcmFwaFFMQ2xpZW50LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMub3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVycyA9IChfYSA9IHt9LCBfYVtrZXldID0gdmFsdWUsIF9hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoUUxDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFFMQ2xpZW50ID0gR3JhcGhRTENsaWVudDtcbmZ1bmN0aW9uIHJhd1JlcXVlc3QodXJsLCBxdWVyeSwgdmFyaWFibGVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpZW50O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNsaWVudC5yYXdSZXF1ZXN0KHF1ZXJ5LCB2YXJpYWJsZXMpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJhd1JlcXVlc3QgPSByYXdSZXF1ZXN0O1xuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KHVybCk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpZW50LnJlcXVlc3QocXVlcnksIHZhcmlhYmxlcyldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0O1xuZnVuY3Rpb24gZ2V0UmVzdWx0KHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlLnRleHQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBtdWx0aWhhc2ggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcblxuY29uc3Qgbm90RW1wdHkgPSBlID0+IGUgIT09ICcnICYmIGUgIT09ICcgJ1xuXG5jbGFzcyBPcmJpdERCQWRkcmVzcyB7XG4gIGNvbnN0cnVjdG9yIChyb290LCBwYXRoKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdFxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKCcvb3JiaXRkYicsIHRoaXMucm9vdCwgdGhpcy5wYXRoKVxuICB9XG5cbiAgc3RhdGljIGlzVmFsaWQgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjb250YWluc1Byb3RvY29sUHJlZml4ID0gKGUsIGkpID0+ICEoKGkgPT09IDAgfHwgaSA9PT0gMSkgJiYgYWRkcmVzcy50b1N0cmluZygpLmluZGV4T2YoJy9vcmJpdCcpID09PSAwICYmIGUgPT09ICdvcmJpdGRiJylcblxuICAgIGNvbnN0IHBhcnRzID0gYWRkcmVzcy50b1N0cmluZygpXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLmZpbHRlcihjb250YWluc1Byb3RvY29sUHJlZml4KVxuICAgICAgLmZpbHRlcihub3RFbXB0eSlcblxuICAgIGxldCBhY2Nlc3NDb250cm9sbGVySGFzaFxuXG4gICAgdHJ5IHtcbiAgICAgIGFjY2Vzc0NvbnRyb2xsZXJIYXNoID0gKHBhcnRzWzBdLmluZGV4T2YoJ3pkJykgPiAtMSB8fCBwYXJ0c1swXS5pbmRleE9mKCdRbScpID4gLTEpXG4gICAgICAgID8gbmV3IENJRChwYXJ0c1swXSkudG9CYXNlRW5jb2RlZFN0cmluZygpXG4gICAgICAgIDogbnVsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiBhY2Nlc3NDb250cm9sbGVySGFzaCAhPT0gbnVsbFxuICB9XG5cbiAgc3RhdGljIHBhcnNlIChhZGRyZXNzKSB7XG4gICAgaWYgKCFhZGRyZXNzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBPcmJpdERCIGFkZHJlc3M6ICR7YWRkcmVzc31gKVxuXG4gICAgaWYgKCFPcmJpdERCQWRkcmVzcy5pc1ZhbGlkKGFkZHJlc3MpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSB2YWxpZCBPcmJpdERCIGFkZHJlc3M6ICR7YWRkcmVzc31gKVxuXG4gICAgY29uc3QgcGFydHMgPSBhZGRyZXNzLnRvU3RyaW5nKClcbiAgICAgIC5zcGxpdCgnLycpXG4gICAgICAuZmlsdGVyKChlLCBpKSA9PiAhKChpID09PSAwIHx8IGkgPT09IDEpICYmIGFkZHJlc3MudG9TdHJpbmcoKS5pbmRleE9mKCcvb3JiaXQnKSA9PT0gMCAmJiBlID09PSAnb3JiaXRkYicpKVxuICAgICAgLmZpbHRlcihlID0+IGUgIT09ICcnICYmIGUgIT09ICcgJylcblxuICAgIHJldHVybiBuZXcgT3JiaXREQkFkZHJlc3MocGFydHNbMF0sIHBhcnRzLnNsaWNlKDEsIHBhcnRzLmxlbmd0aCkuam9pbignLycpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3JiaXREQkFkZHJlc3NcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgaXNJUEZTID0gcmVxdWlyZSgnaXMtaXBmcycpO1xuXG52YXIgQVBJID0gcmVxdWlyZSgnLi9hcGknKTtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBPUkJJVERCX09QVFMgPSBjb25maWcub3JiaXRkYl9vcHRpb25zO1xudmFyIE1PREVSQVRPUiA9ICdNT0RFUkFUT1InO1xudmFyIE1FTUJFUiA9ICdNRU1CRVInO1xuXG52YXIgaXNWYWxpZDNJRCA9IGZ1bmN0aW9uIGlzVmFsaWQzSUQoZGlkKSB7XG4gIHZhciBwYXJ0cyA9IGRpZC5zcGxpdCgnOicpO1xuICBpZiAoIXBhcnRzWzBdID09PSAnZGlkJyB8fCAhcGFydHNbMV0gPT09ICczJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNJUEZTLmNpZChwYXJ0c1syXSk7XG59O1xuXG52YXIgVGhyZWFkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFBsZWFzZSB1c2UgKipzcGFjZS5qb2luVGhyZWFkKiogdG8gZ2V0IHRoZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBUaHJlYWQob3JiaXRkYiwgbmFtZSwgdGhyZWVJZCwgbWVtYmVycywgZmlyc3RNb2RlcmF0b3IsIHN1YnNjcmliZSwgZW5zdXJlQ29ubmVjdGVkKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBUaHJlYWQpO1xuICAgIHRoaXMuX29yYml0ZGIgPSBvcmJpdGRiO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX3NwYWNlTmFtZSA9IG5hbWUuc3BsaXQoJy4nKVsyXTtcbiAgICB0aGlzLl8zaWQgPSB0aHJlZUlkO1xuICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICB0aGlzLl9lbnN1cmVDb25uZWN0ZWQgPSBlbnN1cmVDb25uZWN0ZWQ7XG4gICAgdGhpcy5fcXVldWVkTmV3UG9zdHMgPSBbXTtcbiAgICB0aGlzLl9tZW1iZXJzID0gQm9vbGVhbihtZW1iZXJzKTtcbiAgICB0aGlzLl9maXJzdE1vZGVyYXRvciA9IGZpcnN0TW9kZXJhdG9yIHx8IHRoaXMuXzNpZC5nZXRTdWJESUQodGhpcy5fc3BhY2VOYW1lKTtcbiAgfVxuICAvKipcbiAgICogUG9zdCBhIG1lc3NhZ2UgdG8gdGhlIHRocmVhZFxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG1lc3NhZ2UgICAgICAgICAgICAgICAgIFRoZSBtZXNzYWdlXG4gICAqIEByZXR1cm4gICAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHBvc3RJZCBvZiB0aGUgbmV3IHBvc3RcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFRocmVhZCwgW3tcbiAgICBrZXk6IFwicG9zdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Bvc3QgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXA7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSh0aGlzLl9hZGRyZXNzLCB7XG4gICAgICAgICAgICAgICAgICBmaXJzdE1vZGVyYXRvcjogdGhpcy5fZmlyc3RNb2RlcmF0b3IsXG4gICAgICAgICAgICAgICAgICBtZW1iZXJzOiB0aGlzLl9tZW1iZXJzLFxuICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKHRoaXMuX2FkZHJlc3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApOyAvLyBzZWNvbmRzXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmFkZCh7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwb3N0KF94KSB7XG4gICAgICAgIHJldHVybiBfcG9zdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VGhyZWFkQWRkcmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRocmVhZEFkZHJlc3MyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgYWRkcmVzcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0Q29uZmlncygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yYml0ZGIuX2RldGVybWluZUFkZHJlc3ModGhpcy5fbmFtZSwgJ2ZlZWQnLCB7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NDb250cm9sbGVyOiB0aGlzLl9hY2Nlc3NDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2NvbnRleHQyLnNlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLl9hZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2dldFRocmVhZEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0VGhyZWFkQWRkcmVzczIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRUaHJlYWRBZGRyZXNzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1vZGVyYXRvciB0byB0aGlzIHRocmVhZCwgdGhyb3dzIGVycm9yIGlzIHVzZXIgY2FuIG5vdCBhZGQgYSBtb2RlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgaWQgICAgICAgICAgICAgICAgICAgICAgTW9kZXJhdG9yIElkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRNb2RlcmF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRNb2RlcmF0b3IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghaWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBBUEkuZ2V0U3BhY2VESUQoaWQsIHRoaXMuX3NwYWNlTmFtZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlkID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkM0lEKGlkKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRNb2RlcmF0b3I6IG11c3QgcHJvdmlkZSB2YWxpZCAzSUQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZGIuYWNjZXNzLmdyYW50KE1PREVSQVRPUiwgaWQpKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWRkTW9kZXJhdG9yKF94Mikge1xuICAgICAgICByZXR1cm4gX2FkZE1vZGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkTW9kZXJhdG9yO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIExpc3QgbW9kZXJhdG9yc1xuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXk8U3RyaW5nPn0gICAgICBBcnJheSBvZiBtb2RlcmF0b3IgRElEc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdE1vZGVyYXRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saXN0TW9kZXJhdG9ycyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmFjY2Vzcy5jYXBhYmlsaXRpZXNbJ21vZGVyYXRvcnMnXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RNb2RlcmF0b3JzKCkge1xuICAgICAgICByZXR1cm4gX2xpc3RNb2RlcmF0b3JzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0TW9kZXJhdG9ycztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBBZGQgYSBtZW1iZXIgdG8gdGhpcyB0aHJlYWQsIHRocm93cyBpZiB1c2VyIGNhbiBub3QgYWRkIG1lbWJlciwgdGhyb3cgaXMgbm90IG1lbWJlciB0aHJlYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgaWQgICAgICAgICAgICAgICAgICAgICAgTWVtYmVyIElkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRNZW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRNZW1iZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93SWZOb3RNZW1iZXJzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQVBJLmdldFNwYWNlRElEKGlkLCB0aGlzLl9zcGFjZU5hbWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZCA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZDNJRChpZCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkTW9kZXJhdG9yOiBtdXN0IHByb3ZpZGUgdmFsaWQgM0lEJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93SWZOb3RNZW1iZXJzKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hY2Nlc3MuZ3JhbnQoTUVNQkVSLCBpZCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWVtYmVyKF94Mykge1xuICAgICAgICByZXR1cm4gX2FkZE1lbWJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkTWVtYmVyO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIExpc3QgbWVtYmVycywgdGhyb3dzIGlmIG5vdCBtZW1iZXIgdGhyZWFkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxTdHJpbmc+fSAgICAgIEFycmF5IG9mIG1lbWJlciBESURzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0TWVtYmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xpc3RNZW1iZXJzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0lmTm90TWVtYmVycygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmFjY2Vzcy5jYXBhYmlsaXRpZXNbJ21lbWJlcnMnXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RNZW1iZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xpc3RNZW1iZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0TWVtYmVycztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfdGhyb3dJZk5vdE1lbWJlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZOb3RNZW1iZXJzKCkge1xuICAgICAgaWYgKCF0aGlzLl9tZW1iZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ1RocmVhZDogTm90IGEgbWVtYmVycyBvbmx5IHRocmVhZCwgZnVuY3Rpb24gbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgcG9zdFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBpZCAgICAgICAgICAgICAgICAgICAgICBNb2RlcmF0b3IgSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVBvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9kZWxldGVQb3N0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLnJlbW92ZShoYXNoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZVBvc3QoX3g0KSB7XG4gICAgICAgIHJldHVybiBfZGVsZXRlUG9zdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZXRlUG9zdDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBvc3RzLCBiYXNlZCBvbiB0aGUgb3B0aW9ucy5cbiAgICAgKiBJZiBoYXNoIG5vdCBmb3VuZCB3aGVuIHBhc3NpbmcgZ3QsIGd0ZSwgbHQsIG9yIGx0ZSxcbiAgICAgKiB0aGUgaXRlcmF0b3Igd2lsbCByZXR1cm4gYWxsIGl0ZW1zIChyZXNwZWN0aW5nIGxpbWl0IGFuZCByZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5ndCAgICAgICAgICAgICAgICAgR3JlYXRlciB0aGFuLCB0YWtlcyBhbiBwb3N0SWRcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZ3RlICAgICAgICAgICAgICAgIEdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bywgdGFrZXMgYW4gcG9zdElkXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLmx0ICAgICAgICAgICAgICAgICBMZXNzIHRoYW4sIHRha2VzIGFuIHBvc3RJZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5sdGUgICAgICAgICAgICAgICAgTGVzcyB0aGFuIG9yIGVxdWFsIHRvLCB0YWtlcyBhbiBwb3N0SWRcbiAgICAgKiBAcGFyYW0gICAgIHtJbnRlZ2VyfSAgIG9wdHMubGltaXQgICAgICAgICAgICAgIExpbWl0aW5nIHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiByZXN1bHQsIGRlZmF1bHRzIHRvIC0xIChubyBsaW1pdClcbiAgICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMucmV2ZXJzZSAgICAgICAgICAgIElmIHNldCB0byB0cnVlIHdpbGwgcmVzdWx0IGluIHJldmVyc2luZyB0aGUgcmVzdWx0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3Q+fSAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgaWYgc3VjY2Vzc2Z1bFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQb3N0cyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczgubGVuZ3RoID4gMCAmJiBfYXJnczhbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFswXSA6IHt9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3B0cy5saW1pdCkgb3B0cy5saW1pdCA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLml0ZXJhdG9yKG9wdHMpLmNvbGxlY3QoKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcG9zdCA9IGVudHJ5LnBheWxvYWQudmFsdWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbWV0YURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RJZDogZW50cnkuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiBlbnRyeS5pZGVudGl0eS5pZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG1ldGFEYXRhLCBwb3N0KTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBvc3RzKCkge1xuICAgICAgICByZXR1cm4gX2dldFBvc3RzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQb3N0cztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBuZXcgdXBkYXRlc1xuICAgICAqIGhhdmUgYmVlbiByZWNlaXZlZCBmcm9tIHRoZSBuZXR3b3JrIG9yIGxvY2FsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIHVwZGF0ZUZuICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29uVXBkYXRlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KHVwZGF0ZUZuKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYi5ldmVudHMub24oJ3JlcGxpY2F0ZWQnLCBmdW5jdGlvbiAoYWRkcmVzcywgaGFzaCwgZW50cnksIHByb2csIHRvdCkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RiLmV2ZW50cy5vbignd3JpdGUnLCBmdW5jdGlvbiAoZGJuYW1lLCBlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gb25VcGRhdGUoX3g1KSB7XG4gICAgICAgIHJldHVybiBfb25VcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9uVXBkYXRlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBldmVyeSBuZXdcbiAgICAgKiBjYXBhYmlsaXR5IHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRocmVhZCBhY2Nlc3MgY29udHJvbGxlci5cbiAgICAgKiBUaGlzIGlubGN1ZGVzIHdoZW4gYSBtb2RlcmF0b3Igb3IgbWVtYmVyIGlzIGFkZGVkLlxuICAgICAqIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyLCB3aGljaCBpcyB0aGUgY2FwYWJpbGl0aWVzIG9iaiwgb3JcbiAgICAgKiB5b3UgY2FuIGNhbGwgbGlzdE1vZGVyYXRvciAvIGxpc3RNZW1iZXJzIGFnYWluIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIHVwZGF0ZUZuICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uTmV3Q2FwYWJpbGl0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb25OZXdDYXBhYmlsaXRpZXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHVwZGF0ZUZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX2RiLmFjY2Vzcy5vbigndXBkYXRlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlRm4oX3RoaXMuX2RiLmFjY2Vzcy5jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uTmV3Q2FwYWJpbGl0aWVzKF94Nikge1xuICAgICAgICByZXR1cm4gX29uTmV3Q2FwYWJpbGl0aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvbk5ld0NhcGFiaWxpdGllcztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShvZGJBZGRyZXNzKSB7XG4gICAgICAgIHZhciBpZGVudGl0eTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRDb25maWdzKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlkZW50aXR5ID0gdGhpcy5faWRlbnRpdHk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JiaXRkYi5mZWVkKG9kYkFkZHJlc3MgfHwgdGhpcy5fbmFtZSwgX29iamVjdFNwcmVhZCh7fSwgT1JCSVREQl9PUFRTLCB7XG4gICAgICAgICAgICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICBhY2Nlc3NDb250cm9sbGVyOiB0aGlzLl9hY2Nlc3NDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLl9kYiA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYi5sb2FkKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZHJlc3MgPSB0aGlzLl9kYi5hZGRyZXNzLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVDb25uZWN0ZWQodGhpcy5fYWRkcmVzcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9sb2FkKF94Nykge1xuICAgICAgICByZXR1cm4gX2xvYWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbG9hZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWlyZUxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVpcmVMb2FkKCkge1xuICAgICAgaWYgKCF0aGlzLl9kYikgdGhyb3cgbmV3IEVycm9yKCdfbG9hZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc3RvcmUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDEyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGIuY2xvc2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRDb25maWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaW5pdENvbmZpZ3MyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMygpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5nZXRPZGJJZCh0aGlzLl9zcGFjZU5hbWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eSA9IF9jb250ZXh0MTMuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmlyc3RNb2RlcmF0b3Iuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRTcGFjZURJRCh0aGlzLl9maXJzdE1vZGVyYXRvciwgdGhpcy5fc3BhY2VOYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyc3RNb2RlcmF0b3IgPSBfY29udGV4dDEzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjY2Vzc0NvbnRyb2xsZXIgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGhyZWFkLWFjY2VzcycsXG4gICAgICAgICAgICAgICAgICB0aHJlYWROYW1lOiB0aGlzLl9uYW1lLFxuICAgICAgICAgICAgICAgICAgbWVtYmVyczogdGhpcy5fbWVtYmVycyxcbiAgICAgICAgICAgICAgICAgIGZpcnN0TW9kZXJhdG9yOiB0aGlzLl9maXJzdE1vZGVyYXRvcixcbiAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLl9pZGVudGl0eVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9pbml0Q29uZmlncygpIHtcbiAgICAgICAgcmV0dXJuIF9pbml0Q29uZmlnczIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9pbml0Q29uZmlncztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJhZGRyZXNzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGIgPyB0aGlzLl9hZGRyZXNzIDogbnVsbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRocmVhZDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWQ7IiwiIWZ1bmN0aW9uKGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLmV0aGVycz1lKCl9KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIG8ocyxhLHUpe2Z1bmN0aW9uIGwodCxlKXtpZighYVt0XSl7aWYoIXNbdF0pe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWUmJnIpcmV0dXJuIHIodCwhMCk7aWYoaClyZXR1cm4gaCh0LCEwKTt2YXIgbj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3QrXCInXCIpO3Rocm93IG4uY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixufXZhciBpPWFbdF09e2V4cG9ydHM6e319O3NbdF1bMF0uY2FsbChpLmV4cG9ydHMsZnVuY3Rpb24oZSl7cmV0dXJuIGwoc1t0XVsxXVtlXXx8ZSl9LGksaS5leHBvcnRzLG8scyxhLHUpfXJldHVybiBhW3RdLmV4cG9ydHN9Zm9yKHZhciBoPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsZT0wO2U8dS5sZW5ndGg7ZSsrKWwodVtlXSk7cmV0dXJuIGx9KHsxOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci52ZXJzaW9uPVwiNC4wLjQ4XCJ9LHt9XSwyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vdXRpbHMvcHJvcGVydGllc1wiKSxpPShvLmlzU2lnbmVyPWZ1bmN0aW9uKGUpe3JldHVybiBuLmlzVHlwZShlLFwiU2lnbmVyXCIpfSxvKTtmdW5jdGlvbiBvKCl7bi5zZXRUeXBlKHRoaXMsXCJTaWduZXJcIil9ci5TaWduZXI9aX0se1wiLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSwzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vdXRpbHMvYmlnbnVtYmVyXCIpO3IuQWRkcmVzc1plcm89XCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtyLkhhc2haZXJvPVwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7ci5FdGhlclN5bWJvbD1cIlxcdTAzOWVcIjt2YXIgaT1uLmJpZ051bWJlcmlmeSgtMSk7ci5OZWdhdGl2ZU9uZT1pO3ZhciBvPW4uYmlnTnVtYmVyaWZ5KDApO3IuWmVybz1vO3ZhciBzPW4uYmlnTnVtYmVyaWZ5KDEpO3IuT25lPXM7dmFyIGE9bi5iaWdOdW1iZXJpZnkoMik7ci5Ud289YTt2YXIgdT1uLmJpZ051bWJlcmlmeShcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIik7ci5XZWlQZXJFdGhlcj11O3ZhciBsPW4uYmlnTnVtYmVyaWZ5KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO3IuTWF4VWludDI1Nj1sfSx7XCIuL3V0aWxzL2JpZ251bWJlclwiOjYzfV0sNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyx1PWUoXCIuL2NvbnN0YW50c1wiKSxsPW8oZShcIi4vZXJyb3JzXCIpKSxoPWUoXCIuL3V0aWxzL2FiaS1jb2RlclwiKSxhPWUoXCIuL3V0aWxzL2FkZHJlc3NcIiksZj1lKFwiLi91dGlscy9iaWdudW1iZXJcIiksYz1lKFwiLi91dGlscy9ieXRlc1wiKSxkPWUoXCIuL3V0aWxzL2ludGVyZmFjZVwiKSxwPWUoXCIuL3V0aWxzL3Byb3BlcnRpZXNcIiksdj1lKFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIikseT1lKFwiLi9hYnN0cmFjdC1zaWduZXJcIiksbT0ocz15LlNpZ25lcixpKGcscyksZy5wcm90b3R5cGUuZ2V0QWRkcmVzcz1mdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKX0sZy5wcm90b3R5cGUuX2ZhaWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe2wudGhyb3dFcnJvcihlLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246dH0pfSl9LGcucHJvdG90eXBlLnNpZ25NZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLFwic2lnbk1lc3NhZ2VcIil9LGcucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsXCJzZW5kVHJhbnNhY3Rpb25cIil9LGcucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBnKHRoaXMuYWRkcmVzcyxlKX0sZyk7ZnVuY3Rpb24gZyhlLHQpe3ZhciByPXMuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gcC5kZWZpbmVSZWFkT25seShyLFwiYWRkcmVzc1wiLGUpLHAuZGVmaW5lUmVhZE9ubHkocixcInByb3ZpZGVyXCIsdCkscn1yLlZvaWRTaWduZXI9bTt2YXIgYj17Y2hhaW5JZDohMCxkYXRhOiEwLGZyb206ITAsZ2FzTGltaXQ6ITAsZ2FzUHJpY2U6ITAsbm9uY2U6ITAsdG86ITAsdmFsdWU6ITB9O2Z1bmN0aW9uIHcobyxlLHMpe3ZhciBhPW8uaW50ZXJmYWNlLmZ1bmN0aW9uc1tlXTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dmFyIGk9e30scj1udWxsO2lmKGUubGVuZ3RoPT09YS5pbnB1dHMubGVuZ3RoKzEmJlwib2JqZWN0XCI9PXR5cGVvZiBlW2UubGVuZ3RoLTFdKWZvcih2YXIgbiBpbiBudWxsIT0oaT1wLnNoYWxsb3dDb3B5KGUucG9wKCkpKS5ibG9ja1RhZyYmKHI9aS5ibG9ja1RhZyksZGVsZXRlIGkuYmxvY2tUYWcsaSlpZighYltuXSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiK24pO2lmKGUubGVuZ3RoIT1hLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIik7cmV0dXJuW1wiZGF0YVwiLFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbihlKXtudWxsIT1pW2VdJiZsLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIrZSxsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOmV9KX0pLGkudG89by5fZGVwbG95ZWQocikudGhlbihmdW5jdGlvbigpe3JldHVybiBvLmFkZHJlc3NQcm9taXNlfSksZnVuY3Rpb24gbihpLG8sZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIHM9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciByPW51bGwscj1BcnJheS5pc0FycmF5KG8pP29bdF06b1tlLm5hbWVdO3MucHVzaChuKGkscixlKSl9KSxQcm9taXNlLmFsbChzKX1pZihcImFkZHJlc3NcIj09PWUudHlwZSlyZXR1cm4gaS5yZXNvbHZlTmFtZShvKTtpZihcInR1cGxlXCI9PT1lLnR5cGUpcmV0dXJuIG4oaSxvLGUuY29tcG9uZW50cyk7dmFyIHQ9ZS50eXBlLm1hdGNoKC8oLiopKFxcW1swLTldKlxcXSQpLyk7aWYodCl7aWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIik7dmFyIHI9W10sYT17Y29tcG9uZW50czplLmNvbXBvbmVudHMsdHlwZTp0WzFdfTtyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IucHVzaChuKGksZSxhKSl9KSxQcm9taXNlLmFsbChyKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8pfShvLnByb3ZpZGVyLGUsYS5pbnB1dHMpLnRoZW4oZnVuY3Rpb24obil7aWYoaS5kYXRhPWEuZW5jb2RlKG4pLFwiY2FsbFwiPT09YS50eXBlKXJldHVybiBzP1Byb21pc2UucmVzb2x2ZSh1Llplcm8pOihvLnByb3ZpZGVyfHxsLnRocm93RXJyb3IoXCJjYWxsIChjb25zdGFudCBmdW5jdGlvbnMpIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiY2FsbFwifSksW1wiZ2FzTGltaXRcIixcImdhc1ByaWNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKG51bGwhPWlbZV0pdGhyb3cgbmV3IEVycm9yKFwiY2FsbCBjYW5ub3Qgb3ZlcnJpZGUgXCIrZSl9KSxudWxsPT1pLmZyb20mJm8uc2lnbmVyJiYoaS5mcm9tPW8uc2lnbmVyLmdldEFkZHJlc3MoKSksby5wcm92aWRlci5jYWxsKGkscikudGhlbihmdW5jdGlvbih0KXt2YXIgZTtjLmhleERhdGFMZW5ndGgodCklMzI9PTQmJlwiMHgwOGMzNzlhMFwiPT09Yy5oZXhEYXRhU2xpY2UodCwwLDQpJiYoZT1oLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLGMuaGV4RGF0YVNsaWNlKHQsNCkpLGwudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiLGwuQ0FMTF9FWENFUFRJT04se2FkZHJlc3M6by5hZGRyZXNzLGFyZ3M6bixtZXRob2Q6YS5zaWduYXR1cmUsZXJyb3JTaWduYXR1cmU6XCJFcnJvcihzdHJpbmcpXCIsZXJyb3JBcmdzOltlXSxyZWFzb246ZSx0cmFuc2FjdGlvbjppfSkpO3RyeXt2YXIgcj1hLmRlY29kZSh0KTtyZXR1cm4gMT09PWEub3V0cHV0cy5sZW5ndGgmJihyPXJbMF0pLHJ9Y2F0Y2goZSl7dGhyb3dcIjB4XCI9PT10JiYwPGEub3V0cHV0cy5sZW5ndGgmJmwudGhyb3dFcnJvcihcImNhbGwgZXhjZXB0aW9uXCIsbC5DQUxMX0VYQ0VQVElPTix7YWRkcmVzczpvLmFkZHJlc3MsbWV0aG9kOmEuc2lnbmF0dXJlLGFyZ3M6bn0pLGV9fSkpO2lmKFwidHJhbnNhY3Rpb25cIj09PWEudHlwZSlyZXR1cm4gcz8oby5wcm92aWRlcnx8bC50aHJvd0Vycm9yKFwiZXN0aW1hdGUgZ2FzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZXN0aW1hdGVHYXNcIn0pLG51bGw9PWkuZnJvbSYmby5zaWduZXImJihpLmZyb209by5zaWduZXIuZ2V0QWRkcmVzcygpKSxvLnByb3ZpZGVyLmVzdGltYXRlR2FzKGkpKToobnVsbD09aS5nYXNMaW1pdCYmbnVsbCE9YS5nYXMmJihpLmdhc0xpbWl0PWYuYmlnTnVtYmVyaWZ5KGEuZ2FzKS5hZGQoMjFlMykpLG8uc2lnbmVyfHxsLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uXCJ9KSxudWxsIT1pLmZyb20mJmwudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBmcm9tIGluIGEgdHJhbnNhY3Rpb25cIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uXCJ9KSxvLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24oaSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLndhaXQuYmluZChlKTtyZXR1cm4gZS53YWl0PWZ1bmN0aW9uKGUpe3JldHVybiB0KGUpLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIG4uZXZlbnRzPW4ubG9ncy5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9cC5kZWVwQ29weShlKSxyPW8uaW50ZXJmYWNlLnBhcnNlTG9nKGUpO3JldHVybiByJiYodC5hcmdzPXIudmFsdWVzLHQuZGVjb2RlPXIuZGVjb2RlLHQuZXZlbnQ9ci5uYW1lLHQuZXZlbnRTaWduYXR1cmU9ci5zaWduYXR1cmUpLHQucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oKXtyZXR1cm4gby5wcm92aWRlcn0sdC5nZXRCbG9jaz1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldEJsb2NrKG4uYmxvY2tIYXNoKX0sdC5nZXRUcmFuc2FjdGlvbj1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKG4udHJhbnNhY3Rpb25IYXNoKX0sdC5nZXRUcmFuc2FjdGlvblJlY2VpcHQ9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4pfSx0fSksbn0pfSxlfSkpO3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZSAtIFwiK2EudHlwZSl9KX19ZnVuY3Rpb24gXyhlKXtyZXR1cm4hZS5hZGRyZXNzfHxudWxsIT1lLnRvcGljcyYmMCE9PWUudG9waWNzLmxlbmd0aD8oZS5hZGRyZXNzfHxcIipcIikrXCJAXCIrKGUudG9waWNzP2UudG9waWNzLmpvaW4oXCI6XCIpOlwiXCIpOlwiKlwifXZhciBNPShBLnByb3RvdHlwZS5kZXBsb3llZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kZXBsb3llZCgpfSxBLnByb3RvdHlwZS5fZGVwbG95ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlfHwodGhpcy5kZXBsb3lUcmFuc2FjdGlvbj90aGlzLl9kZXBsb3llZFByb21pc2U9dGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbihmdW5jdGlvbigpe3JldHVybiB0fSk6dGhpcy5fZGVwbG95ZWRQcm9taXNlPXRoaXMucHJvdmlkZXIuZ2V0Q29kZSh0aGlzLmFkZHJlc3MsZSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm5cIjB4XCI9PT1lJiZsLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7Y29udHJhY3RBZGRyZXNzOnQuYWRkcmVzcyxvcGVyYXRpb246XCJnZXREZXBsb3llZFwifSksdH0pKSx0aGlzLl9kZXBsb3llZFByb21pc2V9LEEucHJvdG90eXBlLmZhbGxiYWNrPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5zaWduZXJ8fGwudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCJ9KTt2YXIgcj1wLnNoYWxsb3dDb3B5KGV8fHt9KTtyZXR1cm5bXCJmcm9tXCIsXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPXJbZV0mJmwudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIitlLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246ZX0pfSksci50bz10aGlzLmFkZHJlc3NQcm9taXNlLHRoaXMuZGVwbG95ZWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbihyKX0pfSxBLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1uZXcgbShlLHRoaXMucHJvdmlkZXIpKTt2YXIgdD1uZXcgQSh0aGlzLmFkZHJlc3MsdGhpcy5pbnRlcmZhY2UsZSk7cmV0dXJuIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24mJnAuZGVmaW5lUmVhZE9ubHkodCxcImRlcGxveVRyYW5zYWN0aW9uXCIsdGhpcy5kZXBsb3lUcmFuc2FjdGlvbiksdH0sQS5wcm90b3R5cGUuYXR0YWNoPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgQShlLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyfHx0aGlzLnByb3ZpZGVyKX0sQS5pc0luZGV4ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGQuSW50ZXJmYWNlLmlzSW5kZXhlZChlKX0sQS5wcm90b3R5cGUuX2dldEV2ZW50RmlsdGVyPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKFwiKlwiPT09ZSlyZXR1cm57cHJlcGFyZUV2ZW50OmZ1bmN0aW9uKGUpe3ZhciB0PXIuaW50ZXJmYWNlLnBhcnNlTG9nKGUpO3JldHVybiB0JiYoZS5hcmdzPXQudmFsdWVzLGUuZGVjb2RlPXQuZGVjb2RlLGUuZXZlbnQ9dC5uYW1lLGUuZXZlbnRTaWduYXR1cmU9dC5zaWduYXR1cmUpLFtlXX0sZXZlbnRUYWc6XCIqXCIsZmlsdGVyOnthZGRyZXNzOnRoaXMuYWRkcmVzc319Oy0xIT09ZS5pbmRleE9mKFwiKFwiKSYmKGU9aC5mb3JtYXRTaWduYXR1cmUoaC5wYXJzZVNpZ25hdHVyZShcImV2ZW50IFwiK2UpKSk7dmFyIG49dGhpcy5pbnRlcmZhY2UuZXZlbnRzW2VdO258fGwudGhyb3dFcnJvcihcInVua25vd24gZXZlbnQgLSBcIitlLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1uZXQ6XCJldmVudE5hbWVcIix2YWx1ZTplfSk7dmFyIHQ9e2FkZHJlc3M6dGhpcy5hZGRyZXNzLHRvcGljczpbbi50b3BpY119O3JldHVybntwcmVwYXJlRXZlbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWNvZGUoZS5kYXRhLGUudG9waWNzKTtlLmFyZ3M9dDt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KTtyZXR1cm4gci5wdXNoKGUpLHJ9LGV2ZW50Om4sZXZlbnRUYWc6Xyh0KSxmaWx0ZXI6dH19dmFyIGk9e2FkZHJlc3M6dGhpcy5hZGRyZXNzfSxvPW51bGw7aWYoZS50b3BpY3MmJmUudG9waWNzWzBdKWZvcih2YXIgcyBpbiBpLnRvcGljcz1lLnRvcGljcyx0aGlzLmludGVyZmFjZS5ldmVudHMpaWYoLTEhPT1zLmluZGV4T2YoXCIoXCIpKXt2YXIgYT10aGlzLmludGVyZmFjZS5ldmVudHNbc107aWYoYS50b3BpYz09PWUudG9waWNzWzBdLnRvTG93ZXJDYXNlKCkpe289YTticmVha319cmV0dXJue3ByZXBhcmVFdmVudDpmdW5jdGlvbihlKXtpZighbylyZXR1cm5bZV07dmFyIHQ9by5kZWNvZGUoZS5kYXRhLGUudG9waWNzKTtlLmFyZ3M9dDt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KTtyZXR1cm4gci5wdXNoKGUpLHJ9LGV2ZW50Om8sZXZlbnRUYWc6XyhpKSxmaWx0ZXI6aX19LEEucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKG4saSxlKXt2YXIgbz10aGlzO3RoaXMucHJvdmlkZXJ8fGwudGhyb3dFcnJvcihcImV2ZW50cyByZXF1aXJlIGEgcHJvdmlkZXIgb3IgYSBzaWduZXIgd2l0aCBhIHByb3ZpZGVyXCIsbC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm9uY2VcIn0pO2Z1bmN0aW9uIHQoZSl7dmFyIHQ9cC5kZWVwQ29weShlKSxyPW4ucHJlcGFyZUV2ZW50KHQpO24uZXZlbnQmJih0LmRlY29kZT1uLmV2ZW50LmRlY29kZSx0LmV2ZW50PW4uZXZlbnQubmFtZSx0LmV2ZW50U2lnbmF0dXJlPW4uZXZlbnQuc2lnbmF0dXJlKSx0LnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKCl7by5yZW1vdmVMaXN0ZW5lcihuLmZpbHRlcixpKX0sdC5nZXRCbG9jaz1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldEJsb2NrKGUuYmxvY2tIYXNoKX0sdC5nZXRUcmFuc2FjdGlvbj1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGUudHJhbnNhY3Rpb25IYXNoKX0sdC5nZXRUcmFuc2FjdGlvblJlY2VpcHQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoZS50cmFuc2FjdGlvbkhhc2gpfSxvLmVtaXQuYXBwbHkobyxbbi5maWx0ZXJdLmNvbmNhdChyKSl9dGhpcy5wcm92aWRlci5vbihuLmZpbHRlcix0KSx0aGlzLl9ldmVudHMucHVzaCh7ZXZlbnRGaWx0ZXI6bixsaXN0ZW5lcjppLHdyYXBwZWRMaXN0ZW5lcjp0LG9uY2U6ZX0pfSxBLnByb3RvdHlwZS5vbj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRoaXMuX2dldEV2ZW50RmlsdGVyKGUpLHQsITEpLHRoaXN9LEEucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRFdmVudEZpbHRlcihlKSx0LCEwKSx0aGlzfSxBLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm9uKGUsdCl9LEEucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMscj1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKylyW24tMV09YXJndW1lbnRzW25dO2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiExO3ZhciBpPSExLG89dGhpcy5fZ2V0RXZlbnRGaWx0ZXIoZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnIT09by5ldmVudFRhZ3x8KHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmxpc3RlbmVyLmFwcGx5KHQscil9LDApLGk9ITAsIWUub25jZSl9KSxpfSxBLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiAwO3ZhciB0PXRoaXMuX2dldEV2ZW50RmlsdGVyKGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnPT09dC5ldmVudFRhZ30pLmxlbmd0aH0sQS5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybltdO3ZhciB0PXRoaXMuX2dldEV2ZW50RmlsdGVyKGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnPT09dC5ldmVudFRhZ30pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5saXN0ZW5lcn0pfSxBLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5wcm92aWRlcilyZXR1cm4gdGhpczt2YXIgcj10aGlzLl9nZXRFdmVudEZpbHRlcihlKTtyZXR1cm4gdGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXZlbnRGaWx0ZXIuZXZlbnRUYWchPT1yLmV2ZW50VGFnfHwodC5wcm92aWRlci5yZW1vdmVMaXN0ZW5lcihlLmV2ZW50RmlsdGVyLmZpbHRlcixlLndyYXBwZWRMaXN0ZW5lciksITEpfSksdGhpc30sQS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiB0aGlzO3ZhciBuPSExLGk9dGhpcy5fZ2V0RXZlbnRGaWx0ZXIoZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnIT09aS5ldmVudFRhZ3x8KGUubGlzdGVuZXIhPT10fHwoci5wcm92aWRlci5yZW1vdmVMaXN0ZW5lcihlLmV2ZW50RmlsdGVyLmZpbHRlcixlLndyYXBwZWRMaXN0ZW5lciksISFufHwhKG49ITApKSl9KSx0aGlzfSxBKTtmdW5jdGlvbiBBKHQsZSxyKXt2YXIgbj10aGlzO2lmKGwuY2hlY2tOZXcodGhpcyxBKSxkLkludGVyZmFjZS5pc0ludGVyZmFjZShlKT9wLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJpbnRlcmZhY2VcIixlKTpwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJpbnRlcmZhY2VcIixuZXcgZC5JbnRlcmZhY2UoZSkpLHkuU2lnbmVyLmlzU2lnbmVyKHIpPyhwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHIucHJvdmlkZXIpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInNpZ25lclwiLHIpKTp2LlByb3ZpZGVyLmlzUHJvdmlkZXIocik/KHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIscikscC5kZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsbnVsbCkpOmwudGhyb3dFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJzaWduZXJPclByb3ZpZGVyXCIsdmFsdWU6cn0pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImVzdGltYXRlXCIse30pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImZ1bmN0aW9uc1wiLHt9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJmaWx0ZXJzXCIse30pLE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcj1uLmludGVyZmFjZS5ldmVudHNbZV07cC5kZWZpbmVSZWFkT25seShuLmZpbHRlcnMsZSxmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtyZXR1cm57YWRkcmVzczpuLmFkZHJlc3MsdG9waWNzOnIuZW5jb2RlVG9waWNzKGUpfX0pfSksdGhpcy5fZXZlbnRzPVtdLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIix0KSx0aGlzLnByb3ZpZGVyKXAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NQcm9taXNlXCIsdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZSh0KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwibmFtZSBub3QgZm91bmRcIik7cmV0dXJuIGV9KS5jYXRjaChmdW5jdGlvbihlKXt0aHJvdyBlfSkpO2Vsc2UgdHJ5e3AuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NQcm9taXNlXCIsUHJvbWlzZS5yZXNvbHZlKGEuZ2V0QWRkcmVzcyh0KSkpfWNhdGNoKGUpe2wudGhyb3dFcnJvcihcInByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIHVzZSBub24tYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcImFkZHJlc3NPck5hbWVcIix2YWx1ZTp0fSl9T2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXcobixlLCExKTtudWxsPT1uW2VdP3AuZGVmaW5lUmVhZE9ubHkobixlLHQpOmwud2FybihcIldBUk5JTkc6IE11bHRpcGxlIGRlZmluaXRpb25zIGZvciBcIitlKSxudWxsPT1uLmZ1bmN0aW9uc1tlXSYmKHAuZGVmaW5lUmVhZE9ubHkobi5mdW5jdGlvbnMsZSx0KSxwLmRlZmluZVJlYWRPbmx5KG4uZXN0aW1hdGUsZSx3KG4sZSwhMCkpKX0pfXIuQ29udHJhY3Q9TTt2YXIgRT0oUy5wcm90b3R5cGUuZ2V0RGVwbG95VHJhbnNhY3Rpb249ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dmFyIHI9e307aWYoZS5sZW5ndGg9PT10aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5pbnB1dHMubGVuZ3RoKzEpZm9yKHZhciBuIGluIHI9cC5zaGFsbG93Q29weShlLnBvcCgpKSlpZighYltuXSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiK24pO3JldHVybltcImRhdGFcIixcImZyb21cIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9cltlXSYmbC50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiK2UsbC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjplfSl9KSxsLmNoZWNrQXJndW1lbnRDb3VudChlLmxlbmd0aCx0aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5pbnB1dHMubGVuZ3RoLFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpLHIuZGF0YT10aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5lbmNvZGUodGhpcy5ieXRlY29kZSxlKSxyfSxTLnByb3RvdHlwZS5kZXBsb3k9ZnVuY3Rpb24oKXtmb3IodmFyIHI9dGhpcyxlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3ZhciBuPXRoaXMuZ2V0RGVwbG95VHJhbnNhY3Rpb24uYXBwbHkodGhpcyxlKTtyZXR1cm4gdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKG4pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IE0oYS5nZXRDb250cmFjdEFkZHJlc3MoZSksci5pbnRlcmZhY2Usci5zaWduZXIpO3JldHVybiBwLmRlZmluZVJlYWRPbmx5KHQsXCJkZXBsb3lUcmFuc2FjdGlvblwiLGUpLHR9KX0sUy5wcm90b3R5cGUuYXR0YWNoPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgTShlLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyKX0sUy5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFModGhpcy5pbnRlcmZhY2UsdGhpcy5ieXRlY29kZSxlKX0sUy5mcm9tU29saWRpdHk9ZnVuY3Rpb24oZSx0KXtudWxsPT1lJiZsLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLGwuTUlTU0lOR19BUkdVTUVOVCx7YXJndW1lbnQ6XCJjb21waWxlck91dHB1dFwifSksXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPUpTT04ucGFyc2UoZSkpO3ZhciByPWUuYWJpLG49bnVsbDtyZXR1cm4gZS5ieXRlY29kZT9uPWUuYnl0ZWNvZGU6ZS5ldm0mJmUuZXZtLmJ5dGVjb2RlJiYobj1lLmV2bS5ieXRlY29kZSksbmV3IFMocixuLHQpfSxTKTtmdW5jdGlvbiBTKGUsdCxyKXt2YXIgbj1udWxsO1wic3RyaW5nXCI9PXR5cGVvZiB0P249dDpjLmlzQXJyYXlpc2godCk/bj1jLmhleGxpZnkodCk6XCJzdHJpbmdcIj09dHlwZW9mIHQub2JqZWN0P249dC5vYmplY3Q6bC50aHJvd0Vycm9yKFwiYnl0ZWNvZGUgbXVzdCBiZSBhIHZhbGlkIGhleCBzdHJpbmdcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6dH0pLFwiMHhcIiE9PW4uc3Vic3RyaW5nKDAsMikmJihuPVwiMHhcIituKSxjLmlzSGV4U3RyaW5nKG4pfHxsLnRocm93RXJyb3IoXCJieXRlY29kZSBtdXN0IGJlIGEgdmFsaWQgaGV4IHN0cmluZ1wiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiYnl0ZWNvZGVcIix2YWx1ZTp0fSksbi5sZW5ndGglMiE9MCYmbC50aHJvd0Vycm9yKFwiYnl0ZWNvZGUgbXVzdCBiZSB2YWxpZCBkYXRhIChldmVuIGxlbmd0aClcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6dH0pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImJ5dGVjb2RlXCIsbiksZC5JbnRlcmZhY2UuaXNJbnRlcmZhY2UoZSk/cC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsZSk6cC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsbmV3IGQuSW50ZXJmYWNlKGUpKSxyJiYheS5TaWduZXIuaXNTaWduZXIocikmJmwudGhyb3dFcnJvcihcImludmFsaWQgc2lnbmVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJzaWduZXJcIix2YWx1ZTpudWxsfSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIscnx8bnVsbCl9ci5Db250cmFjdEZhY3Rvcnk9RX0se1wiLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi9jb25zdGFudHNcIjozLFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vdXRpbHMvYWJpLWNvZGVyXCI6NTksXCIuL3V0aWxzL2FkZHJlc3NcIjo2MCxcIi4vdXRpbHMvYmlnbnVtYmVyXCI6NjMsXCIuL3V0aWxzL2J5dGVzXCI6NjQsXCIuL3V0aWxzL2ludGVyZmFjZVwiOjY5LFwiLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw1OltmdW5jdGlvbihlLHQscyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZShcIi4vX3ZlcnNpb25cIik7cy5VTktOT1dOX0VSUk9SPVwiVU5LTk9XTl9FUlJPUlwiLHMuTk9UX0lNUExFTUVOVEVEPVwiTk9UX0lNUExFTUVOVEVEXCIscy5NSVNTSU5HX05FVz1cIk1JU1NJTkdfTkVXXCIscy5DQUxMX0VYQ0VQVElPTj1cIkNBTExfRVhDRVBUSU9OXCIscy5JTlZBTElEX0FSR1VNRU5UPVwiSU5WQUxJRF9BUkdVTUVOVFwiLHMuTUlTU0lOR19BUkdVTUVOVD1cIk1JU1NJTkdfQVJHVU1FTlRcIixzLlVORVhQRUNURURfQVJHVU1FTlQ9XCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIscy5OVU1FUklDX0ZBVUxUPVwiTlVNRVJJQ19GQVVMVFwiLHMuSU5TVUZGSUNJRU5UX0ZVTkRTPVwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIscy5OT05DRV9FWFBJUkVEPVwiTk9OQ0VfRVhQSVJFRFwiLHMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQ9XCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO3ZhciByPSEocy5VTlNVUFBPUlRFRF9PUEVSQVRJT049XCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiksdT0hMTtmdW5jdGlvbiBuKGUsdCxyKXtpZih1KXRocm93IG5ldyBFcnJvcihcInVua25vd24gZXJyb3JcIik7dD10fHxzLlVOS05PV05fRVJST1Iscj1yfHx7fTt2YXIgbj1bXTtPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3RyeXtuLnB1c2godCtcIj1cIitKU09OLnN0cmluZ2lmeShyW3RdKSl9Y2F0Y2goZSl7bi5wdXNoKHQrXCI9XCIrSlNPTi5zdHJpbmdpZnkoclt0XS50b1N0cmluZygpKSl9fSksbi5wdXNoKFwidmVyc2lvbj1cIithLnZlcnNpb24pO3ZhciBpPWU7bi5sZW5ndGgmJihlKz1cIiAoXCIrbi5qb2luKFwiLCBcIikrXCIpXCIpO3ZhciBvPW5ldyBFcnJvcihlKTt0aHJvdyBvLnJlYXNvbj1pLG8uY29kZT10LE9iamVjdC5rZXlzKHIpLmZvckVhY2goZnVuY3Rpb24oZSl7b1tlXT1yW2VdfSksb31zLnRocm93RXJyb3I9bixzLmNoZWNrTmV3PWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHR8fG4oXCJtaXNzaW5nIG5ld1wiLHMuTUlTU0lOR19ORVcse25hbWU6dC5uYW1lfSl9LHMuY2hlY2tBcmd1bWVudENvdW50PWZ1bmN0aW9uKGUsdCxyKXtyPXJ8fFwiXCIsZTx0JiZuKFwibWlzc2luZyBhcmd1bWVudFwiK3Iscy5NSVNTSU5HX0FSR1VNRU5ULHtjb3VudDplLGV4cGVjdGVkQ291bnQ6dH0pLHQ8ZSYmbihcInRvbyBtYW55IGFyZ3VtZW50c1wiK3Iscy5VTkVYUEVDVEVEX0FSR1VNRU5ULHtjb3VudDplLGV4cGVjdGVkQ291bnQ6dH0pfSxzLnNldENlbnNvcnNoaXA9ZnVuY3Rpb24oZSx0KXtyJiZuKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIixzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2V0Q2Vuc29yc2hpcFwifSksdT0hIWUscj0hIXR9LHMuY2hlY2tOb3JtYWxpemU9ZnVuY3Rpb24oKXt0cnl7aWYoW1wiTkZEXCIsXCJORkNcIixcIk5GS0RcIixcIk5GS0NcIl0uZm9yRWFjaChmdW5jdGlvbih0KXt0cnl7XCJ0ZXN0XCIubm9ybWFsaXplKHQpfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIrdCl9fSksU3RyaW5nLmZyb21DaGFyQ29kZSgyMzMpLm5vcm1hbGl6ZShcIk5GRFwiKSE9PVN0cmluZy5mcm9tQ2hhckNvZGUoMTAxLDc2OSkpdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpfWNhdGNoKGUpe24oXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIscy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsZm9ybTplLm1lc3NhZ2V9KX19O3ZhciBpPXtkZWJ1ZzoxLGRlZmF1bHQ6MixpbmZvOjIsd2FybjozLGVycm9yOjQsb2ZmOjV9LG89aS5kZWZhdWx0O2Z1bmN0aW9uIGwoZSx0KXtvPmlbZV18fGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsdCl9ZnVuY3Rpb24gaCgpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtsKFwid2FyblwiLGUpfXMuc2V0TG9nTGV2ZWw9ZnVuY3Rpb24oZSl7dmFyIHQ9aVtlXTtudWxsIT10P289dDpoKFwiaW52bGlhZCBsb2cgbGV2ZWwgLSBcIitlKX0scy53YXJuPWgscy5pbmZvPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO2woXCJpbmZvXCIsZSl9fSx7XCIuL192ZXJzaW9uXCI6MX1dLDY6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPWUoXCIuL2NvbnRyYWN0XCIpO3IuQ29udHJhY3Q9aS5Db250cmFjdCxyLkNvbnRyYWN0RmFjdG9yeT1pLkNvbnRyYWN0RmFjdG9yeSxyLlZvaWRTaWduZXI9aS5Wb2lkU2lnbmVyO3ZhciBvPWUoXCIuL2Fic3RyYWN0LXNpZ25lclwiKTtyLlNpZ25lcj1vLlNpZ25lcjt2YXIgcz1lKFwiLi93YWxsZXRcIik7ci5XYWxsZXQ9cy5XYWxsZXQ7dmFyIGE9bihlKFwiLi9jb25zdGFudHNcIikpO3IuY29uc3RhbnRzPWE7dmFyIHU9bihlKFwiLi9lcnJvcnNcIikpO3IuZXJyb3JzPXU7dmFyIGw9bihlKFwiLi9wcm92aWRlcnNcIikpO3IucHJvdmlkZXJzPWw7dmFyIGg9bihlKFwiLi91dGlsc1wiKSk7ci51dGlscz1oO3ZhciBmPW4oZShcIi4vd29yZGxpc3RzXCIpKTtyLndvcmRsaXN0cz1mO3ZhciBjPWUoXCIuL3V0aWxzL3NoaW1zXCIpO3IucGxhdGZvcm09Yy5wbGF0Zm9ybTt2YXIgZD1lKFwiLi9fdmVyc2lvblwiKTtyLnZlcnNpb249ZC52ZXJzaW9uLHIuZ2V0RGVmYXVsdFByb3ZpZGVyPWZ1bmN0aW9uKGUpe251bGw9PWUmJihlPVwiaG9tZXN0ZWFkXCIpO3ZhciB0PWguZ2V0TmV0d29yayhlKTtyZXR1cm4gdCYmdC5fZGVmYXVsdFByb3ZpZGVyfHx1LnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLHUuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXREZWZhdWx0UHJvdmlkZXJcIixuZXR3b3JrOmV9KSx0Ll9kZWZhdWx0UHJvdmlkZXIobCl9fSx7XCIuL192ZXJzaW9uXCI6MSxcIi4vYWJzdHJhY3Qtc2lnbmVyXCI6MixcIi4vY29uc3RhbnRzXCI6MyxcIi4vY29udHJhY3RcIjo0LFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnNcIjo1NCxcIi4vdXRpbHNcIjo2OCxcIi4vdXRpbHMvc2hpbXNcIjo4MCxcIi4vd2FsbGV0XCI6ODgsXCIuL3dvcmRsaXN0c1wiOjg5fV0sNzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bihlKFwiLi9ldGhlcnNcIikpO3IuZXRoZXJzPWksZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIGUpci5oYXNPd25Qcm9wZXJ0eSh0KXx8KHJbdF09ZVt0XSl9KGUoXCIuL2V0aGVyc1wiKSl9LHtcIi4vZXRoZXJzXCI6Nn1dLDg6W2Z1bmN0aW9uKGUsQyxMKXtcInVzZSBzdHJpY3RcIjshZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihlKXtyZXR1cm4gcGFyc2VJbnQoZSk9PT1lfWZ1bmN0aW9uIG4oZSl7aWYocihlLmxlbmd0aCkpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKWlmKCFyKGVbdF0pfHxlW3RdPDB8fDI1NTxlW3RdKXJldHVybjtyZXR1cm4gMX19ZnVuY3Rpb24gbyhlLHQpe2lmKGUuYnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcoZSkmJlwiVWludDhBcnJheVwiPT09ZS5uYW1lKXJldHVybiB0JiYoZT1lLnNsaWNlP2Uuc2xpY2UoKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSksZTtpZihBcnJheS5pc0FycmF5KGUpKXtpZighbihlKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBjb250YWlucyBpbnZhbGlkIHZhbHVlOiBcIitlKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSl9aWYocihlLmxlbmd0aCkmJm4oZSkpcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO3Rocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0XCIpfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUpfWZ1bmN0aW9uIHMoZSx0LHIsbixpKXtudWxsPT1uJiZudWxsPT1pfHwoZT1lLnNsaWNlP2Uuc2xpY2UobixpKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLG4saSkpLHQuc2V0KGUscil9dmFyIGksdD17dG9CeXRlczpmdW5jdGlvbihlKXt2YXIgdD1bXSxyPTA7Zm9yKGU9ZW5jb2RlVVJJKGUpO3I8ZS5sZW5ndGg7KXt2YXIgbj1lLmNoYXJDb2RlQXQocisrKTszNz09PW4/KHQucHVzaChwYXJzZUludChlLnN1YnN0cihyLDIpLDE2KSkscis9Mik6dC5wdXNoKG4pfXJldHVybiBvKHQpfSxmcm9tQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoOyl7dmFyIG49ZVtyXTtuPDEyOD8odC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpLHIrKyk6MTkxPG4mJm48MjI0Pyh0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbik8PDZ8NjMmZVtyKzFdKSkscis9Mik6KHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZuKTw8MTJ8KDYzJmVbcisxXSk8PDZ8NjMmZVtyKzJdKSkscis9Myl9cmV0dXJuIHQuam9pbihcIlwiKX19LGE9KGk9XCIwMTIzNDU2Nzg5YWJjZGVmXCIse3RvQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrPTIpdC5wdXNoKHBhcnNlSW50KGUuc3Vic3RyKHIsMiksMTYpKTtyZXR1cm4gdH0sZnJvbUJ5dGVzOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07dC5wdXNoKGlbKDI0MCZuKT4+NF0raVsxNSZuXSl9cmV0dXJuIHQuam9pbihcIlwiKX19KSxmPXsxNjoxMCwyNDoxMiwzMjoxNH0sYz1bMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDVdLGQ9Wzk5LDEyNCwxMTksMTIzLDI0MiwxMDcsMTExLDE5Nyw0OCwxLDEwMyw0MywyNTQsMjE1LDE3MSwxMTgsMjAyLDEzMCwyMDEsMTI1LDI1MCw4OSw3MSwyNDAsMTczLDIxMiwxNjIsMTc1LDE1NiwxNjQsMTE0LDE5MiwxODMsMjUzLDE0NywzOCw1NCw2MywyNDcsMjA0LDUyLDE2NSwyMjksMjQxLDExMywyMTYsNDksMjEsNCwxOTksMzUsMTk1LDI0LDE1MCw1LDE1NCw3LDE4LDEyOCwyMjYsMjM1LDM5LDE3OCwxMTcsOSwxMzEsNDQsMjYsMjcsMTEwLDkwLDE2MCw4Miw1OSwyMTQsMTc5LDQxLDIyNyw0NywxMzIsODMsMjA5LDAsMjM3LDMyLDI1MiwxNzcsOTEsMTA2LDIwMywxOTAsNTcsNzQsNzYsODgsMjA3LDIwOCwyMzksMTcwLDI1MSw2Nyw3Nyw1MSwxMzMsNjksMjQ5LDIsMTI3LDgwLDYwLDE1OSwxNjgsODEsMTYzLDY0LDE0MywxNDYsMTU3LDU2LDI0NSwxODgsMTgyLDIxOCwzMywxNiwyNTUsMjQzLDIxMCwyMDUsMTIsMTksMjM2LDk1LDE1MSw2OCwyMywxOTYsMTY3LDEyNiw2MSwxMDAsOTMsMjUsMTE1LDk2LDEyOSw3OSwyMjAsMzQsNDIsMTQ0LDEzNiw3MCwyMzgsMTg0LDIwLDIyMiw5NCwxMSwyMTksMjI0LDUwLDU4LDEwLDczLDYsMzYsOTIsMTk0LDIxMSwxNzIsOTgsMTQ1LDE0OSwyMjgsMTIxLDIzMSwyMDAsNTUsMTA5LDE0MSwyMTMsNzgsMTY5LDEwOCw4NiwyNDQsMjM0LDEwMSwxMjIsMTc0LDgsMTg2LDEyMCwzNyw0NiwyOCwxNjYsMTgwLDE5OCwyMzIsMjIxLDExNiwzMSw3NSwxODksMTM5LDEzOCwxMTIsNjIsMTgxLDEwMiw3MiwzLDI0NiwxNCw5Nyw1Myw4NywxODUsMTM0LDE5MywyOSwxNTgsMjI1LDI0OCwxNTIsMTcsMTA1LDIxNywxNDIsMTQ4LDE1NSwzMCwxMzUsMjMzLDIwNiw4NSw0MCwyMjMsMTQwLDE2MSwxMzcsMTMsMTkxLDIzMCw2NiwxMDQsNjUsMTUzLDQ1LDE1LDE3Niw4NCwxODcsMjJdLGw9WzgyLDksMTA2LDIxMyw0OCw1NCwxNjUsNTYsMTkxLDY0LDE2MywxNTgsMTI5LDI0MywyMTUsMjUxLDEyNCwyMjcsNTcsMTMwLDE1NSw0NywyNTUsMTM1LDUyLDE0Miw2Nyw2OCwxOTYsMjIyLDIzMywyMDMsODQsMTIzLDE0OCw1MCwxNjYsMTk0LDM1LDYxLDIzOCw3NiwxNDksMTEsNjYsMjUwLDE5NSw3OCw4LDQ2LDE2MSwxMDIsNDAsMjE3LDM2LDE3OCwxMTgsOTEsMTYyLDczLDEwOSwxMzksMjA5LDM3LDExNCwyNDgsMjQ2LDEwMCwxMzQsMTA0LDE1MiwyMiwyMTIsMTY0LDkyLDIwNCw5MywxMDEsMTgyLDE0NiwxMDgsMTEyLDcyLDgwLDI1MywyMzcsMTg1LDIxOCw5NCwyMSw3MCw4NywxNjcsMTQxLDE1NywxMzIsMTQ0LDIxNiwxNzEsMCwxNDAsMTg4LDIxMSwxMCwyNDcsMjI4LDg4LDUsMTg0LDE3OSw2OSw2LDIwOCw0NCwzMCwxNDMsMjAyLDYzLDE1LDIsMTkzLDE3NSwxODksMywxLDE5LDEzOCwxMDcsNTgsMTQ1LDE3LDY1LDc5LDEwMywyMjAsMjM0LDE1MSwyNDIsMjA3LDIwNiwyNDAsMTgwLDIzMCwxMTUsMTUwLDE3MiwxMTYsMzQsMjMxLDE3Myw1MywxMzMsMjI2LDI0OSw1NSwyMzIsMjgsMTE3LDIyMywxMTAsNzEsMjQxLDI2LDExMywyOSw0MSwxOTcsMTM3LDExMSwxODMsOTgsMTQsMTcwLDI0LDE5MCwyNywyNTIsODYsNjIsNzUsMTk4LDIxMCwxMjEsMzIsMTU0LDIxOSwxOTIsMjU0LDEyMCwyMDUsOTAsMjQ0LDMxLDIyMSwxNjgsNTEsMTM2LDcsMTk5LDQ5LDE3NywxOCwxNiw4OSwzOSwxMjgsMjM2LDk1LDk2LDgxLDEyNywxNjksMjUsMTgxLDc0LDEzLDQ1LDIyOSwxMjIsMTU5LDE0NywyMDEsMTU2LDIzOSwxNjAsMjI0LDU5LDc3LDE3NCw0MiwyNDUsMTc2LDIwMCwyMzUsMTg3LDYwLDEzMSw4MywxNTMsOTcsMjMsNDMsNCwxMjYsMTg2LDExOSwyMTQsMzgsMjI1LDEwNSwyMCw5OSw4NSwzMywxMiwxMjVdLGg9WzMzMjg0MDIzNDEsNDE2ODkwNzkwOCw0MDAwODA2ODA5LDQxMzUyODc2OTMsNDI5NDExMTc1NywzNTk3MzY0MTU3LDM3MzE4NDUwNDEsMjQ0NTY1NzQyOCwxNjEzNzcwODMyLDMzNjIwMjI3LDM0NjI4ODMyNDEsMTQ0NTY2OTc1NywzODkyMjQ4MDg5LDMwNTA4MjE0NzQsMTMwMzA5NjI5NCwzOTY3MTg2NTg2LDI0MTI0MzE5NDEsNTI4NjQ2ODEzLDIzMTE3MDI4NDgsNDIwMjUyODEzNSw0MDI2MjAyNjQ1LDI5OTIyMDAxNzEsMjM4NzAzNjEwNSw0MjI2ODcxMzA3LDExMDE5MDEyOTIsMzAxNzA2OTY3MSwxNjA0NDk0MDc3LDExNjkxNDE3MzgsNTk3NDY2MzAzLDE0MDMyOTkwNjMsMzgzMjcwNTY4NiwyNjEzMTAwNjM1LDE5NzQ5NzQ0MDIsMzc5MTUxOTAwNCwxMDMzMDgxNzc0LDEyNzc1Njg2MTgsMTgxNTQ5MjE4NiwyMTE4MDc0MTc3LDQxMjY2Njg1NDYsMjIxMTIzNjk0MywxNzQ4MjUxNzQwLDEzNjk4MTA0MjAsMzUyMTUwNDU2NCw0MTkzMzgyNjY0LDM3OTkwODU0NTksMjg4MzExNTEyMywxNjQ3MzkxMDU5LDcwNjAyNDc2NywxMzQ0ODA5MDgsMjUxMjg5Nzg3NCwxMTc2NzA3OTQxLDI2NDY4NTI0NDYsODA2ODg1NDE2LDkzMjYxNTg0MSwxNjgxMDExMzUsNzk4NjYxMzAxLDIzNTM0MTU3Nyw2MDUxNjQwODYsNDYxNDA2MzYzLDM3NTYxODgyMjEsMzQ1NDc5MDQzOCwxMzExMTg4ODQxLDIxNDI0MTc2MTMsMzkzMzU2NjM2NywzMDI1ODIwNDMsNDk1MTU4MTc0LDE0NzkyODk5NzIsODc0MTI1ODcwLDkwNzc0NjA5MywzNjk4MjI0ODE4LDMwMjU4MjAzOTgsMTUzNzI1MzYyNywyNzU2ODU4NjE0LDE5ODM1OTMyOTMsMzA4NDMxMDExMywyMTA4OTI4OTc0LDEzNzg0MjkzMDcsMzcyMjY5OTU4MiwxNTgwMTUwNjQxLDMyNzQ1MTc5OSwyNzkwNDc4ODM3LDMxMTc1MzU1OTIsMCwzMjUzNTk1NDM2LDEwNzU4NDcyNjQsMzgyNTAwNzY0NywyMDQxNjg4NTIwLDMwNTk0NDA2MjEsMzU2Mzc0MzkzNCwyMzc4OTQzMzAyLDE3NDA1NTM5NDUsMTkxNjM1Mjg0MywyNDg3ODk2Nzk4LDI1NTUxMzcyMzYsMjk1ODU3OTk0NCwyMjQ0OTg4NzQ2LDMxNTEwMjQyMzUsMzMyMDgzNTg4MiwxMzM2NTg0OTMzLDM5OTI3MTQwMDYsMjI1MjU1NTIwNSwyNTg4NzU3NDYzLDE3MTQ2MzE1MDksMjkzOTYzMTU2LDIzMTk3OTU2NjMsMzkyNTQ3MzU1Miw2NzI0MDQ1NCw0MjY5NzY4NTc3LDI2ODk2MTgxNjAsMjAxNzIxMzUwOCw2MzEyMTgxMDYsMTI2OTM0NDQ4MywyNzIzMjM4Mzg3LDE1NzEwMDU0MzgsMjE1MTY5NDUyOCw5MzI5NDQ3NCwxMDY2NTcwNDEzLDU2Mzk3NzY2MCwxODgyNzMyNjE2LDQwNTk0MjgxMDAsMTY3MzMxMzUwMywyMDA4NDYzMDQxLDI5NTAzNTU1NzMsMTEwOTQ2NzQ5MSw1Mzc5MjM2MzIsMzg1ODc1OTQ1MCw0MjYwNjIzMTE4LDMyMTgyNjQ2ODUsMjE3Nzc0ODMwMCw0MDM0NDI3MDgsNjM4Nzg0MzA5LDMyODcwODQwNzksMzE5MzkyMTUwNSw4OTkxMjcyMDIsMjI4NjE3NTQzNiw3NzMyNjUyMDksMjQ3OTE0NjA3MSwxNDM3MDUwODY2LDQyMzYxNDgzNTQsMjA1MDgzMzczNSwzMzYyMDIyNTcyLDMxMjY2ODEwNjMsODQwNTA1NjQzLDM4NjYzMjU5MDksMzIyNzU0MTY2NCw0Mjc5MTc3MjAsMjY1NTk5NzkwNSwyNzQ5MTYwNTc1LDExNDMwODc3MTgsMTQxMjA0OTUzNCw5OTkzMjk5NjMsMTkzNDk3MjE5LDIzNTM0MTU4ODIsMzM1NDMyNDUyMSwxODA3MjY4MDUxLDY3MjQwNDU0MCwyODE2NDAxMDE3LDMxNjAzMDEyODIsMzY5ODIyNDkzLDI5MTY4NjY5MzQsMzY4ODk0Nzc3MSwxNjgxMDExMjg2LDE5NDk5NzMwNzAsMzM2MjAyMjcwLDI0NTQyNzY1NzEsMjAxNzIxMzU0LDEyMTAzMjgxNzIsMzA5MzA2MDgzNiwyNjgwMzQxMDg1LDMxODQ3NzYwNDYsMTEzNTM4OTkzNSwzMjk0NzgyMTE4LDk2NTg0MTMyMCw4MzE4ODY3NTYsMzU1NDk5MzIwNyw0MDY4MDQ3MjQzLDM1ODg3NDUwMTAsMjM0NTE5MTQ5MSwxODQ5MTEyNDA5LDM2NjQ2MDQ1OTksMjYwNTQwMjgsMjk4MzU4MTAyOCwyNjIyMzc3NjgyLDEyMzU4NTU4NDAsMzYzMDk4NDM3MiwyODkxMzM5NTE0LDQwOTI5MTY3NDMsMzQ4ODI3OTA3NywzMzk1NjQyNzk5LDQxMDE2Njc0NzAsMTIwMjYzMDM3NywyNjg5NjE4MTYsMTg3NDUwODUwMSw0MDM0NDI3MDE2LDEyNDM5NDgzOTksMTU0NjUzMDQxOCw5NDEzNjYzMDgsMTQ3MDUzOTUwNSwxOTQxMjIyNTk5LDI1NDYzODY1MTMsMzQyMTAzODYyNywyNzE1NjcxOTMyLDM4OTk5NDYxNDAsMTA0MjIyNjk3NywyNTIxNTE3MDIxLDE2Mzk4MjQ4NjAsMjI3MjQ5MDMwLDI2MDczNzY2OSwzNzY1NDY1MjMyLDIwODQ0NTM5NTQsMTkwNzczMzk1NiwzNDI5MjYzMDE4LDI0MjA2NTYzNDQsMTAwODYwNjc3LDQxNjAxNTcxODUsNDcwNjgzMTU0LDMyNjExNjE4OTEsMTc4MTg3MTk2NywyOTI0OTU5NzM3LDE3NzM3Nzk0MDgsMzk0NjkyMjQxLDI1Nzk2MTE5OTIsOTc0OTg2NTM1LDY2NDcwNjc0NSwzNjU1NDU5MTI4LDM5NTg5NjIxOTUsNzMxNDIwODUxLDU3MTU0Mzg1OSwzNTMwMTIzNzA3LDI4NDk2MjY0ODAsMTI2NzgzMTEzLDg2NTM3NTM5OSw3NjUxNzI2NjIsMTAwODYwNjc1NCwzNjEyMDM2MDIsMzM4NzU0OTk4NCwyMjc4NDc3Mzg1LDI4NTc3MTkyOTUsMTM0NDgwOTA4MCwyNzgyOTEyMzc4LDU5NTQyNjcxLDE1MDM3NjQ5ODQsMTYwMDA4NTc2LDQzNzA2MjkzNSwxNzA3MDY1MzA2LDM2MjIyMzM2NDksMjIxODkzNDk4MiwzNDk2NTAzNDgwLDIxODUzMTQ3NTUsNjk3OTMyMjA4LDE1MTI5MTAxOTksNTA0MzAzMzc3LDIwNzUxNzcxNjMsMjgyNDA5OTA2OCwxODQxMDE5ODYyLDczOTY0NDk4Nl0scD1bMjc4MTI0MjIxMSwyMjMwODc3MzA4LDI1ODI1NDIxOTksMjM4MTc0MDkyMywyMzQ4Nzc2ODIsMzE4NDk0NjAyNywyOTg0MTQ0NzUxLDE0MTg4Mzk0OTMsMTM0ODQ4MTA3Miw1MDQ2Mjk3NywyODQ4ODc2MzkxLDIxMDI3OTkxNDcsNDM0NjM0NDk0LDE2NTYwODQ0MzksMzg2Mzg0OTg5OSwyNTk5MTg4MDg2LDExNjcwNTE0NjYsMjYzNjA4NzkzOCwxMDgyNzcxOTEzLDIyODEzNDAyODUsMzY4MDQ4ODkwLDM5NTQzMzQwNDEsMzM4MTU0NDc3NSwyMDEwNjA1OTIsMzk2MzcyNzI3NywxNzM5ODM4Njc2LDQyNTA5MDMyMDIsMzkzMDQzNTUwMywzMjA2NzgyMTA4LDQxNDk0NTM5ODgsMjUzMTU1MzkwNiwxNTM2OTM0MDgwLDMyNjI0OTQ2NDcsNDg0NTcyNjY5LDI5MjMyNzEwNTksMTc4MzM3NTM5OCwxNTE3MDQxMjA2LDEwOTg3OTI3NjcsNDk2NzQyMzEsMTMzNDAzNzcwOCwxNTUwMzMyOTgwLDQwOTg5OTE1MjUsODg2MTcxMTA5LDE1MDU5ODEyOSwyNDgxMDkwOTI5LDE5NDA2NDIwMDgsMTM5ODk0NDA0OSwxMDU5NzIyNTE3LDIwMTg1MTkwOCwxMzg1NTQ3NzE5LDE2OTkwOTUzMzEsMTU4NzM5NzU3MSw2NzQyNDA1MzYsMjcwNDc3NDgwNiwyNTIzMTQ4ODUsMzAzOTc5NTg2NiwxNTE5MTQyNDcsOTA4MzMzNTg2LDI2MDIyNzA4NDgsMTAzODA4Mjc4Niw2NTEwMjk0ODMsMTc2NjcyOTUxMSwzNDQ3Njk4MDk4LDI2ODI5NDI4MzcsNDU0MTY2NzkzLDI2NTI3MzQzMzksMTk1MTkzNTUzMiw3NzUxNjY0OTAsNzU4NTIwNjAzLDMwMDA3OTA2MzgsNDAwNDc5NzAxOCw0MjE3MDg2MTEyLDQxMzc5NjQxMTQsMTI5OTU5NDA0MywxNjM5NDM4MDM4LDM0NjQzNDQ0OTksMjA2ODk4MjA1NywxMDU0NzI5MTg3LDE5MDE5OTc4NzEsMjUzNDYzODcyNCw0MTIxMzE4MjI3LDE3NTcwMDgzMzcsMCw3NTA5MDY4NjEsMTYxNDgxNTI2NCw1MzUwMzUxMzIsMzM2MzQxODU0NSwzOTg4MTUxMTMxLDMyMDE1OTE5MTQsMTE4MzY5Nzg2NywzNjQ3NDU0OTEwLDEyNjU3NzY5NTMsMzczNDI2MDI5OCwzNTY2NzUwNzk2LDM5MDM4NzEwNjQsMTI1MDI4MzQ3MSwxODA3NDcwODAwLDcxNzYxNTA4NywzODQ3MjAzNDk4LDM4NDY5NTI5MSwzMzEzOTEwNTk1LDM2MTcyMTM3NzMsMTQzMjc2MTEzOSwyNDg0MTc2MjYxLDM0ODE5NDU0MTMsMjgzNzY5MzM3LDEwMDkyNTk1NCwyMTgwOTM5NjQ3LDQwMzcwMzgxNjAsMTE0ODczMDQyOCwzMTIzMDI3ODcxLDM4MTMzODY0MDgsNDA4NzUwMTEzNyw0MjY3NTQ5NjAzLDMyMjk2MzA1MjgsMjMxNTYyMDIzOSwyOTA2NjI0NjU4LDMxNTYzMTk2NDUsMTIxNTMxMzk3Niw4Mjk2NjAwNSwzNzQ3ODU1NTQ4LDMyNDU4NDgyNDYsMTk3NDQ1OTA5OCwxNjY1Mjc4MjQxLDgwNzQwNzYzMiw0NTEyODA4OTUsMjUxNTI0MDgzLDE4NDEyODc4OTAsMTI4MzU3NTI0NSwzMzcxMjAyNjgsODkxNjg3Njk5LDgwMTM2OTMyNCwzNzg3MzQ5ODU1LDI3MjE0MjEyMDcsMzQzMTQ4MjQzNiw5NTkzMjE4NzksMTQ2OTMwMTk1Niw0MDY1Njk5NzUxLDIxOTc1ODU1MzQsMTE5OTE5MzQwNSwyODk4ODE0MDUyLDM4ODc3NTA0OTMsNzI0NzAzNTEzLDI1MTQ5MDgwMTksMjY5Njk2MjE0NCwyNTUxODA4Mzg1LDM1MTY4MTMxMzUsMjE0MTQ0NTM0MCwxNzE1NzQxMjE4LDIxMTk0NDUwMzQsMjg3MjgwNzU2OCwyMTk4NTcxMTQ0LDMzOTgxOTA2NjIsNzAwOTY4Njg2LDM1NDcwNTIyMTYsMTAwOTI1OTU0MCwyMDQxMDQ0NzAyLDM4MDM5OTU3NDIsNDg3OTgzODgzLDE5OTExMDU0OTksMTAwNDI2NTY5NiwxNDQ5NDA3MDI2LDEzMTYyMzk5MzAsNTA0NjI5NzcwLDM2ODM3OTczMjEsMTY4NTYwMTM0LDE4MTY2NjcxNzIsMzgzNzI4NzUxNiwxNTcwNzUxMTcwLDE4NTc5MzQyOTEsNDAxNDE4OTc0MCwyNzk3ODg4MDk4LDI4MjIzNDUxMDUsMjc1NDcxMjk4MSw5MzY2MzM1NzIsMjM0NzkyMzgzMyw4NTI4NzkzMzUsMTEzMzIzNDM3NiwxNTAwMzk1MzE5LDMwODQ1NDUzODksMjM0ODkxMjAxMywxNjg5Mzc2MjEzLDM1MzM0NTkwMjIsMzc2MjkyMzk0NSwzMDM0MDgyNDEyLDQyMDU1OTgyOTQsMTMzNDI4NDY4LDYzNDM4MzA4MiwyOTQ5Mjc3MDI5LDIzOTgzODY4MTAsMzkxMzc4OTEwMiw0MDM3MDM4MTYsMzU4MDg2OTMwNiwyMjk3NDYwODU2LDE4NjcxMzAxNDksMTkxODY0Mzc1OCw2MDc2NTY5ODgsNDA0OTA1MzM1MCwzMzQ2MjQ4ODg0LDEzNjg5MDEzMTgsNjAwNTY1OTkyLDIwOTA5ODI4NzcsMjYzMjQ3OTg2MCw1NTc3MTkzMjcsMzcxNzYxNDQxMSwzNjk3MzkzMDg1LDIyNDkwMzQ2MzUsMjIzMjM4ODIzNCwyNDMwNjI3OTUyLDExMTU0Mzg2NTQsMzI5NTc4NjQyMSwyODY1NTIyMjc4LDM2MzMzMzQzNDQsODQyODAwNjcsMzMwMjc4MzAsMzAzODI4NDk0LDI3NDc0MjUxMjEsMTYwMDc5NTk1Nyw0MTg4OTUyNDA3LDM0OTY1ODk3NTMsMjQzNDIzODA4NiwxNDg2NDcxNjE3LDY1ODExOTk2NSwzMTA2MzgxNDcwLDk1MzgwMzIzMywzMzQyMzE4MDAsMzAwNTk3ODc3Niw4NTc4NzA2MDksMzE1MTEyODkzNywxODkwMTc5NTQ1LDIyOTg5NzM4MzgsMjgwNTE3NTQ0NCwzMDU2NDQyMjY3LDU3NDM2NTIxNCwyNDUwODg0NDg3LDU1MDEwMzUyOSwxMjMzNjM3MDcwLDQyODkzNTMwNDUsMjAxODUxOTA4MCwyMDU3NjkxMTAzLDIzOTkzNzQ0NzYsNDE2NjYyMzY0OSwyMTQ4MTA4NjgxLDM4NzU4MzI0NSwzNjY0MTAxMzExLDgzNjIzMjkzNCwzMzMwNTU2NDgyLDMxMDA2NjU5NjAsMzI4MDA5MzUwNSwyOTU1NTE2MzEzLDIwMDIzOTg1MDksMjg3MTgyNjA3LDM0MTM4ODEwMDgsNDIzODg5MDA2OCwzNTk3NTE1NzA3LDk3NTk2Nzc2Nl0sdj1bMTY3MTgwODYxMSwyMDg5MDg5MTQ4LDIwMDY1NzY3NTksMjA3MjkwMTI0Myw0MDYxMDAzNzYyLDE4MDc2MDMzMDcsMTg3MzkyNzc5MSwzMzEwNjUzODkzLDgxMDU3Mzg3MiwxNjk3NDMzNywxNzM5MTgxNjcxLDcyOTYzNDM0Nyw0MjYzMTEwNjU0LDM2MTM1NzA1MTksMjg4Mzk5NzA5OSwxOTg5ODY0NTY2LDMzOTM1NTY0MjYsMjE5MTMzNTI5OCwzMzc2NDQ5OTkzLDIxMDYwNjM0ODUsNDE5NTc0MTY5MCwxNTA4NjE4ODQxLDEyMDQzOTE0OTUsNDAyNzMxNzIzMiwyOTE3OTQxNjc3LDM1NjM1NjYwMzYsMjczNDUxNDA4MiwyOTUxMzY2MDYzLDI2Mjk3NzIxODgsMjc2NzY3MjIyOCwxOTIyNDkxNTA2LDMyMjcyMjkxMjAsMzA4Mjk3NDY0Nyw0MjQ2NTI4NTA5LDI0Nzc2Njk3NzksNjQ0NTAwNTE4LDkxMTg5NTYwNiwxMDYxMjU2NzY3LDQxNDQxNjYzOTEsMzQyNzc2MzE0OCw4Nzg0NzEyMjAsMjc4NDI1MjMyNSwzODQ1NDQ0MDY5LDQwNDM4OTczMjksMTkwNTUxNzE2OSwzNjMxNDU5Mjg4LDgyNzU0ODIwOSwzNTY0NjEwNzcsNjc4OTczNDgsMzM0NDA3ODI3OSw1OTM4Mzk2NTEsMzI3Nzc1Nzg5MSw0MDUyODY5MzYsMjUyNzE0NzkyNiw4NDg3MTY4NSwyNTk1NTY1NDY2LDExODAzMzkyNywzMDU1MzgwNjYsMjE1NzY0ODc2OCwzNzk1NzA1ODI2LDM5NDUxODg4NDMsNjYxMjEyNzExLDI5OTk4MTIwMTgsMTk3MzQxNDUxNywxNTI3NjkwMzMsMjIwODE3NzUzOSw3NDU4MjIyNTIsNDM5MjM1NjEwLDQ1NTk0NzgwMywxODU3MjE1NTk4LDE1MjU1OTMxNzgsMjcwMDgyNzU1MiwxMzkxODk1NjM0LDk5NDkzMjI4MywzNTk2NzI4Mjc4LDMwMTY2NTQyNTksNjk1OTQ3ODE3LDM4MTI1NDgwNjcsNzk1OTU4ODMxLDIyMjQ0OTM0NDQsMTQwODYwNzgyNywzNTEzMzAxNDU3LDAsMzk3OTEzMzQyMSw1NDMxNzg3ODQsNDIyOTk0ODQxMiwyOTgyNzA1NTg1LDE1NDIzMDUzNzEsMTc5MDg5MTExNCwzNDEwMzk4NjY3LDMyMDE5MTg5MTAsOTYxMjQ1NzUzLDEyNTYxMDA5MzgsMTI4OTAwMTAzNiwxNDkxNjQ0NTA0LDM0Nzc3Njc2MzEsMzQ5NjcyMTM2MCw0MDEyNTU3ODA3LDI4NjcxNTQ4NTgsNDIxMjU4MzkzMSwxMTM3MDE4NDM1LDEzMDU5NzUzNzMsODYxMjM0NzM5LDIyNDEwNzM1NDEsMTE3MTIyOTI1Myw0MTc4NjM1MjU3LDMzOTQ4Njc0LDIxMzkyMjU3MjcsMTM1Nzk0Njk2MCwxMDExMTIwMTg4LDI2Nzk3NzY2NzEsMjgzMzQ2ODMyOCwxMzc0OTIxMjk3LDI3NTEzNTYzMjMsMTA4NjM1NzU2OCwyNDA4MTg3Mjc5LDI0NjA4Mjc1MzgsMjY0NjM1MjI4NSw5NDQyNzE0MTYsNDExMDc0MjAwNSwzMTY4NzU2NjY4LDMwNjYxMzI0MDYsMzY2NTE0NTgxOCw1NjAxNTMxMjEsMjcxNTg5MzkyLDQyNzk5NTI4OTUsNDA3Nzg0NjAwMywzNTMwNDA3ODkwLDM0NDQzNDMyNDUsMjAyNjQzNDY4LDMyMjI1MDI1OSwzOTYyNTUzMzI0LDE2MDg2Mjk4NTUsMjU0Mzk5MDE2NywxMTU0MjU0OTE2LDM4OTYyMzMxOSwzMjk0MDczNzk2LDI4MTc2NzY3MTEsMjEyMjUxMzUzNCwxMDI4MDk0NTI1LDE2ODkwNDUwOTIsMTU3NTQ2NzYxMyw0MjIyNjEyNzMsMTkzOTIwMzY5OSwxNjIxMTQ3NzQ0LDIxNzQyMjg4NjUsMTMzOTEzNzYxNSwzNjk5MzUyNTQwLDU3NzEyNzQ1OCw3MTI5MjIxNTQsMjQyNzE0MTAwOCwyMjkwMjg5NTQ0LDExODc2NzkzMDIsMzk5NTcxNTU2NiwzMTAwODYzNDE2LDMzOTQ4Njc0MCwzNzMyNTE0NzgyLDE1OTE5MTc2NjIsMTg2NDU1NTYzLDM2ODE5ODgwNTksMzc2MjAxOTI5Niw4NDQ1MjI1NDYsOTc4MjIwMDkwLDE2OTc0MzM3MCwxMjM5MTI2NjAxLDEwMTMyMTczNCw2MTEwNzYxMzIsMTU1ODQ5MzI3NiwzMjYwOTE1NjUwLDM1NDcyNTAxMzEsMjkwMTM2MTU4MCwxNjU1MDk2NDE4LDI0NDM3MjExMDUsMjUxMDU2NTc4MSwzODI4ODYzOTcyLDIwMzkyMTQ3MTMsMzg3ODg2ODQ1NSwzMzU5ODY5ODk2LDkyODYwNzc5OSwxODQwNzY1NTQ5LDIzNzQ3NjI4OTMsMzU4MDE0NjEzMywxMzIyNDI1NDIyLDI4NTAwNDg0MjUsMTgyMzc5MTIxMiwxNDU5MjY4Njk0LDQwOTQxNjE5MDgsMzkyODM0NjYwMiwxNzA2MDE5NDI5LDIwNTYxODkwNTAsMjkzNDUyMzgyMiwxMzU3OTQ2OTYsMzEzNDU0OTk0NiwyMDIyMjQwMzc2LDYyODA1MDQ2OSw3NzkyNDY2MzgsNDcyMTM1NzA4LDI4MDA4MzQ0NzAsMzAzMjk3MDE2NCwzMzI3MjM2MDM4LDM4OTQ2NjAwNzIsMzcxNTkzMjYzNywxOTU2NDQwMTgwLDUyMjI3MjI4NywxMjcyODEzMTMxLDMxODUzMzY3NjUsMjM0MDgxODMxNSwyMzIzOTc2MDc0LDE4ODg1NDI4MzIsMTA0NDU0NDU3NCwzMDQ5NTUwMjYxLDE3MjI0Njk0NzgsMTIyMjE1MjI2NCw1MDY2MDg2Nyw0MTI3MzI0MTUwLDIzNjA2Nzg1NCwxNjM4MTIyMDgxLDg5NTQ0NTU1NywxNDc1OTgwODg3LDMxMTc0NDM1MTMsMjI1NzY1NTY4NiwzMjQzODA5MjE3LDQ4OTExMDA0NSwyNjYyOTM0NDMwLDM3Nzg1OTkzOTMsNDE2MjA1NTE2MCwyNTYxODc4OTM2LDI4ODU2MzcyOSwxNzczOTE2Nzc3LDM2NDgwMzkzODUsMjM5MTM0NTAzOCwyNDkzOTg1Njg0LDI2MTI0MDc3MDcsNTA1NTYwMDk0LDIyNzQ0OTc5MjcsMzkxMTI0MDE2OSwzNDYwOTI1MzkwLDE0NDI4MTg2NDUsNjc4OTczNDgwLDM3NDkzNTcwMjMsMjM1ODE4Mjc5NiwyNzE3NDA3NjQ5LDIzMDY4Njk2NDEsMjE5NjE3ODA1LDMyMTg3NjExNTEsMzg2MjAyNjIxNCwxMTIwMzA2MjQyLDE3NTY5NDI0NDAsMTEwMzMzMTkwNSwyNTc4NDU5MDMzLDc2Mjc5NjU4OSwyNTI3ODAwNDcsMjk2NjEyNTQ4OCwxNDI1ODQ0MzA4LDMxNTEzOTIxODcsMzcyOTExMTI2XSx5PVsxNjY3NDc0ODg2LDIwODg1MzUyODgsMjAwNDMyNjg5NCwyMDcxNjk0ODM4LDQwNzU5NDk1NjcsMTgwMjIyMzA2MiwxODY5NTkxMDA2LDMzMTgwNDM3OTMsODA4NDcyNjcyLDE2ODQzNTIyLDE3MzQ4NDY5MjYsNzI0MjcwNDIyLDQyNzgwNjU2MzksMzYyMTIxNjk0OSwyODgwMTY5NTQ5LDE5ODc0ODQzOTYsMzQwMjI1MzcxMSwyMTg5NTk3OTgzLDMzODU0MDk2NzMsMjEwNTM3ODgxMCw0MjEwNjkzNjE1LDE0OTkwNjUyNjYsMTE5NTg4Njk5MCw0MDQyMjYzNTQ3LDI5MTM4NTY1NzcsMzU3MDY4OTk3MSwyNzI4NTkwNjg3LDI5NDc1NDE1NzMsMjYyNzUxODI0MywyNzYyMjc0NjQzLDE5MjAxMTIzNTYsMzIzMzgzMTgzNSwzMDgyMjczMzk3LDQyNjEyMjM2NDksMjQ3NTkyOTE0OSw2NDAwNTE3ODgsOTA5NTMxNzU2LDEwNjExMTAxNDIsNDE2MDE2MDUwMSwzNDM1OTQxNzYzLDg3NTg0Njc2MCwyNzc5MTE2NjI1LDM4NTcwMDM3MjksNDA1OTEwNTUyOSwxOTAzMjY4ODM0LDM2MzgwNjQwNDMsODI1MzE2MTk0LDM1MzcxMzk2Miw2NzM3NDA4OCwzMzUxNzI4Nzg5LDU4OTUyMjI0NiwzMjg0MzYwODYxLDQwNDIzNjMzNiwyNTI2NDU0MDcxLDg0MjE3NjEwLDI1OTM4MzAxOTEsMTE3OTAxNTgyLDMwMzE4MzM5NiwyMTU1OTExOTYzLDM4MDY0Nzc3OTEsMzk1ODA1NjY1Myw2NTY4OTQyODYsMjk5ODA2MjQ2MywxOTcwNjQyOTIyLDE1MTU5MTY5OCwyMjA2NDQwOTg5LDc0MTExMDg3Miw0Mzc5MjMzODAsNDU0NzY1ODc4LDE4NTI3NDg1MDgsMTUxNTkwODc4OCwyNjk0OTA0NjY3LDEzODExNjg4MDQsOTkzNzQyMTk4LDM2MDQzNzM5NDMsMzAxNDkwNTQ2OSw2OTA1ODQ0MDIsMzgyMzMyMDc5Nyw3OTE2MzgzNjYsMjIyMzI4MTkzOSwxMzk4MDExMzAyLDM1MjAxNjE5NzcsMCwzOTkxNzQzNjgxLDUzODk5MjcwNCw0MjQ0MzgxNjY3LDI5ODEyMTg0MjUsMTUzMjc1MTI4NiwxNzg1MzgwNTY0LDM0MTkwOTY3MTcsMzIwMDE3ODUzNSw5NjAwNTYxNzgsMTI0NjQyMDYyOCwxMjgwMTAzNTc2LDE0ODIyMjE3NDQsMzQ4NjQ2ODc0MSwzNTAzMzE5OTk1LDQwMjU0Mjg2NzcsMjg2MzMyNjU0Myw0MjI3NTM2NjIxLDExMjg1MTQ5NTAsMTI5Njk0NzA5OCw4NTkwMDIyMTQsMjI0MDEyMzkyMSwxMTYyMjAzMDE4LDQxOTM4NDk1NzcsMzM2ODcwNDQsMjEzOTA2Mjc4MiwxMzQ3NDgxNzYwLDEwMTA1ODI2NDgsMjY3ODA0NTIyMSwyODI5NjQwNTIzLDEzNjQzMjUyODIsMjc0NTQzMzY5MywxMDc3OTg1NDA4LDI0MDg1NDg4NjksMjQ1OTA4NjE0MywyNjQ0MzYwMjI1LDk0MzIxMjY1Niw0MTI2NDc1NTA1LDMxNjY0OTQ1NjMsMzA2NTQzMDM5MSwzNjcxNzUwMDYzLDU1NTgzNjIyNiwyNjk0OTYzNTIsNDI5NDkwODY0NSw0MDkyNzkyNTczLDM1MzcwMDYwMTUsMzQ1Mjc4Mzc0NSwyMDIxMTgxNjgsMzIwMDI1ODk0LDM5NzQ5MDE2OTksMTYwMDExOTIzMCwyNTQzMjk3MDc3LDExNDUzNTk0OTYsMzg3Mzk3OTM0LDMzMDEyMDE4MTEsMjgxMjgwMTYyMSwyMTIyMjIwMjg0LDEwMjc0MjYxNzAsMTY4NDMxOTQzMiwxNTY2NDM1MjU4LDQyMTA3OTg1OCwxOTM2OTU0ODU0LDE2MTY5NDUzNDQsMjE3Mjc1Mzk0NSwxMzMwNjMxMDcwLDM3MDU0MzgxMTUsNTcyNjc5NzQ4LDcwNzQyNzkyNCwyNDI1NDAwMTIzLDIyOTA2NDc4MTksMTE3OTA0NDQ5Miw0MDA4NTg1NjcxLDMwOTkxMjA0OTEsMzM2ODcwNDQwLDM3MzkxMjIwODcsMTU4MzI3NjczMiwxODUyNzc3MTgsMzY4ODU5MzA2OSwzNzcyNzkxNzcxLDg0MjE1OTcxNiw5NzY4OTk3MDAsMTY4NDM1MjIwLDEyMjk1NzcxMDYsMTAxMDU5MDg0LDYwNjM2Njc5MiwxNTQ5NTkxNzM2LDMyNjc1MTc4NTUsMzU1Mzg0OTAyMSwyODk3MDE0NTk1LDE2NTA2MzIzODgsMjQ0MjI0MjEwNSwyNTA5NjEyMDgxLDM4NDAxNjE3NDcsMjAzODAwODgxOCwzODkwNjg4NzI1LDMzNjg1Njc2OTEsOTI2Mzc0MjU0LDE4MzU5MDcwMzQsMjM3NDg2Mzg3MywzNTg3NTMxOTUzLDEzMTM3ODg1NzIsMjg0NjQ4MjUwNSwxODE5MDYzNTEyLDE0NDg1NDA4NDQsNDEwOTYzMzUyMywzOTQxMjEzNjQ3LDE3MDExNjI5NTQsMjA1NDg1MjM0MCwyOTMwNjk4NTY3LDEzNDc0ODE3NiwzMTMyODA2NTExLDIwMjExNjUyOTYsNjIzMjEwMzE0LDc3NDc5NTg2OCw0NzE2MDYzMjgsMjc5NTk1ODYxNSwzMDMxNzQ2NDE5LDMzMzQ4ODU3ODMsMzkwNzUyNzYyNywzNzIyMjgwMDk3LDE5NTM3OTk0MDAsNTIyMTMzODIyLDEyNjMyNjMxMjYsMzE4MzMzNjU0NSwyMzQxMTc2ODQ1LDIzMjQzMzM4MzksMTg4NjQyNTMxMiwxMDQ0MjY3NjQ0LDMwNDg1ODg0MDEsMTcxODAwNDQyOCwxMjEyNzMzNTg0LDUwNTI5NTQyLDQxNDMzMTc0OTUsMjM1ODAzMTY0LDE2MzM3ODg4NjYsODkyNjkwMjgyLDE0NjUzODMzNDIsMzExNTk2MjQ3MywyMjU2OTY1OTExLDMyNTA2NzM4MTcsNDg4NDQ5ODUwLDI2NjEyMDIyMTUsMzc4OTYzMzc1Myw0MTc3MDA3NTk1LDI1NjAxNDQxNzEsMjg2MzM5ODc0LDE3Njg1MzcwNDIsMzY1NDkwNjAyNSwyMzkxNzA1ODYzLDI0OTI3NzAwOTksMjYxMDY3MzE5Nyw1MDUyOTEzMjQsMjI3MzgwODkxNywzOTI0MzY5NjA5LDM0Njk2MjU3MzUsMTQzMTY5OTM3MCw2NzM3NDA4ODAsMzc1NTk2NTA5MywyMzU4MDIxODkxLDI3MTE3NDY2NDksMjMwNzQ4OTgwMSwyMTg5NjE2OTAsMzIxNzAyMTU0MSwzODczODQ1NzE5LDExMTE2NzI0NTIsMTc1MTY5MzUyMCwxMDk0ODI4OTMwLDI1NzY5ODYxNTMsNzU3OTU0Mzk0LDI1MjY0NTY2MiwyOTY0Mzc2NDQzLDE0MTQ4NTU4NDgsMzE0OTY0OTUxNywzNzA1NTU0MzZdLG09WzEzNzQ5ODgxMTIsMjExODIxNDk5NSw0Mzc3NTcxMjMsOTc1NjU4NjQ2LDEwMDEwODk5OTUsNTMwNDAwNzUzLDI5MDIwODc4NTEsMTI3MzE2ODc4Nyw1NDAwODA3MjUsMjkxMDIxOTc2NiwyMjk1MTAxMDczLDQxMTA1Njg0ODUsMTM0MDQ2MzEwMCwzMzA3OTE2MjQ3LDY0MTAyNTE1MiwzMDQzMTQwNDk1LDM3MzYxNjQ5MzcsNjMyOTUzNzAzLDExNzI5NjcwNjQsMTU3Njk3NjYwOSwzMjc0NjY3MjY2LDIxNjkzMDMwNTgsMjM3MDIxMzc5NSwxODA5MDU0MTUwLDU5NzI3ODQ3LDM2MTkyOTg3NywzMjExNjIzMTQ3LDI1MDUyMDIxMzgsMzU2OTI1NTIxMywxNDg0MDA1ODQzLDEyMzk0NDM3NTMsMjM5NTU4ODY3NiwxOTc1NjgzNDM0LDQxMDI5Nzc5MTIsMjU3MjY5NzE5NSw2NjY0NjQ3MzMsMzIwMjQzNzA0Niw0MDM1NDg5MDQ3LDMzNzQzNjE3MDIsMjExMDY2NzQ0NCwxNjc1NTc3ODgwLDM4NDM2OTkwNzQsMjUzODY4MTE4NCwxNjQ5NjM5MjM3LDI5NzYxNTE1MjAsMzE0NDM5NjQyMCw0MjY5OTA3OTk2LDQxNzgwNjIyMjgsMTg4Mzc5MzQ5NiwyNDAzNzI4NjY1LDI0OTc2MDQ3NDMsMTM4Mzg1NjMxMSwyODc2NDk0NjI3LDE5MTc1MTg1NjIsMzgxMDQ5NjM0MywxNzE2ODkwNDEwLDMwMDE3NTU2NTUsODAwNDQwODM1LDIyNjEwODkxNzgsMzU0MzU5OTI2OSw4MDc5NjI2MTAsNTk5NzYyMzU0LDMzNzc4MzYyLDM5Nzc2NzUzNTYsMjMyODgyODk3MSwyODA5NzcxMTU0LDQwNzczODQ0MzIsMTMxNTU2MjE0NSwxNzA4ODQ4MzMzLDEwMTAzOTgyOSwzNTA5ODcxMTM1LDMyOTkyNzg0NzQsODc1NDUxMjkzLDI3MzM4NTYxNjAsOTI5ODc2OTgsMjc2NzY0NTU1NywxOTMxOTUwNjUsMTA4MDA5NDYzNCwxNTg0NTA0NTgyLDMxNzgxMDY5NjEsMTA0MjM4NTY1NywyNTMxMDY3NDUzLDM3MTE4Mjk0MjIsMTMwNjk2NzM2NiwyNDM4MjM3NjIxLDE5MDg2OTQyNzcsNjc1NTY0NjMsMTYxNTg2MTI0Nyw0Mjk0NTYxNjQsMzYwMjc3MDMyNywyMzAyNjkwMjUyLDE3NDIzMTUxMjcsMjk2ODAxMTQ1MywxMjY0NTQ2NjQsMzg3NzE5ODY0OCwyMDQzMjExNDgzLDI3MDkyNjA4NzEsMjA4NDcwNDIzMyw0MTY5NDA4MjAxLDAsMTU5NDE3OTg3LDg0MTczOTU5Miw1MDQ0NTk0MzYsMTgxNzg2NjgzMCw0MjQ1NjE4NjgzLDI2MDM4ODk1MCwxMDM0ODY3OTk4LDkwODkzMzQxNSwxNjg4MTA4NTIsMTc1MDkwMjMwNSwyNjA2NDUzOTY5LDYwNzUzMDU1NCwyMDIwMDg0OTcsMjQ3MjAxMTUzNSwzMDM1NTM1MDU4LDQ2MzE4MDE5MCwyMTYwMTE3MDcxLDE2NDE4MTYyMjYsMTUxNzc2NzUyOSw0NzA5NDgzNzQsMzgwMTMzMjIzNCwzMjMxNzIyMjEzLDEwMDg5MTg1OTUsMzAzNzY1Mjc3LDIzNTQ3NDE4Nyw0MDY5MjQ2ODkzLDc2Njk0NTQ2NSwzMzc1NTM4NjQsMTQ3NTQxODUwMSwyOTQzNjgyMzgwLDQwMDMwNjExNzksMjc0MzAzNDEwOSw0MTQ0MDQ3Nzc1LDE1NTEwMzc4ODQsMTE0NzU1MDY2MSwxNTQzMjA4NTAwLDIzMzY0MzQ1NTAsMzQwODExOTUxNiwzMDY5MDQ5OTYwLDMxMDIwMTE3NDcsMzYxMDM2OTIyNiwxMTEzODE4Mzg0LDMyODY3MTgwOCwyMjI3NTczMDI0LDIyMzYyMjg3MzMsMzUzNTQ4NjQ1NiwyOTM1NTY2ODY1LDMzNDEzOTQyODUsNDk2OTA2MDU5LDM3MDI2NjU0NTksMjI2OTA2ODYwLDIwMDkxOTU0NzIsNzMzMTU2OTcyLDI4NDI3MzcwNDksMjk0OTMwNjgyLDEyMDY0Nzc4NTgsMjgzNTEyMzM5NiwyNzAwMDk5MzU0LDE0NTEwNDQwNTYsNTczODA0NzgzLDIyNjk3Mjg0NTUsMzY0NDM3OTU4NSwyMzYyMDkwMjM4LDI1NjQwMzMzMzQsMjgwMTEwNzQwNywyNzc2MjkyOTA0LDM2Njk0NjI1NjYsMTA2ODM1MTM5Niw3NDIwMzkwMTIsMTM1MDA3ODk4OSwxNzg0NjYzMTk1LDE0MTc1NjE2OTgsNDEzNjQ0MDc3MCwyNDMwMTIyMjE2LDc3NTU1MDgxNCwyMTkzODYyNjQ1LDI2NzM3MDUxNTAsMTc3NTI3NjkyNCwxODc2MjQxODMzLDM0NzUzMTMzMzEsMzM2Njc1NDYxOSwyNzAwNDA0ODcsMzkwMjU2MzE4MiwzNjc4MTI0OTIzLDM0NDE4NTAzNzcsMTg1MTMzMjg1MiwzOTY5NTYyMzY5LDIyMDMwMzIyMzIsMzg2ODU1MjgwNSwyODY4ODk3NDA2LDU2NjAyMTg5Niw0MDExMTkwNTAyLDMxMzU3NDA4ODksMTI0ODgwMjUxMCwzOTM2MjkxMjg0LDY5OTQzMjE1MCw4MzI4NzcyMzEsNzA4NzgwODQ5LDMzMzI3NDAxNDQsODk5ODM1NTg0LDE5NTEzMTcwNDcsNDIzNjQyOTk5MCwzNzY3NTg2OTkyLDg2NjYzNzg0NSw0MDQzNjEwMTg2LDExMDYwNDE1OTEsMjE0NDE2MTgwNiwzOTU0NDE3MTEsMTk4NDgxMjY4NSwxMTM5NzgxNzA5LDM0MzM3MTI5ODAsMzgzNTAzNjg5NSwyNjY0NTQzNzE1LDEyODIwNTAwNzUsMzI0MDg5NDM5MiwxMTgxMDQ1MTE5LDI2NDAyNDMyMDQsMjU5NjU5MTcsNDIwMzE4MTE3MSw0MjExODE4Nzk4LDMwMDk4NzkzODYsMjQ2Mzg3OTc2MiwzOTEwMTYxOTcxLDE4NDI3NTk0NDMsMjU5NzgwNjQ3Niw5MzMzMDEzNzAsMTUwOTQzMDQxNCwzOTQzOTA2NDQxLDM0NjcxOTIzMDIsMzA3NjYzOTAyOSwzNzc2NzY3NDY5LDIwNTE1MTg3ODAsMjYzMTA2NTQzMywxNDQxOTUyNTc1LDQwNDAxNjc2MSwxOTQyNDM1Nzc1LDE0MDg3NDkwMzQsMTYxMDQ1OTczOSwzNzQ1MzQ1MzAwLDIwMTc3Nzg1NjYsMzQwMDUyODc2OSwzMTEwNjUwOTQyLDk0MTg5Njc0OCwzMjY1NDc4NzUxLDM3MTA0OTMzMCwzMTY4OTM3MjI4LDY3NTAzOTYyNyw0Mjc5MDgwMjU3LDk2NzMxMTcyOSwxMzUwNTAyMDYsMzYzNTczMzY2MCwxNjgzNDA3MjQ4LDIwNzY5MzUyNjUsMzU3Njg3MDUxMiwxMjE1MDYxMTA4LDM1MDE3NDE4OTBdLGc9WzEzNDc1NDgzMjcsMTQwMDc4MzIwNSwzMjczMjY3MTA4LDI1MjAzOTM1NjYsMzQwOTY4NTM1NSw0MDQ1MzgwOTMzLDI4ODAyNDAyMTYsMjQ3MTIyNDA2NywxNDI4MTczMDUwLDQxMzg1NjMxODEsMjQ0MTY2MTU1OCw2MzY4MTM5MDAsNDIzMzA5NDYxNSwzNjIwMDIyOTg3LDIxNDk5ODc2NTIsMjQxMTAyOTE1NSwxMjM5MzMxMTYyLDE3MzA1MjU3MjMsMjU1NDcxODczNCwzNzgxMDMzNjY0LDQ2MzQ2MTAxLDMxMDQ2MzcyOCwyNzQzOTQ0ODU1LDMzMjg5NTUzODUsMzg3NTc3MDIwNywyNTAxMjE4OTcyLDM5NTUxOTExNjIsMzY2NzIxOTAzMyw3Njg5MTcxMjMsMzU0NTc4OTQ3Myw2OTI3MDc0MzMsMTE1MDIwODQ1NiwxNzg2MTAyNDA5LDIwMjkyOTMxNzcsMTgwNTIxMTcxMCwzNzEwMzY4MTEzLDMwNjU5NjI4MzEsNDAxNjM5NTk3LDE3MjQ0NTcxMzIsMzAyODE0MzY3NCw0MDkxOTg0MTAsMjE5NjA1MjUyOSwxNjIwNTI5NDU5LDExNjQwNzE4MDcsMzc2OTcyMTk3NSwyMjI2ODc1MzEwLDQ4NjQ0MTM3NiwyNDk5MzQ4NTIzLDE0ODM3NTM1NzYsNDI4ODE5OTY1LDIyNzQ2ODA0MjgsMzA3NTYzNjIxNiw1OTg0Mzg4NjcsMzc5OTE0MTEyMiwxNDc0NTAyNTQzLDcxMTM0OTY3NSwxMjkxNjYxMjAsNTM0NTgzNzAsMjU5MjUyMzY0MywyNzgyMDgyODI0LDQwNjMyNDIzNzUsMjk4ODY4NzI2OSwzMTIwNjk0MTIyLDE1NTkwNDE2NjYsNzMwNTE3Mjc2LDI0NjA0NDkyMDQsNDA0MjQ1OTEyMiwyNzA2MjcwNjkwLDM0NDYwMDQ0NjgsMzU3Mzk0MTY5NCw1MzM4MDQxMzAsMjMyODE0MzYxNCwyNjM3NDQyNjQzLDI2OTUwMzM2ODUsODM5MjI0MDMzLDE5NzM3NDUzODcsOTU3MDU1OTgwLDI4NTYzNDU4MzksMTA2ODUyNzY3LDEzNzEzNjg5NzYsNDE4MTU5ODYwMiwxMDMzMjk3MTU4LDI5MzM3MzQ5MTcsMTE3OTUxMDQ2MSwzMDQ2MjAwNDYxLDkxMzQxOTE3LDE4NjI1MzQ4NjgsNDI4NDUwMjAzNyw2MDU2NTczMzksMjU0NzQzMjkzNywzNDMxNTQ2OTQ3LDIwMDMyOTQ2MjIsMzE4MjQ4NzYxOCwyMjgyMTk1MzM5LDk1NDY2OTQwMywzNjgyMTkxNTk4LDEyMDE3NjUzODYsMzkxNzIzNDcwMywzMzg4NTA3MTY2LDAsMjE5ODQzODAyMiwxMjExMjQ3NTk3LDI4ODc2NTE2OTYsMTMxNTcyMzg5MCw0MjI3NjY1NjYzLDE0NDM4NTc3MjAsNTA3MzU4OTMzLDY1Nzg2MTk0NSwxNjc4MzgxMDE3LDU2MDQ4NzU5MCwzNTE2NjE5NjA0LDk3NTQ1MTY5NCwyOTcwMzU2MzI3LDI2MTMxNDUzNSwzNTM1MDcyOTE4LDI2NTI2MDk0MjUsMTMzMzgzODAyMSwyNzI0MzIyMzM2LDE3Njc1MzY0NTksMzcwOTM4Mzk0LDE4MjYyMTExNCwzODU0NjA2Mzc4LDExMjgwMTQ1NjAsNDg3NzI1ODQ3LDE4NTQ2OTE5NywyOTE4MzUzODYzLDMxMDY3ODA4NDAsMzM1Njc2MTc2OSwyMjM3MTMzMDgxLDEyODY1NjcxNzUsMzE1Mjk3NjM0OSw0MjU1MzUwNjI0LDI2ODM3NjUwMzAsMzE2MDE3NTM0OSwzMzA5NTk0MTcxLDg3ODQ0MzM5MCwxOTg4ODM4MTg1LDM3MDQzMDA0ODYsMTc1NjgxODk0MCwxNjczMDYxNjE3LDM0MDMxMDA2MzYsMjcyNzg2MzA5LDEwNzUwMjU2OTgsNTQ1NTcyMzY5LDIxMDU4ODcyNjgsNDE3NDU2MDA2MSwyOTY2Nzk3MzAsMTg0MTc2ODg2NSwxMjYwMjMyMjM5LDQwOTEzMjcwMjQsMzk2MDMwOTMzMCwzNDk3NTA5MzQ3LDE4MTQ4MDMyMjIsMjU3ODAxODQ4OSw0MTk1NDU2MDcyLDU3NTEzODE0OCwzMjk5NDA5MDM2LDQ0Njc1NDg3OSwzNjI5NTQ2Nzk2LDQwMTE5OTYwNDgsMzM0NzUzMjExMCwzMjUyMjM4NTQ1LDQyNzA2Mzk3NzgsOTE1OTg1NDE5LDM0ODM4MjU1MzcsNjgxOTMzNTM0LDY1MTg2ODA0NiwyNzU1NjM2NjcxLDM4MjgxMDM4MzcsMjIzMzc3NTU0LDI2MDc0Mzk4MjAsMTY0OTcwNDUxOCwzMjcwOTM3ODc1LDM5MDE4MDY3NzYsMTU4MDA4Nzc5OSw0MTE4OTg3Njk1LDMxOTgxMTUyMDAsMjA4NzMwOTQ1OSwyODQyNjc4NTczLDMwMTY2OTcxMDYsMTAwMzAwNzEyOSwyODAyODQ5OTE3LDE4NjA3MzgxNDcsMjA3Nzk2NTI0MywxNjQ0Mzk2NzIsNDEwMDg3MjQ3MiwzMjI4MzMxOSwyODI3MTc3ODgyLDE3MDk2MTAzNTAsMjEyNTEzNTg0NiwxMzY0Mjg3NTEsMzg3NDQyODM5MiwzNjUyOTA0ODU5LDM0NjA5ODQ2MzAsMzU3MjE0NTkyOSwzNTkzMDU2MzgwLDI5MzkyNjYyMjYsODI0ODUyMjU5LDgxODMyNDg4NCwzMjI0NzQwNDU0LDkzMDM2OTIxMiwyODAxNTY2NDEwLDI5Njc1MDcxNTIsMzU1NzA2ODQwLDEyNTczMDkzMzYsNDE0ODI5MjgyNiwyNDMyNTY2NTYsNzkwMDczODQ2LDIzNzMzNDA2MzAsMTI5NjI5NzkwNCwxNDIyNjk5MDg1LDM3NTYyOTk3ODAsMzgxODgzNjQwNSw0NTc5OTI4NDAsMzA5OTY2NzQ4NywyMTM1MzE5ODg5LDc3NDIyMzE0LDE1NjAzODI1MTcsMTk0NTc5ODUxNiw3ODgyMDQzNTMsMTUyMTcwNjc4MSwxMzg1MzU2MjQyLDg3MDkxMjA4NiwzMjU5NjUzODMsMjM1ODk1NzkyMSwyMDUwNDY2MDYwLDIzODgyNjA4ODQsMjMxMzg4NDQ3Niw0MDA2NTIxMTI3LDkwMTIxMDU2OSwzOTkwOTUzMTg5LDEwMTQ2NDY3MDUsMTUwMzQ0OTgyMywxMDYyNTk3MjM1LDIwMzE2MjEzMjYsMzIxMjAzNTg5NSwzOTMxMzcxNDY5LDE1MzMwMTc1MTQsMzUwMTc0NTc1LDIyNTYwMjg4OTEsMjE3NzU0NDE3OSwxMDUyMzM4MzcyLDc0MTg3Njc4OCwxNjA2NTkxMjk2LDE5MTQwNTIwMzUsMjEzNzA1MjUzLDIzMzQ2Njk4OTcsMTEwNzIzNDE5NywxODk5NjAzOTY5LDM3MjUwNjk0OTEsMjYzMTQ0Nzc4MCwyNDIyNDk0OTEzLDE2MzU1MDI5ODAsMTg5MzAyMDM0MiwxOTUwOTAzMzg4LDExMjA5NzQ5MzVdLGI9WzI4MDcwNTg5MzIsMTY5OTk3MDYyNSwyNzY0MjQ5NjIzLDE1ODY5MDM1OTEsMTgwODQ4MTE5NSwxMTczNDMwMTczLDE0ODc2NDU5NDYsNTk5ODQ4NjcsNDE5OTg4MjgwMCwxODQ0ODgyODA2LDE5ODkyNDkyMjgsMTI3NzU1NTk3MCwzNjIzNjM2OTY1LDM0MTk5MTU1NjIsMTE0OTI0OTA3NywyNzQ0MTA0MjkwLDE1MTQ3OTA1NzcsNDU5NzQ0Njk4LDI0NDg2MDM5NCwzMjM1OTk1MTM0LDE5NjMxMTUzMTEsNDAyNzc0NDU4OCwyNTQ0MDc4MTUwLDQxOTA1MzA1MTUsMTYwODk3NTI0NywyNjI3MDE2MDgyLDIwNjIyNzAzMTcsMTUwNzQ5NzI5OCwyMjAwODE4ODc4LDU2NzQ5ODg2OCwxNzY0MzEzNTY4LDMzNTk5MzYyMDEsMjMwNTQ1NTU1NCwyMDM3OTcwMDYyLDEwNDcyMzllMywxOTEwMzE5MDMzLDEzMzczNzY0ODEsMjkwNDAyNzI3MiwyODkyNDE3MzEyLDk4NDkwNzIxNCwxMjQzMTEyNDE1LDgzMDY2MTkxNCw4NjE5NjgyMDksMjEzNTI1MzU4NywyMDExMjE0MTgwLDI5Mjc5MzQzMTUsMjY4NjI1NDcyMSw3MzExODMzNjgsMTc1MDYyNjM3Niw0MjQ2MzEwNzI1LDE4MjA4MjQ3OTgsNDE3Mjc2Mzc3MSwzNTQyMzMwMjI3LDQ4Mzk0ODI3LDI0MDQ5MDE2NjMsMjg3MTY4MjY0NSw2NzE1OTMxOTUsMzI1NDk4ODcyNSwyMDczNzI0NjEzLDE0NTA4NTIzOSwyMjgwNzk2MjAwLDI3Nzk5MTUxOTksMTc5MDU3NTEwNywyMTg3MTI4MDg2LDQ3MjYxNTYzMSwzMDI5NTEwMDA5LDQwNzU4NzcxMjcsMzgwMjIyMjE4NSw0MTA3MTAxNjU4LDMyMDE2MzE3NDksMTY0NjI1MjM0MCw0MjcwNTA3MTc0LDE0MDI4MTE0MzgsMTQzNjU5MDgzNSwzNzc4MTUxODE4LDM5NTAzNTU3MDIsMzk2MzE2MTQ3NSw0MDIwOTEyMjI0LDI2Njc5OTQ3MzcsMjczNzkyMzY2LDIzMzE1OTAxNzcsMTA0Njk5NjEzLDk1MzQ1OTgyLDMxNzU1MDEyODYsMjM3NzQ4NjY3NiwxNTYwNjM3ODkyLDM1NjQwNDUzMTgsMzY5MDU3ODcyLDQyMTM0NDcwNjQsMzkxOTA0MjIzNywxMTM3NDc3OTUyLDI2NTg2MjU0OTcsMTExOTcyNzg0OCwyMzQwOTQ3ODQ5LDE1MzA0NTU4MzMsNDAwNzM2MDk2OCwxNzI0NjY1NTYsMjY2OTU5OTM4LDUxNjU1MjgzNiwwLDIyNTY3MzQ1OTIsMzk4MDkzMTYyNywxODkwMzI4MDgxLDE5MTc3NDIxNzAsNDI5NDcwNDM5OCw5NDUxNjQxNjUsMzU3NTUyODg3OCw5NTg4NzEwODUsMzY0NzIxMjA0NywyNzg3MjA3MjYwLDE0MjMwMjI5MzksNzc1NTYyMjk0LDE3Mzk2NTYyMDIsMzg3NjU1NzY1NSwyNTMwMzkxMjc4LDI0NDMwNTgwNzUsMzMxMDMyMTg1Niw1NDc1MTI3OTYsMTI2NTE5NTYzOSw0Mzc2NTY1OTQsMzEyMTI3NTUzOSw3MTk3MDAxMjgsMzc2MjUwMjY5MCwzODc3ODExNDcsMjE4ODI4Mjk3LDMzNTAwNjU4MDMsMjgzMDcwODE1MCwyODQ4NDYxODU0LDQyODE2OTIwMSwxMjI0NjYxNjUsMzcyMDA4MTA0OSwxNjI3MjM1MTk5LDY0ODAxNzY2NSw0MTIyNzYyMzU0LDEwMDI3ODM4NDYsMjExNzM2MDYzNSw2OTU2MzQ3NTUsMzMzNjM1ODY5MSw0MjM0NzIxMDA1LDQwNDk4NDQ0NTIsMzcwNDI4MDg4MSwyMjMyNDM1Mjk5LDU3NDYyNDY2MywyODczNDM4MTQsNjEyMjA1ODk4LDEwMzk3MTcwNTEsODQwMDE5NzA1LDI3MDgzMjYxODUsNzkzNDUxOTM0LDgyMTI4ODExNCwxMzkxMjAxNjcwLDM4MjIwOTAxNzcsMzc2MTg3ODI3LDMxMTM4NTUzNDQsMTIyNDM0ODA1MiwxNjc5OTY4MjMzLDIzNjE2OTg1NTYsMTA1ODcwOTc0NCw3NTIzNzU0MjEsMjQzMTU5MDk2MywxMzIxNjk5MTQ1LDM1MTkxNDIyMDAsMjczNDU5MTE3OCwxODgxMjc0NDQsMjE3Nzg2OTU1NywzNzI3MjA1NzU0LDIzODQ5MTEwMzEsMzIxNTIxMjQ2MSwyNjQ4OTc2NDQyLDI0NTAzNDYxMDQsMzQzMjczNzM3NSwxMTgwODQ5Mjc4LDMzMTU0NDIwNSwzMTAyMjQ5MTc2LDQxNTAxNDQ1NjksMjk1MjEwMjU5NSwyMTU5OTc2Mjg1LDI0NzQ0MDQzMDQsNzY2MDc4OTMzLDMxMzc3Mzg2MSwyNTcwODMyMDQ0LDIxMDgxMDA2MzIsMTY2ODIxMjg5MiwzMTQ1NDU2NDQzLDIwMTM5MDgyNjIsNDE4NjcyMjE3LDMwNzAzNTY2MzQsMjU5NDczNDkyNywxODUyMTcxOTI1LDM4NjcwNjA5OTEsMzQ3MzQxNjYzNiwzOTA3NDQ4NTk3LDI2MTQ3Mzc2MzksOTE5NDg5MTM1LDE2NDk0ODYzOSwyMDk0NDEwMTYwLDI5OTc4MjU5NTYsNTkwNDI0NjM5LDI0ODYyMjQ1NDksMTcyMzg3MjY3NCwzMTU3NzUwODYyLDMzOTk5NDEyNTAsMzUwMTI1Mjc1MiwzNjI1MjY4MTM1LDI1NTUwNDgxOTYsMzY3MzYzNzM1NiwxMzQzMTI3NTAxLDQxMzAyODEzNjEsMzU5OTU5NTA4NSwyOTU3ODUzNjc5LDEyOTc0MDMwNTAsODE3ODE5MTAsMzA1MTU5MzQyNSwyMjgzNDkwNDEwLDUzMjIwMTc3MiwxMzY3Mjk1NTg5LDM5MjYxNzA5NzQsODk1Mjg3NjkyLDE5NTM3NTc4MzEsMTA5MzU5Nzk2Myw0OTI0ODM0MzEsMzUyODYyNjkwNywxNDQ2MjQyNTc2LDExOTI0NTU2MzgsMTYzNjYwNDYzMSwyMDkzMzYyMjUsMzQ0ODczNDY0LDEwMTU2NzE1NzEsNjY5OTYxODk3LDMzNzU3NDA3NjksMzg1NzU3MjEyNCwyOTczNTMwNjk1LDM3NDcxOTIwMTgsMTkzMzUzMDYxMCwzNDY0MDQyNTE2LDkzNTI5Mzg5NSwzNDU0Njg2MTk5LDI4NTgxMTUwNjksMTg2MzYzODg0NSwzNjgzMDIyOTE2LDQwODUzNjk1MTksMzI5MjQ0NTAzMiw4NzUzMTMxODgsMTA4MDAxNzU3MSwzMjc5MDMzODg1LDYyMTU5MTc3OCwxMjMzODU2NTcyLDI1MDQxMzAzMTcsMjQxOTc1NDQsMzAxNzY3MjcxNiwzODM1NDg0MzQwLDMyNDc0NjU1NTgsMjIyMDk4MTE5NSwzMDYwODQ3OTIyLDE1NTExMjQ1ODgsMTQ2Mzk5NjYwMF0sdz1bNDEwNDYwNTc3NywxMDk3MTU5NTUwLDM5NjY3MzgxOCw2NjA1MTAyNjYsMjg3NTk2ODMxNSwyNjM4NjA2NjIzLDQyMDAxMTUxMTYsMzgwODY2MjM0Nyw4MjE3MTIxNjAsMTk4NjkxODA2MSwzNDMwMzIyNTY4LDM4NTQ0ODg1LDM4NTYxMzcyOTUsNzE4MDAyMTE3LDg5MzY4MTcwMiwxNjU0ODg2MzI1LDI5NzU0ODQzODIsMzEyMjM1ODA1MywzOTI2ODI1MDI5LDQyNzQwNTM0NjksNzk2MTk3NTcxLDEyOTA4MDE3OTMsMTE4NDM0MjkyNSwzNTU2MzYxODM1LDI0MDU0MjY5NDcsMjQ1OTczNTMxNywxODM2NzcyMjg3LDEzODE2MjAzNzMsMzE5NjI2Nzk4OCwxOTQ4MzczODQ4LDM3NjQ5ODgyMzMsMzM4NTM0NTE2NiwzMjYzNzg1NTg5LDIzOTAzMjU0OTIsMTQ4MDQ4NTc4NSwzMTExMjQ3MTQzLDM3ODAwOTc3MjYsMjI5MzA0NTIzMiw1NDgxNjk0MTcsMzQ1OTk1Mzc4OSwzNzQ2MTc1MDc1LDQzOTQ1MjM4OSwxMzYyMzIxNTU5LDE0MDA4NDk3NjIsMTY4NTU3NzkwNSwxODA2NTk5MzU1LDIxNzQ3NTQwNDYsMTM3MDczOTEzLDEyMTQ3OTc5MzYsMTE3NDIxNTA1NSwzNzMxNjU0NTQ4LDIwNzk4OTc0MjYsMTk0MzIxNzA2NywxMjU4NDgwMjQyLDUyOTQ4Nzg0MywxNDM3MjgwODcwLDM5NDUyNjkxNzAsMzA0OTM5MDg5NSwzMzEzMjEyMDM4LDkyMzMxMzYxOSw2Nzk5OThlMywzMjE1MzA3Mjk5LDU3MzI2MDgyLDM3NzY0MjIyMSwzNDc0NzI5ODY2LDIwNDE4NzcxNTksMTMzMzYxOTA3LDE3NzY0NjAxMTAsMzY3MzQ3NjQ1Myw5NjM5MjQ1NCw4Nzg4NDU5MDUsMjgwMTY5OTUyNCw3NzcyMzE2NjgsNDA4MjQ3NTE3MCwyMzMwMDE0MjEzLDQxNDI2MjYyMTIsMjIxMzI5NjM5NSwxNjI2MzE5NDI0LDE5MDYyNDcyNjIsMTg0NjU2MzI2MSw1NjI3NTU5MDIsMzcwODE3MzcxOCwxMDQwNTU5ODM3LDM4NzExNjM5ODEsMTQxODU3MzIwMSwzMjk0NDMwNTc3LDExNDU4NTM0OCwxMzQzNjE4OTEyLDI1NjY1OTU2MDksMzE4NjIwMjU4MiwxMDc4MTg1MDk3LDM2NTEwNDExMjcsMzg5NjY4ODA0OCwyMzA3NjIyOTE5LDQyNTQwODc0MywzMzcxMDk2OTUzLDIwODEwNDg0ODEsMTEwODMzOTA2OCwyMjE2NjEwMjk2LDAsMjE1NjI5OTAxNyw3MzY5NzA4MDIsMjkyNTk2NzY2LDE1MTc0NDA2MjAsMjUxNjU3MjEzLDIyMzUwNjE3NzUsMjkzMzIwMjQ5Myw3NTg3MjAzMTAsMjY1OTA1MTYyLDE1NTQzOTE0MDAsMTUzMjI4NTMzOSw5MDg5OTkyMDQsMTc0NTY3NjkyLDE0NzQ3NjA1OTUsNDAwMjg2MTc0OCwyNjEwMDExNjc1LDMyMzQxNTY0MTYsMzY5MzEyNjI0MSwyMDAxNDMwODc0LDMwMzY5OTQ4NCwyNDc4NDQzMjM0LDI2ODcxNjU4ODgsNTg1MTIyNjIwLDQ1NDQ5OTYwMiwxNTE4NDk3NDIsMjM0NTExOTIxOCwzMDY0NTEwNzY1LDUxNDQ0MzI4NCw0MDQ0OTgxNTkxLDE5NjM0MTI2NTUsMjU4MTQ0NTYxNCwyMTM3MDYyODE5LDE5MzA4NTM1LDE5Mjg3MDcxNjQsMTcxNTE5MzE1Niw0MjE5MzUyMTU1LDExMjY3OTA3OTUsNjAwMjM1MjExLDM5OTI3NDIwNzAsMzg0MTAyNDk1Miw4MzY1NTM0MzEsMTY2OTY2NDgzNCwyNTM1NjA0MjQzLDMzMjMwMTEyMDQsMTI0MzkwNTQxMywzMTQxNDAwNzg2LDQxODA4MDgxMTAsNjk4NDQ1MjU1LDI2NTM4OTk1NDksMjk4OTU1MjYwNCwyMjUzNTgxMzI1LDMyNTI5MzI3MjcsMzAwNDU5MTE0NywxODkxMjExNjg5LDI0ODc4MTA1NzcsMzkxNTY1MzcwMyw0MjM3MDgzODE2LDQwMzA2Njc0MjQsMjEwMDA5MDk2Niw4NjUxMzY0MTgsMTIyOTg5OTY1NSw5NTMyNzA3NDUsMzM5OTY3OTYyOCwzNTU3NTA0NjY0LDQxMTg5MjUyMjIsMjA2MTM3OTc0OSwzMDc5NTQ2NTg2LDI5MTUwMTc3OTEsOTgzNDI2MDkyLDIwMjI4Mzc1ODQsMTYwNzI0NDY1MCwyMTE4NTQxOTA4LDIzNjY4ODI1NTAsMzYzNTk5NjgxNiw5NzI1MTI4MTQsMzI4MzA4ODc3MCwxNTY4NzE4NDk1LDM0OTkzMjY1NjksMzU3NjUzOTUwMyw2MjE5ODI2NzEsMjg5NTcyMzQ2NCw0MTA4ODc5NTIsMjYyMzc2MjE1MiwxMDAyMTQyNjgzLDY0NTQwMTAzNywxNDk0ODA3NjYyLDI1OTU2ODQ4NDQsMTMzNTUzNTc0NywyNTA3MDQwMjMwLDQyOTMyOTU3ODYsMzE2NzY4NDY0MSwzNjc1ODUwMDcsMzg4NTc1MDcxNCwxODY1ODYyNzMwLDI2NjgyMjE2NzQsMjk2MDk3MTMwNSwyNzYzMTczNjgxLDEwNTkyNzA5NTQsMjc3Nzk1MjQ1NCwyNzI0NjQyODY5LDEzMjA5NTc4MTIsMjE5NDMxOTEwMCwyNDI5NTk1ODcyLDI4MTU5NTYyNzUsNzcwODk1MjEsMzk3Mzc3MzEyMSwzNDQ0NTc1ODcxLDI0NDg4MzAyMzEsMTMwNTkwNjU1MCw0MDIxMzA4NzM5LDI4NTcxOTQ3MDAsMjUxNjkwMTg2MCwzNTE4MzU4NDMwLDE3ODczMDQ3ODAsNzQwMjc2NDE3LDE2OTk4Mzk4MTQsMTU5MjM5NDkwOSwyMzUyMzA3NDU3LDIyNzI1NTYwMjYsMTg4ODIxMjQzLDE3Mjk5NzcwMTEsMzY4Nzk5NDAwMiwyNzQwODQ4NDEsMzU5NDk4MjI1MywzNjEzNDk0NDI2LDI3MDE5NDk0OTUsNDE2MjA5NjcyOSwzMjI3MzQ1NzEsMjgzNzk2NjU0MiwxNjQwNTc2NDM5LDQ4NDgzMDY4OSwxMjAyNzk3NjkwLDM1Mzc4NTI4MjgsNDA2NzYzOTEyNSwzNDkwNzU3MzYsMzM0MjMxOTQ3NSw0MTU3NDY3MjE5LDQyNTU4MDAxNTksMTAzMDY5MDAxNSwxMTU1MjM3NDk2LDI5NTE5NzEyNzQsMTc1NzY5MTU3Nyw2MDczOTg5NjgsMjczODkwNTAyNiw0OTkzNDc5OTAsMzc5NDA3ODkwOCwxMDExNDUyNzEyLDIyNzg4NTU2NywyODE4NjY2ODA5LDIxMzExNDM3NiwzMDM0ODgxMjQwLDE0NTU1MjU5ODgsMzQxNDQ1MDU1NSw4NTA4MTcyMzcsMTgxNzk5ODQwOCwzMDkyNzI2NDgwXSxfPVswLDIzNTQ3NDE4Nyw0NzA5NDgzNzQsMzAzNzY1Mjc3LDk0MTg5Njc0OCw5MDg5MzM0MTUsNjA3NTMwNTU0LDcwODc4MDg0OSwxODgzNzkzNDk2LDIxMTgyMTQ5OTUsMTgxNzg2NjgzMCwxNjQ5NjM5MjM3LDEyMTUwNjExMDgsMTE4MTA0NTExOSwxNDE3NTYxNjk4LDE1MTc3Njc1MjksMzc2NzU4Njk5Miw0MDAzMDYxMTc5LDQyMzY0Mjk5OTAsNDA2OTI0Njg5MywzNjM1NzMzNjYwLDM2MDI3NzAzMjcsMzI5OTI3ODQ3NCwzNDAwNTI4NzY5LDI0MzAxMjIyMTYsMjY2NDU0MzcxNSwyMzYyMDkwMjM4LDIxOTM4NjI2NDUsMjgzNTEyMzM5NiwyODAxMTA3NDA3LDMwMzU1MzUwNTgsMzEzNTc0MDg4OSwzNjc4MTI0OTIzLDM1NzY4NzA1MTIsMzM0MTM5NDI4NSwzMzc0MzYxNzAyLDM4MTA0OTYzNDMsMzk3NzY3NTM1Niw0Mjc5MDgwMjU3LDQwNDM2MTAxODYsMjg3NjQ5NDYyNywyNzc2MjkyOTA0LDMwNzY2MzkwMjksMzExMDY1MDk0MiwyNDcyMDExNTM1LDI2NDAyNDMyMDQsMjQwMzcyODY2NSwyMTY5MzAzMDU4LDEwMDEwODk5OTUsODk5ODM1NTg0LDY2NjQ2NDczMyw2OTk0MzIxNTAsNTk3Mjc4NDcsMjI2OTA2ODYwLDUzMDQwMDc1MywyOTQ5MzA2ODIsMTI3MzE2ODc4NywxMTcyOTY3MDY0LDE0NzU0MTg1MDEsMTUwOTQzMDQxNCwxOTQyNDM1Nzc1LDIxMTA2Njc0NDQsMTg3NjI0MTgzMywxNjQxODE2MjI2LDI5MTAyMTk3NjYsMjc0MzAzNDEwOSwyOTc2MTUxNTIwLDMyMTE2MjMxNDcsMjUwNTIwMjEzOCwyNjA2NDUzOTY5LDIzMDI2OTAyNTIsMjI2OTcyODQ1NSwzNzExODI5NDIyLDM1NDM1OTkyNjksMzI0MDg5NDM5MiwzNDc1MzEzMzMxLDM4NDM2OTkwNzQsMzk0MzkwNjQ0MSw0MTc4MDYyMjI4LDQxNDQwNDc3NzUsMTMwNjk2NzM2NiwxMTM5NzgxNzA5LDEzNzQ5ODgxMTIsMTYxMDQ1OTczOSwxOTc1NjgzNDM0LDIwNzY5MzUyNjUsMTc3NTI3NjkyNCwxNzQyMzE1MTI3LDEwMzQ4Njc5OTgsODY2NjM3ODQ1LDU2NjAyMTg5Niw4MDA0NDA4MzUsOTI5ODc2OTgsMTkzMTk1MDY1LDQyOTQ1NjE2NCwzOTU0NDE3MTEsMTk4NDgxMjY4NSwyMDE3Nzc4NTY2LDE3ODQ2NjMxOTUsMTY4MzQwNzI0OCwxMzE1NTYyMTQ1LDEwODAwOTQ2MzQsMTM4Mzg1NjMxMSwxNTUxMDM3ODg0LDEwMTAzOTgyOSwxMzUwNTAyMDYsNDM3NzU3MTIzLDMzNzU1Mzg2NCwxMDQyMzg1NjU3LDgwNzk2MjYxMCw1NzM4MDQ3ODMsNzQyMDM5MDEyLDI1MzEwNjc0NTMsMjU2NDAzMzMzNCwyMzI4ODI4OTcxLDIyMjc1NzMwMjQsMjkzNTU2Njg2NSwyNzAwMDk5MzU0LDMwMDE3NTU2NTUsMzE2ODkzNzIyOCwzODY4NTUyODA1LDM5MDI1NjMxODIsNDIwMzE4MTE3MSw0MTAyOTc3OTEyLDM3MzYxNjQ5MzcsMzUwMTc0MTg5MCwzMjY1NDc4NzUxLDM0MzM3MTI5ODAsMTEwNjA0MTU5MSwxMzQwNDYzMTAwLDE1NzY5NzY2MDksMTQwODc0OTAzNCwyMDQzMjExNDgzLDIwMDkxOTU0NzIsMTcwODg0ODMzMywxODA5MDU0MTUwLDgzMjg3NzIzMSwxMDY4MzUxMzk2LDc2Njk0NTQ2NSw1OTk3NjIzNTQsMTU5NDE3OTg3LDEyNjQ1NDY2NCwzNjE5Mjk4NzcsNDYzMTgwMTkwLDI3MDkyNjA4NzEsMjk0MzY4MjM4MCwzMTc4MTA2OTYxLDMwMDk4NzkzODYsMjU3MjY5NzE5NSwyNTM4NjgxMTg0LDIyMzYyMjg3MzMsMjMzNjQzNDU1MCwzNTA5ODcxMTM1LDM3NDUzNDUzMDAsMzQ0MTg1MDM3NywzMjc0NjY3MjY2LDM5MTAxNjE5NzEsMzg3NzE5ODY0OCw0MTEwNTY4NDg1LDQyMTE4MTg3OTgsMjU5NzgwNjQ3NiwyNDk3NjA0NzQzLDIyNjEwODkxNzgsMjI5NTEwMTA3MywyNzMzODU2MTYwLDI5MDIwODc4NTEsMzIwMjQzNzA0NiwyOTY4MDExNDUzLDM5MzYyOTEyODQsMzgzNTAzNjg5NSw0MTM2NDQwNzcwLDQxNjk0MDgyMDEsMzUzNTQ4NjQ1NiwzNzAyNjY1NDU5LDM0NjcxOTIzMDIsMzIzMTcyMjIxMywyMDUxNTE4NzgwLDE5NTEzMTcwNDcsMTcxNjg5MDQxMCwxNzUwOTAyMzA1LDExMTM4MTgzODQsMTI4MjA1MDA3NSwxNTg0NTA0NTgyLDEzNTAwNzg5ODksMTY4ODEwODUyLDY3NTU2NDYzLDM3MTA0OTMzMCw0MDQwMTY3NjEsODQxNzM5NTkyLDEwMDg5MTg1OTUsNzc1NTUwODE0LDU0MDA4MDcyNSwzOTY5NTYyMzY5LDM4MDEzMzIyMzQsNDAzNTQ4OTA0Nyw0MjY5OTA3OTk2LDM1NjkyNTUyMTMsMzY2OTQ2MjU2NiwzMzY2NzU0NjE5LDMzMzI3NDAxNDQsMjYzMTA2NTQzMywyNDYzODc5NzYyLDIxNjAxMTcwNzEsMjM5NTU4ODY3NiwyNzY3NjQ1NTU3LDI4Njg4OTc0MDYsMzEwMjAxMTc0NywzMDY5MDQ5OTYwLDIwMjAwODQ5NywzMzc3ODM2MiwyNzAwNDA0ODcsNTA0NDU5NDM2LDg3NTQ1MTI5Myw5NzU2NTg2NDYsNjc1MDM5NjI3LDY0MTAyNTE1MiwyMDg0NzA0MjMzLDE5MTc1MTg1NjIsMTYxNTg2MTI0NywxODUxMzMyODUyLDExNDc1NTA2NjEsMTI0ODgwMjUxMCwxNDg0MDA1ODQzLDE0NTEwNDQwNTYsOTMzMzAxMzcwLDk2NzMxMTcyOSw3MzMxNTY5NzIsNjMyOTUzNzAzLDI2MDM4ODk1MCwyNTk2NTkxNywzMjg2NzE4MDgsNDk2OTA2MDU5LDEyMDY0Nzc4NTgsMTIzOTQ0Mzc1MywxNTQzMjA4NTAwLDE0NDE5NTI1NzUsMjE0NDE2MTgwNiwxOTA4Njk0Mjc3LDE2NzU1Nzc4ODAsMTg0Mjc1OTQ0MywzNjEwMzY5MjI2LDM2NDQzNzk1ODUsMzQwODExOTUxNiwzMzA3OTE2MjQ3LDQwMTExOTA1MDIsMzc3Njc2NzQ2OSw0MDc3Mzg0NDMyLDQyNDU2MTg2ODMsMjgwOTc3MTE1NCwyODQyNzM3MDQ5LDMxNDQzOTY0MjAsMzA0MzE0MDQ5NSwyNjczNzA1MTUwLDI0MzgyMzc2MjEsMjIwMzAzMjIzMiwyMzcwMjEzNzk1XSxNPVswLDE4NTQ2OTE5NywzNzA5MzgzOTQsNDg3NzI1ODQ3LDc0MTg3Njc4OCw2NTc4NjE5NDUsOTc1NDUxNjk0LDgyNDg1MjI1OSwxNDgzNzUzNTc2LDE0MDA3ODMyMDUsMTMxNTcyMzg5MCwxMTY0MDcxODA3LDE5NTA5MDMzODgsMjEzNTMxOTg4OSwxNjQ5NzA0NTE4LDE3Njc1MzY0NTksMjk2NzUwNzE1MiwzMTUyOTc2MzQ5LDI4MDE1NjY0MTAsMjkxODM1Mzg2MywyNjMxNDQ3NzgwLDI1NDc0MzI5MzcsMjMyODE0MzYxNCwyMTc3NTQ0MTc5LDM5MDE4MDY3NzYsMzgxODgzNjQwNSw0MjcwNjM5Nzc4LDQxMTg5ODc2OTUsMzI5OTQwOTAzNiwzNDgzODI1NTM3LDM1MzUwNzI5MTgsMzY1MjkwNDg1OSwyMDc3OTY1MjQzLDE4OTMwMjAzNDIsMTg0MTc2ODg2NSwxNzI0NDU3MTMyLDE0NzQ1MDI1NDMsMTU1OTA0MTY2NiwxMTA3MjM0MTk3LDEyNTczMDkzMzYsNTk4NDM4ODY3LDY4MTkzMzUzNCw5MDEyMTA1NjksMTA1MjMzODM3MiwyNjEzMTQ1MzUsNzc0MjIzMTQsNDI4ODE5OTY1LDMxMDQ2MzcyOCwzNDA5Njg1MzU1LDMyMjQ3NDA0NTQsMzcxMDM2ODExMywzNTkzMDU2MzgwLDM4NzU3NzAyMDcsMzk2MDMwOTMzMCw0MDQ1MzgwOTMzLDQxOTU0NTYwNzIsMjQ3MTIyNDA2NywyNTU0NzE4NzM0LDIyMzcxMzMwODEsMjM4ODI2MDg4NCwzMjEyMDM1ODk1LDMwMjgxNDM2NzQsMjg0MjY3ODU3MywyNzI0MzIyMzM2LDQxMzg1NjMxODEsNDI1NTM1MDYyNCwzNzY5NzIxOTc1LDM5NTUxOTExNjIsMzY2NzIxOTAzMywzNTE2NjE5NjA0LDM0MzE1NDY5NDcsMzM0NzUzMjExMCwyOTMzNzM0OTE3LDI3ODIwODI4MjQsMzA5OTY2NzQ4NywzMDE2Njk3MTA2LDIxOTYwNTI1MjksMjMxMzg4NDQ3NiwyNDk5MzQ4NTIzLDI2ODM3NjUwMzAsMTE3OTUxMDQ2MSwxMjk2Mjk3OTA0LDEzNDc1NDgzMjcsMTUzMzAxNzUxNCwxNzg2MTAyNDA5LDE2MzU1MDI5ODAsMjA4NzMwOTQ1OSwyMDAzMjk0NjIyLDUwNzM1ODkzMywzNTU3MDY4NDAsMTM2NDI4NzUxLDUzNDU4MzcwLDgzOTIyNDAzMyw5NTcwNTU5ODAsNjA1NjU3MzM5LDc5MDA3Mzg0NiwyMzczMzQwNjMwLDIyNTYwMjg4OTEsMjYwNzQzOTgyMCwyNDIyNDk0OTEzLDI3MDYyNzA2OTAsMjg1NjM0NTgzOSwzMDc1NjM2MjE2LDMxNjAxNzUzNDksMzU3Mzk0MTY5NCwzNzI1MDY5NDkxLDMyNzMyNjcxMDgsMzM1Njc2MTc2OSw0MTgxNTk4NjAyLDQwNjMyNDIzNzUsNDAxMTk5NjA0OCwzODI4MTAzODM3LDEwMzMyOTcxNTgsOTE1OTg1NDE5LDczMDUxNzI3Niw1NDU1NzIzNjksMjk2Njc5NzMwLDQ0Njc1NDg3OSwxMjkxNjYxMjAsMjEzNzA1MjUzLDE3MDk2MTAzNTAsMTg2MDczODE0NywxOTQ1Nzk4NTE2LDIwMjkyOTMxNzcsMTIzOTMzMTE2MiwxMTIwOTc0OTM1LDE2MDY1OTEyOTYsMTQyMjY5OTA4NSw0MTQ4MjkyODI2LDQyMzMwOTQ2MTUsMzc4MTAzMzY2NCwzOTMxMzcxNDY5LDM2ODIxOTE1OTgsMzQ5NzUwOTM0NywzNDQ2MDA0NDY4LDMzMjg5NTUzODUsMjkzOTI2NjIyNiwyNzU1NjM2NjcxLDMxMDY3ODA4NDAsMjk4ODY4NzI2OSwyMTk4NDM4MDIyLDIyODIxOTUzMzksMjUwMTIxODk3MiwyNjUyNjA5NDI1LDEyMDE3NjUzODYsMTI4NjU2NzE3NSwxMzcxMzY4OTc2LDE1MjE3MDY3ODEsMTgwNTIxMTcxMCwxNjIwNTI5NDU5LDIxMDU4ODcyNjgsMTk4ODgzODE4NSw1MzM4MDQxMzAsMzUwMTc0NTc1LDE2NDQzOTY3Miw0NjM0NjEwMSw4NzA5MTIwODYsOTU0NjY5NDAzLDYzNjgxMzkwMCw3ODgyMDQzNTMsMjM1ODk1NzkyMSwyMjc0NjgwNDI4LDI1OTI1MjM2NDMsMjQ0MTY2MTU1OCwyNjk1MDMzNjg1LDI4ODAyNDAyMTYsMzA2NTk2MjgzMSwzMTgyNDg3NjE4LDM1NzIxNDU5MjksMzc1NjI5OTc4MCwzMjcwOTM3ODc1LDMzODg1MDcxNjYsNDE3NDU2MDA2MSw0MDkxMzI3MDI0LDQwMDY1MjExMjcsMzg1NDYwNjM3OCwxMDE0NjQ2NzA1LDkzMDM2OTIxMiw3MTEzNDk2NzUsNTYwNDg3NTkwLDI3Mjc4NjMwOSw0NTc5OTI4NDAsMTA2ODUyNzY3LDIyMzM3NzU1NCwxNjc4MzgxMDE3LDE4NjI1MzQ4NjgsMTkxNDA1MjAzNSwyMDMxNjIxMzI2LDEyMTEyNDc1OTcsMTEyODAxNDU2MCwxNTgwMDg3Nzk5LDE0MjgxNzMwNTAsMzIyODMzMTksMTgyNjIxMTE0LDQwMTYzOTU5Nyw0ODY0NDEzNzYsNzY4OTE3MTIzLDY1MTg2ODA0NiwxMDAzMDA3MTI5LDgxODMyNDg4NCwxNTAzNDQ5ODIzLDEzODUzNTYyNDIsMTMzMzgzODAyMSwxMTUwMjA4NDU2LDE5NzM3NDUzODcsMjEyNTEzNTg0NiwxNjczMDYxNjE3LDE3NTY4MTg5NDAsMjk3MDM1NjMyNywzMTIwNjk0MTIyLDI4MDI4NDk5MTcsMjg4NzY1MTY5NiwyNjM3NDQyNjQzLDI1MjAzOTM1NjYsMjMzNDY2OTg5NywyMTQ5OTg3NjUyLDM5MTcyMzQ3MDMsMzc5OTE0MTEyMiw0Mjg0NTAyMDM3LDQxMDA4NzI0NzIsMzMwOTU5NDE3MSwzNDYwOTg0NjMwLDM1NDU3ODk0NzMsMzYyOTU0Njc5NiwyMDUwNDY2MDYwLDE4OTk2MDM5NjksMTgxNDgwMzIyMiwxNzMwNTI1NzIzLDE0NDM4NTc3MjAsMTU2MDM4MjUxNywxMDc1MDI1Njk4LDEyNjAyMzIyMzksNTc1MTM4MTQ4LDY5MjcwNzQzMyw4Nzg0NDMzOTAsMTA2MjU5NzIzNSwyNDMyNTY2NTYsOTEzNDE5MTcsNDA5MTk4NDEwLDMyNTk2NTM4MywzNDAzMTAwNjM2LDMyNTIyMzg1NDUsMzcwNDMwMDQ4NiwzNjIwMDIyOTg3LDM4NzQ0MjgzOTIsMzk5MDk1MzE4OSw0MDQyNDU5MTIyLDQyMjc2NjU2NjMsMjQ2MDQ0OTIwNCwyNTc4MDE4NDg5LDIyMjY4NzUzMTAsMjQxMTAyOTE1NSwzMTk4MTE1MjAwLDMwNDYyMDA0NjEsMjgyNzE3Nzg4MiwyNzQzOTQ0ODU1XSxBPVswLDIxODgyODI5Nyw0Mzc2NTY1OTQsMzg3NzgxMTQ3LDg3NTMxMzE4OCw5NTg4NzEwODUsNzc1NTYyMjk0LDU5MDQyNDYzOSwxNzUwNjI2Mzc2LDE2OTk5NzA2MjUsMTkxNzc0MjE3MCwyMTM1MjUzNTg3LDE1NTExMjQ1ODgsMTM2NzI5NTU4OSwxMTgwODQ5Mjc4LDEyNjUxOTU2MzksMzUwMTI1Mjc1MiwzNzIwMDgxMDQ5LDMzOTk5NDEyNTAsMzM1MDA2NTgwMywzODM1NDg0MzQwLDM5MTkwNDIyMzcsNDI3MDUwNzE3NCw0MDg1MzY5NTE5LDMxMDIyNDkxNzYsMzA1MTU5MzQyNSwyNzM0NTkxMTc4LDI5NTIxMDI1OTUsMjM2MTY5ODU1NiwyMTc3ODY5NTU3LDI1MzAzOTEyNzgsMjYxNDczNzYzOSwzMTQ1NDU2NDQzLDMwNjA4NDc5MjIsMjcwODMyNjE4NSwyODkyNDE3MzEyLDI0MDQ5MDE2NjMsMjE4NzEyODA4NiwyNTA0MTMwMzE3LDI1NTUwNDgxOTYsMzU0MjMzMDIyNywzNzI3MjA1NzU0LDMzNzU3NDA3NjksMzI5MjQ0NTAzMiwzODc2NTU3NjU1LDM5MjYxNzA5NzQsNDI0NjMxMDcyNSw0MDI3NzQ0NTg4LDE4MDg0ODExOTUsMTcyMzg3MjY3NCwxOTEwMzE5MDMzLDIwOTQ0MTAxNjAsMTYwODk3NTI0NywxMzkxMjAxNjcwLDExNzM0MzAxNzMsMTIyNDM0ODA1Miw1OTk4NDg2NywyNDQ4NjAzOTQsNDI4MTY5MjAxLDM0NDg3MzQ2NCw5MzUyOTM4OTUsOTg0OTA3MjE0LDc2NjA3ODkzMyw1NDc1MTI3OTYsMTg0NDg4MjgwNiwxNjI3MjM1MTk5LDIwMTEyMTQxODAsMjA2MjI3MDMxNywxNTA3NDk3Mjk4LDE0MjMwMjI5MzksMTEzNzQ3Nzk1MiwxMzIxNjk5MTQ1LDk1MzQ1OTgyLDE0NTA4NTIzOSw1MzIyMDE3NzIsMzEzNzczODYxLDgzMDY2MTkxNCwxMDE1NjcxNTcxLDczMTE4MzM2OCw2NDgwMTc2NjUsMzE3NTUwMTI4NiwyOTU3ODUzNjc5LDI4MDcwNTg5MzIsMjg1ODExNTA2OSwyMzA1NDU1NTU0LDIyMjA5ODExOTUsMjQ3NDQwNDMwNCwyNjU4NjI1NDk3LDM1NzU1Mjg4NzgsMzYyNTI2ODEzNSwzNDczNDE2NjM2LDMyNTQ5ODg3MjUsMzc3ODE1MTgxOCwzOTYzMTYxNDc1LDQyMTM0NDcwNjQsNDEzMDI4MTM2MSwzNTk5NTk1MDg1LDM2ODMwMjI5MTYsMzQzMjczNzM3NSwzMjQ3NDY1NTU4LDM4MDIyMjIxODUsNDAyMDkxMjIyNCw0MTcyNzYzNzcxLDQxMjI3NjIzNTQsMzIwMTYzMTc0OSwzMDE3NjcyNzE2LDI3NjQyNDk2MjMsMjg0ODQ2MTg1NCwyMzMxNTkwMTc3LDIyODA3OTYyMDAsMjQzMTU5MDk2MywyNjQ4OTc2NDQyLDEwNDY5OTYxMywxODgxMjc0NDQsNDcyNjE1NjMxLDI4NzM0MzgxNCw4NDAwMTk3MDUsMTA1ODcwOTc0NCw2NzE1OTMxOTUsNjIxNTkxNzc4LDE4NTIxNzE5MjUsMTY2ODIxMjg5MiwxOTUzNzU3ODMxLDIwMzc5NzAwNjIsMTUxNDc5MDU3NywxNDYzOTk2NjAwLDEwODAwMTc1NzEsMTI5NzQwMzA1MCwzNjczNjM3MzU2LDM2MjM2MzY5NjUsMzIzNTk5NTEzNCwzNDU0Njg2MTk5LDQwMDczNjA5NjgsMzgyMjA5MDE3Nyw0MTA3MTAxNjU4LDQxOTA1MzA1MTUsMjk5NzgyNTk1NiwzMjE1MjEyNDYxLDI4MzA3MDgxNTAsMjc3OTkxNTE5OSwyMjU2NzM0NTkyLDIzNDA5NDc4NDksMjYyNzAxNjA4MiwyNDQzMDU4MDc1LDE3MjQ2NjU1NiwxMjI0NjYxNjUsMjczNzkyMzY2LDQ5MjQ4MzQzMSwxMDQ3MjM5ZTMsODYxOTY4MjA5LDYxMjIwNTg5OCw2OTU2MzQ3NTUsMTY0NjI1MjM0MCwxODYzNjM4ODQ1LDIwMTM5MDgyNjIsMTk2MzExNTMxMSwxNDQ2MjQyNTc2LDE1MzA0NTU4MzMsMTI3NzU1NTk3MCwxMDkzNTk3OTYzLDE2MzY2MDQ2MzEsMTgyMDgyNDc5OCwyMDczNzI0NjEzLDE5ODkyNDkyMjgsMTQzNjU5MDgzNSwxNDg3NjQ1OTQ2LDEzMzczNzY0ODEsMTExOTcyNzg0OCwxNjQ5NDg2MzksODE3ODE5MTAsMzMxNTQ0MjA1LDUxNjU1MjgzNiwxMDM5NzE3MDUxLDgyMTI4ODExNCw2Njk5NjE4OTcsNzE5NzAwMTI4LDI5NzM1MzA2OTUsMzE1Nzc1MDg2MiwyODcxNjgyNjQ1LDI3ODcyMDcyNjAsMjIzMjQzNTI5OSwyMjgzNDkwNDEwLDI2Njc5OTQ3MzcsMjQ1MDM0NjEwNCwzNjQ3MjEyMDQ3LDM1NjQwNDUzMTgsMzI3OTAzMzg4NSwzNDY0MDQyNTE2LDM5ODA5MzE2MjcsMzc2MjUwMjY5MCw0MTUwMTQ0NTY5LDQxOTk4ODI4MDAsMzA3MDM1NjYzNCwzMTIxMjc1NTM5LDI5MDQwMjcyNzIsMjY4NjI1NDcyMSwyMjAwODE4ODc4LDIzODQ5MTEwMzEsMjU3MDgzMjA0NCwyNDg2MjI0NTQ5LDM3NDcxOTIwMTgsMzUyODYyNjkwNywzMzEwMzIxODU2LDMzNTk5MzYyMDEsMzk1MDM1NTcwMiwzODY3MDYwOTkxLDQwNDk4NDQ0NTIsNDIzNDcyMTAwNSwxNzM5NjU2MjAyLDE3OTA1NzUxMDcsMjEwODEwMDYzMiwxODkwMzI4MDgxLDE0MDI4MTE0MzgsMTU4NjkwMzU5MSwxMjMzODU2NTcyLDExNDkyNDkwNzcsMjY2OTU5OTM4LDQ4Mzk0ODI3LDM2OTA1Nzg3Miw0MTg2NzIyMTcsMTAwMjc4Mzg0Niw5MTk0ODkxMzUsNTY3NDk4ODY4LDc1MjM3NTQyMSwyMDkzMzYyMjUsMjQxOTc1NDQsMzc2MTg3ODI3LDQ1OTc0NDY5OCw5NDUxNjQxNjUsODk1Mjg3NjkyLDU3NDYyNDY2Myw3OTM0NTE5MzQsMTY3OTk2ODIzMywxNzY0MzEzNTY4LDIxMTczNjA2MzUsMTkzMzUzMDYxMCwxMzQzMTI3NTAxLDE1NjA2Mzc4OTIsMTI0MzExMjQxNSwxMTkyNDU1NjM4LDM3MDQyODA4ODEsMzUxOTE0MjIwMCwzMzM2MzU4NjkxLDM0MTk5MTU1NjIsMzkwNzQ0ODU5NywzODU3NTcyMTI0LDQwNzU4NzcxMjcsNDI5NDcwNDM5OCwzMDI5NTEwMDA5LDMxMTM4NTUzNDQsMjkyNzkzNDMxNSwyNzQ0MTA0MjkwLDIxNTk5NzYyODUsMjM3NzQ4NjY3NiwyNTk0NzM0OTI3LDI1NDQwNzgxNTBdLEU9WzAsMTUxODQ5NzQyLDMwMzY5OTQ4NCw0NTQ0OTk2MDIsNjA3Mzk4OTY4LDc1ODcyMDMxMCw5MDg5OTkyMDQsMTA1OTI3MDk1NCwxMjE0Nzk3OTM2LDEwOTcxNTk1NTAsMTUxNzQ0MDYyMCwxNDAwODQ5NzYyLDE4MTc5OTg0MDgsMTY5OTgzOTgxNCwyMTE4NTQxOTA4LDIwMDE0MzA4NzQsMjQyOTU5NTg3MiwyNTgxNDQ1NjE0LDIxOTQzMTkxMDAsMjM0NTExOTIxOCwzMDM0ODgxMjQwLDMxODYyMDI1ODIsMjgwMTY5OTUyNCwyOTUxOTcxMjc0LDM2MzU5OTY4MTYsMzUxODM1ODQzMCwzMzk5Njc5NjI4LDMyODMwODg3NzAsNDIzNzA4MzgxNiw0MTE4OTI1MjIyLDQwMDI4NjE3NDgsMzg4NTc1MDcxNCwxMDAyMTQyNjgzLDg1MDgxNzIzNyw2OTg0NDUyNTUsNTQ4MTY5NDE3LDUyOTQ4Nzg0MywzNzc2NDIyMjEsMjI3ODg1NTY3LDc3MDg5NTIxLDE5NDMyMTcwNjcsMjA2MTM3OTc0OSwxNjQwNTc2NDM5LDE3NTc2OTE1NzcsMTQ3NDc2MDU5NSwxNTkyMzk0OTA5LDExNzQyMTUwNTUsMTI5MDgwMTc5MywyODc1OTY4MzE1LDI3MjQ2NDI4NjksMzExMTI0NzE0MywyOTYwOTcxMzA1LDI0MDU0MjY5NDcsMjI1MzU4MTMyNSwyNjM4NjA2NjIzLDI0ODc4MTA1NzcsMzgwODY2MjM0NywzOTI2ODI1MDI5LDQwNDQ5ODE1OTEsNDE2MjA5NjcyOSwzMzQyMzE5NDc1LDM0NTk5NTM3ODksMzU3NjUzOTUwMywzNjkzMTI2MjQxLDE5ODY5MTgwNjEsMjEzNzA2MjgxOSwxNjg1NTc3OTA1LDE4MzY3NzIyODcsMTM4MTYyMDM3MywxNTMyMjg1MzM5LDEwNzgxODUwOTcsMTIyOTg5OTY1NSwxMDQwNTU5ODM3LDkyMzMxMzYxOSw3NDAyNzY0MTcsNjIxOTgyNjcxLDQzOTQ1MjM4OSwzMjI3MzQ1NzEsMTM3MDczOTEzLDE5MzA4NTM1LDM4NzExNjM5ODEsNDAyMTMwODczOSw0MTA0NjA1Nzc3LDQyNTU4MDAxNTksMzI2Mzc4NTU4OSwzNDE0NDUwNTU1LDM0OTkzMjY1NjksMzY1MTA0MTEyNywyOTMzMjAyNDkzLDI4MTU5NTYyNzUsMzE2NzY4NDY0MSwzMDQ5MzkwODk1LDIzMzAwMTQyMTMsMjIxMzI5NjM5NSwyNTY2NTk1NjA5LDI0NDg4MzAyMzEsMTMwNTkwNjU1MCwxMTU1MjM3NDk2LDE2MDcyNDQ2NTAsMTQ1NTUyNTk4OCwxNzc2NDYwMTEwLDE2MjYzMTk0MjQsMjA3OTg5NzQyNiwxOTI4NzA3MTY0LDk2MzkyNDU0LDIxMzExNDM3NiwzOTY2NzM4MTgsNTE0NDQzMjg0LDU2Mjc1NTkwMiw2Nzk5OThlMyw4NjUxMzY0MTgsOTgzNDI2MDkyLDM3MDgxNzM3MTgsMzU1NzUwNDY2NCwzNDc0NzI5ODY2LDMzMjMwMTEyMDQsNDE4MDgwODExMCw0MDMwNjY3NDI0LDM5NDUyNjkxNzAsMzc5NDA3ODkwOCwyNTA3MDQwMjMwLDI2MjM3NjIxNTIsMjI3MjU1NjAyNiwyMzkwMzI1NDkyLDI5NzU0ODQzODIsMzA5MjcyNjQ4MCwyNzM4OTA1MDI2LDI4NTcxOTQ3MDAsMzk3Mzc3MzEyMSwzODU2MTM3Mjk1LDQyNzQwNTM0NjksNDE1NzQ2NzIxOSwzMzcxMDk2OTUzLDMyNTI5MzI3MjcsMzY3MzQ3NjQ1MywzNTU2MzYxODM1LDI3NjMxNzM2ODEsMjkxNTAxNzc5MSwzMDY0NTEwNzY1LDMyMTUzMDcyOTksMjE1NjI5OTAxNywyMzA3NjIyOTE5LDI0NTk3MzUzMTcsMjYxMDAxMTY3NSwyMDgxMDQ4NDgxLDE5NjM0MTI2NTUsMTg0NjU2MzI2MSwxNzI5OTc3MDExLDE0ODA0ODU3ODUsMTM2MjMyMTU1OSwxMjQzOTA1NDEzLDExMjY3OTA3OTUsODc4ODQ1OTA1LDEwMzA2OTAwMTUsNjQ1NDAxMDM3LDc5NjE5NzU3MSwyNzQwODQ4NDEsNDI1NDA4NzQzLDM4NTQ0ODg1LDE4ODgyMTI0MywzNjEzNDk0NDI2LDM3MzE2NTQ1NDgsMzMxMzIxMjAzOCwzNDMwMzIyNTY4LDQwODI0NzUxNzAsNDIwMDExNTExNiwzNzgwMDk3NzI2LDM4OTY2ODgwNDgsMjY2ODIyMTY3NCwyNTE2OTAxODYwLDIzNjY4ODI1NTAsMjIxNjYxMDI5NiwzMTQxNDAwNzg2LDI5ODk1NTI2MDQsMjgzNzk2NjU0MiwyNjg3MTY1ODg4LDEyMDI3OTc2OTAsMTMyMDk1NzgxMiwxNDM3MjgwODcwLDE1NTQzOTE0MDAsMTY2OTY2NDgzNCwxNzg3MzA0NzgwLDE5MDYyNDcyNjIsMjAyMjgzNzU4NCwyNjU5MDUxNjIsMTE0NTg1MzQ4LDQ5OTM0Nzk5MCwzNDkwNzU3MzYsNzM2OTcwODAyLDU4NTEyMjYyMCw5NzI1MTI4MTQsODIxNzEyMTYwLDI1OTU2ODQ4NDQsMjQ3ODQ0MzIzNCwyMjkzMDQ1MjMyLDIxNzQ3NTQwNDYsMzE5NjI2Nzk4OCwzMDc5NTQ2NTg2LDI4OTU3MjM0NjQsMjc3Nzk1MjQ1NCwzNTM3ODUyODI4LDM2ODc5OTQwMDIsMzIzNDE1NjQxNiwzMzg1MzQ1MTY2LDQxNDI2MjYyMTIsNDI5MzI5NTc4NiwzODQxMDI0OTUyLDM5OTI3NDIwNzAsMTc0NTY3NjkyLDU3MzI2MDgyLDQxMDg4Nzk1MiwyOTI1OTY3NjYsNzc3MjMxNjY4LDY2MDUxMDI2NiwxMDExNDUyNzEyLDg5MzY4MTcwMiwxMTA4MzM5MDY4LDEyNTg0ODAyNDIsMTM0MzYxODkxMiwxNDk0ODA3NjYyLDE3MTUxOTMxNTYsMTg2NTg2MjczMCwxOTQ4MzczODQ4LDIxMDAwOTA5NjYsMjcwMTk0OTQ5NSwyODE4NjY2ODA5LDMwMDQ1OTExNDcsMzEyMjM1ODA1MywyMjM1MDYxNzc1LDIzNTIzMDc0NTcsMjUzNTYwNDI0MywyNjUzODk5NTQ5LDM5MTU2NTM3MDMsMzc2NDk4ODIzMyw0MjE5MzUyMTU1LDQwNjc2MzkxMjUsMzQ0NDU3NTg3MSwzMjk0NDMwNTc3LDM3NDYxNzUwNzUsMzU5NDk4MjI1Myw4MzY1NTM0MzEsOTUzMjcwNzQ1LDYwMDIzNTIxMSw3MTgwMDIxMTcsMzY3NTg1MDA3LDQ4NDgzMDY4OSwxMzMzNjE5MDcsMjUxNjU3MjEzLDIwNDE4NzcxNTksMTg5MTIxMTY4OSwxODA2NTk5MzU1LDE2NTQ4ODYzMjUsMTU2ODcxODQ5NSwxNDE4NTczMjAxLDEzMzU1MzU3NDcsMTE4NDM0MjkyNV07ZnVuY3Rpb24gUyhlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cis9NCl0LnB1c2goZVtyXTw8MjR8ZVtyKzFdPDwxNnxlW3IrMl08PDh8ZVtyKzNdKTtyZXR1cm4gdH12YXIgaz1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBrKSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwia2V5XCIse3ZhbHVlOm8oZSwhMCl9KSx0aGlzLl9wcmVwYXJlKCl9O2sucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dmFyIGU9Zlt0aGlzLmtleS5sZW5ndGhdO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpXCIpO3RoaXMuX0tlPVtdLHRoaXMuX0tkPVtdO2Zvcih2YXIgdD0wO3Q8PWU7dCsrKXRoaXMuX0tlLnB1c2goWzAsMCwwLDBdKSx0aGlzLl9LZC5wdXNoKFswLDAsMCwwXSk7Zm9yKHZhciByLG49NCooZSsxKSxpPXRoaXMua2V5Lmxlbmd0aC80LG89Uyh0aGlzLmtleSksdD0wO3Q8aTt0Kyspcj10Pj4yLHRoaXMuX0tlW3JdW3QlNF09b1t0XSx0aGlzLl9LZFtlLXJdW3QlNF09b1t0XTtmb3IodmFyIHMsYT0wLHU9aTt1PG47KXtpZihzPW9baS0xXSxvWzBdXj1kW3M+PjE2JjI1NV08PDI0XmRbcz4+OCYyNTVdPDwxNl5kWzI1NSZzXTw8OF5kW3M+PjI0JjI1NV1eY1thXTw8MjQsYSs9MSw4IT1pKWZvcih0PTE7dDxpO3QrKylvW3RdXj1vW3QtMV07ZWxzZXtmb3IodD0xO3Q8aS8yO3QrKylvW3RdXj1vW3QtMV07cz1vW2kvMi0xXSxvW2kvMl1ePWRbMjU1JnNdXmRbcz4+OCYyNTVdPDw4XmRbcz4+MTYmMjU1XTw8MTZeZFtzPj4yNCYyNTVdPDwyNDtmb3IodD1pLzIrMTt0PGk7dCsrKW9bdF1ePW9bdC0xXX1mb3IodD0wO3Q8aSYmdTxuOylsPXU+PjIsaD11JTQsdGhpcy5fS2VbbF1baF09b1t0XSx0aGlzLl9LZFtlLWxdW2hdPW9bdCsrXSx1Kyt9Zm9yKHZhciBsPTE7bDxlO2wrKylmb3IodmFyIGg9MDtoPDQ7aCsrKXM9dGhpcy5fS2RbbF1baF0sdGhpcy5fS2RbbF1baF09X1tzPj4yNCYyNTVdXk1bcz4+MTYmMjU1XV5BW3M+PjgmMjU1XV5FWzI1NSZzXX0say5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihlKXtpZigxNiE9ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7Zm9yKHZhciB0PXRoaXMuX0tlLmxlbmd0aC0xLHI9WzAsMCwwLDBdLG49UyhlKSxpPTA7aTw0O2krKyluW2ldXj10aGlzLl9LZVswXVtpXTtmb3IodmFyIG89MTtvPHQ7bysrKXtmb3IoaT0wO2k8NDtpKyspcltpXT1oW25baV0+PjI0JjI1NV1ecFtuWyhpKzEpJTRdPj4xNiYyNTVdXnZbblsoaSsyKSU0XT4+OCYyNTVdXnlbMjU1Jm5bKGkrMyklNF1dXnRoaXMuX0tlW29dW2ldO249ci5zbGljZSgpfWZvcih2YXIgcyxhPXUoMTYpLGk9MDtpPDQ7aSsrKXM9dGhpcy5fS2VbdF1baV0sYVs0KmldPTI1NSYoZFtuW2ldPj4yNCYyNTVdXnM+PjI0KSxhWzQqaSsxXT0yNTUmKGRbblsoaSsxKSU0XT4+MTYmMjU1XV5zPj4xNiksYVs0KmkrMl09MjU1JihkW25bKGkrMiklNF0+PjgmMjU1XV5zPj44KSxhWzQqaSszXT0yNTUmKGRbMjU1Jm5bKGkrMyklNF1dXnMpO3JldHVybiBhfSxrLnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGUpe2lmKDE2IT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7Zm9yKHZhciB0PXRoaXMuX0tkLmxlbmd0aC0xLHI9WzAsMCwwLDBdLG49UyhlKSxpPTA7aTw0O2krKyluW2ldXj10aGlzLl9LZFswXVtpXTtmb3IodmFyIG89MTtvPHQ7bysrKXtmb3IoaT0wO2k8NDtpKyspcltpXT1tW25baV0+PjI0JjI1NV1eZ1tuWyhpKzMpJTRdPj4xNiYyNTVdXmJbblsoaSsyKSU0XT4+OCYyNTVdXndbMjU1Jm5bKGkrMSklNF1dXnRoaXMuX0tkW29dW2ldO249ci5zbGljZSgpfWZvcih2YXIgcyxhPXUoMTYpLGk9MDtpPDQ7aSsrKXM9dGhpcy5fS2RbdF1baV0sYVs0KmldPTI1NSYobFtuW2ldPj4yNCYyNTVdXnM+PjI0KSxhWzQqaSsxXT0yNTUmKGxbblsoaSszKSU0XT4+MTYmMjU1XV5zPj4xNiksYVs0KmkrMl09MjU1JihsW25bKGkrMiklNF0+PjgmMjU1XV5zPj44KSxhWzQqaSszXT0yNTUmKGxbMjU1Jm5bKGkrMSklNF1dXnMpO3JldHVybiBhfTt2YXIgTj1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBOKSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO3RoaXMuZGVzY3JpcHRpb249XCJFbGVjdHJvbmljIENvZGUgQmxvY2tcIix0aGlzLm5hbWU9XCJlY2JcIix0aGlzLl9hZXM9bmV3IGsoZSl9O04ucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoKGU9byhlKSkubGVuZ3RoJTE2IT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXMoZSxyLDAsbixuKzE2KSxzKHI9dGhpcy5fYWVzLmVuY3J5cHQociksdCxuKTtyZXR1cm4gdH0sTi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihlKXtpZigoZT1vKGUpKS5sZW5ndGglMTYhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXMoZSxyLDAsbixuKzE2KSxzKHI9dGhpcy5fYWVzLmRlY3J5cHQociksdCxuKTtyZXR1cm4gdH07dmFyIHg9ZnVuY3Rpb24oZSx0KXtpZighKHRoaXMgaW5zdGFuY2VvZiB4KSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO2lmKHRoaXMuZGVzY3JpcHRpb249XCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIix0aGlzLm5hbWU9XCJjYmNcIix0KXtpZigxNiE9dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpfWVsc2UgdD11KDE2KTt0aGlzLl9sYXN0Q2lwaGVyYmxvY2s9byh0LCEwKSx0aGlzLl9hZXM9bmV3IGsoZSl9O3gucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoKGU9byhlKSkubGVuZ3RoJTE2IT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXtzKGUsciwwLG4sbisxNik7Zm9yKHZhciBpPTA7aTwxNjtpKyspcltpXV49dGhpcy5fbGFzdENpcGhlcmJsb2NrW2ldO3RoaXMuX2xhc3RDaXBoZXJibG9jaz10aGlzLl9hZXMuZW5jcnlwdChyKSxzKHRoaXMuX2xhc3RDaXBoZXJibG9jayx0LG4pfXJldHVybiB0fSx4LnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGUpe2lmKChlPW8oZSkpLmxlbmd0aCUxNiE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7Zm9yKHZhciB0PXUoZS5sZW5ndGgpLHI9dSgxNiksbj0wO248ZS5sZW5ndGg7bis9MTYpe3MoZSxyLDAsbixuKzE2KSxyPXRoaXMuX2Flcy5kZWNyeXB0KHIpO2Zvcih2YXIgaT0wO2k8MTY7aSsrKXRbbitpXT1yW2ldXnRoaXMuX2xhc3RDaXBoZXJibG9ja1tpXTtzKGUsdGhpcy5fbGFzdENpcGhlcmJsb2NrLDAsbixuKzE2KX1yZXR1cm4gdH07dmFyIFA9ZnVuY3Rpb24oZSx0LHIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFApKXRocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIik7aWYodGhpcy5kZXNjcmlwdGlvbj1cIkNpcGhlciBGZWVkYmFja1wiLHRoaXMubmFtZT1cImNmYlwiLHQpe2lmKDE2IT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBzaXplKVwiKX1lbHNlIHQ9dSgxNik7cj1yfHwxLHRoaXMuc2VnbWVudFNpemU9cix0aGlzLl9zaGlmdFJlZ2lzdGVyPW8odCwhMCksdGhpcy5fYWVzPW5ldyBrKGUpfTtQLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoJXRoaXMuc2VnbWVudFNpemUhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIik7Zm9yKHZhciB0LHI9byhlLCEwKSxuPTA7bjxyLmxlbmd0aDtuKz10aGlzLnNlZ21lbnRTaXplKXt0PXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO2Zvcih2YXIgaT0wO2k8dGhpcy5zZWdtZW50U2l6ZTtpKyspcltuK2ldXj10W2ldO3ModGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSkscyhyLHRoaXMuX3NoaWZ0UmVnaXN0ZXIsMTYtdGhpcy5zZWdtZW50U2l6ZSxuLG4rdGhpcy5zZWdtZW50U2l6ZSl9cmV0dXJuIHJ9LFAucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoZS5sZW5ndGgldGhpcy5zZWdtZW50U2l6ZSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIik7Zm9yKHZhciB0LHI9byhlLCEwKSxuPTA7bjxyLmxlbmd0aDtuKz10aGlzLnNlZ21lbnRTaXplKXt0PXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO2Zvcih2YXIgaT0wO2k8dGhpcy5zZWdtZW50U2l6ZTtpKyspcltuK2ldXj10W2ldO3ModGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSkscyhlLHRoaXMuX3NoaWZ0UmVnaXN0ZXIsMTYtdGhpcy5zZWdtZW50U2l6ZSxuLG4rdGhpcy5zZWdtZW50U2l6ZSl9cmV0dXJuIHJ9O3ZhciBJPWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgSSkpdGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKTtpZih0aGlzLmRlc2NyaXB0aW9uPVwiT3V0cHV0IEZlZWRiYWNrXCIsdGhpcy5uYW1lPVwib2ZiXCIsdCl7aWYoMTYhPXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX1lbHNlIHQ9dSgxNik7dGhpcy5fbGFzdFByZWNpcGhlcj1vKHQsITApLHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleD0xNix0aGlzLl9hZXM9bmV3IGsoZSl9O0kucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW8oZSwhMCkscj0wO3I8dC5sZW5ndGg7cisrKTE2PT09dGhpcy5fbGFzdFByZWNpcGhlckluZGV4JiYodGhpcy5fbGFzdFByZWNpcGhlcj10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKSx0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXg9MCksdFtyXV49dGhpcy5fbGFzdFByZWNpcGhlclt0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXgrK107cmV0dXJuIHR9LEkucHJvdG90eXBlLmRlY3J5cHQ9SS5wcm90b3R5cGUuZW5jcnlwdDt2YXIgVD1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBUKSl0aHJvdyBFcnJvcihcIkNvdW50ZXIgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKTswPT09ZXx8ZXx8KGU9MSksXCJudW1iZXJcIj09dHlwZW9mIGU/KHRoaXMuX2NvdW50ZXI9dSgxNiksdGhpcy5zZXRWYWx1ZShlKSk6dGhpcy5zZXRCeXRlcyhlKX07VC5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fHBhcnNlSW50KGUpIT1lKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgY291bnRlciB2YWx1ZSAobXVzdCBiZSBhbiBpbnRlZ2VyKVwiKTtmb3IodmFyIHQ9MTU7MDw9dDstLXQpdGhpcy5fY291bnRlclt0XT1lJTI1NixlPj49OH0sVC5wcm90b3R5cGUuc2V0Qnl0ZXM9ZnVuY3Rpb24oZSl7aWYoMTYhPShlPW8oZSwhMCkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgYnl0ZXMgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7dGhpcy5fY291bnRlcj1lfSxULnByb3RvdHlwZS5pbmNyZW1lbnQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9MTU7MDw9ZTtlLS0pe2lmKDI1NSE9PXRoaXMuX2NvdW50ZXJbZV0pe3RoaXMuX2NvdW50ZXJbZV0rKzticmVha310aGlzLl9jb3VudGVyW2VdPTB9fTt2YXIgUj1mdW5jdGlvbihlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFIpKXRocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIik7dGhpcy5kZXNjcmlwdGlvbj1cIkNvdW50ZXJcIix0aGlzLm5hbWU9XCJjdHJcIix0IGluc3RhbmNlb2YgVHx8KHQ9bmV3IFQodCkpLHRoaXMuX2NvdW50ZXI9dCx0aGlzLl9yZW1haW5pbmdDb3VudGVyPW51bGwsdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4PTE2LHRoaXMuX2Flcz1uZXcgayhlKX07Ui5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9byhlLCEwKSxyPTA7cjx0Lmxlbmd0aDtyKyspMTY9PT10aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXgmJih0aGlzLl9yZW1haW5pbmdDb3VudGVyPXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX2NvdW50ZXIuX2NvdW50ZXIpLHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleD0wLHRoaXMuX2NvdW50ZXIuaW5jcmVtZW50KCkpLHRbcl1ePXRoaXMuX3JlbWFpbmluZ0NvdW50ZXJbdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4KytdO3JldHVybiB0fSxSLnByb3RvdHlwZS5kZWNyeXB0PVIucHJvdG90eXBlLmVuY3J5cHQ7dmFyIE89e0FFUzprLENvdW50ZXI6VCxNb2RlT2ZPcGVyYXRpb246e2VjYjpOLGNiYzp4LGNmYjpQLG9mYjpJLGN0cjpSfSx1dGlsczp7aGV4OmEsdXRmODp0fSxwYWRkaW5nOntwa2NzNzp7cGFkOmZ1bmN0aW9uKGUpe3ZhciB0PTE2LShlPW8oZSwhMCkpLmxlbmd0aCUxNixyPXUoZS5sZW5ndGgrdCk7cyhlLHIpO2Zvcih2YXIgbj1lLmxlbmd0aDtuPHIubGVuZ3RoO24rKylyW25dPXQ7cmV0dXJuIHJ9LHN0cmlwOmZ1bmN0aW9uKGUpe2lmKChlPW8oZSwhMCkpLmxlbmd0aDwxNil0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzcgaW52YWxpZCBsZW5ndGhcIik7dmFyIHQ9ZVtlLmxlbmd0aC0xXTtpZigxNjx0KXRocm93IG5ldyBFcnJvcihcIlBLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlXCIpO2Zvcih2YXIgcj1lLmxlbmd0aC10LG49MDtuPHQ7bisrKWlmKGVbcituXSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlXCIpO3ZhciBpPXUocik7cmV0dXJuIHMoZSxpLDAsMCxyKSxpfX19LF9hcnJheVRlc3Q6e2NvZXJjZUFycmF5Om8sY3JlYXRlQXJyYXk6dSxjb3B5QXJyYXk6c319O3ZvaWQgMCE9PUw/Qy5leHBvcnRzPU86KGUuYWVzanMmJihPLl9hZXNqcz1lLmFlc2pzKSxlLmFlc2pzPU8pfSh0aGlzKX0se31dLDk6W2Z1bmN0aW9uKEEsZSx0KXshZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB5KGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKHR8fFwiQXNzZXJ0aW9uIGZhaWxlZFwiKX1mdW5jdGlvbiByKGUsdCl7ZS5zdXBlcl89dDtmdW5jdGlvbiByKCl7fXIucHJvdG90eXBlPXQucHJvdG90eXBlLGUucHJvdG90eXBlPW5ldyByLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV9ZnVuY3Rpb24gbShlLHQscil7aWYobS5pc0JOKGUpKXJldHVybiBlO3RoaXMubmVnYXRpdmU9MCx0aGlzLndvcmRzPW51bGwsdGhpcy5sZW5ndGg9MCwodGhpcy5yZWQ9bnVsbCkhPT1lJiYoXCJsZVwiIT09dCYmXCJiZVwiIT09dHx8KHI9dCx0PTEwKSx0aGlzLl9pbml0KGV8fDAsdHx8MTAscnx8XCJiZVwiKSl9dmFyIG47XCJvYmplY3RcIj09dHlwZW9mIGU/ZS5leHBvcnRzPW06dC5CTj1tLChtLkJOPW0pLndvcmRTaXplPTI2O3RyeXtuPUEoXCJidWZmZXJcIikuQnVmZmVyfWNhdGNoKGUpe31mdW5jdGlvbiBzKGUsdCxyKXtmb3IodmFyIG49MCxpPU1hdGgubWluKGUubGVuZ3RoLHIpLG89dDtvPGk7bysrKXt2YXIgcz1lLmNoYXJDb2RlQXQobyktNDg7bjw8PTQsbnw9NDk8PXMmJnM8PTU0P3MtNDkrMTA6MTc8PXMmJnM8PTIyP3MtMTcrMTA6MTUmc31yZXR1cm4gbn1mdW5jdGlvbiBmKGUsdCxyLG4pe2Zvcih2YXIgaT0wLG89TWF0aC5taW4oZS5sZW5ndGgscikscz10O3M8bztzKyspe3ZhciBhPWUuY2hhckNvZGVBdChzKS00ODtpKj1uLGkrPTQ5PD1hP2EtNDkrMTA6MTc8PWE/YS0xNysxMDphfXJldHVybiBpfW0uaXNCTj1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIG18fG51bGwhPT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZS5jb25zdHJ1Y3Rvci53b3JkU2l6ZT09PW0ud29yZFNpemUmJkFycmF5LmlzQXJyYXkoZS53b3Jkcyl9LG0ubWF4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA8ZS5jbXAodCk/ZTp0fSxtLm1pbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLmNtcCh0KTwwP2U6dH0sbS5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oZSx0LHIpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiB0aGlzLl9pbml0TnVtYmVyKGUsdCxyKTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm4gdGhpcy5faW5pdEFycmF5KGUsdCxyKTtcImhleFwiPT09dCYmKHQ9MTYpLHkodD09PSgwfHQpJiYyPD10JiZ0PD0zNik7dmFyIG49MDtcIi1cIj09PShlPWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csXCJcIikpWzBdJiZuKyssMTY9PT10P3RoaXMuX3BhcnNlSGV4KGUsbik6dGhpcy5fcGFyc2VCYXNlKGUsdCxuKSxcIi1cIj09PWVbMF0mJih0aGlzLm5lZ2F0aXZlPTEpLHRoaXMuc3RyaXAoKSxcImxlXCI9PT1yJiZ0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksdCxyKX0sbS5wcm90b3R5cGUuX2luaXROdW1iZXI9ZnVuY3Rpb24oZSx0LHIpe2U8MCYmKHRoaXMubmVnYXRpdmU9MSxlPS1lKSxlPDY3MTA4ODY0Pyh0aGlzLndvcmRzPVs2NzEwODg2MyZlXSx0aGlzLmxlbmd0aD0xKTplPDQ1MDM1OTk2MjczNzA0OTY/KHRoaXMud29yZHM9WzY3MTA4ODYzJmUsZS82NzEwODg2NCY2NzEwODg2M10sdGhpcy5sZW5ndGg9Mik6KHkoZTw5MDA3MTk5MjU0NzQwOTkyKSx0aGlzLndvcmRzPVs2NzEwODg2MyZlLGUvNjcxMDg4NjQmNjcxMDg4NjMsMV0sdGhpcy5sZW5ndGg9MyksXCJsZVwiPT09ciYmdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLHQscil9LG0ucHJvdG90eXBlLl9pbml0QXJyYXk9ZnVuY3Rpb24oZSx0LHIpe2lmKHkoXCJudW1iZXJcIj09dHlwZW9mIGUubGVuZ3RoKSxlLmxlbmd0aDw9MClyZXR1cm4gdGhpcy53b3Jkcz1bMF0sdGhpcy5sZW5ndGg9MSx0aGlzO3RoaXMubGVuZ3RoPU1hdGguY2VpbChlLmxlbmd0aC8zKSx0aGlzLndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciBuLGksbz0wO288dGhpcy5sZW5ndGg7bysrKXRoaXMud29yZHNbb109MDt2YXIgcz0wO2lmKFwiYmVcIj09PXIpZm9yKG89ZS5sZW5ndGgtMSxuPTA7MDw9bztvLT0zKWk9ZVtvXXxlW28tMV08PDh8ZVtvLTJdPDwxNix0aGlzLndvcmRzW25dfD1pPDxzJjY3MTA4ODYzLHRoaXMud29yZHNbbisxXT1pPj4+MjYtcyY2NzEwODg2MywyNjw9KHMrPTI0KSYmKHMtPTI2LG4rKyk7ZWxzZSBpZihcImxlXCI9PT1yKWZvcihuPW89MDtvPGUubGVuZ3RoO28rPTMpaT1lW29dfGVbbysxXTw8OHxlW28rMl08PDE2LHRoaXMud29yZHNbbl18PWk8PHMmNjcxMDg4NjMsdGhpcy53b3Jkc1tuKzFdPWk+Pj4yNi1zJjY3MTA4ODYzLDI2PD0ocys9MjQpJiYocy09MjYsbisrKTtyZXR1cm4gdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5fcGFyc2VIZXg9ZnVuY3Rpb24oZSx0KXt0aGlzLmxlbmd0aD1NYXRoLmNlaWwoKGUubGVuZ3RoLXQpLzYpLHRoaXMud29yZHM9bmV3IEFycmF5KHRoaXMubGVuZ3RoKTtmb3IodmFyIHIsbj0wO248dGhpcy5sZW5ndGg7bisrKXRoaXMud29yZHNbbl09MDtmb3IodmFyIGk9MCxuPWUubGVuZ3RoLTYsbz0wO3Q8PW47bi09NilyPXMoZSxuLG4rNiksdGhpcy53b3Jkc1tvXXw9cjw8aSY2NzEwODg2Myx0aGlzLndvcmRzW28rMV18PXI+Pj4yNi1pJjQxOTQzMDMsMjY8PShpKz0yNCkmJihpLT0yNixvKyspO24rNiE9PXQmJihyPXMoZSx0LG4rNiksdGhpcy53b3Jkc1tvXXw9cjw8aSY2NzEwODg2Myx0aGlzLndvcmRzW28rMV18PXI+Pj4yNi1pJjQxOTQzMDMpLHRoaXMuc3RyaXAoKX0sbS5wcm90b3R5cGUuX3BhcnNlQmFzZT1mdW5jdGlvbihlLHQscil7dGhpcy53b3Jkcz1bMF07Zm9yKHZhciBuPTAsaT10aGlzLmxlbmd0aD0xO2k8PTY3MTA4ODYzO2kqPXQpbisrO24tLSxpPWkvdHwwO2Zvcih2YXIgbz1lLmxlbmd0aC1yLHM9byVuLGE9TWF0aC5taW4obyxvLXMpK3IsdT0wLGw9cjtsPGE7bCs9bil1PWYoZSxsLGwrbix0KSx0aGlzLmltdWxuKGkpLHRoaXMud29yZHNbMF0rdTw2NzEwODg2ND90aGlzLndvcmRzWzBdKz11OnRoaXMuX2lhZGRuKHUpO2lmKDAhPXMpe2Zvcih2YXIgaD0xLHU9ZihlLGwsZS5sZW5ndGgsdCksbD0wO2w8cztsKyspaCo9dDt0aGlzLmltdWxuKGgpLHRoaXMud29yZHNbMF0rdTw2NzEwODg2ND90aGlzLndvcmRzWzBdKz11OnRoaXMuX2lhZGRuKHUpfX0sbS5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlKXtlLndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciB0PTA7dDx0aGlzLmxlbmd0aDt0KyspZS53b3Jkc1t0XT10aGlzLndvcmRzW3RdO2UubGVuZ3RoPXRoaXMubGVuZ3RoLGUubmVnYXRpdmU9dGhpcy5uZWdhdGl2ZSxlLnJlZD10aGlzLnJlZH0sbS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbShudWxsKTtyZXR1cm4gdGhpcy5jb3B5KGUpLGV9LG0ucHJvdG90eXBlLl9leHBhbmQ9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLmxlbmd0aDxlOyl0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdPTA7cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLnN0cmlwPWZ1bmN0aW9uKCl7Zm9yKDsxPHRoaXMubGVuZ3RoJiYwPT09dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXTspdGhpcy5sZW5ndGgtLTtyZXR1cm4gdGhpcy5fbm9ybVNpZ24oKX0sbS5wcm90b3R5cGUuX25vcm1TaWduPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxlbmd0aCYmMD09PXRoaXMud29yZHNbMF0mJih0aGlzLm5lZ2F0aXZlPTApLHRoaXN9LG0ucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5yZWQ/XCI8Qk4tUjogXCI6XCI8Qk46IFwiKSt0aGlzLnRvU3RyaW5nKDE2KStcIj5cIn07dmFyIGM9W1wiXCIsXCIwXCIsXCIwMFwiLFwiMDAwXCIsXCIwMDAwXCIsXCIwMDAwMFwiLFwiMDAwMDAwXCIsXCIwMDAwMDAwXCIsXCIwMDAwMDAwMFwiLFwiMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJdLGQ9WzAsMCwyNSwxNiwxMiwxMSwxMCw5LDgsOCw3LDcsNyw3LDYsNiw2LDYsNiw2LDYsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNV0scD1bMCwwLDMzNTU0NDMyLDQzMDQ2NzIxLDE2Nzc3MjE2LDQ4ODI4MTI1LDYwNDY2MTc2LDQwMzUzNjA3LDE2Nzc3MjE2LDQzMDQ2NzIxLDFlNywxOTQ4NzE3MSwzNTgzMTgwOCw2Mjc0ODUxNyw3NTI5NTM2LDExMzkwNjI1LDE2Nzc3MjE2LDI0MTM3NTY5LDM0MDEyMjI0LDQ3MDQ1ODgxLDY0ZTYsNDA4NDEwMSw1MTUzNjMyLDY0MzYzNDMsNzk2MjYyNCw5NzY1NjI1LDExODgxMzc2LDE0MzQ4OTA3LDE3MjEwMzY4LDIwNTExMTQ5LDI0M2U1LDI4NjI5MTUxLDMzNTU0NDMyLDM5MTM1MzkzLDQ1NDM1NDI0LDUyNTIxODc1LDYwNDY2MTc2XTtmdW5jdGlvbiBpKGUsdCxyKXtyLm5lZ2F0aXZlPXQubmVnYXRpdmVeZS5uZWdhdGl2ZTt2YXIgbj1lLmxlbmd0aCt0Lmxlbmd0aHwwLG49KHIubGVuZ3RoPW4pLTF8MCxpPTY3MTA4ODYzJihmPSgwfGUud29yZHNbMF0pKigwfHQud29yZHNbMF0pKSxvPWYvNjcxMDg4NjR8MDtyLndvcmRzWzBdPWk7Zm9yKHZhciBzPTE7czxuO3MrKyl7Zm9yKHZhciBhPW8+Pj4yNix1PTY3MTA4ODYzJm8sbD1NYXRoLm1pbihzLHQubGVuZ3RoLTEpLGg9TWF0aC5tYXgoMCxzLWUubGVuZ3RoKzEpO2g8PWw7aCsrKXt2YXIgZixjPXMtaHwwO2ErPShmPSgwfGUud29yZHNbY10pKigwfHQud29yZHNbaF0pK3UpLzY3MTA4ODY0fDAsdT02NzEwODg2MyZmfXIud29yZHNbc109MHx1LG89MHxhfXJldHVybiAwIT09bz9yLndvcmRzW3NdPTB8bzpyLmxlbmd0aC0tLHIuc3RyaXAoKX1tLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlLHQpe2lmKHQ9MHx0fHwxLDE2PT09KGU9ZXx8MTApfHxcImhleFwiPT09ZSl7YT1cIlwiO2Zvcih2YXIgcj0wLG49MCxpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXMud29yZHNbaV0scz0oMTY3NzcyMTUmKG88PHJ8bikpLnRvU3RyaW5nKDE2KSxhPTAhPT0obj1vPj4+MjQtciYxNjc3NzIxNSl8fGkhPT10aGlzLmxlbmd0aC0xP2NbNi1zLmxlbmd0aF0rcythOnMrYTsyNjw9KHIrPTIpJiYoci09MjYsaS0tKX1mb3IoMCE9PW4mJihhPW4udG9TdHJpbmcoMTYpK2EpO2EubGVuZ3RoJXQhPTA7KWE9XCIwXCIrYTtyZXR1cm4gMCE9PXRoaXMubmVnYXRpdmUmJihhPVwiLVwiK2EpLGF9aWYoZT09PSgwfGUpJiYyPD1lJiZlPD0zNil7dmFyIHU9ZFtlXSxsPXBbZV07Zm9yKGE9XCJcIiwoaD10aGlzLmNsb25lKCkpLm5lZ2F0aXZlPTA7IWguaXNaZXJvKCk7KXt2YXIgaCxmPWgubW9kbihsKS50b1N0cmluZyhlKTthPShoPWguaWRpdm4obCkpLmlzWmVybygpP2YrYTpjW3UtZi5sZW5ndGhdK2YrYX1mb3IodGhpcy5pc1plcm8oKSYmKGE9XCIwXCIrYSk7YS5sZW5ndGgldCE9MDspYT1cIjBcIithO3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZSYmKGE9XCItXCIrYSksYX15KCExLFwiQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNlwiKX0sbS5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzWzBdO3JldHVybiAyPT09dGhpcy5sZW5ndGg/ZSs9NjcxMDg4NjQqdGhpcy53b3Jkc1sxXTozPT09dGhpcy5sZW5ndGgmJjE9PT10aGlzLndvcmRzWzJdP2UrPTQ1MDM1OTk2MjczNzA0OTYrNjcxMDg4NjQqdGhpcy53b3Jkc1sxXToyPHRoaXMubGVuZ3RoJiZ5KCExLFwiTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzXCIpLDAhPT10aGlzLm5lZ2F0aXZlPy1lOmV9LG0ucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvU3RyaW5nKDE2KX0sbS5wcm90b3R5cGUudG9CdWZmZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4geSh2b2lkIDAhPT1uKSx0aGlzLnRvQXJyYXlMaWtlKG4sZSx0KX0sbS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LGUsdCl9LG0ucHJvdG90eXBlLnRvQXJyYXlMaWtlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmJ5dGVMZW5ndGgoKSxpPXJ8fE1hdGgubWF4KDEsbik7eShuPD1pLFwiYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aFwiKSx5KDA8aSxcIlJlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMFwiKSx0aGlzLnN0cmlwKCk7dmFyIG8scyxhPVwibGVcIj09PXQsdT1uZXcgZShpKSxsPXRoaXMuY2xvbmUoKTtpZihhKXtmb3Iocz0wOyFsLmlzWmVybygpO3MrKylvPWwuYW5kbG4oMjU1KSxsLml1c2hybig4KSx1W3NdPW87Zm9yKDtzPGk7cysrKXVbc109MH1lbHNle2ZvcihzPTA7czxpLW47cysrKXVbc109MDtmb3Iocz0wOyFsLmlzWmVybygpO3MrKylvPWwuYW5kbG4oMjU1KSxsLml1c2hybig4KSx1W2ktcy0xXT1vfXJldHVybiB1fSxNYXRoLmNsejMyP20ucHJvdG90eXBlLl9jb3VudEJpdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDMyLU1hdGguY2x6MzIoZSl9Om0ucHJvdG90eXBlLl9jb3VudEJpdHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZSxyPTA7cmV0dXJuIDQwOTY8PXQmJihyKz0xMyx0Pj4+PTEzKSw2NDw9dCYmKHIrPTcsdD4+Pj03KSw4PD10JiYocis9NCx0Pj4+PTQpLDI8PXQmJihyKz0yLHQ+Pj49Mikscit0fSxtLnByb3RvdHlwZS5femVyb0JpdHM9ZnVuY3Rpb24oZSl7aWYoMD09PWUpcmV0dXJuIDI2O3ZhciB0PWUscj0wO3JldHVybiAwPT0oODE5MSZ0KSYmKHIrPTEzLHQ+Pj49MTMpLDA9PSgxMjcmdCkmJihyKz03LHQ+Pj49NyksMD09KDE1JnQpJiYocis9NCx0Pj4+PTQpLDA9PSgzJnQpJiYocis9Mix0Pj4+PTIpLDA9PSgxJnQpJiZyKysscn0sbS5wcm90b3R5cGUuYml0TGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXSx0PXRoaXMuX2NvdW50Qml0cyhlKTtyZXR1cm4gMjYqKHRoaXMubGVuZ3RoLTEpK3R9LG0ucHJvdG90eXBlLnplcm9CaXRzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gMDtmb3IodmFyIGU9MCx0PTA7dDx0aGlzLmxlbmd0aDt0Kyspe3ZhciByPXRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbdF0pO2lmKGUrPXIsMjYhPT1yKWJyZWFrfXJldHVybiBlfSxtLnByb3RvdHlwZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpLzgpfSxtLnByb3RvdHlwZS50b1R3b3M9ZnVuY3Rpb24oZSl7cmV0dXJuIDAhPT10aGlzLm5lZ2F0aXZlP3RoaXMuYWJzKCkuaW5vdG4oZSkuaWFkZG4oMSk6dGhpcy5jbG9uZSgpfSxtLnByb3RvdHlwZS5mcm9tVHdvcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZXN0bihlLTEpP3RoaXMubm90bihlKS5pYWRkbigxKS5pbmVnKCk6dGhpcy5jbG9uZSgpfSxtLnByb3RvdHlwZS5pc05lZz1mdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZX0sbS5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCl9LG0ucHJvdG90eXBlLmluZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1plcm8oKXx8KHRoaXMubmVnYXRpdmVePTEpLHRoaXN9LG0ucHJvdG90eXBlLml1b3I9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLmxlbmd0aDxlLmxlbmd0aDspdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXT0wO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXRoaXMud29yZHNbdF09dGhpcy53b3Jkc1t0XXxlLndvcmRzW3RdO3JldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlvcj1mdW5jdGlvbihlKXtyZXR1cm4geSgwPT0odGhpcy5uZWdhdGl2ZXxlLm5lZ2F0aXZlKSksdGhpcy5pdW9yKGUpfSxtLnByb3RvdHlwZS5vcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sZW5ndGg+ZS5sZW5ndGg/dGhpcy5jbG9uZSgpLmlvcihlKTplLmNsb25lKCkuaW9yKHRoaXMpfSxtLnByb3RvdHlwZS51b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pdW9yKGUpOmUuY2xvbmUoKS5pdW9yKHRoaXMpfSxtLnByb3RvdHlwZS5pdWFuZD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5sZW5ndGg+ZS5sZW5ndGg/ZTp0aGlzLHI9MDtyPHQubGVuZ3RoO3IrKyl0aGlzLndvcmRzW3JdPXRoaXMud29yZHNbcl0mZS53b3Jkc1tyXTtyZXR1cm4gdGhpcy5sZW5ndGg9dC5sZW5ndGgsdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5pYW5kPWZ1bmN0aW9uKGUpe3JldHVybiB5KDA9PSh0aGlzLm5lZ2F0aXZlfGUubmVnYXRpdmUpKSx0aGlzLml1YW5kKGUpfSxtLnByb3RvdHlwZS5hbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pYW5kKGUpOmUuY2xvbmUoKS5pYW5kKHRoaXMpfSxtLnByb3RvdHlwZS51YW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbmd0aD5lLmxlbmd0aD90aGlzLmNsb25lKCkuaXVhbmQoZSk6ZS5jbG9uZSgpLml1YW5kKHRoaXMpfSxtLnByb3RvdHlwZS5pdXhvcj1mdW5jdGlvbihlKXtmb3IodmFyIHQscj10aGlzLmxlbmd0aD5lLmxlbmd0aD8odD10aGlzLGUpOih0PWUsdGhpcyksbj0wO248ci5sZW5ndGg7bisrKXRoaXMud29yZHNbbl09dC53b3Jkc1tuXV5yLndvcmRzW25dO2lmKHRoaXMhPT10KWZvcig7bjx0Lmxlbmd0aDtuKyspdGhpcy53b3Jkc1tuXT10LndvcmRzW25dO3JldHVybiB0aGlzLmxlbmd0aD10Lmxlbmd0aCx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLml4b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHkoMD09KHRoaXMubmVnYXRpdmV8ZS5uZWdhdGl2ZSkpLHRoaXMuaXV4b3IoZSl9LG0ucHJvdG90eXBlLnhvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sZW5ndGg+ZS5sZW5ndGg/dGhpcy5jbG9uZSgpLml4b3IoZSk6ZS5jbG9uZSgpLml4b3IodGhpcyl9LG0ucHJvdG90eXBlLnV4b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pdXhvcihlKTplLmNsb25lKCkuaXV4b3IodGhpcyl9LG0ucHJvdG90eXBlLmlub3RuPWZ1bmN0aW9uKGUpe3koXCJudW1iZXJcIj09dHlwZW9mIGUmJjA8PWUpO3ZhciB0PTB8TWF0aC5jZWlsKGUvMjYpLHI9ZSUyNjt0aGlzLl9leHBhbmQodCksMDxyJiZ0LS07Zm9yKHZhciBuPTA7bjx0O24rKyl0aGlzLndvcmRzW25dPTY3MTA4ODYzJn50aGlzLndvcmRzW25dO3JldHVybiAwPHImJih0aGlzLndvcmRzW25dPX50aGlzLndvcmRzW25dJjY3MTA4ODYzPj4yNi1yKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLm5vdG49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bihlKX0sbS5wcm90b3R5cGUuc2V0bj1mdW5jdGlvbihlLHQpe3koXCJudW1iZXJcIj09dHlwZW9mIGUmJjA8PWUpO3ZhciByPWUvMjZ8MCxuPWUlMjY7cmV0dXJuIHRoaXMuX2V4cGFuZCgxK3IpLHRoaXMud29yZHNbcl09dD90aGlzLndvcmRzW3JdfDE8PG46dGhpcy53b3Jkc1tyXSZ+KDE8PG4pLHRoaXMuc3RyaXAoKX0sbS5wcm90b3R5cGUuaWFkZD1mdW5jdGlvbihlKXt2YXIgdCxyLG47aWYoMCE9PXRoaXMubmVnYXRpdmUmJjA9PT1lLm5lZ2F0aXZlKXJldHVybiB0aGlzLm5lZ2F0aXZlPTAsdD10aGlzLmlzdWIoZSksdGhpcy5uZWdhdGl2ZV49MSx0aGlzLl9ub3JtU2lnbigpO2lmKDA9PT10aGlzLm5lZ2F0aXZlJiYwIT09ZS5uZWdhdGl2ZSlyZXR1cm4gZS5uZWdhdGl2ZT0wLHQ9dGhpcy5pc3ViKGUpLGUubmVnYXRpdmU9MSx0Ll9ub3JtU2lnbigpO249dGhpcy5sZW5ndGg+ZS5sZW5ndGg/KHI9dGhpcyxlKToocj1lLHRoaXMpO2Zvcih2YXIgaT0wLG89MDtvPG4ubGVuZ3RoO28rKyl0PSgwfHIud29yZHNbb10pKygwfG4ud29yZHNbb10pK2ksdGhpcy53b3Jkc1tvXT02NzEwODg2MyZ0LGk9dD4+PjI2O2Zvcig7MCE9PWkmJm88ci5sZW5ndGg7bysrKXQ9KDB8ci53b3Jkc1tvXSkraSx0aGlzLndvcmRzW29dPTY3MTA4ODYzJnQsaT10Pj4+MjY7aWYodGhpcy5sZW5ndGg9ci5sZW5ndGgsMCE9PWkpdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF09aSx0aGlzLmxlbmd0aCsrO2Vsc2UgaWYociE9PXRoaXMpZm9yKDtvPHIubGVuZ3RoO28rKyl0aGlzLndvcmRzW29dPXIud29yZHNbb107cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gMCE9PWUubmVnYXRpdmUmJjA9PT10aGlzLm5lZ2F0aXZlPyhlLm5lZ2F0aXZlPTAsdD10aGlzLnN1YihlKSxlLm5lZ2F0aXZlXj0xLHQpOjA9PT1lLm5lZ2F0aXZlJiYwIT09dGhpcy5uZWdhdGl2ZT8odGhpcy5uZWdhdGl2ZT0wLHQ9ZS5zdWIodGhpcyksdGhpcy5uZWdhdGl2ZT0xLHQpOnRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pYWRkKGUpOmUuY2xvbmUoKS5pYWRkKHRoaXMpfSxtLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uKGUpe2lmKDAhPT1lLm5lZ2F0aXZlKXtlLm5lZ2F0aXZlPTA7dmFyIHQ9dGhpcy5pYWRkKGUpO3JldHVybiBlLm5lZ2F0aXZlPTEsdC5fbm9ybVNpZ24oKX1pZigwIT09dGhpcy5uZWdhdGl2ZSlyZXR1cm4gdGhpcy5uZWdhdGl2ZT0wLHRoaXMuaWFkZChlKSx0aGlzLm5lZ2F0aXZlPTEsdGhpcy5fbm9ybVNpZ24oKTt2YXIgcixuLGk9dGhpcy5jbXAoZSk7aWYoMD09PWkpcmV0dXJuIHRoaXMubmVnYXRpdmU9MCx0aGlzLmxlbmd0aD0xLHRoaXMud29yZHNbMF09MCx0aGlzO249MDxpPyhyPXRoaXMsZSk6KHI9ZSx0aGlzKTtmb3IodmFyIG89MCxzPTA7czxuLmxlbmd0aDtzKyspbz0odD0oMHxyLndvcmRzW3NdKS0oMHxuLndvcmRzW3NdKStvKT4+MjYsdGhpcy53b3Jkc1tzXT02NzEwODg2MyZ0O2Zvcig7MCE9PW8mJnM8ci5sZW5ndGg7cysrKW89KHQ9KDB8ci53b3Jkc1tzXSkrbyk+PjI2LHRoaXMud29yZHNbc109NjcxMDg4NjMmdDtpZigwPT09byYmczxyLmxlbmd0aCYmciE9PXRoaXMpZm9yKDtzPHIubGVuZ3RoO3MrKyl0aGlzLndvcmRzW3NdPXIud29yZHNbc107cmV0dXJuIHRoaXMubGVuZ3RoPU1hdGgubWF4KHRoaXMubGVuZ3RoLHMpLHIhPT10aGlzJiYodGhpcy5uZWdhdGl2ZT0xKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIoZSl9O3ZhciBvPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpLG8scz1lLndvcmRzLGE9dC53b3Jkcyx1PXIud29yZHMsbD0wfHNbMF0saD04MTkxJmwsZj1sPj4+MTMsYz0wfHNbMV0sZD04MTkxJmMscD1jPj4+MTMsdj0wfHNbMl0seT04MTkxJnYsbT12Pj4+MTMsZz0wfHNbM10sYj04MTkxJmcsdz1nPj4+MTMsXz0wfHNbNF0sTT04MTkxJl8sQT1fPj4+MTMsRT0wfHNbNV0sUz04MTkxJkUsaz1FPj4+MTMsTj0wfHNbNl0seD04MTkxJk4sUD1OPj4+MTMsST0wfHNbN10sVD04MTkxJkksUj1JPj4+MTMsTz0wfHNbOF0sQz04MTkxJk8sTD1PPj4+MTMsQj0wfHNbOV0sRD04MTkxJkIsVT1CPj4+MTMsRj0wfGFbMF0saj04MTkxJkYsRz1GPj4+MTMsSD0wfGFbMV0sej04MTkxJkgsVj1IPj4+MTMsSz0wfGFbMl0scT04MTkxJkssVz1LPj4+MTMsWj0wfGFbM10sSj04MTkxJlosWD1aPj4+MTMsJD0wfGFbNF0sUT04MTkxJiQsWT0kPj4+MTMsZWU9MHxhWzVdLHRlPTgxOTEmZWUscmU9ZWU+Pj4xMyxuZT0wfGFbNl0saWU9ODE5MSZuZSxvZT1uZT4+PjEzLHNlPTB8YVs3XSxhZT04MTkxJnNlLHVlPXNlPj4+MTMsbGU9MHxhWzhdLGhlPTgxOTEmbGUsZmU9bGU+Pj4xMyxjZT0wfGFbOV0sZGU9ODE5MSZjZSxwZT1jZT4+PjEzO3IubmVnYXRpdmU9ZS5uZWdhdGl2ZV50Lm5lZ2F0aXZlLHIubGVuZ3RoPTE5O3ZhciB2ZT0oMCtNYXRoLmltdWwoaCxqKXwwKSsoKDgxOTEmKGk9TWF0aC5pbXVsKGgsRykrTWF0aC5pbXVsKGYsail8MCkpPDwxMyl8MCx5ZT0oTWF0aC5pbXVsKGYsRykrKGk+Pj4xMyl8MCkrKHZlPj4+MjYpfDA7dmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKGQsaiksaT1NYXRoLmltdWwoZCxHKStNYXRoLmltdWwocCxqKXwwLG89TWF0aC5pbXVsKHAsRyk7dmFyIG1lPSh5ZSsobitNYXRoLmltdWwoaCx6KXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsVil8MCkrTWF0aC5pbXVsKGYseil8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsVil8MCkrKGk+Pj4xMyl8MCkrKG1lPj4+MjYpfDAsbWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKHksaiksaT1NYXRoLmltdWwoeSxHKStNYXRoLmltdWwobSxqKXwwLG89TWF0aC5pbXVsKG0sRyksbj1uK01hdGguaW11bChkLHopfDAsaT0oaStNYXRoLmltdWwoZCxWKXwwKStNYXRoLmltdWwocCx6KXwwLG89bytNYXRoLmltdWwocCxWKXwwO3ZhciBnZT0oeWUrKG4rTWF0aC5pbXVsKGgscSl8MCl8MCkrKCg4MTkxJihpPShpK01hdGguaW11bChoLFcpfDApK01hdGguaW11bChmLHEpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLFcpfDApKyhpPj4+MTMpfDApKyhnZT4+PjI2KXwwLGdlJj02NzEwODg2MyxuPU1hdGguaW11bChiLGopLGk9TWF0aC5pbXVsKGIsRykrTWF0aC5pbXVsKHcsail8MCxvPU1hdGguaW11bCh3LEcpLG49bitNYXRoLmltdWwoeSx6KXwwLGk9KGkrTWF0aC5pbXVsKHksVil8MCkrTWF0aC5pbXVsKG0seil8MCxvPW8rTWF0aC5pbXVsKG0sVil8MCxuPW4rTWF0aC5pbXVsKGQscSl8MCxpPShpK01hdGguaW11bChkLFcpfDApK01hdGguaW11bChwLHEpfDAsbz1vK01hdGguaW11bChwLFcpfDA7dmFyIGJlPSh5ZSsobitNYXRoLmltdWwoaCxKKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsWCl8MCkrTWF0aC5pbXVsKGYsSil8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsWCl8MCkrKGk+Pj4xMyl8MCkrKGJlPj4+MjYpfDAsYmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKE0saiksaT1NYXRoLmltdWwoTSxHKStNYXRoLmltdWwoQSxqKXwwLG89TWF0aC5pbXVsKEEsRyksbj1uK01hdGguaW11bChiLHopfDAsaT0oaStNYXRoLmltdWwoYixWKXwwKStNYXRoLmltdWwodyx6KXwwLG89bytNYXRoLmltdWwodyxWKXwwLG49bitNYXRoLmltdWwoeSxxKXwwLGk9KGkrTWF0aC5pbXVsKHksVyl8MCkrTWF0aC5pbXVsKG0scSl8MCxvPW8rTWF0aC5pbXVsKG0sVyl8MCxuPW4rTWF0aC5pbXVsKGQsSil8MCxpPShpK01hdGguaW11bChkLFgpfDApK01hdGguaW11bChwLEopfDAsbz1vK01hdGguaW11bChwLFgpfDA7dmFyIHdlPSh5ZSsobitNYXRoLmltdWwoaCxRKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsWSl8MCkrTWF0aC5pbXVsKGYsUSl8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsWSl8MCkrKGk+Pj4xMyl8MCkrKHdlPj4+MjYpfDAsd2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKFMsaiksaT1NYXRoLmltdWwoUyxHKStNYXRoLmltdWwoayxqKXwwLG89TWF0aC5pbXVsKGssRyksbj1uK01hdGguaW11bChNLHopfDAsaT0oaStNYXRoLmltdWwoTSxWKXwwKStNYXRoLmltdWwoQSx6KXwwLG89bytNYXRoLmltdWwoQSxWKXwwLG49bitNYXRoLmltdWwoYixxKXwwLGk9KGkrTWF0aC5pbXVsKGIsVyl8MCkrTWF0aC5pbXVsKHcscSl8MCxvPW8rTWF0aC5pbXVsKHcsVyl8MCxuPW4rTWF0aC5pbXVsKHksSil8MCxpPShpK01hdGguaW11bCh5LFgpfDApK01hdGguaW11bChtLEopfDAsbz1vK01hdGguaW11bChtLFgpfDAsbj1uK01hdGguaW11bChkLFEpfDAsaT0oaStNYXRoLmltdWwoZCxZKXwwKStNYXRoLmltdWwocCxRKXwwLG89bytNYXRoLmltdWwocCxZKXwwO3ZhciBfZT0oeWUrKG4rTWF0aC5pbXVsKGgsdGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoaCxyZSl8MCkrTWF0aC5pbXVsKGYsdGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLHJlKXwwKSsoaT4+PjEzKXwwKSsoX2U+Pj4yNil8MCxfZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoeCxqKSxpPU1hdGguaW11bCh4LEcpK01hdGguaW11bChQLGopfDAsbz1NYXRoLmltdWwoUCxHKSxuPW4rTWF0aC5pbXVsKFMseil8MCxpPShpK01hdGguaW11bChTLFYpfDApK01hdGguaW11bChrLHopfDAsbz1vK01hdGguaW11bChrLFYpfDAsbj1uK01hdGguaW11bChNLHEpfDAsaT0oaStNYXRoLmltdWwoTSxXKXwwKStNYXRoLmltdWwoQSxxKXwwLG89bytNYXRoLmltdWwoQSxXKXwwLG49bitNYXRoLmltdWwoYixKKXwwLGk9KGkrTWF0aC5pbXVsKGIsWCl8MCkrTWF0aC5pbXVsKHcsSil8MCxvPW8rTWF0aC5pbXVsKHcsWCl8MCxuPW4rTWF0aC5pbXVsKHksUSl8MCxpPShpK01hdGguaW11bCh5LFkpfDApK01hdGguaW11bChtLFEpfDAsbz1vK01hdGguaW11bChtLFkpfDAsbj1uK01hdGguaW11bChkLHRlKXwwLGk9KGkrTWF0aC5pbXVsKGQscmUpfDApK01hdGguaW11bChwLHRlKXwwLG89bytNYXRoLmltdWwocCxyZSl8MDt2YXIgTWU9KHllKyhuK01hdGguaW11bChoLGllKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsb2UpfDApK01hdGguaW11bChmLGllKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZixvZSl8MCkrKGk+Pj4xMyl8MCkrKE1lPj4+MjYpfDAsTWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKFQsaiksaT1NYXRoLmltdWwoVCxHKStNYXRoLmltdWwoUixqKXwwLG89TWF0aC5pbXVsKFIsRyksbj1uK01hdGguaW11bCh4LHopfDAsaT0oaStNYXRoLmltdWwoeCxWKXwwKStNYXRoLmltdWwoUCx6KXwwLG89bytNYXRoLmltdWwoUCxWKXwwLG49bitNYXRoLmltdWwoUyxxKXwwLGk9KGkrTWF0aC5pbXVsKFMsVyl8MCkrTWF0aC5pbXVsKGsscSl8MCxvPW8rTWF0aC5pbXVsKGssVyl8MCxuPW4rTWF0aC5pbXVsKE0sSil8MCxpPShpK01hdGguaW11bChNLFgpfDApK01hdGguaW11bChBLEopfDAsbz1vK01hdGguaW11bChBLFgpfDAsbj1uK01hdGguaW11bChiLFEpfDAsaT0oaStNYXRoLmltdWwoYixZKXwwKStNYXRoLmltdWwodyxRKXwwLG89bytNYXRoLmltdWwodyxZKXwwLG49bitNYXRoLmltdWwoeSx0ZSl8MCxpPShpK01hdGguaW11bCh5LHJlKXwwKStNYXRoLmltdWwobSx0ZSl8MCxvPW8rTWF0aC5pbXVsKG0scmUpfDAsbj1uK01hdGguaW11bChkLGllKXwwLGk9KGkrTWF0aC5pbXVsKGQsb2UpfDApK01hdGguaW11bChwLGllKXwwLG89bytNYXRoLmltdWwocCxvZSl8MDt2YXIgQWU9KHllKyhuK01hdGguaW11bChoLGFlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsdWUpfDApK01hdGguaW11bChmLGFlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZix1ZSl8MCkrKGk+Pj4xMyl8MCkrKEFlPj4+MjYpfDAsQWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEMsaiksaT1NYXRoLmltdWwoQyxHKStNYXRoLmltdWwoTCxqKXwwLG89TWF0aC5pbXVsKEwsRyksbj1uK01hdGguaW11bChULHopfDAsaT0oaStNYXRoLmltdWwoVCxWKXwwKStNYXRoLmltdWwoUix6KXwwLG89bytNYXRoLmltdWwoUixWKXwwLG49bitNYXRoLmltdWwoeCxxKXwwLGk9KGkrTWF0aC5pbXVsKHgsVyl8MCkrTWF0aC5pbXVsKFAscSl8MCxvPW8rTWF0aC5pbXVsKFAsVyl8MCxuPW4rTWF0aC5pbXVsKFMsSil8MCxpPShpK01hdGguaW11bChTLFgpfDApK01hdGguaW11bChrLEopfDAsbz1vK01hdGguaW11bChrLFgpfDAsbj1uK01hdGguaW11bChNLFEpfDAsaT0oaStNYXRoLmltdWwoTSxZKXwwKStNYXRoLmltdWwoQSxRKXwwLG89bytNYXRoLmltdWwoQSxZKXwwLG49bitNYXRoLmltdWwoYix0ZSl8MCxpPShpK01hdGguaW11bChiLHJlKXwwKStNYXRoLmltdWwodyx0ZSl8MCxvPW8rTWF0aC5pbXVsKHcscmUpfDAsbj1uK01hdGguaW11bCh5LGllKXwwLGk9KGkrTWF0aC5pbXVsKHksb2UpfDApK01hdGguaW11bChtLGllKXwwLG89bytNYXRoLmltdWwobSxvZSl8MCxuPW4rTWF0aC5pbXVsKGQsYWUpfDAsaT0oaStNYXRoLmltdWwoZCx1ZSl8MCkrTWF0aC5pbXVsKHAsYWUpfDAsbz1vK01hdGguaW11bChwLHVlKXwwO3ZhciBFZT0oeWUrKG4rTWF0aC5pbXVsKGgsaGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoaCxmZSl8MCkrTWF0aC5pbXVsKGYsaGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLGZlKXwwKSsoaT4+PjEzKXwwKSsoRWU+Pj4yNil8MCxFZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxqKSxpPU1hdGguaW11bChELEcpK01hdGguaW11bChVLGopfDAsbz1NYXRoLmltdWwoVSxHKSxuPW4rTWF0aC5pbXVsKEMseil8MCxpPShpK01hdGguaW11bChDLFYpfDApK01hdGguaW11bChMLHopfDAsbz1vK01hdGguaW11bChMLFYpfDAsbj1uK01hdGguaW11bChULHEpfDAsaT0oaStNYXRoLmltdWwoVCxXKXwwKStNYXRoLmltdWwoUixxKXwwLG89bytNYXRoLmltdWwoUixXKXwwLG49bitNYXRoLmltdWwoeCxKKXwwLGk9KGkrTWF0aC5pbXVsKHgsWCl8MCkrTWF0aC5pbXVsKFAsSil8MCxvPW8rTWF0aC5pbXVsKFAsWCl8MCxuPW4rTWF0aC5pbXVsKFMsUSl8MCxpPShpK01hdGguaW11bChTLFkpfDApK01hdGguaW11bChrLFEpfDAsbz1vK01hdGguaW11bChrLFkpfDAsbj1uK01hdGguaW11bChNLHRlKXwwLGk9KGkrTWF0aC5pbXVsKE0scmUpfDApK01hdGguaW11bChBLHRlKXwwLG89bytNYXRoLmltdWwoQSxyZSl8MCxuPW4rTWF0aC5pbXVsKGIsaWUpfDAsaT0oaStNYXRoLmltdWwoYixvZSl8MCkrTWF0aC5pbXVsKHcsaWUpfDAsbz1vK01hdGguaW11bCh3LG9lKXwwLG49bitNYXRoLmltdWwoeSxhZSl8MCxpPShpK01hdGguaW11bCh5LHVlKXwwKStNYXRoLmltdWwobSxhZSl8MCxvPW8rTWF0aC5pbXVsKG0sdWUpfDAsbj1uK01hdGguaW11bChkLGhlKXwwLGk9KGkrTWF0aC5pbXVsKGQsZmUpfDApK01hdGguaW11bChwLGhlKXwwLG89bytNYXRoLmltdWwocCxmZSl8MDt2YXIgU2U9KHllKyhuK01hdGguaW11bChoLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgscGUpfDApK01hdGguaW11bChmLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZixwZSl8MCkrKGk+Pj4xMyl8MCkrKFNlPj4+MjYpfDAsU2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQseiksaT1NYXRoLmltdWwoRCxWKStNYXRoLmltdWwoVSx6KXwwLG89TWF0aC5pbXVsKFUsViksbj1uK01hdGguaW11bChDLHEpfDAsaT0oaStNYXRoLmltdWwoQyxXKXwwKStNYXRoLmltdWwoTCxxKXwwLG89bytNYXRoLmltdWwoTCxXKXwwLG49bitNYXRoLmltdWwoVCxKKXwwLGk9KGkrTWF0aC5pbXVsKFQsWCl8MCkrTWF0aC5pbXVsKFIsSil8MCxvPW8rTWF0aC5pbXVsKFIsWCl8MCxuPW4rTWF0aC5pbXVsKHgsUSl8MCxpPShpK01hdGguaW11bCh4LFkpfDApK01hdGguaW11bChQLFEpfDAsbz1vK01hdGguaW11bChQLFkpfDAsbj1uK01hdGguaW11bChTLHRlKXwwLGk9KGkrTWF0aC5pbXVsKFMscmUpfDApK01hdGguaW11bChrLHRlKXwwLG89bytNYXRoLmltdWwoayxyZSl8MCxuPW4rTWF0aC5pbXVsKE0saWUpfDAsaT0oaStNYXRoLmltdWwoTSxvZSl8MCkrTWF0aC5pbXVsKEEsaWUpfDAsbz1vK01hdGguaW11bChBLG9lKXwwLG49bitNYXRoLmltdWwoYixhZSl8MCxpPShpK01hdGguaW11bChiLHVlKXwwKStNYXRoLmltdWwodyxhZSl8MCxvPW8rTWF0aC5pbXVsKHcsdWUpfDAsbj1uK01hdGguaW11bCh5LGhlKXwwLGk9KGkrTWF0aC5pbXVsKHksZmUpfDApK01hdGguaW11bChtLGhlKXwwLG89bytNYXRoLmltdWwobSxmZSl8MDt2YXIga2U9KHllKyhuK01hdGguaW11bChkLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGQscGUpfDApK01hdGguaW11bChwLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwocCxwZSl8MCkrKGk+Pj4xMyl8MCkrKGtlPj4+MjYpfDAsa2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQscSksaT1NYXRoLmltdWwoRCxXKStNYXRoLmltdWwoVSxxKXwwLG89TWF0aC5pbXVsKFUsVyksbj1uK01hdGguaW11bChDLEopfDAsaT0oaStNYXRoLmltdWwoQyxYKXwwKStNYXRoLmltdWwoTCxKKXwwLG89bytNYXRoLmltdWwoTCxYKXwwLG49bitNYXRoLmltdWwoVCxRKXwwLGk9KGkrTWF0aC5pbXVsKFQsWSl8MCkrTWF0aC5pbXVsKFIsUSl8MCxvPW8rTWF0aC5pbXVsKFIsWSl8MCxuPW4rTWF0aC5pbXVsKHgsdGUpfDAsaT0oaStNYXRoLmltdWwoeCxyZSl8MCkrTWF0aC5pbXVsKFAsdGUpfDAsbz1vK01hdGguaW11bChQLHJlKXwwLG49bitNYXRoLmltdWwoUyxpZSl8MCxpPShpK01hdGguaW11bChTLG9lKXwwKStNYXRoLmltdWwoayxpZSl8MCxvPW8rTWF0aC5pbXVsKGssb2UpfDAsbj1uK01hdGguaW11bChNLGFlKXwwLGk9KGkrTWF0aC5pbXVsKE0sdWUpfDApK01hdGguaW11bChBLGFlKXwwLG89bytNYXRoLmltdWwoQSx1ZSl8MCxuPW4rTWF0aC5pbXVsKGIsaGUpfDAsaT0oaStNYXRoLmltdWwoYixmZSl8MCkrTWF0aC5pbXVsKHcsaGUpfDAsbz1vK01hdGguaW11bCh3LGZlKXwwO3ZhciBOZT0oeWUrKG4rTWF0aC5pbXVsKHksZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoeSxwZSl8MCkrTWF0aC5pbXVsKG0sZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChtLHBlKXwwKSsoaT4+PjEzKXwwKSsoTmU+Pj4yNil8MCxOZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxKKSxpPU1hdGguaW11bChELFgpK01hdGguaW11bChVLEopfDAsbz1NYXRoLmltdWwoVSxYKSxuPW4rTWF0aC5pbXVsKEMsUSl8MCxpPShpK01hdGguaW11bChDLFkpfDApK01hdGguaW11bChMLFEpfDAsbz1vK01hdGguaW11bChMLFkpfDAsbj1uK01hdGguaW11bChULHRlKXwwLGk9KGkrTWF0aC5pbXVsKFQscmUpfDApK01hdGguaW11bChSLHRlKXwwLG89bytNYXRoLmltdWwoUixyZSl8MCxuPW4rTWF0aC5pbXVsKHgsaWUpfDAsaT0oaStNYXRoLmltdWwoeCxvZSl8MCkrTWF0aC5pbXVsKFAsaWUpfDAsbz1vK01hdGguaW11bChQLG9lKXwwLG49bitNYXRoLmltdWwoUyxhZSl8MCxpPShpK01hdGguaW11bChTLHVlKXwwKStNYXRoLmltdWwoayxhZSl8MCxvPW8rTWF0aC5pbXVsKGssdWUpfDAsbj1uK01hdGguaW11bChNLGhlKXwwLGk9KGkrTWF0aC5pbXVsKE0sZmUpfDApK01hdGguaW11bChBLGhlKXwwLG89bytNYXRoLmltdWwoQSxmZSl8MDt2YXIgeGU9KHllKyhuK01hdGguaW11bChiLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGIscGUpfDApK01hdGguaW11bCh3LGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwodyxwZSl8MCkrKGk+Pj4xMyl8MCkrKHhlPj4+MjYpfDAseGUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsUSksaT1NYXRoLmltdWwoRCxZKStNYXRoLmltdWwoVSxRKXwwLG89TWF0aC5pbXVsKFUsWSksbj1uK01hdGguaW11bChDLHRlKXwwLGk9KGkrTWF0aC5pbXVsKEMscmUpfDApK01hdGguaW11bChMLHRlKXwwLG89bytNYXRoLmltdWwoTCxyZSl8MCxuPW4rTWF0aC5pbXVsKFQsaWUpfDAsaT0oaStNYXRoLmltdWwoVCxvZSl8MCkrTWF0aC5pbXVsKFIsaWUpfDAsbz1vK01hdGguaW11bChSLG9lKXwwLG49bitNYXRoLmltdWwoeCxhZSl8MCxpPShpK01hdGguaW11bCh4LHVlKXwwKStNYXRoLmltdWwoUCxhZSl8MCxvPW8rTWF0aC5pbXVsKFAsdWUpfDAsbj1uK01hdGguaW11bChTLGhlKXwwLGk9KGkrTWF0aC5pbXVsKFMsZmUpfDApK01hdGguaW11bChrLGhlKXwwLG89bytNYXRoLmltdWwoayxmZSl8MDt2YXIgUGU9KHllKyhuK01hdGguaW11bChNLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKE0scGUpfDApK01hdGguaW11bChBLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoQSxwZSl8MCkrKGk+Pj4xMyl8MCkrKFBlPj4+MjYpfDAsUGUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsdGUpLGk9TWF0aC5pbXVsKEQscmUpK01hdGguaW11bChVLHRlKXwwLG89TWF0aC5pbXVsKFUscmUpLG49bitNYXRoLmltdWwoQyxpZSl8MCxpPShpK01hdGguaW11bChDLG9lKXwwKStNYXRoLmltdWwoTCxpZSl8MCxvPW8rTWF0aC5pbXVsKEwsb2UpfDAsbj1uK01hdGguaW11bChULGFlKXwwLGk9KGkrTWF0aC5pbXVsKFQsdWUpfDApK01hdGguaW11bChSLGFlKXwwLG89bytNYXRoLmltdWwoUix1ZSl8MCxuPW4rTWF0aC5pbXVsKHgsaGUpfDAsaT0oaStNYXRoLmltdWwoeCxmZSl8MCkrTWF0aC5pbXVsKFAsaGUpfDAsbz1vK01hdGguaW11bChQLGZlKXwwO3ZhciBJZT0oeWUrKG4rTWF0aC5pbXVsKFMsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoUyxwZSl8MCkrTWF0aC5pbXVsKGssZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChrLHBlKXwwKSsoaT4+PjEzKXwwKSsoSWU+Pj4yNil8MCxJZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxpZSksaT1NYXRoLmltdWwoRCxvZSkrTWF0aC5pbXVsKFUsaWUpfDAsbz1NYXRoLmltdWwoVSxvZSksbj1uK01hdGguaW11bChDLGFlKXwwLGk9KGkrTWF0aC5pbXVsKEMsdWUpfDApK01hdGguaW11bChMLGFlKXwwLG89bytNYXRoLmltdWwoTCx1ZSl8MCxuPW4rTWF0aC5pbXVsKFQsaGUpfDAsaT0oaStNYXRoLmltdWwoVCxmZSl8MCkrTWF0aC5pbXVsKFIsaGUpfDAsbz1vK01hdGguaW11bChSLGZlKXwwO3ZhciBUZT0oeWUrKG4rTWF0aC5pbXVsKHgsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoeCxwZSl8MCkrTWF0aC5pbXVsKFAsZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChQLHBlKXwwKSsoaT4+PjEzKXwwKSsoVGU+Pj4yNil8MCxUZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxhZSksaT1NYXRoLmltdWwoRCx1ZSkrTWF0aC5pbXVsKFUsYWUpfDAsbz1NYXRoLmltdWwoVSx1ZSksbj1uK01hdGguaW11bChDLGhlKXwwLGk9KGkrTWF0aC5pbXVsKEMsZmUpfDApK01hdGguaW11bChMLGhlKXwwLG89bytNYXRoLmltdWwoTCxmZSl8MDt2YXIgUmU9KHllKyhuK01hdGguaW11bChULGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKFQscGUpfDApK01hdGguaW11bChSLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoUixwZSl8MCkrKGk+Pj4xMyl8MCkrKFJlPj4+MjYpfDAsUmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsaGUpLGk9TWF0aC5pbXVsKEQsZmUpK01hdGguaW11bChVLGhlKXwwLG89TWF0aC5pbXVsKFUsZmUpO3ZhciBPZT0oeWUrKG4rTWF0aC5pbXVsKEMsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoQyxwZSl8MCkrTWF0aC5pbXVsKEwsZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChMLHBlKXwwKSsoaT4+PjEzKXwwKSsoT2U+Pj4yNil8MCxPZSY9NjcxMDg4NjM7dmFyIENlPSh5ZStNYXRoLmltdWwoRCxkZSl8MCkrKCg4MTkxJihpPU1hdGguaW11bChELHBlKStNYXRoLmltdWwoVSxkZSl8MCkpPDwxMyl8MDtyZXR1cm4geWU9KE1hdGguaW11bChVLHBlKSsoaT4+PjEzKXwwKSsoQ2U+Pj4yNil8MCxDZSY9NjcxMDg4NjMsdVswXT12ZSx1WzFdPW1lLHVbMl09Z2UsdVszXT1iZSx1WzRdPXdlLHVbNV09X2UsdVs2XT1NZSx1WzddPUFlLHVbOF09RWUsdVs5XT1TZSx1WzEwXT1rZSx1WzExXT1OZSx1WzEyXT14ZSx1WzEzXT1QZSx1WzE0XT1JZSx1WzE1XT1UZSx1WzE2XT1SZSx1WzE3XT1PZSx1WzE4XT1DZSwwIT15ZSYmKHVbMTldPXllLHIubGVuZ3RoKyspLHJ9O2Z1bmN0aW9uIGEoZSx0LHIpe3JldHVybihuZXcgdSkubXVscChlLHQscil9ZnVuY3Rpb24gdShlLHQpe3RoaXMueD1lLHRoaXMueT10fU1hdGguaW11bHx8KG89aSksbS5wcm90b3R5cGUubXVsVG89ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmxlbmd0aCtlLmxlbmd0aCxuPSgxMD09PXRoaXMubGVuZ3RoJiYxMD09PWUubGVuZ3RoP286cjw2Mz9pOnI8MTAyND9mdW5jdGlvbihlLHQscil7ci5uZWdhdGl2ZT10Lm5lZ2F0aXZlXmUubmVnYXRpdmUsci5sZW5ndGg9ZS5sZW5ndGgrdC5sZW5ndGg7Zm9yKHZhciBuPTAsaT0wLG89MDtvPHIubGVuZ3RoLTE7bysrKXtmb3IodmFyIHM9aSxpPTAsYT02NzEwODg2MyZuLHU9TWF0aC5taW4obyx0Lmxlbmd0aC0xKSxsPU1hdGgubWF4KDAsby1lLmxlbmd0aCsxKTtsPD11O2wrKyl7dmFyIGg9by1sLGY9KDB8ZS53b3Jkc1toXSkqKDB8dC53b3Jkc1tsXSksYz02NzEwODg2MyZmLGE9NjcxMDg4NjMmKGM9YythfDApO2krPShzPShzPXMrKGYvNjcxMDg4NjR8MCl8MCkrKGM+Pj4yNil8MCk+Pj4yNixzJj02NzEwODg2M31yLndvcmRzW29dPWEsbj1zLHM9aX1yZXR1cm4gMCE9PW4/ci53b3Jkc1tvXT1uOnIubGVuZ3RoLS0sci5zdHJpcCgpfTphKSh0aGlzLGUsdCk7cmV0dXJuIG59LHUucHJvdG90eXBlLm1ha2VSQlQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBBcnJheShlKSxyPW0ucHJvdG90eXBlLl9jb3VudEJpdHMoZSktMSxuPTA7bjxlO24rKyl0W25dPXRoaXMucmV2QmluKG4scixlKTtyZXR1cm4gdH0sdS5wcm90b3R5cGUucmV2QmluPWZ1bmN0aW9uKGUsdCxyKXtpZigwPT09ZXx8ZT09PXItMSlyZXR1cm4gZTtmb3IodmFyIG49MCxpPTA7aTx0O2krKylufD0oMSZlKTw8dC1pLTEsZT4+PTE7cmV0dXJuIG59LHUucHJvdG90eXBlLnBlcm11dGU9ZnVuY3Rpb24oZSx0LHIsbixpLG8pe2Zvcih2YXIgcz0wO3M8bztzKyspbltzXT10W2Vbc11dLGlbc109cltlW3NdXX0sdS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxyLG4saSxvKXt0aGlzLnBlcm11dGUobyxlLHQscixuLGkpO2Zvcih2YXIgcz0xO3M8aTtzPDw9MSlmb3IodmFyIGE9czw8MSx1PU1hdGguY29zKDIqTWF0aC5QSS9hKSxsPU1hdGguc2luKDIqTWF0aC5QSS9hKSxoPTA7aDxpO2grPWEpZm9yKHZhciBmPXUsYz1sLGQ9MDtkPHM7ZCsrKXt2YXIgcD1yW2grZF0sdj1uW2grZF0seT1mKihnPXJbaCtkK3NdKS1jKihtPW5baCtkK3NdKSxtPWYqbStjKmcsZz15O3JbaCtkXT1wK2csbltoK2RdPXYrbSxyW2grZCtzXT1wLWcsbltoK2Qrc109di1tLGQhPT1hJiYoeT11KmYtbCpjLGM9dSpjK2wqZixmPXkpfX0sdS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2I9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9MSYoaT0xfE1hdGgubWF4KHQsZSkpLG49MCxpPWkvMnwwO2k7aT4+Pj0xKW4rKztyZXR1cm4gMTw8bisxK3J9LHUucHJvdG90eXBlLmNvbmp1Z2F0ZT1mdW5jdGlvbihlLHQscil7aWYoIShyPD0xKSlmb3IodmFyIG49MDtuPHIvMjtuKyspe3ZhciBpPWVbbl07ZVtuXT1lW3Itbi0xXSxlW3Itbi0xXT1pLGk9dFtuXSx0W25dPS10W3Itbi0xXSx0W3Itbi0xXT0taX19LHUucHJvdG90eXBlLm5vcm1hbGl6ZTEzYj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wLG49MDtuPHQvMjtuKyspe3ZhciBpPTgxOTIqTWF0aC5yb3VuZChlWzIqbisxXS90KStNYXRoLnJvdW5kKGVbMipuXS90KStyO2Vbbl09NjcxMDg4NjMmaSxyPWk8NjcxMDg4NjQ/MDppLzY3MTA4ODY0fDB9cmV0dXJuIGV9LHUucHJvdG90eXBlLmNvbnZlcnQxM2I9ZnVuY3Rpb24oZSx0LHIsbil7Zm9yKHZhciBpPTAsbz0wO288dDtvKyspaSs9MHxlW29dLHJbMipvXT04MTkxJmksaT4+Pj0xMyxyWzIqbysxXT04MTkxJmksaT4+Pj0xMztmb3Iobz0yKnQ7bzxuOysrbylyW29dPTA7eSgwPT09aSkseSgwPT0oLTgxOTImaSkpfSx1LnByb3RvdHlwZS5zdHViPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT0wO3JldHVybiB0fSx1LnByb3RvdHlwZS5tdWxwPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0yKnRoaXMuZ3Vlc3NMZW4xM2IoZS5sZW5ndGgsdC5sZW5ndGgpLGk9dGhpcy5tYWtlUkJUKG4pLG89dGhpcy5zdHViKG4pLHM9bmV3IEFycmF5KG4pLGE9bmV3IEFycmF5KG4pLHU9bmV3IEFycmF5KG4pLGw9bmV3IEFycmF5KG4pLGg9bmV3IEFycmF5KG4pLGY9bmV3IEFycmF5KG4pLGM9ci53b3JkcztjLmxlbmd0aD1uLHRoaXMuY29udmVydDEzYihlLndvcmRzLGUubGVuZ3RoLHMsbiksdGhpcy5jb252ZXJ0MTNiKHQud29yZHMsdC5sZW5ndGgsbCxuKSx0aGlzLnRyYW5zZm9ybShzLG8sYSx1LG4saSksdGhpcy50cmFuc2Zvcm0obCxvLGgsZixuLGkpO2Zvcih2YXIgZD0wO2Q8bjtkKyspe3ZhciBwPWFbZF0qaFtkXS11W2RdKmZbZF07dVtkXT1hW2RdKmZbZF0rdVtkXSpoW2RdLGFbZF09cH1yZXR1cm4gdGhpcy5jb25qdWdhdGUoYSx1LG4pLHRoaXMudHJhbnNmb3JtKGEsdSxjLG8sbixpKSx0aGlzLmNvbmp1Z2F0ZShjLG8sbiksdGhpcy5ub3JtYWxpemUxM2IoYyxuKSxyLm5lZ2F0aXZlPWUubmVnYXRpdmVedC5uZWdhdGl2ZSxyLmxlbmd0aD1lLmxlbmd0aCt0Lmxlbmd0aCxyLnN0cmlwKCl9LG0ucHJvdG90eXBlLm11bD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbShudWxsKTtyZXR1cm4gdC53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgrZS5sZW5ndGgpLHRoaXMubXVsVG8oZSx0KX0sbS5wcm90b3R5cGUubXVsZj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbShudWxsKTtyZXR1cm4gdC53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgrZS5sZW5ndGgpLGEodGhpcyxlLHQpfSxtLnByb3RvdHlwZS5pbXVsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkubXVsVG8oZSx0aGlzKX0sbS5wcm90b3R5cGUuaW11bG49ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSkseShlPDY3MTA4ODY0KTtmb3IodmFyIHQ9MCxyPTA7cjx0aGlzLmxlbmd0aDtyKyspe3ZhciBuPSgwfHRoaXMud29yZHNbcl0pKmUsaT0oNjcxMDg4NjMmbikrKDY3MTA4ODYzJnQpO3Q+Pj0yNix0Kz1uLzY3MTA4ODY0fDAsdCs9aT4+PjI2LHRoaXMud29yZHNbcl09NjcxMDg4NjMmaX1yZXR1cm4gMCE9PXQmJih0aGlzLndvcmRzW3JdPXQsdGhpcy5sZW5ndGgrKyksdGhpc30sbS5wcm90b3R5cGUubXVsbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKGUpfSxtLnByb3RvdHlwZS5zcXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWwodGhpcyl9LG0ucHJvdG90eXBlLmlzcXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSl9LG0ucHJvdG90eXBlLnBvdz1mdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bmV3IEFycmF5KGUuYml0TGVuZ3RoKCkpLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49ci8yNnwwLGk9ciUyNjt0W3JdPShlLndvcmRzW25dJjE8PGkpPj4+aX1yZXR1cm4gdH0oZSk7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuZXcgbSgxKTtmb3IodmFyIHI9dGhpcyxuPTA7bjx0Lmxlbmd0aCYmMD09PXRbbl07bisrLHI9ci5zcXIoKSk7aWYoKytuPHQubGVuZ3RoKWZvcih2YXIgaT1yLnNxcigpO248dC5sZW5ndGg7bisrLGk9aS5zcXIoKSkwIT09dFtuXSYmKHI9ci5tdWwoaSkpO3JldHVybiByfSxtLnByb3RvdHlwZS5pdXNobG49ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSYmMDw9ZSk7dmFyIHQ9ZSUyNixyPShlLXQpLzI2LG49NjcxMDg4NjM+Pj4yNi10PDwyNi10O2lmKDAhPXQpe2Zvcih2YXIgaT0wLG89MDtvPHRoaXMubGVuZ3RoO28rKyl7dmFyIHM9dGhpcy53b3Jkc1tvXSZuLGE9KDB8dGhpcy53b3Jkc1tvXSktczw8dDt0aGlzLndvcmRzW29dPWF8aSxpPXM+Pj4yNi10fWkmJih0aGlzLndvcmRzW29dPWksdGhpcy5sZW5ndGgrKyl9aWYoMCE9cil7Zm9yKG89dGhpcy5sZW5ndGgtMTswPD1vO28tLSl0aGlzLndvcmRzW28rcl09dGhpcy53b3Jkc1tvXTtmb3Iobz0wO288cjtvKyspdGhpcy53b3Jkc1tvXT0wO3RoaXMubGVuZ3RoKz1yfXJldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlzaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB5KDA9PT10aGlzLm5lZ2F0aXZlKSx0aGlzLml1c2hsbihlKX0sbS5wcm90b3R5cGUuaXVzaHJuPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbjt5KFwibnVtYmVyXCI9PXR5cGVvZiBlJiYwPD1lKSxuPXQ/KHQtdCUyNikvMjY6MDt2YXIgaT1lJTI2LG89TWF0aC5taW4oKGUtaSkvMjYsdGhpcy5sZW5ndGgpLHM9NjcxMDg4NjNeNjcxMDg4NjM+Pj5pPDxpLGE9cjtpZihuLT1vLG49TWF0aC5tYXgoMCxuKSxhKXtmb3IodmFyIHU9MDt1PG87dSsrKWEud29yZHNbdV09dGhpcy53b3Jkc1t1XTthLmxlbmd0aD1vfWlmKDAhPT1vKWlmKHRoaXMubGVuZ3RoPm8pZm9yKHRoaXMubGVuZ3RoLT1vLHU9MDt1PHRoaXMubGVuZ3RoO3UrKyl0aGlzLndvcmRzW3VdPXRoaXMud29yZHNbdStvXTtlbHNlIHRoaXMud29yZHNbMF09MCx0aGlzLmxlbmd0aD0xO2Zvcih2YXIgbD0wLHU9dGhpcy5sZW5ndGgtMTswPD11JiYoMCE9PWx8fG48PXUpO3UtLSl7dmFyIGg9MHx0aGlzLndvcmRzW3VdO3RoaXMud29yZHNbdV09bDw8MjYtaXxoPj4+aSxsPWgmc31yZXR1cm4gYSYmMCE9PWwmJihhLndvcmRzW2EubGVuZ3RoKytdPWwpLDA9PT10aGlzLmxlbmd0aCYmKHRoaXMud29yZHNbMF09MCx0aGlzLmxlbmd0aD0xKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlzaHJuPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4geSgwPT09dGhpcy5uZWdhdGl2ZSksdGhpcy5pdXNocm4oZSx0LHIpfSxtLnByb3RvdHlwZS5zaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXNobG4oZSl9LG0ucHJvdG90eXBlLnVzaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGUpfSxtLnByb3RvdHlwZS5zaHJuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXNocm4oZSl9LG0ucHJvdG90eXBlLnVzaHJuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGUpfSxtLnByb3RvdHlwZS50ZXN0bj1mdW5jdGlvbihlKXt5KFwibnVtYmVyXCI9PXR5cGVvZiBlJiYwPD1lKTt2YXIgdD1lJTI2LHI9KGUtdCkvMjYsbj0xPDx0O3JldHVybiEodGhpcy5sZW5ndGg8PXIpJiYhISh0aGlzLndvcmRzW3JdJm4pfSxtLnByb3RvdHlwZS5pbWFza249ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSYmMDw9ZSk7dmFyIHQscj1lJTI2LG49KGUtcikvMjY7cmV0dXJuIHkoMD09PXRoaXMubmVnYXRpdmUsXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIiksdGhpcy5sZW5ndGg8PW4/dGhpczooMCE9ciYmbisrLHRoaXMubGVuZ3RoPU1hdGgubWluKG4sdGhpcy5sZW5ndGgpLDAhPXImJih0PTY3MTA4ODYzXjY3MTA4ODYzPj4+cjw8cix0aGlzLndvcmRzW3RoaXMubGVuZ3RoLTFdJj10KSx0aGlzLnN0cmlwKCkpfSxtLnByb3RvdHlwZS5tYXNrbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihlKX0sbS5wcm90b3R5cGUuaWFkZG49ZnVuY3Rpb24oZSl7cmV0dXJuIHkoXCJudW1iZXJcIj09dHlwZW9mIGUpLHkoZTw2NzEwODg2NCksZTwwP3RoaXMuaXN1Ym4oLWUpOjAhPT10aGlzLm5lZ2F0aXZlPygxPT09dGhpcy5sZW5ndGgmJigwfHRoaXMud29yZHNbMF0pPGU/KHRoaXMud29yZHNbMF09ZS0oMHx0aGlzLndvcmRzWzBdKSx0aGlzLm5lZ2F0aXZlPTApOih0aGlzLm5lZ2F0aXZlPTAsdGhpcy5pc3VibihlKSx0aGlzLm5lZ2F0aXZlPTEpLHRoaXMpOnRoaXMuX2lhZGRuKGUpfSxtLnByb3RvdHlwZS5faWFkZG49ZnVuY3Rpb24oZSl7dGhpcy53b3Jkc1swXSs9ZTtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoJiY2NzEwODg2NDw9dGhpcy53b3Jkc1t0XTt0KyspdGhpcy53b3Jkc1t0XS09NjcxMDg4NjQsdD09PXRoaXMubGVuZ3RoLTE/dGhpcy53b3Jkc1t0KzFdPTE6dGhpcy53b3Jkc1t0KzFdKys7cmV0dXJuIHRoaXMubGVuZ3RoPU1hdGgubWF4KHRoaXMubGVuZ3RoLHQrMSksdGhpc30sbS5wcm90b3R5cGUuaXN1Ym49ZnVuY3Rpb24oZSl7aWYoeShcIm51bWJlclwiPT10eXBlb2YgZSkseShlPDY3MTA4ODY0KSxlPDApcmV0dXJuIHRoaXMuaWFkZG4oLWUpO2lmKDAhPT10aGlzLm5lZ2F0aXZlKXJldHVybiB0aGlzLm5lZ2F0aXZlPTAsdGhpcy5pYWRkbihlKSx0aGlzLm5lZ2F0aXZlPTEsdGhpcztpZih0aGlzLndvcmRzWzBdLT1lLDE9PT10aGlzLmxlbmd0aCYmdGhpcy53b3Jkc1swXTwwKXRoaXMud29yZHNbMF09LXRoaXMud29yZHNbMF0sdGhpcy5uZWdhdGl2ZT0xO2Vsc2UgZm9yKHZhciB0PTA7dDx0aGlzLmxlbmd0aCYmdGhpcy53b3Jkc1t0XTwwO3QrKyl0aGlzLndvcmRzW3RdKz02NzEwODg2NCwtLXRoaXMud29yZHNbdCsxXTtyZXR1cm4gdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5hZGRuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaWFkZG4oZSl9LG0ucHJvdG90eXBlLnN1Ym49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihlKX0sbS5wcm90b3R5cGUuaWFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5lZ2F0aXZlPTAsdGhpc30sbS5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCl9LG0ucHJvdG90eXBlLl9pc2hsbnN1Ym11bD1mdW5jdGlvbihlLHQscil7dmFyIG4saT1lLmxlbmd0aCtyO3RoaXMuX2V4cGFuZChpKTtmb3IodmFyIG89MCxzPTA7czxlLmxlbmd0aDtzKyspe249KDB8dGhpcy53b3Jkc1tzK3JdKStvO3ZhciBhPSgwfGUud29yZHNbc10pKnQsbz0oKG4tPTY3MTA4ODYzJmEpPj4yNiktKGEvNjcxMDg4NjR8MCk7dGhpcy53b3Jkc1tzK3JdPTY3MTA4ODYzJm59Zm9yKDtzPHRoaXMubGVuZ3RoLXI7cysrKW89KG49KDB8dGhpcy53b3Jkc1tzK3JdKStvKT4+MjYsdGhpcy53b3Jkc1tzK3JdPTY3MTA4ODYzJm47aWYoMD09PW8pcmV0dXJuIHRoaXMuc3RyaXAoKTtmb3IoeSgtMT09PW8pLHM9bz0wO3M8dGhpcy5sZW5ndGg7cysrKW89KG49LSgwfHRoaXMud29yZHNbc10pK28pPj4yNix0aGlzLndvcmRzW3NdPTY3MTA4ODYzJm47cmV0dXJuIHRoaXMubmVnYXRpdmU9MSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLl93b3JkRGl2PWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5sZW5ndGgtZS5sZW5ndGgsbj10aGlzLmNsb25lKCksaT1lLG89MHxpLndvcmRzW2kubGVuZ3RoLTFdOzAhPShyPTI2LXRoaXMuX2NvdW50Qml0cyhvKSkmJihpPWkudXNobG4ociksbi5pdXNobG4ociksbz0wfGkud29yZHNbaS5sZW5ndGgtMV0pO3ZhciBzLGE9bi5sZW5ndGgtaS5sZW5ndGg7aWYoXCJtb2RcIiE9PXQpeyhzPW5ldyBtKG51bGwpKS5sZW5ndGg9MSthLHMud29yZHM9bmV3IEFycmF5KHMubGVuZ3RoKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKylzLndvcmRzW3VdPTB9dmFyIGw9bi5jbG9uZSgpLl9pc2hsbnN1Ym11bChpLDEsYSk7MD09PWwubmVnYXRpdmUmJihuPWwscyYmKHMud29yZHNbYV09MSkpO2Zvcih2YXIgaD1hLTE7MDw9aDtoLS0pe3ZhciBmPTY3MTA4ODY0KigwfG4ud29yZHNbaS5sZW5ndGgraF0pKygwfG4ud29yZHNbaS5sZW5ndGgraC0xXSksZj1NYXRoLm1pbihmL298MCw2NzEwODg2Myk7Zm9yKG4uX2lzaGxuc3VibXVsKGksZixoKTswIT09bi5uZWdhdGl2ZTspZi0tLG4ubmVnYXRpdmU9MCxuLl9pc2hsbnN1Ym11bChpLDEsaCksbi5pc1plcm8oKXx8KG4ubmVnYXRpdmVePTEpO3MmJihzLndvcmRzW2hdPWYpfXJldHVybiBzJiZzLnN0cmlwKCksbi5zdHJpcCgpLFwiZGl2XCIhPT10JiYwIT1yJiZuLml1c2hybihyKSx7ZGl2OnN8fG51bGwsbW9kOm59fSxtLnByb3RvdHlwZS5kaXZtb2Q9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB5KCFlLmlzWmVybygpKSx0aGlzLmlzWmVybygpP3tkaXY6bmV3IG0oMCksbW9kOm5ldyBtKDApfTowIT09dGhpcy5uZWdhdGl2ZSYmMD09PWUubmVnYXRpdmU/KG89dGhpcy5uZWcoKS5kaXZtb2QoZSx0KSxcIm1vZFwiIT09dCYmKG49by5kaXYubmVnKCkpLFwiZGl2XCIhPT10JiYoaT1vLm1vZC5uZWcoKSxyJiYwIT09aS5uZWdhdGl2ZSYmaS5pYWRkKGUpKSx7ZGl2Om4sbW9kOml9KTowPT09dGhpcy5uZWdhdGl2ZSYmMCE9PWUubmVnYXRpdmU/KG89dGhpcy5kaXZtb2QoZS5uZWcoKSx0KSxcIm1vZFwiIT09dCYmKG49by5kaXYubmVnKCkpLHtkaXY6bixtb2Q6by5tb2R9KTowIT0odGhpcy5uZWdhdGl2ZSZlLm5lZ2F0aXZlKT8obz10aGlzLm5lZygpLmRpdm1vZChlLm5lZygpLHQpLFwiZGl2XCIhPT10JiYoaT1vLm1vZC5uZWcoKSxyJiYwIT09aS5uZWdhdGl2ZSYmaS5pc3ViKGUpKSx7ZGl2Om8uZGl2LG1vZDppfSk6ZS5sZW5ndGg+dGhpcy5sZW5ndGh8fHRoaXMuY21wKGUpPDA/e2RpdjpuZXcgbSgwKSxtb2Q6dGhpc306MT09PWUubGVuZ3RoP1wiZGl2XCI9PT10P3tkaXY6dGhpcy5kaXZuKGUud29yZHNbMF0pLG1vZDpudWxsfTpcIm1vZFwiPT09dD97ZGl2Om51bGwsbW9kOm5ldyBtKHRoaXMubW9kbihlLndvcmRzWzBdKSl9OntkaXY6dGhpcy5kaXZuKGUud29yZHNbMF0pLG1vZDpuZXcgbSh0aGlzLm1vZG4oZS53b3Jkc1swXSkpfTp0aGlzLl93b3JkRGl2KGUsdCk7dmFyIG4saSxvfSxtLnByb3RvdHlwZS5kaXY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGl2bW9kKGUsXCJkaXZcIiwhMSkuZGl2fSxtLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGl2bW9kKGUsXCJtb2RcIiwhMSkubW9kfSxtLnByb3RvdHlwZS51bW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRpdm1vZChlLFwibW9kXCIsITApLm1vZH0sbS5wcm90b3R5cGUuZGl2Um91bmQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5kaXZtb2QoZSk7aWYodC5tb2QuaXNaZXJvKCkpcmV0dXJuIHQuZGl2O3ZhciByPTAhPT10LmRpdi5uZWdhdGl2ZT90Lm1vZC5pc3ViKGUpOnQubW9kLG49ZS51c2hybigxKSxpPWUuYW5kbG4oMSksbz1yLmNtcChuKTtyZXR1cm4gbzwwfHwxPT09aSYmMD09PW8/dC5kaXY6MCE9PXQuZGl2Lm5lZ2F0aXZlP3QuZGl2LmlzdWJuKDEpOnQuZGl2LmlhZGRuKDEpfSxtLnByb3RvdHlwZS5tb2RuPWZ1bmN0aW9uKGUpe3koZTw9NjcxMDg4NjMpO2Zvcih2YXIgdD0oMTw8MjYpJWUscj0wLG49dGhpcy5sZW5ndGgtMTswPD1uO24tLSlyPSh0KnIrKDB8dGhpcy53b3Jkc1tuXSkpJWU7cmV0dXJuIHJ9LG0ucHJvdG90eXBlLmlkaXZuPWZ1bmN0aW9uKGUpe3koZTw9NjcxMDg4NjMpO2Zvcih2YXIgdD0wLHI9dGhpcy5sZW5ndGgtMTswPD1yO3ItLSl7dmFyIG49KDB8dGhpcy53b3Jkc1tyXSkrNjcxMDg4NjQqdDt0aGlzLndvcmRzW3JdPW4vZXwwLHQ9biVlfXJldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmRpdm49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihlKX0sbS5wcm90b3R5cGUuZWdjZD1mdW5jdGlvbihlKXt5KDA9PT1lLm5lZ2F0aXZlKSx5KCFlLmlzWmVybygpKTtmb3IodmFyIHQ9dGhpcyxyPWUuY2xvbmUoKSx0PTAhPT10Lm5lZ2F0aXZlP3QudW1vZChlKTp0LmNsb25lKCksbj1uZXcgbSgxKSxpPW5ldyBtKDApLG89bmV3IG0oMCkscz1uZXcgbSgxKSxhPTA7dC5pc0V2ZW4oKSYmci5pc0V2ZW4oKTspdC5pdXNocm4oMSksci5pdXNocm4oMSksKythO2Zvcih2YXIgdT1yLmNsb25lKCksbD10LmNsb25lKCk7IXQuaXNaZXJvKCk7KXtmb3IodmFyIGg9MCxmPTE7MD09KHQud29yZHNbMF0mZikmJmg8MjY7KytoLGY8PD0xKTtpZigwPGgpZm9yKHQuaXVzaHJuKGgpOzA8aC0tOykobi5pc09kZCgpfHxpLmlzT2RkKCkpJiYobi5pYWRkKHUpLGkuaXN1YihsKSksbi5pdXNocm4oMSksaS5pdXNocm4oMSk7Zm9yKHZhciBjPTAsZD0xOzA9PShyLndvcmRzWzBdJmQpJiZjPDI2OysrYyxkPDw9MSk7aWYoMDxjKWZvcihyLml1c2hybihjKTswPGMtLTspKG8uaXNPZGQoKXx8cy5pc09kZCgpKSYmKG8uaWFkZCh1KSxzLmlzdWIobCkpLG8uaXVzaHJuKDEpLHMuaXVzaHJuKDEpOzA8PXQuY21wKHIpPyh0LmlzdWIociksbi5pc3ViKG8pLGkuaXN1YihzKSk6KHIuaXN1Yih0KSxvLmlzdWIobikscy5pc3ViKGkpKX1yZXR1cm57YTpvLGI6cyxnY2Q6ci5pdXNobG4oYSl9fSxtLnByb3RvdHlwZS5faW52bXA9ZnVuY3Rpb24oZSl7eSgwPT09ZS5uZWdhdGl2ZSkseSghZS5pc1plcm8oKSk7Zm9yKHZhciB0LHI9dGhpcyxuPWUuY2xvbmUoKSxyPTAhPT1yLm5lZ2F0aXZlP3IudW1vZChlKTpyLmNsb25lKCksaT1uZXcgbSgxKSxvPW5ldyBtKDApLHM9bi5jbG9uZSgpOzA8ci5jbXBuKDEpJiYwPG4uY21wbigxKTspe2Zvcih2YXIgYT0wLHU9MTswPT0oci53b3Jkc1swXSZ1KSYmYTwyNjsrK2EsdTw8PTEpO2lmKDA8YSlmb3Ioci5pdXNocm4oYSk7MDxhLS07KWkuaXNPZGQoKSYmaS5pYWRkKHMpLGkuaXVzaHJuKDEpO2Zvcih2YXIgbD0wLGg9MTswPT0obi53b3Jkc1swXSZoKSYmbDwyNjsrK2wsaDw8PTEpO2lmKDA8bClmb3Iobi5pdXNocm4obCk7MDxsLS07KW8uaXNPZGQoKSYmby5pYWRkKHMpLG8uaXVzaHJuKDEpOzA8PXIuY21wKG4pPyhyLmlzdWIobiksaS5pc3ViKG8pKToobi5pc3ViKHIpLG8uaXN1YihpKSl9cmV0dXJuKHQ9MD09PXIuY21wbigxKT9pOm8pLmNtcG4oMCk8MCYmdC5pYWRkKGUpLHR9LG0ucHJvdG90eXBlLmdjZD1mdW5jdGlvbihlKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBlLmFicygpO2lmKGUuaXNaZXJvKCkpcmV0dXJuIHRoaXMuYWJzKCk7dmFyIHQ9dGhpcy5jbG9uZSgpLHI9ZS5jbG9uZSgpO3QubmVnYXRpdmU9MDtmb3IodmFyIG49ci5uZWdhdGl2ZT0wO3QuaXNFdmVuKCkmJnIuaXNFdmVuKCk7bisrKXQuaXVzaHJuKDEpLHIuaXVzaHJuKDEpO2Zvcig7Oyl7Zm9yKDt0LmlzRXZlbigpOyl0Lml1c2hybigxKTtmb3IoO3IuaXNFdmVuKCk7KXIuaXVzaHJuKDEpO3ZhciBpPXQuY21wKHIpO2lmKGk8MCl2YXIgbz10LHQ9cixyPW87ZWxzZSBpZigwPT09aXx8MD09PXIuY21wbigxKSlicmVhazt0LmlzdWIocil9cmV0dXJuIHIuaXVzaGxuKG4pfSxtLnByb3RvdHlwZS5pbnZtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVnY2QoZSkuYS51bW9kKGUpfSxtLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4gMD09KDEmdGhpcy53b3Jkc1swXSl9LG0ucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PSgxJnRoaXMud29yZHNbMF0pfSxtLnByb3RvdHlwZS5hbmRsbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53b3Jkc1swXSZlfSxtLnByb3RvdHlwZS5iaW5jbj1mdW5jdGlvbihlKXt5KFwibnVtYmVyXCI9PXR5cGVvZiBlKTt2YXIgdD1lJTI2LHI9KGUtdCkvMjYsbj0xPDx0O2lmKHRoaXMubGVuZ3RoPD1yKXJldHVybiB0aGlzLl9leHBhbmQoMStyKSx0aGlzLndvcmRzW3JdfD1uLHRoaXM7Zm9yKHZhciBpPW4sbz1yOzAhPT1pJiZvPHRoaXMubGVuZ3RoO28rKyl7dmFyIHM9MHx0aGlzLndvcmRzW29dLGk9KHMrPWkpPj4+MjY7cyY9NjcxMDg4NjMsdGhpcy53b3Jkc1tvXT1zfXJldHVybiAwIT09aSYmKHRoaXMud29yZHNbb109aSx0aGlzLmxlbmd0aCsrKSx0aGlzfSxtLnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGVuZ3RoJiYwPT09dGhpcy53b3Jkc1swXX0sbS5wcm90b3R5cGUuY21wbj1mdW5jdGlvbihlKXt2YXIgdCxyLG49ZTwwO3JldHVybiAwPT09dGhpcy5uZWdhdGl2ZXx8bj8wPT09dGhpcy5uZWdhdGl2ZSYmbj8xOih0aGlzLnN0cmlwKCkscj0xPHRoaXMubGVuZ3RoPzE6KG4mJihlPS1lKSx5KGU8PTY3MTA4ODYzLFwiTnVtYmVyIGlzIHRvbyBiaWdcIiksKHQ9MHx0aGlzLndvcmRzWzBdKT09PWU/MDp0PGU/LTE6MSksMCE9PXRoaXMubmVnYXRpdmU/MHwtcjpyKTotMX0sbS5wcm90b3R5cGUuY21wPWZ1bmN0aW9uKGUpe2lmKDAhPT10aGlzLm5lZ2F0aXZlJiYwPT09ZS5uZWdhdGl2ZSlyZXR1cm4tMTtpZigwPT09dGhpcy5uZWdhdGl2ZSYmMCE9PWUubmVnYXRpdmUpcmV0dXJuIDE7dmFyIHQ9dGhpcy51Y21wKGUpO3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZT8wfC10OnR9LG0ucHJvdG90eXBlLnVjbXA9ZnVuY3Rpb24oZSl7aWYodGhpcy5sZW5ndGg+ZS5sZW5ndGgpcmV0dXJuIDE7aWYodGhpcy5sZW5ndGg8ZS5sZW5ndGgpcmV0dXJuLTE7Zm9yKHZhciB0PTAscj10aGlzLmxlbmd0aC0xOzA8PXI7ci0tKXt2YXIgbj0wfHRoaXMud29yZHNbcl0saT0wfGUud29yZHNbcl07aWYobiE9aSl7bjxpP3Q9LTE6aTxuJiYodD0xKTticmVha319cmV0dXJuIHR9LG0ucHJvdG90eXBlLmd0bj1mdW5jdGlvbihlKXtyZXR1cm4gMT09PXRoaXMuY21wbihlKX0sbS5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT10aGlzLmNtcChlKX0sbS5wcm90b3R5cGUuZ3Rlbj1mdW5jdGlvbihlKXtyZXR1cm4gMDw9dGhpcy5jbXBuKGUpfSxtLnByb3RvdHlwZS5ndGU9ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PXRoaXMuY21wKGUpfSxtLnByb3RvdHlwZS5sdG49ZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT10aGlzLmNtcG4oZSl9LG0ucHJvdG90eXBlLmx0PWZ1bmN0aW9uKGUpe3JldHVybi0xPT09dGhpcy5jbXAoZSl9LG0ucHJvdG90eXBlLmx0ZW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY21wbihlKTw9MH0sbS5wcm90b3R5cGUubHRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNtcChlKTw9MH0sbS5wcm90b3R5cGUuZXFuPWZ1bmN0aW9uKGUpe3JldHVybiAwPT09dGhpcy5jbXBuKGUpfSxtLnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtyZXR1cm4gMD09PXRoaXMuY21wKGUpfSxtLnJlZD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IF8oZSl9LG0ucHJvdG90eXBlLnRvUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB5KCF0aGlzLnJlZCxcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIikseSgwPT09dGhpcy5uZWdhdGl2ZSxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLGUuY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChlKX0sbS5wcm90b3R5cGUuZnJvbVJlZD1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwiZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSx0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKX0sbS5wcm90b3R5cGUuX2ZvcmNlUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlZD1lLHRoaXN9LG0ucHJvdG90eXBlLmZvcmNlUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB5KCF0aGlzLnJlZCxcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksdGhpcy5fZm9yY2VSZWQoZSl9LG0ucHJvdG90eXBlLnJlZEFkZD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuYWRkKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZElBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHkodGhpcy5yZWQsXCJyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5pYWRkKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFN1Yj1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuc3ViKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZElTdWI9ZnVuY3Rpb24oZSl7cmV0dXJuIHkodGhpcy5yZWQsXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5pc3ViKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFNobD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuc2hsKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZE11bD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxlKSx0aGlzLnJlZC5tdWwodGhpcyxlKX0sbS5wcm90b3R5cGUucmVkSU11bD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxlKSx0aGlzLnJlZC5pbXVsKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFNxcj1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwicmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSx0aGlzLnJlZC5zcXIodGhpcyl9LG0ucHJvdG90eXBlLnJlZElTcXI9ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLmlzcXIodGhpcyl9LG0ucHJvdG90eXBlLnJlZFNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLnNxcnQodGhpcyl9LG0ucHJvdG90eXBlLnJlZEludm09ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLmludm0odGhpcyl9LG0ucHJvdG90eXBlLnJlZE5lZz1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSx0aGlzLnJlZC5uZWcodGhpcyl9LG0ucHJvdG90eXBlLnJlZFBvdz1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCYmIWUucmVkLFwicmVkUG93KG5vcm1hbE51bSlcIiksdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksdGhpcy5yZWQucG93KHRoaXMsZSl9O3ZhciBsPXtrMjU2Om51bGwscDIyNDpudWxsLHAxOTI6bnVsbCxwMjU1MTk6bnVsbH07ZnVuY3Rpb24gaChlLHQpe3RoaXMubmFtZT1lLHRoaXMucD1uZXcgbSh0LDE2KSx0aGlzLm49dGhpcy5wLmJpdExlbmd0aCgpLHRoaXMuaz1uZXcgbSgxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCksdGhpcy50bXA9dGhpcy5fdG1wKCl9ZnVuY3Rpb24gdigpe2guY2FsbCh0aGlzLFwiazI1NlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIil9ZnVuY3Rpb24gZygpe2guY2FsbCh0aGlzLFwicDIyNFwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIil9ZnVuY3Rpb24gYigpe2guY2FsbCh0aGlzLFwicDE5MlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmZcIil9ZnVuY3Rpb24gdygpe2guY2FsbCh0aGlzLFwiMjU1MTlcIixcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIil9ZnVuY3Rpb24gXyhlKXt2YXIgdDtcInN0cmluZ1wiPT10eXBlb2YgZT8odD1tLl9wcmltZShlKSx0aGlzLm09dC5wLHRoaXMucHJpbWU9dCk6KHkoZS5ndG4oMSksXCJtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5tPWUsdGhpcy5wcmltZT1udWxsKX1mdW5jdGlvbiBNKGUpe18uY2FsbCh0aGlzLGUpLHRoaXMuc2hpZnQ9dGhpcy5tLmJpdExlbmd0aCgpLHRoaXMuc2hpZnQlMjYhPTAmJih0aGlzLnNoaWZ0Kz0yNi10aGlzLnNoaWZ0JTI2KSx0aGlzLnI9bmV3IG0oMSkuaXVzaGxuKHRoaXMuc2hpZnQpLHRoaXMucjI9dGhpcy5pbW9kKHRoaXMuci5zcXIoKSksdGhpcy5yaW52PXRoaXMuci5faW52bXAodGhpcy5tKSx0aGlzLm1pbnY9dGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pLHRoaXMubWludj10aGlzLm1pbnYudW1vZCh0aGlzLnIpLHRoaXMubWludj10aGlzLnIuc3ViKHRoaXMubWludil9aC5wcm90b3R5cGUuX3RtcD1mdW5jdGlvbigpe3ZhciBlPW5ldyBtKG51bGwpO3JldHVybiBlLndvcmRzPW5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uLzEzKSksZX0saC5wcm90b3R5cGUuaXJlZHVjZT1mdW5jdGlvbihlKXtmb3IodmFyIHQscj1lO3RoaXMuc3BsaXQocix0aGlzLnRtcCksKHQ9KHI9KHI9dGhpcy5pbXVsSyhyKSkuaWFkZCh0aGlzLnRtcCkpLmJpdExlbmd0aCgpKT50aGlzLm47KTt2YXIgbj10PHRoaXMubj8tMTpyLnVjbXAodGhpcy5wKTtyZXR1cm4gMD09PW4/KHIud29yZHNbMF09MCxyLmxlbmd0aD0xKTowPG4/ci5pc3ViKHRoaXMucCk6dm9pZCAwIT09ci5zdHJpcD9yLnN0cmlwKCk6ci5fc3RyaXAoKSxyfSxoLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe2UuaXVzaHJuKHRoaXMubiwwLHQpfSxoLnByb3RvdHlwZS5pbXVsSz1mdW5jdGlvbihlKXtyZXR1cm4gZS5pbXVsKHRoaXMuayl9LHIodixoKSx2LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1NYXRoLm1pbihlLmxlbmd0aCw5KSxuPTA7bjxyO24rKyl0LndvcmRzW25dPWUud29yZHNbbl07aWYodC5sZW5ndGg9cixlLmxlbmd0aDw9OSlyZXR1cm4gZS53b3Jkc1swXT0wLHZvaWQoZS5sZW5ndGg9MSk7dmFyIGk9ZS53b3Jkc1s5XTtmb3IodC53b3Jkc1t0Lmxlbmd0aCsrXT00MTk0MzAzJmksbj0xMDtuPGUubGVuZ3RoO24rKyl7dmFyIG89MHxlLndvcmRzW25dO2Uud29yZHNbbi0xMF09KDQxOTQzMDMmbyk8PDR8aT4+PjIyLGk9b31pPj4+PTIyLDA9PT0oZS53b3Jkc1tuLTEwXT1pKSYmMTA8ZS5sZW5ndGg/ZS5sZW5ndGgtPTEwOmUubGVuZ3RoLT05fSx2LnByb3RvdHlwZS5pbXVsSz1mdW5jdGlvbihlKXtlLndvcmRzW2UubGVuZ3RoXT0wLGUud29yZHNbZS5sZW5ndGgrMV09MCxlLmxlbmd0aCs9Mjtmb3IodmFyIHQ9MCxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPTB8ZS53b3Jkc1tyXTt0Kz05NzcqbixlLndvcmRzW3JdPTY3MTA4ODYzJnQsdD02NCpuKyh0LzY3MTA4ODY0fDApfXJldHVybiAwPT09ZS53b3Jkc1tlLmxlbmd0aC0xXSYmKGUubGVuZ3RoLS0sMD09PWUud29yZHNbZS5sZW5ndGgtMV0mJmUubGVuZ3RoLS0pLGV9LHIoZyxoKSxyKGIsaCkscih3LGgpLHcucHJvdG90eXBlLmltdWxLPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49MTkqKDB8ZS53b3Jkc1tyXSkrdCxpPTY3MTA4ODYzJm47bj4+Pj0yNixlLndvcmRzW3JdPWksdD1ufXJldHVybiAwIT09dCYmKGUud29yZHNbZS5sZW5ndGgrK109dCksZX0sbS5fcHJpbWU9ZnVuY3Rpb24oZSl7aWYobFtlXSlyZXR1cm4gbFtlXTt2YXIgdDtpZihcImsyNTZcIj09PWUpdD1uZXcgdjtlbHNlIGlmKFwicDIyNFwiPT09ZSl0PW5ldyBnO2Vsc2UgaWYoXCJwMTkyXCI9PT1lKXQ9bmV3IGI7ZWxzZXtpZihcInAyNTUxOVwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByaW1lIFwiK2UpO3Q9bmV3IHd9cmV0dXJuIGxbZV09dH0sXy5wcm90b3R5cGUuX3ZlcmlmeTE9ZnVuY3Rpb24oZSl7eSgwPT09ZS5uZWdhdGl2ZSxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLHkoZS5yZWQsXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpfSxfLnByb3RvdHlwZS5fdmVyaWZ5Mj1mdW5jdGlvbihlLHQpe3koMD09KGUubmVnYXRpdmV8dC5uZWdhdGl2ZSksXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSx5KGUucmVkJiZlLnJlZD09PXQucmVkLFwicmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKX0sXy5wcm90b3R5cGUuaW1vZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wcmltZT90aGlzLnByaW1lLmlyZWR1Y2UoZSkuX2ZvcmNlUmVkKHRoaXMpOmUudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKGUpe3JldHVybiBlLmlzWmVybygpP2UuY2xvbmUoKTp0aGlzLm0uc3ViKGUpLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdmVyaWZ5MihlLHQpO3ZhciByPWUuYWRkKHQpO3JldHVybiAwPD1yLmNtcCh0aGlzLm0pJiZyLmlzdWIodGhpcy5tKSxyLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUuaWFkZD1mdW5jdGlvbihlLHQpe3RoaXMuX3ZlcmlmeTIoZSx0KTt2YXIgcj1lLmlhZGQodCk7cmV0dXJuIDA8PXIuY21wKHRoaXMubSkmJnIuaXN1Yih0aGlzLm0pLHJ9LF8ucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlLHQpe3RoaXMuX3ZlcmlmeTIoZSx0KTt2YXIgcj1lLnN1Yih0KTtyZXR1cm4gci5jbXBuKDApPDAmJnIuaWFkZCh0aGlzLm0pLHIuX2ZvcmNlUmVkKHRoaXMpfSxfLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdmVyaWZ5MihlLHQpO3ZhciByPWUuaXN1Yih0KTtyZXR1cm4gci5jbXBuKDApPDAmJnIuaWFkZCh0aGlzLm0pLHJ9LF8ucHJvdG90eXBlLnNobD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkxKGUpLHRoaXMuaW1vZChlLnVzaGxuKHQpKX0sXy5wcm90b3R5cGUuaW11bD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkyKGUsdCksdGhpcy5pbW9kKGUuaW11bCh0KSl9LF8ucHJvdG90eXBlLm11bD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkyKGUsdCksdGhpcy5pbW9kKGUubXVsKHQpKX0sXy5wcm90b3R5cGUuaXNxcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pbXVsKGUsZS5jbG9uZSgpKX0sXy5wcm90b3R5cGUuc3FyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm11bChlLGUpfSxfLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKGUpe2lmKGUuaXNaZXJvKCkpcmV0dXJuIGUuY2xvbmUoKTt2YXIgdD10aGlzLm0uYW5kbG4oMyk7aWYoeSh0JTI9PTEpLDM9PT10KXt2YXIgcj10aGlzLm0uYWRkKG5ldyBtKDEpKS5pdXNocm4oMik7cmV0dXJuIHRoaXMucG93KGUscil9Zm9yKHZhciBuPXRoaXMubS5zdWJuKDEpLGk9MDshbi5pc1plcm8oKSYmMD09PW4uYW5kbG4oMSk7KWkrKyxuLml1c2hybigxKTt5KCFuLmlzWmVybygpKTtmb3IodmFyIG89bmV3IG0oMSkudG9SZWQodGhpcykscz1vLnJlZE5lZygpLGE9dGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpLHU9bmV3IG0oMioodT10aGlzLm0uYml0TGVuZ3RoKCkpKnUpLnRvUmVkKHRoaXMpOzAhPT10aGlzLnBvdyh1LGEpLmNtcChzKTspdS5yZWRJQWRkKHMpO2Zvcih2YXIgbD10aGlzLnBvdyh1LG4pLGg9dGhpcy5wb3coZSxuLmFkZG4oMSkuaXVzaHJuKDEpKSxmPXRoaXMucG93KGUsbiksYz1pOzAhPT1mLmNtcChvKTspe2Zvcih2YXIgZD1mLHA9MDswIT09ZC5jbXAobyk7cCsrKWQ9ZC5yZWRTcXIoKTt5KHA8Yyk7dmFyIHY9dGhpcy5wb3cobCxuZXcgbSgxKS5pdXNobG4oYy1wLTEpKSxoPWgucmVkTXVsKHYpLGw9di5yZWRTcXIoKSxmPWYucmVkTXVsKGwpLGM9cH1yZXR1cm4gaH0sXy5wcm90b3R5cGUuaW52bT1mdW5jdGlvbihlKXt2YXIgdD1lLl9pbnZtcCh0aGlzLm0pO3JldHVybiAwIT09dC5uZWdhdGl2ZT8odC5uZWdhdGl2ZT0wLHRoaXMuaW1vZCh0KS5yZWROZWcoKSk6dGhpcy5pbW9kKHQpfSxfLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oZSx0KXtpZih0LmlzWmVybygpKXJldHVybiBuZXcgbSgxKS50b1JlZCh0aGlzKTtpZigwPT09dC5jbXBuKDEpKXJldHVybiBlLmNsb25lKCk7dmFyIHI9bmV3IEFycmF5KDE2KTtyWzBdPW5ldyBtKDEpLnRvUmVkKHRoaXMpLHJbMV09ZTtmb3IodmFyIG49MjtuPHIubGVuZ3RoO24rKylyW25dPXRoaXMubXVsKHJbbi0xXSxlKTt2YXIgaT1yWzBdLG89MCxzPTAsYT10LmJpdExlbmd0aCgpJTI2O2ZvcigwPT09YSYmKGE9MjYpLG49dC5sZW5ndGgtMTswPD1uO24tLSl7Zm9yKHZhciB1PXQud29yZHNbbl0sbD1hLTE7MDw9bDtsLS0pe3ZhciBoPXU+PmwmMTtpIT09clswXSYmKGk9dGhpcy5zcXIoaSkpLDAhPWh8fDAhPT1vPyhvPDw9MSxvfD1oLCg0PT09KytzfHwwPT09biYmMD09PWwpJiYoaT10aGlzLm11bChpLHJbb10pLG89cz0wKSk6cz0wfWE9MjZ9cmV0dXJuIGl9LF8ucHJvdG90eXBlLmNvbnZlcnRUbz1mdW5jdGlvbihlKXt2YXIgdD1lLnVtb2QodGhpcy5tKTtyZXR1cm4gdD09PWU/dC5jbG9uZSgpOnR9LF8ucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2xvbmUoKTtyZXR1cm4gdC5yZWQ9bnVsbCx0fSxtLm1vbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBNKGUpfSxyKE0sXyksTS5wcm90b3R5cGUuY29udmVydFRvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmltb2QoZS51c2hsbih0aGlzLnNoaWZ0KSl9LE0ucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaW1vZChlLm11bCh0aGlzLnJpbnYpKTtyZXR1cm4gdC5yZWQ9bnVsbCx0fSxNLnByb3RvdHlwZS5pbXVsPWZ1bmN0aW9uKGUsdCl7aWYoZS5pc1plcm8oKXx8dC5pc1plcm8oKSlyZXR1cm4gZS53b3Jkc1swXT0wLGUubGVuZ3RoPTEsZTt2YXIgcj1lLmltdWwodCksbj1yLm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKSxpPXIuaXN1YihuKS5pdXNocm4odGhpcy5zaGlmdCksbz1pO3JldHVybiAwPD1pLmNtcCh0aGlzLm0pP289aS5pc3ViKHRoaXMubSk6aS5jbXBuKDApPDAmJihvPWkuaWFkZCh0aGlzLm0pKSxvLl9mb3JjZVJlZCh0aGlzKX0sTS5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUsdCl7aWYoZS5pc1plcm8oKXx8dC5pc1plcm8oKSlyZXR1cm4gbmV3IG0oMCkuX2ZvcmNlUmVkKHRoaXMpO3ZhciByPWUubXVsKHQpLG49ci5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSksaT1yLmlzdWIobikuaXVzaHJuKHRoaXMuc2hpZnQpLG89aTtyZXR1cm4gMDw9aS5jbXAodGhpcy5tKT9vPWkuaXN1Yih0aGlzLm0pOmkuY21wbigwKTwwJiYobz1pLmlhZGQodGhpcy5tKSksby5fZm9yY2VSZWQodGhpcyl9LE0ucHJvdG90eXBlLmludm09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaW1vZChlLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSkuX2ZvcmNlUmVkKHRoaXMpfX0odm9pZCAwPT09ZXx8ZSx0aGlzKX0se2J1ZmZlcjoxMX1dLDEwOltmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKHIpe3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVWludDhBcnJheShlKTtyZXR1cm4oci5jcnlwdG98fHIubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyh0KSx0fX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDExOltmdW5jdGlvbihlLHQscil7fSx7fV0sMTI6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yO24udmVyc2lvbj1lKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb24sbi51dGlscz1lKFwiLi9lbGxpcHRpYy91dGlsc1wiKSxuLnJhbmQ9ZShcImJyb3JhbmRcIiksbi5jdXJ2ZT1lKFwiLi9lbGxpcHRpYy9jdXJ2ZVwiKSxuLmN1cnZlcz1lKFwiLi9lbGxpcHRpYy9jdXJ2ZXNcIiksbi5lYz1lKFwiLi9lbGxpcHRpYy9lY1wiKSxuLmVkZHNhPWUoXCIuL2VsbGlwdGljL2VkZHNhXCIpfSx7XCIuLi9wYWNrYWdlLmpzb25cIjoyNSxcIi4vZWxsaXB0aWMvY3VydmVcIjoxNSxcIi4vZWxsaXB0aWMvY3VydmVzXCI6MTgsXCIuL2VsbGlwdGljL2VjXCI6MTksXCIuL2VsbGlwdGljL2VkZHNhXCI6MjIsXCIuL2VsbGlwdGljL3V0aWxzXCI6MjQsYnJvcmFuZDoxMH1dLDEzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZShcImJuLmpzXCIpLGk9ZShcIi4uL3V0aWxzXCIpLFM9aS5nZXROQUYsaz1pLmdldEpTRixmPWkuYXNzZXJ0O2Z1bmN0aW9uIG8oZSx0KXt0aGlzLnR5cGU9ZSx0aGlzLnA9bmV3IG4odC5wLDE2KSx0aGlzLnJlZD10LnByaW1lP24ucmVkKHQucHJpbWUpOm4ubW9udCh0aGlzLnApLHRoaXMuemVybz1uZXcgbigwKS50b1JlZCh0aGlzLnJlZCksdGhpcy5vbmU9bmV3IG4oMSkudG9SZWQodGhpcy5yZWQpLHRoaXMudHdvPW5ldyBuKDIpLnRvUmVkKHRoaXMucmVkKSx0aGlzLm49dC5uJiZuZXcgbih0Lm4sMTYpLHRoaXMuZz10LmcmJnRoaXMucG9pbnRGcm9tSlNPTih0LmcsdC5nUmVkKSx0aGlzLl93bmFmVDE9bmV3IEFycmF5KDQpLHRoaXMuX3duYWZUMj1uZXcgQXJyYXkoNCksdGhpcy5fd25hZlQzPW5ldyBBcnJheSg0KSx0aGlzLl93bmFmVDQ9bmV3IEFycmF5KDQpLHRoaXMuX2JpdExlbmd0aD10aGlzLm4/dGhpcy5uLmJpdExlbmd0aCgpOjA7dmFyIHI9dGhpcy5uJiZ0aGlzLnAuZGl2KHRoaXMubik7IXJ8fDA8ci5jbXBuKDEwMCk/dGhpcy5yZWROPW51bGw6KHRoaXMuX21heHdlbGxUcmljaz0hMCx0aGlzLnJlZE49dGhpcy5uLnRvUmVkKHRoaXMucmVkKSl9ZnVuY3Rpb24gcyhlLHQpe3RoaXMuY3VydmU9ZSx0aGlzLnR5cGU9dCx0aGlzLnByZWNvbXB1dGVkPW51bGx9KHQuZXhwb3J0cz1vKS5wcm90b3R5cGUucG9pbnQ9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIil9LG8ucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpfSxvLnByb3RvdHlwZS5fZml4ZWROYWZNdWw9ZnVuY3Rpb24oZSx0KXtmKGUucHJlY29tcHV0ZWQpO3ZhciByPWUuX2dldERvdWJsZXMoKSxuPVModCwxLHRoaXMuX2JpdExlbmd0aCksaT0oMTw8ci5zdGVwKzEpLShyLnN0ZXAlMj09MD8yOjEpO2kvPTM7Zm9yKHZhciBvPVtdLHM9MDtzPG4ubGVuZ3RoO3MrPXIuc3RlcCl7Zm9yKHZhciBhPTAsdD1zK3Iuc3RlcC0xO3M8PXQ7dC0tKWE9KGE8PDEpK25bdF07by5wdXNoKGEpfWZvcih2YXIgdT10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksbD10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksaD1pOzA8aDtoLS0pe2ZvcihzPTA7czxvLmxlbmd0aDtzKyspeyhhPW9bc10pPT09aD9sPWwubWl4ZWRBZGQoci5wb2ludHNbc10pOmE9PT0taCYmKGw9bC5taXhlZEFkZChyLnBvaW50c1tzXS5uZWcoKSkpfXU9dS5hZGQobCl9cmV0dXJuIHUudG9QKCl9LG8ucHJvdG90eXBlLl93bmFmTXVsPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPWUuX2dldE5BRlBvaW50cyg0KSxuPXIud25kLGk9ci5wb2ludHMsbz1TKHQsbix0aGlzLl9iaXRMZW5ndGgpLHM9dGhpcy5qcG9pbnQobnVsbCxudWxsLG51bGwpLGE9by5sZW5ndGgtMTswPD1hO2EtLSl7Zm9yKHQ9MDswPD1hJiYwPT09b1thXTthLS0pdCsrO2lmKDA8PWEmJnQrKyxzPXMuZGJscCh0KSxhPDApYnJlYWs7dmFyIHU9b1thXTtmKDAhPT11KSxzPVwiYWZmaW5lXCI9PT1lLnR5cGU/MDx1P3MubWl4ZWRBZGQoaVt1LTE+PjFdKTpzLm1peGVkQWRkKGlbLXUtMT4+MV0ubmVnKCkpOjA8dT9zLmFkZChpW3UtMT4+MV0pOnMuYWRkKGlbLXUtMT4+MV0ubmVnKCkpfXJldHVyblwiYWZmaW5lXCI9PT1lLnR5cGU/cy50b1AoKTpzfSxvLnByb3RvdHlwZS5fd25hZk11bEFkZD1mdW5jdGlvbihlLHQscixuLGkpe2Zvcih2YXIgbz10aGlzLl93bmFmVDEscz10aGlzLl93bmFmVDIsYT10aGlzLl93bmFmVDMsdT0wLGw9MDtsPG47bCsrKXt2YXIgaD0oQT10W2xdKS5fZ2V0TkFGUG9pbnRzKGUpO29bbF09aC53bmQsc1tsXT1oLnBvaW50c31mb3IobD1uLTE7MTw9bDtsLT0yKXt2YXIgZj1sLTEsYz1sO2lmKDE9PT1vW2ZdJiYxPT09b1tjXSl7dmFyIGQ9W3RbZl0sbnVsbCxudWxsLHRbY11dOzA9PT10W2ZdLnkuY21wKHRbY10ueSk/KGRbMV09dFtmXS5hZGQodFtjXSksZFsyXT10W2ZdLnRvSigpLm1peGVkQWRkKHRbY10ubmVnKCkpKTowPT09dFtmXS55LmNtcCh0W2NdLnkucmVkTmVnKCkpPyhkWzFdPXRbZl0udG9KKCkubWl4ZWRBZGQodFtjXSksZFsyXT10W2ZdLmFkZCh0W2NdLm5lZygpKSk6KGRbMV09dFtmXS50b0ooKS5taXhlZEFkZCh0W2NdKSxkWzJdPXRbZl0udG9KKCkubWl4ZWRBZGQodFtjXS5uZWcoKSkpO3ZhciBwPVstMywtMSwtNSwtNywwLDcsNSwxLDNdLHY9ayhyW2ZdLHJbY10pLHU9TWF0aC5tYXgodlswXS5sZW5ndGgsdSk7YVtmXT1uZXcgQXJyYXkodSksYVtjXT1uZXcgQXJyYXkodSk7Zm9yKHZhciB5PTA7eTx1O3krKyl7dmFyIG09MHx2WzBdW3ldLGc9MHx2WzFdW3ldO2FbZl1beV09cFszKigxK20pKygxK2cpXSxhW2NdW3ldPTAsc1tmXT1kfX1lbHNlIGFbZl09UyhyW2ZdLG9bZl0sdGhpcy5fYml0TGVuZ3RoKSxhW2NdPVMocltjXSxvW2NdLHRoaXMuX2JpdExlbmd0aCksdT1NYXRoLm1heChhW2ZdLmxlbmd0aCx1KSx1PU1hdGgubWF4KGFbY10ubGVuZ3RoLHUpfWZvcih2YXIgYj10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksdz10aGlzLl93bmFmVDQsbD11OzA8PWw7bC0tKXtmb3IodmFyIF89MDswPD1sOyl7Zm9yKHZhciBNPSEwLHk9MDt5PG47eSsrKXdbeV09MHxhW3ldW2xdLDAhPT13W3ldJiYoTT0hMSk7aWYoIU0pYnJlYWs7XysrLGwtLX1pZigwPD1sJiZfKyssYj1iLmRibHAoXyksbDwwKWJyZWFrO2Zvcih5PTA7eTxuO3krKyl7dmFyIEEsRT13W3ldOzAhPT1FJiYoMDxFP0E9c1t5XVtFLTE+PjFdOkU8MCYmKEE9c1t5XVstRS0xPj4xXS5uZWcoKSksYj1cImFmZmluZVwiPT09QS50eXBlP2IubWl4ZWRBZGQoQSk6Yi5hZGQoQSkpfX1mb3IobD0wO2w8bjtsKyspc1tsXT1udWxsO3JldHVybiBpP2I6Yi50b1AoKX0sKG8uQmFzZVBvaW50PXMpLnByb3RvdHlwZS5lcT1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKX0scy5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKX0sby5wcm90b3R5cGUuZGVjb2RlUG9pbnQ9ZnVuY3Rpb24oZSx0KXtlPWkudG9BcnJheShlLHQpO3ZhciByPXRoaXMucC5ieXRlTGVuZ3RoKCk7aWYoKDQ9PT1lWzBdfHw2PT09ZVswXXx8Nz09PWVbMF0pJiZlLmxlbmd0aC0xPT0yKnIpcmV0dXJuIDY9PT1lWzBdP2YoZVtlLmxlbmd0aC0xXSUyPT0wKTo3PT09ZVswXSYmZihlW2UubGVuZ3RoLTFdJTI9PTEpLHRoaXMucG9pbnQoZS5zbGljZSgxLDErciksZS5zbGljZSgxK3IsMSsyKnIpKTtpZigoMj09PWVbMF18fDM9PT1lWzBdKSYmZS5sZW5ndGgtMT09PXIpcmV0dXJuIHRoaXMucG9pbnRGcm9tWChlLnNsaWNlKDEsMStyKSwzPT09ZVswXSk7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb2ludCBmb3JtYXRcIil9LHMucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsITApfSxzLnByb3RvdHlwZS5fZW5jb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkscj10aGlzLmdldFgoKS50b0FycmF5KFwiYmVcIix0KTtyZXR1cm4gZT9bdGhpcy5nZXRZKCkuaXNFdmVuKCk/MjozXS5jb25jYXQocik6WzRdLmNvbmNhdChyLHRoaXMuZ2V0WSgpLnRvQXJyYXkoXCJiZVwiLHQpKX0scy5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGkuZW5jb2RlKHRoaXMuX2VuY29kZSh0KSxlKX0scy5wcm90b3R5cGUucHJlY29tcHV0ZT1mdW5jdGlvbihlKXtpZih0aGlzLnByZWNvbXB1dGVkKXJldHVybiB0aGlzO3ZhciB0PXtkb3VibGVzOm51bGwsbmFmOm51bGwsYmV0YTpudWxsfTtyZXR1cm4gdC5uYWY9dGhpcy5fZ2V0TkFGUG9pbnRzKDgpLHQuZG91Ymxlcz10aGlzLl9nZXREb3VibGVzKDQsZSksdC5iZXRhPXRoaXMuX2dldEJldGEoKSx0aGlzLnByZWNvbXB1dGVkPXQsdGhpc30scy5wcm90b3R5cGUuX2hhc0RvdWJsZXM9ZnVuY3Rpb24oZSl7aWYoIXRoaXMucHJlY29tcHV0ZWQpcmV0dXJuITE7dmFyIHQ9dGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO3JldHVybiEhdCYmdC5wb2ludHMubGVuZ3RoPj1NYXRoLmNlaWwoKGUuYml0TGVuZ3RoKCkrMSkvdC5zdGVwKX0scy5wcm90b3R5cGUuX2dldERvdWJsZXM9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLnByZWNvbXB1dGVkJiZ0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcztmb3IodmFyIHI9W3RoaXNdLG49dGhpcyxpPTA7aTx0O2krPWUpe2Zvcih2YXIgbz0wO288ZTtvKyspbj1uLmRibCgpO3IucHVzaChuKX1yZXR1cm57c3RlcDplLHBvaW50czpyfX0scy5wcm90b3R5cGUuX2dldE5BRlBvaW50cz1mdW5jdGlvbihlKXtpZih0aGlzLnByZWNvbXB1dGVkJiZ0aGlzLnByZWNvbXB1dGVkLm5hZilyZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7Zm9yKHZhciB0PVt0aGlzXSxyPSgxPDxlKS0xLG49MT09cj9udWxsOnRoaXMuZGJsKCksaT0xO2k8cjtpKyspdFtpXT10W2ktMV0uYWRkKG4pO3JldHVybnt3bmQ6ZSxwb2ludHM6dH19LHMucHJvdG90eXBlLl9nZXRCZXRhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LHMucHJvdG90eXBlLmRibHA9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMscj0wO3I8ZTtyKyspdD10LmRibCgpO3JldHVybiB0fX0se1wiLi4vdXRpbHNcIjoyNCxcImJuLmpzXCI6OX1dLDE0OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXt9fSx7fV0sMTU6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yO24uYmFzZT1lKFwiLi9iYXNlXCIpLG4uc2hvcnQ9ZShcIi4vc2hvcnRcIiksbi5tb250PWUoXCIuL21vbnRcIiksbi5lZHdhcmRzPWUoXCIuL2Vkd2FyZHNcIil9LHtcIi4vYmFzZVwiOjEzLFwiLi9lZHdhcmRzXCI6MTQsXCIuL21vbnRcIjoxNixcIi4vc2hvcnRcIjoxN31dLDE2OltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwxNzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKSxfPWUoXCJibi5qc1wiKSxpPWUoXCJpbmhlcml0c1wiKSxvPWUoXCIuL2Jhc2VcIikscz1uLmFzc2VydDtmdW5jdGlvbiBhKGUpe28uY2FsbCh0aGlzLFwic2hvcnRcIixlKSx0aGlzLmE9bmV3IF8oZS5hLDE2KS50b1JlZCh0aGlzLnJlZCksdGhpcy5iPW5ldyBfKGUuYiwxNikudG9SZWQodGhpcy5yZWQpLHRoaXMudGludj10aGlzLnR3by5yZWRJbnZtKCksdGhpcy56ZXJvQT0wPT09dGhpcy5hLmZyb21SZWQoKS5jbXBuKDApLHRoaXMudGhyZWVBPTA9PT10aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpLHRoaXMuZW5kbz10aGlzLl9nZXRFbmRvbW9ycGhpc20oZSksdGhpcy5fZW5kb1duYWZUMT1uZXcgQXJyYXkoNCksdGhpcy5fZW5kb1duYWZUMj1uZXcgQXJyYXkoNCl9ZnVuY3Rpb24gdShlLHQscixuKXtvLkJhc2VQb2ludC5jYWxsKHRoaXMsZSxcImFmZmluZVwiKSxudWxsPT09dCYmbnVsbD09PXI/KHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuaW5mPSEwKToodGhpcy54PW5ldyBfKHQsMTYpLHRoaXMueT1uZXcgXyhyLDE2KSxuJiYodGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKSx0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpKSx0aGlzLngucmVkfHwodGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLHRoaXMueS5yZWR8fCh0aGlzLnk9dGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksdGhpcy5pbmY9ITEpfWZ1bmN0aW9uIGwoZSx0LHIsbil7by5CYXNlUG9pbnQuY2FsbCh0aGlzLGUsXCJqYWNvYmlhblwiKSxudWxsPT09dCYmbnVsbD09PXImJm51bGw9PT1uPyh0aGlzLng9dGhpcy5jdXJ2ZS5vbmUsdGhpcy55PXRoaXMuY3VydmUub25lLHRoaXMuej1uZXcgXygwKSk6KHRoaXMueD1uZXcgXyh0LDE2KSx0aGlzLnk9bmV3IF8ociwxNiksdGhpcy56PW5ldyBfKG4sMTYpKSx0aGlzLngucmVkfHwodGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLHRoaXMueS5yZWR8fCh0aGlzLnk9dGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksdGhpcy56LnJlZHx8KHRoaXMuej10aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSx0aGlzLnpPbmU9dGhpcy56PT09dGhpcy5jdXJ2ZS5vbmV9aShhLG8pLCh0LmV4cG9ydHM9YSkucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc209ZnVuY3Rpb24oZSl7dmFyIHQscixuLGk7aWYodGhpcy56ZXJvQSYmdGhpcy5nJiZ0aGlzLm4mJjE9PT10aGlzLnAubW9kbigzKSlyZXR1cm4gbj1lLmJldGE/bmV3IF8oZS5iZXRhLDE2KS50b1JlZCh0aGlzLnJlZCk6KG49KHI9dGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCkpWzBdLmNtcChyWzFdKTwwP3JbMF06clsxXSkudG9SZWQodGhpcy5yZWQpLGUubGFtYmRhP3Q9bmV3IF8oZS5sYW1iZGEsMTYpOihpPXRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pLDA9PT10aGlzLmcubXVsKGlbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChuKSk/dD1pWzBdOih0PWlbMV0scygwPT09dGhpcy5nLm11bCh0KS54LmNtcCh0aGlzLmcueC5yZWRNdWwobikpKSkpLHtiZXRhOm4sbGFtYmRhOnQsYmFzaXM6ZS5iYXNpcz9lLmJhc2lzLm1hcChmdW5jdGlvbihlKXtyZXR1cm57YTpuZXcgXyhlLmEsMTYpLGI6bmV3IF8oZS5iLDE2KX19KTp0aGlzLl9nZXRFbmRvQmFzaXModCl9fSxhLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzPWZ1bmN0aW9uKGUpe3ZhciB0PWU9PT10aGlzLnA/dGhpcy5yZWQ6Xy5tb250KGUpLHI9bmV3IF8oMikudG9SZWQodCkucmVkSW52bSgpLG49ci5yZWROZWcoKSxpPW5ldyBfKDMpLnRvUmVkKHQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwocik7cmV0dXJuW24ucmVkQWRkKGkpLmZyb21SZWQoKSxuLnJlZFN1YihpKS5mcm9tUmVkKCldfSxhLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG4saSxvLHMsYSx1PXRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKS8yKSksbD1lLGg9dGhpcy5uLmNsb25lKCksZj1uZXcgXygxKSxjPW5ldyBfKDApLGQ9bmV3IF8oMCkscD1uZXcgXygxKSx2PTA7MCE9PWwuY21wbigwKTspe3ZhciB5PWguZGl2KGwpLG09aC5zdWIoeS5tdWwobCkpLGc9ZC5zdWIoeS5tdWwoZikpLGI9cC5zdWIoeS5tdWwoYykpO2lmKCFuJiZtLmNtcCh1KTwwKXQ9YS5uZWcoKSxyPWYsbj1tLm5lZygpLGk9ZztlbHNlIGlmKG4mJjI9PSsrdilicmVhaztoPWwsbD1hPW0sZD1mLGY9ZyxwPWMsYz1ifW89bS5uZWcoKSxzPWc7dmFyIHc9bi5zcXIoKS5hZGQoaS5zcXIoKSk7cmV0dXJuIDA8PW8uc3FyKCkuYWRkKHMuc3FyKCkpLmNtcCh3KSYmKG89dCxzPXIpLG4ubmVnYXRpdmUmJihuPW4ubmVnKCksaT1pLm5lZygpKSxvLm5lZ2F0aXZlJiYobz1vLm5lZygpLHM9cy5uZWcoKSksW3thOm4sYjppfSx7YTpvLGI6c31dfSxhLnByb3RvdHlwZS5fZW5kb1NwbGl0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZW5kby5iYXNpcyxyPXRbMF0sbj10WzFdLGk9bi5iLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLG89ci5iLm5lZygpLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLHM9aS5tdWwoci5hKSxhPW8ubXVsKG4uYSksdT1pLm11bChyLmIpLGw9by5tdWwobi5iKTtyZXR1cm57azE6ZS5zdWIocykuc3ViKGEpLGsyOnUuYWRkKGwpLm5lZygpfX0sYS5wcm90b3R5cGUucG9pbnRGcm9tWD1mdW5jdGlvbihlLHQpeyhlPW5ldyBfKGUsMTYpKS5yZWR8fChlPWUudG9SZWQodGhpcy5yZWQpKTt2YXIgcj1lLnJlZFNxcigpLnJlZE11bChlKS5yZWRJQWRkKGUucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKSxuPXIucmVkU3FydCgpO2lmKDAhPT1uLnJlZFNxcigpLnJlZFN1YihyKS5jbXAodGhpcy56ZXJvKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50XCIpO3ZhciBpPW4uZnJvbVJlZCgpLmlzT2RkKCk7cmV0dXJuKHQmJiFpfHwhdCYmaSkmJihuPW4ucmVkTmVnKCkpLHRoaXMucG9pbnQoZSxuKX0sYS5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oZSl7aWYoZS5pbmYpcmV0dXJuITA7dmFyIHQ9ZS54LHI9ZS55LG49dGhpcy5hLnJlZE11bCh0KSxpPXQucmVkU3FyKCkucmVkTXVsKHQpLnJlZElBZGQobikucmVkSUFkZCh0aGlzLmIpO3JldHVybiAwPT09ci5yZWRTcXIoKS5yZWRJU3ViKGkpLmNtcG4oMCl9LGEucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZD1mdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPXRoaXMuX2VuZG9XbmFmVDEsaT10aGlzLl9lbmRvV25hZlQyLG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIHM9dGhpcy5fZW5kb1NwbGl0KHRbb10pLGE9ZVtvXSx1PWEuX2dldEJldGEoKTtzLmsxLm5lZ2F0aXZlJiYocy5rMS5pbmVnKCksYT1hLm5lZyghMCkpLHMuazIubmVnYXRpdmUmJihzLmsyLmluZWcoKSx1PXUubmVnKCEwKSksblsyKm9dPWEsblsyKm8rMV09dSxpWzIqb109cy5rMSxpWzIqbysxXT1zLmsyfWZvcih2YXIgbD10aGlzLl93bmFmTXVsQWRkKDEsbixpLDIqbyxyKSxoPTA7aDwyKm87aCsrKW5baF09bnVsbCxpW2hdPW51bGw7cmV0dXJuIGx9LGkodSxvLkJhc2VQb2ludCksYS5wcm90b3R5cGUucG9pbnQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBuZXcgdSh0aGlzLGUsdCxyKX0sYS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTj1mdW5jdGlvbihlLHQpe3JldHVybiB1LmZyb21KU09OKHRoaXMsZSx0KX0sdS5wcm90b3R5cGUuX2dldEJldGE9ZnVuY3Rpb24oKXtpZih0aGlzLmN1cnZlLmVuZG8pe3ZhciBlPXRoaXMucHJlY29tcHV0ZWQ7aWYoZSYmZS5iZXRhKXJldHVybiBlLmJldGE7dmFyIHQscixuPXRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksdGhpcy55KTtyZXR1cm4gZSYmKHQ9dGhpcy5jdXJ2ZSxyPWZ1bmN0aW9uKGUpe3JldHVybiB0LnBvaW50KGUueC5yZWRNdWwodC5lbmRvLmJldGEpLGUueSl9LChlLmJldGE9bikucHJlY29tcHV0ZWQ9e2JldGE6bnVsbCxuYWY6ZS5uYWYmJnt3bmQ6ZS5uYWYud25kLHBvaW50czplLm5hZi5wb2ludHMubWFwKHIpfSxkb3VibGVzOmUuZG91YmxlcyYme3N0ZXA6ZS5kb3VibGVzLnN0ZXAscG9pbnRzOmUuZG91Ymxlcy5wb2ludHMubWFwKHIpfX0pLG59fSx1LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVjb21wdXRlZD9bdGhpcy54LHRoaXMueSx0aGlzLnByZWNvbXB1dGVkJiZ7ZG91Ymxlczp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMmJntzdGVwOnRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpfSxuYWY6dGhpcy5wcmVjb21wdXRlZC5uYWYmJnt3bmQ6dGhpcy5wcmVjb21wdXRlZC5uYWYud25kLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSl9fV06W3RoaXMueCx0aGlzLnldfSx1LmZyb21KU09OPWZ1bmN0aW9uKHQsZSxyKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9SlNPTi5wYXJzZShlKSk7dmFyIG49dC5wb2ludChlWzBdLGVbMV0scik7aWYoIWVbMl0pcmV0dXJuIG47ZnVuY3Rpb24gaShlKXtyZXR1cm4gdC5wb2ludChlWzBdLGVbMV0scil9dmFyIG89ZVsyXTtyZXR1cm4gbi5wcmVjb21wdXRlZD17YmV0YTpudWxsLGRvdWJsZXM6by5kb3VibGVzJiZ7c3RlcDpvLmRvdWJsZXMuc3RlcCxwb2ludHM6W25dLmNvbmNhdChvLmRvdWJsZXMucG9pbnRzLm1hcChpKSl9LG5hZjpvLm5hZiYme3duZDpvLm5hZi53bmQscG9pbnRzOltuXS5jb25jYXQoby5uYWYucG9pbnRzLm1hcChpKSl9fSxufSx1LnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpP1wiPEVDIFBvaW50IEluZmluaXR5PlwiOlwiPEVDIFBvaW50IHg6IFwiK3RoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwyKStcIj5cIn0sdS5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluZn0sdS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaW5mKXJldHVybiBlO2lmKGUuaW5mKXJldHVybiB0aGlzO2lmKHRoaXMuZXEoZSkpcmV0dXJuIHRoaXMuZGJsKCk7aWYodGhpcy5uZWcoKS5lcShlKSlyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO2lmKDA9PT10aGlzLnguY21wKGUueCkpcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCxudWxsKTt2YXIgdD10aGlzLnkucmVkU3ViKGUueSk7MCE9PXQuY21wbigwKSYmKHQ9dC5yZWRNdWwodGhpcy54LnJlZFN1YihlLngpLnJlZEludm0oKSkpO3ZhciByPXQucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIoZS54KSxuPXQucmVkTXVsKHRoaXMueC5yZWRTdWIocikpLnJlZElTdWIodGhpcy55KTtyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChyLG4pfSx1LnByb3RvdHlwZS5kYmw9ZnVuY3Rpb24oKXtpZih0aGlzLmluZilyZXR1cm4gdGhpczt2YXIgZT10aGlzLnkucmVkQWRkKHRoaXMueSk7aWYoMD09PWUuY21wbigwKSlyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO3ZhciB0PXRoaXMuY3VydmUuYSxyPXRoaXMueC5yZWRTcXIoKSxuPWUucmVkSW52bSgpLGk9ci5yZWRBZGQocikucmVkSUFkZChyKS5yZWRJQWRkKHQpLnJlZE11bChuKSxvPWkucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpLHM9aS5yZWRNdWwodGhpcy54LnJlZFN1YihvKSkucmVkSVN1Yih0aGlzLnkpO3JldHVybiB0aGlzLmN1cnZlLnBvaW50KG8scyl9LHUucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54LmZyb21SZWQoKX0sdS5wcm90b3R5cGUuZ2V0WT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnkuZnJvbVJlZCgpfSx1LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9bmV3IF8oZSwxNiksdGhpcy5pc0luZmluaXR5KCk/dGhpczp0aGlzLl9oYXNEb3VibGVzKGUpP3RoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsZSk6dGhpcy5jdXJ2ZS5lbmRvP3RoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFt0aGlzXSxbZV0pOnRoaXMuY3VydmUuX3duYWZNdWwodGhpcyxlKX0sdS5wcm90b3R5cGUubXVsQWRkPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1bdGhpcyx0XSxpPVtlLHJdO3JldHVybiB0aGlzLmN1cnZlLmVuZG8/dGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQobixpKTp0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsbixpLDIpfSx1LnByb3RvdHlwZS5qbXVsQWRkPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1bdGhpcyx0XSxpPVtlLHJdO3JldHVybiB0aGlzLmN1cnZlLmVuZG8/dGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQobixpLCEwKTp0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsbixpLDIsITApfSx1LnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcz09PWV8fHRoaXMuaW5mPT09ZS5pbmYmJih0aGlzLmluZnx8MD09PXRoaXMueC5jbXAoZS54KSYmMD09PXRoaXMueS5jbXAoZS55KSl9LHUucHJvdG90eXBlLm5lZz1mdW5jdGlvbihlKXtpZih0aGlzLmluZilyZXR1cm4gdGhpczt2YXIgdCxyLG49dGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsdGhpcy55LnJlZE5lZygpKTtyZXR1cm4gZSYmdGhpcy5wcmVjb21wdXRlZCYmKHQ9dGhpcy5wcmVjb21wdXRlZCxyPWZ1bmN0aW9uKGUpe3JldHVybiBlLm5lZygpfSxuLnByZWNvbXB1dGVkPXtuYWY6dC5uYWYmJnt3bmQ6dC5uYWYud25kLHBvaW50czp0Lm5hZi5wb2ludHMubWFwKHIpfSxkb3VibGVzOnQuZG91YmxlcyYme3N0ZXA6dC5kb3VibGVzLnN0ZXAscG9pbnRzOnQuZG91Ymxlcy5wb2ludHMubWFwKHIpfX0pLG59LHUucHJvdG90eXBlLnRvSj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluZj90aGlzLmN1cnZlLmpwb2ludChudWxsLG51bGwsbnVsbCk6dGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LHRoaXMueSx0aGlzLmN1cnZlLm9uZSl9LGkobCxvLkJhc2VQb2ludCksYS5wcm90b3R5cGUuanBvaW50PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbmV3IGwodGhpcyxlLHQscil9LGwucHJvdG90eXBlLnRvUD1mdW5jdGlvbigpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsbnVsbCk7dmFyIGU9dGhpcy56LnJlZEludm0oKSx0PWUucmVkU3FyKCkscj10aGlzLngucmVkTXVsKHQpLG49dGhpcy55LnJlZE11bCh0KS5yZWRNdWwoZSk7cmV0dXJuIHRoaXMuY3VydmUucG9pbnQocixuKX0sbC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCx0aGlzLnkucmVkTmVnKCksdGhpcy56KX0sbC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBlO2lmKGUuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO3ZhciB0PWUuei5yZWRTcXIoKSxyPXRoaXMuei5yZWRTcXIoKSxuPXRoaXMueC5yZWRNdWwodCksaT1lLngucmVkTXVsKHIpLG89dGhpcy55LnJlZE11bCh0LnJlZE11bChlLnopKSxzPWUueS5yZWRNdWwoci5yZWRNdWwodGhpcy56KSksYT1uLnJlZFN1YihpKSx1PW8ucmVkU3ViKHMpO2lmKDA9PT1hLmNtcG4oMCkpcmV0dXJuIDAhPT11LmNtcG4oMCk/dGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCxudWxsLG51bGwpOnRoaXMuZGJsKCk7dmFyIGw9YS5yZWRTcXIoKSxoPWwucmVkTXVsKGEpLGY9bi5yZWRNdWwobCksYz11LnJlZFNxcigpLnJlZElBZGQoaCkucmVkSVN1YihmKS5yZWRJU3ViKGYpLGQ9dS5yZWRNdWwoZi5yZWRJU3ViKGMpKS5yZWRJU3ViKG8ucmVkTXVsKGgpKSxwPXRoaXMuei5yZWRNdWwoZS56KS5yZWRNdWwoYSk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGMsZCxwKX0sbC5wcm90b3R5cGUubWl4ZWRBZGQ9ZnVuY3Rpb24oZSl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIGUudG9KKCk7aWYoZS5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy56LnJlZFNxcigpLHI9dGhpcy54LG49ZS54LnJlZE11bCh0KSxpPXRoaXMueSxvPWUueS5yZWRNdWwodCkucmVkTXVsKHRoaXMueikscz1yLnJlZFN1YihuKSxhPWkucmVkU3ViKG8pO2lmKDA9PT1zLmNtcG4oMCkpcmV0dXJuIDAhPT1hLmNtcG4oMCk/dGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCxudWxsLG51bGwpOnRoaXMuZGJsKCk7dmFyIHU9cy5yZWRTcXIoKSxsPXUucmVkTXVsKHMpLGg9ci5yZWRNdWwodSksZj1hLnJlZFNxcigpLnJlZElBZGQobCkucmVkSVN1YihoKS5yZWRJU3ViKGgpLGM9YS5yZWRNdWwoaC5yZWRJU3ViKGYpKS5yZWRJU3ViKGkucmVkTXVsKGwpKSxkPXRoaXMuei5yZWRNdWwocyk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGYsYyxkKX0sbC5wcm90b3R5cGUuZGJscD1mdW5jdGlvbihlKXtpZigwPT09ZSlyZXR1cm4gdGhpcztpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZighZSlyZXR1cm4gdGhpcy5kYmwoKTtpZih0aGlzLmN1cnZlLnplcm9BfHx0aGlzLmN1cnZlLnRocmVlQSl7Zm9yKHZhciB0PXRoaXMscj0wO3I8ZTtyKyspdD10LmRibCgpO3JldHVybiB0fWZvcih2YXIgbj10aGlzLmN1cnZlLmEsaT10aGlzLmN1cnZlLnRpbnYsbz10aGlzLngscz10aGlzLnksYT10aGlzLnosdT1hLnJlZFNxcigpLnJlZFNxcigpLGw9cy5yZWRBZGQocykscj0wO3I8ZTtyKyspe3ZhciBoPW8ucmVkU3FyKCksZj1sLnJlZFNxcigpLGM9Zi5yZWRTcXIoKSxkPWgucmVkQWRkKGgpLnJlZElBZGQoaCkucmVkSUFkZChuLnJlZE11bCh1KSkscD1vLnJlZE11bChmKSx2PWQucmVkU3FyKCkucmVkSVN1YihwLnJlZEFkZChwKSkseT1wLnJlZElTdWIodiksbT0obT1kLnJlZE11bCh5KSkucmVkSUFkZChtKS5yZWRJU3ViKGMpLGc9bC5yZWRNdWwoYSk7cisxPGUmJih1PXUucmVkTXVsKGMpKSxvPXYsYT1nLGw9bX1yZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobyxsLnJlZE11bChpKSxhKX0sbC5wcm90b3R5cGUuZGJsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpP3RoaXM6dGhpcy5jdXJ2ZS56ZXJvQT90aGlzLl96ZXJvRGJsKCk6dGhpcy5jdXJ2ZS50aHJlZUE/dGhpcy5fdGhyZWVEYmwoKTp0aGlzLl9kYmwoKX0sbC5wcm90b3R5cGUuX3plcm9EYmw9ZnVuY3Rpb24oKXt2YXIgZSx0LHIsbixpLG8scyxhLHUsbCxoLGYsYyxkLHAsdix5PXRoaXMuek9uZT8ocj10aGlzLngucmVkU3FyKCksaT0obj10aGlzLnkucmVkU3FyKCkpLnJlZFNxcigpLG89KG89dGhpcy54LnJlZEFkZChuKS5yZWRTcXIoKS5yZWRJU3ViKHIpLnJlZElTdWIoaSkpLnJlZElBZGQobyksYT0ocz1yLnJlZEFkZChyKS5yZWRJQWRkKHIpKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIobyksdT0odT0odT1pLnJlZElBZGQoaSkpLnJlZElBZGQodSkpLnJlZElBZGQodSksZT1hLHQ9cy5yZWRNdWwoby5yZWRJU3ViKGEpKS5yZWRJU3ViKHUpLHRoaXMueS5yZWRBZGQodGhpcy55KSk6KGw9dGhpcy54LnJlZFNxcigpLGY9KGg9dGhpcy55LnJlZFNxcigpKS5yZWRTcXIoKSxjPShjPXRoaXMueC5yZWRBZGQoaCkucmVkU3FyKCkucmVkSVN1YihsKS5yZWRJU3ViKGYpKS5yZWRJQWRkKGMpLHA9KGQ9bC5yZWRBZGQobCkucmVkSUFkZChsKSkucmVkU3FyKCksdj0odj0odj1mLnJlZElBZGQoZikpLnJlZElBZGQodikpLnJlZElBZGQodiksZT1wLnJlZElTdWIoYykucmVkSVN1YihjKSx0PWQucmVkTXVsKGMucmVkSVN1YihlKSkucmVkSVN1Yih2KSwoeT10aGlzLnkucmVkTXVsKHRoaXMueikpLnJlZElBZGQoeSkpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChlLHQseSl9LGwucHJvdG90eXBlLl90aHJlZURibD1mdW5jdGlvbigpe3ZhciBlLHQscixuLGksbyxzLGEsdSxsLGgsZixjLGQscCx2LHk7cmV0dXJuIHRoaXMuek9uZT8ocj10aGlzLngucmVkU3FyKCksaT0obj10aGlzLnkucmVkU3FyKCkpLnJlZFNxcigpLG89KG89dGhpcy54LnJlZEFkZChuKS5yZWRTcXIoKS5yZWRJU3ViKHIpLnJlZElTdWIoaSkpLnJlZElBZGQobyksdT1hPShzPXIucmVkQWRkKHIpLnJlZElBZGQocikucmVkSUFkZCh0aGlzLmN1cnZlLmEpKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIobyksbD0obD0obD1pLnJlZElBZGQoaSkpLnJlZElBZGQobCkpLnJlZElBZGQobCksZT1zLnJlZE11bChvLnJlZElTdWIoYSkpLnJlZElTdWIobCksdD10aGlzLnkucmVkQWRkKHRoaXMueSkpOihoPXRoaXMuei5yZWRTcXIoKSxmPXRoaXMueS5yZWRTcXIoKSxjPXRoaXMueC5yZWRNdWwoZiksZD0oZD10aGlzLngucmVkU3ViKGgpLnJlZE11bCh0aGlzLngucmVkQWRkKGgpKSkucmVkQWRkKGQpLnJlZElBZGQoZCksdj0ocD0ocD1jLnJlZElBZGQoYykpLnJlZElBZGQocCkpLnJlZEFkZChwKSx1PWQucmVkU3FyKCkucmVkSVN1Yih2KSx0PXRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGYpLnJlZElTdWIoaCkseT0oeT0oeT0oeT1mLnJlZFNxcigpKS5yZWRJQWRkKHkpKS5yZWRJQWRkKHkpKS5yZWRJQWRkKHkpLGU9ZC5yZWRNdWwocC5yZWRJU3ViKHUpKS5yZWRJU3ViKHkpKSx0aGlzLmN1cnZlLmpwb2ludCh1LGUsdCl9LGwucHJvdG90eXBlLl9kYmw9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmN1cnZlLmEsdD10aGlzLngscj10aGlzLnksbj10aGlzLnosaT1uLnJlZFNxcigpLnJlZFNxcigpLG89dC5yZWRTcXIoKSxzPXIucmVkU3FyKCksYT1vLnJlZEFkZChvKS5yZWRJQWRkKG8pLnJlZElBZGQoZS5yZWRNdWwoaSkpLHU9dC5yZWRBZGQodCksbD0odT11LnJlZElBZGQodSkpLnJlZE11bChzKSxoPWEucmVkU3FyKCkucmVkSVN1YihsLnJlZEFkZChsKSksZj1sLnJlZElTdWIoaCksYz1zLnJlZFNxcigpO2M9KGM9KGM9Yy5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpO3ZhciBkPWEucmVkTXVsKGYpLnJlZElTdWIoYykscD1yLnJlZEFkZChyKS5yZWRNdWwobik7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGgsZCxwKX0sbC5wcm90b3R5cGUudHJwbD1mdW5jdGlvbigpe2lmKCF0aGlzLmN1cnZlLnplcm9BKXJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTt2YXIgZT10aGlzLngucmVkU3FyKCksdD10aGlzLnkucmVkU3FyKCkscj10aGlzLnoucmVkU3FyKCksbj10LnJlZFNxcigpLGk9ZS5yZWRBZGQoZSkucmVkSUFkZChlKSxvPWkucmVkU3FyKCkscz10aGlzLngucmVkQWRkKHQpLnJlZFNxcigpLnJlZElTdWIoZSkucmVkSVN1YihuKSxhPShzPShzPShzPXMucmVkSUFkZChzKSkucmVkQWRkKHMpLnJlZElBZGQocykpLnJlZElTdWIobykpLnJlZFNxcigpLHU9bi5yZWRJQWRkKG4pO3U9KHU9KHU9dS5yZWRJQWRkKHUpKS5yZWRJQWRkKHUpKS5yZWRJQWRkKHUpO3ZhciBsPWkucmVkSUFkZChzKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIoYSkucmVkSVN1Yih1KSxoPXQucmVkTXVsKGwpO2g9KGg9aC5yZWRJQWRkKGgpKS5yZWRJQWRkKGgpO3ZhciBmPXRoaXMueC5yZWRNdWwoYSkucmVkSVN1YihoKTtmPShmPWYucmVkSUFkZChmKSkucmVkSUFkZChmKTt2YXIgYz10aGlzLnkucmVkTXVsKGwucmVkTXVsKHUucmVkSVN1YihsKSkucmVkSVN1YihzLnJlZE11bChhKSkpO2M9KGM9KGM9Yy5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpO3ZhciBkPXRoaXMuei5yZWRBZGQocykucmVkU3FyKCkucmVkSVN1YihyKS5yZWRJU3ViKGEpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChmLGMsZCl9LGwucHJvdG90eXBlLm11bD1mdW5jdGlvbihlLHQpe3JldHVybiBlPW5ldyBfKGUsdCksdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLGUpfSxsLnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtpZihcImFmZmluZVwiPT09ZS50eXBlKXJldHVybiB0aGlzLmVxKGUudG9KKCkpO2lmKHRoaXM9PT1lKXJldHVybiEwO3ZhciB0PXRoaXMuei5yZWRTcXIoKSxyPWUuei5yZWRTcXIoKTtpZigwIT09dGhpcy54LnJlZE11bChyKS5yZWRJU3ViKGUueC5yZWRNdWwodCkpLmNtcG4oMCkpcmV0dXJuITE7dmFyIG49dC5yZWRNdWwodGhpcy56KSxpPXIucmVkTXVsKGUueik7cmV0dXJuIDA9PT10aGlzLnkucmVkTXVsKGkpLnJlZElTdWIoZS55LnJlZE11bChuKSkuY21wbigwKX0sbC5wcm90b3R5cGUuZXFYVG9QPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuei5yZWRTcXIoKSxyPWUudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh0KTtpZigwPT09dGhpcy54LmNtcChyKSlyZXR1cm4hMDtmb3IodmFyIG49ZS5jbG9uZSgpLGk9dGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0KTs7KXtpZihuLmlhZGQodGhpcy5jdXJ2ZS5uKSwwPD1uLmNtcCh0aGlzLmN1cnZlLnApKXJldHVybiExO2lmKHIucmVkSUFkZChpKSwwPT09dGhpcy54LmNtcChyKSlyZXR1cm4hMH19LGwucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0luZmluaXR5KCk/XCI8RUMgSlBvaW50IEluZmluaXR5PlwiOlwiPEVDIEpQb2ludCB4OiBcIit0aGlzLngudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LnRvU3RyaW5nKDE2LDIpK1wiIHo6IFwiK3RoaXMuei50b1N0cmluZygxNiwyKStcIj5cIn0sbC5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy56LmNtcG4oMCl9fSx7XCIuLi91dGlsc1wiOjI0LFwiLi9iYXNlXCI6MTMsXCJibi5qc1wiOjksaW5oZXJpdHM6Mzl9XSwxODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9cixvPWUoXCJoYXNoLmpzXCIpLHM9ZShcIi4vY3VydmVcIiksYT1lKFwiLi91dGlsc1wiKS5hc3NlcnQ7ZnVuY3Rpb24gdShlKXtcInNob3J0XCI9PT1lLnR5cGU/dGhpcy5jdXJ2ZT1uZXcgcy5zaG9ydChlKTpcImVkd2FyZHNcIj09PWUudHlwZT90aGlzLmN1cnZlPW5ldyBzLmVkd2FyZHMoZSk6dGhpcy5jdXJ2ZT1uZXcgcy5tb250KGUpLHRoaXMuZz10aGlzLmN1cnZlLmcsdGhpcy5uPXRoaXMuY3VydmUubix0aGlzLmhhc2g9ZS5oYXNoLGEodGhpcy5nLnZhbGlkYXRlKCksXCJJbnZhbGlkIGN1cnZlXCIpLGEodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSxcIkludmFsaWQgY3VydmUsIEcqTiAhPSBPXCIpfWZ1bmN0aW9uIGwodCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoaSx0LHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXt2YXIgZT1uZXcgdShyKTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksdCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0pLGV9fSl9aS5QcmVzZXRDdXJ2ZT11LGwoXCJwMTkyXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDE5MlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCI2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMVwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMVwiLGhhc2g6by5zaGEyNTYsZ1JlZDohMSxnOltcIjE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyXCIsXCIwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMVwiXX0pLGwoXCJwMjI0XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDIyNFwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZVwiLGI6XCJiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNFwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZFwiLGhhc2g6by5zaGEyNTYsZ1JlZDohMSxnOltcImI3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxXCIsXCJiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNFwiXX0pLGwoXCJwMjU2XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOm51bGwscDpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmXCIsYTpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjXCIsYjpcIjVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiXCIsbjpcImZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxXCIsaGFzaDpvLnNoYTI1NixnUmVkOiExLGc6W1wiNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTZcIixcIjRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1XCJdfSksbChcInAzODRcIix7dHlwZTpcInNob3J0XCIscHJpbWU6bnVsbCxwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmZcIixhOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmNcIixiOlwiYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWZcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzNcIixoYXNoOm8uc2hhMzg0LGdSZWQ6ITEsZzpbXCJhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCA1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiN1wiLFwiMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWZcIl19KSxsKFwicDUyMVwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpudWxsLHA6XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCIwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiA5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAzYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMFwiLG46XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCBmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOVwiLGhhc2g6by5zaGE1MTIsZ1JlZDohMSxnOltcIjAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5IDA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3IGEyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2XCIsXCIwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSA1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAzZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MFwiXX0pLGwoXCJjdXJ2ZTI1NTE5XCIse3R5cGU6XCJtb250XCIscHJpbWU6XCJwMjU1MTlcIixwOlwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiLGE6XCI3NmQwNlwiLGI6XCIxXCIsbjpcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixoYXNoOm8uc2hhMjU2LGdSZWQ6ITEsZzpbXCI5XCJdfSksbChcImVkMjU1MTlcIix7dHlwZTpcImVkd2FyZHNcIixwcmltZTpcInAyNTUxOVwiLHA6XCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIsYTpcIi0xXCIsYzpcIjFcIixkOlwiNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhM1wiLG46XCIxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkXCIsaGFzaDpvLnNoYTI1NixnUmVkOiExLGc6W1wiMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYVwiLFwiNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OFwiXX0pO3RyeXtuPWUoXCIuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMVwiKX1jYXRjaChlKXtuPXZvaWQgMH1sKFwic2VjcDI1NmsxXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwiazI1NlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiLGE6XCIwXCIsYjpcIjdcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDFcIixoOlwiMVwiLGhhc2g6by5zaGEyNTYsYmV0YTpcIjdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWVcIixsYW1iZGE6XCI1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyXCIsYmFzaXM6W3thOlwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIixiOlwiLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCJ9LHthOlwiMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIsYjpcIjMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCJ9XSxnUmVkOiExLGc6W1wiNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiLFwiNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiLG5dfSl9LHtcIi4vY3VydmVcIjoxNSxcIi4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxXCI6MjMsXCIuL3V0aWxzXCI6MjQsXCJoYXNoLmpzXCI6MjZ9XSwxOTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciB5PWUoXCJibi5qc1wiKSxtPWUoXCJobWFjLWRyYmdcIiksbj1lKFwiLi4vdXRpbHNcIiksaT1lKFwiLi4vY3VydmVzXCIpLG89ZShcImJyb3JhbmRcIiksZD1uLmFzc2VydCxzPWUoXCIuL2tleVwiKSxnPWUoXCIuL3NpZ25hdHVyZVwiKTtmdW5jdGlvbiBhKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYShlKTtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGQoaS5oYXNPd25Qcm9wZXJ0eShlKSxcIlVua25vd24gY3VydmUgXCIrZSksZT1pW2VdKSxlIGluc3RhbmNlb2YgaS5QcmVzZXRDdXJ2ZSYmKGU9e2N1cnZlOmV9KSx0aGlzLmN1cnZlPWUuY3VydmUuY3VydmUsdGhpcy5uPXRoaXMuY3VydmUubix0aGlzLm5oPXRoaXMubi51c2hybigxKSx0aGlzLmc9dGhpcy5jdXJ2ZS5nLHRoaXMuZz1lLmN1cnZlLmcsdGhpcy5nLnByZWNvbXB1dGUoZS5jdXJ2ZS5uLmJpdExlbmd0aCgpKzEpLHRoaXMuaGFzaD1lLmhhc2h8fGUuY3VydmUuaGFzaH0odC5leHBvcnRzPWEpLnByb3RvdHlwZS5rZXlQYWlyPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcyh0aGlzLGUpfSxhLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBzLmZyb21Qcml2YXRlKHRoaXMsZSx0KX0sYS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYz1mdW5jdGlvbihlLHQpe3JldHVybiBzLmZyb21QdWJsaWModGhpcyxlLHQpfSxhLnByb3RvdHlwZS5nZW5LZXlQYWlyPWZ1bmN0aW9uKGUpe2U9ZXx8e307Zm9yKHZhciB0PW5ldyBtKHtoYXNoOnRoaXMuaGFzaCxwZXJzOmUucGVycyxwZXJzRW5jOmUucGVyc0VuY3x8XCJ1dGY4XCIsZW50cm9weTplLmVudHJvcHl8fG8odGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksZW50cm9weUVuYzplLmVudHJvcHkmJmUuZW50cm9weUVuY3x8XCJ1dGY4XCIsbm9uY2U6dGhpcy5uLnRvQXJyYXkoKX0pLHI9dGhpcy5uLmJ5dGVMZW5ndGgoKSxuPXRoaXMubi5zdWIobmV3IHkoMikpOzspe3ZhciBpPW5ldyB5KHQuZ2VuZXJhdGUocikpO2lmKCEoMDxpLmNtcChuKSkpcmV0dXJuIGkuaWFkZG4oMSksdGhpcy5rZXlGcm9tUHJpdmF0ZShpKX19LGEucHJvdG90eXBlLl90cnVuY2F0ZVRvTj1mdW5jdGlvbihlLHQpe3ZhciByPTgqZS5ieXRlTGVuZ3RoKCktdGhpcy5uLmJpdExlbmd0aCgpO3JldHVybiAwPHImJihlPWUudXNocm4ocikpLCF0JiYwPD1lLmNtcCh0aGlzLm4pP2Uuc3ViKHRoaXMubik6ZX0sYS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlLHQscixuKXtcIm9iamVjdFwiPT10eXBlb2YgciYmKG49cixyPW51bGwpLG49bnx8e30sdD10aGlzLmtleUZyb21Qcml2YXRlKHQsciksZT10aGlzLl90cnVuY2F0ZVRvTihuZXcgeShlLDE2KSk7Zm9yKHZhciBpPXRoaXMubi5ieXRlTGVuZ3RoKCksbz10LmdldFByaXZhdGUoKS50b0FycmF5KFwiYmVcIixpKSxzPWUudG9BcnJheShcImJlXCIsaSksYT1uZXcgbSh7aGFzaDp0aGlzLmhhc2gsZW50cm9weTpvLG5vbmNlOnMscGVyczpuLnBlcnMscGVyc0VuYzpuLnBlcnNFbmN8fFwidXRmOFwifSksdT10aGlzLm4uc3ViKG5ldyB5KDEpKSxsPTA7O2wrKyl7dmFyIGg9bi5rP24uayhsKTpuZXcgeShhLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtpZighKChoPXRoaXMuX3RydW5jYXRlVG9OKGgsITApKS5jbXBuKDEpPD0wfHwwPD1oLmNtcCh1KSkpe3ZhciBmPXRoaXMuZy5tdWwoaCk7aWYoIWYuaXNJbmZpbml0eSgpKXt2YXIgYz1mLmdldFgoKSxkPWMudW1vZCh0aGlzLm4pO2lmKDAhPT1kLmNtcG4oMCkpe3ZhciBwPWguaW52bSh0aGlzLm4pLm11bChkLm11bCh0LmdldFByaXZhdGUoKSkuaWFkZChlKSk7aWYoMCE9PShwPXAudW1vZCh0aGlzLm4pKS5jbXBuKDApKXt2YXIgdj0oZi5nZXRZKCkuaXNPZGQoKT8xOjApfCgwIT09Yy5jbXAoZCk/MjowKTtyZXR1cm4gbi5jYW5vbmljYWwmJjA8cC5jbXAodGhpcy5uaCkmJihwPXRoaXMubi5zdWIocCksdl49MSksbmV3IGcoe3I6ZCxzOnAscmVjb3ZlcnlQYXJhbTp2fSl9fX19fX0sYS5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uKGUsdCxyLG4pe2U9dGhpcy5fdHJ1bmNhdGVUb04obmV3IHkoZSwxNikpLHI9dGhpcy5rZXlGcm9tUHVibGljKHIsbik7dmFyIGk9KHQ9bmV3IGcodCxcImhleFwiKSkucixvPXQucztpZihpLmNtcG4oMSk8MHx8MDw9aS5jbXAodGhpcy5uKSlyZXR1cm4hMTtpZihvLmNtcG4oMSk8MHx8MDw9by5jbXAodGhpcy5uKSlyZXR1cm4hMTt2YXIgcyxhPW8uaW52bSh0aGlzLm4pLHU9YS5tdWwoZSkudW1vZCh0aGlzLm4pLGw9YS5tdWwoaSkudW1vZCh0aGlzLm4pO3JldHVybiB0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2s/IShzPXRoaXMuZy5qbXVsQWRkKHUsci5nZXRQdWJsaWMoKSxsKSkuaXNJbmZpbml0eSgpJiZzLmVxWFRvUChpKTohKHM9dGhpcy5nLm11bEFkZCh1LHIuZ2V0UHVibGljKCksbCkpLmlzSW5maW5pdHkoKSYmMD09PXMuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAoaSl9LGEucHJvdG90eXBlLnJlY292ZXJQdWJLZXk9ZnVuY3Rpb24oZSx0LHIsbil7ZCgoMyZyKT09PXIsXCJUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzXCIpLHQ9bmV3IGcodCxuKTt2YXIgaT10aGlzLm4sbz1uZXcgeShlKSxzPXQucixhPXQucyx1PTEmcixsPXI+PjE7aWYoMDw9cy5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkmJmwpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlXCIpO3M9bD90aGlzLmN1cnZlLnBvaW50RnJvbVgocy5hZGQodGhpcy5jdXJ2ZS5uKSx1KTp0aGlzLmN1cnZlLnBvaW50RnJvbVgocyx1KTt2YXIgaD10LnIuaW52bShpKSxmPWkuc3ViKG8pLm11bChoKS51bW9kKGkpLGM9YS5tdWwoaCkudW1vZChpKTtyZXR1cm4gdGhpcy5nLm11bEFkZChmLHMsYyl9LGEucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW09ZnVuY3Rpb24oZSx0LHIsbil7aWYobnVsbCE9PSh0PW5ldyBnKHQsbikpLnJlY292ZXJ5UGFyYW0pcmV0dXJuIHQucmVjb3ZlcnlQYXJhbTtmb3IodmFyIGksbz0wO288NDtvKyspe3RyeXtpPXRoaXMucmVjb3ZlclB1YktleShlLHQsbyl9Y2F0Y2goZSl7Y29udGludWV9aWYoaS5lcShyKSlyZXR1cm4gb310aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3JcIil9fSx7XCIuLi9jdXJ2ZXNcIjoxOCxcIi4uL3V0aWxzXCI6MjQsXCIuL2tleVwiOjIwLFwiLi9zaWduYXR1cmVcIjoyMSxcImJuLmpzXCI6OSxicm9yYW5kOjEwLFwiaG1hYy1kcmJnXCI6Mzh9XSwyMDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCJibi5qc1wiKSxpPWUoXCIuLi91dGlsc1wiKS5hc3NlcnQ7ZnVuY3Rpb24gbyhlLHQpe3RoaXMuZWM9ZSx0aGlzLnByaXY9bnVsbCx0aGlzLnB1Yj1udWxsLHQucHJpdiYmdGhpcy5faW1wb3J0UHJpdmF0ZSh0LnByaXYsdC5wcml2RW5jKSx0LnB1YiYmdGhpcy5faW1wb3J0UHVibGljKHQucHViLHQucHViRW5jKX0odC5leHBvcnRzPW8pLmZyb21QdWJsaWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0IGluc3RhbmNlb2Ygbz90Om5ldyBvKGUse3B1Yjp0LHB1YkVuYzpyfSl9LG8uZnJvbVByaXZhdGU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0IGluc3RhbmNlb2Ygbz90Om5ldyBvKGUse3ByaXY6dCxwcml2RW5jOnJ9KX0sby5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFB1YmxpYygpO3JldHVybiBlLmlzSW5maW5pdHkoKT97cmVzdWx0OiExLHJlYXNvbjpcIkludmFsaWQgcHVibGljIGtleVwifTplLnZhbGlkYXRlKCk/ZS5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCk/e3Jlc3VsdDohMCxyZWFzb246bnVsbH06e3Jlc3VsdDohMSxyZWFzb246XCJQdWJsaWMga2V5ICogTiAhPSBPXCJ9OntyZXN1bHQ6ITEscmVhc29uOlwiUHVibGljIGtleSBpcyBub3QgYSBwb2ludFwifX0sby5wcm90b3R5cGUuZ2V0UHVibGljPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJih0PWUsZT1udWxsKSx0aGlzLnB1Ynx8KHRoaXMucHViPXRoaXMuZWMuZy5tdWwodGhpcy5wcml2KSksdD90aGlzLnB1Yi5lbmNvZGUodCxlKTp0aGlzLnB1Yn0sby5wcm90b3R5cGUuZ2V0UHJpdmF0ZT1mdW5jdGlvbihlKXtyZXR1cm5cImhleFwiPT09ZT90aGlzLnByaXYudG9TdHJpbmcoMTYsMik6dGhpcy5wcml2fSxvLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZT1mdW5jdGlvbihlLHQpe3RoaXMucHJpdj1uZXcgbihlLHR8fDE2KSx0aGlzLnByaXY9dGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKX0sby5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYz1mdW5jdGlvbihlLHQpe2lmKGUueHx8ZS55KXJldHVyblwibW9udFwiPT09dGhpcy5lYy5jdXJ2ZS50eXBlP2koZS54LFwiTmVlZCB4IGNvb3JkaW5hdGVcIik6XCJzaG9ydFwiIT09dGhpcy5lYy5jdXJ2ZS50eXBlJiZcImVkd2FyZHNcIiE9PXRoaXMuZWMuY3VydmUudHlwZXx8aShlLngmJmUueSxcIk5lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGVcIiksdm9pZCh0aGlzLnB1Yj10aGlzLmVjLmN1cnZlLnBvaW50KGUueCxlLnkpKTt0aGlzLnB1Yj10aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGUsdCl9LG8ucHJvdG90eXBlLmRlcml2ZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5tdWwodGhpcy5wcml2KS5nZXRYKCl9LG8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmVjLnNpZ24oZSx0aGlzLHQscil9LG8ucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVjLnZlcmlmeShlLHQsdGhpcyl9LG8ucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIjxLZXkgcHJpdjogXCIrKHRoaXMucHJpdiYmdGhpcy5wcml2LnRvU3RyaW5nKDE2LDIpKStcIiBwdWI6IFwiKyh0aGlzLnB1YiYmdGhpcy5wdWIuaW5zcGVjdCgpKStcIiA+XCJ9fSx7XCIuLi91dGlsc1wiOjI0LFwiYm4uanNcIjo5fV0sMjE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdT1lKFwiYm4uanNcIiksbD1lKFwiLi4vdXRpbHNcIiksbj1sLmFzc2VydDtmdW5jdGlvbiBpKGUsdCl7aWYoZSBpbnN0YW5jZW9mIGkpcmV0dXJuIGU7dGhpcy5faW1wb3J0REVSKGUsdCl8fChuKGUuciYmZS5zLFwiU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzXCIpLHRoaXMucj1uZXcgdShlLnIsMTYpLHRoaXMucz1uZXcgdShlLnMsMTYpLHZvaWQgMD09PWUucmVjb3ZlcnlQYXJhbT90aGlzLnJlY292ZXJ5UGFyYW09bnVsbDp0aGlzLnJlY292ZXJ5UGFyYW09ZS5yZWNvdmVyeVBhcmFtKX1mdW5jdGlvbiBoKCl7dGhpcy5wbGFjZT0wfWZ1bmN0aW9uIGYoZSx0KXt2YXIgcj1lW3QucGxhY2UrK107aWYoISgxMjgmcikpcmV0dXJuIHI7dmFyIG49MTUmcjtpZigwPT1ufHw0PG4pcmV0dXJuITE7Zm9yKHZhciBpPTAsbz0wLHM9dC5wbGFjZTtvPG47bysrLHMrKylpPDw9OCxpfD1lW3NdLGk+Pj49MDtyZXR1cm4hKGk8PTEyNykmJih0LnBsYWNlPXMsaSl9ZnVuY3Rpb24gcyhlKXtmb3IodmFyIHQ9MCxyPWUubGVuZ3RoLTE7IWVbdF0mJiEoMTI4JmVbdCsxXSkmJnQ8cjspdCsrO3JldHVybiAwPT09dD9lOmUuc2xpY2UodCl9ZnVuY3Rpb24gYShlLHQpe2lmKHQ8MTI4KWUucHVzaCh0KTtlbHNle3ZhciByPTErKE1hdGgubG9nKHQpL01hdGguTE4yPj4+Myk7Zm9yKGUucHVzaCgxMjh8cik7LS1yOyllLnB1c2godD4+PihyPDwzKSYyNTUpO2UucHVzaCh0KX19KHQuZXhwb3J0cz1pKS5wcm90b3R5cGUuX2ltcG9ydERFUj1mdW5jdGlvbihlLHQpe2U9bC50b0FycmF5KGUsdCk7dmFyIHI9bmV3IGg7aWYoNDghPT1lW3IucGxhY2UrK10pcmV0dXJuITE7dmFyIG49ZihlLHIpO2lmKCExPT09bilyZXR1cm4hMTtpZihuK3IucGxhY2UhPT1lLmxlbmd0aClyZXR1cm4hMTtpZigyIT09ZVtyLnBsYWNlKytdKXJldHVybiExO3ZhciBpPWYoZSxyKTtpZighMT09PWkpcmV0dXJuITE7dmFyIG89ZS5zbGljZShyLnBsYWNlLGkrci5wbGFjZSk7aWYoci5wbGFjZSs9aSwyIT09ZVtyLnBsYWNlKytdKXJldHVybiExO3ZhciBzPWYoZSxyKTtpZighMT09PXMpcmV0dXJuITE7aWYoZS5sZW5ndGghPT1zK3IucGxhY2UpcmV0dXJuITE7dmFyIGE9ZS5zbGljZShyLnBsYWNlLHMrci5wbGFjZSk7aWYoMD09PW9bMF0pe2lmKCEoMTI4Jm9bMV0pKXJldHVybiExO289by5zbGljZSgxKX1pZigwPT09YVswXSl7aWYoISgxMjgmYVsxXSkpcmV0dXJuITE7YT1hLnNsaWNlKDEpfXJldHVybiB0aGlzLnI9bmV3IHUobyksdGhpcy5zPW5ldyB1KGEpLCEodGhpcy5yZWNvdmVyeVBhcmFtPW51bGwpfSxpLnByb3RvdHlwZS50b0RFUj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnIudG9BcnJheSgpLHI9dGhpcy5zLnRvQXJyYXkoKTtmb3IoMTI4JnRbMF0mJih0PVswXS5jb25jYXQodCkpLDEyOCZyWzBdJiYocj1bMF0uY29uY2F0KHIpKSx0PXModCkscj1zKHIpOyEoclswXXx8MTI4JnJbMV0pOylyPXIuc2xpY2UoMSk7dmFyIG49WzJdO2Eobix0Lmxlbmd0aCksKG49bi5jb25jYXQodCkpLnB1c2goMiksYShuLHIubGVuZ3RoKTt2YXIgaT1uLmNvbmNhdChyKSxvPVs0OF07cmV0dXJuIGEobyxpLmxlbmd0aCksbz1vLmNvbmNhdChpKSxsLmVuY29kZShvLGUpfX0se1wiLi4vdXRpbHNcIjoyNCxcImJuLmpzXCI6OX1dLDIyOltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwyMzpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz12b2lkIDB9LHt9XSwyNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIsaT1lKFwiYm4uanNcIiksbz1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxzPWUoXCJtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzXCIpO24uYXNzZXJ0PW8sbi50b0FycmF5PXMudG9BcnJheSxuLnplcm8yPXMuemVybzIsbi50b0hleD1zLnRvSGV4LG4uZW5jb2RlPXMuZW5jb2RlLG4uZ2V0TkFGPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgQXJyYXkoTWF0aC5tYXgoZS5iaXRMZW5ndGgoKSxyKSsxKTtuLmZpbGwoMCk7Zm9yKHZhciBpPTE8PHQrMSxvPWUuY2xvbmUoKSxzPTA7czxuLmxlbmd0aDtzKyspe3ZhciBhLHU9by5hbmRsbihpLTEpO28uaXNPZGQoKT8oYT0oaT4+MSktMTx1PyhpPj4xKS11OnUsby5pc3VibihhKSk6YT0wLG5bc109YSxvLml1c2hybigxKX1yZXR1cm4gbn0sbi5nZXRKU0Y9ZnVuY3Rpb24oZSx0KXt2YXIgcj1bW10sW11dO2U9ZS5jbG9uZSgpLHQ9dC5jbG9uZSgpO2Zvcih2YXIgbj0wLGk9MDswPGUuY21wbigtbil8fDA8dC5jbXBuKC1pKTspe3ZhciBvLHMsYSx1PWUuYW5kbG4oMykrbiYzLGw9dC5hbmRsbigzKStpJjM7Mz09PXUmJih1PS0xKSwzPT09bCYmKGw9LTEpLG89MD09KDEmdSk/MDozIT09KHM9ZS5hbmRsbig3KStuJjcpJiY1IT09c3x8MiE9PWw/dTotdSxyWzBdLnB1c2gobyksYT0wPT0oMSZsKT8wOjMhPT0ocz10LmFuZGxuKDcpK2kmNykmJjUhPT1zfHwyIT09dT9sOi1sLHJbMV0ucHVzaChhKSwyKm49PT1vKzEmJihuPTEtbiksMippPT09YSsxJiYoaT0xLWkpLGUuaXVzaHJuKDEpLHQuaXVzaHJuKDEpfXJldHVybiByfSxuLmNhY2hlZFByb3BlcnR5PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1cIl9cIit0O2UucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXNbbl0/dGhpc1tuXTp0aGlzW25dPXIuY2FsbCh0aGlzKX19LG4ucGFyc2VCeXRlcz1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9uLnRvQXJyYXkoZSxcImhleFwiKTplfSxuLmludEZyb21MRT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGkoZSxcImhleFwiLFwibGVcIil9fSx7XCJibi5qc1wiOjksXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDEsXCJtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzXCI6NDJ9XSwyNTpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz17dmVyc2lvbjpcIjYuNS4zXCJ9fSx7fV0sMjY6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1yO24udXRpbHM9ZShcIi4vaGFzaC91dGlsc1wiKSxuLmNvbW1vbj1lKFwiLi9oYXNoL2NvbW1vblwiKSxuLnNoYT1lKFwiLi9oYXNoL3NoYVwiKSxuLnJpcGVtZD1lKFwiLi9oYXNoL3JpcGVtZFwiKSxuLmhtYWM9ZShcIi4vaGFzaC9obWFjXCIpLG4uc2hhMT1uLnNoYS5zaGExLG4uc2hhMjU2PW4uc2hhLnNoYTI1NixuLnNoYTIyND1uLnNoYS5zaGEyMjQsbi5zaGEzODQ9bi5zaGEuc2hhMzg0LG4uc2hhNTEyPW4uc2hhLnNoYTUxMixuLnJpcGVtZDE2MD1uLnJpcGVtZC5yaXBlbWQxNjB9LHtcIi4vaGFzaC9jb21tb25cIjoyNyxcIi4vaGFzaC9obWFjXCI6MjgsXCIuL2hhc2gvcmlwZW1kXCI6MjksXCIuL2hhc2gvc2hhXCI6MzAsXCIuL2hhc2gvdXRpbHNcIjozN31dLDI3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4vdXRpbHNcIiksbj1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKTtmdW5jdGlvbiBvKCl7dGhpcy5wZW5kaW5nPW51bGwsdGhpcy5wZW5kaW5nVG90YWw9MCx0aGlzLmJsb2NrU2l6ZT10aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZSx0aGlzLm91dFNpemU9dGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplLHRoaXMuaG1hY1N0cmVuZ3RoPXRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoLHRoaXMucGFkTGVuZ3RoPXRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoLzgsdGhpcy5lbmRpYW49XCJiaWdcIix0aGlzLl9kZWx0YTg9dGhpcy5ibG9ja1NpemUvOCx0aGlzLl9kZWx0YTMyPXRoaXMuYmxvY2tTaXplLzMyfShyLkJsb2NrSGFzaD1vKS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGUsdCl7aWYoZT1pLnRvQXJyYXkoZSx0KSx0aGlzLnBlbmRpbmc/dGhpcy5wZW5kaW5nPXRoaXMucGVuZGluZy5jb25jYXQoZSk6dGhpcy5wZW5kaW5nPWUsdGhpcy5wZW5kaW5nVG90YWwrPWUubGVuZ3RoLHRoaXMucGVuZGluZy5sZW5ndGg+PXRoaXMuX2RlbHRhOCl7dmFyIHI9KGU9dGhpcy5wZW5kaW5nKS5sZW5ndGgldGhpcy5fZGVsdGE4O3RoaXMucGVuZGluZz1lLnNsaWNlKGUubGVuZ3RoLXIsZS5sZW5ndGgpLDA9PT10aGlzLnBlbmRpbmcubGVuZ3RoJiYodGhpcy5wZW5kaW5nPW51bGwpLGU9aS5qb2luMzIoZSwwLGUubGVuZ3RoLXIsdGhpcy5lbmRpYW4pO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9dGhpcy5fZGVsdGEzMil0aGlzLl91cGRhdGUoZSxuLG4rdGhpcy5fZGVsdGEzMil9cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLmRpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpLG4obnVsbD09PXRoaXMucGVuZGluZyksdGhpcy5fZGlnZXN0KGUpfSxvLnByb3RvdHlwZS5fcGFkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wZW5kaW5nVG90YWwsdD10aGlzLl9kZWx0YTgscj10LShlK3RoaXMucGFkTGVuZ3RoKSV0LG49bmV3IEFycmF5KHIrdGhpcy5wYWRMZW5ndGgpO25bMF09MTI4O2Zvcih2YXIgaT0xO2k8cjtpKyspbltpXT0wO2lmKGU8PD0zLFwiYmlnXCI9PT10aGlzLmVuZGlhbil7Zm9yKHZhciBvPTg7bzx0aGlzLnBhZExlbmd0aDtvKyspbltpKytdPTA7bltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPWU+Pj4yNCYyNTUsbltpKytdPWU+Pj4xNiYyNTUsbltpKytdPWU+Pj44JjI1NSxuW2krK109MjU1JmV9ZWxzZSBmb3IobltpKytdPTI1NSZlLG5baSsrXT1lPj4+OCYyNTUsbltpKytdPWU+Pj4xNiYyNTUsbltpKytdPWU+Pj4yNCYyNTUsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbz04O288dGhpcy5wYWRMZW5ndGg7bysrKW5baSsrXT0wO3JldHVybiBufX0se1wiLi91dGlsc1wiOjM3LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxfV0sMjg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi91dGlsc1wiKSxpPWUoXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCIpO2Z1bmN0aW9uIG8oZSx0LHIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyhlLHQscik7dGhpcy5IYXNoPWUsdGhpcy5ibG9ja1NpemU9ZS5ibG9ja1NpemUvOCx0aGlzLm91dFNpemU9ZS5vdXRTaXplLzgsdGhpcy5pbm5lcj1udWxsLHRoaXMub3V0ZXI9bnVsbCx0aGlzLl9pbml0KG4udG9BcnJheSh0LHIpKX0odC5leHBvcnRzPW8pLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbihlKXtlLmxlbmd0aD50aGlzLmJsb2NrU2l6ZSYmKGU9KG5ldyB0aGlzLkhhc2gpLnVwZGF0ZShlKS5kaWdlc3QoKSksaShlLmxlbmd0aDw9dGhpcy5ibG9ja1NpemUpO2Zvcih2YXIgdD1lLmxlbmd0aDt0PHRoaXMuYmxvY2tTaXplO3QrKyllLnB1c2goMCk7Zm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdXj01NDtmb3IodGhpcy5pbm5lcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGUpLHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdXj0xMDY7dGhpcy5vdXRlcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGUpfSxvLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5pbm5lci51cGRhdGUoZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpLHRoaXMub3V0ZXIuZGlnZXN0KGUpfX0se1wiLi91dGlsc1wiOjM3LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxfV0sMjk6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi91dGlsc1wiKSxpPWUoXCIuL2NvbW1vblwiKSx5PW4ucm90bDMyLG09bi5zdW0zMixnPW4uc3VtMzJfMyxiPW4uc3VtMzJfNCxvPWkuQmxvY2tIYXNoO2Z1bmN0aW9uIHMoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHM7by5jYWxsKHRoaXMpLHRoaXMuaD1bMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdLHRoaXMuZW5kaWFuPVwibGl0dGxlXCJ9ZnVuY3Rpb24gdyhlLHQscixuKXtyZXR1cm4gZTw9MTU/dF5yXm46ZTw9MzE/dCZyfH50Jm46ZTw9NDc/KHR8fnIpXm46ZTw9NjM/dCZufHImfm46dF4ocnx+bil9bi5pbmhlcml0cyhzLG8pLChyLnJpcGVtZDE2MD1zKS5ibG9ja1NpemU9NTEyLHMub3V0U2l6ZT0xNjAscy5obWFjU3RyZW5ndGg9MTkyLHMucGFkTGVuZ3RoPTY0LHMucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsbixpPWY9dGhpcy5oWzBdLG89dj10aGlzLmhbMV0scz1wPXRoaXMuaFsyXSxhPWQ9dGhpcy5oWzNdLHU9Yz10aGlzLmhbNF0sbD0wO2w8ODA7bCsrKXZhciBoPW0oeShiKGYsdyhsLHYscCxkKSxlW19bbF0rdF0sKG49bCk8PTE1PzA6bjw9MzE/MTUxODUwMDI0OTpuPD00Nz8xODU5Nzc1MzkzOm48PTYzPzI0MDA5NTk3MDg6Mjg0MDg1MzgzOCksQVtsXSksYyksZj1jLGM9ZCxkPXkocCwxMCkscD12LHY9aCxoPW0oeShiKGksdyg3OS1sLG8scyxhKSxlW01bbF0rdF0sKHI9bCk8PTE1PzEzNTI4Mjk5MjY6cjw9MzE/MTU0ODYwMzY4NDpyPD00Nz8xODM2MDcyNjkxOnI8PTYzPzIwNTM5OTQyMTc6MCksRVtsXSksdSksaT11LHU9YSxhPXkocywxMCkscz1vLG89aDtoPWcodGhpcy5oWzFdLHAsYSksdGhpcy5oWzFdPWcodGhpcy5oWzJdLGQsdSksdGhpcy5oWzJdPWcodGhpcy5oWzNdLGMsaSksdGhpcy5oWzNdPWcodGhpcy5oWzRdLGYsbyksdGhpcy5oWzRdPWcodGhpcy5oWzBdLHYscyksdGhpcy5oWzBdPWh9LHMucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuXCJoZXhcIj09PWU/bi50b0hleDMyKHRoaXMuaCxcImxpdHRsZVwiKTpuLnNwbGl0MzIodGhpcy5oLFwibGl0dGxlXCIpfTt2YXIgXz1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSw3LDQsMTMsMSwxMCw2LDE1LDMsMTIsMCw5LDUsMiwxNCwxMSw4LDMsMTAsMTQsNCw5LDE1LDgsMSwyLDcsMCw2LDEzLDExLDUsMTIsMSw5LDExLDEwLDAsOCwxMiw0LDEzLDMsNywxNSwxNCw1LDYsMiw0LDAsNSw5LDcsMTIsMiwxMCwxNCwxLDMsOCwxMSw2LDE1LDEzXSxNPVs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdLEE9WzExLDE0LDE1LDEyLDUsOCw3LDksMTEsMTMsMTQsMTUsNiw3LDksOCw3LDYsOCwxMywxMSw5LDcsMTUsNywxMiwxNSw5LDExLDcsMTMsMTIsMTEsMTMsNiw3LDE0LDksMTMsMTUsMTQsOCwxMyw2LDUsMTIsNyw1LDExLDEyLDE0LDE1LDE0LDE1LDksOCw5LDE0LDUsNiw4LDYsNSwxMiw5LDE1LDUsMTEsNiw4LDEzLDEyLDUsMTIsMTMsMTQsMTEsOCw1LDZdLEU9WzgsOSw5LDExLDEzLDE1LDE1LDUsNyw3LDgsMTEsMTQsMTQsMTIsNiw5LDEzLDE1LDcsMTIsOCw5LDExLDcsNywxMiw3LDYsMTUsMTMsMTEsOSw3LDE1LDExLDgsNiw2LDE0LDEyLDEzLDUsMTQsMTMsMTMsNyw1LDE1LDUsOCwxMSwxNCwxNCw2LDE0LDYsOSwxMiw5LDEyLDUsMTUsOCw4LDUsMTIsOSwxMiw1LDE0LDYsOCwxMyw2LDUsMTUsMTMsMTEsMTFdfSx7XCIuL2NvbW1vblwiOjI3LFwiLi91dGlsc1wiOjM3fV0sMzA6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnNoYTE9ZShcIi4vc2hhLzFcIiksci5zaGEyMjQ9ZShcIi4vc2hhLzIyNFwiKSxyLnNoYTI1Nj1lKFwiLi9zaGEvMjU2XCIpLHIuc2hhMzg0PWUoXCIuL3NoYS8zODRcIiksci5zaGE1MTI9ZShcIi4vc2hhLzUxMlwiKX0se1wiLi9zaGEvMVwiOjMxLFwiLi9zaGEvMjI0XCI6MzIsXCIuL3NoYS8yNTZcIjozMyxcIi4vc2hhLzM4NFwiOjM0LFwiLi9zaGEvNTEyXCI6MzV9XSwzMTpbZnVuY3Rpb24oZSx0LHIpe2FyZ3VtZW50c1s0XVsxNF1bMF0uYXBwbHkocixhcmd1bWVudHMpfSx7ZHVwOjE0fV0sMzI6W2Z1bmN0aW9uKGUsdCxyKXthcmd1bWVudHNbNF1bMTRdWzBdLmFwcGx5KHIsYXJndW1lbnRzKX0se2R1cDoxNH1dLDMzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZShcIi4uL3V0aWxzXCIpLGk9ZShcIi4uL2NvbW1vblwiKSxvPWUoXCIuL2NvbW1vblwiKSxwPWUoXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCIpLHY9bi5zdW0zMix5PW4uc3VtMzJfNCxtPW4uc3VtMzJfNSxnPW8uY2gzMixiPW8ubWFqMzIsdz1vLnMwXzI1NixfPW8uczFfMjU2LE09by5nMF8yNTYsQT1vLmcxXzI1NixzPWkuQmxvY2tIYXNoLGE9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF07ZnVuY3Rpb24gdSgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHUpKXJldHVybiBuZXcgdTtzLmNhbGwodGhpcyksdGhpcy5oPVsxNzc5MDMzNzAzLDMxNDQxMzQyNzcsMTAxMzkwNDI0MiwyNzczNDgwNzYyLDEzNTk4OTMxMTksMjYwMDgyMjkyNCw1Mjg3MzQ2MzUsMTU0MTQ1OTIyNV0sdGhpcy5rPWEsdGhpcy5XPW5ldyBBcnJheSg2NCl9bi5pbmhlcml0cyh1LHMpLCh0LmV4cG9ydHM9dSkuYmxvY2tTaXplPTUxMix1Lm91dFNpemU9MjU2LHUuaG1hY1N0cmVuZ3RoPTE5Mix1LnBhZExlbmd0aD02NCx1LnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPXRoaXMuVyxuPTA7bjwxNjtuKyspcltuXT1lW3Qrbl07Zm9yKDtuPHIubGVuZ3RoO24rKylyW25dPXkoQShyW24tMl0pLHJbbi03XSxNKHJbbi0xNV0pLHJbbi0xNl0pO3ZhciBpPXRoaXMuaFswXSxvPXRoaXMuaFsxXSxzPXRoaXMuaFsyXSxhPXRoaXMuaFszXSx1PXRoaXMuaFs0XSxsPXRoaXMuaFs1XSxoPXRoaXMuaFs2XSxmPXRoaXMuaFs3XTtmb3IocCh0aGlzLmsubGVuZ3RoPT09ci5sZW5ndGgpLG49MDtuPHIubGVuZ3RoO24rKyl2YXIgYz1tKGYsXyh1KSxnKHUsbCxoKSx0aGlzLmtbbl0scltuXSksZD12KHcoaSksYihpLG8scykpLGY9aCxoPWwsbD11LHU9dihhLGMpLGE9cyxzPW8sbz1pLGk9dihjLGQpO3RoaXMuaFswXT12KHRoaXMuaFswXSxpKSx0aGlzLmhbMV09dih0aGlzLmhbMV0sbyksdGhpcy5oWzJdPXYodGhpcy5oWzJdLHMpLHRoaXMuaFszXT12KHRoaXMuaFszXSxhKSx0aGlzLmhbNF09dih0aGlzLmhbNF0sdSksdGhpcy5oWzVdPXYodGhpcy5oWzVdLGwpLHRoaXMuaFs2XT12KHRoaXMuaFs2XSxoKSx0aGlzLmhbN109dih0aGlzLmhbN10sZil9LHUucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuXCJoZXhcIj09PWU/bi50b0hleDMyKHRoaXMuaCxcImJpZ1wiKTpuLnNwbGl0MzIodGhpcy5oLFwiYmlnXCIpfX0se1wiLi4vY29tbW9uXCI6MjcsXCIuLi91dGlsc1wiOjM3LFwiLi9jb21tb25cIjozNixcIm1pbmltYWxpc3RpYy1hc3NlcnRcIjo0MX1dLDM0OltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwzNTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKSxpPWUoXCIuLi9jb21tb25cIiksQz1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxMPW4ucm90cjY0X2hpLEI9bi5yb3RyNjRfbG8sYz1uLnNocjY0X2hpLGQ9bi5zaHI2NF9sbyxEPW4uc3VtNjQsVT1uLnN1bTY0X2hpLEY9bi5zdW02NF9sbyxwPW4uc3VtNjRfNF9oaSx2PW4uc3VtNjRfNF9sbyxqPW4uc3VtNjRfNV9oaSxHPW4uc3VtNjRfNV9sbyxvPWkuQmxvY2tIYXNoLHM9WzExMTYzNTI0MDgsMzYwOTc2NzQ1OCwxODk5NDQ3NDQxLDYwMjg5MTcyNSwzMDQ5MzIzNDcxLDM5NjQ0ODQzOTksMzkyMTAwOTU3MywyMTczMjk1NTQ4LDk2MTk4NzE2Myw0MDgxNjI4NDcyLDE1MDg5NzA5OTMsMzA1MzgzNDI2NSwyNDUzNjM1NzQ4LDI5Mzc2NzE1NzksMjg3MDc2MzIyMSwzNjY0NjA5NTYwLDM2MjQzODEwODAsMjczNDg4MzM5NCwzMTA1OTg0MDEsMTE2NDk5NjU0Miw2MDcyMjUyNzgsMTMyMzYxMDc2NCwxNDI2ODgxOTg3LDM1OTAzMDQ5OTQsMTkyNTA3ODM4OCw0MDY4MTgyMzgzLDIxNjIwNzgyMDYsOTkxMzM2MTEzLDI2MTQ4ODgxMDMsNjMzODAzMzE3LDMyNDgyMjI1ODAsMzQ3OTc3NDg2OCwzODM1MzkwNDAxLDI2NjY2MTM0NTgsNDAyMjIyNDc3NCw5NDQ3MTExMzksMjY0MzQ3MDc4LDIzNDEyNjI3NzMsNjA0ODA3NjI4LDIwMDc4MDA5MzMsNzcwMjU1OTgzLDE0OTU5OTA5MDEsMTI0OTE1MDEyMiwxODU2NDMxMjM1LDE1NTUwODE2OTIsMzE3NTIxODEzMiwxOTk2MDY0OTg2LDIxOTg5NTA4MzcsMjU1NDIyMDg4MiwzOTk5NzE5MzM5LDI4MjE4MzQzNDksNzY2Nzg0MDE2LDI5NTI5OTY4MDgsMjU2NjU5NDg3OSwzMjEwMzEzNjcxLDMyMDMzMzc5NTYsMzMzNjU3MTg5MSwxMDM0NDU3MDI2LDM1ODQ1Mjg3MTEsMjQ2Njk0ODkwMSwxMTM5MjY5OTMsMzc1ODMyNjM4MywzMzgyNDE4OTUsMTY4NzE3OTM2LDY2NjMwNzIwNSwxMTg4MTc5OTY0LDc3MzUyOTkxMiwxNTQ2MDQ1NzM0LDEyOTQ3NTczNzIsMTUyMjgwNTQ4NSwxMzk2MTgyMjkxLDI2NDM4MzM4MjMsMTY5NTE4MzcwMCwyMzQzNTI3MzkwLDE5ODY2NjEwNTEsMTAxNDQ3NzQ4MCwyMTc3MDI2MzUwLDEyMDY3NTkxNDIsMjQ1Njk1NjAzNywzNDQwNzc2MjcsMjczMDQ4NTkyMSwxMjkwODYzNDYwLDI4MjAzMDI0MTEsMzE1ODQ1NDI3MywzMjU5NzMwODAwLDM1MDU5NTI2NTcsMzM0NTc2NDc3MSwxMDYyMTcwMDgsMzUxNjA2NTgxNywzNjA2MDA4MzQ0LDM2MDAzNTI4MDQsMTQzMjcyNTc3Niw0MDk0NTcxOTA5LDE0NjcwMzE1OTQsMjc1NDIzMzQ0LDg1MTE2OTcyMCw0MzAyMjc3MzQsMzEwMDgyMzc1Miw1MDY5NDg2MTYsMTM2MzI1ODE5NSw2NTkwNjA1NTYsMzc1MDY4NTU5Myw4ODM5OTc4NzcsMzc4NTA1MDI4MCw5NTgxMzk1NzEsMzMxODMwNzQyNywxMzIyODIyMjE4LDM4MTI3MjM0MDMsMTUzNzAwMjA2MywyMDAzMDM0OTk1LDE3NDc4NzM3NzksMzYwMjAzNjg5OSwxOTU1NTYyMjIyLDE1NzU5OTAwMTIsMjAyNDEwNDgxNSwxMTI1NTkyOTI4LDIyMjc3MzA0NTIsMjcxNjkwNDMwNiwyMzYxODUyNDI0LDQ0Mjc3NjA0NCwyNDI4NDM2NDc0LDU5MzY5ODM0NCwyNzU2NzM0MTg3LDM3MzMxMTAyNDksMzIwNDAzMTQ3OSwyOTk5MzUxNTczLDMzMjkzMjUyOTgsMzgxNTkyMDQyNywzMzkxNTY5NjE0LDM5MjgzODM5MDAsMzUxNTI2NzI3MSw1NjYyODA3MTEsMzk0MDE4NzYwNiwzNDU0MDY5NTM0LDQxMTg2MzAyNzEsNDAwMDIzOTk5MiwxMTY0MTg0NzQsMTkxNDEzODU1NCwxNzQyOTI0MjEsMjczMTA1NTI3MCwyODkzODAzNTYsMzIwMzk5MzAwNiw0NjAzOTMyNjksMzIwNjIwMzE1LDY4NTQ3MTczMyw1ODc0OTY4MzYsODUyMTQyOTcxLDEwODY3OTI4NTEsMTAxNzAzNjI5OCwzNjU1NDMxMDAsMTEyNjAwMDU4MCwyNjE4Mjk3Njc2LDEyODgwMzM0NzAsMzQwOTg1NTE1OCwxNTAxNTA1OTQ4LDQyMzQ1MDk4NjYsMTYwNzE2NzkxNSw5ODcxNjc0NjgsMTgxNjQwMjMxNiwxMjQ2MTg5NTkxXTtmdW5jdGlvbiBhKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYSkpcmV0dXJuIG5ldyBhO28uY2FsbCh0aGlzKSx0aGlzLmg9WzE3NzkwMzM3MDMsNDA4OTIzNTcyMCwzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUsMTAxMzkwNDI0Miw0MjcxMTc1NzIzLDI3NzM0ODA3NjIsMTU5NTc1MDEyOSwxMzU5ODkzMTE5LDI5MTc1NjUxMzcsMjYwMDgyMjkyNCw3MjU1MTExOTksNTI4NzM0NjM1LDQyMTUzODk1NDcsMTU0MTQ1OTIyNSwzMjcwMzMyMDldLHRoaXMuaz1zLHRoaXMuVz1uZXcgQXJyYXkoMTYwKX1uLmluaGVyaXRzKGEsbyksKHQuZXhwb3J0cz1hKS5ibG9ja1NpemU9MTAyNCxhLm91dFNpemU9NTEyLGEuaG1hY1N0cmVuZ3RoPTE5MixhLnBhZExlbmd0aD0xMjgsYS5wcm90b3R5cGUuX3ByZXBhcmVCbG9jaz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLlcsbj0wO248MzI7bisrKXJbbl09ZVt0K25dO2Zvcig7bjxyLmxlbmd0aDtuKz0yKXt2YXIgaT1mdW5jdGlvbihlLHQpe3ZhciByPUwoZSx0LDE5KSxuPUwodCxlLDI5KSxpPWMoZSx0LDYpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KHJbbi00XSxyW24tM10pLG89ZnVuY3Rpb24oZSx0KXt2YXIgcj1CKGUsdCwxOSksbj1CKHQsZSwyOSksaT1kKGUsdCw2KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShyW24tNF0scltuLTNdKSxzPXJbbi0xNF0sYT1yW24tMTNdLHU9ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwxKSxuPUwoZSx0LDgpLGk9YyhlLHQsNyksbz1yXm5eaTtvPDAmJihvKz00Mjk0OTY3Mjk2KTtyZXR1cm4gb30ocltuLTMwXSxyW24tMjldKSxsPWZ1bmN0aW9uKGUsdCl7dmFyIHI9QihlLHQsMSksbj1CKGUsdCw4KSxpPWQoZSx0LDcpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KHJbbi0zMF0scltuLTI5XSksaD1yW24tMzJdLGY9cltuLTMxXTtyW25dPXAoaSxvLHMsYSx1LGwsaCxmKSxyW24rMV09dihpLG8scyxhLHUsbCxoLGYpfX0sYS5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbihlLHQpe3RoaXMuX3ByZXBhcmVCbG9jayhlLHQpO3ZhciByPXRoaXMuVyxuPXRoaXMuaFswXSxpPXRoaXMuaFsxXSxvPXRoaXMuaFsyXSxzPXRoaXMuaFszXSxhPXRoaXMuaFs0XSx1PXRoaXMuaFs1XSxsPXRoaXMuaFs2XSxoPXRoaXMuaFs3XSxmPXRoaXMuaFs4XSxjPXRoaXMuaFs5XSxkPXRoaXMuaFsxMF0scD10aGlzLmhbMTFdLHY9dGhpcy5oWzEyXSx5PXRoaXMuaFsxM10sbT10aGlzLmhbMTRdLGc9dGhpcy5oWzE1XTtDKHRoaXMuay5sZW5ndGg9PT1yLmxlbmd0aCk7Zm9yKHZhciBiPTA7YjxyLmxlbmd0aDtiKz0yKXZhciB3PW0sXz1nLE09ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwxNCksbj1MKGUsdCwxOCksaT1MKHQsZSw5KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShmLGMpLEE9ZnVuY3Rpb24oZSx0KXt2YXIgcj1CKGUsdCwxNCksbj1CKGUsdCwxOCksaT1CKHQsZSw5KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShmLGMpLEU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUmdF5+ZSZyO248MCYmKG4rPTQyOTQ5NjcyOTYpO3JldHVybiBufShmLGQsdiksUz1mdW5jdGlvbihlLHQscil7dmFyIG49ZSZ0Xn5lJnI7bjwwJiYobis9NDI5NDk2NzI5Nik7cmV0dXJuIG59KGMscCx5KSxrPXRoaXMua1tiXSxOPXRoaXMua1tiKzFdLHg9cltiXSxQPXJbYisxXSxJPWoodyxfLE0sQSxFLFMsayxOLHgsUCksVD1HKHcsXyxNLEEsRSxTLGssTix4LFApLHc9ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwyOCksbj1MKHQsZSwyKSxpPUwodCxlLDcpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KG4saSksXz1mdW5jdGlvbihlLHQpe3ZhciByPUIoZSx0LDI4KSxuPUIodCxlLDIpLGk9Qih0LGUsNyksbz1yXm5eaTtvPDAmJihvKz00Mjk0OTY3Mjk2KTtyZXR1cm4gb30obixpKSxNPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1lJnReZSZyXnQmcjtuPDAmJihuKz00Mjk0OTY3Mjk2KTtyZXR1cm4gbn0obixvLGEpLEE9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUmdF5lJnJedCZyO248MCYmKG4rPTQyOTQ5NjcyOTYpO3JldHVybiBufShpLHMsdSksUj1VKHcsXyxNLEEpLE89Rih3LF8sTSxBKSxtPXYsZz15LHY9ZCx5PXAsZD1mLHA9YyxmPVUobCxoLEksVCksYz1GKGgsaCxJLFQpLGw9YSxoPXUsYT1vLHU9cyxvPW4scz1pLG49VShJLFQsUixPKSxpPUYoSSxULFIsTyk7RCh0aGlzLmgsMCxuLGkpLEQodGhpcy5oLDIsbyxzKSxEKHRoaXMuaCw0LGEsdSksRCh0aGlzLmgsNixsLGgpLEQodGhpcy5oLDgsZixjKSxEKHRoaXMuaCwxMCxkLHApLEQodGhpcy5oLDEyLHYseSksRCh0aGlzLmgsMTQsbSxnKX0sYS5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm5cImhleFwiPT09ZT9uLnRvSGV4MzIodGhpcy5oLFwiYmlnXCIpOm4uc3BsaXQzMih0aGlzLmgsXCJiaWdcIil9fSx7XCIuLi9jb21tb25cIjoyNyxcIi4uL3V0aWxzXCI6MzcsXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDF9XSwzNjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKS5yb3RyMzI7ZnVuY3Rpb24gaShlLHQscil7cmV0dXJuIGUmdF5+ZSZyfWZ1bmN0aW9uIG8oZSx0LHIpe3JldHVybiBlJnReZSZyXnQmcn1mdW5jdGlvbiBzKGUsdCxyKXtyZXR1cm4gZV50XnJ9ci5mdF8xPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiAwPT09ZT9pKHQscixuKToxPT09ZXx8Mz09PWU/dF5yXm46Mj09PWU/byh0LHIsbik6dm9pZCAwfSxyLmNoMzI9aSxyLm1hajMyPW8sci5wMzI9cyxyLnMwXzI1Nj1mdW5jdGlvbihlKXtyZXR1cm4gbihlLDIpXm4oZSwxMylebihlLDIyKX0sci5zMV8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSw2KV5uKGUsMTEpXm4oZSwyNSl9LHIuZzBfMjU2PWZ1bmN0aW9uKGUpe3JldHVybiBuKGUsNylebihlLDE4KV5lPj4+M30sci5nMV8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSwxNylebihlLDE5KV5lPj4+MTB9fSx7XCIuLi91dGlsc1wiOjM3fV0sMzc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbD1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxuPWUoXCJpbmhlcml0c1wiKTtmdW5jdGlvbiBvKGUpe3JldHVybihlPj4+MjR8ZT4+PjgmNjUyODB8ZTw8OCYxNjcxMTY4MHwoMjU1JmUpPDwyNCk+Pj4wfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIDE9PT1lLmxlbmd0aD9cIjBcIitlOmV9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gNz09PWUubGVuZ3RoP1wiMFwiK2U6Nj09PWUubGVuZ3RoP1wiMDBcIitlOjU9PT1lLmxlbmd0aD9cIjAwMFwiK2U6ND09PWUubGVuZ3RoP1wiMDAwMFwiK2U6Mz09PWUubGVuZ3RoP1wiMDAwMDBcIitlOjI9PT1lLmxlbmd0aD9cIjAwMDAwMFwiK2U6MT09PWUubGVuZ3RoP1wiMDAwMDAwMFwiK2U6ZX1yLmluaGVyaXRzPW4sci50b0FycmF5PWZ1bmN0aW9uKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5zbGljZSgpO2lmKCFlKXJldHVybltdO3ZhciByPVtdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKWlmKHQpe2lmKFwiaGV4XCI9PT10KWZvcigoZT1lLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksXCJcIikpLmxlbmd0aCUyIT0wJiYoZT1cIjBcIitlKSxuPTA7bjxlLmxlbmd0aDtuKz0yKXIucHVzaChwYXJzZUludChlW25dK2VbbisxXSwxNikpfWVsc2UgZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWUuY2hhckNvZGVBdChuKSxvPWk+Pjgscz0yNTUmaTtvP3IucHVzaChvLHMpOnIucHVzaChzKX1lbHNlIGZvcihuPTA7bjxlLmxlbmd0aDtuKyspcltuXT0wfGVbbl07cmV0dXJuIHJ9LHIudG9IZXg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXQrPWkoZVtyXS50b1N0cmluZygxNikpO3JldHVybiB0fSxyLmh0b25sPW8sci50b0hleDMyPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVwiXCIsbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dO1wibGl0dGxlXCI9PT10JiYoaT1vKGkpKSxyKz1zKGkudG9TdHJpbmcoMTYpKX1yZXR1cm4gcn0sci56ZXJvMj1pLHIuemVybzg9cyxyLmpvaW4zMj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT1yLXQ7bChpJTQ9PTApO2Zvcih2YXIgbz1uZXcgQXJyYXkoaS80KSxzPTAsYT10O3M8by5sZW5ndGg7cysrLGErPTQpe3ZhciB1PVwiYmlnXCI9PT1uP2VbYV08PDI0fGVbYSsxXTw8MTZ8ZVthKzJdPDw4fGVbYSszXTplW2ErM108PDI0fGVbYSsyXTw8MTZ8ZVthKzFdPDw4fGVbYV07b1tzXT11Pj4+MH1yZXR1cm4gb30sci5zcGxpdDMyPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPW5ldyBBcnJheSg0KmUubGVuZ3RoKSxuPTAsaT0wO248ZS5sZW5ndGg7bisrLGkrPTQpe3ZhciBvPWVbbl07XCJiaWdcIj09PXQ/KHJbaV09bz4+PjI0LHJbaSsxXT1vPj4+MTYmMjU1LHJbaSsyXT1vPj4+OCYyNTUscltpKzNdPTI1NSZvKToocltpKzNdPW8+Pj4yNCxyW2krMl09bz4+PjE2JjI1NSxyW2krMV09bz4+PjgmMjU1LHJbaV09MjU1Jm8pfXJldHVybiByfSxyLnJvdHIzMj1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+dHxlPDwzMi10fSxyLnJvdGwzMj1mdW5jdGlvbihlLHQpe3JldHVybiBlPDx0fGU+Pj4zMi10fSxyLnN1bTMyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdD4+PjB9LHIuc3VtMzJfMz1mdW5jdGlvbihlLHQscil7cmV0dXJuIGUrdCtyPj4+MH0sci5zdW0zMl80PWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBlK3QrcituPj4+MH0sci5zdW0zMl81PWZ1bmN0aW9uKGUsdCxyLG4saSl7cmV0dXJuIGUrdCtyK24raT4+PjB9LHIuc3VtNjQ9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9ZVt0XSxvPW4rZVt0KzFdPj4+MCxzPShvPG4/MTowKStyK2k7ZVt0XT1zPj4+MCxlW3QrMV09b30sci5zdW02NF9oaT1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4odCtuPj4+MDx0PzE6MCkrZStyPj4+MH0sci5zdW02NF9sbz1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gdCtuPj4+MH0sci5zdW02NF80X2hpPWZ1bmN0aW9uKGUsdCxyLG4saSxvLHMsYSl7dmFyIHU9MCxsPXQ7cmV0dXJuIHUrPShsPWwrbj4+PjApPHQ/MTowLHUrPShsPWwrbz4+PjApPG8/MTowLGUrcitpK3MrKHUrPShsPWwrYT4+PjApPGE/MTowKT4+PjB9LHIuc3VtNjRfNF9sbz1mdW5jdGlvbihlLHQscixuLGksbyxzLGEpe3JldHVybiB0K24rbythPj4+MH0sci5zdW02NF81X2hpPWZ1bmN0aW9uKGUsdCxyLG4saSxvLHMsYSx1LGwpe3ZhciBoPTAsZj10O3JldHVybiBoKz0oZj1mK24+Pj4wKTx0PzE6MCxoKz0oZj1mK28+Pj4wKTxvPzE6MCxoKz0oZj1mK2E+Pj4wKTxhPzE6MCxlK3IraStzK3UrKGgrPShmPWYrbD4+PjApPGw/MTowKT4+PjB9LHIuc3VtNjRfNV9sbz1mdW5jdGlvbihlLHQscixuLGksbyxzLGEsdSxsKXtyZXR1cm4gdCtuK28rYStsPj4+MH0sci5yb3RyNjRfaGk9ZnVuY3Rpb24oZSx0LHIpe3JldHVybih0PDwzMi1yfGU+Pj5yKT4+PjB9LHIucm90cjY0X2xvPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4oZTw8MzItcnx0Pj4+cik+Pj4wfSxyLnNocjY0X2hpPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT4+PnJ9LHIuc2hyNjRfbG89ZnVuY3Rpb24oZSx0LHIpe3JldHVybihlPDwzMi1yfHQ+Pj5yKT4+PjB9fSx7aW5oZXJpdHM6MzksXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDF9XSwzODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCJoYXNoLmpzXCIpLHM9ZShcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIiksaT1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKTtmdW5jdGlvbiBvKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyhlKTt0aGlzLmhhc2g9ZS5oYXNoLHRoaXMucHJlZFJlc2lzdD0hIWUucHJlZFJlc2lzdCx0aGlzLm91dExlbj10aGlzLmhhc2gub3V0U2l6ZSx0aGlzLm1pbkVudHJvcHk9ZS5taW5FbnRyb3B5fHx0aGlzLmhhc2guaG1hY1N0cmVuZ3RoLHRoaXMuX3Jlc2VlZD1udWxsLHRoaXMucmVzZWVkSW50ZXJ2YWw9bnVsbCx0aGlzLks9bnVsbCx0aGlzLlY9bnVsbDt2YXIgdD1zLnRvQXJyYXkoZS5lbnRyb3B5LGUuZW50cm9weUVuY3x8XCJoZXhcIikscj1zLnRvQXJyYXkoZS5ub25jZSxlLm5vbmNlRW5jfHxcImhleFwiKSxuPXMudG9BcnJheShlLnBlcnMsZS5wZXJzRW5jfHxcImhleFwiKTtpKHQubGVuZ3RoPj10aGlzLm1pbkVudHJvcHkvOCxcIk5vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogXCIrdGhpcy5taW5FbnRyb3B5K1wiIGJpdHNcIiksdGhpcy5faW5pdCh0LHIsbil9KHQuZXhwb3J0cz1vKS5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuY29uY2F0KHQpLmNvbmNhdChyKTt0aGlzLks9bmV3IEFycmF5KHRoaXMub3V0TGVuLzgpLHRoaXMuVj1uZXcgQXJyYXkodGhpcy5vdXRMZW4vOCk7Zm9yKHZhciBpPTA7aTx0aGlzLlYubGVuZ3RoO2krKyl0aGlzLktbaV09MCx0aGlzLlZbaV09MTt0aGlzLl91cGRhdGUobiksdGhpcy5fcmVzZWVkPTEsdGhpcy5yZXNlZWRJbnRlcnZhbD0yODE0NzQ5NzY3MTA2NTZ9LG8ucHJvdG90eXBlLl9obWFjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuLmhtYWModGhpcy5oYXNoLHRoaXMuSyl9LG8ucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMF0pO2UmJih0PXQudXBkYXRlKGUpKSx0aGlzLks9dC5kaWdlc3QoKSx0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpLGUmJih0aGlzLks9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMV0pLnVwZGF0ZShlKS5kaWdlc3QoKSx0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpKX0sby5wcm90b3R5cGUucmVzZWVkPWZ1bmN0aW9uKGUsdCxyLG4pe1wic3RyaW5nXCIhPXR5cGVvZiB0JiYobj1yLHI9dCx0PW51bGwpLGU9cy50b0FycmF5KGUsdCkscj1zLnRvQXJyYXkocixuKSxpKGUubGVuZ3RoPj10aGlzLm1pbkVudHJvcHkvOCxcIk5vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogXCIrdGhpcy5taW5FbnRyb3B5K1wiIGJpdHNcIiksdGhpcy5fdXBkYXRlKGUuY29uY2F0KHJ8fFtdKSksdGhpcy5fcmVzZWVkPTF9LG8ucHJvdG90eXBlLmdlbmVyYXRlPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKHRoaXMuX3Jlc2VlZD50aGlzLnJlc2VlZEludGVydmFsKXRocm93IG5ldyBFcnJvcihcIlJlc2VlZCBpcyByZXF1aXJlZFwiKTtcInN0cmluZ1wiIT10eXBlb2YgdCYmKG49cixyPXQsdD1udWxsKSxyJiYocj1zLnRvQXJyYXkocixufHxcImhleFwiKSx0aGlzLl91cGRhdGUocikpO2Zvcih2YXIgaT1bXTtpLmxlbmd0aDxlOyl0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpLGk9aS5jb25jYXQodGhpcy5WKTt2YXIgbz1pLnNsaWNlKDAsZSk7cmV0dXJuIHRoaXMuX3VwZGF0ZShyKSx0aGlzLl9yZXNlZWQrKyxzLmVuY29kZShvLHQpfX0se1wiaGFzaC5qc1wiOjI2LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxLFwibWluaW1hbGlzdGljLWNyeXB0by11dGlsc1wiOjQyfV0sMzk6W2Z1bmN0aW9uKGUsdCxyKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuY3JlYXRlP3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3QmJihlLnN1cGVyXz10LGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pKX06dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI7dCYmKGUuc3VwZXJfPXQsKHI9ZnVuY3Rpb24oKXt9KS5wcm90b3R5cGU9dC5wcm90b3R5cGUsZS5wcm90b3R5cGU9bmV3IHIsZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSl9fSx7fV0sNDA6W2Z1bmN0aW9uKGUsXyx0KXsoZnVuY3Rpb24oYix3KXshZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fTshZS5KU19TSEEzX05PX05PREVfSlMmJlwib2JqZWN0XCI9PXR5cGVvZiBiJiZiLnZlcnNpb25zJiZiLnZlcnNpb25zLm5vZGUmJihlPXcpO2Zvcih2YXIgdD0hZS5KU19TSEEzX05PX0NPTU1PTl9KUyYmXCJvYmplY3RcIj09dHlwZW9mIF8mJl8uZXhwb3J0cyx1PVwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpLGg9WzAsOCwxNiwyNF0saGU9WzEsMCwzMjg5OCwwLDMyOTA2LDIxNDc0ODM2NDgsMjE0NzUxNjQxNiwyMTQ3NDgzNjQ4LDMyOTA3LDAsMjE0NzQ4MzY0OSwwLDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjc3NywyMTQ3NDgzNjQ4LDEzOCwwLDEzNiwwLDIxNDc1MTY0MjUsMCwyMTQ3NDgzNjU4LDAsMjE0NzUxNjU1NSwwLDEzOSwyMTQ3NDgzNjQ4LDMyOTA1LDIxNDc0ODM2NDgsMzI3NzEsMjE0NzQ4MzY0OCwzMjc3MCwyMTQ3NDgzNjQ4LDEyOCwyMTQ3NDgzNjQ4LDMyNzc4LDAsMjE0NzQ4MzY1OCwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjg5NiwyMTQ3NDgzNjQ4LDIxNDc0ODM2NDksMCwyMTQ3NTE2NDI0LDIxNDc0ODM2NDhdLHI9WzIyNCwyNTYsMzg0LDUxMl0sbz1bXCJoZXhcIixcImJ1ZmZlclwiLFwiYXJyYXlCdWZmZXJcIixcImFycmF5XCJdLHM9ZnVuY3Rpb24odCxyLG4pe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbmV3IG0odCxyLHQpLnVwZGF0ZShlKVtuXSgpfX0sYT1mdW5jdGlvbihyLG4saSl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBtKHIsbix0KS51cGRhdGUoZSlbaV0oKX19LG49ZnVuY3Rpb24oZSx0KXt2YXIgcj1zKGUsdCxcImhleFwiKTtyLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgbShlLHQsZSl9LHIudXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiByLmNyZWF0ZSgpLnVwZGF0ZShlKX07Zm9yKHZhciBuPTA7bjxvLmxlbmd0aDsrK24pe3ZhciBpPW9bbl07cltpXT1zKGUsdCxpKX1yZXR1cm4gcn0saT1be25hbWU6XCJrZWNjYWtcIixwYWRkaW5nOlsxLDI1Niw2NTUzNiwxNjc3NzIxNl0sYml0czpyLGNyZWF0ZU1ldGhvZDpufSx7bmFtZTpcInNoYTNcIixwYWRkaW5nOls2LDE1MzYsMzkzMjE2LDEwMDY2MzI5Nl0sYml0czpyLGNyZWF0ZU1ldGhvZDpufSx7bmFtZTpcInNoYWtlXCIscGFkZGluZzpbMzEsNzkzNiwyMDMxNjE2LDUyMDA5MzY5Nl0sYml0czpbMTI4LDI1Nl0sY3JlYXRlTWV0aG9kOmZ1bmN0aW9uKHQscil7dmFyIG49YSh0LHIsXCJoZXhcIik7bi5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHQscixlKX0sbi51cGRhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jcmVhdGUodCkudXBkYXRlKGUpfTtmb3IodmFyIGU9MDtlPG8ubGVuZ3RoOysrZSl7dmFyIGk9b1tlXTtuW2ldPWEodCxyLGkpfXJldHVybiBufX1dLGw9e30sZj1bXSxjPTA7YzxpLmxlbmd0aDsrK2MpZm9yKHZhciBkPWlbY10scD1kLmJpdHMsdj0wO3Y8cC5sZW5ndGg7Kyt2KXt2YXIgeT1kLm5hbWUrXCJfXCIrcFt2XTtmLnB1c2goeSksbFt5XT1kLmNyZWF0ZU1ldGhvZChwW3ZdLGQucGFkZGluZyl9ZnVuY3Rpb24gbShlLHQscil7dGhpcy5ibG9ja3M9W10sdGhpcy5zPVtdLHRoaXMucGFkZGluZz10LHRoaXMub3V0cHV0Qml0cz1yLHRoaXMucmVzZXQ9ITAsdGhpcy5ibG9jaz0wLHRoaXMuc3RhcnQ9MCx0aGlzLmJsb2NrQ291bnQ9MTYwMC0oZTw8MSk+PjUsdGhpcy5ieXRlQ291bnQ9dGhpcy5ibG9ja0NvdW50PDwyLHRoaXMub3V0cHV0QmxvY2tzPXI+PjUsdGhpcy5leHRyYUJ5dGVzPSgzMSZyKT4+Mztmb3IodmFyIG49MDtuPDUwOysrbil0aGlzLnNbbl09MH1tLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJzdHJpbmdcIiE9dHlwZW9mIGU7dCYmZS5jb25zdHJ1Y3Rvcj09PUFycmF5QnVmZmVyJiYoZT1uZXcgVWludDhBcnJheShlKSk7Zm9yKHZhciByLG4saT1lLmxlbmd0aCxvPXRoaXMuYmxvY2tzLHM9dGhpcy5ieXRlQ291bnQsYT10aGlzLmJsb2NrQ291bnQsdT0wLGw9dGhpcy5zO3U8aTspe2lmKHRoaXMucmVzZXQpZm9yKHRoaXMucmVzZXQ9ITEsb1swXT10aGlzLmJsb2NrLHI9MTtyPGErMTsrK3Ipb1tyXT0wO2lmKHQpZm9yKHI9dGhpcy5zdGFydDt1PGkmJnI8czsrK3Upb1tyPj4yXXw9ZVt1XTw8aFszJnIrK107ZWxzZSBmb3Iocj10aGlzLnN0YXJ0O3U8aSYmcjxzOysrdSkobj1lLmNoYXJDb2RlQXQodSkpPDEyOD9vW3I+PjJdfD1uPDxoWzMmcisrXToobjwyMDQ4P29bcj4+Ml18PSgxOTJ8bj4+Nik8PGhbMyZyKytdOihuPDU1Mjk2fHw1NzM0NDw9bj9vW3I+PjJdfD0oMjI0fG4+PjEyKTw8aFszJnIrK106KG49NjU1MzYrKCgxMDIzJm4pPDwxMHwxMDIzJmUuY2hhckNvZGVBdCgrK3UpKSxvW3I+PjJdfD0oMjQwfG4+PjE4KTw8aFszJnIrK10sb1tyPj4yXXw9KDEyOHxuPj4xMiY2Myk8PGhbMyZyKytdKSxvW3I+PjJdfD0oMTI4fG4+PjYmNjMpPDxoWzMmcisrXSksb1tyPj4yXXw9KDEyOHw2MyZuKTw8aFszJnIrK10pO2lmKHM8PSh0aGlzLmxhc3RCeXRlSW5kZXg9cikpe2Zvcih0aGlzLnN0YXJ0PXItcyx0aGlzLmJsb2NrPW9bYV0scj0wO3I8YTsrK3IpbFtyXV49b1tyXTtnKGwpLHRoaXMucmVzZXQ9ITB9ZWxzZSB0aGlzLnN0YXJ0PXJ9cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLmZpbmFsaXplPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ibG9ja3MsdD10aGlzLmxhc3RCeXRlSW5kZXgscj10aGlzLmJsb2NrQ291bnQsbj10aGlzLnM7aWYoZVt0Pj4yXXw9dGhpcy5wYWRkaW5nWzMmdF0sdGhpcy5sYXN0Qnl0ZUluZGV4PT09dGhpcy5ieXRlQ291bnQpZm9yKGVbMF09ZVtyXSx0PTE7dDxyKzE7Kyt0KWVbdF09MDtmb3IoZVtyLTFdfD0yMTQ3NDgzNjQ4LHQ9MDt0PHI7Kyt0KW5bdF1ePWVbdF07ZyhuKX0sbS5wcm90b3R5cGUudG9TdHJpbmc9bS5wcm90b3R5cGUuaGV4PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0PXRoaXMuYmxvY2tDb3VudCxyPXRoaXMucyxuPXRoaXMub3V0cHV0QmxvY2tzLGk9dGhpcy5leHRyYUJ5dGVzLG89MCxzPTAsYT1cIlwiO3M8bjspe2ZvcihvPTA7bzx0JiZzPG47KytvLCsrcyllPXJbb10sYSs9dVtlPj40JjE1XSt1WzE1JmVdK3VbZT4+MTImMTVdK3VbZT4+OCYxNV0rdVtlPj4yMCYxNV0rdVtlPj4xNiYxNV0rdVtlPj4yOCYxNV0rdVtlPj4yNCYxNV07cyV0PT0wJiYoZyhyKSxvPTApfXJldHVybiBpJiYoZT1yW29dLDA8aSYmKGErPXVbZT4+NCYxNV0rdVsxNSZlXSksMTxpJiYoYSs9dVtlPj4xMiYxNV0rdVtlPj44JjE1XSksMjxpJiYoYSs9dVtlPj4yMCYxNV0rdVtlPj4xNiYxNV0pKSxhfSxtLnByb3RvdHlwZS5idWZmZXI9bS5wcm90b3R5cGUuYXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXt0aGlzLmZpbmFsaXplKCk7Zm9yKHZhciBlPXRoaXMuYmxvY2tDb3VudCx0PXRoaXMucyxyPXRoaXMub3V0cHV0QmxvY2tzLG49dGhpcy5leHRyYUJ5dGVzLGk9MCxvPTAscz10aGlzLm91dHB1dEJpdHM+PjMsYT1uP25ldyBBcnJheUJ1ZmZlcihyKzE8PDIpOm5ldyBBcnJheUJ1ZmZlcihzKSx1PW5ldyBVaW50MzJBcnJheShhKTtvPHI7KXtmb3IoaT0wO2k8ZSYmbzxyOysraSwrK28pdVtvXT10W2ldO28lZT09MCYmZyh0KX1yZXR1cm4gbiYmKHVbaV09dFtpXSxhPWEuc2xpY2UoMCxzKSksYX0sbS5wcm90b3R5cGUuZGlnZXN0PW0ucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0LHI9dGhpcy5ibG9ja0NvdW50LG49dGhpcy5zLGk9dGhpcy5vdXRwdXRCbG9ja3Msbz10aGlzLmV4dHJhQnl0ZXMscz0wLGE9MCx1PVtdO2E8aTspe2ZvcihzPTA7czxyJiZhPGk7KytzLCsrYSllPWE8PDIsdD1uW3NdLHVbZV09MjU1JnQsdVtlKzFdPXQ+PjgmMjU1LHVbZSsyXT10Pj4xNiYyNTUsdVtlKzNdPXQ+PjI0JjI1NTthJXI9PTAmJmcobil9cmV0dXJuIG8mJihlPWE8PDIsdD1uW3NdLDA8byYmKHVbZV09MjU1JnQpLDE8byYmKHVbZSsxXT10Pj44JjI1NSksMjxvJiYodVtlKzJdPXQ+PjE2JjI1NSkpLHV9O3ZhciBnPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG4saSxvLHMsYSx1LGwsaCxmLGMsZCxwLHYseSxtLGcsYix3LF8sTSxBLEUsUyxrLE4seCxQLEksVCxSLE8sQyxMLEIsRCxVLEYsaixHLEgseixWLEsscSxXLFosSixYLCQsUSxZLGVlLHRlLHJlLG5lLGllLG9lLHNlLGFlLHVlLGxlPTA7bGU8NDg7bGUrPTIpbj1lWzBdXmVbMTBdXmVbMjBdXmVbMzBdXmVbNDBdLGk9ZVsxXV5lWzExXV5lWzIxXV5lWzMxXV5lWzQxXSxvPWVbMl1eZVsxMl1eZVsyMl1eZVszMl1eZVs0Ml0scz1lWzNdXmVbMTNdXmVbMjNdXmVbMzNdXmVbNDNdLGE9ZVs0XV5lWzE0XV5lWzI0XV5lWzM0XV5lWzQ0XSx1PWVbNV1eZVsxNV1eZVsyNV1eZVszNV1eZVs0NV0sbD1lWzZdXmVbMTZdXmVbMjZdXmVbMzZdXmVbNDZdLGg9ZVs3XV5lWzE3XV5lWzI3XV5lWzM3XV5lWzQ3XSx0PShmPWVbOF1eZVsxOF1eZVsyOF1eZVszOF1eZVs0OF0pXihvPDwxfHM+Pj4zMSkscj0oYz1lWzldXmVbMTldXmVbMjldXmVbMzldXmVbNDldKV4oczw8MXxvPj4+MzEpLGVbMF1ePXQsZVsxXV49cixlWzEwXV49dCxlWzExXV49cixlWzIwXV49dCxlWzIxXV49cixlWzMwXV49dCxlWzMxXV49cixlWzQwXV49dCxlWzQxXV49cix0PW5eKGE8PDF8dT4+PjMxKSxyPWleKHU8PDF8YT4+PjMxKSxlWzJdXj10LGVbM11ePXIsZVsxMl1ePXQsZVsxM11ePXIsZVsyMl1ePXQsZVsyM11ePXIsZVszMl1ePXQsZVszM11ePXIsZVs0Ml1ePXQsZVs0M11ePXIsdD1vXihsPDwxfGg+Pj4zMSkscj1zXihoPDwxfGw+Pj4zMSksZVs0XV49dCxlWzVdXj1yLGVbMTRdXj10LGVbMTVdXj1yLGVbMjRdXj10LGVbMjVdXj1yLGVbMzRdXj10LGVbMzVdXj1yLGVbNDRdXj10LGVbNDVdXj1yLHQ9YV4oZjw8MXxjPj4+MzEpLHI9dV4oYzw8MXxmPj4+MzEpLGVbNl1ePXQsZVs3XV49cixlWzE2XV49dCxlWzE3XV49cixlWzI2XV49dCxlWzI3XV49cixlWzM2XV49dCxlWzM3XV49cixlWzQ2XV49dCxlWzQ3XV49cix0PWxeKG48PDF8aT4+PjMxKSxyPWheKGk8PDF8bj4+PjMxKSxlWzhdXj10LGVbOV1ePXIsZVsxOF1ePXQsZVsxOV1ePXIsZVsyOF1ePXQsZVsyOV1ePXIsZVszOF1ePXQsZVszOV1ePXIsZVs0OF1ePXQsZVs0OV1ePXIsZD1lWzBdLHA9ZVsxXSxLPWVbMTFdPDw0fGVbMTBdPj4+MjgscT1lWzEwXTw8NHxlWzExXT4+PjI4LE49ZVsyMF08PDN8ZVsyMV0+Pj4yOSx4PWVbMjFdPDwzfGVbMjBdPj4+Mjksb2U9ZVszMV08PDl8ZVszMF0+Pj4yMyxzZT1lWzMwXTw8OXxlWzMxXT4+PjIzLEc9ZVs0MF08PDE4fGVbNDFdPj4+MTQsSD1lWzQxXTw8MTh8ZVs0MF0+Pj4xNCxPPWVbMl08PDF8ZVszXT4+PjMxLEM9ZVszXTw8MXxlWzJdPj4+MzEsdj1lWzEzXTw8MTJ8ZVsxMl0+Pj4yMCx5PWVbMTJdPDwxMnxlWzEzXT4+PjIwLFc9ZVsyMl08PDEwfGVbMjNdPj4+MjIsWj1lWzIzXTw8MTB8ZVsyMl0+Pj4yMixQPWVbMzNdPDwxM3xlWzMyXT4+PjE5LEk9ZVszMl08PDEzfGVbMzNdPj4+MTksYWU9ZVs0Ml08PDJ8ZVs0M10+Pj4zMCx1ZT1lWzQzXTw8MnxlWzQyXT4+PjMwLFk9ZVs1XTw8MzB8ZVs0XT4+PjIsZWU9ZVs0XTw8MzB8ZVs1XT4+PjIsTD1lWzE0XTw8NnxlWzE1XT4+PjI2LEI9ZVsxNV08PDZ8ZVsxNF0+Pj4yNixtPWVbMjVdPDwxMXxlWzI0XT4+PjIxLGc9ZVsyNF08PDExfGVbMjVdPj4+MjEsSj1lWzM0XTw8MTV8ZVszNV0+Pj4xNyxYPWVbMzVdPDwxNXxlWzM0XT4+PjE3LFQ9ZVs0NV08PDI5fGVbNDRdPj4+MyxSPWVbNDRdPDwyOXxlWzQ1XT4+PjMsQT1lWzZdPDwyOHxlWzddPj4+NCxFPWVbN108PDI4fGVbNl0+Pj40LHRlPWVbMTddPDwyM3xlWzE2XT4+PjkscmU9ZVsxNl08PDIzfGVbMTddPj4+OSxEPWVbMjZdPDwyNXxlWzI3XT4+PjcsVT1lWzI3XTw8MjV8ZVsyNl0+Pj43LGI9ZVszNl08PDIxfGVbMzddPj4+MTEsdz1lWzM3XTw8MjF8ZVszNl0+Pj4xMSwkPWVbNDddPDwyNHxlWzQ2XT4+PjgsUT1lWzQ2XTw8MjR8ZVs0N10+Pj44LHo9ZVs4XTw8Mjd8ZVs5XT4+PjUsVj1lWzldPDwyN3xlWzhdPj4+NSxTPWVbMThdPDwyMHxlWzE5XT4+PjEyLGs9ZVsxOV08PDIwfGVbMThdPj4+MTIsbmU9ZVsyOV08PDd8ZVsyOF0+Pj4yNSxpZT1lWzI4XTw8N3xlWzI5XT4+PjI1LEY9ZVszOF08PDh8ZVszOV0+Pj4yNCxqPWVbMzldPDw4fGVbMzhdPj4+MjQsXz1lWzQ4XTw8MTR8ZVs0OV0+Pj4xOCxNPWVbNDldPDwxNHxlWzQ4XT4+PjE4LGVbMF09ZF5+diZtLGVbMV09cF5+eSZnLGVbMTBdPUFeflMmTixlWzExXT1FXn5rJngsZVsyMF09T15+TCZELGVbMjFdPUNefkImVSxlWzMwXT16Xn5LJlcsZVszMV09Vl5+cSZaLGVbNDBdPVlefnRlJm5lLGVbNDFdPWVlXn5yZSZpZSxlWzJdPXZefm0mYixlWzNdPXlefmcmdyxlWzEyXT1TXn5OJlAsZVsxM109a15+eCZJLGVbMjJdPUxefkQmRixlWzIzXT1CXn5VJmosZVszMl09S15+VyZKLGVbMzNdPXFeflomWCxlWzQyXT10ZV5+bmUmb2UsZVs0M109cmVefmllJnNlLGVbNF09bV5+YiZfLGVbNV09Z15+dyZNLGVbMTRdPU5eflAmVCxlWzE1XT14Xn5JJlIsZVsyNF09RF5+RiZHLGVbMjVdPVVefmomSCxlWzM0XT1XXn5KJiQsZVszNV09Wl5+WCZRLGVbNDRdPW5lXn5vZSZhZSxlWzQ1XT1pZV5+c2UmdWUsZVs2XT1iXn5fJmQsZVs3XT13Xn5NJnAsZVsxNl09UF5+VCZBLGVbMTddPUleflImRSxlWzI2XT1GXn5HJk8sZVsyN109al5+SCZDLGVbMzZdPUpefiQmeixlWzM3XT1YXn5RJlYsZVs0Nl09b2VefmFlJlksZVs0N109c2VefnVlJmVlLGVbOF09X15+ZCZ2LGVbOV09TV5+cCZ5LGVbMThdPVRefkEmUyxlWzE5XT1SXn5FJmssZVsyOF09R15+TyZMLGVbMjldPUhefkMmQixlWzM4XT0kXn56JkssZVszOV09UV5+ViZxLGVbNDhdPWFlXn5ZJnRlLGVbNDldPXVlXn5lZSZyZSxlWzBdXj1oZVtsZV0sZVsxXV49aGVbbGUrMV19O2lmKHQpXy5leHBvcnRzPWw7ZWxzZSBmb3IoYz0wO2M8Zi5sZW5ndGg7KytjKWVbZltjXV09bFtmW2NdXX0oKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtfcHJvY2Vzczo0M31dLDQxOltmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbihlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcih0fHxcIkFzc2VydGlvbiBmYWlsZWRcIil9KHQuZXhwb3J0cz1uKS5lcXVhbD1mdW5jdGlvbihlLHQscil7aWYoZSE9dCl0aHJvdyBuZXcgRXJyb3Iocnx8XCJBc3NlcnRpb24gZmFpbGVkOiBcIitlK1wiICE9IFwiK3QpfX0se31dLDQyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cjtmdW5jdGlvbiBpKGUpe3JldHVybiAxPT09ZS5sZW5ndGg/XCIwXCIrZTplfWZ1bmN0aW9uIG8oZSl7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXQrPWkoZVtyXS50b1N0cmluZygxNikpO3JldHVybiB0fW4udG9BcnJheT1mdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUuc2xpY2UoKTtpZighZSlyZXR1cm5bXTt2YXIgcj1bXTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspcltuXT0wfGVbbl07cmV0dXJuIHJ9aWYoXCJoZXhcIj09PXQpeyhlPWUucmVwbGFjZSgvW15hLXowLTldKy9naSxcIlwiKSkubGVuZ3RoJTIhPTAmJihlPVwiMFwiK2UpO2ZvcihuPTA7bjxlLmxlbmd0aDtuKz0yKXIucHVzaChwYXJzZUludChlW25dK2VbbisxXSwxNikpfWVsc2UgZm9yKG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZS5jaGFyQ29kZUF0KG4pLG89aT4+OCxzPTI1NSZpO28/ci5wdXNoKG8scyk6ci5wdXNoKHMpfXJldHVybiByfSxuLnplcm8yPWksbi50b0hleD1vLG4uZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJoZXhcIj09PXQ/byhlKTplfX0se31dLDQzOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXticm93c2VyOiEwfX0se31dLDQ0OltmdW5jdGlvbihlLHIsbyl7KGZ1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGwoZSl7dmFyIHk9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF0sbT0xNzc5MDMzNzAzLGc9MzE0NDEzNDI3NyxiPTEwMTM5MDQyNDIsdz0yNzczNDgwNzYyLF89MTM1OTg5MzExOSxNPTI2MDA4MjI5MjQsQT01Mjg3MzQ2MzUsRT0xNTQxNDU5MjI1LFM9bmV3IEFycmF5KDY0KTtmdW5jdGlvbiB0KGUpe2Zvcih2YXIgdD0wLHI9ZS5sZW5ndGg7NjQ8PXI7KXtmb3IodmFyIG4saSxvLHMsYT1tLHU9ZyxsPWIsaD13LGY9XyxjPU0sZD1BLHA9RSx2PTA7djwxNjt2KyspaT10KzQqdixTW3ZdPSgyNTUmZVtpXSk8PDI0fCgyNTUmZVtpKzFdKTw8MTZ8KDI1NSZlW2krMl0pPDw4fDI1NSZlW2krM107Zm9yKHY9MTY7djw2NDt2Kyspbz0oKG49U1t2LTJdKT4+PjE3fG48PDE1KV4obj4+PjE5fG48PDEzKV5uPj4+MTAscz0oKG49U1t2LTE1XSk+Pj43fG48PDI1KV4obj4+PjE4fG48PDE0KV5uPj4+MyxTW3ZdPShvK1Nbdi03XXwwKSsocytTW3YtMTZdfDApfDA7Zm9yKHY9MDt2PDY0O3YrKylvPSgoKGY+Pj42fGY8PDI2KV4oZj4+PjExfGY8PDIxKV4oZj4+PjI1fGY8PDcpKSsoZiZjXn5mJmQpfDApKyhwKyh5W3ZdK1Nbdl18MCl8MCl8MCxzPSgoYT4+PjJ8YTw8MzApXihhPj4+MTN8YTw8MTkpXihhPj4+MjJ8YTw8MTApKSsoYSZ1XmEmbF51JmwpfDAscD1kLGQ9YyxjPWYsZj1oK298MCxoPWwsbD11LHU9YSxhPW8rc3wwO209bSthfDAsZz1nK3V8MCxiPWIrbHwwLHc9dytofDAsXz1fK2Z8MCxNPU0rY3wwLEE9QStkfDAsRT1FK3B8MCx0Kz02NCxyLT02NH19dChlKTt2YXIgcixuPWUubGVuZ3RoJTY0LGk9ZS5sZW5ndGgvNTM2ODcwOTEyfDAsbz1lLmxlbmd0aDw8MyxzPW48NTY/NTY6MTIwLGE9ZS5zbGljZShlLmxlbmd0aC1uLGUubGVuZ3RoKTtmb3IoYS5wdXNoKDEyOCkscj0xK247cjxzO3IrKylhLnB1c2goMCk7cmV0dXJuIGEucHVzaChpPj4+MjQmMjU1KSxhLnB1c2goaT4+PjE2JjI1NSksYS5wdXNoKGk+Pj44JjI1NSksYS5wdXNoKGk+Pj4wJjI1NSksYS5wdXNoKG8+Pj4yNCYyNTUpLGEucHVzaChvPj4+MTYmMjU1KSxhLnB1c2gobz4+PjgmMjU1KSxhLnB1c2gobz4+PjAmMjU1KSx0KGEpLFttPj4+MjQmMjU1LG0+Pj4xNiYyNTUsbT4+PjgmMjU1LG0+Pj4wJjI1NSxnPj4+MjQmMjU1LGc+Pj4xNiYyNTUsZz4+PjgmMjU1LGc+Pj4wJjI1NSxiPj4+MjQmMjU1LGI+Pj4xNiYyNTUsYj4+PjgmMjU1LGI+Pj4wJjI1NSx3Pj4+MjQmMjU1LHc+Pj4xNiYyNTUsdz4+PjgmMjU1LHc+Pj4wJjI1NSxfPj4+MjQmMjU1LF8+Pj4xNiYyNTUsXz4+PjgmMjU1LF8+Pj4wJjI1NSxNPj4+MjQmMjU1LE0+Pj4xNiYyNTUsTT4+PjgmMjU1LE0+Pj4wJjI1NSxBPj4+MjQmMjU1LEE+Pj4xNiYyNTUsQT4+PjgmMjU1LEE+Pj4wJjI1NSxFPj4+MjQmMjU1LEU+Pj4xNiYyNTUsRT4+PjgmMjU1LEU+Pj4wJjI1NV19ZnVuY3Rpb24gUChlLHQscil7ZT1lLmxlbmd0aDw9NjQ/ZTpsKGUpO2Zvcih2YXIgbj02NCt0Lmxlbmd0aCs0LGk9bmV3IEFycmF5KG4pLG89bmV3IEFycmF5KDY0KSxzPVtdLGE9MDthPDY0O2ErKylpW2FdPTU0O2ZvcihhPTA7YTxlLmxlbmd0aDthKyspaVthXV49ZVthXTtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKWlbNjQrYV09dFthXTtmb3IoYT1uLTQ7YTxuO2ErKylpW2FdPTA7Zm9yKGE9MDthPDY0O2ErKylvW2FdPTkyO2ZvcihhPTA7YTxlLmxlbmd0aDthKyspb1thXV49ZVthXTtmdW5jdGlvbiB1KCl7Zm9yKHZhciBlPW4tMTtuLTQ8PWU7ZS0tKXtpZihpW2VdKyssaVtlXTw9MjU1KXJldHVybjtpW2VdPTB9fWZvcig7MzI8PXI7KXUoKSxzPXMuY29uY2F0KGwoby5jb25jYXQobChpKSkpKSxyLT0zMjtyZXR1cm4gMDxyJiYodSgpLHM9cy5jb25jYXQobChvLmNvbmNhdChsKGkpKSkuc2xpY2UoMCxyKSkpLHN9ZnVuY3Rpb24gSShlLHQscixuLGkpe3ZhciBvO2ZvcihSKGUsMTYqKDIqci0xKSxpLDAsMTYpLG89MDtvPDIqcjtvKyspVChlLDE2Km8saSwxNiksZnVuY3Rpb24oZSx0KXtSKGUsMCx0LDAsMTYpO2Zvcih2YXIgcj04OzA8cjtyLT0yKXRbNF1ePXModFswXSt0WzEyXSw3KSx0WzhdXj1zKHRbNF0rdFswXSw5KSx0WzEyXV49cyh0WzhdK3RbNF0sMTMpLHRbMF1ePXModFsxMl0rdFs4XSwxOCksdFs5XV49cyh0WzVdK3RbMV0sNyksdFsxM11ePXModFs5XSt0WzVdLDkpLHRbMV1ePXModFsxM10rdFs5XSwxMyksdFs1XV49cyh0WzFdK3RbMTNdLDE4KSx0WzE0XV49cyh0WzEwXSt0WzZdLDcpLHRbMl1ePXModFsxNF0rdFsxMF0sOSksdFs2XV49cyh0WzJdK3RbMTRdLDEzKSx0WzEwXV49cyh0WzZdK3RbMl0sMTgpLHRbM11ePXModFsxNV0rdFsxMV0sNyksdFs3XV49cyh0WzNdK3RbMTVdLDkpLHRbMTFdXj1zKHRbN10rdFszXSwxMyksdFsxNV1ePXModFsxMV0rdFs3XSwxOCksdFsxXV49cyh0WzBdK3RbM10sNyksdFsyXV49cyh0WzFdK3RbMF0sOSksdFszXV49cyh0WzJdK3RbMV0sMTMpLHRbMF1ePXModFszXSt0WzJdLDE4KSx0WzZdXj1zKHRbNV0rdFs0XSw3KSx0WzddXj1zKHRbNl0rdFs1XSw5KSx0WzRdXj1zKHRbN10rdFs2XSwxMyksdFs1XV49cyh0WzRdK3RbN10sMTgpLHRbMTFdXj1zKHRbMTBdK3RbOV0sNyksdFs4XV49cyh0WzExXSt0WzEwXSw5KSx0WzldXj1zKHRbOF0rdFsxMV0sMTMpLHRbMTBdXj1zKHRbOV0rdFs4XSwxOCksdFsxMl1ePXModFsxNV0rdFsxNF0sNyksdFsxM11ePXModFsxMl0rdFsxNV0sOSksdFsxNF1ePXModFsxM10rdFsxMl0sMTMpLHRbMTVdXj1zKHRbMTRdK3RbMTNdLDE4KTtmb3Iocj0wO3I8MTY7KytyKWVbcl0rPXRbcl19KGksbiksUihpLDAsZSx0KzE2Km8sMTYpO2ZvcihvPTA7bzxyO28rKylSKGUsdCsyKm8qMTYsZSwxNipvLDE2KTtmb3Iobz0wO288cjtvKyspUihlLHQrMTYqKDIqbysxKSxlLDE2KihvK3IpLDE2KX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGU8PHR8ZT4+PjMyLXR9ZnVuY3Rpb24gVChlLHQscixuKXtmb3IodmFyIGk9MDtpPG47aSsrKXJbaV1ePWVbdCtpXX1mdW5jdGlvbiBSKGUsdCxyLG4saSl7Zm9yKDtpLS07KXJbbisrXT1lW3QrK119ZnVuY3Rpb24gaShlKXtpZihlJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtpZihcIm51bWJlclwiIT10eXBlb2YgZVt0XSlyZXR1cm47dmFyIHI9cGFyc2VJbnQoZVt0XSk7aWYociE9ZVt0XXx8cjwwfHwyNTY8PXIpcmV0dXJufXJldHVybiAxfX1mdW5jdGlvbiBPKGUsdCl7dmFyIHI9cGFyc2VJbnQoZSk7aWYoZSE9cil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFwiK3QpO3JldHVybiByfWZ1bmN0aW9uIGUobyxlLHMsYSx1LGwsaCl7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjYWxsYmFja1wiKTtpZihzPU8ocyxcIk5cIiksYT1PKGEsXCJyXCIpLHU9Tyh1LFwicFwiKSxsPU8obCxcImRrTGVuXCIpLDA9PT1zfHwwIT0ocyZzLTEpKXRocm93IG5ldyBFcnJvcihcIk4gbXVzdCBiZSBwb3dlciBvZiAyXCIpO2lmKEMvMTI4L2E8cyl0aHJvdyBuZXcgRXJyb3IoXCJOIHRvbyBsYXJnZVwiKTtpZihDLzEyOC91PGEpdGhyb3cgbmV3IEVycm9yKFwiciB0b28gbGFyZ2VcIik7aWYoIWkobykpdGhyb3cgbmV3IEVycm9yKFwicGFzc3dvcmQgbXVzdCBiZSBhbiBhcnJheSBvciBidWZmZXJcIik7aWYobz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvKSwhaShlKSl0aHJvdyBuZXcgRXJyb3IoXCJzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyXCIpO2U9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSk7Zm9yKHZhciBmPVAobyxlLDEyOCp1KmEpLGM9bmV3IFVpbnQzMkFycmF5KDMyKnUqYSksdD0wO3Q8Yy5sZW5ndGg7dCsrKXt2YXIgcj00KnQ7Y1t0XT0oMjU1JmZbMytyXSk8PDI0fCgyNTUmZlsyK3JdKTw8MTZ8KDI1NSZmWzErcl0pPDw4fCgyNTUmZlswK3JdKTw8MH12YXIgZCxwLHY9bmV3IFVpbnQzMkFycmF5KDY0KmEpLHk9bmV3IFVpbnQzMkFycmF5KDMyKmEqcyksbT0zMiphLGc9bmV3IFVpbnQzMkFycmF5KDE2KSxiPW5ldyBVaW50MzJBcnJheSgxNiksdz11KnMqMixfPTAsTT1udWxsLEE9ITEsRT0wLFM9MCxrPXBhcnNlSW50KDFlMy9hKSxOPXZvaWQgMCE9PW4/bjpzZXRUaW1lb3V0LHg9ZnVuY3Rpb24oKXtpZihBKXJldHVybiBoKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSxfL3cpO3N3aXRjaChFKXtjYXNlIDA6UihjLHA9MzIqUyphLHYsMCxtKSxFPTEsZD0wO2Nhc2UgMTprPCh0PXMtZCkmJih0PWspO2Zvcih2YXIgZT0wO2U8dDtlKyspUih2LDAseSwoZCtlKSptLG0pLEkodixtLGEsZyxiKTtpZihkKz10LF8rPXQsKHI9cGFyc2VJbnQoMWUzKl8vdykpIT09TSl7aWYoQT1oKG51bGwsXy93KSlicmVhaztNPXJ9aWYoZDxzKWJyZWFrO2Q9MCxFPTI7Y2FzZSAyOnZhciB0O2s8KHQ9cy1kKSYmKHQ9ayk7Zm9yKHZhciByLGU9MDtlPHQ7ZSsrKXt2YXIgbj12WzE2KigyKmEtMSldJnMtMTtUKHksbiptLHYsbSksSSh2LG0sYSxnLGIpfWlmKGQrPXQsXys9dCwocj1wYXJzZUludCgxZTMqXy93KSkhPT1NKXtpZihBPWgobnVsbCxfL3cpKWJyZWFrO009cn1pZihkPHMpYnJlYWs7aWYoUih2LDAsYyxwLG0pLCsrUzx1KXtFPTA7YnJlYWt9Zj1bXTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKWYucHVzaChjW2VdPj4wJjI1NSksZi5wdXNoKGNbZV0+PjgmMjU1KSxmLnB1c2goY1tlXT4+MTYmMjU1KSxmLnB1c2goY1tlXT4+MjQmMjU1KTt2YXIgaT1QKG8sZixsKTtyZXR1cm4gaChudWxsLDEsaSl9Tih4KX07eCgpfXZhciB0LEM7dD10aGlzLEM9MjE0NzQ4MzY0Nyx2b2lkIDAhPT1vP3IuZXhwb3J0cz1lOnQmJih0LnNjcnlwdCYmKHQuX3NjcnlwdD10LnNjcnlwdCksdC5zY3J5cHQ9ZSl9KS5jYWxsKHRoaXMsZShcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGUpfSx7dGltZXJzOjQ2fV0sNDU6W2Z1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24oeSxlLHQpeyFmdW5jdGlvbihyLG4pe1widXNlIHN0cmljdFwiO3ZhciB0LGksbyxzLGUsYSx1LGwsaDtmdW5jdGlvbiBmKGUpe3JldHVybiBpW3RdPWMuYXBwbHkobixlKSx0Kyt9ZnVuY3Rpb24gYyhlKXt2YXIgdD1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuYXBwbHkobix0KTpuZXcgRnVuY3Rpb24oXCJcIitlKSgpfX1mdW5jdGlvbiBkKGUpe2lmKG8pc2V0VGltZW91dChjKGQsZSksMCk7ZWxzZXt2YXIgdD1pW2VdO2lmKHQpe289ITA7dHJ5e3QoKX1maW5hbGx5e3AoZSksbz0hMX19fX1mdW5jdGlvbiBwKGUpe2RlbGV0ZSBpW2VdfWZ1bmN0aW9uIHYoZSl7ZS5zb3VyY2U9PT1yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYwPT09ZS5kYXRhLmluZGV4T2YobCkmJmQoK2UuZGF0YS5zbGljZShsLmxlbmd0aCkpfXIuc2V0SW1tZWRpYXRlfHwodD0xLG89IShpPXt9KSxzPXIuZG9jdW1lbnQsaD0oaD1PYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihyKSkmJmguc2V0VGltZW91dD9oOnIsZT1cIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwoci5wcm9jZXNzKT9mdW5jdGlvbigpe3ZhciBlPWYoYXJndW1lbnRzKTtyZXR1cm4geS5uZXh0VGljayhjKGQsZSkpLGV9OmZ1bmN0aW9uKCl7aWYoci5wb3N0TWVzc2FnZSYmIXIuaW1wb3J0U2NyaXB0cyl7dmFyIGU9ITAsdD1yLm9ubWVzc2FnZTtyZXR1cm4gci5vbm1lc3NhZ2U9ZnVuY3Rpb24oKXtlPSExfSxyLnBvc3RNZXNzYWdlKFwiXCIsXCIqXCIpLHIub25tZXNzYWdlPXQsZX19KCk/KGw9XCJzZXRJbW1lZGlhdGUkXCIrTWF0aC5yYW5kb20oKStcIiRcIixyLmFkZEV2ZW50TGlzdGVuZXI/ci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHYsITEpOnIuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIix2KSxmdW5jdGlvbigpe3ZhciBlPWYoYXJndW1lbnRzKTtyZXR1cm4gci5wb3N0TWVzc2FnZShsK2UsXCIqXCIpLGV9KTpyLk1lc3NhZ2VDaGFubmVsPygodT1uZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbihlKXtkKGUuZGF0YSl9LGZ1bmN0aW9uKCl7dmFyIGU9Zihhcmd1bWVudHMpO3JldHVybiB1LnBvcnQyLnBvc3RNZXNzYWdlKGUpLGV9KTpzJiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gcy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpPyhhPXMuZG9jdW1lbnRFbGVtZW50LGZ1bmN0aW9uKCl7dmFyIGU9Zihhcmd1bWVudHMpLHQ9cy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO3JldHVybiB0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2QoZSksdC5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxhLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH0sYS5hcHBlbmRDaGlsZCh0KSxlfSk6ZnVuY3Rpb24oKXt2YXIgZT1mKGFyZ3VtZW50cyk7cmV0dXJuIHNldFRpbWVvdXQoYyhkLGUpLDApLGV9LGguc2V0SW1tZWRpYXRlPWUsaC5jbGVhckltbWVkaWF0ZT1wKX0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/dm9pZCAwPT09ZT90aGlzOmU6c2VsZil9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30sZShcInRpbWVyc1wiKS5jbGVhckltbWVkaWF0ZSl9LHtfcHJvY2Vzczo0Myx0aW1lcnM6NDZ9XSw0NjpbZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbihlKXt0LmV4cG9ydHM9e3NldEltbWVkaWF0ZTplLnNldEltbWVkaWF0ZX19KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHt9XSw0NzpbZnVuY3Rpb24oZSxpLHQpeyhmdW5jdGlvbihlKXt2YXIgdCxyLG47ZS5jcnlwdG8mJmNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJih0PW5ldyBVaW50OEFycmF5KDE2KSxyPWZ1bmN0aW9uKCl7cmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdH0pLHJ8fChuPW5ldyBBcnJheSgxNikscj1mdW5jdGlvbigpe2Zvcih2YXIgZSx0PTA7dDwxNjt0KyspMD09KDMmdCkmJihlPTQyOTQ5NjcyOTYqTWF0aC5yYW5kb20oKSksblt0XT1lPj4+KCgzJnQpPDwzKSYyNTU7cmV0dXJuIG59KSxpLmV4cG9ydHM9cn0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDQ4OltmdW5jdGlvbihlLHQscil7Zm9yKHZhciBzPWUoXCIuL3JuZ1wiKSxuPVtdLG89e30saT0wO2k8MjU2O2krKyluW2ldPShpKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cigxKSxvW25baV1dPWk7ZnVuY3Rpb24gZChlLHQpe3ZhciByPXR8fDA7cmV0dXJuIG5bZVtyKytdXStuW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXStcIi1cIituW2VbcisrXV0rbltlW3IrK11dK1wiLVwiK25bZVtyKytdXStuW2VbcisrXV0rXCItXCIrbltlW3IrK11dK25bZVtyKytdXStcIi1cIituW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXStuW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXX12YXIgYT1zKCkscD1bMXxhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XV0sdj0xNjM4MyYoYVs2XTw8OHxhWzddKSx5PTAsbT0wO2Z1bmN0aW9uIHUoZSx0LHIpe3ZhciBuPXQmJnJ8fDA7XCJzdHJpbmdcIj09dHlwZW9mIGUmJih0PVwiYmluYXJ5XCI9PWU/bmV3IEFycmF5KDE2KTpudWxsLGU9bnVsbCk7dmFyIGk9KGU9ZXx8e30pLnJhbmRvbXx8KGUucm5nfHxzKSgpO2lmKGlbNl09MTUmaVs2XXw2NCxpWzhdPTYzJmlbOF18MTI4LHQpZm9yKHZhciBvPTA7bzwxNjtvKyspdFtuK29dPWlbb107cmV0dXJuIHR8fGQoaSl9dmFyIGw9dTtsLnYxPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10JiZyfHwwLGk9dHx8W10sbz12b2lkIDAhPT0oZT1lfHx7fSkuY2xvY2tzZXE/ZS5jbG9ja3NlcTp2LHM9dm9pZCAwIT09ZS5tc2Vjcz9lLm1zZWNzOihuZXcgRGF0ZSkuZ2V0VGltZSgpLGE9dm9pZCAwIT09ZS5uc2Vjcz9lLm5zZWNzOm0rMSx1PXMteSsoYS1tKS8xZTQ7aWYodTwwJiZ2b2lkIDA9PT1lLmNsb2Nrc2VxJiYobz1vKzEmMTYzODMpLCh1PDB8fHk8cykmJnZvaWQgMD09PWUubnNlY3MmJihhPTApLDFlNDw9YSl0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTt5PXMsdj1vO3ZhciBsPSgxZTQqKDI2ODQzNTQ1NSYocys9MTIyMTkyOTI4ZTUpKSsobT1hKSklNDI5NDk2NzI5NjtpW24rK109bD4+PjI0JjI1NSxpW24rK109bD4+PjE2JjI1NSxpW24rK109bD4+PjgmMjU1LGlbbisrXT0yNTUmbDt2YXIgaD1zLzQyOTQ5NjcyOTYqMWU0JjI2ODQzNTQ1NTtpW24rK109aD4+PjgmMjU1LGlbbisrXT0yNTUmaCxpW24rK109aD4+PjI0JjE1fDE2LGlbbisrXT1oPj4+MTYmMjU1LGlbbisrXT1vPj4+OHwxMjgsaVtuKytdPTI1NSZvO2Zvcih2YXIgZj1lLm5vZGV8fHAsYz0wO2M8NjtjKyspaVtuK2NdPWZbY107cmV0dXJuIHR8fGQoaSl9LGwudjQ9dSxsLnBhcnNlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10JiZyfHwwLGk9MDtmb3IodD10fHxbXSxlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZyxmdW5jdGlvbihlKXtpPDE2JiYodFtuK2krK109b1tlXSl9KTtpPDE2Oyl0W24raSsrXT0wO3JldHVybiB0fSxsLnVucGFyc2U9ZCx0LmV4cG9ydHM9bH0se1wiLi9ybmdcIjo0N31dLDQ5OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dHJ5e3QuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdD1YTUxIdHRwUmVxdWVzdH1jYXRjaChlKXtjb25zb2xlLmxvZyhcIldhcm5pbmc6IFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBkZWZpbmVkXCIpLHQuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdD1udWxsfX0se31dLDUwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksaT0oby5pc1Byb3ZpZGVyPWZ1bmN0aW9uKGUpe3JldHVybiBuLmlzVHlwZShlLFwiUHJvdmlkZXJcIil9LG8pO2Z1bmN0aW9uIG8oKXtuLnNldFR5cGUodGhpcyxcIlByb3ZpZGVyXCIpfXIuUHJvdmlkZXI9aX0se1wiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0fV0sNTE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZShcIi4uL3V0aWxzL2FkZHJlc3NcIiksYT1lKFwiLi4vdXRpbHMvYmlnbnVtYmVyXCIpLHU9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGw9ZShcIi4uL2NvbnN0YW50c1wiKSxoPWUoXCIuLi91dGlscy9oYXNoXCIpLGY9ZShcIi4uL3V0aWxzL25ldHdvcmtzXCIpLGM9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksZD1lKFwiLi4vdXRpbHMvcmxwXCIpLHA9ZShcIi4uL3V0aWxzL3RyYW5zYWN0aW9uXCIpLHY9ZShcIi4uL3V0aWxzL3V0ZjhcIikseT1lKFwiLi4vdXRpbHMvd2ViXCIpLG09byhlKFwiLi4vZXJyb3JzXCIpKSxnPWUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyXCIpO2Z1bmN0aW9uIGIoZSx0KXt2YXIgcj17fTtmb3IodmFyIG4gaW4gZSl0cnl7dmFyIGk9ZVtuXSh0W25dKTt2b2lkIDAhPT1pJiYocltuXT1pKX1jYXRjaChlKXt0aHJvdyBlLmNoZWNrS2V5PW4sZS5jaGVja1ZhbHVlPXRbbl0sZX1yZXR1cm4gcn1mdW5jdGlvbiB3KHQscil7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3I6dChlKX19ZnVuY3Rpb24gXyhyKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO3ZhciB0PVtdO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7dC5wdXNoKHIoZSkpfSksdH19ZnVuY3Rpb24gTShlLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYodHx8XCIweFwiPT09ZS5zdWJzdHJpbmcoMCwyKXx8KGU9XCIweFwiK2UpLDMyPT09dS5oZXhEYXRhTGVuZ3RoKGUpKT9lLnRvTG93ZXJDYXNlKCk6KG0udGhyb3dFcnJvcihcImludmFsaWQgaGFzaFwiLG0uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiaGFzaFwiLHZhbHVlOmV9KSxudWxsKX1mdW5jdGlvbiBBKGUpe3JldHVybiBhLmJpZ051bWJlcmlmeShlKS50b051bWJlcigpfWZ1bmN0aW9uIEUoZSl7aWYoIXUuaXNIZXhTdHJpbmcoZSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO2Zvcig7ZS5sZW5ndGg8NjY7KWU9XCIweDBcIitlLnN1YnN0cmluZygyKTtyZXR1cm4gZX1mdW5jdGlvbiBTKGUpe2lmKG51bGw9PWUpcmV0dXJuXCJsYXRlc3RcIjtpZihcImVhcmxpZXN0XCI9PT1lKXJldHVyblwiMHgwXCI7aWYoXCJsYXRlc3RcIj09PWV8fFwicGVuZGluZ1wiPT09ZSlyZXR1cm4gZTtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gdS5oZXhTdHJpcFplcm9zKHUuaGV4bGlmeShlKSk7aWYodS5pc0hleFN0cmluZyhlKSlyZXR1cm4gdS5oZXhTdHJpcFplcm9zKGUpO3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIil9dmFyIGs9e2hhc2g6TSxibG9ja0hhc2g6dyhNLG51bGwpLGJsb2NrTnVtYmVyOncoQSxudWxsKSx0cmFuc2FjdGlvbkluZGV4OncoQSxudWxsKSxjb25maXJtYXRpb25zOncoQSxudWxsKSxmcm9tOnMuZ2V0QWRkcmVzcyxnYXNQcmljZTphLmJpZ051bWJlcmlmeSxnYXNMaW1pdDphLmJpZ051bWJlcmlmeSx0bzp3KHMuZ2V0QWRkcmVzcyxudWxsKSx2YWx1ZTphLmJpZ051bWJlcmlmeSxub25jZTpBLGRhdGE6dS5oZXhsaWZ5LHI6dyhFKSxzOncoRSksdjp3KEEpLGNyZWF0ZXM6dyhzLmdldEFkZHJlc3MsbnVsbCkscmF3OncodS5oZXhsaWZ5KX07ZnVuY3Rpb24gTihlKXt2YXIgdDtudWxsIT1lLmdhcyYmbnVsbD09ZS5nYXNMaW1pdCYmKGUuZ2FzTGltaXQ9ZS5nYXMpLGUudG8mJmEuYmlnTnVtYmVyaWZ5KGUudG8pLmlzWmVybygpJiYoZS50bz1cIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSxudWxsIT1lLmlucHV0JiZudWxsPT1lLmRhdGEmJihlLmRhdGE9ZS5pbnB1dCksbnVsbD09ZS50byYmbnVsbD09ZS5jcmVhdGVzJiYoZS5jcmVhdGVzPXMuZ2V0Q29udHJhY3RBZGRyZXNzKGUpKSxlLnJhd3x8ZS52JiZlLnImJmUucyYmKHQ9W3Uuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5ub25jZSkpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5nYXNQcmljZSkpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5nYXNMaW1pdCkpLGUudG98fFwiMHhcIix1LnN0cmlwWmVyb3ModS5oZXhsaWZ5KGUudmFsdWV8fFwiMHhcIikpLHUuaGV4bGlmeShlLmRhdGF8fFwiMHhcIiksdS5zdHJpcFplcm9zKHUuaGV4bGlmeShlLnZ8fFwiMHhcIikpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5yKSksdS5zdHJpcFplcm9zKHUuaGV4bGlmeShlLnMpKV0sZS5yYXc9ZC5lbmNvZGUodCkpO3ZhciByPWIoayxlKSxuPWUubmV0d29ya0lkO3JldHVybiBudWxsIT1lLmNoYWluSWQmJm51bGw9PW4mJm51bGw9PXIudiYmKG49ZS5jaGFpbklkKSx1LmlzSGV4U3RyaW5nKG4pJiYobj1hLmJpZ051bWJlcmlmeShuKS50b051bWJlcigpKSxcIm51bWJlclwiIT10eXBlb2YgbiYmbnVsbCE9ci52JiYoKG49KHIudi0zNSkvMik8MCYmKG49MCksbj1wYXJzZUludChuKSksXCJudW1iZXJcIiE9dHlwZW9mIG4mJihuPTApLHIubmV0d29ya0lkPW4sbnVsbD09ci5jaGFpbklkJiZudWxsIT1uJiYoci5jaGFpbklkPW4pLHIuYmxvY2tIYXNoJiZcInhcIj09PXIuYmxvY2tIYXNoLnJlcGxhY2UoLzAvZyxcIlwiKSYmKHIuYmxvY2tIYXNoPW51bGwpLHJ9dmFyIHg9e2hhc2g6TSxwYXJlbnRIYXNoOk0sbnVtYmVyOkEsdGltZXN0YW1wOkEsbm9uY2U6dyh1LmhleGxpZnkpLGRpZmZpY3VsdHk6ZnVuY3Rpb24oZSl7dmFyIHQ9YS5iaWdOdW1iZXJpZnkoZSk7dHJ5e3JldHVybiB0LnRvTnVtYmVyKCl9Y2F0Y2goZSl7fXJldHVybiBudWxsfSxnYXNMaW1pdDphLmJpZ051bWJlcmlmeSxnYXNVc2VkOmEuYmlnTnVtYmVyaWZ5LG1pbmVyOnMuZ2V0QWRkcmVzcyxleHRyYURhdGE6dS5oZXhsaWZ5LHRyYW5zYWN0aW9uczp3KF8oTSkpfSxQPWMuc2hhbGxvd0NvcHkoeCk7ZnVuY3Rpb24gSShlLHQpe3JldHVybiBudWxsIT1lLmF1dGhvciYmbnVsbD09ZS5taW5lciYmKGUubWluZXI9ZS5hdXRob3IpLGIodD9QOngsZSl9UC50cmFuc2FjdGlvbnM9dyhfKE4pKTt2YXIgVD17ZnJvbTp3KHMuZ2V0QWRkcmVzcyksbm9uY2U6dyhBKSxnYXNMaW1pdDp3KGEuYmlnTnVtYmVyaWZ5KSxnYXNQcmljZTp3KGEuYmlnTnVtYmVyaWZ5KSx0bzp3KHMuZ2V0QWRkcmVzcyksdmFsdWU6dyhhLmJpZ051bWJlcmlmeSksZGF0YTp3KHUuaGV4bGlmeSl9O2Z1bmN0aW9uIFIoZSl7cmV0dXJuIGIoVCxlKX12YXIgTz17dHJhbnNhY3Rpb25Mb2dJbmRleDp3KEEpLHRyYW5zYWN0aW9uSW5kZXg6QSxibG9ja051bWJlcjpBLHRyYW5zYWN0aW9uSGFzaDpNLGFkZHJlc3M6cy5nZXRBZGRyZXNzLHRvcGljczpfKE0pLGRhdGE6dS5oZXhsaWZ5LGxvZ0luZGV4OkEsYmxvY2tIYXNoOk19O3ZhciBDPXt0bzp3KHMuZ2V0QWRkcmVzcyxudWxsKSxmcm9tOncocy5nZXRBZGRyZXNzLG51bGwpLGNvbnRyYWN0QWRkcmVzczp3KHMuZ2V0QWRkcmVzcyxudWxsKSx0cmFuc2FjdGlvbkluZGV4OkEscm9vdDp3KE0pLGdhc1VzZWQ6YS5iaWdOdW1iZXJpZnksbG9nc0Jsb29tOncodS5oZXhsaWZ5KSxibG9ja0hhc2g6TSx0cmFuc2FjdGlvbkhhc2g6TSxsb2dzOl8oZnVuY3Rpb24oZSl7cmV0dXJuIGIoTyxlKX0pLGJsb2NrTnVtYmVyOkEsY29uZmlybWF0aW9uczp3KEEsbnVsbCksY3VtdWxhdGl2ZUdhc1VzZWQ6YS5iaWdOdW1iZXJpZnksc3RhdHVzOncoQSl9O2Z1bmN0aW9uIEwoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe0woZSl9KTpudWxsIT1lJiZNKGUpLGV9dmFyIEI9e2Zyb21CbG9jazp3KFMsdm9pZCAwKSx0b0Jsb2NrOncoUyx2b2lkIDApLGFkZHJlc3M6dyhzLmdldEFkZHJlc3Msdm9pZCAwKSx0b3BpY3M6dyhMLHZvaWQgMCl9LEQ9e2Jsb2NrSGFzaDp3KE0sdm9pZCAwKSxhZGRyZXNzOncocy5nZXRBZGRyZXNzLHZvaWQgMCksdG9waWNzOncoTCx2b2lkIDApfTt2YXIgVSxGLGo9e2Jsb2NrTnVtYmVyOncoQSksYmxvY2tIYXNoOncoTSksdHJhbnNhY3Rpb25JbmRleDpBLHJlbW92ZWQ6dyhmdW5jdGlvbihlKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGUpcmV0dXJuIGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKFwidHJ1ZVwiPT09ZSlyZXR1cm4hMDtpZihcImZhbHNlXCI9PT1lKXJldHVybiExfXRocm93IG5ldyBFcnJvcihcImludmFpZCBib29sZWFuIC0gXCIrZSl9KSxhZGRyZXNzOnMuZ2V0QWRkcmVzcyxkYXRhOihVPXUuaGV4bGlmeSxGPVwiMHhcIixmdW5jdGlvbihlKXtyZXR1cm4gZT9VKGUpOkZ9KSx0b3BpY3M6XyhNKSx0cmFuc2FjdGlvbkhhc2g6TSxsb2dJbmRleDpBfTtmdW5jdGlvbiBHKGUpe3JldHVybiBiKGosZSl9ZnVuY3Rpb24gSChlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpBcnJheS5pc0FycmF5KGUpPyhlLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9PWUmJjMyIT09dS5oZXhEYXRhTGVuZ3RoKGUpJiZtLnRocm93RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsbS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRvcGljXCIsdmFsdWU6ZX0pfSksZS5qb2luKFwiLFwiKSk6bnVsbD09PWU/XCJcIjptLnRocm93RXJyb3IoXCJpbnZhbGlkIHRvcGljIHZhbHVlXCIsbS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRvcGljXCIsdmFsdWU6ZX0pfSkuam9pbihcIiZcIil9ZnVuY3Rpb24geihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMjA9PT11LmhleERhdGFMZW5ndGgoZSkpcmV0dXJuXCJhZGRyZXNzOlwiK3MuZ2V0QWRkcmVzcyhlKTtpZihlPWUudG9Mb3dlckNhc2UoKSwzMj09PXUuaGV4RGF0YUxlbmd0aChlKSlyZXR1cm5cInR4OlwiK2U7aWYoLTE9PT1lLmluZGV4T2YoXCI6XCIpKXJldHVybiBlfWVsc2V7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm5cImZpbHRlcjo6XCIrSChlKTtpZihlJiZcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm5cImZpbHRlcjpcIisoZS5hZGRyZXNzfHxcIlwiKStcIjpcIitIKGUudG9waWNzfHxbXSl9dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiK2UpfWZ1bmN0aW9uIFYoKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX12YXIgSyxxPShLPWcuUHJvdmlkZXIsaShXLEspLFcucHJvdG90eXBlLl9kb1BvbGw9ZnVuY3Rpb24oKXt2YXIgdT10aGlzO3RoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGZ1bmN0aW9uKHMpe2lmKHUucG9sbGluZyYmKHUuX3NldEZhc3RCbG9ja051bWJlcihzKSxzIT09dS5fbGFzdEJsb2NrTnVtYmVyKSl7LTI9PT11Ll9lbWl0dGVkLmJsb2NrJiYodS5fZW1pdHRlZC5ibG9jaz1zLTEpO2Zvcih2YXIgZT11Ll9lbWl0dGVkLmJsb2NrKzE7ZTw9cztlKyspdS5lbWl0KFwiYmxvY2tcIixlKTt1Ll9lbWl0dGVkLmJsb2NrIT09cyYmKHUuX2VtaXR0ZWQuYmxvY2s9cyxPYmplY3Qua2V5cyh1Ll9lbWl0dGVkKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0O1wiYmxvY2tcIj09PWV8fFwicGVuZGluZ1wiIT09KHQ9dS5fZW1pdHRlZFtlXSkmJjEyPHMtdCYmZGVsZXRlIHUuX2VtaXR0ZWRbZV19KSksLTI9PT11Ll9sYXN0QmxvY2tOdW1iZXImJih1Ll9sYXN0QmxvY2tOdW1iZXI9cy0xKTt2YXIgYT17fSx0PXt9O3JldHVybiB1Ll9ldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKXt0W2UudGFnXT0hMH0pLE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIjpcIik7c3dpdGNoKHRbMF0pe2Nhc2VcInR4XCI6dmFyIHI9dFsxXTt1LmdldFRyYW5zYWN0aW9uUmVjZWlwdChyKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZudWxsIT1lLmJsb2NrTnVtYmVyJiYodS5fZW1pdHRlZFtcInQ6XCIrcl09ZS5ibG9ja051bWJlcix1LmVtaXQocixlKSksbnVsbH0pLmNhdGNoKGZ1bmN0aW9uKGUpe3UuZW1pdChcImVycm9yXCIsZSl9KTticmVhaztjYXNlXCJhZGRyZXNzXCI6dmFyIG49dFsxXTt1Ll9iYWxhbmNlc1tuXSYmKGFbbl09dS5fYmFsYW5jZXNbbl0pLHUuZ2V0QmFsYW5jZShuLFwibGF0ZXN0XCIpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9dS5fYmFsYW5jZXNbbl07aWYoIXR8fCFlLmVxKHQpKXJldHVybiB1Ll9iYWxhbmNlc1tuXT1lLHUuZW1pdChuLGUpLG51bGx9KS5jYXRjaChmdW5jdGlvbihlKXt1LmVtaXQoXCJlcnJvclwiLGUpfSk7YnJlYWs7Y2FzZVwiZmlsdGVyXCI6dmFyIGk9dFsyXS5zcGxpdCgvJi9nKS5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIixcIik7cmV0dXJuIDE9PT10Lmxlbmd0aD9cIlwiPT09dFswXT9udWxsOmU6dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJcIj09PWU/bnVsbDplfSl9KSxvPXthZGRyZXNzOnRbMV0sZnJvbUJsb2NrOnUuX2xhc3RCbG9ja051bWJlcisxLHRvQmxvY2s6cyx0b3BpY3M6aX07by5hZGRyZXNzfHxkZWxldGUgby5hZGRyZXNzLHUuZ2V0TG9ncyhvKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDAhPT1lLmxlbmd0aClyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3UuX2VtaXR0ZWRbXCJiOlwiK2UuYmxvY2tIYXNoXT1lLmJsb2NrTnVtYmVyLHUuX2VtaXR0ZWRbXCJ0OlwiK2UudHJhbnNhY3Rpb25IYXNoXT1lLmJsb2NrTnVtYmVyLHUuZW1pdChvLGUpfSksbnVsbH0pLmNhdGNoKGZ1bmN0aW9uKGUpe3UuZW1pdChcImVycm9yXCIsZSl9KX19KSx1Ll9sYXN0QmxvY2tOdW1iZXI9cyx1Ll9iYWxhbmNlcz1hLG51bGx9fSkuY2F0Y2goZnVuY3Rpb24oZSl7fSksdGhpcy5kb1BvbGwoKX0sVy5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jaz1mdW5jdGlvbihlKXt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9ZS0xLHRoaXMucG9sbGluZyYmdGhpcy5fZG9Qb2xsKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXLnByb3RvdHlwZSxcIm5ldHdvcmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25ldHdvcmt9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksVy5wcm90b3R5cGUuZ2V0TmV0d29yaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWR5fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVy5wcm90b3R5cGUsXCJibG9ja051bWJlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXLnByb3RvdHlwZSxcInBvbGxpbmdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuX3BvbGxlcn0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe2UmJiF0Ll9wb2xsZXI/KHQuX3BvbGxlcj1zZXRJbnRlcnZhbCh0Ll9kb1BvbGwuYmluZCh0KSx0LnBvbGxpbmdJbnRlcnZhbCksdC5fZG9Qb2xsKCkpOiFlJiZ0Ll9wb2xsZXImJihjbGVhckludGVydmFsKHQuX3BvbGxlciksdC5fcG9sbGVyPW51bGwpfSwwKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVy5wcm90b3R5cGUsXCJwb2xsaW5nSW50ZXJ2YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvbGxpbmdJbnRlcnZhbH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGU8PTB8fHBhcnNlSW50KFN0cmluZyhlKSkhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2xsaW5nIGludGVydmFsXCIpO3RoaXMuX3BvbGxpbmdJbnRlcnZhbD1lLHRoaXMuX3BvbGxlciYmKGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKSx0aGlzLl9wb2xsZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXt0Ll9kb1BvbGwoKX0sdGhpcy5fcG9sbGluZ0ludGVydmFsKSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksVy5wcm90b3R5cGUuX2dldEZhc3RCbG9ja051bWJlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1WKCk7cmV0dXJuIGUtdGhpcy5fZmFzdFF1ZXJ5RGF0ZT4yKnRoaXMuX3BvbGxpbmdJbnRlcnZhbCYmKHRoaXMuX2Zhc3RRdWVyeURhdGU9ZSx0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlPXRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybihudWxsPT10Ll9mYXN0QmxvY2tOdW1iZXJ8fGU+dC5fZmFzdEJsb2NrTnVtYmVyKSYmKHQuX2Zhc3RCbG9ja051bWJlcj1lKSx0Ll9mYXN0QmxvY2tOdW1iZXJ9KSksdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZX0sVy5wcm90b3R5cGUuX3NldEZhc3RCbG9ja051bWJlcj1mdW5jdGlvbihlKXtudWxsIT10aGlzLl9mYXN0QmxvY2tOdW1iZXImJmU8dGhpcy5fZmFzdEJsb2NrTnVtYmVyfHwodGhpcy5fZmFzdFF1ZXJ5RGF0ZT1WKCksKG51bGw9PXRoaXMuX2Zhc3RCbG9ja051bWJlcnx8ZT50aGlzLl9mYXN0QmxvY2tOdW1iZXIpJiYodGhpcy5fZmFzdEJsb2NrTnVtYmVyPWUsdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZT1Qcm9taXNlLnJlc29sdmUoZSkpKX0sVy5wcm90b3R5cGUud2FpdEZvclRyYW5zYWN0aW9uPWZ1bmN0aW9uKG4saSl7dmFyIG89dGhpcztyZXR1cm4gbnVsbD09aSYmKGk9MSksdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQobikudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gMD09PWl8fGUmJmUuY29uZmlybWF0aW9ucz49aT9lOm5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3ZhciByPWZ1bmN0aW9uKGUpe2UuY29uZmlybWF0aW9uczxpfHwoby5yZW1vdmVMaXN0ZW5lcihuLHIpLHQoZSkpfTtvLm9uKG4scil9KX0pfSxXLnByb3RvdHlwZS5nZXRCbG9ja051bWJlcj1mdW5jdGlvbigpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiByLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLHt9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXBhcnNlSW50KGUpO2lmKHQhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIGdldEJsb2NrTnVtYmVyXCIpO3JldHVybiByLl9zZXRGYXN0QmxvY2tOdW1iZXIodCksdH0pfSl9LFcucHJvdG90eXBlLmdldEdhc1ByaWNlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGUucGVyZm9ybShcImdldEdhc1ByaWNlXCIse30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpfSl9KX0sVy5wcm90b3R5cGUuZ2V0QmFsYW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzT3JOYW1lOmUsYmxvY2tUYWc6dH0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5ibG9ja1RhZztyZXR1cm4gbi5fZ2V0QWRkcmVzcyh0KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXthZGRyZXNzOmUsYmxvY2tUYWc6UyhyKX07cmV0dXJuIG4ucGVyZm9ybShcImdldEJhbGFuY2VcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBhLmJpZ051bWJlcmlmeShlKX0pfSl9KX0pfSxXLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe2FkZHJlc3NPck5hbWU6ZSxibG9ja1RhZzp0fSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLmFkZHJlc3NPck5hbWUscj1lLmJsb2NrVGFnO3JldHVybiBuLl9nZXRBZGRyZXNzKHQpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9e2FkZHJlc3M6ZSxibG9ja1RhZzpTKHIpfTtyZXR1cm4gbi5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpLnRvTnVtYmVyKCl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0Q29kZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzT3JOYW1lOmUsYmxvY2tUYWc6dH0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5ibG9ja1RhZztyZXR1cm4gbi5fZ2V0QWRkcmVzcyh0KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXthZGRyZXNzOmUsYmxvY2tUYWc6UyhyKX07cmV0dXJuIG4ucGVyZm9ybShcImdldENvZGVcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1LmhleGxpZnkoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0U3RvcmFnZUF0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgaT10aGlzO3JldHVybiB0aGlzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyh7YWRkcmVzc09yTmFtZTplLHBvc2l0aW9uOnQsYmxvY2tUYWc6cn0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5wb3NpdGlvbixuPWUuYmxvY2tUYWc7cmV0dXJuIGkuX2dldEFkZHJlc3ModCkudGhlbihmdW5jdGlvbihlKXt2YXIgdD17YWRkcmVzczplLGJsb2NrVGFnOlMobikscG9zaXRpb246dS5oZXhTdHJpcFplcm9zKHUuaGV4bGlmeShyKSl9O3JldHVybiBpLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1LmhleGxpZnkoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHtzaWduZWRUcmFuc2FjdGlvbjplfSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLnNpZ25lZFRyYW5zYWN0aW9uLHI9e3NpZ25lZFRyYW5zYWN0aW9uOnUuaGV4bGlmeSh0KX07cmV0dXJuIG4ucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG4uX3dyYXBUcmFuc2FjdGlvbihwLnBhcnNlKHQpLGUpfSxmdW5jdGlvbihlKXt0aHJvdyBlLnRyYW5zYWN0aW9uPXAucGFyc2UodCksZS50cmFuc2FjdGlvbi5oYXNoJiYoZS50cmFuc2FjdGlvbkhhc2g9ZS50cmFuc2FjdGlvbi5oYXNoKSxlfSl9KX0pfSxXLnByb3RvdHlwZS5fd3JhcFRyYW5zYWN0aW9uPWZ1bmN0aW9uKHIsZSl7dmFyIG49dGhpcztpZihudWxsIT1lJiYzMiE9PXUuaGV4RGF0YUxlbmd0aChlKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO3ZhciB0PXI7cmV0dXJuIG51bGwhPWUmJnIuaGFzaCE9PWUmJm0udGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsbS5VTktOT1dOX0VSUk9SLHtleHBlY3RlZEhhc2g6ci5oYXNoLHJldHVybmVkSGFzaDplfSksdC53YWl0PWZ1bmN0aW9uKHQpe3JldHVybiAwIT09dCYmKG4uX2VtaXR0ZWRbXCJ0OlwiK3IuaGFzaF09XCJwZW5kaW5nXCIpLG4ud2FpdEZvclRyYW5zYWN0aW9uKHIuaGFzaCx0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lJiYwPT09dD9udWxsOihuLl9lbWl0dGVkW1widDpcIityLmhhc2hdPWUuYmxvY2tOdW1iZXIsMD09PWUuc3RhdHVzJiZtLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIixtLkNBTExfRVhDRVBUSU9OLHt0cmFuc2FjdGlvbkhhc2g6ci5oYXNoLHRyYW5zYWN0aW9uOnJ9KSxlKX0pfSx0fSxXLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWMuc2hhbGxvd0NvcHkoZSk7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHtibG9ja1RhZzp0LHR4OnJ9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciByPWUuYmxvY2tUYWcsdD1lLnR4O3JldHVybiBuLl9yZXNvbHZlTmFtZXModCxbXCJ0b1wiLFwiZnJvbVwiXSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD17YmxvY2tUYWc6UyhyKSx0cmFuc2FjdGlvbjpSKGUpfTtyZXR1cm4gbi5wZXJmb3JtKFwiY2FsbFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHUuaGV4bGlmeShlKX0pfSl9KX0pfSxXLnByb3RvdHlwZS5lc3RpbWF0ZUdhcz1mdW5jdGlvbihlKXt2YXIgcj10aGlzLHQ9e3RvOmUudG8sZnJvbTplLmZyb20sZGF0YTplLmRhdGEsZ2FzUHJpY2U6ZS5nYXNQcmljZSx2YWx1ZTplLnZhbHVlfTtyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXModCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5fcmVzb2x2ZU5hbWVzKGUsW1widG9cIixcImZyb21cIl0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9e3RyYW5zYWN0aW9uOlIoZSl9O3JldHVybiByLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpfSl9KX0pfSl9LFcucHJvdG90eXBlLmdldEJsb2NrPWZ1bmN0aW9uKGUsbyl7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe2Jsb2NrSGFzaE9yQmxvY2tUYWc6ZX0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ibG9ja0hhc2hPckJsb2NrVGFnO3RyeXt2YXIgcj11LmhleGxpZnkodCk7aWYoMzI9PT11LmhleERhdGFMZW5ndGgocikpcmV0dXJuIHkucG9sbChmdW5jdGlvbigpe3JldHVybiBzLnBlcmZvcm0oXCJnZXRCbG9ja1wiLHtibG9ja0hhc2g6cixpbmNsdWRlVHJhbnNhY3Rpb25zOiEhb30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/bnVsbD09cy5fZW1pdHRlZFtcImI6XCIrcl0/bnVsbDp2b2lkIDA6SShlLG8pfSl9LHtvbmNlQmxvY2s6c30pfWNhdGNoKGUpe310cnl7dmFyIG49LTEyOCxpPVModCk7cmV0dXJuIHUuaXNIZXhTdHJpbmcoaSkmJihuPXBhcnNlSW50KGkuc3Vic3RyaW5nKDIpLDE2KSkseS5wb2xsKGZ1bmN0aW9uKCl7cmV0dXJuIHMucGVyZm9ybShcImdldEJsb2NrXCIse2Jsb2NrVGFnOmksaW5jbHVkZVRyYW5zYWN0aW9uczohIW99KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP0koZSxvKTpuPD1zLl9lbWl0dGVkLmJsb2NrP3ZvaWQgMDpudWxsfSl9LHtvbmNlQmxvY2s6c30pfWNhdGNoKGUpe310aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIpfSl9KX0sVy5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe3RyYW5zYWN0aW9uSGFzaDplfSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLnRyYW5zYWN0aW9uSGFzaCxyPXt0cmFuc2FjdGlvbkhhc2g6TSh0LCEwKX07cmV0dXJuIHkucG9sbChmdW5jdGlvbigpe3JldHVybiBuLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLHIpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbD09ZSlyZXR1cm4gbnVsbD09bi5fZW1pdHRlZFtcInQ6XCIrdF0/bnVsbDp2b2lkIDA7dmFyIHI9Vy5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2UoZSk7aWYobnVsbD09ci5ibG9ja051bWJlcilyLmNvbmZpcm1hdGlvbnM9MDtlbHNlIGlmKG51bGw9PXIuY29uZmlybWF0aW9ucylyZXR1cm4gbi5fZ2V0RmFzdEJsb2NrTnVtYmVyKCkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLXIuYmxvY2tOdW1iZXIrMTtyZXR1cm4gdDw9MCYmKHQ9MSksci5jb25maXJtYXRpb25zPXQsbi5fd3JhcFRyYW5zYWN0aW9uKHIpfSk7cmV0dXJuIG4uX3dyYXBUcmFuc2FjdGlvbihyKX0pfSx7b25jZUJsb2NrOm59KX0pfSl9LFcucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdD1mdW5jdGlvbihlKXt2YXIgbz10aGlzO3JldHVybiB0aGlzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyh7dHJhbnNhY3Rpb25IYXNoOmV9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciBpPWUudHJhbnNhY3Rpb25IYXNoLHQ9e3RyYW5zYWN0aW9uSGFzaDpNKGksITApfTtyZXR1cm4geS5wb2xsKGZ1bmN0aW9uKCl7cmV0dXJuIG8ucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbD09ZSlyZXR1cm4gbnVsbD09by5fZW1pdHRlZFtcInQ6XCIraV0/bnVsbDp2b2lkIDA7aWYobnVsbCE9ZS5ibG9ja0hhc2gpe3ZhciB0LHIsbj0oKHI9YihDLHQ9ZSkpLmxvZ3MuZm9yRWFjaChmdW5jdGlvbihlLHQpe251bGw9PWUudHJhbnNhY3Rpb25Mb2dJbmRleCYmKGUudHJhbnNhY3Rpb25Mb2dJbmRleD10KX0pLG51bGwhPXQuc3RhdHVzJiYoci5ieXphbnRpdW09ITApLHIpO2lmKG51bGw9PW4uYmxvY2tOdW1iZXIpbi5jb25maXJtYXRpb25zPTA7ZWxzZSBpZihudWxsPT1uLmNvbmZpcm1hdGlvbnMpcmV0dXJuIG8uX2dldEZhc3RCbG9ja051bWJlcigpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS1uLmJsb2NrTnVtYmVyKzE7cmV0dXJuIHQ8PTAmJih0PTEpLG4uY29uZmlybWF0aW9ucz10LG59KTtyZXR1cm4gbn19KX0se29uY2VCbG9jazpvfSl9KX0pfSxXLnByb3RvdHlwZS5nZXRMb2dzPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKGUpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG4uX3Jlc29sdmVOYW1lcyhlLFtcImFkZHJlc3NcIl0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQscj17ZmlsdGVyOih0PWUpJiZ0LmJsb2NrSGFzaD9iKEQsdCk6YihCLHQpfTtyZXR1cm4gbi5wZXJmb3JtKFwiZ2V0TG9nc1wiLHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIF8oRykoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0RXRoZXJQcmljZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBlLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIse30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGV9KX0pfSxXLnByb3RvdHlwZS5fZ2V0QWRkcmVzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZXNvbHZlTmFtZSh0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lJiZtLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLG0uVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJyZXNvbHZlTmFtZShcIitKU09OLnN0cmluZ2lmeSh0KStcIilcIn0pLGV9KX0sVy5wcm90b3R5cGUuX3Jlc29sdmVOYW1lcz1mdW5jdGlvbihlLHQpe3ZhciByPVtdLG49Yy5zaGFsbG93Q29weShlKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe251bGwhPW5bdF0mJnIucHVzaCh0aGlzLl9nZXRBZGRyZXNzKG5bdF0pLnRoZW4oZnVuY3Rpb24oZSl7blt0XT1lfSkpfSx0aGlzKSxQcm9taXNlLmFsbChyKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG59KX0sVy5wcm90b3R5cGUuX2dldFJlc29sdmVyPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24oZSl7ZS5lbnNBZGRyZXNzfHxtLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsbS5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIkVOU1wiLG5ldHdvcms6ZS5uYW1lfSk7dmFyIHQ9XCIweDAxNzhiOGJmXCIraC5uYW1laGFzaChuKS5zdWJzdHJpbmcoMikscj17dG86ZS5lbnNBZGRyZXNzLGRhdGE6dH07cmV0dXJuIGkuY2FsbChyKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDMyIT09dS5oZXhEYXRhTGVuZ3RoKGUpKXJldHVybiBudWxsO3ZhciB0PXMuZ2V0QWRkcmVzcyh1LmhleERhdGFTbGljZShlLDEyKSk7cmV0dXJuIHQ9PT1sLkFkZHJlc3NaZXJvP251bGw6dH0pfSl9LFcucHJvdG90eXBlLnJlc29sdmVOYW1lPWZ1bmN0aW9uKHQpe3ZhciByPXRoaXM7aWYodCBpbnN0YW5jZW9mIFByb21pc2UpcmV0dXJuIHQudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5yZXNvbHZlTmFtZShlKX0pO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHMuZ2V0QWRkcmVzcyh0KSl9Y2F0Y2goZSl7aWYodS5pc0hleFN0cmluZyh0KSl0aHJvdyBlfXZhciBuPXRoaXMsaT1oLm5hbWVoYXNoKHQpO3JldHVybiB0aGlzLl9nZXRSZXNvbHZlcih0KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7dmFyIHQ9e3RvOmUsZGF0YTpcIjB4M2IzYjU3ZGVcIitpLnN1YnN0cmluZygyKX07cmV0dXJuIG4uY2FsbCh0KX0pLnRoZW4oZnVuY3Rpb24oZSl7aWYoMzIhPT11LmhleERhdGFMZW5ndGgoZSkpcmV0dXJuIG51bGw7dmFyIHQ9cy5nZXRBZGRyZXNzKHUuaGV4RGF0YVNsaWNlKGUsMTIpKTtyZXR1cm4gdD09PWwuQWRkcmVzc1plcm8/bnVsbDp0fSl9LFcucHJvdG90eXBlLmxvb2t1cEFkZHJlc3M9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcztpZihuIGluc3RhbmNlb2YgUHJvbWlzZSlyZXR1cm4gbi50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0Lmxvb2t1cEFkZHJlc3MoZSl9KTt2YXIgZT0obj1zLmdldEFkZHJlc3MobikpLnN1YnN0cmluZygyKStcIi5hZGRyLnJldmVyc2VcIixyPWgubmFtZWhhc2goZSksaT10aGlzO3JldHVybiB0aGlzLl9nZXRSZXNvbHZlcihlKS50aGVuKGZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiBudWxsO3ZhciB0PXt0bzplLGRhdGE6XCIweDY5MWYzNDMxXCIrci5zdWJzdHJpbmcoMil9O3JldHVybiBpLmNhbGwodCl9KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoKGU9ZS5zdWJzdHJpbmcoMikpLmxlbmd0aDw2NClyZXR1cm4gbnVsbDtpZigoZT1lLnN1YnN0cmluZyg2NCkpLmxlbmd0aDw2NClyZXR1cm4gbnVsbDt2YXIgdD1hLmJpZ051bWJlcmlmeShcIjB4XCIrZS5zdWJzdHJpbmcoMCw2NCkpLnRvTnVtYmVyKCk7aWYoMip0PihlPWUuc3Vic3RyaW5nKDY0KSkubGVuZ3RoKXJldHVybiBudWxsO3ZhciByPXYudG9VdGY4U3RyaW5nKFwiMHhcIitlLnN1YnN0cmluZygwLDIqdCkpO3JldHVybiBpLnJlc29sdmVOYW1lKHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUhPW4/bnVsbDpyfSl9KX0sVy5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2U9TixXLnByb3RvdHlwZS5kb1BvbGw9ZnVuY3Rpb24oKXt9LFcucHJvdG90eXBlLnBlcmZvcm09ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbS50aHJvd0Vycm9yKGUrXCIgbm90IGltcGxlbWVudGVkXCIsbS5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjplfSksbnVsbH0sVy5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZz1mdW5jdGlvbigpe20ud2FybihcIldBUk5JTkc6IHRoaXMgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGV2ZW50c1wiKX0sVy5wcm90b3R5cGUuX3N0b3BQZW5kaW5nPWZ1bmN0aW9uKCl7fSxXLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLHQscil7dGhpcy5fZXZlbnRzLnB1c2goe3RhZzp6KGUpLGxpc3RlbmVyOnQsb25jZTpyfSksXCJwZW5kaW5nXCI9PT1lJiZ0aGlzLl9zdGFydFBlbmRpbmcoKSx0aGlzLnBvbGxpbmc9ITB9LFcucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZSx0LCExKSx0aGlzfSxXLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZSx0LCEwKSx0aGlzfSxXLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub24oZSx0KX0sVy5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcyxyPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXJbbi0xXT1hcmd1bWVudHNbbl07dmFyIGk9ITEsbz16KGUpO3JldHVybiB0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YWchPT1vfHwoc2V0VGltZW91dChmdW5jdGlvbigpe2UubGlzdGVuZXIuYXBwbHkodCxyKX0sMCksaT0hMCwhZS5vbmNlKX0pLDA9PT10aGlzLmxpc3RlbmVyQ291bnQoKSYmKHRoaXMucG9sbGluZz0hMSksaX0sVy5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlKXtpZighZSlyZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDt2YXIgdD16KGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZz09PXR9KS5sZW5ndGh9LFcucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgdD16KGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZz09PXR9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubGlzdGVuZXJ9KX0sVy5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBudWxsPT1lPyh0aGlzLl9ldmVudHM9W10sdGhpcy5fc3RvcFBlbmRpbmcoKSk6KHQ9eihlKSx0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YWchPT10fSksXCJwZW5kaW5nXCI9PT1lJiZ0aGlzLl9zdG9wUGVuZGluZygpKSwwPT09dGhpcy5fZXZlbnRzLmxlbmd0aCYmKHRoaXMucG9sbGluZz0hMSksdGhpc30sVy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj0hMSxuPXooZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZyE9PW58fGUubGlzdGVuZXIhPXR8fCghIXJ8fCEocj0hMCkpfSksXCJwZW5kaW5nXCI9PT1lJiYwPT09dGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSYmdGhpcy5fc3RvcFBlbmRpbmcoKSwwPT09dGhpcy5saXN0ZW5lckNvdW50KCkmJih0aGlzLnBvbGxpbmc9ITEpLHRoaXN9LFcpO2Z1bmN0aW9uIFcoZSl7dmFyIHQscj1LLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG0uY2hlY2tOZXcocixnLlByb3ZpZGVyKSxlIGluc3RhbmNlb2YgUHJvbWlzZT8oYy5kZWZpbmVSZWFkT25seShyLFwicmVhZHlcIixlLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGMuZGVmaW5lUmVhZE9ubHkocixcIl9uZXR3b3JrXCIsZSksZX0pKSxyLnJlYWR5LmNhdGNoKGZ1bmN0aW9uKGUpe30pKToodD1mLmdldE5ldHdvcmsobnVsbD09ZT9cImhvbWVzdGVhZFwiOmUpKT8oYy5kZWZpbmVSZWFkT25seShyLFwiX25ldHdvcmtcIix0KSxjLmRlZmluZVJlYWRPbmx5KHIsXCJyZWFkeVwiLFByb21pc2UucmVzb2x2ZShyLl9uZXR3b3JrKSkpOm0udGhyb3dFcnJvcihcImludmFsaWQgbmV0d29ya1wiLG0uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwibmV0d29ya1wiLHZhbHVlOmV9KSxyLl9sYXN0QmxvY2tOdW1iZXI9LTIsci5fYmFsYW5jZXM9e30sci5fZXZlbnRzPVtdLHIuX3BvbGxpbmdJbnRlcnZhbD00ZTMsci5fZW1pdHRlZD17YmxvY2s6LTJ9LHIuX2Zhc3RRdWVyeURhdGU9MCxyfXIuQmFzZVByb3ZpZGVyPXEsYy5kZWZpbmVSZWFkT25seShnLlByb3ZpZGVyLFwiaW5oZXJpdHNcIixjLmluaGVyaXRhYmxlKGcuUHJvdmlkZXIpKX0se1wiLi4vY29uc3RhbnRzXCI6MyxcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9hZGRyZXNzXCI6NjAsXCIuLi91dGlscy9iaWdudW1iZXJcIjo2MyxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9oYXNoXCI6NjUsXCIuLi91dGlscy9uZXR3b3Jrc1wiOjcyLFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvcmxwXCI6NzYsXCIuLi91dGlscy90cmFuc2FjdGlvblwiOjgzLFwiLi4vdXRpbHMvdXRmOFwiOjg1LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Fic3RyYWN0LXByb3ZpZGVyXCI6NTB9XSw1MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1lKFwiLi9iYXNlLXByb3ZpZGVyXCIpLGE9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLHU9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksbD1lKFwiLi4vdXRpbHMvd2ViXCIpLGg9byhlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBmKGUpe3ZhciB0LHI9W107Zm9yKHZhciBuIGluIGUpe251bGwhPWVbbl0mJih0PWEuaGV4bGlmeShlW25dKSx7Z2FzTGltaXQ6ITAsZ2FzUHJpY2U6ITAsbm9uY2U6ITAsdmFsdWU6ITB9W25dJiYodD1hLmhleFN0cmlwWmVyb3ModCkpLHIucHVzaChuK1wiPVwiK3QpKX1yZXR1cm4gci5qb2luKFwiJlwiKX1mdW5jdGlvbiBjKGUpe2lmKDA9PWUuc3RhdHVzJiYoXCJObyByZWNvcmRzIGZvdW5kXCI9PT1lLm1lc3NhZ2V8fFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCI9PT1lLm1lc3NhZ2UpKXJldHVybiBlLnJlc3VsdDtpZigxPT1lLnN0YXR1cyYmXCJPS1wiPT1lLm1lc3NhZ2UpcmV0dXJuIGUucmVzdWx0O3ZhciB0PW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7dGhyb3cgdC5yZXN1bHQ9SlNPTi5zdHJpbmdpZnkoZSksdH1mdW5jdGlvbiBkKGUpe2lmKFwiMi4wXCIhPWUuanNvbnJwYyl0aHJvdyh0PW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIikpLnJlc3VsdD1KU09OLnN0cmluZ2lmeShlKSx0O2lmKGUuZXJyb3Ipe3ZhciB0PW5ldyBFcnJvcihlLmVycm9yLm1lc3NhZ2V8fFwidW5rbm93biBlcnJvclwiKTt0aHJvdyBlLmVycm9yLmNvZGUmJih0LmNvZGU9ZS5lcnJvci5jb2RlKSxlLmVycm9yLmRhdGEmJih0LmRhdGE9ZS5lcnJvci5kYXRhKSx0fXJldHVybiBlLnJlc3VsdH1mdW5jdGlvbiBwKGUpe2lmKFwicGVuZGluZ1wiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJwZW5kaW5nIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuXCJsYXRlc3RcIj09PWU/ZTpwYXJzZUludChlLnN1YnN0cmluZygyKSwxNil9dmFyIHYseT1cIjhGRzNKTVo5VVNTNE5UQTZZS0VLSElOVTU2U0VQUFZCSlJcIixtPSh2PXMuQmFzZVByb3ZpZGVyLGkoZyx2KSxnLnByb3RvdHlwZS5wZXJmb3JtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcyxuPXRoaXMuYmFzZVVybCxpPVwiXCI7dGhpcy5hcGlLZXkmJihpKz1cIiZhcGlrZXk9XCIrdGhpcy5hcGlLZXkpO2Z1bmN0aW9uIG8odCxlKXtyZXR1cm4gbC5mZXRjaEpzb24odCxudWxsLGV8fGQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHIuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInBlcmZvcm1cIixyZXF1ZXN0OnQscmVzcG9uc2U6ZSxwcm92aWRlcjpyfSksZX0pfXZhciBzO3N3aXRjaChlKXtjYXNlXCJnZXRCbG9ja051bWJlclwiOnJldHVybiBvKG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9ibG9ja051bWJlclwiK2kpO2Nhc2VcImdldEdhc1ByaWNlXCI6cmV0dXJuIG8obis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dhc1ByaWNlXCIraSk7Y2FzZVwiZ2V0QmFsYW5jZVwiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPWJhbGFuY2UmYWRkcmVzcz1cIit0LmFkZHJlc3MsbyhuKz1cIiZ0YWc9XCIrdC5ibG9ja1RhZytpLGMpO2Nhc2VcImdldFRyYW5zYWN0aW9uQ291bnRcIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uQ291bnQmYWRkcmVzcz1cIit0LmFkZHJlc3MsbyhuKz1cIiZ0YWc9XCIrdC5ibG9ja1RhZytpKTtjYXNlXCJnZXRDb2RlXCI6cmV0dXJuIG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRDb2RlJmFkZHJlc3M9XCIrdC5hZGRyZXNzLG8obis9XCImdGFnPVwiK3QuYmxvY2tUYWcraSxkKTtjYXNlXCJnZXRTdG9yYWdlQXRcIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFN0b3JhZ2VBdCZhZGRyZXNzPVwiK3QuYWRkcmVzcyxuKz1cIiZwb3NpdGlvbj1cIit0LnBvc2l0aW9uLG8obis9XCImdGFnPVwiK3QuYmxvY2tUYWcraSxkKTtjYXNlXCJzZW5kVHJhbnNhY3Rpb25cIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX3NlbmRSYXdUcmFuc2FjdGlvbiZoZXg9XCIrdC5zaWduZWRUcmFuc2FjdGlvbixvKG4rPWkpLmNhdGNoKGZ1bmN0aW9uKGUpe3Rocm93IGUucmVzcG9uc2VUZXh0JiYoMDw9ZS5yZXNwb25zZVRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZoLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIixoLklOU1VGRklDSUVOVF9GVU5EUyx7fSksMDw9ZS5yZXNwb25zZVRleHQuaW5kZXhPZihcInNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZFwiKSYmaC50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsaC5OT05DRV9FWFBJUkVELHt9KSwwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2VcIikmJmgudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsaC5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7fSkpLGV9KTtjYXNlXCJnZXRCbG9ja1wiOnJldHVybiB0LmJsb2NrVGFnPyhuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0QmxvY2tCeU51bWJlciZ0YWc9XCIrdC5ibG9ja1RhZyx0LmluY2x1ZGVUcmFuc2FjdGlvbnM/bis9XCImYm9vbGVhbj10cnVlXCI6bis9XCImYm9vbGVhbj1mYWxzZVwiLG8obis9aSkpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3QgaW1wbGVtZW5ldGVkXCIpKTtjYXNlXCJnZXRUcmFuc2FjdGlvblwiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gmdHhoYXNoPVwiK3QudHJhbnNhY3Rpb25IYXNoLG8obis9aSk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6cmV0dXJuIG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQmdHhoYXNoPVwiK3QudHJhbnNhY3Rpb25IYXNoLG8obis9aSk7Y2FzZVwiY2FsbFwiOnJldHVybihuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfY2FsbFwiKyhzPShzPWYodC50cmFuc2FjdGlvbikpJiZcIiZcIitzKSxcImxhdGVzdFwiIT09dC5ibG9ja1RhZyk/UHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRXRoZXJzY2FuUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBibG9ja1RhZyBmb3IgY2FsbFwiKSk6byhuKz1pKTtjYXNlXCJlc3RpbWF0ZUdhc1wiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZXN0aW1hdGVHYXMmXCIrKHM9KHM9Zih0LnRyYW5zYWN0aW9uKSkmJlwiJlwiK3MpLG8obis9aSk7Y2FzZVwiZ2V0TG9nc1wiOm4rPVwiL2FwaT9tb2R1bGU9bG9ncyZhY3Rpb249Z2V0TG9nc1wiO3RyeXtpZih0LmZpbHRlci5mcm9tQmxvY2smJihuKz1cIiZmcm9tQmxvY2s9XCIrcCh0LmZpbHRlci5mcm9tQmxvY2spKSx0LmZpbHRlci50b0Jsb2NrJiYobis9XCImdG9CbG9jaz1cIitwKHQuZmlsdGVyLnRvQmxvY2spKSx0LmZpbHRlci5ibG9ja0hhc2gpdHJ5e2gudGhyb3dFcnJvcihcIkV0aGVyc2NhbiBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrSGFzaCBmaWx0ZXJzXCIsaC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImdldExvZ3MoYmxvY2tIYXNoKVwifSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfWlmKHQuZmlsdGVyLmFkZHJlc3MmJihuKz1cIiZhZGRyZXNzPVwiK3QuZmlsdGVyLmFkZHJlc3MpLHQuZmlsdGVyLnRvcGljcyYmMDx0LmZpbHRlci50b3BpY3MubGVuZ3RoKXtpZigxPHQuZmlsdGVyLnRvcGljcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIpO3ZhciBhPXQuZmlsdGVyLnRvcGljc1swXTtpZihcInN0cmluZ1wiIT10eXBlb2YgYXx8NjYhPT1hLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYzAgZm9ybWF0XCIpO24rPVwiJnRvcGljMD1cIithfX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9dmFyIHU9dGhpcztyZXR1cm4gbyhuKz1pLGMpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHI9e30sbj1Qcm9taXNlLnJlc29sdmUoKTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe249bi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXQuYmxvY2tIYXNoP251bGw6KHQuYmxvY2tIYXNoPXJbdC50cmFuc2FjdGlvbkhhc2hdLG51bGw9PXQuYmxvY2tIYXNoP3UuZ2V0VHJhbnNhY3Rpb24odC50cmFuc2FjdGlvbkhhc2gpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHJbdC50cmFuc2FjdGlvbkhhc2hdPWUuYmxvY2tIYXNoLHQuYmxvY2tIYXNoPWUuYmxvY2tIYXNoLG51bGx9KTpudWxsKX0pfSksbi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0pO2Nhc2VcImdldEV0aGVyUHJpY2VcIjpyZXR1cm5cImhvbWVzdGVhZFwiIT09dGhpcy5uZXR3b3JrLm5hbWU/UHJvbWlzZS5yZXNvbHZlKDApOihuKz1cIi9hcGk/bW9kdWxlPXN0YXRzJmFjdGlvbj1ldGhwcmljZVwiLG8obis9aSxjKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUZsb2F0KGUuZXRodXNkKX0pKX1yZXR1cm4gdi5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsZSx0KX0sZy5wcm90b3R5cGUuZ2V0SGlzdG9yeT1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyxpPXRoaXMuYmFzZVVybCxvPVwiXCI7cmV0dXJuIHRoaXMuYXBpS2V5JiYobys9XCImYXBpa2V5PVwiK3RoaXMuYXBpS2V5KSxudWxsPT10JiYodD0wKSxudWxsPT1yJiYocj05OTk5OTk5OSksdGhpcy5yZXNvbHZlTmFtZShlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBpKz1cIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPVwiK2UsaSs9XCImc3RhcnRibG9jaz1cIit0LGkrPVwiJmVuZGJsb2NrPVwiK3IsaSs9XCImc29ydD1hc2NcIitvLGwuZmV0Y2hKc29uKGksbnVsbCxjKS50aGVuKGZ1bmN0aW9uKGUpe24uZW1pdChcImRlYnVnXCIse2FjdGlvbjpcImdldEhpc3RvcnlcIixyZXF1ZXN0OmkscmVzcG9uc2U6ZSxwcm92aWRlcjpufSk7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbih0KXtbXCJjb250cmFjdEFkZHJlc3NcIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7XCJcIj09dFtlXSYmZGVsZXRlIHRbZV19KSxudWxsPT10LmNyZWF0ZXMmJm51bGwhPXQuY29udHJhY3RBZGRyZXNzJiYodC5jcmVhdGVzPXQuY29udHJhY3RBZGRyZXNzKTt2YXIgZT1zLkJhc2VQcm92aWRlci5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2UodCk7dC50aW1lU3RhbXAmJihlLnRpbWVzdGFtcD1wYXJzZUludCh0LnRpbWVTdGFtcCkpLHIucHVzaChlKX0pLHJ9KX0pfSxnKTtmdW5jdGlvbiBnKGUsdCl7dmFyIHI9di5jYWxsKHRoaXMsZSl8fHRoaXM7aC5jaGVja05ldyhyLGcpO3ZhciBuPVwiaW52YWxpZFwiO3IubmV0d29yayYmKG49ci5uZXR3b3JrLm5hbWUpO3ZhciBpPW51bGw7c3dpdGNoKG4pe2Nhc2VcImhvbWVzdGVhZFwiOmk9XCJodHRwczovL2FwaS5ldGhlcnNjYW4uaW9cIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aT1cImh0dHBzOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmk9XCJodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aT1cImh0dHBzOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmk9XCJodHRwczovL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIpfXJldHVybiB1LmRlZmluZVJlYWRPbmx5KHIsXCJiYXNlVXJsXCIsaSksdS5kZWZpbmVSZWFkT25seShyLFwiYXBpS2V5XCIsdHx8eSkscn1yLkV0aGVyc2NhblByb3ZpZGVyPW19LHtcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDUzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooci5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IHIpfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWUoXCIuL2Jhc2UtcHJvdmlkZXJcIiksYT1vKGUoXCIuLi9lcnJvcnNcIikpO2Z1bmN0aW9uIHUodCl7dmFyIHI9ITAsbj1udWxsO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9ZT9udWxsIT1uP24ubmFtZT09PWUubmFtZSYmbi5jaGFpbklkPT09ZS5jaGFpbklkJiYobi5lbnNBZGRyZXNzPT09ZS5lbnNBZGRyZXNzfHxudWxsPT1uLmVuc0FkZHJlc3MmJm51bGw9PWUuZW5zQWRkcmVzcyl8fGEudGhyb3dFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJuZXR3b3Jrc1wiLHZhbHVlOnR9KTpuPWU6cj0hMX0pLHJ9dmFyIGwsaD0obD1zLkJhc2VQcm92aWRlcixpKGYsbCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGYucHJvdG90eXBlLFwicHJvdmlkZXJzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm92aWRlcnMuc2xpY2UoMCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZi5wcm90b3R5cGUucGVyZm9ybT1mdW5jdGlvbihpLG8pe3ZhciBzPXRoaXMucHJvdmlkZXJzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLGUpe3ZhciBuPW51bGw7IWZ1bmN0aW9uIHQoKXtzLmxlbmd0aD9zLnNoaWZ0KCkucGVyZm9ybShpLG8pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl9KS5jYXRjaChmdW5jdGlvbihlKXtuPW58fGUsc2V0VGltZW91dCh0LDApfSk6ZShuKX0oKX0pfSxmKTtmdW5jdGlvbiBmKGUpe3ZhciB0LHI9dGhpcztpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibm8gcHJvdmlkZXJzXCIpO3JldHVybiByPXUoZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmV0d29ya30pKT9sLmNhbGwodGhpcyxlWzBdLm5ldHdvcmspfHx0aGlzOih0PVByb21pc2UuYWxsKGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldE5ldHdvcmsoKX0pKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1KGUpfHxhLnRocm93RXJyb3IoXCJnZXROZXR3b3JrIHJldHVybmVkIG51bGxcIixhLlVOS05PV05fRVJST1Ise30pLGVbMF19KSxsLmNhbGwodGhpcyx0KXx8dGhpcyksYS5jaGVja05ldyhyLGYpLHIuX3Byb3ZpZGVycz1lLnNsaWNlKDApLHJ9ci5GYWxsYmFja1Byb3ZpZGVyPWh9LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDU0OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vYWJzdHJhY3QtcHJvdmlkZXJcIik7ci5Qcm92aWRlcj1uLlByb3ZpZGVyO3ZhciBpPWUoXCIuL2Jhc2UtcHJvdmlkZXJcIik7ci5CYXNlUHJvdmlkZXI9aS5CYXNlUHJvdmlkZXI7dmFyIG89ZShcIi4vZXRoZXJzY2FuLXByb3ZpZGVyXCIpO3IuRXRoZXJzY2FuUHJvdmlkZXI9by5FdGhlcnNjYW5Qcm92aWRlcjt2YXIgcz1lKFwiLi9mYWxsYmFjay1wcm92aWRlclwiKTtyLkZhbGxiYWNrUHJvdmlkZXI9cy5GYWxsYmFja1Byb3ZpZGVyO3ZhciBhPWUoXCIuL2lwYy1wcm92aWRlclwiKTtyLklwY1Byb3ZpZGVyPWEuSXBjUHJvdmlkZXI7dmFyIHU9ZShcIi4vaW5mdXJhLXByb3ZpZGVyXCIpO3IuSW5mdXJhUHJvdmlkZXI9dS5JbmZ1cmFQcm92aWRlcjt2YXIgbD1lKFwiLi9qc29uLXJwYy1wcm92aWRlclwiKTtyLkpzb25ScGNQcm92aWRlcj1sLkpzb25ScGNQcm92aWRlcixyLkpzb25ScGNTaWduZXI9bC5Kc29uUnBjU2lnbmVyO3ZhciBoPWUoXCIuL3dlYjMtcHJvdmlkZXJcIik7ci5XZWIzUHJvdmlkZXI9aC5XZWIzUHJvdmlkZXJ9LHtcIi4vYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vYmFzZS1wcm92aWRlclwiOjUxLFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIjo1MixcIi4vZmFsbGJhY2stcHJvdmlkZXJcIjo1MyxcIi4vaW5mdXJhLXByb3ZpZGVyXCI6NTUsXCIuL2lwYy1wcm92aWRlclwiOjU2LFwiLi9qc29uLXJwYy1wcm92aWRlclwiOjU3LFwiLi93ZWIzLXByb3ZpZGVyXCI6NTh9XSw1NTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxhPWUoXCIuL2pzb24tcnBjLXByb3ZpZGVyXCIpLHU9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGw9ZShcIi4uL3V0aWxzL25ldHdvcmtzXCIpLGg9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksZj1vKGUoXCIuLi9lcnJvcnNcIikpLGM9XCI3ZDBkODFkMDkxOWY0ZjA1YjlhYjY2MzRiZTAxZWU3M1wiLGQ9KHM9YS5Kc29uUnBjUHJvdmlkZXIsaShwLHMpLHAucHJvdG90eXBlLl9zdGFydFBlbmRpbmc9ZnVuY3Rpb24oKXtmLndhcm4oXCJXQVJOSU5HOiBJTkZVUkEgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnNcIil9LHAucHJvdG90eXBlLmdldFNpZ25lcj1mdW5jdGlvbihlKXtyZXR1cm4gZi50aHJvd0Vycm9yKFwiSU5GVVJBIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLGYuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRTaWduZXJcIn0pfSxwLnByb3RvdHlwZS5saXN0QWNjb3VudHM9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKX0scCk7ZnVuY3Rpb24gcChlLHQpe3ZhciByPXRoaXMsbj1sLmdldE5ldHdvcmsobnVsbD09ZT9cImhvbWVzdGVhZFwiOmUpO251bGw9PXQmJih0PWMpO3ZhciBpPW51bGw7c3dpdGNoKG4ubmFtZSl7Y2FzZVwiaG9tZXN0ZWFkXCI6aT1cIm1haW5uZXQuaW5mdXJhLmlvXCI7YnJlYWs7Y2FzZVwicm9wc3RlblwiOmk9XCJyb3BzdGVuLmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcInJpbmtlYnlcIjppPVwicmlua2VieS5pbmZ1cmEuaW9cIjticmVhaztjYXNlXCJnb2VybGlcIjppPVwiZ29lcmxpLmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aT1cImtvdmFuLmluZnVyYS5pb1wiO2JyZWFrO2RlZmF1bHQ6Zi50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLGYuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJuZXR3b3JrXCIsdmFsdWU6ZX0pfXJldHVybiB1LmlzSGV4U3RyaW5nKFwiMHhcIit0LDE2KT8ocj1zLmNhbGwodGhpcyxcImh0dHBzOi8vXCIraStcIi92My9cIit0LG4pfHx0aGlzLGguZGVmaW5lUmVhZE9ubHkocixcImFwaUFjY2Vzc1Rva2VuXCIsbnVsbCksaC5kZWZpbmVSZWFkT25seShyLFwicHJvamVjdElkXCIsdCkpOihmLndhcm4oXCJUaGUgbGVnYWN5IElORlVSQSBhcGlBY2Nlc1Rva2VuIEFQSSBpcyBkZXByZWNhdGVkOyBwbGVhc2UgdXBncmFkZSB0byBhIFByb2plY3QgSUQgaW5zdGVhZCAoc2VlIElORlVSQSBkc2hib2FyZDsgaHR0cHM6Ly9pbmZ1cmEuaW8pXCIpLHI9cy5jYWxsKHRoaXMsXCJodHRwczovL1wiK2krXCIvXCIrdCxuKXx8dGhpcyxoLmRlZmluZVJlYWRPbmx5KHIsXCJhcGlBY2Nlc3NUb2tlblwiLHQpLGguZGVmaW5lUmVhZE9ubHkocixcInByb2plY3RJZFwiLG51bGwpKSxmLmNoZWNrTmV3KHIscCkscn1yLkluZnVyYVByb3ZpZGVyPWR9LHtcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi4vdXRpbHMvbmV0d29ya3NcIjo3MixcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIjo3NCxcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjo1N31dLDU2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHt9XSw1NzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1lKFwiLi9iYXNlLXByb3ZpZGVyXCIpLGE9ZShcIi4uL2Fic3RyYWN0LXNpZ25lclwiKSx1PW8oZShcIi4uL2Vycm9yc1wiKSksbD1lKFwiLi4vdXRpbHMvYWRkcmVzc1wiKSxoPWUoXCIuLi91dGlscy9ieXRlc1wiKSxmPWUoXCIuLi91dGlscy9uZXR3b3Jrc1wiKSxjPWUoXCIuLi91dGlscy9wcm9wZXJ0aWVzXCIpLGQ9ZShcIi4uL3V0aWxzL3V0ZjhcIikscD1lKFwiLi4vdXRpbHMvd2ViXCIpO2Z1bmN0aW9uIHYoZSl7aWYoZS5lcnJvcil7dmFyIHQ9bmV3IEVycm9yKGUuZXJyb3IubWVzc2FnZSk7dGhyb3cgdC5jb2RlPWUuZXJyb3IuY29kZSx0LmRhdGE9ZS5lcnJvci5kYXRhLHR9cmV0dXJuIGUucmVzdWx0fWZ1bmN0aW9uIHkoZSl7cmV0dXJuIGU/ZS50b0xvd2VyQ2FzZSgpOmV9dmFyIG0sZz17fSxiPTQyLHc9KG09YS5TaWduZXIsaShfLG0pLF8ucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiB0aGlzLl9hZGRyZXNzP1Byb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTp0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGg8PXQuX2luZGV4JiZ1LnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiK3QuX2luZGV4LHUuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRBZGRyZXNzXCJ9KSx0Ll9hZGRyZXNzPWwuZ2V0QWRkcmVzcyhlW3QuX2luZGV4XSksdC5fYWRkcmVzc30pfSxfLnByb3RvdHlwZS5nZXRCYWxhbmNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksZSl9LF8ucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmdldEFkZHJlc3MoKSxlKX0sXy5wcm90b3R5cGUuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7ZT1jLnNoYWxsb3dDb3B5KGUpO3ZhciB0LHI9dGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZT1lJiZlLnRvTG93ZXJDYXNlKCl9KTtyZXR1cm4gbnVsbD09ZS5nYXNMaW1pdCYmKCh0PWMuc2hhbGxvd0NvcHkoZSkpLmZyb209cixlLmdhc0xpbWl0PXRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXModCkpLFByb21pc2UuYWxsKFtjLnJlc29sdmVQcm9wZXJ0aWVzKGUpLHJdKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0scj1FLmhleGxpZnlUcmFuc2FjdGlvbih0KTtyZXR1cm4gci5mcm9tPWVbMV0sbi5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFtyXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZX0sZnVuY3Rpb24oZSl7dGhyb3cgZS5yZXNwb25zZVRleHQmJigwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZ1LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIix1LklOU1VGRklDSUVOVF9GVU5EUyx7dHJhbnNhY3Rpb246dH0pLDA8PWUucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJub25jZSB0b28gbG93XCIpJiZ1LnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIix1Lk5PTkNFX0VYUElSRUQse3RyYW5zYWN0aW9uOnR9KSwwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIikmJnUudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsdS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7dHJhbnNhY3Rpb246dH0pKSxlfSl9KX0sXy5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKGUpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHAucG9sbChmdW5jdGlvbigpe3JldHVybiByLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHQpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbCE9PWUpcmV0dXJuIHIucHJvdmlkZXIuX3dyYXBUcmFuc2FjdGlvbihlLHQpfSl9LHtmYXN0UmV0cnk6MjUwLG9uY2VCbG9jazpyLnByb3ZpZGVyfSkuY2F0Y2goZnVuY3Rpb24oZSl7dGhyb3cgZS50cmFuc2FjdGlvbkhhc2g9dCxlfSl9KX0sXy5wcm90b3R5cGUuc2lnbk1lc3NhZ2U9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPVwic3RyaW5nXCI9PXR5cGVvZiBlP2QudG9VdGY4Qnl0ZXMoZSk6ZTtyZXR1cm4gdGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdC5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIixbZS50b0xvd2VyQ2FzZSgpLGguaGV4bGlmeShyKV0pfSl9LF8ucHJvdG90eXBlLnVubG9jaz1mdW5jdGlvbih0KXt2YXIgcj10aGlzLnByb3ZpZGVyO3JldHVybiB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsW2UudG9Mb3dlckNhc2UoKSx0LG51bGxdKX0pfSxfKTtmdW5jdGlvbiBfKGUsdCxyKXt2YXIgbj1tLmNhbGwodGhpcyl8fHRoaXM7aWYodS5jaGVja05ldyhuLF8pLGUhPT1nKXRocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpO3JldHVybiBjLmRlZmluZVJlYWRPbmx5KG4sXCJwcm92aWRlclwiLHQpLHI/XCJzdHJpbmdcIj09dHlwZW9mIHI/Yy5kZWZpbmVSZWFkT25seShuLFwiX2FkZHJlc3NcIixsLmdldEFkZHJlc3MocikpOlwibnVtYmVyXCI9PXR5cGVvZiByP2MuZGVmaW5lUmVhZE9ubHkobixcIl9pbmRleFwiLHIpOnUudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJhZGRyZXNzT3JJbmRleFwiLHZhbHVlOnJ9KTpjLmRlZmluZVJlYWRPbmx5KG4sXCJfaW5kZXhcIiwwKSxufXIuSnNvblJwY1NpZ25lcj13O3ZhciBNLEE9e2NoYWluSWQ6ITAsZGF0YTohMCxnYXNMaW1pdDohMCxnYXNQcmljZTohMCxub25jZTohMCx0bzohMCx2YWx1ZTohMH0sRT0oTT1zLkJhc2VQcm92aWRlcixpKFMsTSksUy5wcm90b3R5cGUuZ2V0U2lnbmVyPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdyhnLHRoaXMsZSl9LFMucHJvdG90eXBlLmxpc3RBY2NvdW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGwuZ2V0QWRkcmVzcyhlKX0pfSl9LFMucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLG49e21ldGhvZDplLHBhcmFtczp0LGlkOmIrKyxqc29ucnBjOlwiMi4wXCJ9O3JldHVybiBwLmZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sSlNPTi5zdHJpbmdpZnkobiksdikudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwic2VuZFwiLHJlcXVlc3Q6bixyZXNwb25zZTplLHByb3ZpZGVyOnJ9KSxlfSl9LFMucHJvdG90eXBlLnBlcmZvcm09ZnVuY3Rpb24oZSx0KXtzd2l0Y2goZSl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2Jsb2NrTnVtYmVyXCIsW10pO2Nhc2VcImdldEdhc1ByaWNlXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nYXNQcmljZVwiLFtdKTtjYXNlXCJnZXRCYWxhbmNlXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nZXRCYWxhbmNlXCIsW3kodC5hZGRyZXNzKSx0LmJsb2NrVGFnXSk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFt5KHQuYWRkcmVzcyksdC5ibG9ja1RhZ10pO2Nhc2VcImdldENvZGVcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2dldENvZGVcIixbeSh0LmFkZHJlc3MpLHQuYmxvY2tUYWddKTtjYXNlXCJnZXRTdG9yYWdlQXRcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2dldFN0b3JhZ2VBdFwiLFt5KHQuYWRkcmVzcyksdC5wb3NpdGlvbix0LmJsb2NrVGFnXSk7Y2FzZVwic2VuZFRyYW5zYWN0aW9uXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixbdC5zaWduZWRUcmFuc2FjdGlvbl0pLmNhdGNoKGZ1bmN0aW9uKGUpe3Rocm93IGUucmVzcG9uc2VUZXh0JiYoMDxlLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZ1LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIix1LklOU1VGRklDSUVOVF9GVU5EUyx7fSksMDxlLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwibm9uY2UgdG9vIGxvd1wiKSYmdS50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsdS5OT05DRV9FWFBJUkVELHt9KSwwPGUucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiKSYmdS50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIix1LlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELHt9KSksZX0pO2Nhc2VcImdldEJsb2NrXCI6cmV0dXJuIHQuYmxvY2tUYWc/dGhpcy5zZW5kKFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixbdC5ibG9ja1RhZywhIXQuaW5jbHVkZVRyYW5zYWN0aW9uc10pOnQuYmxvY2tIYXNoP3RoaXMuc2VuZChcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFt0LmJsb2NrSGFzaCwhIXQuaW5jbHVkZVRyYW5zYWN0aW9uc10pOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgYmxvY2sgdGFnIG9yIGJsb2NrIGhhc2hcIikpO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFt0LnRyYW5zYWN0aW9uSGFzaF0pO2Nhc2VcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsW3QudHJhbnNhY3Rpb25IYXNoXSk7Y2FzZVwiY2FsbFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfY2FsbFwiLFtTLmhleGxpZnlUcmFuc2FjdGlvbih0LnRyYW5zYWN0aW9uLHtmcm9tOiEwfSksdC5ibG9ja1RhZ10pO2Nhc2VcImVzdGltYXRlR2FzXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9lc3RpbWF0ZUdhc1wiLFtTLmhleGxpZnlUcmFuc2FjdGlvbih0LnRyYW5zYWN0aW9uLHtmcm9tOiEwfSldKTtjYXNlXCJnZXRMb2dzXCI6cmV0dXJuIHQuZmlsdGVyJiZudWxsIT10LmZpbHRlci5hZGRyZXNzJiYodC5maWx0ZXIuYWRkcmVzcz15KHQuZmlsdGVyLmFkZHJlc3MpKSx0aGlzLnNlbmQoXCJldGhfZ2V0TG9nc1wiLFt0LmZpbHRlcl0pfXJldHVybiB1LnRocm93RXJyb3IoZStcIiBub3QgaW1wbGVtZW50ZWRcIix1Lk5PVF9JTVBMRU1FTlRFRCx7b3BlcmF0aW9uOmV9KSxudWxsfSxTLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nPWZ1bmN0aW9uKCl7dmFyIHIsbjtudWxsPT10aGlzLl9wZW5kaW5nRmlsdGVyJiYobj0ocj10aGlzKS5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLFtdKSwodGhpcy5fcGVuZGluZ0ZpbHRlcj1uKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbiBlKCl7ci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIixbdF0pLnRoZW4oZnVuY3Rpb24oZSl7aWYoci5fcGVuZGluZ0ZpbHRlciE9bilyZXR1cm4gbnVsbDt2YXIgdD1Qcm9taXNlLnJlc29sdmUoKTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IuX2VtaXR0ZWRbXCJ0OlwiK2UudG9Mb3dlckNhc2UoKV09XCJwZW5kaW5nXCIsdD10LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gci5nZXRUcmFuc2FjdGlvbihlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByLmVtaXQoXCJwZW5kaW5nXCIsZSksbnVsbH0pfSl9KSx0LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdD0xZTMsbmV3IFByb21pc2UoZnVuY3Rpb24oZSl7c2V0VGltZW91dChmdW5jdGlvbigpe2UoKX0sdCl9KTt2YXIgdH0pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiByLl9wZW5kaW5nRmlsdGVyPT1uPyhzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZSgpfSwwKSxudWxsKTp2b2lkIHIuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIixbdF0pfSkuY2F0Y2goZnVuY3Rpb24oZSl7fSl9KCksdH0pLmNhdGNoKGZ1bmN0aW9uKGUpe30pKX0sUy5wcm90b3R5cGUuX3N0b3BQZW5kaW5nPWZ1bmN0aW9uKCl7dGhpcy5fcGVuZGluZ0ZpbHRlcj1udWxsfSxTLmhleGxpZnlUcmFuc2FjdGlvbj1mdW5jdGlvbihyLGUpe3ZhciB0PWMuc2hhbGxvd0NvcHkoQSk7aWYoZSlmb3IodmFyIG4gaW4gZSllW25dJiYodFtuXT0hMCk7Yy5jaGVja1Byb3BlcnRpZXMocix0KTt2YXIgaT17fTtyZXR1cm5bXCJnYXNMaW1pdFwiLFwiZ2FzUHJpY2VcIixcIm5vbmNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0O251bGwhPXJbZV0mJih0PWguaGV4U3RyaXBaZXJvcyhoLmhleGxpZnkocltlXSkpLFwiZ2FzTGltaXRcIj09PWUmJihlPVwiZ2FzXCIpLGlbZV09dCl9KSxbXCJmcm9tXCIsXCJ0b1wiLFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPXJbZV0mJihpW2VdPWguaGV4bGlmeShyW2VdKSl9KSxpfSxTKTtmdW5jdGlvbiBTKGUsdCl7dmFyIHIsbj10aGlzO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiZudWxsPT09dCYmZi5nZXROZXR3b3JrKGUpJiYodD1lLGU9bnVsbCksbj10P00uY2FsbCh0aGlzLHQpfHx0aGlzOihyPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7c2V0VGltZW91dChmdW5jdGlvbigpe24uc2VuZChcIm5ldF92ZXJzaW9uXCIsW10pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHQoZi5nZXROZXR3b3JrKHBhcnNlSW50KGUpKSl9KS5jYXRjaChmdW5jdGlvbihlKXtyKGUpfSl9KX0pLE0uY2FsbCh0aGlzLHIpfHx0aGlzKSx1LmNoZWNrTmV3KG4sUyksZT1lfHxcImh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVwiLG4uY29ubmVjdGlvbj1cInN0cmluZ1wiPT10eXBlb2YgZT97dXJsOmV9OmUsbn1yLkpzb25ScGNQcm92aWRlcj1FfSx7XCIuLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi4vZXJyb3JzXCI6NSxcIi4uL3V0aWxzL2FkZHJlc3NcIjo2MCxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9uZXR3b3Jrc1wiOjcyLFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvdXRmOFwiOjg1LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDU4OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooci5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IHIpfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLGE9ZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIiksdT1lKFwiLi4vdXRpbHMvcHJvcGVydGllc1wiKSxsPW8oZShcIi4uL2Vycm9yc1wiKSksaD00MixmPShzPWEuSnNvblJwY1Byb3ZpZGVyLGkoYyxzKSxjLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQscil7dmFyIG89dGhpcztyZXR1cm5cImV0aF9zaWduXCI9PXQmJnRoaXMuX3dlYjNQcm92aWRlci5pc01ldGFNYXNrJiYodD1cInBlcnNvbmFsX3NpZ25cIixyPVtyWzFdLHJbMF1dKSxuZXcgUHJvbWlzZShmdW5jdGlvbihuLGkpe3ZhciBlPXttZXRob2Q6dCxwYXJhbXM6cixpZDpoKyssanNvbnJwYzpcIjIuMFwifTtvLl9zZW5kQXN5bmMoZSxmdW5jdGlvbihlLHQpe2lmKGUpaShlKTtlbHNle2lmKHQuZXJyb3Ipe3ZhciByPW5ldyBFcnJvcih0LmVycm9yLm1lc3NhZ2UpO3JldHVybiByLmNvZGU9dC5lcnJvci5jb2RlLHIuZGF0YT10LmVycm9yLmRhdGEsdm9pZCBpKHIpfW4odC5yZXN1bHQpfX0pfSl9LGMpO2Z1bmN0aW9uIGMoZSx0KXt2YXIgcj1zLmNhbGwodGhpcyxlLmhvc3R8fGUucGF0aHx8XCJcIix0KXx8dGhpcztyZXR1cm4gbC5jaGVja05ldyhyLGMpLGUmJihlLnNlbmRBc3luYz9yLl9zZW5kQXN5bmM9ZS5zZW5kQXN5bmMuYmluZChlKTplLnNlbmQmJihyLl9zZW5kQXN5bmM9ZS5zZW5kLmJpbmQoZSkpKSxlJiZyLl9zZW5kQXN5bmN8fGwudGhyb3dFcnJvcihcImludmFsaWQgd2ViM1Byb3ZpZGVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ3ZWIzUHJvdmlkZXJcIix2YWx1ZTplfSksdS5kZWZpbmVSZWFkT25seShyLFwiX3dlYjNQcm92aWRlclwiLGUpLHUuZGVmaW5lUmVhZE9ubHkocixcInByb3ZpZGVyXCIsZSkscn1yLldlYjNQcm92aWRlcj1mfSx7XCIuLi9lcnJvcnNcIjo1LFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi9qc29uLXJwYy1wcm92aWRlclwiOjU3fV0sNTk6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZShcIi4uL2NvbnN0YW50c1wiKSxsPW8oZShcIi4uL2Vycm9yc1wiKSksYT1lKFwiLi9hZGRyZXNzXCIpLHU9ZShcIi4vYmlnbnVtYmVyXCIpLGg9ZShcIi4vYnl0ZXNcIiksZj1lKFwiLi91dGY4XCIpLGM9ZShcIi4vcHJvcGVydGllc1wiKSxkPW5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pLHA9bmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKSx2PW5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7ci5kZWZhdWx0Q29lcmNlRnVuYz1mdW5jdGlvbihlLHQpe3ZhciByPWUubWF0Y2gocCk7cmV0dXJuIHImJnBhcnNlSW50KHJbMl0pPD00OD90LnRvTnVtYmVyKCk6dH07dmFyIHk9bmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpLG09bmV3IFJlZ0V4cChcIl5bQS1aYS16X11bQS1aYS16MC05X10qJFwiKTtmdW5jdGlvbiBnKGUpe3JldHVybiBlLm1hdGNoKC9edWludCgkfFteMS05XSkvKT9lPVwidWludDI1NlwiK2Uuc3Vic3RyaW5nKDQpOmUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykmJihlPVwiaW50MjU2XCIrZS5zdWJzdHJpbmcoMykpLGV9ZnVuY3Rpb24gYihlLHQpe3ZhciByPWU7ZnVuY3Rpb24gbihlKXt0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJytyW2VdKydcIiBhdCBwb3NpdGlvbiAnK2UrJyBpbiBcIicrcisnXCInKX1lPWUucmVwbGFjZSgvXFxzL2csXCIgXCIpO2Zvcih2YXIgaT17dHlwZTpcIlwiLG5hbWU6XCJcIixzdGF0ZTp7YWxsb3dUeXBlOiEwfX0sbz1pLHM9MDtzPGUubGVuZ3RoO3MrKyl7dmFyIGE9ZVtzXTtzd2l0Y2goYSl7Y2FzZVwiKFwiOm8uc3RhdGUuYWxsb3dQYXJhbXN8fG4ocyksby5zdGF0ZS5hbGxvd1R5cGU9ITEsby50eXBlPWcoby50eXBlKSxvLmNvbXBvbmVudHM9W3t0eXBlOlwiXCIsbmFtZTpcIlwiLHBhcmVudDpvLHN0YXRlOnthbGxvd1R5cGU6ITB9fV0sbz1vLmNvbXBvbmVudHNbMF07YnJlYWs7Y2FzZVwiKVwiOmRlbGV0ZSBvLnN0YXRlLHQmJlwiaW5kZXhlZFwiPT09by5uYW1lJiYoby5pbmRleGVkPSEwLG8ubmFtZT1cIlwiKSxvLnR5cGU9ZyhvLnR5cGUpO3ZhciB1PW87KG89by5wYXJlbnQpfHxuKHMpLGRlbGV0ZSB1LnBhcmVudCxvLnN0YXRlLmFsbG93UGFyYW1zPSExLG8uc3RhdGUuYWxsb3dOYW1lPSEwLG8uc3RhdGUuYWxsb3dBcnJheT0hMDticmVhaztjYXNlXCIsXCI6ZGVsZXRlIG8uc3RhdGUsdCYmXCJpbmRleGVkXCI9PT1vLm5hbWUmJihvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpLG8udHlwZT1nKG8udHlwZSk7dmFyIGw9e3R5cGU6XCJcIixuYW1lOlwiXCIscGFyZW50Om8ucGFyZW50LHN0YXRlOnthbGxvd1R5cGU6ITB9fTtvLnBhcmVudC5jb21wb25lbnRzLnB1c2gobCksZGVsZXRlIG8ucGFyZW50LG89bDticmVhaztjYXNlXCIgXCI6by5zdGF0ZS5hbGxvd1R5cGUmJlwiXCIhPT1vLnR5cGUmJihvLnR5cGU9ZyhvLnR5cGUpLGRlbGV0ZSBvLnN0YXRlLmFsbG93VHlwZSxvLnN0YXRlLmFsbG93TmFtZT0hMCxvLnN0YXRlLmFsbG93UGFyYW1zPSEwKSxvLnN0YXRlLmFsbG93TmFtZSYmXCJcIiE9PW8ubmFtZSYmKHQmJlwiaW5kZXhlZFwiPT09by5uYW1lPyhvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpOm8uc3RhdGUuYWxsb3dOYW1lPSExKTticmVhaztjYXNlXCJbXCI6by5zdGF0ZS5hbGxvd0FycmF5fHxuKHMpLG8udHlwZSs9YSxvLnN0YXRlLmFsbG93QXJyYXk9ITEsby5zdGF0ZS5hbGxvd05hbWU9ITEsby5zdGF0ZS5yZWFkQXJyYXk9ITA7YnJlYWs7Y2FzZVwiXVwiOm8uc3RhdGUucmVhZEFycmF5fHxuKHMpLG8udHlwZSs9YSxvLnN0YXRlLnJlYWRBcnJheT0hMSxvLnN0YXRlLmFsbG93QXJyYXk9ITAsby5zdGF0ZS5hbGxvd05hbWU9ITA7YnJlYWs7ZGVmYXVsdDpvLnN0YXRlLmFsbG93VHlwZT8oby50eXBlKz1hLG8uc3RhdGUuYWxsb3dQYXJhbXM9ITAsby5zdGF0ZS5hbGxvd0FycmF5PSEwKTpvLnN0YXRlLmFsbG93TmFtZT8oby5uYW1lKz1hLGRlbGV0ZSBvLnN0YXRlLmFsbG93QXJyYXkpOm8uc3RhdGUucmVhZEFycmF5P28udHlwZSs9YTpuKHMpfX1pZihvLnBhcmVudCl0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiKTtyZXR1cm4gZGVsZXRlIGkuc3RhdGUsdCYmXCJpbmRleGVkXCI9PT1vLm5hbWUmJihvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpLGkudHlwZT1nKGkudHlwZSksaX1mdW5jdGlvbiB3KGUpe3JldHVybiBzZShyLmRlZmF1bHRDb2VyY2VGdW5jLGUpLnR5cGV9ci5wYXJzZVBhcmFtVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gYihlLCEwKX0sci5mb3JtYXRQYXJhbVR5cGU9dyxyLmZvcm1hdFNpZ25hdHVyZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lK1wiKFwiK2UuaW5wdXRzLm1hcCh3KS5qb2luKFwiLFwiKStcIilcIn0sci5wYXJzZVNpZ25hdHVyZT1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm5cImV2ZW50IFwiPT09KGU9KGU9KGU9ZS5yZXBsYWNlKC9cXHMvZyxcIiBcIikpLnJlcGxhY2UoL1xcKC9nLFwiIChcIikucmVwbGFjZSgvXFwpL2csXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpKS50cmltKCkpLnN1YnN0cmluZygwLDYpP2Z1bmN0aW9uKGUpe3ZhciB0PXthbm9ueW1vdXM6ITEsaW5wdXRzOltdLG5hbWU6XCJcIix0eXBlOlwiZXZlbnRcIn0scj1lLm1hdGNoKHkpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQ6IFwiK2UpO2lmKHQubmFtZT1yWzFdLnRyaW0oKSxpZShyWzJdKS5mb3JFYWNoKGZ1bmN0aW9uKGUpeyhlPWIoZSwhMCkpLmluZGV4ZWQ9ISFlLmluZGV4ZWQsdC5pbnB1dHMucHVzaChlKX0pLHJbM10uc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcImFub255bW91c1wiOnQuYW5vbnltb3VzPSEwO2JyZWFrO2Nhc2VcIlwiOmJyZWFrO2RlZmF1bHQ6bC5pbmZvKFwidW5rbm93biBtb2RpZmllcjogXCIrZSl9fSksdC5uYW1lJiYhdC5uYW1lLm1hdGNoKG0pKXRocm93IG5ldyBFcnJvcignaW52YWxpZCBpZGVudGlmaWVyOiBcIicrdC5uYW1lKydcIicpO3JldHVybiB0fShlLnN1YnN0cmluZyg2KS50cmltKCkpOihcImZ1bmN0aW9uIFwiPT09ZS5zdWJzdHJpbmcoMCw5KSYmKGU9ZS5zdWJzdHJpbmcoOSkpLGZ1bmN0aW9uKGUpe3ZhciB0PXtjb25zdGFudDohMSxnYXM6bnVsbCxpbnB1dHM6W10sbmFtZTpcIlwiLG91dHB1dHM6W10scGF5YWJsZTohMSxzdGF0ZU11dGFiaWxpdHk6bnVsbCx0eXBlOlwiZnVuY3Rpb25cIn0scj1lLnNwbGl0KFwiQFwiKTtpZigxIT09ci5sZW5ndGgpe2lmKDI8ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmVcIik7aWYoIXJbMV0ubWF0Y2goL15bMC05XSskLykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgZ2FzXCIpO3QuZ2FzPXUuYmlnTnVtYmVyaWZ5KHJbMV0pLGU9clswXX12YXIgbj0ocj1lLnNwbGl0KFwiIHJldHVybnMgXCIpKVswXS5tYXRjaCh5KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpZ25hdHVyZVwiKTtpZih0Lm5hbWU9blsxXS50cmltKCksIXQubmFtZS5tYXRjaChtKSl0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWRlbnRpZmllcjogXCInK25bMV0rJ1wiJyk7aWYoaWUoblsyXSkuZm9yRWFjaChmdW5jdGlvbihlKXt0LmlucHV0cy5wdXNoKGIoZSkpfSksblszXS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZVwiY29uc3RhbnRcIjp0LmNvbnN0YW50PSEwO2JyZWFrO2Nhc2VcInBheWFibGVcIjp0LnBheWFibGU9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJwYXlhYmxlXCI7YnJlYWs7Y2FzZVwicHVyZVwiOnQuY29uc3RhbnQ9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJwdXJlXCI7YnJlYWs7Y2FzZVwidmlld1wiOnQuY29uc3RhbnQ9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJ2aWV3XCI7YnJlYWs7Y2FzZVwiZXh0ZXJuYWxcIjpjYXNlXCJwdWJsaWNcIjpjYXNlXCJcIjpicmVhaztkZWZhdWx0OmwuaW5mbyhcInVua25vd24gbW9kaWZpZXI6IFwiK2UpfX0pLDE8ci5sZW5ndGgpe3ZhciBpPXJbMV0ubWF0Y2goeSk7aWYoXCJcIiE9aVsxXS50cmltKCl8fFwiXCIhPWlbM10udHJpbSgpKXRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIpO2llKGlbMl0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5vdXRwdXRzLnB1c2goYihlKSl9KX1pZihcImNvbnN0cnVjdG9yXCI9PT10Lm5hbWUpe2lmKHQudHlwZT1cImNvbnN0cnVjdG9yXCIsdC5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RvciBtYXkgbm90IGhhdmUgb3V0cHV0c1wiKTtkZWxldGUgdC5uYW1lLGRlbGV0ZSB0Lm91dHB1dHN9cmV0dXJuIHR9KGUudHJpbSgpKSk7dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBzaWduYXR1cmVcIil9O2Z1bmN0aW9uIF8oZSx0LHIsbixpKXt0aGlzLmNvZXJjZUZ1bmM9ZSx0aGlzLm5hbWU9dCx0aGlzLnR5cGU9cix0aGlzLmxvY2FsTmFtZT1uLHRoaXMuZHluYW1pYz1pfXZhciBNLEE9KGkoRSxNPV8pLEUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUoZSl9LEUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNvZGVyLmRlY29kZShlLHQpfSxFKTtmdW5jdGlvbiBFKGUpe3ZhciB0PU0uY2FsbCh0aGlzLGUuY29lcmNlRnVuYyxlLm5hbWUsZS50eXBlLHZvaWQgMCxlLmR5bmFtaWMpfHx0aGlzO3JldHVybiBjLmRlZmluZVJlYWRPbmx5KHQsXCJjb2RlclwiLGUpLHR9dmFyIFMsaz0oaShOLFM9XyksTi5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBoLmFycmF5aWZ5KFtdKX0sTi5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7aWYodD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG51bGxcIik7cmV0dXJue2NvbnN1bWVkOjAsdmFsdWU6dGhpcy5jb2VyY2VGdW5jKFwibnVsbFwiLHZvaWQgMCl9fSxOKTtmdW5jdGlvbiBOKGUsdCl7cmV0dXJuIFMuY2FsbCh0aGlzLGUsXCJudWxsXCIsXCJcIix0LCExKXx8dGhpc312YXIgeCxQPShpKEkseD1fKSxJLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCl7dHJ5e3ZhciBlPXUuYmlnTnVtYmVyaWZ5KHQpO2lmKHRoaXMuc2lnbmVkKXt2YXIgcj1zLk1heFVpbnQyNTYubWFza24oOCp0aGlzLnNpemUtMSk7aWYoZS5ndChyKSl0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO2lmKHI9ci5hZGQocy5PbmUpLm11bChzLk5lZ2F0aXZlT25lKSxlLmx0KHIpKXRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIil9ZWxzZSBpZihlLmx0KHMuWmVybyl8fGUuZ3Qocy5NYXhVaW50MjU2Lm1hc2tuKDgqdGhpcy5zaXplKSkpdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtyZXR1cm4gZT1lLnRvVHdvcyg4KnRoaXMuc2l6ZSkubWFza24oOCp0aGlzLnNpemUpLHRoaXMuc2lnbmVkJiYoZT1lLmZyb21Ud29zKDgqdGhpcy5zaXplKS50b1R3b3MoMjU2KSksaC5wYWRaZXJvcyhoLmFycmF5aWZ5KGUpLDMyKX1jYXRjaChlKXtsLnRocm93RXJyb3IoXCJpbnZhbGlkIG51bWJlciB2YWx1ZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTp0aGlzLm5hbWUsdmFsdWU6dH0pfXJldHVybiBudWxsfSxJLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlLmxlbmd0aDx0KzMyJiZsLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBmb3IgXCIrdGhpcy5uYW1lK1wiIHR5cGVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6dGhpcy5uYW1lLHZhbHVlOmguaGV4bGlmeShlLnNsaWNlKHQsdCszMikpfSk7dmFyIHI9MzItdGhpcy5zaXplLG49dS5iaWdOdW1iZXJpZnkoZS5zbGljZSh0K3IsdCszMikpLG49dGhpcy5zaWduZWQ/bi5mcm9tVHdvcyg4KnRoaXMuc2l6ZSk6bi5tYXNrbig4KnRoaXMuc2l6ZSk7cmV0dXJue2NvbnN1bWVkOjMyLHZhbHVlOnRoaXMuY29lcmNlRnVuYyh0aGlzLm5hbWUsbil9fSxJKTtmdW5jdGlvbiBJKGUsdCxyLG4pe3ZhciBpPXRoaXMsbz0ocj9cImludFwiOlwidWludFwiKSs4KnQ7cmV0dXJuKGk9eC5jYWxsKHRoaXMsZSxvLG8sbiwhMSl8fHRoaXMpLnNpemU9dCxpLnNpZ25lZD1yLGl9dmFyIFQsUj1uZXcgUChmdW5jdGlvbihlLHQpe3JldHVybiB0fSwzMiwhMSxcIm5vbmVcIiksTz0oaShDLFQ9XyksQy5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBSLmVuY29kZShlPzE6MCl9LEMucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3RyeXt2YXIgcj1SLmRlY29kZShlLHQpfWNhdGNoKGUpe3Rocm93XCJpbnN1ZmZpY2llbnQgZGF0YSBmb3IgdWludDI1NiB0eXBlXCI9PT1lLnJlYXNvbiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGJvb2xlYW4gdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImJvb2xlYW5cIix2YWx1ZTplLnZhbHVlfSksZX1yZXR1cm57Y29uc3VtZWQ6ci5jb25zdW1lZCx2YWx1ZTp0aGlzLmNvZXJjZUZ1bmMoXCJib29sXCIsIXIudmFsdWUuaXNaZXJvKCkpfX0sQyk7ZnVuY3Rpb24gQyhlLHQpe3JldHVybiBULmNhbGwodGhpcyxlLFwiYm9vbFwiLFwiYm9vbFwiLHQsITEpfHx0aGlzfXZhciBMLEI9KGkoRCxMPV8pLEQucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgVWludDhBcnJheSgzMik7dHJ5e3ZhciByPWguYXJyYXlpZnkodCk7aWYoci5sZW5ndGghPT10aGlzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIik7ZS5zZXQocil9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW52YWxpZCBcIit0aGlzLm5hbWUrXCIgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6dGhpcy5uYW1lLHZhbHVlOmUudmFsdWV8fHR9KX1yZXR1cm4gZX0sRC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubGVuZ3RoPHQrMzImJmwudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGZvciBcIit0aGlzLm5hbWUrXCIgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTp0aGlzLm5hbWUsdmFsdWU6aC5oZXhsaWZ5KGUuc2xpY2UodCx0KzMyKSl9KSx7Y29uc3VtZWQ6MzIsdmFsdWU6dGhpcy5jb2VyY2VGdW5jKHRoaXMubmFtZSxoLmhleGxpZnkoZS5zbGljZSh0LHQrdGhpcy5sZW5ndGgpKSl9fSxEKTtmdW5jdGlvbiBEKGUsdCxyKXt2YXIgbj10aGlzLGk9XCJieXRlc1wiK3Q7cmV0dXJuKG49TC5jYWxsKHRoaXMsZSxpLGksciwhMSl8fHRoaXMpLmxlbmd0aD10LG59dmFyIFUsRj0oaShqLFU9Xyksai5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBVaW50OEFycmF5KDMyKTt0cnl7ZS5zZXQoaC5hcnJheWlmeShhLmdldEFkZHJlc3ModCkpLDEyKX1jYXRjaChlKXtsLnRocm93RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJhZGRyZXNzXCIsdmFsdWU6dH0pfXJldHVybiBlfSxqLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5sZW5ndGg8dCszMiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGFkZHJlc3MgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImFkZHJlc3NcIix2YWx1ZTpoLmhleGxpZnkoZS5zbGljZSh0LHQrMzIpKX0pLHtjb25zdW1lZDozMix2YWx1ZTp0aGlzLmNvZXJjZUZ1bmMoXCJhZGRyZXNzXCIsYS5nZXRBZGRyZXNzKGguaGV4bGlmeShlLnNsaWNlKHQrMTIsdCszMikpKSl9fSxqKTtmdW5jdGlvbiBqKGUsdCl7cmV0dXJuIFUuY2FsbCh0aGlzLGUsXCJhZGRyZXNzXCIsXCJhZGRyZXNzXCIsdCwhMSl8fHRoaXN9ZnVuY3Rpb24gRyhlKXt2YXIgdD0zMipNYXRoLmNlaWwoZS5sZW5ndGgvMzIpLHI9bmV3IFVpbnQ4QXJyYXkodC1lLmxlbmd0aCk7cmV0dXJuIGguY29uY2F0KFtSLmVuY29kZShlLmxlbmd0aCksZSxyXSl9ZnVuY3Rpb24gSChlLHQscil7ZS5sZW5ndGg8dCszMiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGR5bmFtaWNCeXRlcyBsZW5ndGhcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpyLGNvZGVyVHlwZTpcImR5bmFtaWNCeXRlc1wiLHZhbHVlOmguaGV4bGlmeShlLnNsaWNlKHQsdCszMikpfSk7dmFyIG49Ui5kZWNvZGUoZSx0KS52YWx1ZTt0cnl7bj1uLnRvTnVtYmVyKCl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiZHluYW1pYyBieXRlcyBjb3VudCB0b28gbGFyZ2VcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpyLGNvZGVyVHlwZTpcImR5bmFtaWNCeXRlc1wiLHZhbHVlOm4udG9TdHJpbmcoKX0pfXJldHVybiBlLmxlbmd0aDx0KzMyK24mJmwudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGZvciBkeW5hbWljQnl0ZXMgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnIsY29kZXJUeXBlOlwiZHluYW1pY0J5dGVzXCIsdmFsdWU6aC5oZXhsaWZ5KGUuc2xpY2UodCx0KzMyK24pKX0pLHtjb25zdW1lZDozMiszMipNYXRoLmNlaWwobi8zMiksdmFsdWU6ZS5zbGljZSh0KzMyLHQrMzIrbil9fXZhciB6LFY9KGkoSyx6PV8pLEsucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIEcoaC5hcnJheWlmeShlKSl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW52YWxpZCBieXRlcyB2YWx1ZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImJ5dGVzXCIsdmFsdWU6ZS52YWx1ZX0pfXJldHVybiBudWxsfSxLLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXt2YXIgcj1IKGUsdCx0aGlzLmxvY2FsTmFtZSk7cmV0dXJuIHIudmFsdWU9dGhpcy5jb2VyY2VGdW5jKFwiYnl0ZXNcIixoLmhleGxpZnkoci52YWx1ZSkpLHJ9LEspO2Z1bmN0aW9uIEsoZSx0KXtyZXR1cm4gei5jYWxsKHRoaXMsZSxcImJ5dGVzXCIsXCJieXRlc1wiLHQsITApfHx0aGlzfXZhciBxLFc9KGkoWixxPV8pLFoucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZSYmbC50aHJvd0Vycm9yKFwiaW52YWxpZCBzdHJpbmcgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJzdHJpbmdcIix2YWx1ZTplfSksRyhmLnRvVXRmOEJ5dGVzKGUpKX0sWi5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9SChlLHQsdGhpcy5sb2NhbE5hbWUpO3JldHVybiByLnZhbHVlPXRoaXMuY29lcmNlRnVuYyhcInN0cmluZ1wiLGYudG9VdGY4U3RyaW5nKHIudmFsdWUpKSxyfSxaKTtmdW5jdGlvbiBaKGUsdCl7cmV0dXJuIHEuY2FsbCh0aGlzLGUsXCJzdHJpbmdcIixcInN0cmluZ1wiLHQsITApfHx0aGlzfWZ1bmN0aW9uIEooZSl7cmV0dXJuIDMyKk1hdGguY2VpbChlLzMyKX1mdW5jdGlvbiBYKGUscil7dmFyIHQ7QXJyYXkuaXNBcnJheShyKXx8KHImJlwib2JqZWN0XCI9PXR5cGVvZiByPyh0PVtdLGUuZm9yRWFjaChmdW5jdGlvbihlKXt0LnB1c2gocltlLmxvY2FsTmFtZV0pfSkscj10KTpsLnRocm93RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsbC5JTlZBTElEX0FSR1VNRU5ULHtjb2RlclR5cGU6XCJ0dXBsZVwiLHZhbHVlOnJ9KSksZS5sZW5ndGghPT1yLmxlbmd0aCYmbC50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHtjb2RlclR5cGU6XCJ0dXBsZVwiLHZhbHVlOnJ9KTt2YXIgbj1bXTtlLmZvckVhY2goZnVuY3Rpb24oZSx0KXtuLnB1c2goe2R5bmFtaWM6ZS5keW5hbWljLHZhbHVlOmUuZW5jb2RlKHJbdF0pfSl9KTt2YXIgaT0wLG89MDtuLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5keW5hbWljPyhpKz0zMixvKz1KKGUudmFsdWUubGVuZ3RoKSk6aSs9SihlLnZhbHVlLmxlbmd0aCl9KTt2YXIgcz0wLGE9aSx1PW5ldyBVaW50OEFycmF5KGkrbyk7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihlKXtlLmR5bmFtaWM/KHUuc2V0KFIuZW5jb2RlKGEpLHMpLHMrPTMyLHUuc2V0KGUudmFsdWUsYSksYSs9SihlLnZhbHVlLmxlbmd0aCkpOih1LnNldChlLnZhbHVlLHMpLHMrPUooZS52YWx1ZS5sZW5ndGgpKX0pLHV9ZnVuY3Rpb24gJChlLG4saSl7dmFyIG89aSxzPTAsYT1bXTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7ZS5keW5hbWljPyh0PVIuZGVjb2RlKG4saSksKHI9ZS5kZWNvZGUobixvK3QudmFsdWUudG9OdW1iZXIoKSkpLmNvbnN1bWVkPXQuY29uc3VtZWQpOnI9ZS5kZWNvZGUobixpKSxudWxsIT1yLnZhbHVlJiZhLnB1c2goci52YWx1ZSksaSs9ci5jb25zdW1lZCxzKz1yLmNvbnN1bWVkfSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5sb2NhbE5hbWU7ciYmKFwibGVuZ3RoXCI9PT1yJiYocj1cIl9sZW5ndGhcIiksbnVsbD09YVtyXSYmKGFbcl09YVt0XSkpfSkse3ZhbHVlOmEsY29uc3VtZWQ6c319dmFyIFEsWT0oaShlZSxRPV8pLGVlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSl7QXJyYXkuaXNBcnJheShlKXx8bC50aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJhcnJheVwiLHZhbHVlOmV9KTt2YXIgdD10aGlzLmxlbmd0aCxyPW5ldyBVaW50OEFycmF5KDApOy0xPT09dCYmKHQ9ZS5sZW5ndGgscj1SLmVuY29kZSh0KSksbC5jaGVja0FyZ3VtZW50Q291bnQodCxlLmxlbmd0aCxcIiBpbiBjb2RlciBhcnJheVwiKyh0aGlzLmxvY2FsTmFtZT9cIiBcIit0aGlzLmxvY2FsTmFtZTpcIlwiKSk7Zm9yKHZhciBuPVtdLGk9MDtpPGUubGVuZ3RoO2krKyluLnB1c2godGhpcy5jb2Rlcik7cmV0dXJuIGguY29uY2F0KFtyLFgobixlKV0pfSxlZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9MCxuPXRoaXMubGVuZ3RoO2lmKC0xPT09bil7dHJ5e3ZhciBpPVIuZGVjb2RlKGUsdCl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGR5bmFtaWMgYXJyYXkgbGVuZ3RoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6dGhpcy5sb2NhbE5hbWUsY29kZXJUeXBlOlwiYXJyYXlcIix2YWx1ZTplLnZhbHVlfSl9dHJ5e249aS52YWx1ZS50b051bWJlcigpfWNhdGNoKGUpe2wudGhyb3dFcnJvcihcImFycmF5IGNvdW50IHRvbyBsYXJnZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImFycmF5XCIsdmFsdWU6aS52YWx1ZS50b1N0cmluZygpfSl9cis9aS5jb25zdW1lZCx0Kz1pLmNvbnN1bWVkfWZvcih2YXIgbz1bXSxzPTA7czxuO3MrKylvLnB1c2gobmV3IEEodGhpcy5jb2RlcikpO3ZhciBhPSQobyxlLHQpO3JldHVybiBhLmNvbnN1bWVkKz1yLGEudmFsdWU9dGhpcy5jb2VyY2VGdW5jKHRoaXMudHlwZSxhLnZhbHVlKSxhfSxlZSk7ZnVuY3Rpb24gZWUoZSx0LHIsbil7dmFyIGk9dGhpcyxvPXQudHlwZStcIltcIisoMDw9cj9yOlwiXCIpK1wiXVwiLHM9LTE9PT1yfHx0LmR5bmFtaWM7cmV0dXJuKGk9US5jYWxsKHRoaXMsZSxcImFycmF5XCIsbyxuLHMpfHx0aGlzKS5jb2Rlcj10LGkubGVuZ3RoPXIsaX12YXIgdGUscmU9KGkobmUsdGU9XyksbmUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gWCh0aGlzLmNvZGVycyxlKX0sbmUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3ZhciByPSQodGhpcy5jb2RlcnMsZSx0KTtyZXR1cm4gci52YWx1ZT10aGlzLmNvZXJjZUZ1bmModGhpcy50eXBlLHIudmFsdWUpLHJ9LG5lKTtmdW5jdGlvbiBuZShlLHQscil7dmFyIG49dGhpcyxpPSExLG89W107dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZHluYW1pYyYmKGk9ITApLG8ucHVzaChlLnR5cGUpfSk7dmFyIHM9XCJ0dXBsZShcIitvLmpvaW4oXCIsXCIpK1wiKVwiO3JldHVybihuPXRlLmNhbGwodGhpcyxlLFwidHVwbGVcIixzLHIsaSl8fHRoaXMpLmNvZGVycz10LG59ZnVuY3Rpb24gaWUoZSl7ZT1lLnRyaW0oKTtmb3IodmFyIHQ9W10scj1cIlwiLG49MCxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBvPWVbaV07aWYoXCIsXCI9PT1vJiYwPT09bil0LnB1c2gocikscj1cIlwiO2Vsc2UgaWYocis9byxcIihcIj09PW8pbisrO2Vsc2UgaWYoXCIpXCI9PT1vJiYtMT09PS0tbil0aHJvdyBuZXcgRXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhzaXNcIil9cmV0dXJuIHImJnQucHVzaChyKSx0fXZhciBvZT17YWRkcmVzczpGLGJvb2w6TyxzdHJpbmc6VyxieXRlczpWfTtmdW5jdGlvbiBzZShlLHQpe3ZhciByPW9lW3QudHlwZV07aWYocilyZXR1cm4gbmV3IHIoZSx0Lm5hbWUpO3ZhciBuLGksbyxzLGE9dC50eXBlLm1hdGNoKHApO2lmKGEpcmV0dXJuKDA9PT0odT1wYXJzZUludChhWzJdfHxcIjI1NlwiKSl8fDI1Njx1fHx1JTghPTApJiZsLnRocm93RXJyb3IoXCJpbnZhbGlkIFwiK2FbMV0rXCIgYml0IGxlbmd0aFwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicGFyYW1cIix2YWx1ZTp0fSksbmV3IFAoZSx1LzgsXCJpbnRcIj09PWFbMV0sdC5uYW1lKTtpZihhPXQudHlwZS5tYXRjaChkKSlyZXR1cm4oMD09PSh1PXBhcnNlSW50KGFbMV0pKXx8MzI8dSkmJmwudGhyb3dFcnJvcihcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJwYXJhbVwiLHZhbHVlOnR9KSxuZXcgQihlLHUsdC5uYW1lKTtpZihhPXQudHlwZS5tYXRjaCh2KSl7dmFyIHU9cGFyc2VJbnQoYVsyXXx8XCItMVwiKTtyZXR1cm4odD1jLnNoYWxsb3dDb3B5KHQpKS50eXBlPWFbMV0sdD1jLmRlZXBDb3B5KHQpLG5ldyBZKGUsc2UoZSx0KSx1LHQubmFtZSl9cmV0dXJuXCJ0dXBsZVwiPT09dC50eXBlLnN1YnN0cmluZygwLDUpPyhuPWUsaT10LmNvbXBvbmVudHMsbz10Lm5hbWUscz1bXSwoaT1pfHxbXSkuZm9yRWFjaChmdW5jdGlvbihlKXtzLnB1c2goc2UobixlKSl9KSxuZXcgcmUobixzLG8pKTpcIlwiPT09dC50eXBlP25ldyBrKGUsdC5uYW1lKToobC50aHJvd0Vycm9yKFwiaW52YWxpZCB0eXBlXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ0eXBlXCIsdmFsdWU6dC50eXBlfSksbnVsbCl9dmFyIGFlPSh1ZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7ZS5sZW5ndGghPT10Lmxlbmd0aCYmbC50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7Y291bnQ6e3R5cGVzOmUubGVuZ3RoLHZhbHVlczp0Lmxlbmd0aH0sdmFsdWU6e3R5cGVzOmUsdmFsdWVzOnR9fSk7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1udWxsLHQ9XCJzdHJpbmdcIj09dHlwZW9mIGU/YihlKTplO3IucHVzaChzZSh0aGlzLmNvZXJjZUZ1bmMsdCkpfSx0aGlzKSxoLmhleGxpZnkobmV3IHJlKHRoaXMuY29lcmNlRnVuYyxyLFwiX1wiKS5lbmNvZGUodCkpfSx1ZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1udWxsLHQ9XCJzdHJpbmdcIj09dHlwZW9mIGU/YihlKTpjLmRlZXBDb3B5KGUpO3IucHVzaChzZSh0aGlzLmNvZXJjZUZ1bmMsdCkpfSx0aGlzKSxuZXcgcmUodGhpcy5jb2VyY2VGdW5jLHIsXCJfXCIpLmRlY29kZShoLmFycmF5aWZ5KHQpLDApLnZhbHVlfSx1ZSk7ZnVuY3Rpb24gdWUoZSl7bC5jaGVja05ldyh0aGlzLHVlKSxlPWV8fHIuZGVmYXVsdENvZXJjZUZ1bmMsYy5kZWZpbmVSZWFkT25seSh0aGlzLFwiY29lcmNlRnVuY1wiLGUpfXIuQWJpQ29kZXI9YWUsci5kZWZhdWx0QWJpQ29kZXI9bmV3IGFlfSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4vYWRkcmVzc1wiOjYwLFwiLi9iaWdudW1iZXJcIjo2MyxcIi4vYnl0ZXNcIjo2NCxcIi4vcHJvcGVydGllc1wiOjc0LFwiLi91dGY4XCI6ODV9XSw2MDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oZShcImJuLmpzXCIpKSxvPWUoXCIuL2J5dGVzXCIpLHM9ZShcIi4va2VjY2FrMjU2XCIpLGE9ZShcIi4vcmxwXCIpLHU9ZShcIi4uL2Vycm9yc1wiKTtmdW5jdGlvbiBsKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiZlLm1hdGNoKC9eMHhbMC05QS1GYS1mXXs0MH0kLyl8fHUudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiYWRkcmVzc1wiLHZhbHVlOmV9KTtmb3IodmFyIHQ9KGU9ZS50b0xvd2VyQ2FzZSgpKS5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIikscj1uZXcgVWludDhBcnJheSg0MCksbj0wO248NDA7bisrKXJbbl09dFtuXS5jaGFyQ29kZUF0KDApO3I9by5hcnJheWlmeShzLmtlY2NhazI1NihyKSk7Zm9yKHZhciBpPTA7aTw0MDtpKz0yKTg8PXJbaT4+MV0+PjQmJih0W2ldPXRbaV0udG9VcHBlckNhc2UoKSksODw9KDE1JnJbaT4+MV0pJiYodFtpKzFdPXRbaSsxXS50b1VwcGVyQ2FzZSgpKTtyZXR1cm5cIjB4XCIrdC5qb2luKFwiXCIpfWZvcih2YXIgaD17fSxmPTA7ZjwxMDtmKyspaFtTdHJpbmcoZildPVN0cmluZyhmKTtmb3IoZj0wO2Y8MjY7ZisrKWhbU3RyaW5nLmZyb21DaGFyQ29kZSg2NStmKV09U3RyaW5nKDEwK2YpO3ZhciBjLGQ9TWF0aC5mbG9vcigoYz05MDA3MTk5MjU0NzQwOTkxLE1hdGgubG9nMTA/TWF0aC5sb2cxMChjKTpNYXRoLmxvZyhjKS9NYXRoLkxOMTApKTtmdW5jdGlvbiBwKGUpe2U9KGU9ZS50b1VwcGVyQ2FzZSgpKS5zdWJzdHJpbmcoNCkrZS5zdWJzdHJpbmcoMCwyKStcIjAwXCI7dmFyIHQ9XCJcIjtmb3IoZS5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWhbZV19KTt0Lmxlbmd0aD49ZDspdmFyIHI9dC5zdWJzdHJpbmcoMCxkKSx0PXBhcnNlSW50KHIsMTApJTk3K3Quc3Vic3RyaW5nKHIubGVuZ3RoKTtmb3IodmFyIG49U3RyaW5nKDk4LXBhcnNlSW50KHQsMTApJTk3KTtuLmxlbmd0aDwyOyluPVwiMFwiK247cmV0dXJuIG59ZnVuY3Rpb24gdihlKXt2YXIgdD1udWxsO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlJiZ1LnRocm93RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFkZHJlc3NcIix2YWx1ZTplfSksZS5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKVwiMHhcIiE9PWUuc3Vic3RyaW5nKDAsMikmJihlPVwiMHhcIitlKSx0PWwoZSksZS5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSYmdCE9PWUmJnUudGhyb3dFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhZGRyZXNzXCIsdmFsdWU6ZX0pO2Vsc2UgaWYoZS5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpe2ZvcihlLnN1YnN0cmluZygyLDQpIT09cChlKSYmdS50aHJvd0Vycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFkZHJlc3NcIix2YWx1ZTplfSksdD1uZXcgaS5kZWZhdWx0LkJOKGUuc3Vic3RyaW5nKDQpLDM2KS50b1N0cmluZygxNik7dC5sZW5ndGg8NDA7KXQ9XCIwXCIrdDt0PWwoXCIweFwiK3QpfWVsc2UgdS50aHJvd0Vycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhZGRyZXNzXCIsdmFsdWU6ZX0pO3JldHVybiB0fXIuZ2V0QWRkcmVzcz12LHIuZ2V0SWNhcEFkZHJlc3M9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBpLmRlZmF1bHQuQk4odihlKS5zdWJzdHJpbmcoMiksMTYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO3QubGVuZ3RoPDMwOyl0PVwiMFwiK3Q7cmV0dXJuXCJYRVwiK3AoXCJYRTAwXCIrdCkrdH0sci5nZXRDb250cmFjdEFkZHJlc3M9ZnVuY3Rpb24oZSl7aWYoIWUuZnJvbSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiKTt2YXIgdD1lLm5vbmNlO3JldHVybiB2KFwiMHhcIitzLmtlY2NhazI1NihhLmVuY29kZShbdihlLmZyb20pLG8uc3RyaXBaZXJvcyhvLmhleGxpZnkodCkpXSkpLnN1YnN0cmluZygyNikpfSxyLmdldENyZWF0ZTJBZGRyZXNzPWZ1bmN0aW9uKGUpe3ZhciB0PWUuaW5pdENvZGVIYXNoO2UuaW5pdENvZGUmJih0P3Mua2VjY2FrMjU2KGUuaW5pdENvZGUpIT09dCYmdS50aHJvd0Vycm9yKFwiaW5pdENvZGUvaW5pdENvZGVIYXNoIG1pc21hdGNoXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pOnQ9cy5rZWNjYWsyNTYoZS5pbml0Q29kZSkpLHR8fHUudGhyb3dFcnJvcihcIm1pc3NpbmcgaW5pdENvZGUgb3IgaW5pdENvZGVIYXNoXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pO3ZhciByPXYoZS5mcm9tKSxuPW8uYXJyYXlpZnkoZS5zYWx0KTtyZXR1cm4gMzIhPT1uLmxlbmd0aCYmdS50aHJvd0Vycm9yKFwiaW52YWxpZCBzYWx0XCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pLHYoXCIweFwiK3Mua2VjY2FrMjU2KG8uY29uY2F0KFtcIjB4ZmZcIixyLG4sdF0pKS5zdWJzdHJpbmcoMjYpKX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2J5dGVzXCI6NjQsXCIuL2tlY2NhazI1NlwiOjcxLFwiLi9ybHBcIjo3NixcImJuLmpzXCI6OX1dLDYxOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4uL3V0aWxzL2J5dGVzXCIpO3QuZXhwb3J0cz17ZGVjb2RlOmZ1bmN0aW9uKGUpe2U9YXRvYihlKTtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cisrKXQucHVzaChlLmNoYXJDb2RlQXQocikpO3JldHVybiBuLmFycmF5aWZ5KHQpfSxlbmNvZGU6ZnVuY3Rpb24oZSl7ZT1uLmFycmF5aWZ5KGUpO2Zvcih2YXIgdD1cIlwiLHI9MDtyPGUubGVuZ3RoO3IrKyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbcl0pO3JldHVybiBidG9hKHQpfX19LHtcIi4uL3V0aWxzL2J5dGVzXCI6NjR9XSw2MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPWUoXCIuL2J5dGVzXCIpLG49ZShcIi4vcHJvcGVydGllc1wiKSxpPShvLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bC5hcnJheWlmeShlKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuXCJcIjtmb3IodmFyIHI9WzBdLG49MDtuPHQubGVuZ3RoOysrbil7Zm9yKHZhciBpPXRbbl0sbz0wO288ci5sZW5ndGg7KytvKWkrPXJbb108PDgscltvXT1pJXRoaXMuYmFzZSxpPWkvdGhpcy5iYXNlfDA7Zm9yKDswPGk7KXIucHVzaChpJXRoaXMuYmFzZSksaT1pL3RoaXMuYmFzZXwwfWZvcih2YXIgcz1cIlwiLGE9MDswPT09dFthXSYmYTx0Lmxlbmd0aC0xOysrYSlzKz10aGlzLl9sZWFkZXI7Zm9yKHZhciB1PXIubGVuZ3RoLTE7MDw9dTstLXUpcys9dGhpcy5hbHBoYWJldFtyW3VdXTtyZXR1cm4gc30sby5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7dmFyIHQ9W107aWYoMD09PWUubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSh0KTt0LnB1c2goMCk7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPXRoaXMuX2FscGhhYmV0TWFwW2Vbcl1dO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIit0aGlzLmJhc2UrXCIgY2hhcmFjdGVyXCIpO2Zvcih2YXIgaT1uLG89MDtvPHQubGVuZ3RoOysrbylpKz10W29dKnRoaXMuYmFzZSx0W29dPTI1NSZpLGk+Pj04O2Zvcig7MDxpOyl0LnB1c2goMjU1JmkpLGk+Pj04fWZvcih2YXIgcz0wO2Vbc109PT10aGlzLl9sZWFkZXImJnM8ZS5sZW5ndGgtMTsrK3MpdC5wdXNoKDApO3JldHVybiBsLmFycmF5aWZ5KG5ldyBVaW50OEFycmF5KHQucmV2ZXJzZSgpKSl9LG8pO2Z1bmN0aW9uIG8oZSl7bi5kZWZpbmVSZWFkT25seSh0aGlzLFwiYWxwaGFiZXRcIixlKSxuLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJiYXNlXCIsZS5sZW5ndGgpLG4uZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9hbHBoYWJldE1hcFwiLHt9KSxuLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJfbGVhZGVyXCIsZS5jaGFyQXQoMCkpO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXRoaXMuX2FscGhhYmV0TWFwW2UuY2hhckF0KHQpXT10fXZhciBzPW5ldyhyLkJhc2VYPWkpKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7ci5CYXNlMzI9czt2YXIgYT1uZXcgaShcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7ci5CYXNlNTg9YX0se1wiLi9ieXRlc1wiOjY0LFwiLi9wcm9wZXJ0aWVzXCI6NzR9XSw2MzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19LGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKGUoXCJibi5qc1wiKSkscz1lKFwiLi9ieXRlc1wiKSxhPWUoXCIuL3Byb3BlcnRpZXNcIiksdT1pKGUoXCIuLi9lcnJvcnNcIikpLGw9bmV3IG8uZGVmYXVsdC5CTigtMSk7ZnVuY3Rpb24gaChlKXt2YXIgdD1lLnRvU3RyaW5nKDE2KTtyZXR1cm5cIi1cIj09PXRbMF0/dC5sZW5ndGglMj09MD9cIi0weDBcIit0LnN1YnN0cmluZygxKTpcIi0weFwiK3Quc3Vic3RyaW5nKDEpOnQubGVuZ3RoJTI9PTE/XCIweDBcIit0OlwiMHhcIit0fWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGQoeShlKSl9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gbmV3IHAoaChlKSl9ZnVuY3Rpb24gZChlKXt2YXIgdD1lLl9oZXg7cmV0dXJuXCItXCI9PT10WzBdP25ldyBvLmRlZmF1bHQuQk4odC5zdWJzdHJpbmcoMyksMTYpLm11bChsKTpuZXcgby5kZWZhdWx0LkJOKHQuc3Vic3RyaW5nKDIpLDE2KX12YXIgcD0odi5wcm90b3R5cGUuZnJvbVR3b3M9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZCh0aGlzKS5mcm9tVHdvcyhlKSl9LHYucHJvdG90eXBlLnRvVHdvcz1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLnRvVHdvcyhlKSl9LHYucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVyblwiLVwiPT09dGhpcy5faGV4WzBdP2MoZCh0aGlzKS5tdWwobCkpOnRoaXN9LHYucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLmFkZChmKGUpKSl9LHYucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLnN1YihmKGUpKSl9LHYucHJvdG90eXBlLmRpdj1mdW5jdGlvbihlKXtyZXR1cm4geShlKS5pc1plcm8oKSYmdS50aHJvd0Vycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiLHUuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiZGl2aWRlXCIsZmF1bHQ6XCJkaXZpc2lvbiBieSB6ZXJvXCJ9KSxjKGQodGhpcykuZGl2KGYoZSkpKX0sdi5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykubXVsKGYoZSkpKX0sdi5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykubW9kKGYoZSkpKX0sdi5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykucG93KGYoZSkpKX0sdi5wcm90b3R5cGUubWFza249ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZCh0aGlzKS5tYXNrbihlKSl9LHYucHJvdG90eXBlLmVxPWZ1bmN0aW9uKGUpe3JldHVybiBkKHRoaXMpLmVxKGYoZSkpfSx2LnByb3RvdHlwZS5sdD1mdW5jdGlvbihlKXtyZXR1cm4gZCh0aGlzKS5sdChmKGUpKX0sdi5wcm90b3R5cGUubHRlPWZ1bmN0aW9uKGUpe3JldHVybiBkKHRoaXMpLmx0ZShmKGUpKX0sdi5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGQodGhpcykuZ3QoZihlKSl9LHYucHJvdG90eXBlLmd0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZCh0aGlzKS5ndGUoZihlKSl9LHYucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMpLmlzWmVybygpfSx2LnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gZCh0aGlzKS50b051bWJlcigpfWNhdGNoKGUpe3UudGhyb3dFcnJvcihcIm92ZXJmbG93XCIsdS5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJzZXRWYWx1ZVwiLGZhdWx0Olwib3ZlcmZsb3dcIixkZXRhaWxzOmUubWVzc2FnZX0pfXJldHVybiBudWxsfSx2LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMpLnRvU3RyaW5nKDEwKX0sdi5wcm90b3R5cGUudG9IZXhTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGV4fSx2LmlzQmlnTnVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiBhLmlzVHlwZShlLFwiQmlnTnVtYmVyXCIpfSx2KTtmdW5jdGlvbiB2KGUpe2lmKHUuY2hlY2tOZXcodGhpcyx2KSxhLnNldFR5cGUodGhpcyxcIkJpZ051bWJlclwiKSxcInN0cmluZ1wiPT10eXBlb2YgZSlzLmlzSGV4U3RyaW5nKGUpPyhcIjB4XCI9PWUmJihlPVwiMHgwXCIpLGEuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixlKSk6XCItXCI9PT1lWzBdJiZzLmlzSGV4U3RyaW5nKGUuc3Vic3RyaW5nKDEpKT9hLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJfaGV4XCIsZSk6ZS5tYXRjaCgvXi0/WzAtOV0qJC8pPyhcIlwiPT1lJiYoZT1cIjBcIiksYS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgobmV3IG8uZGVmYXVsdC5CTihlKSkpKTp1LnRocm93RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmcgdmFsdWVcIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3BhcnNlSW50KFN0cmluZyhlKSkhPT1lJiZ1LnRocm93RXJyb3IoXCJ1bmRlcmZsb3dcIix1Lk5VTUVSSUNfRkFVTFQse29wZXJhdGlvbjpcInNldFZhbHVlXCIsZmF1bHQ6XCJ1bmRlcmZsb3dcIix2YWx1ZTplLG91dHB1dFZhbHVlOnBhcnNlSW50KFN0cmluZyhlKSl9KTt0cnl7YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgobmV3IG8uZGVmYXVsdC5CTihlKSkpfWNhdGNoKGUpe3UudGhyb3dFcnJvcihcIm92ZXJmbG93XCIsdS5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJzZXRWYWx1ZVwiLGZhdWx0Olwib3ZlcmZsb3dcIixkZXRhaWxzOmUubWVzc2FnZX0pfX1lbHNlIGUgaW5zdGFuY2VvZiB2P2EuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixlLl9oZXgpOmUudG9IZXhTdHJpbmc/YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgoZihlLnRvSGV4U3RyaW5nKCkpKSk6ZS5faGV4JiZzLmlzSGV4U3RyaW5nKGUuX2hleCk/YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGUuX2hleCk6cy5pc0FycmF5aXNoKGUpP2EuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixoKG5ldyBvLmRlZmF1bHQuQk4ocy5oZXhsaWZ5KGUpLnN1YnN0cmluZygyKSwxNikpKTp1LnRocm93RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSl9ZnVuY3Rpb24geShlKXtyZXR1cm4gcC5pc0JpZ051bWJlcihlKT9lOm5ldyBwKGUpfXIuQmlnTnVtYmVyPXAsci5iaWdOdW1iZXJpZnk9eX0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NCxcIi4vcHJvcGVydGllc1wiOjc0LFwiYm4uanNcIjo5fV0sNjQ6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPW4oZShcIi4uL2Vycm9yc1wiKSk7ZnVuY3Rpb24gcyhlKXtyZXR1cm4hIWUudG9IZXhTdHJpbmd9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdC5zbGljZXx8KHQuc2xpY2U9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiB1KG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0LGUpKSl9KSx0fWZ1bmN0aW9uIGwoZSl7aWYoIWV8fHBhcnNlSW50KFN0cmluZyhlLmxlbmd0aCkpIT1lLmxlbmd0aHx8XCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuITE7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07aWYocjwwfHwyNTY8PXJ8fHBhcnNlSW50KFN0cmluZyhyKSkhPXIpcmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gaChlKXtpZihudWxsPT1lJiZhLnRocm93RXJyb3IoXCJjYW5ub3QgY29udmVydCBudWxsIHZhbHVlIHRvIGFycmF5XCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KSxzKGUpJiYoZT1lLnRvSGV4U3RyaW5nKCkpLFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiBsKGUpP3UobmV3IFVpbnQ4QXJyYXkoZSkpOihhLnRocm93RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsbnVsbCx7YXJnOlwidmFsdWVcIix2YWx1ZTplLHR5cGU6dHlwZW9mIGV9KSxudWxsKTt2YXIgdD1lLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXSokLyk7dHx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXhpZGVjaW1hbCBzdHJpbmdcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwiMHhcIiE9PXRbMV0mJmEudGhyb3dFcnJvcihcImhleCBzdHJpbmcgbXVzdCBoYXZlIDB4IHByZWZpeFwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksKGU9ZS5zdWJzdHJpbmcoMikpLmxlbmd0aCUyJiYoZT1cIjBcIitlKTtmb3IodmFyIHI9W10sbj0wO248ZS5sZW5ndGg7bis9MilyLnB1c2gocGFyc2VJbnQoZS5zdWJzdHIobiwyKSwxNikpO3JldHVybiB1KG5ldyBVaW50OEFycmF5KHIpKX1mdW5jdGlvbiBpKGUpe2Zvcih2YXIgdD1bXSxyPTAsbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1oKGVbbl0pO3QucHVzaChpKSxyKz1pLmxlbmd0aH1mb3IodmFyIG89bmV3IFVpbnQ4QXJyYXkocikscz0wLG49MDtuPHQubGVuZ3RoO24rKylvLnNldCh0W25dLHMpLHMrPXRbbl0ubGVuZ3RoO3JldHVybiB1KG8pfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4hKFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSYmKCF0fHxlLmxlbmd0aD09PTIrMip0KX1yLmlzSGV4YWJsZT1zLHIuaXNBcnJheWlzaD1sLHIuYXJyYXlpZnk9aCxyLmNvbmNhdD1pLHIuc3RyaXBaZXJvcz1mdW5jdGlvbihlKXt2YXIgdD1oKGUpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gdDtmb3IodmFyIHI9MDswPT09dFtyXTspcisrO3JldHVybiByJiYodD10LnNsaWNlKHIpKSx0fSxyLnBhZFplcm9zPWZ1bmN0aW9uKGUsdCl7aWYodDwoZT1oKGUpKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHBhZFwiKTt2YXIgcj1uZXcgVWludDhBcnJheSh0KTtyZXR1cm4gci5zZXQoZSx0LWUubGVuZ3RoKSx1KHIpfSxyLmlzSGV4U3RyaW5nPW87dmFyIGY9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7ZnVuY3Rpb24gYyhlKXtpZihzKGUpKXJldHVybiBlLnRvSGV4U3RyaW5nKCk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe2U8MCYmYS50aHJvd0Vycm9yKFwiY2Fubm90IGhleGxpZnkgbmVnYXRpdmUgdmFsdWVcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLDkwMDcxOTkyNTQ3NDA5OTE8PWUmJmEudGhyb3dFcnJvcihcIm91dC1vZi1yYW5nZVwiLGEuTlVNRVJJQ19GQVVMVCx7b3BlcmFydGlvbjpcImhleGxpZnlcIixmYXVsdDpcIm91dC1vZi1zYWZlLXJhbmdlXCJ9KTtmb3IodmFyIHQ9XCJcIjtlOyl0PWZbMTUmZV0rdCxlPU1hdGguZmxvb3IoZS8xNik7cmV0dXJuIHQubGVuZ3RoPyh0Lmxlbmd0aCUyJiYodD1cIjBcIit0KSxcIjB4XCIrdCk6XCIweDAwXCJ9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciByPWUubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdKiQvKTtyZXR1cm4gcnx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXhpZGVjaW1hbCBzdHJpbmdcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwiMHhcIiE9PXJbMV0mJmEudGhyb3dFcnJvcihcImhleCBzdHJpbmcgbXVzdCBoYXZlIDB4IHByZWZpeFwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksZS5sZW5ndGglMiYmKGU9XCIweDBcIitlLnN1YnN0cmluZygyKSksZX1pZihsKGUpKXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbz1lW2ldO24ucHVzaChmWygyNDAmbyk+PjRdK2ZbMTUmb10pfXJldHVyblwiMHhcIituLmpvaW4oXCJcIil9cmV0dXJuIGEudGhyb3dFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLG51bGwse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwibmV2ZXJcIn1mdW5jdGlvbiBkKGUsdCl7Zm9yKG8oZSl8fGEudGhyb3dFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSk7ZS5sZW5ndGg8Mip0KzI7KWU9XCIweDBcIitlLnN1YnN0cmluZygyKTtyZXR1cm4gZX1mdW5jdGlvbiBwKGUpe3ZhciB0LHI9MCxuPVwiMHhcIixpPVwiMHhcIjtpZigodD1lKSYmbnVsbCE9dC5yJiZudWxsIT10LnMpe251bGw9PWUudiYmbnVsbD09ZS5yZWNvdmVyeVBhcmFtJiZhLnRocm93RXJyb3IoXCJhdCBsZWFzdCBvbiBvZiByZWNvdmVyeVBhcmFtIG9yIHYgbXVzdCBiZSBzcGVjaWZpZWRcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50Olwic2lnbmF0dXJlXCIsdmFsdWU6ZX0pLG49ZChlLnIsMzIpLGk9ZChlLnMsMzIpLFwic3RyaW5nXCI9PXR5cGVvZihyPWUudikmJihyPXBhcnNlSW50KHIsMTYpKTt2YXIgbz1lLnJlY292ZXJ5UGFyYW07bnVsbD09byYmbnVsbCE9ZS52JiYobz0xLXIlMikscj0yNytvfWVsc2V7dmFyIHM9aChlKTtpZig2NSE9PXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2lnbmF0dXJlXCIpO249YyhzLnNsaWNlKDAsMzIpKSxpPWMocy5zbGljZSgzMiw2NCkpLDI3IT09KHI9c1s2NF0pJiYyOCE9PXImJihyPTI3K3IlMil9cmV0dXJue3I6bixzOmkscmVjb3ZlcnlQYXJhbTpyLTI3LHY6cn19ci5oZXhsaWZ5PWMsci5oZXhEYXRhTGVuZ3RoPWZ1bmN0aW9uKGUpe3JldHVybiBvKGUpJiZlLmxlbmd0aCUyPT0wPyhlLmxlbmd0aC0yKS8yOm51bGx9LHIuaGV4RGF0YVNsaWNlPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbyhlKXx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXggZGF0YVwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksZS5sZW5ndGglMiE9MCYmYS50aHJvd0Vycm9yKFwiaGV4IGRhdGEgbGVuZ3RoIG11c3QgYmUgZXZlblwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksdD0yKzIqdCxudWxsIT1yP1wiMHhcIitlLnN1YnN0cmluZyh0LDIrMipyKTpcIjB4XCIrZS5zdWJzdHJpbmcodCl9LHIuaGV4U3RyaXBaZXJvcz1mdW5jdGlvbihlKXtmb3IobyhlKXx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KTszPGUubGVuZ3RoJiZcIjB4MFwiPT09ZS5zdWJzdHJpbmcoMCwzKTspZT1cIjB4XCIrZS5zdWJzdHJpbmcoMyk7cmV0dXJuIGV9LHIuaGV4WmVyb1BhZD1kLHIuc3BsaXRTaWduYXR1cmU9cCxyLmpvaW5TaWduYXR1cmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoaShbKGU9cChlKSkucixlLnMsZS5yZWNvdmVyeVBhcmFtP1wiMHgxY1wiOlwiMHgxYlwiXSkpfX0se1wiLi4vZXJyb3JzXCI6NX1dLDY1OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1uKGUoXCIuLi9lcnJvcnNcIikpLG89ZShcIi4vYnl0ZXNcIikscz1lKFwiLi91dGY4XCIpLGE9ZShcIi4va2VjY2FrMjU2XCIpLHU9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF0pLGw9bmV3IFJlZ0V4cChcIl4oKC4qKVxcXFwuKT8oW14uXSspJFwiKSxoPW5ldyBSZWdFeHAoXCJeW2EtejAtOS4tXSokXCIpO3IubmFtZWhhc2g9ZnVuY3Rpb24oZSl7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJmkudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzcyAtIFwiK1N0cmluZyhlKSxpLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KSwoZT1lLnRvTG93ZXJDYXNlKCkpLm1hdGNoKGgpfHxpLnRocm93RXJyb3IoXCJjb250YWlucyBpbnZhbGlkIFVzZVNURDNBU0NJSVJ1bGVzIGNoYXJhY3RlcnNcIixpLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KTtmb3IodmFyIHQ9dTtlLmxlbmd0aDspe3ZhciByPWUubWF0Y2gobCksbj1zLnRvVXRmOEJ5dGVzKHJbM10pLHQ9YS5rZWNjYWsyNTYoby5jb25jYXQoW3QsYS5rZWNjYWsyNTYobildKSk7ZT1yWzJdfHxcIlwifXJldHVybiBvLmhleGxpZnkodCl9LHIuaWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGEua2VjY2FrMjU2KHMudG9VdGY4Qnl0ZXMoZSkpfSxyLmhhc2hNZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiBhLmtlY2NhazI1NihvLmNvbmNhdChbcy50b1V0ZjhCeXRlcyhcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCIpLHMudG9VdGY4Qnl0ZXMoU3RyaW5nKGUubGVuZ3RoKSksXCJzdHJpbmdcIj09dHlwZW9mIGU/cy50b1V0ZjhCeXRlcyhlKTplXSkpfX0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NCxcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3V0ZjhcIjo4NX1dLDY2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZj1uKGUoXCIuLi9lcnJvcnNcIikpLGM9ZShcIi4uL3dvcmRsaXN0cy9sYW5nLWVuXCIpLGE9ZShcIi4vYmFzZXhcIiksZD1lKFwiLi9ieXRlc1wiKSxsPWUoXCIuL2JpZ251bWJlclwiKSxpPWUoXCIuL3V0ZjhcIiksbz1lKFwiLi9wYmtkZjJcIiksaD1lKFwiLi9obWFjXCIpLHA9ZShcIi4vcHJvcGVydGllc1wiKSx2PWUoXCIuL3NlY3AyNTZrMVwiKSx5PWUoXCIuL3NoYTJcIiksbT1sLmJpZ051bWJlcmlmeShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSxzPWkudG9VdGY4Qnl0ZXMoXCJCaXRjb2luIHNlZWRcIiksZz0yMTQ3NDgzNjQ4O2Z1bmN0aW9uIGIoZSl7cmV0dXJuKDE8PGUpLTE8PDgtZX1mdW5jdGlvbiB3KGUpe3JldHVybiBkLmhleFplcm9QYWQoZC5oZXhsaWZ5KGUpLDMyKX1mdW5jdGlvbiB1KGUpe3ZhciB0PWQuaGV4RGF0YVNsaWNlKHkuc2hhMjU2KHkuc2hhMjU2KGUpKSwwLDQpO3JldHVybiBhLkJhc2U1OC5lbmNvZGUoZC5jb25jYXQoW2UsdF0pKX12YXIgXz17fTtyLmRlZmF1bHRQYXRoPVwibS80NCcvNjAnLzAnLzAvMFwiO3ZhciBNPShPYmplY3QuZGVmaW5lUHJvcGVydHkoQS5wcm90b3R5cGUsXCJleHRlbmRlZEtleVwiLHtnZXQ6ZnVuY3Rpb24oKXtpZigyNTY8PXRoaXMuZGVwdGgpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGggdG9vIGxhcmdlIVwiKTtyZXR1cm4gdShkLmNvbmNhdChbbnVsbCE9dGhpcy5wcml2YXRlS2V5P1wiMHgwNDg4QURFNFwiOlwiMHgwNDg4QjIxRVwiLGQuaGV4bGlmeSh0aGlzLmRlcHRoKSx0aGlzLnBhcmVudEZpbmdlcnByaW50LGQuaGV4WmVyb1BhZChkLmhleGxpZnkodGhpcy5pbmRleCksNCksdGhpcy5jaGFpbkNvZGUsbnVsbCE9dGhpcy5wcml2YXRlS2V5P2QuY29uY2F0KFtcIjB4MDBcIix0aGlzLnByaXZhdGVLZXldKTp0aGlzLnB1YmxpY0tleV0pKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxBLnByb3RvdHlwZS5uZXV0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEoXyxudWxsLHRoaXMucHVibGljS2V5LHRoaXMucGFyZW50RmluZ2VycHJpbnQsdGhpcy5jaGFpbkNvZGUsdGhpcy5pbmRleCx0aGlzLmRlcHRoLG51bGwsdGhpcy5wYXRoKX0sQS5wcm90b3R5cGUuX2Rlcml2ZT1mdW5jdGlvbihlKXtpZig0Mjk0OTY3Mjk1PGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleCAtIFwiK1N0cmluZyhlKSk7dmFyIHQ9dGhpcy5wYXRoO3QmJih0Kz1cIi9cIisoZSZ+ZykpO3ZhciByPW5ldyBVaW50OEFycmF5KDM3KTtpZihlJmcpe2lmKCF0aGlzLnByaXZhdGVLZXkpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIpO3Iuc2V0KGQuYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSwxKSx0JiYodCs9XCInXCIpfWVsc2Ugci5zZXQoZC5hcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO2Zvcih2YXIgbj0yNDswPD1uO24tPTgpclszMysobj4+MyldPWU+PjI0LW4mMjU1O3ZhciBpPWguY29tcHV0ZUhtYWMoaC5TdXBwb3J0ZWRBbGdvcml0aG1zLnNoYTUxMix0aGlzLmNoYWluQ29kZSxyKSxvPWkuc2xpY2UoMCwzMikscz1pLnNsaWNlKDMyKSxhPW51bGwsdT1udWxsO3JldHVybiB0aGlzLnByaXZhdGVLZXk/YT13KGwuYmlnTnVtYmVyaWZ5KG8pLmFkZCh0aGlzLnByaXZhdGVLZXkpLm1vZChtKSk6dT1uZXcgdi5LZXlQYWlyKGQuaGV4bGlmeShvKSkuX2FkZFBvaW50KHRoaXMucHVibGljS2V5KSxuZXcgQShfLGEsdSx0aGlzLmZpbmdlcnByaW50LHcocyksZSx0aGlzLmRlcHRoKzEsdGhpcy5tbmVtb25pYyx0KX0sQS5wcm90b3R5cGUuZGVyaXZlUGF0aD1mdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwiL1wiKTtpZigwPT09dC5sZW5ndGh8fFwibVwiPT09dFswXSYmMCE9PXRoaXMuZGVwdGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIC0gXCIrZSk7XCJtXCI9PT10WzBdJiZ0LnNoaWZ0KCk7Zm9yKHZhciByPXRoaXMsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2lmKGkubWF0Y2goL15bMC05XSsnJC8pKXt2YXIgbz1wYXJzZUludChpLnN1YnN0cmluZygwLGkubGVuZ3RoLTEpKTtpZihnPD1vKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2kpO3I9ci5fZGVyaXZlKGcrbyl9ZWxzZXtpZighaS5tYXRjaCgvXlswLTldKyQvKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggY29tcG9uZW50IC0gXCIraSk7bz1wYXJzZUludChpKTtpZihnPD1vKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2kpO3I9ci5fZGVyaXZlKG8pfX1yZXR1cm4gcn0sQS5pc0hETm9kZT1mdW5jdGlvbihlKXtyZXR1cm4gcC5pc1R5cGUoZSxcIkhETm9kZVwiKX0sQSk7ZnVuY3Rpb24gQShlLHQscixuLGksbyxzLGEsdSl7aWYoZi5jaGVja05ldyh0aGlzLEEpLGUhPT1fKXRocm93IG5ldyBFcnJvcihcIkhETm9kZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO3ZhciBsO3Q/KGw9bmV3IHYuS2V5UGFpcih0KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcml2YXRlS2V5XCIsbC5wcml2YXRlS2V5KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixsLmNvbXByZXNzZWRQdWJsaWNLZXkpKToocC5kZWZpbmVSZWFkT25seSh0aGlzLFwicHJpdmF0ZUtleVwiLG51bGwpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInB1YmxpY0tleVwiLGQuaGV4bGlmeShyKSkpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInBhcmVudEZpbmdlcnByaW50XCIsbikscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiZmluZ2VycHJpbnRcIixkLmhleERhdGFTbGljZSh5LnJpcGVtZDE2MCh5LnNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLDAsNCkpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIix2LmNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiY2hhaW5Db2RlXCIsaSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW5kZXhcIixvKSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJkZXB0aFwiLHMpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcIm1uZW1vbmljXCIsYSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwicGF0aFwiLHUpLHAuc2V0VHlwZSh0aGlzLFwiSEROb2RlXCIpfWZ1bmN0aW9uIEUoZSx0KXt2YXIgcj1kLmFycmF5aWZ5KGUpO2lmKHIubGVuZ3RoPDE2fHw2NDxyLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlZWRcIik7dmFyIG49ZC5hcnJheWlmeShoLmNvbXB1dGVIbWFjKGguU3VwcG9ydGVkQWxnb3JpdGhtcy5zaGE1MTIscyxyKSk7cmV0dXJuIG5ldyBNKF8sdyhuLnNsaWNlKDAsMzIpKSxudWxsLFwiMHgwMDAwMDAwMFwiLHcobi5zbGljZSgzMikpLDAsMCx0LFwibVwiKX1mdW5jdGlvbiBTKGUsdCl7dD10fHxcIlwiO3ZhciByPWkudG9VdGY4Qnl0ZXMoXCJtbmVtb25pY1wiK3QsaS5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCk7cmV0dXJuIGQuaGV4bGlmeShvLnBia2RmMihpLnRvVXRmOEJ5dGVzKGUsaS5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCksciwyMDQ4LDY0LFwic2hhNTEyXCIpKX1mdW5jdGlvbiBrKGUsdCl7dD10fHxjLmxhbmdFbixmLmNoZWNrTm9ybWFsaXplKCk7dmFyIHI9dC5zcGxpdChlKTtpZihyLmxlbmd0aCUzIT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIik7Zm9yKHZhciBuPWQuYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExKnIubGVuZ3RoLzgpKSksaT0wLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIHM9dC5nZXRXb3JkSW5kZXgocltvXS5ub3JtYWxpemUoXCJORktEXCIpKTtpZigtMT09PXMpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtmb3IodmFyIGE9MDthPDExO2ErKylzJjE8PDEwLWEmJihuW2k+PjNdfD0xPDw3LWklOCksaSsrfXZhciB1PTMyKnIubGVuZ3RoLzMsbD1iKHIubGVuZ3RoLzMpLGg9ZC5hcnJheWlmeSh5LnNoYTI1NihuLnNsaWNlKDAsdS84KSkpWzBdO2lmKChoJj1sKSE9KG5bbi5sZW5ndGgtMV0mbCkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaGVja3N1bVwiKTtyZXR1cm4gZC5oZXhsaWZ5KG4uc2xpY2UoMCx1LzgpKX1mdW5jdGlvbiBOKGUsdCl7aWYoKGU9ZC5hcnJheWlmeShlKSkubGVuZ3RoJTQhPTB8fGUubGVuZ3RoPDE2fHwzMjxlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudHJvcHlcIik7Zm9yKHZhciByPVswXSxuPTExLGk9MDtpPGUubGVuZ3RoO2krKyk4PG4/KHJbci5sZW5ndGgtMV08PD04LHJbci5sZW5ndGgtMV18PWVbaV0sbi09OCk6KHJbci5sZW5ndGgtMV08PD1uLHJbci5sZW5ndGgtMV18PWVbaV0+PjgtbixyLnB1c2goZVtpXSYoMTw8OC1uKS0xKSxuKz0zKTt2YXIgbz1kLmFycmF5aWZ5KHkuc2hhMjU2KGUpKVswXSxzPWUubGVuZ3RoLzQ7cmV0dXJuIG8mPWIocykscltyLmxlbmd0aC0xXTw8PXMscltyLmxlbmd0aC0xXXw9bz4+OC1zLCh0PXR8fGMubGFuZ0VuKS5qb2luKHIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0LmdldFdvcmQoZSl9KSl9ci5IRE5vZGU9TSxyLmZyb21FeHRlbmRlZEtleT1mdW5jdGlvbihlKXt2YXIgdD1hLkJhc2U1OC5kZWNvZGUoZSk7ODI9PT10Lmxlbmd0aCYmdSh0LnNsaWNlKDAsNzgpKT09PWV8fGYudGhyb3dFcnJvcihcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcImV4dGVuZGVkS2V5XCIsdmFsdWU6XCJbUkVEQUNURURdXCJ9KTt2YXIgcj10WzRdLG49ZC5oZXhsaWZ5KHQuc2xpY2UoNSw5KSksaT1wYXJzZUludChkLmhleGxpZnkodC5zbGljZSg5LDEzKSkuc3Vic3RyaW5nKDIpLDE2KSxvPWQuaGV4bGlmeSh0LnNsaWNlKDEzLDQ1KSkscz10LnNsaWNlKDQ1LDc4KTtzd2l0Y2goZC5oZXhsaWZ5KHQuc2xpY2UoMCw0KSkpe2Nhc2VcIjB4MDQ4OGIyMWVcIjpjYXNlXCIweDA0MzU4N2NmXCI6cmV0dXJuIG5ldyBNKF8sbnVsbCxkLmhleGxpZnkocyksbixvLGkscixudWxsLG51bGwpO2Nhc2VcIjB4MDQ4OGFkZTRcIjpjYXNlXCIweDA0MzU4Mzk0XCI6aWYoMCE9PXNbMF0pYnJlYWs7cmV0dXJuIG5ldyBNKF8sZC5oZXhsaWZ5KHMuc2xpY2UoMSkpLG51bGwsbixvLGkscixudWxsLG51bGwpfXJldHVybiBmLnRocm93RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLGYuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJleHRlbmRlZEtleVwiLHZhbHVlOlwiW1JFREFDVEVEXVwifSl9LHIuZnJvbU1uZW1vbmljPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gRShTKGU9TihrKGUsdCksdCksciksZSl9LHIuZnJvbVNlZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSxudWxsKX0sci5tbmVtb25pY1RvU2VlZD1TLHIubW5lbW9uaWNUb0VudHJvcHk9ayxyLmVudHJvcHlUb01uZW1vbmljPU4sci5pc1ZhbGlkTW5lbW9uaWM9ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIGsoZSx0KSwhMH1jYXRjaChlKXt9cmV0dXJuITF9fSx7XCIuLi9lcnJvcnNcIjo1LFwiLi4vd29yZGxpc3RzL2xhbmctZW5cIjo5MCxcIi4vYmFzZXhcIjo2MixcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2htYWNcIjo2NyxcIi4vcGJrZGYyXCI6NzMsXCIuL3Byb3BlcnRpZXNcIjo3NCxcIi4vc2VjcDI1NmsxXCI6NzcsXCIuL3NoYTJcIjo3OSxcIi4vdXRmOFwiOjg1fV0sNjc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpLG8scz1uKGUoXCJoYXNoLmpzXCIpKSxhPWUoXCIuLi91dGlscy9ieXRlc1wiKSx1PW4oZShcIi4uL2Vycm9yc1wiKSk7KG89aT1yLlN1cHBvcnRlZEFsZ29yaXRobXN8fChyLlN1cHBvcnRlZEFsZ29yaXRobXM9e30pKS5zaGEyNTY9XCJzaGEyNTZcIixvLnNoYTUxMj1cInNoYTUxMlwiLHIuY29tcHV0ZUhtYWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpW2VdfHx1LnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIrZSx1LlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiaG1hY1wiLGFsZ29yaXRobTplfSksYS5hcnJheWlmeShzLmhtYWMoc1tlXSxhLmFycmF5aWZ5KHQpKS51cGRhdGUoYS5hcnJheWlmeShyKSkuZGlnZXN0KCkpfX0se1wiLi4vZXJyb3JzXCI6NSxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCJoYXNoLmpzXCI6MjZ9XSw2ODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZShcIi4vYWJpLWNvZGVyXCIpO3IuQWJpQ29kZXI9aS5BYmlDb2RlcixyLmRlZmF1bHRBYmlDb2Rlcj1pLmRlZmF1bHRBYmlDb2RlcixyLmZvcm1hdFNpZ25hdHVyZT1pLmZvcm1hdFNpZ25hdHVyZSxyLmZvcm1hdFBhcmFtVHlwZT1pLmZvcm1hdFBhcmFtVHlwZSxyLnBhcnNlU2lnbmF0dXJlPWkucGFyc2VTaWduYXR1cmUsci5wYXJzZVBhcmFtVHlwZT1pLnBhcnNlUGFyYW1UeXBlO3ZhciBvPWUoXCIuL2FkZHJlc3NcIik7ci5nZXRBZGRyZXNzPW8uZ2V0QWRkcmVzcyxyLmdldENvbnRyYWN0QWRkcmVzcz1vLmdldENvbnRyYWN0QWRkcmVzcyxyLmdldENyZWF0ZTJBZGRyZXNzPW8uZ2V0Q3JlYXRlMkFkZHJlc3Msci5nZXRJY2FwQWRkcmVzcz1vLmdldEljYXBBZGRyZXNzO3ZhciBzPW4oZShcIi4vYmFzZTY0XCIpKTtyLmJhc2U2ND1zO3ZhciBhPWUoXCIuL2JpZ251bWJlclwiKTtyLkJpZ051bWJlcj1hLkJpZ051bWJlcixyLmJpZ051bWJlcmlmeT1hLmJpZ051bWJlcmlmeTt2YXIgdT1lKFwiLi9ieXRlc1wiKTtyLmFycmF5aWZ5PXUuYXJyYXlpZnksci5jb25jYXQ9dS5jb25jYXQsci5oZXhEYXRhU2xpY2U9dS5oZXhEYXRhU2xpY2Usci5oZXhEYXRhTGVuZ3RoPXUuaGV4RGF0YUxlbmd0aCxyLmhleGxpZnk9dS5oZXhsaWZ5LHIuaGV4U3RyaXBaZXJvcz11LmhleFN0cmlwWmVyb3Msci5oZXhaZXJvUGFkPXUuaGV4WmVyb1BhZCxyLmlzSGV4U3RyaW5nPXUuaXNIZXhTdHJpbmcsci5qb2luU2lnbmF0dXJlPXUuam9pblNpZ25hdHVyZSxyLnBhZFplcm9zPXUucGFkWmVyb3Msci5zcGxpdFNpZ25hdHVyZT11LnNwbGl0U2lnbmF0dXJlLHIuc3RyaXBaZXJvcz11LnN0cmlwWmVyb3M7dmFyIGw9ZShcIi4vaGFzaFwiKTtyLmhhc2hNZXNzYWdlPWwuaGFzaE1lc3NhZ2Usci5pZD1sLmlkLHIubmFtZWhhc2g9bC5uYW1laGFzaDt2YXIgaD1uKGUoXCIuL2hkbm9kZVwiKSk7ci5IRE5vZGU9aDt2YXIgZj1lKFwiLi9pbnRlcmZhY2VcIik7ci5JbnRlcmZhY2U9Zi5JbnRlcmZhY2U7dmFyIGM9ZShcIi4vanNvbi13YWxsZXRcIik7ci5nZXRKc29uV2FsbGV0QWRkcmVzcz1jLmdldEpzb25XYWxsZXRBZGRyZXNzO3ZhciBkPWUoXCIuL2tlY2NhazI1NlwiKTtyLmtlY2NhazI1Nj1kLmtlY2NhazI1Njt2YXIgcD1lKFwiLi9zaGEyXCIpO3Iuc2hhMjU2PXAuc2hhMjU2O3ZhciB2PWUoXCIuL3NvbGlkaXR5XCIpO3Iuc29saWRpdHlLZWNjYWsyNTY9di5rZWNjYWsyNTYsci5zb2xpZGl0eVBhY2s9di5wYWNrLHIuc29saWRpdHlTaGEyNTY9di5zaGEyNTY7dmFyIHk9ZShcIi4vcmFuZG9tLWJ5dGVzXCIpO3IucmFuZG9tQnl0ZXM9eS5yYW5kb21CeXRlczt2YXIgbT1lKFwiLi9uZXR3b3Jrc1wiKTtyLmdldE5ldHdvcms9bS5nZXROZXR3b3JrO3ZhciBnPWUoXCIuL3Byb3BlcnRpZXNcIik7ci5jaGVja1Byb3BlcnRpZXM9Zy5jaGVja1Byb3BlcnRpZXMsci5kZWVwQ29weT1nLmRlZXBDb3B5LHIuZGVmaW5lUmVhZE9ubHk9Zy5kZWZpbmVSZWFkT25seSxyLnJlc29sdmVQcm9wZXJ0aWVzPWcucmVzb2x2ZVByb3BlcnRpZXMsci5zaGFsbG93Q29weT1nLnNoYWxsb3dDb3B5O3ZhciBiPW4oZShcIi4vcmxwXCIpKTtyLlJMUD1iO3ZhciB3PWUoXCIuL3NlY3AyNTZrMVwiKTtyLmNvbXB1dGVBZGRyZXNzPXcuY29tcHV0ZUFkZHJlc3Msci5jb21wdXRlUHVibGljS2V5PXcuY29tcHV0ZVB1YmxpY0tleSxyLnJlY292ZXJBZGRyZXNzPXcucmVjb3ZlckFkZHJlc3Msci5yZWNvdmVyUHVibGljS2V5PXcucmVjb3ZlclB1YmxpY0tleSxyLnZlcmlmeU1lc3NhZ2U9dy52ZXJpZnlNZXNzYWdlO3ZhciBfPWUoXCIuL3NpZ25pbmcta2V5XCIpO3IuU2lnbmluZ0tleT1fLlNpZ25pbmdLZXk7dmFyIE09ZShcIi4vdHJhbnNhY3Rpb25cIik7ci5wb3B1bGF0ZVRyYW5zYWN0aW9uPU0ucG9wdWxhdGVUcmFuc2FjdGlvbjt2YXIgQT1lKFwiLi90cmFuc2FjdGlvblwiKTtyLnBhcnNlVHJhbnNhY3Rpb249QS5wYXJzZSxyLnNlcmlhbGl6ZVRyYW5zYWN0aW9uPUEuc2VyaWFsaXplO3ZhciBFPWUoXCIuL3V0ZjhcIik7ci5mb3JtYXRCeXRlczMyU3RyaW5nPUUuZm9ybWF0Qnl0ZXMzMlN0cmluZyxyLnBhcnNlQnl0ZXMzMlN0cmluZz1FLnBhcnNlQnl0ZXMzMlN0cmluZyxyLnRvVXRmOEJ5dGVzPUUudG9VdGY4Qnl0ZXMsci50b1V0ZjhTdHJpbmc9RS50b1V0ZjhTdHJpbmc7dmFyIFM9ZShcIi4vdW5pdHNcIik7ci5jb21taWZ5PVMuY29tbWlmeSxyLmZvcm1hdEV0aGVyPVMuZm9ybWF0RXRoZXIsci5wYXJzZUV0aGVyPVMucGFyc2VFdGhlcixyLmZvcm1hdFVuaXRzPVMuZm9ybWF0VW5pdHMsci5wYXJzZVVuaXRzPVMucGFyc2VVbml0czt2YXIgaz1lKFwiLi93ZWJcIik7ci5mZXRjaEpzb249ay5mZXRjaEpzb24sci5wb2xsPWsucG9sbDt2YXIgTj1lKFwiLi9obWFjXCIpO3IuU3VwcG9ydGVkQWxnb3JpdGhtcz1OLlN1cHBvcnRlZEFsZ29yaXRobXM7dmFyIHg9ZShcIi4vdXRmOFwiKTtyLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybT14LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTt2YXIgUD1lKFwiLi93b3JkbGlzdFwiKTtyLldvcmRsaXN0PVAuV29yZGxpc3R9LHtcIi4vYWJpLWNvZGVyXCI6NTksXCIuL2FkZHJlc3NcIjo2MCxcIi4vYmFzZTY0XCI6NjEsXCIuL2JpZ251bWJlclwiOjYzLFwiLi9ieXRlc1wiOjY0LFwiLi9oYXNoXCI6NjUsXCIuL2hkbm9kZVwiOjY2LFwiLi9obWFjXCI6NjcsXCIuL2ludGVyZmFjZVwiOjY5LFwiLi9qc29uLXdhbGxldFwiOjcwLFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vbmV0d29ya3NcIjo3MixcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9yYW5kb20tYnl0ZXNcIjo3NSxcIi4vcmxwXCI6NzYsXCIuL3NlY3AyNTZrMVwiOjc3LFwiLi9zaGEyXCI6NzksXCIuL3NpZ25pbmcta2V5XCI6ODEsXCIuL3NvbGlkaXR5XCI6ODIsXCIuL3RyYW5zYWN0aW9uXCI6ODMsXCIuL3VuaXRzXCI6ODQsXCIuL3V0ZjhcIjo4NSxcIi4vd2ViXCI6ODYsXCIuL3dvcmRsaXN0XCI6ODd9XSw2OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBzKGUpe2Zvcih2YXIgdCBpbiBwLnNldFR5cGUodGhpcyxcIkRlc2NyaXB0aW9uXCIpLGUpcC5kZWZpbmVSZWFkT25seSh0aGlzLHQscC5kZWVwQ29weShlW3RdLCEwKSk7T2JqZWN0LmZyZWV6ZSh0aGlzKX12YXIgYSx1PWUoXCIuL2FkZHJlc3NcIiksZj1lKFwiLi9hYmktY29kZXJcIiksbD1lKFwiLi9iaWdudW1iZXJcIiksYz1lKFwiLi9ieXRlc1wiKSxoPWUoXCIuL2hhc2hcIiksZD1lKFwiLi9rZWNjYWsyNTZcIikscD1lKFwiLi9wcm9wZXJ0aWVzXCIpLHY9byhlKFwiLi4vZXJyb3JzXCIpKSx5PWZ1bmN0aW9uKGUpe3Auc2V0VHlwZSh0aGlzLFwiSW5kZXhlZFwiKSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJoYXNoXCIsZSl9LG09KGkoZyxhPXMpLGcucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlLHQpe2MuaXNIZXhTdHJpbmcoZSl8fHYudGhyb3dFcnJvcihcImludmFsaWQgY29udHJhY3QgYnl0ZWNvZGVcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6ZX0pLHYuY2hlY2tBcmd1bWVudENvdW50KHQubGVuZ3RoLHRoaXMuaW5wdXRzLmxlbmd0aCxcIiBpbiBJbnRlcmZhY2UgY29uc3RydWN0b3JcIik7dHJ5e3JldHVybiBlK2YuZGVmYXVsdEFiaUNvZGVyLmVuY29kZSh0aGlzLmlucHV0cyx0KS5zdWJzdHJpbmcoMil9Y2F0Y2goZSl7di50aHJvd0Vycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBhcmd1bWVudFwiLHYuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOmUuYXJnLHJlYXNvbjplLnJlYXNvbix2YWx1ZTplLnZhbHVlfSl9cmV0dXJuIG51bGx9LGcpO2Z1bmN0aW9uIGcoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciBiLHc9KGkoXyxiPXMpLF8ucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt2LmNoZWNrQXJndW1lbnRDb3VudChlLmxlbmd0aCx0aGlzLmlucHV0cy5sZW5ndGgsXCIgaW4gaW50ZXJmYWNlIGZ1bmN0aW9uIFwiK3RoaXMubmFtZSk7dHJ5e3JldHVybiB0aGlzLnNpZ2hhc2grZi5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKHRoaXMuaW5wdXRzLGUpLnN1YnN0cmluZygyKX1jYXRjaChlKXt2LnRocm93RXJyb3IoXCJpbnZhbGlkIGlucHV0IGFyZ3VtZW50XCIsdi5JTlZBTElEX0FSR1VNRU5ULHthcmc6ZS5hcmcscmVhc29uOmUucmVhc29uLHZhbHVlOmUudmFsdWV9KX1yZXR1cm4gbnVsbH0sXy5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKHRoaXMub3V0cHV0cyxjLmFycmF5aWZ5KHQpKX1jYXRjaChlKXt2LnRocm93RXJyb3IoXCJpbnZhbGlkIGRhdGEgZm9yIGZ1bmN0aW9uIG91dHB1dFwiLHYuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiZGF0YVwiLGVycm9yQXJnOmUuYXJnLGVycm9yVmFsdWU6ZS52YWx1ZSx2YWx1ZTp0LHJlYXNvbjplLnJlYXNvbn0pfX0sXyk7ZnVuY3Rpb24gXygpe3JldHVybiBudWxsIT09YiYmYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9dmFyIE0sQT0oaShFLE09cyksRSk7ZnVuY3Rpb24gRSgpe3JldHVybiBudWxsIT09TSYmTS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9dmFyIFMsaz0oaShOLFM9cyksTi5wcm90b3R5cGUuZW5jb2RlVG9waWNzPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7ZS5sZW5ndGg+dGhpcy5pbnB1dHMubGVuZ3RoJiZ2LnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHMgZm9yIFwiK3RoaXMubmFtZSx2LlVORVhQRUNURURfQVJHVU1FTlQse21heENvdW50OmUubGVuZ3RoLGV4cGVjdGVkQ291bnQ6dGhpcy5pbnB1dHMubGVuZ3RofSk7dmFyIGk9W107Zm9yKHRoaXMuYW5vbnltb3VzfHxpLnB1c2godGhpcy50b3BpYyksZS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9bi5pbnB1dHNbdF07ci5pbmRleGVkP251bGw9PWU/aS5wdXNoKG51bGwpOlwic3RyaW5nXCI9PT1yLnR5cGU/aS5wdXNoKGguaWQoZSkpOlwiYnl0ZXNcIj09PXIudHlwZT9pLnB1c2goZC5rZWNjYWsyNTYoZSkpOi0xIT09ci50eXBlLmluZGV4T2YoXCJbXCIpfHxcInR1cGxlXCI9PT1yLnR5cGUuc3Vic3RyaW5nKDAsNSk/di50aHJvd0Vycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3QgaW1wbGVtZW50ZWQgeWV0OyBidWcgdXMgb24gR2l0SHViXCIsdi5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjpcImZpbHRlcihhcnJheXx0dXBsZSlcIn0pOihcImFkZHJlc3NcIj09PXIudHlwZSYmdS5nZXRBZGRyZXNzKGUpLGkucHVzaChjLmhleFplcm9QYWQoYy5oZXhsaWZ5KGUpLDMyKS50b0xvd2VyQ2FzZSgpKSk6bnVsbCE9ZSYmdi50aHJvd0Vycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OnIubmFtZXx8dCx2YWx1ZTplfSl9KTtpLmxlbmd0aCYmbnVsbD09PWlbaS5sZW5ndGgtMV07KWkucG9wKCk7cmV0dXJuIGl9LE4ucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHIpe251bGw9PXJ8fHRoaXMuYW5vbnltb3VzfHwocj1yLnNsaWNlKDEpKTt2YXIgbixpPVtdLG89W10scz1bXTt0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7ZS5pbmRleGVkP1wic3RyaW5nXCI9PT1lLnR5cGV8fFwiYnl0ZXNcIj09PWUudHlwZXx8MDw9ZS50eXBlLmluZGV4T2YoXCJbXCIpfHxcInR1cGxlXCI9PT1lLnR5cGUuc3Vic3RyaW5nKDAsNSk/KGkucHVzaCh7dHlwZTpcImJ5dGVzMzJcIixuYW1lOmUubmFtZXx8XCJcIn0pLHMucHVzaCghMCkpOihpLnB1c2goZSkscy5wdXNoKCExKSk6KG8ucHVzaChlKSxzLnB1c2goITEpKX0pLG51bGwhPXImJihuPWYuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShpLGMuY29uY2F0KHIpKSk7dmFyIGE9Zi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKG8sYy5hcnJheWlmeShlKSksdT17fSxsPTAsaD0wO3JldHVybiB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7ZS5pbmRleGVkP251bGw9PXI/dVt0XT1uZXcgeShudWxsKTpzW3RdP3VbdF09bmV3IHkobltoKytdKTp1W3RdPW5baCsrXTp1W3RdPWFbbCsrXSxlLm5hbWUmJih1W2UubmFtZV09dVt0XSl9KSx1Lmxlbmd0aD10aGlzLmlucHV0cy5sZW5ndGgsbmV3IEEodSl9LE4pO2Z1bmN0aW9uIE4oKXtyZXR1cm4gbnVsbCE9PVMmJlMuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciB4LFA9KGkoSSx4PXMpLEkpO2Z1bmN0aW9uIEkoKXtyZXR1cm4gbnVsbCE9PXgmJnguYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciBULFI9KGkoTyxUPXMpLE8pO2Z1bmN0aW9uIE8oKXtyZXR1cm4gbnVsbCE9PVQmJlQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfWZ1bmN0aW9uIEMoZSl7c3dpdGNoKGUudHlwZSl7Y2FzZVwiY29uc3RydWN0b3JcIjp2YXIgdD1uZXcgbSh7aW5wdXRzOmUuaW5wdXRzLHBheWFibGU6bnVsbD09ZS5wYXlhYmxlfHwhIWUucGF5YWJsZX0pO3RoaXMuZGVwbG95RnVuY3Rpb258fCh0aGlzLmRlcGxveUZ1bmN0aW9uPXQpO2JyZWFrO2Nhc2VcImZ1bmN0aW9uXCI6dmFyIHI9Zi5mb3JtYXRTaWduYXR1cmUoZSkucmVwbGFjZSgvdHVwbGUvZyxcIlwiKSxuPWguaWQocikuc3Vic3RyaW5nKDAsMTApLGk9ITE7bnVsbCE9ZS5jb25zdGFudD9pPWUuY29uc3RhbnQ6bnVsbCE9ZS5zdGF0ZU11dGFiaWxpdHkmJihpPVwidmlld1wiPT1lLnN0YXRlTXV0YWJpbGl0eXx8XCJwdXJlXCI9PWUuc3RhdGVNdXRhYmlsaXR5KTt0PW5ldyB3KHtpbnB1dHM6ZS5pbnB1dHMsb3V0cHV0czplLm91dHB1dHMsZ2FzOmUuZ2FzLHBheWFibGU6bnVsbD09ZS5wYXlhYmxlfHwhIWUucGF5YWJsZSx0eXBlOmk/XCJjYWxsXCI6XCJ0cmFuc2FjdGlvblwiLG5hbWU6ZS5uYW1lLHNpZ25hdHVyZTpyLHNpZ2hhc2g6bn0pO2UubmFtZSYmKG51bGw9PXRoaXMuZnVuY3Rpb25zW2UubmFtZV0/cC5kZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucyxlLm5hbWUsdCk6di53YXJuKFwiV0FSTklORzogTXVsdGlwbGUgZGVmaW5pdGlvbnMgZm9yIFwiK2UubmFtZSkpLG51bGw9PXRoaXMuZnVuY3Rpb25zW3Quc2lnbmF0dXJlXSYmcC5kZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucyx0LnNpZ25hdHVyZSx0KTticmVhaztjYXNlXCJldmVudFwiOnI9Zi5mb3JtYXRTaWduYXR1cmUoZSkucmVwbGFjZSgvdHVwbGUvZyxcIlwiKSx0PW5ldyBrKHtuYW1lOmUubmFtZSxzaWduYXR1cmU6cixpbnB1dHM6ZS5pbnB1dHMsdG9waWM6aC5pZChyKSxhbm9ueW1vdXM6ISFlLmFub255bW91c30pO2UubmFtZSYmbnVsbD09dGhpcy5ldmVudHNbZS5uYW1lXSYmcC5kZWZpbmVSZWFkT25seSh0aGlzLmV2ZW50cyxlLm5hbWUsdCksbnVsbD09dGhpcy5ldmVudHNbdC5zaWduYXR1cmVdJiZwLmRlZmluZVJlYWRPbmx5KHRoaXMuZXZlbnRzLHQuc2lnbmF0dXJlLHQpO2JyZWFrO2Nhc2VcInJlY2VpdmVcIjpjYXNlXCJmYWxsYmFja1wiOmJyZWFrO2RlZmF1bHQ6di53YXJuKFwiV0FSTklORzogdW5zdXBwb3J0ZWQgQUJJIHR5cGUgLSBcIitlLnR5cGUpfX12YXIgTD0oQi5wcm90b3R5cGUucGFyc2VUcmFuc2FjdGlvbj1mdW5jdGlvbihlKXt2YXIgdD1lLmRhdGEuc3Vic3RyaW5nKDAsMTApLnRvTG93ZXJDYXNlKCk7Zm9yKHZhciByIGluIHRoaXMuZnVuY3Rpb25zKWlmKC0xIT09ci5pbmRleE9mKFwiKFwiKSl7dmFyIG49dGhpcy5mdW5jdGlvbnNbcl07aWYobi5zaWdoYXNoPT09dCl7dmFyIGk9Zi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKG4uaW5wdXRzLFwiMHhcIitlLmRhdGEuc3Vic3RyaW5nKDEwKSk7cmV0dXJuIG5ldyBQKHthcmdzOmksZGVjb2RlOm4uZGVjb2RlLG5hbWU6bi5uYW1lLHNpZ25hdHVyZTpuLnNpZ25hdHVyZSxzaWdoYXNoOm4uc2lnaGFzaCx2YWx1ZTpsLmJpZ051bWJlcmlmeShlLnZhbHVlfHxcIjBcIil9KX19cmV0dXJuIG51bGx9LEIucHJvdG90eXBlLnBhcnNlTG9nPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLmV2ZW50cylpZigtMSE9PXQuaW5kZXhPZihcIihcIikpe3ZhciByPXRoaXMuZXZlbnRzW3RdO2lmKCFyLmFub255bW91cyYmci50b3BpYz09PWUudG9waWNzWzBdKXJldHVybiBuZXcgUih7ZGVjb2RlOnIuZGVjb2RlLG5hbWU6ci5uYW1lLHNpZ25hdHVyZTpyLnNpZ25hdHVyZSx0b3BpYzpyLnRvcGljLHZhbHVlczpyLmRlY29kZShlLmRhdGEsZS50b3BpY3MpfSl9cmV0dXJuIG51bGx9LEIuaXNJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHAuaXNUeXBlKGUsXCJJbnRlcmZhY2VcIil9LEIuaXNJbmRleGVkPWZ1bmN0aW9uKGUpe3JldHVybiBwLmlzVHlwZShlLFwiSW5kZXhlZFwiKX0sQik7ZnVuY3Rpb24gQih0KXtpZih2LmNoZWNrTmV3KHRoaXMsQiksXCJzdHJpbmdcIj09dHlwZW9mIHQpe3RyeXt0PUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7di50aHJvd0Vycm9yKFwiY291bGQgbm90IHBhcnNlIEFCSSBKU09OXCIsdi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhYmlcIixlcnJvck1lc3NhZ2U6ZS5tZXNzYWdlLHZhbHVlOnR9KX1pZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdi50aHJvd0Vycm9yKFwiaW52YWxpZCBhYmlcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFiaVwiLHZhbHVlOnR9KSxudWxsfXAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImZ1bmN0aW9uc1wiLHt9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJldmVudHNcIix7fSk7dmFyIHI9W107dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1mLnBhcnNlU2lnbmF0dXJlKGUpKSxyLnB1c2goZSl9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJhYmlcIixwLmRlZXBDb3B5KHIsITApKSxyLmZvckVhY2goQyx0aGlzKSx0aGlzLmRlcGxveUZ1bmN0aW9ufHxDLmNhbGwodGhpcyx7dHlwZTpcImNvbnN0cnVjdG9yXCIsaW5wdXRzOltdfSkscC5zZXRUeXBlKHRoaXMsXCJJbnRlcmZhY2VcIil9ci5JbnRlcmZhY2U9TH0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYWJpLWNvZGVyXCI6NTksXCIuL2FkZHJlc3NcIjo2MCxcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2hhc2hcIjo2NSxcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3Byb3BlcnRpZXNcIjo3NH1dLDcwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vYWRkcmVzc1wiKTtmdW5jdGlvbiBpKGUpe3RyeXt2YXIgdD1KU09OLnBhcnNlKGUpfWNhdGNoKGUpe3JldHVybiExfXJldHVybiB0LmVuY3NlZWQmJnQuZXRoYWRkcn1mdW5jdGlvbiBvKGUpe3RyeXt2YXIgdD1KU09OLnBhcnNlKGUpfWNhdGNoKGUpe3JldHVybiExfXJldHVybiEoIXQudmVyc2lvbnx8cGFyc2VJbnQodC52ZXJzaW9uKSE9PXQudmVyc2lvbnx8MyE9PXBhcnNlSW50KHQudmVyc2lvbikpfXIuaXNDcm93ZHNhbGVXYWxsZXQ9aSxyLmlzU2VjcmV0U3RvcmFnZVdhbGxldD1vLHIuZ2V0SnNvbldhbGxldEFkZHJlc3M9ZnVuY3Rpb24oZSl7aWYoaShlKSl0cnl7cmV0dXJuIG4uZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGUpLmV0aGFkZHIpfWNhdGNoKGUpe3JldHVybiBudWxsfWlmKG8oZSkpdHJ5e3JldHVybiBuLmdldEFkZHJlc3MoSlNPTi5wYXJzZShlKS5hZGRyZXNzKX1jYXRjaChlKXtyZXR1cm4gbnVsbH1yZXR1cm4gbnVsbH19LHtcIi4vYWRkcmVzc1wiOjYwfV0sNzE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1lKFwianMtc2hhM1wiKSxpPWUoXCIuL2J5dGVzXCIpO3Iua2VjY2FrMjU2PWZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIituLmtlY2Nha18yNTYoaS5hcnJheWlmeShlKSl9fSx7XCIuL2J5dGVzXCI6NjQsXCJqcy1zaGEzXCI6NDB9XSw3MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bihlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBpKHIpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1bXTtyZXR1cm4gZS5JbmZ1cmFQcm92aWRlciYmdC5wdXNoKG5ldyBlLkluZnVyYVByb3ZpZGVyKHIpKSxlLkV0aGVyc2NhblByb3ZpZGVyJiZ0LnB1c2gobmV3IGUuRXRoZXJzY2FuUHJvdmlkZXIocikpLDA9PT10Lmxlbmd0aD9udWxsOmUuRmFsbGJhY2tQcm92aWRlcj9uZXcgZS5GYWxsYmFja1Byb3ZpZGVyKHQpOnRbMF19fWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGUuSnNvblJwY1Byb3ZpZGVyP25ldyBlLkpzb25ScGNQcm92aWRlcih0LHIpOm51bGx9fXZhciBhPXtjaGFpbklkOjEsZW5zQWRkcmVzczpcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLG5hbWU6XCJob21lc3RlYWRcIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJob21lc3RlYWRcIil9LHU9e2NoYWluSWQ6MyxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcInJvcHN0ZW5cIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJyb3BzdGVuXCIpfSxsPXt1bnNwZWNpZmllZDp7Y2hhaW5JZDowLG5hbWU6XCJ1bnNwZWNpZmllZFwifSxob21lc3RlYWQ6YSxtYWlubmV0OmEsbW9yZGVuOntjaGFpbklkOjIsbmFtZTpcIm1vcmRlblwifSxyb3BzdGVuOnUsdGVzdG5ldDp1LHJpbmtlYnk6e2NoYWluSWQ6NCxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcInJpbmtlYnlcIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJyaW5rZWJ5XCIpfSxnb2VybGk6e2NoYWluSWQ6NSxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcImdvZXJsaVwiLF9kZWZhdWx0UHJvdmlkZXI6aShcImdvZXJsaVwiKX0sa292YW46e2NoYWluSWQ6NDIsbmFtZTpcImtvdmFuXCIsX2RlZmF1bHRQcm92aWRlcjppKFwia292YW5cIil9LGNsYXNzaWM6e2NoYWluSWQ6NjEsbmFtZTpcImNsYXNzaWNcIixfZGVmYXVsdFByb3ZpZGVyOnMoXCJodHRwczovL3dlYjMuZ2FzdHJhY2tlci5pb1wiLFwiY2xhc3NpY1wiKX0sY2xhc3NpY1Rlc3RuZXQ6e2NoYWluSWQ6NjIsbmFtZTpcImNsYXNzaWNUZXN0bmV0XCIsX2RlZmF1bHRQcm92aWRlcjpzKFwiaHR0cHM6Ly93ZWIzLmdhc3RyYWNrZXIuaW8vbW9yZGVuXCIsXCJjbGFzc2ljVGVzdG5ldFwiKX19O3IuZ2V0TmV0d29yaz1mdW5jdGlvbihlKXtpZihudWxsPT1lKXJldHVybiBudWxsO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXtmb3IodmFyIHQgaW4gbCl7dmFyIHI9bFt0XTtpZihyLmNoYWluSWQ9PT1lKXJldHVybntuYW1lOnIubmFtZSxjaGFpbklkOnIuY2hhaW5JZCxlbnNBZGRyZXNzOnIuZW5zQWRkcmVzc3x8bnVsbCxfZGVmYXVsdFByb3ZpZGVyOnIuX2RlZmF1bHRQcm92aWRlcnx8bnVsbH19cmV0dXJue2NoYWluSWQ6ZSxuYW1lOlwidW5rbm93blwifX1pZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIG49bFtlXTtyZXR1cm4gbnVsbD09bj9udWxsOntuYW1lOm4ubmFtZSxjaGFpbklkOm4uY2hhaW5JZCxlbnNBZGRyZXNzOm4uZW5zQWRkcmVzcyxfZGVmYXVsdFByb3ZpZGVyOm4uX2RlZmF1bHRQcm92aWRlcnx8bnVsbH19dmFyIGk9bFtlLm5hbWVdO3JldHVybiBpPygwIT09ZS5jaGFpbklkJiZlLmNoYWluSWQhPT1pLmNoYWluSWQmJm8udGhyb3dFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLG8uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwibmV0d29ya1wiLHZhbHVlOmV9KSx7bmFtZTplLm5hbWUsY2hhaW5JZDppLmNoYWluSWQsZW5zQWRkcmVzczplLmVuc0FkZHJlc3N8fGkuZW5zQWRkcmVzc3x8bnVsbCxfZGVmYXVsdFByb3ZpZGVyOmUuX2RlZmF1bHRQcm92aWRlcnx8aS5fZGVmYXVsdFByb3ZpZGVyfHxudWxsfSk6KFwibnVtYmVyXCIhPXR5cGVvZiBlLmNoYWluSWQmJm8udGhyb3dFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsby5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJuZXR3b3JrXCIsdmFsdWU6ZX0pLGUpfX0se1wiLi4vZXJyb3JzXCI6NX1dLDczOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG09ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGc9ZShcIi4vaG1hY1wiKTtyLnBia2RmMj1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBvO2U9bS5hcnJheWlmeShlKSx0PW0uYXJyYXlpZnkodCk7dmFyIHMsYSx1PTEsbD1uZXcgVWludDhBcnJheShuKSxoPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKzQpO2guc2V0KHQpO2Zvcih2YXIgZj0xO2Y8PXU7ZisrKXtoW3QubGVuZ3RoXT1mPj4yNCYyNTUsaFt0Lmxlbmd0aCsxXT1mPj4xNiYyNTUsaFt0Lmxlbmd0aCsyXT1mPj44JjI1NSxoW3QubGVuZ3RoKzNdPTI1NSZmO3ZhciBjPWcuY29tcHV0ZUhtYWMoaSxlLGgpO298fChvPWMubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkobykscz1uLSgodT1NYXRoLmNlaWwobi9vKSktMSkqbyksYS5zZXQoYyk7Zm9yKHZhciBkPTE7ZDxyO2QrKyl7Yz1nLmNvbXB1dGVIbWFjKGksZSxjKTtmb3IodmFyIHA9MDtwPG87cCsrKWFbcF1ePWNbcF19dmFyIHY9KGYtMSkqbyx5PWY9PT11P3M6bztsLnNldChtLmFycmF5aWZ5KGEpLnNsaWNlKDAseSksdil9cmV0dXJuIG0uYXJyYXlpZnkobCl9fSx7XCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi9obWFjXCI6Njd9XSw3NDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bihlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBzKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLHZhbHVlOnIsd3JpdGFibGU6ITF9KX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUmJmUuX2V0aGVyc1R5cGU9PT10fXIuZGVmaW5lUmVhZE9ubHk9cyxyLnNldFR5cGU9ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9ldGhlcnNUeXBlXCIse2NvbmZpZ3VyYWJsZTohMSx2YWx1ZTp0LHdyaXRhYmxlOiExfSl9LHIuaXNUeXBlPWEsci5yZXNvbHZlUHJvcGVydGllcz1mdW5jdGlvbihyKXt2YXIgbj17fSxpPVtdO3JldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXJbdF07ZSBpbnN0YW5jZW9mIFByb21pc2U/aS5wdXNoKGUudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gblt0XT1lLG51bGx9KSk6blt0XT1lfSksUHJvbWlzZS5hbGwoaSkudGhlbihmdW5jdGlvbigpe3JldHVybiBufSl9LHIuY2hlY2tQcm9wZXJ0aWVzPWZ1bmN0aW9uKHQscil7dCYmXCJvYmplY3RcIj09dHlwZW9mIHR8fGkudGhyb3dFcnJvcihcImludmFsaWQgb2JqZWN0XCIsaS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcIm9iamVjdFwiLHZhbHVlOnR9KSxPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JbZV18fGkudGhyb3dFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiK2UsaS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRyYW5zYWN0aW9uXCIsdmFsdWU6dCxrZXk6ZX0pfSl9LHIuc2hhbGxvd0NvcHk9ZnVuY3Rpb24oZSl7dmFyIHQ9e307Zm9yKHZhciByIGluIGUpdFtyXT1lW3JdO3JldHVybiB0fTt2YXIgdT17Ym9vbGVhbjohMCxudW1iZXI6ITAsc3RyaW5nOiEwfTtyLmRlZXBDb3B5PWZ1bmN0aW9uIHQoZSxyKXtpZihudWxsPT1lfHx1W3R5cGVvZiBlXSlyZXR1cm4gZTtpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdChlLHIpfSk7cmV0dXJuIHImJk9iamVjdC5mcmVlemUobiksbn1pZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYoYShlLFwiQmlnTnVtYmVyXCIpKXJldHVybiBlO2lmKGEoZSxcIkRlc2NyaXB0aW9uXCIpKXJldHVybiBlO2lmKGEoZSxcIkluZGV4ZWRcIikpcmV0dXJuIGU7Zm9yKHZhciBpIGluIG49e30sZSl7dmFyIG89ZVtpXTt2b2lkIDAhPT1vJiZzKG4saSx0KG8scikpfXJldHVybiByJiZPYmplY3QuZnJlZXplKG4pLG59aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSlyZXR1cm4gZTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIrdHlwZW9mIGUpfSxyLmluaGVyaXRhYmxlPWZ1bmN0aW9uIG4oaSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0LHI7cj1pLCh0PWUpLnN1cGVyXz1yLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHMoZSxcImluaGVyaXRzXCIsbihlKSl9fX0se1wiLi4vZXJyb3JzXCI6NX1dLDc1OltmdW5jdGlvbihvLGUscyl7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW8oXCIuLi91dGlscy9ieXRlc1wiKSx0PW8oXCIuLi91dGlscy9wcm9wZXJ0aWVzXCIpLG49ZS5jcnlwdG98fGUubXNDcnlwdG87ZnVuY3Rpb24gaShlKXtpZihlPD0wfHwxMDI0PGV8fHBhcnNlSW50KFN0cmluZyhlKSkhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsZW5ndGhcIik7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoZSk7cmV0dXJuIG4uZ2V0UmFuZG9tVmFsdWVzKHQpLHIuYXJyYXlpZnkodCl9biYmbi5nZXRSYW5kb21WYWx1ZXN8fChjb25zb2xlLmxvZyhcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlOyB1c2luZyB3ZWFrIHJhbmRvbUJ5dGVzXCIpLG49e2dldFJhbmRvbVZhbHVlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PDIwO3QrKylmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl0P2Vbcl1ePU1hdGgudHJ1bmMoMjU2Kk1hdGgucmFuZG9tKCkpOmVbcl09TWF0aC50cnVuYygyNTYqTWF0aC5yYW5kb20oKSk7cmV0dXJuIGV9LF93ZWFrQ3J5cHRvOiEwfSkscy5yYW5kb21CeXRlcz1pLCEwPT09bi5fd2Vha0NyeXB0byYmdC5kZWZpbmVSZWFkT25seShpLFwiX3dlYWtDcnlwdG9cIiwhMCl9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw3NjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPWUoXCIuL2J5dGVzXCIpO2Z1bmN0aW9uIHMoZSl7Zm9yKHZhciB0PVtdO2U7KXQudW5zaGlmdCgyNTUmZSksZT4+PTg7cmV0dXJuIHR9ZnVuY3Rpb24gaShlLHQscil7Zm9yKHZhciBuPTAsaT0wO2k8cjtpKyspbj0yNTYqbitlW3QraV07cmV0dXJuIG59ZnVuY3Rpb24gYShlLHQscixuKXtmb3IodmFyIGk9W107cjx0KzErbjspe3ZhciBvPXUoZSxyKTtpZihpLnB1c2goby5yZXN1bHQpLHQrMStuPChyKz1vLmNvbnN1bWVkKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscFwiKX1yZXR1cm57Y29uc3VtZWQ6MStuLHJlc3VsdDppfX1mdW5jdGlvbiB1KGUsdCl7aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIik7aWYoMjQ4PD1lW3RdKXtpZih0KzErKHI9ZVt0XS0yNDcpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRvbyBzaG9ydFwiKTtpZih0KzErcisobj1pKGUsdCsxLHIpKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0byBzaG9ydFwiKTtyZXR1cm4gYShlLHQsdCsxK3IscituKX1pZigxOTI8PWVbdF0pe2lmKHQrMSsobj1lW3RdLTE5Mik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiKTtyZXR1cm4gYShlLHQsdCsxLG4pfWlmKDE4NDw9ZVt0XSl7dmFyIHI7aWYodCsxKyhyPWVbdF0tMTgzKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO2lmKHQrMStyKyhuPWkoZSx0KzEscikpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIik7cmV0dXJue2NvbnN1bWVkOjErcituLHJlc3VsdDpvLmhleGxpZnkoZS5zbGljZSh0KzErcix0KzErcituKSl9fWlmKDEyODw9ZVt0XSl7dmFyIG47aWYodCsxKyhuPWVbdF0tMTI4KT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO3JldHVybntjb25zdW1lZDoxK24scmVzdWx0Om8uaGV4bGlmeShlLnNsaWNlKHQrMSx0KzErbikpfX1yZXR1cm57Y29uc3VtZWQ6MSxyZXN1bHQ6by5oZXhsaWZ5KGVbdF0pfX1yLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gby5oZXhsaWZ5KGZ1bmN0aW9uIHQoZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXtyPXIuY29uY2F0KHQoZSkpfSksci5sZW5ndGg8PTU1PyhyLnVuc2hpZnQoMTkyK3IubGVuZ3RoKSxyKTooKG49cyhyLmxlbmd0aCkpLnVuc2hpZnQoMjQ3K24ubGVuZ3RoKSxuLmNvbmNhdChyKSl9dmFyIG4saT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvLmFycmF5aWZ5KGUpKTtyZXR1cm4gMT09PWkubGVuZ3RoJiZpWzBdPD0xMjc/aTppLmxlbmd0aDw9NTU/KGkudW5zaGlmdCgxMjgraS5sZW5ndGgpLGkpOigobj1zKGkubGVuZ3RoKSkudW5zaGlmdCgxODMrbi5sZW5ndGgpLG4uY29uY2F0KGkpKX0oZSkpfSxyLmRlY29kZT1mdW5jdGlvbihlKXt2YXIgdD1vLmFycmF5aWZ5KGUpLHI9dSh0LDApO2lmKHIuY29uc3VtZWQhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO3JldHVybiByLnJlc3VsdH19LHtcIi4vYnl0ZXNcIjo2NH1dLDc3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1lKFwiZWxsaXB0aWNcIiksbz1lKFwiLi9hZGRyZXNzXCIpLHM9ZShcIi4vYnl0ZXNcIiksYT1lKFwiLi9oYXNoXCIpLHU9ZShcIi4va2VjY2FrMjU2XCIpLGw9ZShcIi4vcHJvcGVydGllc1wiKSxoPW4oZShcIi4uL2Vycm9yc1wiKSksZj1udWxsO2Z1bmN0aW9uIGMoKXtyZXR1cm4gZj1mfHxuZXcgaS5lYyhcInNlY3AyNTZrMVwiKX12YXIgZD0ocC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVByaXZhdGUocy5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKS5zaWduKHMuYXJyYXlpZnkoZSkse2Nhbm9uaWNhbDohMH0pO3JldHVybntyZWNvdmVyeVBhcmFtOnQucmVjb3ZlcnlQYXJhbSxyOnMuaGV4WmVyb1BhZChcIjB4XCIrdC5yLnRvU3RyaW5nKDE2KSwzMiksczpzLmhleFplcm9QYWQoXCIweFwiK3Qucy50b1N0cmluZygxNiksMzIpLHY6MjcrdC5yZWNvdmVyeVBhcmFtfX0scC5wcm90b3R5cGUuY29tcHV0ZVNoYXJlZFNlY3JldD1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVByaXZhdGUocy5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKSxyPWMoKS5rZXlGcm9tUHVibGljKHMuYXJyYXlpZnkodihlKSkpO3JldHVybiBzLmhleFplcm9QYWQoXCIweFwiK3QuZGVyaXZlKHIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwzMil9LHAucHJvdG90eXBlLl9hZGRQb2ludD1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVB1YmxpYyhzLmFycmF5aWZ5KHRoaXMucHVibGljS2V5KSkscj1jKCkua2V5RnJvbVB1YmxpYyhzLmFycmF5aWZ5KGUpKTtyZXR1cm5cIjB4XCIrdC5wdWIuYWRkKHIucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpfSxwKTtmdW5jdGlvbiBwKGUpe3ZhciB0PWMoKS5rZXlGcm9tUHJpdmF0ZShzLmFycmF5aWZ5KGUpKTtsLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcml2YXRlS2V5XCIscy5oZXhsaWZ5KHQucHJpdi50b0FycmF5KFwiYmVcIiwzMikpKSxsLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixcIjB4XCIrdC5nZXRQdWJsaWMoITEsXCJoZXhcIikpLGwuZGVmaW5lUmVhZE9ubHkodGhpcyxcImNvbXByZXNzZWRQdWJsaWNLZXlcIixcIjB4XCIrdC5nZXRQdWJsaWMoITAsXCJoZXhcIikpLGwuZGVmaW5lUmVhZE9ubHkodGhpcyxcInB1YmxpY0tleUJ5dGVzXCIsdC5nZXRQdWJsaWMoKS5lbmNvZGUobnVsbCwhMCkpfWZ1bmN0aW9uIHYoZSx0KXt2YXIgcj1zLmFycmF5aWZ5KGUpO2lmKDMyIT09ci5sZW5ndGgpcmV0dXJuIDMzPT09ci5sZW5ndGg/dD9zLmhleGxpZnkocik6XCIweFwiK2MoKS5rZXlGcm9tUHVibGljKHIpLmdldFB1YmxpYyghMSxcImhleFwiKTo2NT09PXIubGVuZ3RoP3Q/XCIweFwiK2MoKS5rZXlGcm9tUHVibGljKHIpLmdldFB1YmxpYyghMCxcImhleFwiKTpzLmhleGxpZnkocik6KGgudGhyb3dFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsaC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJrZXlcIix2YWx1ZTpcIltSRURBQ1RFRF1cIn0pLG51bGwpO3ZhciBuPW5ldyBkKHIpO3JldHVybiB0P24uY29tcHJlc3NlZFB1YmxpY0tleTpuLnB1YmxpY0tleX1mdW5jdGlvbiB5KGUpe3ZhciB0PVwiMHhcIit2KGUpLnNsaWNlKDQpO3JldHVybiBvLmdldEFkZHJlc3MoXCIweFwiK3Uua2VjY2FrMjU2KHQpLnN1YnN0cmluZygyNikpfWZ1bmN0aW9uIG0oZSx0KXt2YXIgcj1zLnNwbGl0U2lnbmF0dXJlKHQpLG49e3I6cy5hcnJheWlmeShyLnIpLHM6cy5hcnJheWlmeShyLnMpfTtyZXR1cm5cIjB4XCIrYygpLnJlY292ZXJQdWJLZXkocy5hcnJheWlmeShlKSxuLHIucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsITEpfWZ1bmN0aW9uIGcoZSx0KXtyZXR1cm4geShtKHMuYXJyYXlpZnkoZSksdCkpfXIuS2V5UGFpcj1kLHIuY29tcHV0ZVB1YmxpY0tleT12LHIuY29tcHV0ZUFkZHJlc3M9eSxyLnJlY292ZXJQdWJsaWNLZXk9bSxyLnJlY292ZXJBZGRyZXNzPWcsci52ZXJpZnlNZXNzYWdlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGcoYS5oYXNoTWVzc2FnZShlKSx0KX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2FkZHJlc3NcIjo2MCxcIi4vYnl0ZXNcIjo2NCxcIi4vaGFzaFwiOjY1LFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vcHJvcGVydGllc1wiOjc0LGVsbGlwdGljOjEyfV0sNzg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIFI9bihlKFwiYWVzLWpzXCIpKSx5PW4oZShcInNjcnlwdC1qc1wiKSksTz1uKGUoXCJ1dWlkXCIpKSxDPWUoXCIuL3NpZ25pbmcta2V5XCIpLGc9aShlKFwiLi9oZG5vZGVcIikpLGI9ZShcIi4vYWRkcmVzc1wiKSxMPWUoXCIuL2J5dGVzXCIpLHc9ZShcIi4vcGJrZGYyXCIpLEI9ZShcIi4va2VjY2FrMjU2XCIpLHA9ZShcIi4vdXRmOFwiKSxEPWUoXCIuL3JhbmRvbS1ieXRlc1wiKTtmdW5jdGlvbiBfKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiZcIjB4XCIhPT1lLnN1YnN0cmluZygwLDIpJiYoZT1cIjB4XCIrZSksTC5hcnJheWlmeShlKX1mdW5jdGlvbiBVKGUsdCl7Zm9yKGU9U3RyaW5nKGUpO2UubGVuZ3RoPHQ7KWU9XCIwXCIrZTtyZXR1cm4gZX1mdW5jdGlvbiBGKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3AudG9VdGY4Qnl0ZXMoZSxwLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTpMLmFycmF5aWZ5KGUpfWZ1bmN0aW9uIE0oZSx0KXtmb3IodmFyIHI9ZSxuPXQudG9Mb3dlckNhc2UoKS5zcGxpdChcIi9cIiksaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgbz1udWxsO2Zvcih2YXIgcyBpbiByKWlmKHMudG9Mb3dlckNhc2UoKT09PW5baV0pe289cltzXTticmVha31pZihudWxsPT09bylyZXR1cm4gbnVsbDtyPW99cmV0dXJuIHJ9ci5kZWNyeXB0Q3Jvd2RzYWxlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9SlNPTi5wYXJzZShlKTt0PUYodCk7dmFyIG49Yi5nZXRBZGRyZXNzKE0ocixcImV0aGFkZHJcIikpLGk9XyhNKHIsXCJlbmNzZWVkXCIpKTtpZighaXx8aS5sZW5ndGglMTYhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmNzZWVkXCIpO2Zvcih2YXIgbz13LnBia2RmMih0LHQsMmUzLDMyLFwic2hhMjU2XCIpLnNsaWNlKDAsMTYpLHM9aS5zbGljZSgwLDE2KSxhPWkuc2xpY2UoMTYpLHU9bmV3IFIuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY2JjKG8scyksbD1MLmFycmF5aWZ5KHUuZGVjcnlwdChhKSksbD1SLmRlZmF1bHQucGFkZGluZy5wa2NzNy5zdHJpcChsKSxoPVwiXCIsZj0wO2Y8bC5sZW5ndGg7ZisrKWgrPVN0cmluZy5mcm9tQ2hhckNvZGUobFtmXSk7dmFyIGM9cC50b1V0ZjhCeXRlcyhoKSxkPW5ldyBDLlNpZ25pbmdLZXkoQi5rZWNjYWsyNTYoYykpO2lmKGQuYWRkcmVzcyE9PW4pdGhyb3cgbmV3IEVycm9yKFwiY29ycnVwdCBjcm93ZHNhbGUgd2FsbGV0XCIpO3JldHVybiBkfSxyLmRlY3J5cHQ9ZnVuY3Rpb24oZSx0LGQpe2Z1bmN0aW9uIHAoZSx0KXt2YXIgcixuLGk9XyhNKG0sXCJjcnlwdG8vY2lwaGVydGV4dFwiKSk7aWYoTC5oZXhsaWZ5KChyPWUuc2xpY2UoMTYsMzIpLG49aSxCLmtlY2NhazI1NihMLmNvbmNhdChbcixuXSkpKSkuc3Vic3RyaW5nKDIpIT09TShtLFwiY3J5cHRvL21hY1wiKS50b0xvd2VyQ2FzZSgpKXJldHVybiB0KG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIikpLG51bGw7dmFyIG89ZnVuY3Rpb24oZSx0KXtpZihcImFlcy0xMjgtY3RyXCIhPT1NKG0sXCJjcnlwdG8vY2lwaGVyXCIpKXJldHVybiBudWxsO3ZhciByPV8oTShtLFwiY3J5cHRvL2NpcGhlcnBhcmFtcy9pdlwiKSksbj1uZXcgUi5kZWZhdWx0LkNvdW50ZXIociksaT1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoZSxuKTtyZXR1cm4gTC5hcnJheWlmeShpLmRlY3J5cHQodCkpfShlLnNsaWNlKDAsMTYpLGkpLHM9ZS5zbGljZSgzMiw2NCk7aWYoIW8pcmV0dXJuIHQobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIpKSxudWxsO3ZhciBhPW5ldyBDLlNpZ25pbmdLZXkobyk7aWYobS5hZGRyZXNzJiZhLmFkZHJlc3MhPT1iLmdldEFkZHJlc3MobS5hZGRyZXNzKSlyZXR1cm4gdChuZXcgRXJyb3IoXCJhZGRyZXNzIG1pc21hdGNoXCIpKSxudWxsO3ZhciB1PU0obSxcIngtZXRoZXJzL2xvY2FsZVwiKTtpZihcIjAuMVwiPT09TShtLFwieC1ldGhlcnMvdmVyc2lvblwiKSYmKG51bGw9PXV8fFwiZW5cIj09PXUpKXt2YXIgbD1fKE0obSxcIngtZXRoZXJzL21uZW1vbmljQ2lwaGVydGV4dFwiKSksaD1fKE0obSxcIngtZXRoZXJzL21uZW1vbmljQ291bnRlclwiKSksZj1uZXcgUi5kZWZhdWx0LkNvdW50ZXIoaCksYz1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIocyxmKSxkPU0obSxcIngtZXRoZXJzL3BhdGhcIil8fGcuZGVmYXVsdFBhdGgscD1MLmFycmF5aWZ5KGMuZGVjcnlwdChsKSksdj1nLmVudHJvcHlUb01uZW1vbmljKHApLHk9Zy5mcm9tTW5lbW9uaWModikuZGVyaXZlUGF0aChkKTtpZih5LnByaXZhdGVLZXkhPUwuaGV4bGlmeShvKSlyZXR1cm4gdChuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKSksbnVsbDthPW5ldyBDLlNpZ25pbmdLZXkoeSl9cmV0dXJuIGF9dmFyIG09SlNPTi5wYXJzZShlKSx2PUYodCk7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGksbyl7dmFyIGU9TShtLFwiY3J5cHRvL2tkZlwiKTtpZihlJiZcInN0cmluZ1wiPT10eXBlb2YgZSlpZihcInNjcnlwdFwiPT09ZS50b0xvd2VyQ2FzZSgpKXt2YXIgdD1fKE0obSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSkscj1wYXJzZUludChNKG0sXCJjcnlwdG8va2RmcGFyYW1zL25cIikpLG49cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9yXCIpKSxzPXBhcnNlSW50KE0obSxcImNyeXB0by9rZGZwYXJhbXMvcFwiKSk7aWYoIXJ8fCFufHwhcylyZXR1cm4gdm9pZCBvKG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIikpO2lmKDAhPShyJnItMSkpcmV0dXJuIHZvaWQgbyhuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXIgdmFsdWUgZm9yIE5cIikpO2lmKDMyIT09KGw9cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSkpKXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZGVyaXZlZC1rZXkgbGVuZ3RoXCIpKTtkJiZkKDApLHkuZGVmYXVsdCh2LHQscixuLHMsNjQsZnVuY3Rpb24oZSx0LHIpe2lmKGUpZS5wcm9ncmVzcz10LG8oZSk7ZWxzZSBpZihyKXtyPUwuYXJyYXlpZnkocik7dmFyIG49cChyLG8pO2lmKCFuKXJldHVybjtkJiZkKDEpLGkobil9ZWxzZSBpZihkKXJldHVybiBkKHQpfSl9ZWxzZSBpZihcInBia2RmMlwiPT09ZS50b0xvd2VyQ2FzZSgpKXt2YXIgdD1fKE0obSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSksYT1udWxsLHU9TShtLFwiY3J5cHRvL2tkZnBhcmFtcy9wcmZcIik7aWYoXCJobWFjLXNoYTI1NlwiPT09dSlhPVwic2hhMjU2XCI7ZWxzZXtpZihcImhtYWMtc2hhNTEyXCIhPT11KXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgcHJmXCIpKTthPVwic2hhNTEyXCJ9dmFyIGwsaD1wYXJzZUludChNKG0sXCJjcnlwdG8va2RmcGFyYW1zL2NcIikpO2lmKDMyIT09KGw9cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSkpKXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZGVyaXZlZC1rZXkgbGVuZ3RoXCIpKTt2YXIgZj13LnBia2RmMih2LHQsaCxsLGEpLGM9cChmLG8pO2lmKCFjKXJldHVybjtpKGMpfWVsc2UgbyhuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiKSk7ZWxzZSBvKG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIpKX0pfSxyLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHcsXyl7XCJmdW5jdGlvblwiIT10eXBlb2Ygd3x8X3x8KF89dyx3PXt9KSx3PXd8fHt9O3ZhciBNPW51bGw7aWYoMzIhPT0oTT1DLlNpZ25pbmdLZXkuaXNTaWduaW5nS2V5KGUpP0wuYXJyYXlpZnkoZS5wcml2YXRlS2V5KTpMLmFycmF5aWZ5KGUpKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcml2YXRlIGtleVwiKTt2YXIgcj1GKHQpLEE9bnVsbDtpZih3LmVudHJvcHkmJihBPUwuYXJyYXlpZnkody5lbnRyb3B5KSksdy5tbmVtb25pYylpZihBKXtpZihnLmVudHJvcHlUb01uZW1vbmljKEEpIT09dy5tbmVtb25pYyl0aHJvdyBuZXcgRXJyb3IoXCJlbnRyb3B5IGFuZCBtbmVtb25pYyBtaXNtYXRjaFwiKX1lbHNlIEE9TC5hcnJheWlmeShnLm1uZW1vbmljVG9FbnRyb3B5KHcubW5lbW9uaWMsdy53b3JkbGlzdCkpO3ZhciBFPXcucGF0aDtBJiYhRSYmKEU9Zy5kZWZhdWx0UGF0aCk7dmFyIFM9KFM9dy5jbGllbnQpfHxcImV0aGVycy5qc1wiLGs9bnVsbCxrPXcuc2FsdD9MLmFycmF5aWZ5KHcuc2FsdCk6RC5yYW5kb21CeXRlcygzMiksTj1udWxsO2lmKHcuaXYpe2lmKDE2IT09KE49TC5hcnJheWlmeSh3Lml2KSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIil9ZWxzZSBOPUQucmFuZG9tQnl0ZXMoMTYpO3ZhciB4PW51bGw7aWYody51dWlkKXtpZigxNiE9PSh4PUwuYXJyYXlpZnkody51dWlkKSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXVpZFwiKX1lbHNlIHg9RC5yYW5kb21CeXRlcygxNik7dmFyIFA9MTw8MTcsST04LFQ9MTtyZXR1cm4gdy5zY3J5cHQmJih3LnNjcnlwdC5OJiYoUD13LnNjcnlwdC5OKSx3LnNjcnlwdC5yJiYoST13LnNjcnlwdC5yKSx3LnNjcnlwdC5wJiYoVD13LnNjcnlwdC5wKSksbmV3IFByb21pc2UoZnVuY3Rpb24oZyxiKXtfJiZfKDApLHkuZGVmYXVsdChyLGssUCxJLFQsNjQsZnVuY3Rpb24oZSx0LHIpe2lmKGUpZS5wcm9ncmVzcz10LGIoZSk7ZWxzZSBpZihyKXt2YXIgbixpLG8scyxhLHUsbD0ocj1MLmFycmF5aWZ5KHIpKS5zbGljZSgwLDE2KSxoPXIuc2xpY2UoMTYsMzIpLGY9ci5zbGljZSgzMiw2NCksYz1uZXcgQy5TaWduaW5nS2V5KE0pLmFkZHJlc3MsZD1uZXcgUi5kZWZhdWx0LkNvdW50ZXIoTikscD1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIobCxkKSx2PUwuYXJyYXlpZnkocC5lbmNyeXB0KE0pKSx5PUIua2VjY2FrMjU2KEwuY29uY2F0KFtoLHZdKSksbT17YWRkcmVzczpjLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLGlkOk8uZGVmYXVsdC52NCh7cmFuZG9tOnh9KSx2ZXJzaW9uOjMsQ3J5cHRvOntjaXBoZXI6XCJhZXMtMTI4LWN0clwiLGNpcGhlcnBhcmFtczp7aXY6TC5oZXhsaWZ5KE4pLnN1YnN0cmluZygyKX0sY2lwaGVydGV4dDpMLmhleGxpZnkodikuc3Vic3RyaW5nKDIpLGtkZjpcInNjcnlwdFwiLGtkZnBhcmFtczp7c2FsdDpMLmhleGxpZnkoaykuc3Vic3RyaW5nKDIpLG46UCxka2xlbjozMixwOlQscjpJfSxtYWM6eS5zdWJzdHJpbmcoMil9fTtBJiYobj1ELnJhbmRvbUJ5dGVzKDE2KSxpPW5ldyBSLmRlZmF1bHQuQ291bnRlcihuKSxvPW5ldyBSLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmN0cihmLGkpLHM9TC5hcnJheWlmeShvLmVuY3J5cHQoQSkpLHU9KGE9bmV3IERhdGUpLmdldFVUQ0Z1bGxZZWFyKCkrXCItXCIrVShhLmdldFVUQ01vbnRoKCkrMSwyKStcIi1cIitVKGEuZ2V0VVRDRGF0ZSgpLDIpK1wiVFwiK1UoYS5nZXRVVENIb3VycygpLDIpK1wiLVwiK1UoYS5nZXRVVENNaW51dGVzKCksMikrXCItXCIrVShhLmdldFVUQ1NlY29uZHMoKSwyKStcIi4wWlwiLG1bXCJ4LWV0aGVyc1wiXT17Y2xpZW50OlMsZ2V0aEZpbGVuYW1lOlwiVVRDLS1cIit1K1wiLS1cIittLmFkZHJlc3MsbW5lbW9uaWNDb3VudGVyOkwuaGV4bGlmeShuKS5zdWJzdHJpbmcoMiksbW5lbW9uaWNDaXBoZXJ0ZXh0OkwuaGV4bGlmeShzKS5zdWJzdHJpbmcoMikscGF0aDpFLHZlcnNpb246XCIwLjFcIn0sdy53b3JkbGlzdCYmXCJzdHJpbmdcIj09dHlwZW9mIHcud29yZGxpc3QubG9jYWxlJiYobVtcIngtZXRoZXJzXCJdLmxvY2FsZT13LndvcmRsaXN0LmxvY2FsZSkpLF8mJl8oMSksZyhKU09OLnN0cmluZ2lmeShtKSl9ZWxzZSBpZihfKXJldHVybiBfKHQpfSl9KX19LHtcIi4vYWRkcmVzc1wiOjYwLFwiLi9ieXRlc1wiOjY0LFwiLi9oZG5vZGVcIjo2NixcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3Bia2RmMlwiOjczLFwiLi9yYW5kb20tYnl0ZXNcIjo3NSxcIi4vc2lnbmluZy1rZXlcIjo4MSxcIi4vdXRmOFwiOjg1LFwiYWVzLWpzXCI6OCxcInNjcnlwdC1qc1wiOjQ0LHV1aWQ6NDh9XSw3OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oZShcImhhc2guanNcIikpLG89ZShcIi4vYnl0ZXNcIik7ci5yaXBlbWQxNjA9ZnVuY3Rpb24oZSl7cmV0dXJuXCIweFwiK2kuZGVmYXVsdC5yaXBlbWQxNjAoKS51cGRhdGUoby5hcnJheWlmeShlKSkuZGlnZXN0KFwiaGV4XCIpfSxyLnNoYTI1Nj1mdW5jdGlvbihlKXtyZXR1cm5cIjB4XCIraS5kZWZhdWx0LnNoYTI1NigpLnVwZGF0ZShvLmFycmF5aWZ5KGUpKS5kaWdlc3QoXCJoZXhcIil9LHIuc2hhNTEyPWZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIitpLmRlZmF1bHQuc2hhNTEyKCkudXBkYXRlKG8uYXJyYXlpZnkoZSkpLmRpZ2VzdChcImhleFwiKX19LHtcIi4vYnl0ZXNcIjo2NCxcImhhc2guanNcIjoyNn1dLDgwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZShcInNldGltbWVkaWF0ZVwiKSxyLnBsYXRmb3JtPVwiYnJvd3NlclwifSx7c2V0aW1tZWRpYXRlOjQ1fV0sODE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPWUoXCIuL2hkbm9kZVwiKSxvPWUoXCIuL2J5dGVzXCIpLHM9ZShcIi4vcHJvcGVydGllc1wiKSxhPWUoXCIuL3NlY3AyNTZrMVwiKSx1PW4oZShcIi4uL2Vycm9yc1wiKSksbD0oaC5wcm90b3R5cGUuc2lnbkRpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5rZXlQYWlyLnNpZ24oZSl9LGgucHJvdG90eXBlLmNvbXB1dGVTaGFyZWRTZWNyZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMua2V5UGFpci5jb21wdXRlU2hhcmVkU2VjcmV0KG8uYXJyYXlpZnkoZSkpfSxoLmlzU2lnbmluZ0tleT1mdW5jdGlvbihlKXtyZXR1cm4gcy5pc1R5cGUoZSxcIlNpZ25pbmdLZXlcIil9LGgpO2Z1bmN0aW9uIGgoZSl7dS5jaGVja05ldyh0aGlzLGgpO3ZhciB0PW51bGwsdD1pLkhETm9kZS5pc0hETm9kZShlKT8ocy5kZWZpbmVSZWFkT25seSh0aGlzLFwibW5lbW9uaWNcIixlLm1uZW1vbmljKSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXRoXCIsZS5wYXRoKSxvLmFycmF5aWZ5KGUucHJpdmF0ZUtleSkpOihcInN0cmluZ1wiPT10eXBlb2YgZSYmZS5tYXRjaCgvXlswLTlhLWZdKiQvaSkmJjY0PT09ZS5sZW5ndGgmJihlPVwiMHhcIitlKSxvLmFycmF5aWZ5KGUpKTt0cnl7MzIhPT10Lmxlbmd0aCYmdS50aHJvd0Vycm9yKFwiZXhhY3RseSAzMiBieXRlcyByZXF1aXJlZFwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicHJpdmF0ZUtleVwiLHZhbHVlOlwiW1JFREFDVEVEXVwifSl9Y2F0Y2goZSl7dmFyIHI9e2FyZzpcInByaXZhdGVLZXlcIixyZWFzb246ZS5yZWFzb24sdmFsdWU6XCJbUkVEQUNURURdXCJ9O2UudmFsdWUmJihcIm51bWJlclwiPT10eXBlb2YgZS52YWx1ZS5sZW5ndGgmJihyLmxlbmd0aD1lLnZhbHVlLmxlbmd0aCksci50eXBlPXR5cGVvZiBlLnZhbHVlKSx1LnRocm93RXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsZS5jb2RlLHIpfXMuZGVmaW5lUmVhZE9ubHkodGhpcyxcInByaXZhdGVLZXlcIixvLmhleGxpZnkodCkpLHMuZGVmaW5lUmVhZE9ubHkodGhpcyxcImtleVBhaXJcIixuZXcgYS5LZXlQYWlyKHQpKSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIix0aGlzLmtleVBhaXIucHVibGljS2V5KSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYS5jb21wdXRlQWRkcmVzcyh0aGlzLmtleVBhaXIucHVibGljS2V5KSkscy5zZXRUeXBlKHRoaXMsXCJTaWduaW5nS2V5XCIpfXIuU2lnbmluZ0tleT1sfSx7XCIuLi9lcnJvcnNcIjo1LFwiLi9ieXRlc1wiOjY0LFwiLi9oZG5vZGVcIjo2NixcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9zZWNwMjU2azFcIjo3N31dLDgyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZShcIi4vYmlnbnVtYmVyXCIpLGw9ZShcIi4vYnl0ZXNcIiksaD1lKFwiLi91dGY4XCIpLG49ZShcIi4va2VjY2FrMjU2XCIpLGk9ZShcIi4vc2hhMlwiKSxmPW5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIiksYz1uZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIiksZD1uZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpLHA9XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7ZnVuY3Rpb24gbyhlLHIpe2lmKGUubGVuZ3RoIT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlL3ZhbHVlIGNvdW50IG1pc21hdGNoXCIpO3ZhciBuPVtdO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSx0KXtuLnB1c2goZnVuY3Rpb24gdChlLHIsbil7c3dpdGNoKGUpe2Nhc2VcImFkZHJlc3NcIjpyZXR1cm4gbj9sLnBhZFplcm9zKHIsMzIpOmwuYXJyYXlpZnkocik7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGgudG9VdGY4Qnl0ZXMocik7Y2FzZVwiYnl0ZXNcIjpyZXR1cm4gbC5hcnJheWlmeShyKTtjYXNlXCJib29sXCI6cmV0dXJuIHI9cj9cIjB4MDFcIjpcIjB4MDBcIixuP2wucGFkWmVyb3MociwzMik6bC5hcnJheWlmeShyKX12YXIgaT1lLm1hdGNoKGMpO2lmKGkpe2lmKChvPXBhcnNlSW50KGlbMl18fFwiMjU2XCIpKSU4IT0wfHwwPT09b3x8MjU2PG8pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBudW1iZXIgdHlwZSAtIFwiK2UpO3JldHVybiBuJiYobz0yNTYpLHI9dS5iaWdOdW1iZXJpZnkocikudG9Ud29zKG8pLGwucGFkWmVyb3MocixvLzgpfWlmKGk9ZS5tYXRjaChmKSl7dmFyIG89cGFyc2VJbnQoaVsxXSk7aWYoU3RyaW5nKG8pIT1pWzFdfHwwPT09b3x8MzI8byl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG51bWJlciB0eXBlIC0gXCIrZSk7aWYobC5hcnJheWlmeShyKS5ieXRlTGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIitlKTtyZXR1cm4gbj9sLmFycmF5aWZ5KChyK3ApLnN1YnN0cmluZygwLDY2KSk6cn1pZigoaT1lLm1hdGNoKGQpKSYmQXJyYXkuaXNBcnJheShyKSl7dmFyIHM9aVsxXTtpZihwYXJzZUludChpWzJdfHxTdHJpbmcoci5sZW5ndGgpKSE9ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgXCIrZSk7dmFyIGE9W107cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbihlKXthLnB1c2godChzLGUsITApKX0pLGwuY29uY2F0KGEpfXRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZSAtIFwiK2UpfShlLHJbdF0pKX0pLGwuaGV4bGlmeShsLmNvbmNhdChuKSl9ci5wYWNrPW8sci5rZWNjYWsyNTY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5rZWNjYWsyNTYobyhlLHQpKX0sci5zaGEyNTY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaS5zaGEyNTYobyhlLHQpKX19LHtcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2tlY2NhazI1NlwiOjcxLFwiLi9zaGEyXCI6NzksXCIuL3V0ZjhcIjo4NX1dLDgzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1lKFwiLi4vY29uc3RhbnRzXCIpLGE9bihlKFwiLi4vZXJyb3JzXCIpKSx1PWUoXCIuL3NlY3AyNTZrMVwiKSxsPWUoXCIuL2FkZHJlc3NcIiksaD1lKFwiLi9iaWdudW1iZXJcIiksZj1lKFwiLi9ieXRlc1wiKSxjPWUoXCIuL2tlY2NhazI1NlwiKSxzPWUoXCIuL3Byb3BlcnRpZXNcIiksZD1uKGUoXCIuL3JscFwiKSksbz1lKFwiLi4vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXCIpO2Z1bmN0aW9uIHAoZSl7cmV0dXJuXCIweFwiPT09ZT9pLlplcm86aC5iaWdOdW1iZXJpZnkoZSl9dmFyIHY9W3tuYW1lOlwibm9uY2VcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZ2FzUHJpY2VcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZ2FzTGltaXRcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwidG9cIixsZW5ndGg6MjB9LHtuYW1lOlwidmFsdWVcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZGF0YVwifV0seT17Y2hhaW5JZDohMCxkYXRhOiEwLGdhc0xpbWl0OiEwLGdhc1ByaWNlOiEwLG5vbmNlOiEwLHRvOiEwLHZhbHVlOiEwfTtyLnNlcmlhbGl6ZT1mdW5jdGlvbihyLGUpe3MuY2hlY2tQcm9wZXJ0aWVzKHIseSk7dmFyIG49W107di5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXJbZS5uYW1lXXx8W10sdD1mLmFycmF5aWZ5KGYuaGV4bGlmeSh0KSk7ZS5sZW5ndGgmJnQubGVuZ3RoIT09ZS5sZW5ndGgmJjA8dC5sZW5ndGgmJmEudGhyb3dFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIitlLm5hbWUsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ0cmFuc2FjdGlvblwiK2UubmFtZSx2YWx1ZTp0fSksZS5tYXhMZW5ndGgmJih0PWYuc3RyaXBaZXJvcyh0KSkubGVuZ3RoPmUubWF4TGVuZ3RoJiZhLnRocm93RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIrZS5uYW1lLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidHJhbnNhY3Rpb25cIitlLm5hbWUsdmFsdWU6dH0pLG4ucHVzaChmLmhleGxpZnkodCkpfSksbnVsbCE9ci5jaGFpbklkJiYwIT09ci5jaGFpbklkJiYobi5wdXNoKGYuaGV4bGlmeShyLmNoYWluSWQpKSxuLnB1c2goXCIweFwiKSxuLnB1c2goXCIweFwiKSk7dmFyIHQ9ZC5lbmNvZGUobik7aWYoIWUpcmV0dXJuIHQ7dmFyIGk9Zi5zcGxpdFNpZ25hdHVyZShlKSxvPTI3K2kucmVjb3ZlcnlQYXJhbTtyZXR1cm4gOT09PW4ubGVuZ3RoJiYobi5wb3AoKSxuLnBvcCgpLG4ucG9wKCksbys9MipyLmNoYWluSWQrOCksbi5wdXNoKGYuaGV4bGlmeShvKSksbi5wdXNoKGYuc3RyaXBaZXJvcyhmLmFycmF5aWZ5KGkucikpKSxuLnB1c2goZi5zdHJpcFplcm9zKGYuYXJyYXlpZnkoaS5zKSkpLGQuZW5jb2RlKG4pfSxyLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0PWQuZGVjb2RlKGUpOzkhPT10Lmxlbmd0aCYmNiE9PXQubGVuZ3RoJiZhLnRocm93RXJyb3IoXCJpbnZhbGlkIHJhdyB0cmFuc2FjdGlvblwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicmF3VHJhbnNhY3RpblwiLHZhbHVlOmV9KTt2YXIgcixuPXtub25jZTpwKHRbMF0pLnRvTnVtYmVyKCksZ2FzUHJpY2U6cCh0WzFdKSxnYXNMaW1pdDpwKHRbMl0pLHRvOlwiMHhcIj09PShyPXRbM10pP251bGw6bC5nZXRBZGRyZXNzKHIpLHZhbHVlOnAodFs0XSksZGF0YTp0WzVdLGNoYWluSWQ6MH07aWYoNj09PXQubGVuZ3RoKXJldHVybiBuO3RyeXtuLnY9aC5iaWdOdW1iZXJpZnkodFs2XSkudG9OdW1iZXIoKX1jYXRjaChlKXtyZXR1cm4gYS5pbmZvKGUpLG59aWYobi5yPWYuaGV4WmVyb1BhZCh0WzddLDMyKSxuLnM9Zi5oZXhaZXJvUGFkKHRbOF0sMzIpLGguYmlnTnVtYmVyaWZ5KG4ucikuaXNaZXJvKCkmJmguYmlnTnVtYmVyaWZ5KG4ucykuaXNaZXJvKCkpbi5jaGFpbklkPW4udixuLnY9MDtlbHNle24uY2hhaW5JZD1NYXRoLmZsb29yKChuLnYtMzUpLzIpLG4uY2hhaW5JZDwwJiYobi5jaGFpbklkPTApO3ZhciBpPW4udi0yNyxvPXQuc2xpY2UoMCw2KTswIT09bi5jaGFpbklkJiYoby5wdXNoKGYuaGV4bGlmeShuLmNoYWluSWQpKSxvLnB1c2goXCIweFwiKSxvLnB1c2goXCIweFwiKSxpLT0yKm4uY2hhaW5JZCs4KTt2YXIgcz1jLmtlY2NhazI1NihkLmVuY29kZShvKSk7dHJ5e24uZnJvbT11LnJlY292ZXJBZGRyZXNzKHMse3I6Zi5oZXhsaWZ5KG4uciksczpmLmhleGxpZnkobi5zKSxyZWNvdmVyeVBhcmFtOml9KX1jYXRjaChlKXthLmluZm8oZSl9bi5oYXNoPWMua2VjY2FrMjU2KGUpfXJldHVybiBufSxyLnBvcHVsYXRlVHJhbnNhY3Rpb249ZnVuY3Rpb24oZSx0LHIpe28uUHJvdmlkZXIuaXNQcm92aWRlcih0KXx8YS50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJwcm92aWRlclwiLHZhbHVlOnR9KSxzLmNoZWNrUHJvcGVydGllcyhlLHkpO3ZhciBuLGk9cy5zaGFsbG93Q29weShlKTtyZXR1cm4gbnVsbCE9aS50byYmKGkudG89dC5yZXNvbHZlTmFtZShpLnRvKSksbnVsbD09aS5nYXNQcmljZSYmKGkuZ2FzUHJpY2U9dC5nZXRHYXNQcmljZSgpKSxudWxsPT1pLm5vbmNlJiYoaS5ub25jZT10LmdldFRyYW5zYWN0aW9uQ291bnQocikpLG51bGw9PWkuZ2FzTGltaXQmJigobj1zLnNoYWxsb3dDb3B5KGkpKS5mcm9tPXIsaS5nYXNMaW1pdD10LmVzdGltYXRlR2FzKG4pKSxudWxsPT1pLmNoYWluSWQmJihpLmNoYWluSWQ9dC5nZXROZXR3b3JrKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFpbklkfSkpLHMucmVzb2x2ZVByb3BlcnRpZXMoaSl9fSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4uL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclwiOjUwLFwiLi9hZGRyZXNzXCI6NjAsXCIuL2JpZ251bWJlclwiOjYzLFwiLi9ieXRlc1wiOjY0LFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9ybHBcIjo3NixcIi4vc2VjcDI1NmsxXCI6Nzd9XSw4NDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGksaD1lKFwiLi4vY29uc3RhbnRzXCIpLGY9bihlKFwiLi4vZXJyb3JzXCIpKSxjPWUoXCIuL2JpZ251bWJlclwiKSxvPXt9O2Z1bmN0aW9uIHMoZSl7cmV0dXJue2RlY2ltYWxzOmUubGVuZ3RoLTEsdGVuUG93ZXI6Yy5iaWdOdW1iZXJpZnkoZSl9fWZ1bmN0aW9uIGQoZSl7dmFyIHQ9b1tTdHJpbmcoZSkudG9Mb3dlckNhc2UoKV07aWYoIXQmJlwibnVtYmVyXCI9PXR5cGVvZiBlJiZwYXJzZUludChTdHJpbmcoZSkpPT1lJiYwPD1lJiZlPD0yNTYpe2Zvcih2YXIgcj1cIjFcIixuPTA7bjxlO24rKylyKz1cIjBcIjt0PXMocil9cmV0dXJuIHR8fGYudGhyb3dFcnJvcihcImludmFsaWQgdW5pdFR5cGVcIixmLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KSx0fWZ1bmN0aW9uIGEoZSx0KXt2YXIgcj1kKHQpLG49KGU9Yy5iaWdOdW1iZXJpZnkoZSkpLmx0KGguWmVybyk7biYmKGU9ZS5tdWwoaC5OZWdhdGl2ZU9uZSkpO2Zvcih2YXIgaT1lLm1vZChyLnRlblBvd2VyKS50b1N0cmluZygpO2kubGVuZ3RoPHIuZGVjaW1hbHM7KWk9XCIwXCIraTtyZXR1cm4gaT1pLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdLGU9ZS5kaXYoci50ZW5Qb3dlcikudG9TdHJpbmcoKStcIi5cIitpLG4mJihlPVwiLVwiK2UpLGV9ZnVuY3Rpb24gdShlLHQpe251bGw9PXQmJih0PTE4KTt2YXIgcj1kKHQpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLm1hdGNoKC9eLT9bMC05LixdKyQvKXx8Zi50aHJvd0Vycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KSwwPT09ci5kZWNpbWFscylyZXR1cm4gYy5iaWdOdW1iZXJpZnkoZSk7dmFyIG49XCItXCI9PT1lLnN1YnN0cmluZygwLDEpO24mJihlPWUuc3Vic3RyaW5nKDEpKSxcIi5cIj09PWUmJmYudGhyb3dFcnJvcihcIm1pc3NpbmcgdmFsdWVcIixmLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pO3ZhciBpPWUuc3BsaXQoXCIuXCIpOzI8aS5sZW5ndGgmJmYudGhyb3dFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KTt2YXIgbz1pWzBdLHM9aVsxXSxvPW98fFwiMFwiO2Zvcigocz1zfHxcIjBcIikubGVuZ3RoPnIuZGVjaW1hbHMmJmYudGhyb3dFcnJvcihcInVuZGVyZmxvdyBvY2N1cnJlZFwiLGYuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiZGl2aXNpb25cIixmYXVsdDpcInVuZGVyZmxvd1wifSk7cy5sZW5ndGg8ci5kZWNpbWFsczspcys9XCIwXCI7dmFyIGE9Yy5iaWdOdW1iZXJpZnkobyksdT1jLmJpZ051bWJlcmlmeShzKSxsPWEubXVsKHIudGVuUG93ZXIpLmFkZCh1KTtyZXR1cm4gbiYmKGw9bC5tdWwoaC5OZWdhdGl2ZU9uZSkpLGx9aT1cIjFcIixbXCJ3ZWlcIixcImt3ZWlcIixcIk13ZWlcIixcIkd3ZWlcIixcInN6YWJvXCIsXCJmaW5uZXlcIixcImV0aGVyXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9cyhpKTtvW2UudG9Mb3dlckNhc2UoKV09dCxvW1N0cmluZyh0LmRlY2ltYWxzKV09dCxpKz1cIjAwMFwifSksci5jb21taWZ5PWZ1bmN0aW9uKGUpe3ZhciB0PVN0cmluZyhlKS5zcGxpdChcIi5cIik7KDI8dC5sZW5ndGh8fCF0WzBdLm1hdGNoKC9eLT9bMC05XSokLyl8fHRbMV0mJiF0WzFdLm1hdGNoKC9eWzAtOV0qJC8pfHxcIi5cIj09PWV8fFwiLS5cIj09PWUpJiZmLnRocm93RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInZhbHVlXCIsdmFsdWU6ZX0pO3ZhciByPXRbMF0sbj1cIlwiO2ZvcihcIi1cIj09PXIuc3Vic3RyaW5nKDAsMSkmJihuPVwiLVwiLHI9ci5zdWJzdHJpbmcoMSkpO1wiMFwiPT09ci5zdWJzdHJpbmcoMCwxKTspcj1yLnN1YnN0cmluZygxKTtcIlwiPT09ciYmKHI9XCIwXCIpO3ZhciBpPVwiXCI7Mj09PXQubGVuZ3RoJiYoaT1cIi5cIisodFsxXXx8XCIwXCIpKTtmb3IodmFyIG89W107ci5sZW5ndGg7KXtpZihyLmxlbmd0aDw9Myl7by51bnNoaWZ0KHIpO2JyZWFrfXZhciBzPXIubGVuZ3RoLTM7by51bnNoaWZ0KHIuc3Vic3RyaW5nKHMpKSxyPXIuc3Vic3RyaW5nKDAscyl9cmV0dXJuIG4rby5qb2luKFwiLFwiKStpfSxyLmZvcm1hdFVuaXRzPWEsci5wYXJzZVVuaXRzPXUsci5mb3JtYXRFdGhlcj1mdW5jdGlvbihlKXtyZXR1cm4gYShlLDE4KX0sci5wYXJzZUV0aGVyPWZ1bmN0aW9uKGUpe3JldHVybiB1KGUsMTgpfX0se1wiLi4vY29uc3RhbnRzXCI6MyxcIi4uL2Vycm9yc1wiOjUsXCIuL2JpZ251bWJlclwiOjYzfV0sODU6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxuLGk9ZShcIi4uL2NvbnN0YW50c1wiKSxhPWUoXCIuLi9lcnJvcnNcIiksaD1lKFwiLi9ieXRlc1wiKTtmdW5jdGlvbiBvKGUsdCl7dm9pZCAwPT09dCYmKHQ9cy5jdXJyZW50KSx0IT1zLmN1cnJlbnQmJihhLmNoZWNrTm9ybWFsaXplKCksZT1lLm5vcm1hbGl6ZSh0KSk7Zm9yKHZhciByPVtdLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZS5jaGFyQ29kZUF0KG4pO2lmKGk8MTI4KXIucHVzaChpKTtlbHNlIGlmKGk8MjA0OClyLnB1c2goaT4+NnwxOTIpLHIucHVzaCg2MyZpfDEyOCk7ZWxzZSBpZig1NTI5Nj09KDY0NTEyJmkpKXtuKys7dmFyIG89ZS5jaGFyQ29kZUF0KG4pO2lmKG4+PWUubGVuZ3RofHw1NjMyMCE9KDY0NTEyJm8pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO2k9NjU1MzYrKCgxMDIzJmkpPDwxMCkrKDEwMjMmbyksci5wdXNoKGk+PjE4fDI0MCksci5wdXNoKGk+PjEyJjYzfDEyOCksci5wdXNoKGk+PjYmNjN8MTI4KSxyLnB1c2goNjMmaXwxMjgpfWVsc2Ugci5wdXNoKGk+PjEyfDIyNCksci5wdXNoKGk+PjYmNjN8MTI4KSxyLnB1c2goNjMmaXwxMjgpfXJldHVybiBoLmFycmF5aWZ5KHIpfWZ1bmN0aW9uIHUoZSx0KXtlPWguYXJyYXlpZnkoZSk7Zm9yKHZhciByPVwiXCIsbj0wO248ZS5sZW5ndGg7KXt2YXIgaT1lW24rK107aWYoaT4+NyE9MCl7dmFyIG89bnVsbCxzPW51bGw7aWYoMTkyPT0oMjI0JmkpKW89MSxzPTEyNztlbHNlIGlmKDIyND09KDI0MCZpKSlvPTIscz0yMDQ3O2Vsc2V7aWYoMjQwIT0oMjQ4JmkpKXtpZih0KWNvbnRpbnVlO2lmKDEyOD09KDE5MiZpKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiKTt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgaW52YWxpZCBwcmVmaXhcIil9bz0zLHM9NjU1MzV9aWYobitvPmUubGVuZ3RoKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdG9vIHNob3J0XCIpO2Zvcig7bjxlLmxlbmd0aCYmZVtuXT4+Nj09MjtuKyspO31lbHNle2Zvcih2YXIgYT1pJigxPDw4LW8tMSktMSx1PTA7dTxvO3UrKyl7dmFyIGw9ZVtuXTtpZigxMjghPSgxOTImbCkpe2E9bnVsbDticmVha31hPWE8PDZ8NjMmbCxuKyt9aWYobnVsbCE9PWEpaWYoYTw9cyl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGY4IGJ5dGUgc2VxdWVuY2U7IG92ZXJsb25nXCIpfWVsc2UgaWYoMTExNDExMTxhKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgb3V0LW9mLXJhbmdlXCIpfWVsc2UgaWYoNTUyOTY8PWEmJmE8PTU3MzQzKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdXRmLTE2IHN1cnJvZ2F0ZVwiKX1lbHNlIGE8PTY1NTM1P3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGE+PjEwJjEwMjMpLDU2MzIwKygxMDIzJmEpKSk7ZWxzZSBpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVwiKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpfXJldHVybiByfShuPXM9ci5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm18fChyLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybT17fSkpLmN1cnJlbnQ9XCJcIixuLk5GQz1cIk5GQ1wiLG4uTkZEPVwiTkZEXCIsbi5ORktDPVwiTkZLQ1wiLG4uTkZLRD1cIk5GS0RcIixyLnRvVXRmOEJ5dGVzPW8sci50b1V0ZjhTdHJpbmc9dSxyLmZvcm1hdEJ5dGVzMzJTdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9byhlKTtpZigzMTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKTtyZXR1cm4gaC5oZXhsaWZ5KGguY29uY2F0KFt0LGkuSGFzaFplcm9dKS5zbGljZSgwLDMyKSl9LHIucGFyc2VCeXRlczMyU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PWguYXJyYXlpZnkoZSk7aWYoMzIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKTtpZigwIT09dFszMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIHN0cmluZyAtIG5vIG51bGwgdGVybWluYXRvclwiKTtmb3IodmFyIHI9MzE7MD09PXRbci0xXTspci0tO3JldHVybiB1KHQuc2xpY2UoMCxyKSl9fSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NH1dLDg2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZj1lKFwieG1saHR0cHJlcXVlc3RcIiksaT1lKFwiLi9iYXNlNjRcIiksbz1lKFwiLi9wcm9wZXJ0aWVzXCIpLHM9ZShcIi4vdXRmOFwiKSxjPW4oZShcIi4uL2Vycm9yc1wiKSk7ci5mZXRjaEpzb249ZnVuY3Rpb24oZSxhLHUpe3ZhciB0LHI9e30sbD1udWxsLGg9MTJlNDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlsPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYobnVsbD09ZS51cmwmJmMudGhyb3dFcnJvcihcIm1pc3NpbmcgVVJMXCIsYy5NSVNTSU5HX0FSR1VNRU5ULHthcmc6XCJ1cmxcIn0pLGw9ZS51cmwsXCJudW1iZXJcIj09dHlwZW9mIGUudGltZW91dCYmMDxlLnRpbWVvdXQmJihoPWUudGltZW91dCksZS5oZWFkZXJzKWZvcih2YXIgbiBpbiBlLmhlYWRlcnMpcltuLnRvTG93ZXJDYXNlKCldPXtrZXk6bix2YWx1ZTpTdHJpbmcoZS5oZWFkZXJzW25dKX07bnVsbCE9ZS51c2VyJiZudWxsIT1lLnBhc3N3b3JkJiYoXCJodHRwczpcIiE9PWwuc3Vic3RyaW5nKDAsNikmJiEwIT09ZS5hbGxvd0luc2VjdXJlJiZjLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIixjLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInVybFwiLHVybDpsLHVzZXI6ZS51c2VyLHBhc3N3b3JkOlwiW1JFREFDVEVEXVwifSksdD1lLnVzZXIrXCI6XCIrZS5wYXNzd29yZCxyLmF1dGhvcml6YXRpb249e2tleTpcIkF1dGhvcml6YXRpb25cIix2YWx1ZTpcIkJhc2ljIFwiK2kuZW5jb2RlKHMudG9VdGY4Qnl0ZXModCkpfSl9cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4saSl7ZnVuY3Rpb24gbygpe251bGwhPWUmJihjbGVhclRpbWVvdXQoZSksZT1udWxsKX12YXIgcz1uZXcgZi5YTUxIdHRwUmVxdWVzdCxlPW51bGwsZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbCE9ZSYmKGU9bnVsbCxpKG5ldyBFcnJvcihcInRpbWVvdXRcIikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLmFib3J0KCl9LDApKX0saCk7YT8ocy5vcGVuKFwiUE9TVFwiLGwsITApLHJbXCJjb250ZW50LXR5cGVcIl09e2tleTpcIkNvbnRlbnQtVHlwZVwiLHZhbHVlOlwiYXBwbGljYXRpb24vanNvblwifSk6cy5vcGVuKFwiR0VUXCIsbCwhMCksT2JqZWN0LmtleXMocikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yW2VdO3Muc2V0UmVxdWVzdEhlYWRlcih0LmtleSx0LnZhbHVlKX0pLHMub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoND09PXMucmVhZHlTdGF0ZSl7aWYoMjAwIT1zLnN0YXR1cyl7bygpO3ZhciBlPW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2UgLSBcIitzLnN0YXR1cyk7cmV0dXJuIGUuc3RhdHVzQ29kZT1zLnN0YXR1cyxzLnJlc3BvbnNlVGV4dCYmKGUucmVzcG9uc2VUZXh0PXMucmVzcG9uc2VUZXh0KSx2b2lkIGkoZSl9dmFyIHQ9bnVsbDt0cnl7dD1KU09OLnBhcnNlKHMucmVzcG9uc2VUZXh0KX1jYXRjaChlKXtvKCk7dmFyIHI9bmV3IEVycm9yKFwiaW52YWxpZCBqc29uIHJlc3BvbnNlXCIpO3JldHVybiByLm9yZ2luaWFsRXJyb3I9ZSxyLnJlc3BvbnNlVGV4dD1zLnJlc3BvbnNlVGV4dCxudWxsIT1hJiYoci5yZXF1ZXN0Qm9keT1hKSxyLnVybD1sLHZvaWQgaShyKX1pZih1KXRyeXt0PXUodCl9Y2F0Y2goZSl7cmV0dXJuIG8oKSxlLnVybD1sLGUuYm9keT1hLGUucmVzcG9uc2VUZXh0PXMucmVzcG9uc2VUZXh0LHZvaWQgaShlKX1vKCksbih0KX19LHMub25lcnJvcj1mdW5jdGlvbihlKXtvKCksaShlKX07dHJ5e251bGwhPWE/cy5zZW5kKGEpOnMuc2VuZCgpfWNhdGNoKGUpe28oKTt2YXIgdD1uZXcgRXJyb3IoXCJjb25uZWN0aW9uIGVycm9yXCIpO3QuZXJyb3I9ZSxpKHQpfX0pfSxyLnBvbGw9ZnVuY3Rpb24odSxsKXtyZXR1cm4gbD1sfHx7fSxudWxsPT0obD1vLnNoYWxsb3dDb3B5KGwpKS5mbG9vciYmKGwuZmxvb3I9MCksbnVsbD09bC5jZWlsaW5nJiYobC5jZWlsaW5nPTFlNCksbnVsbD09bC5pbnRlcnZhbCYmKGwuaW50ZXJ2YWw9MjUwKSxuZXcgUHJvbWlzZShmdW5jdGlvbihuLHQpe3ZhciBlPW51bGwsaT0hMSxvPWZ1bmN0aW9uKCl7cmV0dXJuIWkmJihpPSEwLGUmJmNsZWFyVGltZW91dChlKSwhMCl9O2wudGltZW91dCYmKGU9c2V0VGltZW91dChmdW5jdGlvbigpe28oKSYmdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKX0sbC50aW1lb3V0KSk7dmFyIHM9bC5mYXN0UmV0cnl8fG51bGwsYT0wOyFmdW5jdGlvbiByKCl7cmV0dXJuIHUoKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiB2b2lkIDAhPT1lP28oKSYmbihlKTpsLm9uY2VCbG9jaz9sLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIixyKTppfHwoYSsrLCh0PWwuaW50ZXJ2YWwqcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMixhKSkpKTxsLmZsb29yJiYodD1sLmZsb29yKSx0PmwuY2VpbGluZyYmKHQ9bC5jZWlsaW5nKSxzJiYoYS0tLHQ9cyxzPW51bGwpLHNldFRpbWVvdXQocix0KSksbnVsbH0sZnVuY3Rpb24oZSl7bygpJiZ0KGUpfSl9KCl9KX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2Jhc2U2NFwiOjYxLFwiLi9wcm9wZXJ0aWVzXCI6NzQsXCIuL3V0ZjhcIjo4NSx4bWxodHRwcmVxdWVzdDo0OX1dLDg3OltmdW5jdGlvbihvLGUscyl7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW8oXCIuLi91dGlscy9oYXNoXCIpLHQ9byhcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIik7cy5jaGVjaz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8MjA0ODtyKyspe3ZhciBuPWUuZ2V0V29yZChyKTtpZihyIT09ZS5nZXRXb3JkSW5kZXgobikpcmV0dXJuXCIweFwiO3QucHVzaChuKX1yZXR1cm4gaS5pZCh0LmpvaW4oXCJcXG5cIikrXCJcXG5cIil9O3ZhciByPShuLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlKXtyZXR1cm4gZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKy9nKX0sbi5wcm90b3R5cGUuam9pbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5qb2luKFwiIFwiKX0sbik7ZnVuY3Rpb24gbihlKXt0LmRlZmluZVJlYWRPbmx5KHRoaXMsXCJsb2NhbGVcIixlKX1zLldvcmRsaXN0PXIscy5yZWdpc3Rlcj1mdW5jdGlvbihlLHQpe3Q9dHx8ZS5sb2NhbGV9fSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7XCIuLi91dGlscy9oYXNoXCI6NjUsXCIuLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw4ODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxhPWUoXCIuL3V0aWxzL2J5dGVzXCIpLHU9ZShcIi4vdXRpbHMvaGFzaFwiKSxsPWUoXCIuL3V0aWxzL2hkbm9kZVwiKSxoPWUoXCIuL3V0aWxzL2pzb24td2FsbGV0XCIpLGY9ZShcIi4vdXRpbHMva2VjY2FrMjU2XCIpLGM9ZShcIi4vdXRpbHMvcHJvcGVydGllc1wiKSxkPWUoXCIuL3V0aWxzL3JhbmRvbS1ieXRlc1wiKSxwPW8oZShcIi4vdXRpbHMvc2VjcmV0LXN0b3JhZ2VcIikpLHY9ZShcIi4vdXRpbHMvc2lnbmluZy1rZXlcIikseT1lKFwiLi91dGlscy90cmFuc2FjdGlvblwiKSxtPWUoXCIuL2Fic3RyYWN0LXNpZ25lclwiKSxnPWUoXCIuL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclwiKSxiPW8oZShcIi4vZXJyb3JzXCIpKSx3PShzPW0uU2lnbmVyLGkoXyxzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJhZGRyZXNzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpZ25pbmdLZXkuYWRkcmVzc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJtbmVtb25pY1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaWduaW5nS2V5Lm1uZW1vbmljfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInBhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wYXRofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInByaXZhdGVLZXlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wcml2YXRlS2V5fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLF8ucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGcuUHJvdmlkZXIuaXNQcm92aWRlcihlKXx8Yi50aHJvd0Vycm9yKFwiaW52YWxpZCBwcm92aWRlclwiLGIuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJwcm92aWRlclwiLHZhbHVlOmV9KSxuZXcgXyh0aGlzLnNpZ25pbmdLZXksZSl9LF8ucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyl9LF8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyhlKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXkuc2VyaWFsaXplKGUpLHI9bi5zaWduaW5nS2V5LnNpZ25EaWdlc3QoZi5rZWNjYWsyNTYodCkpO3JldHVybiB5LnNlcmlhbGl6ZShlLHIpfSl9LF8ucHJvdG90eXBlLnNpZ25NZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoYS5qb2luU2lnbmF0dXJlKHRoaXMuc2lnbmluZ0tleS5zaWduRGlnZXN0KHUuaGFzaE1lc3NhZ2UoZSkpKSl9LF8ucHJvdG90eXBlLmdldEJhbGFuY2U9ZnVuY3Rpb24oZSl7aWYoIXRoaXMucHJvdmlkZXIpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm92aWRlclwiKTtyZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuYWRkcmVzcyxlKX0sXy5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25Db3VudD1mdW5jdGlvbihlKXtpZighdGhpcy5wcm92aWRlcil0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIpO3JldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5hZGRyZXNzLGUpfSxfLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5wcm92aWRlcil0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIpO3JldHVybiBudWxsPT1lLm5vbmNlJiYoKGU9Yy5zaGFsbG93Q29weShlKSkubm9uY2U9dGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KFwicGVuZGluZ1wiKSkseS5wb3B1bGF0ZVRyYW5zYWN0aW9uKGUsdGhpcy5wcm92aWRlcix0aGlzLmFkZHJlc3MpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHQuc2lnbihlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0LnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihlKX0pfSl9LF8ucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fHJ8fChyPXQsdD17fSksciYmXCJmdW5jdGlvblwiIT10eXBlb2Ygcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO3JldHVybiB0PXR8fHt9LHRoaXMubW5lbW9uaWMmJigodD1jLnNoYWxsb3dDb3B5KHQpKS5tbmVtb25pYz10aGlzLm1uZW1vbmljLHQucGF0aD10aGlzLnBhdGgpLHAuZW5jcnlwdCh0aGlzLnByaXZhdGVLZXksZSx0LHIpfSxfLmNyZWF0ZVJhbmRvbT1mdW5jdGlvbihlKXt2YXIgdD1kLnJhbmRvbUJ5dGVzKDE2KTsoZT1lfHx7fSkuZXh0cmFFbnRyb3B5JiYodD1hLmFycmF5aWZ5KGYua2VjY2FrMjU2KGEuY29uY2F0KFt0LGUuZXh0cmFFbnRyb3B5XSkpLnN1YnN0cmluZygwLDM0KSkpO3ZhciByPWwuZW50cm9weVRvTW5lbW9uaWModCxlLmxvY2FsZSk7cmV0dXJuIF8uZnJvbU1uZW1vbmljKHIsZS5wYXRoLGUubG9jYWxlKX0sXy5mcm9tRW5jcnlwdGVkSnNvbj1mdW5jdGlvbihlLHQscil7aWYoaC5pc0Nyb3dkc2FsZVdhbGxldChlKSl0cnl7ciYmcigwKTt2YXIgbj1wLmRlY3J5cHRDcm93ZHNhbGUoZSx0KTtyZXR1cm4gciYmcigxKSxQcm9taXNlLnJlc29sdmUobmV3IF8obikpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX1lbHNlIGlmKGguaXNTZWNyZXRTdG9yYWdlV2FsbGV0KGUpKXJldHVybiBwLmRlY3J5cHQoZSx0LHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBfKGUpfSk7cmV0dXJuIFByb21pc2UucmVqZWN0KFwiaW52YWxpZCB3YWxsZXQgSlNPTlwiKX0sXy5mcm9tTW5lbW9uaWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0PXR8fGwuZGVmYXVsdFBhdGgsbmV3IF8obC5mcm9tTW5lbW9uaWMoZSxyKS5kZXJpdmVQYXRoKHQpKX0sXyk7ZnVuY3Rpb24gXyhlLHQpe3ZhciByPXMuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gYi5jaGVja05ldyhyLF8pLHYuU2lnbmluZ0tleS5pc1NpZ25pbmdLZXkoZSk/Yy5kZWZpbmVSZWFkT25seShyLFwic2lnbmluZ0tleVwiLGUpOmMuZGVmaW5lUmVhZE9ubHkocixcInNpZ25pbmdLZXlcIixuZXcgdi5TaWduaW5nS2V5KGUpKSxjLmRlZmluZVJlYWRPbmx5KHIsXCJwcm92aWRlclwiLHQpLHJ9ci5XYWxsZXQ9d30se1wiLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vdXRpbHMvYnl0ZXNcIjo2NCxcIi4vdXRpbHMvaGFzaFwiOjY1LFwiLi91dGlscy9oZG5vZGVcIjo2NixcIi4vdXRpbHMvanNvbi13YWxsZXRcIjo3MCxcIi4vdXRpbHMva2VjY2FrMjU2XCI6NzEsXCIuL3V0aWxzL3Byb3BlcnRpZXNcIjo3NCxcIi4vdXRpbHMvcmFuZG9tLWJ5dGVzXCI6NzUsXCIuL3V0aWxzL3NlY3JldC1zdG9yYWdlXCI6NzgsXCIuL3V0aWxzL3NpZ25pbmcta2V5XCI6ODEsXCIuL3V0aWxzL3RyYW5zYWN0aW9uXCI6ODN9XSw4OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPWUoXCIuLi93b3JkbGlzdHMvbGFuZy1lblwiKS5sYW5nRW47ci5lbj1ufSx7XCIuLi93b3JkbGlzdHMvbGFuZy1lblwiOjkwfV0sOTA6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbyxzPWUoXCIuLi91dGlscy93b3JkbGlzdFwiKSxhPVwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiLHU9bnVsbDtmdW5jdGlvbiBsKGUpe2lmKG51bGw9PXUmJih1PWEucmVwbGFjZSgvKFtBLVpdKS9nLFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKSxcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiIT09cy5jaGVjayhlKSkpdGhyb3cgdT1udWxsLG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBlbiAoRW5nbGlzaCkgRkFJTEVEXCIpfWZ1bmN0aW9uIGgoKXtyZXR1cm4gby5jYWxsKHRoaXMsXCJlblwiKXx8dGhpc312YXIgZj1uZXcobz1zLldvcmRsaXN0LGkoaCxvKSxoLnByb3RvdHlwZS5nZXRXb3JkPWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMpLHVbZV19LGgucHJvdG90eXBlLmdldFdvcmRJbmRleD1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzKSx1LmluZGV4T2YoZSl9LGgpO3IubGFuZ0VuPWYscy5yZWdpc3RlcihmKX0se1wiLi4vdXRpbHMvd29yZGxpc3RcIjo4N31dfSx7fSxbN10pKDcpfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMubWluLmpzLm1hcFxuIiwiLyoqXG4gKiBbanMtc2hhMjU2XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Nn1cbiAqXG4gKiBAdmVyc2lvbiAwLjkuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBFUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTI1Nl9OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcbiAgICByb290ID0gc2VsZjtcbiAgfVxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBMjU2X05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG4gIHZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xuICB2YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbiAgXTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2FycmF5JywgJ2RpZ2VzdCcsICdhcnJheUJ1ZmZlciddO1xuXG4gIHZhciBibG9ja3MgPSBbXTtcblxuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBMjU2X05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKCdoZXgnLCBpczIyNCk7XG4gICAgaWYgKE5PREVfSlMpIHtcbiAgICAgIG1ldGhvZCA9IG5vZGVXcmFwKG1ldGhvZCwgaXMyMjQpO1xuICAgIH1cbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGEyNTYoaXMyMjQpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZCh0eXBlLCBpczIyNCk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIG5vZGVXcmFwID0gZnVuY3Rpb24gKG1ldGhvZCwgaXMyMjQpIHtcbiAgICB2YXIgY3J5cHRvID0gKDAsZXZhbCkoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gKDAsZXZhbCkoXCJyZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcIik7XG4gICAgdmFyIGFsZ29yaXRobSA9IGlzMjI0ID8gJ3NoYTIyNCcgOiAnc2hhMjU2JztcbiAgICB2YXIgbm9kZU1ldGhvZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShtZXNzYWdlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkgfHxcbiAgICAgICAgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShuZXcgQnVmZmVyKG1lc3NhZ2UpKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBub2RlTWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGlzMjI0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgSG1hY1NoYTI1NihrZXksIGlzMjI0LCB0cnVlKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVIbWFjTWV0aG9kID0gZnVuY3Rpb24gKGlzMjI0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QoJ2hleCcsIGlzMjI0KTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhMjU2KGtleSwgaXMyMjQpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSkudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlSG1hY091dHB1dE1ldGhvZCh0eXBlLCBpczIyNCk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgZnVuY3Rpb24gU2hhMjU2KGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoaXMyMjQpIHtcbiAgICAgIHRoaXMuaDAgPSAweGMxMDU5ZWQ4O1xuICAgICAgdGhpcy5oMSA9IDB4MzY3Y2Q1MDc7XG4gICAgICB0aGlzLmgyID0gMHgzMDcwZGQxNztcbiAgICAgIHRoaXMuaDMgPSAweGY3MGU1OTM5O1xuICAgICAgdGhpcy5oNCA9IDB4ZmZjMDBiMzE7XG4gICAgICB0aGlzLmg1ID0gMHg2ODU4MTUxMTtcbiAgICAgIHRoaXMuaDYgPSAweDY0Zjk4ZmE3O1xuICAgICAgdGhpcy5oNyA9IDB4YmVmYTRmYTQ7XG4gICAgfSBlbHNlIHsgLy8gMjU2XG4gICAgICB0aGlzLmgwID0gMHg2YTA5ZTY2NztcbiAgICAgIHRoaXMuaDEgPSAweGJiNjdhZTg1O1xuICAgICAgdGhpcy5oMiA9IDB4M2M2ZWYzNzI7XG4gICAgICB0aGlzLmgzID0gMHhhNTRmZjUzYTtcbiAgICAgIHRoaXMuaDQgPSAweDUxMGU1MjdmO1xuICAgICAgdGhpcy5oNSA9IDB4OWIwNTY4OGM7XG4gICAgICB0aGlzLmg2ID0gMHgxZjgzZDlhYjtcbiAgICAgIHRoaXMuaDcgPSAweDViZTBjZDE5O1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2sgPSB0aGlzLnN0YXJ0ID0gdGhpcy5ieXRlcyA9IHRoaXMuaEJ5dGVzID0gMDtcbiAgICB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdCA9IHRydWU7XG4gICAgdGhpcy5pczIyNCA9IGlzMjI0O1xuICB9XG5cbiAgU2hhMjU2LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgYmxvY2tzWzE2XSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9XG4gICAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgICAgYmxvY2tzWzEyXSA9IGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gNjQ7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICB0aGlzLmhCeXRlcyArPSB0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NiA8PCAwO1xuICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4O1xuICAgIGJsb2Nrc1sxNl0gPSB0aGlzLmJsb2NrO1xuICAgIGJsb2Nrc1tpID4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgaWYgKCF0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgIH1cbiAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICB9XG4gICAgYmxvY2tzWzE0XSA9IHRoaXMuaEJ5dGVzIDw8IDMgfCB0aGlzLmJ5dGVzID4+PiAyOTtcbiAgICBibG9ja3NbMTVdID0gdGhpcy5ieXRlcyA8PCAzO1xuICAgIHRoaXMuaGFzaCgpO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IHRoaXMuaDAsIGIgPSB0aGlzLmgxLCBjID0gdGhpcy5oMiwgZCA9IHRoaXMuaDMsIGUgPSB0aGlzLmg0LCBmID0gdGhpcy5oNSwgZyA9IHRoaXMuaDYsXG4gICAgICBoID0gdGhpcy5oNywgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGosIHMwLCBzMSwgbWFqLCB0MSwgdDIsIGNoLCBhYiwgZGEsIGNkLCBiYztcblxuICAgIGZvciAoaiA9IDE2OyBqIDwgNjQ7ICsraikge1xuICAgICAgLy8gcmlnaHRyb3RhdGVcbiAgICAgIHQxID0gYmxvY2tzW2ogLSAxNV07XG4gICAgICBzMCA9ICgodDEgPj4+IDcpIHwgKHQxIDw8IDI1KSkgXiAoKHQxID4+PiAxOCkgfCAodDEgPDwgMTQpKSBeICh0MSA+Pj4gMyk7XG4gICAgICB0MSA9IGJsb2Nrc1tqIC0gMl07XG4gICAgICBzMSA9ICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF4gKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXiAodDEgPj4+IDEwKTtcbiAgICAgIGJsb2Nrc1tqXSA9IGJsb2Nrc1tqIC0gMTZdICsgczAgKyBibG9ja3NbaiAtIDddICsgczEgPDwgMDtcbiAgICB9XG5cbiAgICBiYyA9IGIgJiBjO1xuICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaiArPSA0KSB7XG4gICAgICBpZiAodGhpcy5maXJzdCkge1xuICAgICAgICBpZiAodGhpcy5pczIyNCkge1xuICAgICAgICAgIGFiID0gMzAwMDMyO1xuICAgICAgICAgIHQxID0gYmxvY2tzWzBdIC0gMTQxMzI1NzgxOTtcbiAgICAgICAgICBoID0gdDEgLSAxNTAwNTQ1OTkgPDwgMDtcbiAgICAgICAgICBkID0gdDEgKyAyNDE3NzA3NyA8PCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFiID0gNzA0NzUxMTA5O1xuICAgICAgICAgIHQxID0gYmxvY2tzWzBdIC0gMjEwMjQ0MjQ4O1xuICAgICAgICAgIGggPSB0MSAtIDE1MjE0ODY1MzQgPDwgMDtcbiAgICAgICAgICBkID0gdDEgKyAxNDM2OTQ1NjUgPDwgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9ICgoYSA+Pj4gMikgfCAoYSA8PCAzMCkpIF4gKChhID4+PiAxMykgfCAoYSA8PCAxOSkpIF4gKChhID4+PiAyMikgfCAoYSA8PCAxMCkpO1xuICAgICAgICBzMSA9ICgoZSA+Pj4gNikgfCAoZSA8PCAyNikpIF4gKChlID4+PiAxMSkgfCAoZSA8PCAyMSkpIF4gKChlID4+PiAyNSkgfCAoZSA8PCA3KSk7XG4gICAgICAgIGFiID0gYSAmIGI7XG4gICAgICAgIG1haiA9IGFiIF4gKGEgJiBjKSBeIGJjO1xuICAgICAgICBjaCA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgICAgdDEgPSBoICsgczEgKyBjaCArIEtbal0gKyBibG9ja3Nbal07XG4gICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgIGggPSBkICsgdDEgPDwgMDtcbiAgICAgICAgZCA9IHQxICsgdDIgPDwgMDtcbiAgICAgIH1cbiAgICAgIHMwID0gKChkID4+PiAyKSB8IChkIDw8IDMwKSkgXiAoKGQgPj4+IDEzKSB8IChkIDw8IDE5KSkgXiAoKGQgPj4+IDIyKSB8IChkIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoaCA+Pj4gNikgfCAoaCA8PCAyNikpIF4gKChoID4+PiAxMSkgfCAoaCA8PCAyMSkpIF4gKChoID4+PiAyNSkgfCAoaCA8PCA3KSk7XG4gICAgICBkYSA9IGQgJiBhO1xuICAgICAgbWFqID0gZGEgXiAoZCAmIGIpIF4gYWI7XG4gICAgICBjaCA9IChoICYgZSkgXiAofmggJiBmKTtcbiAgICAgIHQxID0gZyArIHMxICsgY2ggKyBLW2ogKyAxXSArIGJsb2Nrc1tqICsgMV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZyA9IGMgKyB0MSA8PCAwO1xuICAgICAgYyA9IHQxICsgdDIgPDwgMDtcbiAgICAgIHMwID0gKChjID4+PiAyKSB8IChjIDw8IDMwKSkgXiAoKGMgPj4+IDEzKSB8IChjIDw8IDE5KSkgXiAoKGMgPj4+IDIyKSB8IChjIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoZyA+Pj4gNikgfCAoZyA8PCAyNikpIF4gKChnID4+PiAxMSkgfCAoZyA8PCAyMSkpIF4gKChnID4+PiAyNSkgfCAoZyA8PCA3KSk7XG4gICAgICBjZCA9IGMgJiBkO1xuICAgICAgbWFqID0gY2QgXiAoYyAmIGEpIF4gZGE7XG4gICAgICBjaCA9IChnICYgaCkgXiAofmcgJiBlKTtcbiAgICAgIHQxID0gZiArIHMxICsgY2ggKyBLW2ogKyAyXSArIGJsb2Nrc1tqICsgMl07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZiA9IGIgKyB0MSA8PCAwO1xuICAgICAgYiA9IHQxICsgdDIgPDwgMDtcbiAgICAgIHMwID0gKChiID4+PiAyKSB8IChiIDw8IDMwKSkgXiAoKGIgPj4+IDEzKSB8IChiIDw8IDE5KSkgXiAoKGIgPj4+IDIyKSB8IChiIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoZiA+Pj4gNikgfCAoZiA8PCAyNikpIF4gKChmID4+PiAxMSkgfCAoZiA8PCAyMSkpIF4gKChmID4+PiAyNSkgfCAoZiA8PCA3KSk7XG4gICAgICBiYyA9IGIgJiBjO1xuICAgICAgbWFqID0gYmMgXiAoYiAmIGQpIF4gY2Q7XG4gICAgICBjaCA9IChmICYgZykgXiAofmYgJiBoKTtcbiAgICAgIHQxID0gZSArIHMxICsgY2ggKyBLW2ogKyAzXSArIGJsb2Nrc1tqICsgM107XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZSA9IGEgKyB0MSA8PCAwO1xuICAgICAgYSA9IHQxICsgdDIgPDwgMDtcbiAgICB9XG5cbiAgICB0aGlzLmgwID0gdGhpcy5oMCArIGEgPDwgMDtcbiAgICB0aGlzLmgxID0gdGhpcy5oMSArIGIgPDwgMDtcbiAgICB0aGlzLmgyID0gdGhpcy5oMiArIGMgPDwgMDtcbiAgICB0aGlzLmgzID0gdGhpcy5oMyArIGQgPDwgMDtcbiAgICB0aGlzLmg0ID0gdGhpcy5oNCArIGUgPDwgMDtcbiAgICB0aGlzLmg1ID0gdGhpcy5oNSArIGYgPDwgMDtcbiAgICB0aGlzLmg2ID0gdGhpcy5oNiArIGcgPDwgMDtcbiAgICB0aGlzLmg3ID0gdGhpcy5oNyArIGggPDwgMDtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSxcbiAgICAgIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuXG4gICAgdmFyIGhleCA9IEhFWF9DSEFSU1soaDAgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gwICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDEgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMiAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gzICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDQgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g2ICYgMHgwRl07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICBoZXggKz0gSEVYX0NIQVJTWyhoNyA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDcgJiAweDBGXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMjU2LnByb3RvdHlwZS5oZXg7XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsXG4gICAgICBoNiA9IHRoaXMuaDYsIGg3ID0gdGhpcy5oNztcblxuICAgIHZhciBhcnIgPSBbXG4gICAgICAoaDAgPj4gMjQpICYgMHhGRiwgKGgwID4+IDE2KSAmIDB4RkYsIChoMCA+PiA4KSAmIDB4RkYsIGgwICYgMHhGRixcbiAgICAgIChoMSA+PiAyNCkgJiAweEZGLCAoaDEgPj4gMTYpICYgMHhGRiwgKGgxID4+IDgpICYgMHhGRiwgaDEgJiAweEZGLFxuICAgICAgKGgyID4+IDI0KSAmIDB4RkYsIChoMiA+PiAxNikgJiAweEZGLCAoaDIgPj4gOCkgJiAweEZGLCBoMiAmIDB4RkYsXG4gICAgICAoaDMgPj4gMjQpICYgMHhGRiwgKGgzID4+IDE2KSAmIDB4RkYsIChoMyA+PiA4KSAmIDB4RkYsIGgzICYgMHhGRixcbiAgICAgIChoNCA+PiAyNCkgJiAweEZGLCAoaDQgPj4gMTYpICYgMHhGRiwgKGg0ID4+IDgpICYgMHhGRiwgaDQgJiAweEZGLFxuICAgICAgKGg1ID4+IDI0KSAmIDB4RkYsIChoNSA+PiAxNikgJiAweEZGLCAoaDUgPj4gOCkgJiAweEZGLCBoNSAmIDB4RkYsXG4gICAgICAoaDYgPj4gMjQpICYgMHhGRiwgKGg2ID4+IDE2KSAmIDB4RkYsIChoNiA+PiA4KSAmIDB4RkYsIGg2ICYgMHhGRlxuICAgIF07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICBhcnIucHVzaCgoaDcgPj4gMjQpICYgMHhGRiwgKGg3ID4+IDE2KSAmIDB4RkYsIChoNyA+PiA4KSAmIDB4RkYsIGg3ICYgMHhGRik7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5hcnJheSA9IFNoYTI1Ni5wcm90b3R5cGUuZGlnZXN0O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmlzMjI0ID8gMjggOiAzMik7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDAsIHRoaXMuaDApO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig0LCB0aGlzLmgxKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoOCwgdGhpcy5oMik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDEyLCB0aGlzLmgzKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTYsIHRoaXMuaDQpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigyMCwgdGhpcy5oNSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDI0LCB0aGlzLmg2KTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMigyOCwgdGhpcy5oNyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gSG1hY1NoYTI1NihrZXksIGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICB2YXIgaSwgdHlwZSA9IHR5cGVvZiBrZXk7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBbXSwgbGVuZ3RoID0ga2V5Lmxlbmd0aCwgaW5kZXggPSAwLCBjb2RlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4YzAgfCAoY29kZSA+PiA2KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweGUwIHwgKGNvZGUgPj4gMTIpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXkgPSBieXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBrZXkuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAga2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5Lmxlbmd0aCA+IDY0KSB7XG4gICAgICBrZXkgPSAobmV3IFNoYTI1NihpczIyNCwgdHJ1ZSkpLnVwZGF0ZShrZXkpLmFycmF5KCk7XG4gICAgfVxuXG4gICAgdmFyIG9LZXlQYWQgPSBbXSwgaUtleVBhZCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICB2YXIgYiA9IGtleVtpXSB8fCAwO1xuICAgICAgb0tleVBhZFtpXSA9IDB4NWMgXiBiO1xuICAgICAgaUtleVBhZFtpXSA9IDB4MzYgXiBiO1xuICAgIH1cblxuICAgIFNoYTI1Ni5jYWxsKHRoaXMsIGlzMjI0LCBzaGFyZWRNZW1vcnkpO1xuXG4gICAgdGhpcy51cGRhdGUoaUtleVBhZCk7XG4gICAgdGhpcy5vS2V5UGFkID0gb0tleVBhZDtcbiAgICB0aGlzLmlubmVyID0gdHJ1ZTtcbiAgICB0aGlzLnNoYXJlZE1lbW9yeSA9IHNoYXJlZE1lbW9yeTtcbiAgfVxuICBIbWFjU2hhMjU2LnByb3RvdHlwZSA9IG5ldyBTaGEyNTYoKTtcblxuICBIbWFjU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgIHRoaXMuaW5uZXIgPSBmYWxzZTtcbiAgICAgIHZhciBpbm5lckhhc2ggPSB0aGlzLmFycmF5KCk7XG4gICAgICBTaGEyNTYuY2FsbCh0aGlzLCB0aGlzLmlzMjI0LCB0aGlzLnNoYXJlZE1lbW9yeSk7XG4gICAgICB0aGlzLnVwZGF0ZSh0aGlzLm9LZXlQYWQpO1xuICAgICAgdGhpcy51cGRhdGUoaW5uZXJIYXNoKTtcbiAgICAgIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSBjcmVhdGVNZXRob2QoKTtcbiAgZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzO1xuICBleHBvcnRzLnNoYTIyNCA9IGNyZWF0ZU1ldGhvZCh0cnVlKTtcbiAgZXhwb3J0cy5zaGEyNTYuaG1hYyA9IGNyZWF0ZUhtYWNNZXRob2QoKTtcbiAgZXhwb3J0cy5zaGEyMjQuaG1hYyA9IGNyZWF0ZUhtYWNNZXRob2QodHJ1ZSk7XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICByb290LnNoYTI1NiA9IGV4cG9ydHMuc2hhMjU2O1xuICAgIHJvb3Quc2hhMjI0ID0gZXhwb3J0cy5zaGEyMjQ7XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCIvKipcbiAqIE11bHRpaGFzaCBpbXBsZW1lbnRhdGlvbiBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXVsdGloYXNoXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5cbmNvbnN0IGNzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5leHBvcnRzLm5hbWVzID0gY3MubmFtZXNcbmV4cG9ydHMuY29kZXMgPSBjcy5jb2Rlc1xuZXhwb3J0cy5kZWZhdWx0TGVuZ3RocyA9IGNzLmRlZmF1bHRMZW5ndGhzXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gdG9IZXhTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgYnVmZmVyJylcbiAgfVxuXG4gIHJldHVybiBoYXNoLnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUhleFN0cmluZyAoaGFzaCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oaGFzaCwgJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvQjU4U3RyaW5nID0gZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgYnVmZmVyJylcbiAgfVxuXG4gIHJldHVybiBiczU4LmVuY29kZShoYXNoKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGJhc2U1OCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUI1OFN0cmluZyA9IGZ1bmN0aW9uIGZyb21CNThTdHJpbmcgKGhhc2gpIHtcbiAgbGV0IGVuY29kZWQgPSBoYXNoXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaGFzaCkpIHtcbiAgICBlbmNvZGVkID0gaGFzaC50b1N0cmluZygpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oYnM1OC5kZWNvZGUoZW5jb2RlZCkpXG59XG5cbi8qKlxuICogRGVjb2RlIGEgaGFzaCBmcm9tIHRoZSBnaXZlbiBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybnMge3tjb2RlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogQnVmZmVyfX0gcmVzdWx0XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChidWYpIHtcbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoYnVmLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCB0b28gc2hvcnQuIG11c3QgYmUgPiAzIGJ5dGVzLicpXG4gIH1cblxuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmICghZXhwb3J0cy5pc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIHVua25vd24gZnVuY3Rpb24gY29kZTogMHgke2NvZGUudG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgY29uc3QgbGVuID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmIChsZW4gPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggaW52YWxpZCBsZW5ndGg6IDB4JHtsZW4udG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGxlbmd0aCBpbmNvbnNpc3RlbnQ6IDB4JHtidWYudG9TdHJpbmcoJ2hleCcpfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGU6IGNvZGUsXG4gICAgbmFtZTogY3MuY29kZXNbY29kZV0sXG4gICAgbGVuZ3RoOiBsZW4sXG4gICAgZGlnZXN0OiBidWZcbiAgfVxufVxuXG4vKipcbiAqICBFbmNvZGUgYSBoYXNoIGRpZ2VzdCBhbG9uZyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gY29kZS5cbiAqXG4gKiA+ICoqTm90ZToqKiB0aGUgbGVuZ3RoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBkaWdlc3QgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkaWdlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAoZGlnZXN0LCBjb2RlLCBsZW5ndGgpIHtcbiAgaWYgKCFkaWdlc3QgfHwgY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZW5jb2RlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBhcmdzOiBkaWdlc3QsIGNvZGUnKVxuICB9XG5cbiAgLy8gZW5zdXJlIGl0J3MgYSBoYXNoZnVuY3Rpb24gY29kZS5cbiAgY29uc3QgaGFzaGZuID0gZXhwb3J0cy5jb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKGRpZ2VzdCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3Qgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShoYXNoZm4pKSxcbiAgICBCdWZmZXIuZnJvbSh2YXJpbnQuZW5jb2RlKGxlbmd0aCkpLFxuICAgIGRpZ2VzdFxuICBdKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGFzaCBmdW5jdGlvbiBuYW1lIGludG8gdGhlIG1hdGNoaW5nIGNvZGUuXG4gKiBJZiBwYXNzZWQgYSBudW1iZXIgaXQgd2lsbCByZXR1cm4gdGhlIG51bWJlciBpZiBpdCdzIGEgdmFsaWQgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5jb2VyY2VDb2RlID0gZnVuY3Rpb24gY29lcmNlQ29kZSAobmFtZSkge1xuICBsZXQgY29kZSA9IG5hbWVcblxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGNzLm5hbWVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGhhc2ggZnVuY3Rpb24gbmFtZWQ6ICR7bmFtZX1gKVxuICAgIH1cbiAgICBjb2RlID0gY3MubmFtZXNbbmFtZV1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhhc2ggZnVuY3Rpb24gY29kZSBzaG91bGQgYmUgYSBudW1iZXIuIEdvdDogJHtjb2RlfWApXG4gIH1cblxuICBpZiAoY3MuY29kZXNbY29kZV0gPT09IHVuZGVmaW5lZCAmJiAhZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBmdW5jdGlvbiBjb2RlOiAke2NvZGV9YClcbiAgfVxuXG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogQ2hlY2tzIHdldGhlciBhIGNvZGUgaXMgcGFydCBvZiB0aGUgYXBwIHJhbmdlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQXBwQ29kZSA9IGZ1bmN0aW9uIGFwcENvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPiAwICYmIGNvZGUgPCAweDEwXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBtdWx0aWhhc2ggY29kZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENvZGUgPSBmdW5jdGlvbiB2YWxpZENvZGUgKGNvZGUpIHtcbiAgaWYgKGV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChjcy5jb2Rlc1tjb2RlXSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gYnVmZmVyIGlzIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBleHBvcnRzLmRlY29kZShtdWx0aWhhc2gpIC8vIHRocm93cyBpZiBiYWQuXG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG11bHRpaGFzaFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5leHBvcnRzLnByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeCAobXVsdGloYXNoKSB7XG4gIHZhbGlkYXRlKG11bHRpaGFzaClcblxuICByZXR1cm4gbXVsdGloYXNoLnNsaWNlKDAsIDIpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcFNlcmllcyA9IHJlcXVpcmUoJ3Atc2VyaWVzJylcbmNvbnN0IFBlZXJNb25pdG9yID0gcmVxdWlyZSgnaXBmcy1wdWJzdWItcGVlci1tb25pdG9yJylcblxuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnbG9ncGxlYXNlJylcbmNvbnN0IGxvZ2dlciA9IExvZ2dlci5jcmVhdGUoXCJwdWJzdWJcIiwgeyBjb2xvcjogTG9nZ2VyLkNvbG9ycy5ZZWxsb3cgfSlcbkxvZ2dlci5zZXRMb2dMZXZlbCgnRVJST1InKVxuXG5jb25zdCBtYXhUb3BpY3NPcGVuID0gMjU2XG5sZXQgdG9waWNzT3BlbkNvdW50ID0gMFxuXG5jbGFzcyBJUEZTUHVic3ViIHtcbiAgY29uc3RydWN0b3IoaXBmcywgaWQpIHtcbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuX2lkID0gaWRcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge31cblxuICAgIGlmICh0aGlzLl9pcGZzLnB1YnN1YiA9PT0gbnVsbClcbiAgICAgIGxvZ2dlci5lcnJvcihcIlRoZSBwcm92aWRlZCB2ZXJzaW9uIG9mIGlwZnMgZG9lc24ndCBoYXZlIHB1YnN1YiBzdXBwb3J0LiBNZXNzYWdlcyB3aWxsIG5vdCBiZSBleGNoYW5nZWQuXCIpXG5cbiAgICB0aGlzLl9oYW5kbGVNZXNzYWdlID0gdGhpcy5faGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpXG5cbiAgICAvLyBCdW1wIHVwIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIHdlIGNhbiBoYXZlIG9wZW4sXG4gICAgLy8gaWUuIG51bWJlciBvZiBkYXRhYmFzZXMgcmVwbGljYXRpbmdcbiAgICBpZiAodGhpcy5faXBmcy5zZXRNYXhMaXN0ZW5lcnMpXG4gICAgICB0aGlzLl9pcGZzLnNldE1heExpc3RlbmVycyhtYXhUb3BpY3NPcGVuKVxuICB9XG5cbiAgYXN5bmMgc3Vic2NyaWJlKHRvcGljLCBvbk1lc3NhZ2VDYWxsYmFjaywgb25OZXdQZWVyQ2FsbGJhY2spIHtcbiAgICBpZighdGhpcy5fc3Vic2NyaXB0aW9uc1t0b3BpY10gJiYgdGhpcy5faXBmcy5wdWJzdWIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2lwZnMucHVic3ViLnN1YnNjcmliZSh0b3BpYywgdGhpcy5faGFuZGxlTWVzc2FnZSlcblxuICAgICAgY29uc3QgdG9waWNNb25pdG9yID0gbmV3IFBlZXJNb25pdG9yKHRoaXMuX2lwZnMucHVic3ViLCB0b3BpYylcblxuICAgICAgdG9waWNNb25pdG9yLm9uKCdqb2luJywgKHBlZXIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBQZWVyIGpvaW5lZCAke3RvcGljfTpgKVxuICAgICAgICBsb2dnZXIuZGVidWcocGVlcilcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNbdG9waWNdKSB7XG4gICAgICAgICAgb25OZXdQZWVyQ2FsbGJhY2sodG9waWMsIHBlZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ1BlZXIgam9pbmVkIGEgcm9vbSB3ZSBkb25cXCd0IGhhdmUgYSBzdWJzY3JpcHRpb24gZm9yJylcbiAgICAgICAgICBsb2dnZXIud2Fybih0b3BpYywgcGVlcilcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdG9waWNNb25pdG9yLm9uKCdsZWF2ZScsIChwZWVyKSA9PiBsb2dnZXIuZGVidWcoYFBlZXIgJHtwZWVyfSBsZWZ0ICR7dG9waWN9YCkpXG4gICAgICB0b3BpY01vbml0b3Iub24oJ2Vycm9yJywgKGUpID0+IGxvZ2dlci5lcnJvcihlKSlcblxuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1t0b3BpY10gPSB7XG4gICAgICAgIHRvcGljTW9uaXRvcjogdG9waWNNb25pdG9yLFxuICAgICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZUNhbGxiYWNrLFxuICAgICAgICBvbk5ld1BlZXI6IG9uTmV3UGVlckNhbGxiYWNrXG4gICAgICB9XG5cbiAgICAgIHRvcGljc09wZW5Db3VudCArK1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiVG9waWNzIG9wZW46XCIsIHRvcGljc09wZW5Db3VudClcbiAgICB9XG4gIH1cblxuICBhc3luYyB1bnN1YnNjcmliZShoYXNoKSB7XG4gICAgaWYodGhpcy5fc3Vic2NyaXB0aW9uc1toYXNoXSkge1xuICAgICAgYXdhaXQgdGhpcy5faXBmcy5wdWJzdWIudW5zdWJzY3JpYmUoaGFzaCwgdGhpcy5faGFuZGxlTWVzc2FnZSlcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNbaGFzaF0udG9waWNNb25pdG9yLnN0b3AoKVxuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbaGFzaF1cbiAgICAgIGxvZ2dlci5kZWJ1ZyhgVW5zdWJzY3JpYmVkIGZyb20gJyR7aGFzaH0nYClcbiAgICAgIHRvcGljc09wZW5Db3VudCAtLVxuICAgICAgbG9nZ2VyLmRlYnVnKFwiVG9waWNzIG9wZW46XCIsIHRvcGljc09wZW5Db3VudClcbiAgICB9XG4gIH1cblxuICBwdWJsaXNoKHRvcGljLCBtZXNzYWdlKSB7XG4gICAgaWYodGhpcy5fc3Vic2NyaXB0aW9uc1t0b3BpY10gJiYgdGhpcy5faXBmcy5wdWJzdWIpIHtcbiAgICAgIHRoaXMuX2lwZnMucHVic3ViLnB1Ymxpc2godG9waWMsIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpXG4gICAgYXdhaXQgcFNlcmllcyh0b3BpY3MubWFwKCh0KSA9PiB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcywgdCkpKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fVxuICB9XG5cbiAgYXN5bmMgX2hhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIERvbid0IHByb2Nlc3Mgb3VyIG93biBtZXNzYWdlc1xuICAgIGlmIChtZXNzYWdlLmZyb20gPT09IHRoaXMuX2lkKVxuICAgICAgcmV0dXJuXG5cbiAgICAvLyBHZXQgdGhlIG1lc3NhZ2UgY29udGVudCBhbmQgYSBzdWJzY3JpcHRpb25cbiAgICBsZXQgY29udGVudCwgc3Vic2NyaXB0aW9uLCB0b3BpY0lkXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgdG9waWNcbiAgICAgIHRvcGljSWQgPSBtZXNzYWdlLnRvcGljSURzWzBdXG4gICAgICBjb250ZW50ID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpXG4gICAgICBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zW3RvcGljSWRdXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGUpXG4gICAgICBsb2dnZXIuZXJyb3IoJ0NvdWxkblxcJ3QgcGFyc2UgcHVic3ViIG1lc3NhZ2U6JywgbWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZihzdWJzY3JpcHRpb24gJiYgc3Vic2NyaXB0aW9uLm9uTWVzc2FnZSAmJiBjb250ZW50KSB7XG4gICAgICBhd2FpdCBzdWJzY3JpcHRpb24ub25NZXNzYWdlKHRvcGljSWQsIGNvbnRlbnQpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSVBGU1B1YnN1YlxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBFYWNoU2VyaWVzID0gcmVxdWlyZSgncC1lYWNoLXNlcmllcycpXG5jb25zdCBHU2V0ID0gcmVxdWlyZSgnLi9nLXNldCcpXG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vZW50cnknKVxuY29uc3QgTG9nSU8gPSByZXF1aXJlKCcuL2xvZy1pbycpXG5jb25zdCBMb2dFcnJvciA9IHJlcXVpcmUoJy4vbG9nLWVycm9ycycpXG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vbGFtcG9ydC1jbG9jaycpXG5jb25zdCBTb3J0aW5nID0gcmVxdWlyZSgnLi9sb2ctc29ydGluZycpXG5jb25zdCB7IExhc3RXcml0ZVdpbnMsIE5vWmVyb2VzIH0gPSBTb3J0aW5nXG5jb25zdCBBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9kZWZhdWx0LWFjY2Vzcy1jb250cm9sbGVyJylcbmNvbnN0IHsgaXNEZWZpbmVkLCBmaW5kVW5pcXVlcyB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBFbnRyeUluZGV4ID0gcmVxdWlyZSgnLi9lbnRyeS1pbmRleCcpXG5jb25zdCByYW5kb21JZCA9ICgpID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKClcbmNvbnN0IGdldEhhc2ggPSBlID0+IGUuaGFzaFxuY29uc3QgZmxhdE1hcCA9IChyZXMsIGFjYykgPT4gcmVzLmNvbmNhdChhY2MpXG5jb25zdCBnZXROZXh0UG9pbnRlcnMgPSBlbnRyeSA9PiBlbnRyeS5uZXh0XG5jb25zdCBtYXhDbG9ja1RpbWVSZWR1Y2VyID0gKHJlcywgYWNjKSA9PiBNYXRoLm1heChyZXMsIGFjYy5jbG9jay50aW1lKVxuY29uc3QgdW5pcXVlRW50cmllc1JlZHVjZXIgPSAocmVzLCBhY2MpID0+IHtcbiAgcmVzW2FjYy5oYXNoXSA9IGFjY1xuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogTG9nLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTG9nIGltcGxlbWVudHMgYSBHLVNldCBDUkRUIGFuZCBhZGRzIG9yZGVyaW5nLlxuICpcbiAqIEZyb206XG4gKiBcIkEgY29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBDb252ZXJnZW50IGFuZCBDb21tdXRhdGl2ZSBSZXBsaWNhdGVkIERhdGEgVHlwZXNcIlxuICogaHR0cHM6Ly9oYWwuaW5yaWEuZnIvaW5yaWEtMDA1NTU1ODhcbiAqL1xuY2xhc3MgTG9nIGV4dGVuZHMgR1NldCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9nIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SVBGU30gaXBmcyBBbiBJUEZTIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpZGVudGl0eSBJZGVudGl0eSAoaHR0cHM6Ly9naXRodWIuY29tL29yYml0ZGIvb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXIvYmxvYi9tYXN0ZXIvc3JjL2lkZW50aXR5LmpzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2dJZCBJRCBvZiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFjY2VzcyBBY2Nlc3NDb250cm9sbGVyICguL2RlZmF1bHQtYWNjZXNzLWNvbnRyb2xsZXIpXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmVudHJpZXMgQW4gQXJyYXkgb2YgRW50cmllcyBmcm9tIHdoaWNoIHRvIGNyZWF0ZSB0aGUgbG9nXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmhlYWRzIFNldCB0aGUgaGVhZHMgb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0Nsb2NrfSBvcHRpb25zLmNsb2NrIFNldCB0aGUgY2xvY2sgb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNvcnRGbiBUaGUgc29ydCBmdW5jdGlvbiAtIGJ5IGRlZmF1bHQgTGFzdFdyaXRlV2luc1xuICAgKiBAcmV0dXJuIHtMb2d9IFRoZSBsb2cgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yIChpcGZzLCBpZGVudGl0eSwgeyBsb2dJZCwgYWNjZXNzLCBlbnRyaWVzLCBoZWFkcywgY2xvY2ssIHNvcnRGbiB9ID0ge30pIHtcbiAgICBpZiAoIWlzRGVmaW5lZChpcGZzKSkge1xuICAgICAgdGhyb3cgTG9nRXJyb3IuSVBGU05vdERlZmluZWRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKCFpc0RlZmluZWQoaWRlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChhY2Nlc3MpKSB7XG4gICAgICBhY2Nlc3MgPSBuZXcgQWNjZXNzQ29udHJvbGxlcigpXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChlbnRyaWVzKSAmJiAhQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnZW50cmllcycgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvZiBFbnRyeSBpbnN0YW5jZXNgKVxuICAgIH1cblxuICAgIGlmIChpc0RlZmluZWQoaGVhZHMpICYmICFBcnJheS5pc0FycmF5KGhlYWRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnaGVhZHMnIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXlgKVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKHNvcnRGbikpIHtcbiAgICAgIHNvcnRGbiA9IExhc3RXcml0ZVdpbnNcbiAgICB9XG5cbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9zb3J0Rm4gPSBOb1plcm9lcyhzb3J0Rm4pXG5cbiAgICB0aGlzLl9zdG9yYWdlID0gaXBmc1xuICAgIHRoaXMuX2lkID0gbG9nSWQgfHwgcmFuZG9tSWQoKVxuXG4gICAgLy8gQWNjZXNzIENvbnRyb2xsZXJcbiAgICB0aGlzLl9hY2Nlc3MgPSBhY2Nlc3NcbiAgICAvLyBJZGVudGl0eVxuICAgIHRoaXMuX2lkZW50aXR5ID0gaWRlbnRpdHlcblxuICAgIC8vIEFkZCBlbnRyaWVzIHRvIHRoZSBpbnRlcm5hbCBjYWNoZVxuICAgIGVudHJpZXMgPSBlbnRyaWVzIHx8IFtdXG4gICAgdGhpcy5fZW50cnlJbmRleCA9IG5ldyBFbnRyeUluZGV4KGVudHJpZXMucmVkdWNlKHVuaXF1ZUVudHJpZXNSZWR1Y2VyLCB7fSkpXG5cbiAgICAvLyBTZXQgaGVhZHMgaWYgbm90IHBhc3NlZCBhcyBhbiBhcmd1bWVudFxuICAgIGhlYWRzID0gaGVhZHMgfHwgTG9nLmZpbmRIZWFkcyhlbnRyaWVzKVxuICAgIHRoaXMuX2hlYWRzSW5kZXggPSBoZWFkcy5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KVxuXG4gICAgLy8gSW5kZXggb2YgYWxsIG5leHQgcG9pbnRlcnMgaW4gdGhpcyBsb2dcbiAgICB0aGlzLl9uZXh0c0luZGV4ID0ge31cbiAgICBjb25zdCBhZGRUb05leHRzSW5kZXggPSBlID0+IGUubmV4dC5mb3JFYWNoKGEgPT4gKHRoaXMuX25leHRzSW5kZXhbYV0gPSBlLmhhc2gpKVxuICAgIGVudHJpZXMuZm9yRWFjaChhZGRUb05leHRzSW5kZXgpXG5cbiAgICAvLyBTZXQgdGhlIGxlbmd0aCwgd2UgY2FsY3VsYXRlIHRoZSBsZW5ndGggbWFudWFsbHkgaW50ZXJuYWxseVxuICAgIHRoaXMuX2xlbmd0aCA9IGVudHJpZXMubGVuZ3RoXG5cbiAgICAvLyBTZXQgdGhlIGNsb2NrXG4gICAgY29uc3QgbWF4VGltZSA9IE1hdGgubWF4KGNsb2NrID8gY2xvY2sudGltZSA6IDAsIHRoaXMuaGVhZHMucmVkdWNlKG1heENsb2NrVGltZVJlZHVjZXIsIDApKVxuICAgIC8vIFRha2UgdGhlIGdpdmVuIGtleSBhcyB0aGUgY2xvY2sgaWQgaXMgaXQncyBhIEtleSBpbnN0YW5jZSxcbiAgICAvLyBvdGhlcndpc2UgaWYga2V5IHdhcyBnaXZlbiwgdGFrZSB3aGF0ZXZlciBpdCBpcyxcbiAgICAvLyBhbmQgaWYgaXQgd2FzIG51bGwsIHRha2UgdGhlIGdpdmVuIGlkIGFzIHRoZSBjbG9jayBpZFxuICAgIHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKHRoaXMuX2lkZW50aXR5LnB1YmxpY0tleSwgbWF4VGltZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgbG9nLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbG9jayBvZiB0aGUgbG9nLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGNsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxvZy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGhcbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgaW4gdGhlIGxvZy5cbiAgICogQHJldHVybnMge0FycmF5PEVudHJ5Pn1cbiAgICovXG4gIGdldCB2YWx1ZXMgKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMudHJhdmVyc2UodGhpcy5oZWFkcykpLnJldmVyc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaGVhZHMgYXMgaGFzaGVzLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICovXG4gIGdldCBoZWFkcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5faGVhZHNJbmRleCkuc29ydCh0aGlzLl9zb3J0Rm4pLnJldmVyc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgRW50cnkgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSBlbnRyaWVzIHdoaWNoXG4gICAqIGFyZSBub3QgaW4gdGhlIGxvZyBjdXJyZW50bHkuXG4gICAqIEByZXR1cm5zIHtBcnJheTxFbnRyeT59XG4gICAqL1xuICBnZXQgdGFpbHMgKCkge1xuICAgIHJldHVybiBMb2cuZmluZFRhaWxzKHRoaXMudmFsdWVzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaGFzaGVzIHRoYXQgYXJlIHJlZmVyZW5jZWQgYnkgZW50cmllcyB3aGljaFxuICAgKiBhcmUgbm90IGluIHRoZSBsb2cgY3VycmVudGx5LlxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgaGFzaGVzXG4gICAqL1xuICBnZXQgdGFpbEhhc2hlcyAoKSB7XG4gICAgcmV0dXJuIExvZy5maW5kVGFpbEhhc2hlcyh0aGlzLnZhbHVlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGlkZW50aXR5IGZvciB0aGUgbG9nXG4gICAqIEBwYXJhbSB7SWRlbnRpdHl9IFtpZGVudGl0eV0gVGhlIGlkZW50aXR5IHRvIGJlIHNldFxuICAgKi9cbiAgc2V0SWRlbnRpdHkgKGlkZW50aXR5KSB7XG4gICAgdGhpcy5faWRlbnRpdHkgPSBpZGVudGl0eVxuICAgIC8vIEZpbmQgdGhlIGxhdGVzdCBjbG9jayBmcm9tIHRoZSBoZWFkc1xuICAgIGNvbnN0IHRpbWUgPSBNYXRoLm1heCh0aGlzLmNsb2NrLnRpbWUsIHRoaXMuaGVhZHMucmVkdWNlKG1heENsb2NrVGltZVJlZHVjZXIsIDApKVxuICAgIHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKHRoaXMuX2lkZW50aXR5LnB1YmxpY0tleSwgdGltZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuIGVudHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdIFRoZSBoYXNoZXMgb2YgdGhlIGVudHJ5XG4gICAqIEByZXR1cm5zIHtFbnRyeXx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgKGhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlJbmRleC5nZXQoaGFzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBlbnRyeSBpcyBwYXJ0IG9mIHRoZSBsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGhhc2ggb2YgdGhlIGVudHJ5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzIChlbnRyeSkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyeUluZGV4LmdldChlbnRyeS5oYXNoIHx8IGVudHJ5KSAhPT0gdW5kZWZpbmVkXG4gIH1cblxuICB0cmF2ZXJzZSAocm9vdEVudHJpZXMsIGFtb3VudCA9IC0xLCBlbmRIYXNoKSB7XG4gICAgLy8gU29ydCB0aGUgZ2l2ZW4gZ2l2ZW4gcm9vdCBlbnRyaWVzIGFuZCB1c2UgYXMgdGhlIHN0YXJ0aW5nIHN0YWNrXG4gICAgdmFyIHN0YWNrID0gcm9vdEVudHJpZXMuc29ydCh0aGlzLl9zb3J0Rm4pLnJldmVyc2UoKVxuICAgIC8vIENhY2hlIGZvciBjaGVja2luZyBpZiB3ZSd2ZSBwcm9jZXNzZWQgYW4gZW50cnkgYWxyZWFkeVxuICAgIGxldCB0cmF2ZXJzZWQgPSB7fVxuICAgIC8vIEVuZCByZXN1bHRcbiAgICBsZXQgcmVzdWx0ID0ge31cbiAgICAvLyBXZSBrZWVwIGEgY291bnRlciB0byBjaGVjayBpZiB3ZSBoYXZlIHRyYXZlcnNlZCByZXF1ZXN0ZWQgYW1vdW50IG9mIGVudHJpZXNcbiAgICBsZXQgY291bnQgPSAwXG5cbiAgICAvLyBOYW1lZCBmdW5jdGlvbiBmb3IgZ2V0dGluZyBhbiBlbnRyeSBmcm9tIHRoZSBsb2dcbiAgICBjb25zdCBnZXRFbnRyeSA9IGUgPT4gdGhpcy5nZXQoZSlcblxuICAgIC8vIEFkZCBhbiBlbnRyeSB0byB0aGUgc3RhY2sgYW5kIHRyYXZlcnNlZCBub2RlcyBpbmRleFxuICAgIGNvbnN0IGFkZFRvU3RhY2sgPSBlbnRyeSA9PiB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgZW50cnksIGRvbid0IGFkZCBpdCB0byB0aGUgc3RhY2tcbiAgICAgIGlmICghZW50cnkgfHwgdHJhdmVyc2VkW2VudHJ5Lmhhc2hdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGVudHJ5IGluIGZyb250IG9mIHRoZSBzdGFjayBhbmQgc29ydFxuICAgICAgc3RhY2sgPSBbZW50cnksIC4uLnN0YWNrXVxuICAgICAgICAuc29ydCh0aGlzLl9zb3J0Rm4pXG4gICAgICAgIC5yZXZlcnNlKClcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjYWNoZSBvZiBwcm9jZXNzZWQgZW50cmllc1xuICAgICAgdHJhdmVyc2VkW2VudHJ5Lmhhc2hdID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYXZlcnNhbFxuICAgIC8vIFByb2Nlc3Mgc3RhY2sgdW50aWwgaXQncyBlbXB0eSAodHJhdmVyc2VkIHRoZSBmdWxsIGxvZylcbiAgICAvLyBvciB3aGVuIHdlIGhhdmUgdGhlIHJlcXVlc3RlZCBhbW91bnQgb2YgZW50cmllc1xuICAgIC8vIElmIHJlcXVlc3RlZCBlbnRyeSBhbW91bnQgaXMgLTEsIHRyYXZlcnNlIGFsbFxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIChhbW91bnQgPT09IC0xIHx8IGNvdW50IDwgYW1vdW50KSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb25cbiAgICAgIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIHN0YWNrXG4gICAgICBjb25zdCBlbnRyeSA9IHN0YWNrLnNoaWZ0KClcblxuICAgICAgLy8gQWRkIHRvIHRoZSByZXN1bHRcbiAgICAgIGNvdW50KytcbiAgICAgIHJlc3VsdFtlbnRyeS5oYXNoXSA9IGVudHJ5XG4gICAgICAvLyBBZGQgZW50cnkncyBuZXh0IHJlZmVyZW5jZXMgdG8gdGhlIHN0YWNrXG4gICAgICBlbnRyeS5uZXh0Lm1hcChnZXRFbnRyeSlcbiAgICAgICAgLmZpbHRlcihpc0RlZmluZWQpXG4gICAgICAgIC5mb3JFYWNoKGFkZFRvU3RhY2spXG5cbiAgICAgIC8vIElmIGl0IGlzIHRoZSBzcGVjaWZpZWQgZW5kIGhhc2gsIGJyZWFrIG91dCBvZiB0aGUgd2hpbGUgbG9vcFxuICAgICAgaWYgKGVudHJ5Lmhhc2ggPT09IGVuZEhhc2gpIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBlbnRyeSB0byB0aGUgbG9nLlxuICAgKiBAcGFyYW0ge0VudHJ5fSBlbnRyeSBFbnRyeSB0byBhZGRcbiAgICogQHJldHVybiB7TG9nfSBOZXcgTG9nIGNvbnRhaW5pbmcgdGhlIGFwcGVuZGVkIHZhbHVlXG4gICAqL1xuICBhc3luYyBhcHBlbmQgKGRhdGEsIHBvaW50ZXJDb3VudCA9IDEpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGNsb2NrIChmaW5kIHRoZSBsYXRlc3QgY2xvY2spXG4gICAgY29uc3QgbmV3VGltZSA9IE1hdGgubWF4KHRoaXMuY2xvY2sudGltZSwgdGhpcy5oZWFkcy5yZWR1Y2UobWF4Q2xvY2tUaW1lUmVkdWNlciwgMCkpICsgMVxuICAgIHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKHRoaXMuY2xvY2suaWQsIG5ld1RpbWUpXG5cbiAgICAvLyBHZXQgdGhlIHJlcXVpcmVkIGFtb3VudCBvZiBoYXNoZXMgdG8gbmV4dCBlbnRyaWVzIChhcyBwZXIgY3VycmVudCBzdGF0ZSBvZiB0aGUgbG9nKVxuICAgIGNvbnN0IHJlZmVyZW5jZXMgPSB0aGlzLnRyYXZlcnNlKHRoaXMuaGVhZHMsIE1hdGgubWF4KHBvaW50ZXJDb3VudCwgdGhpcy5oZWFkcy5sZW5ndGgpKVxuXG4gICAgY29uc3Qgc29ydGVkSGVhZEluZGV4ID0gdGhpcy5oZWFkcy5yZXZlcnNlKCkucmVkdWNlKHVuaXF1ZUVudHJpZXNSZWR1Y2VyLCB7fSlcbiAgICBjb25zdCBuZXh0cyA9IE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHNvcnRlZEhlYWRJbmRleCwgcmVmZXJlbmNlcykpXG4gICAgLy8gQFRPRE86IFNwbGl0IEVudHJ5LmNyZWF0ZSBpbnRvIGNyZWF0aW5nIG9iamVjdCwgY2hlY2tpbmcgcGVybWlzc2lvbiwgc2lnbmluZyBhbmQgdGhlbiBwb3N0aW5nIHRvIElQRlNcbiAgICAvLyBDcmVhdGUgdGhlIGVudHJ5IGFuZCBhZGQgaXQgdG8gdGhlIGludGVybmFsIGNhY2hlXG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCBFbnRyeS5jcmVhdGUoXG4gICAgICB0aGlzLl9zdG9yYWdlLFxuICAgICAgdGhpcy5faWRlbnRpdHksXG4gICAgICB0aGlzLmlkLFxuICAgICAgZGF0YSxcbiAgICAgIG5leHRzLFxuICAgICAgdGhpcy5jbG9ja1xuICAgIClcblxuICAgIGNvbnN0IGNhbkFwcGVuZCA9IGF3YWl0IHRoaXMuX2FjY2Vzcy5jYW5BcHBlbmQoZW50cnksIHRoaXMuX2lkZW50aXR5LnByb3ZpZGVyKVxuICAgIGlmICghY2FuQXBwZW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBhcHBlbmQgZW50cnksIGtleSBcIiR7dGhpcy5faWRlbnRpdHkuaWR9XCIgaXMgbm90IGFsbG93ZWQgdG8gd3JpdGUgdG8gdGhlIGxvZ2ApXG4gICAgfVxuXG4gICAgdGhpcy5fZW50cnlJbmRleC5zZXQoZW50cnkuaGFzaCwgZW50cnkpXG4gICAgbmV4dHMuZm9yRWFjaChlID0+ICh0aGlzLl9uZXh0c0luZGV4W2VdID0gZW50cnkuaGFzaCkpXG4gICAgdGhpcy5faGVhZHNJbmRleCA9IHt9XG4gICAgdGhpcy5faGVhZHNJbmRleFtlbnRyeS5oYXNoXSA9IGVudHJ5XG4gICAgLy8gVXBkYXRlIHRoZSBsZW5ndGhcbiAgICB0aGlzLl9sZW5ndGgrK1xuICAgIHJldHVybiBlbnRyeVxuICB9XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhIGphdnNjcmlwdCBpdGVyYXRvciBvdmVyIGxvZyBlbnRyaWVzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBvcHRpb25zLmd0IEJlZ2lubmluZyBoYXNoIG9mIHRoZSBpdGVyYXRvciwgbm9uLWluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gb3B0aW9ucy5ndGUgQmVnaW5uaW5nIGhhc2ggb2YgdGhlIGl0ZXJhdG9yLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IG9wdGlvbnMubHQgRW5kaW5nIGhhc2ggb2YgdGhlIGl0ZXJhdG9yLCBub24taW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBvcHRpb25zLmx0ZSBFbmRpbmcgaGFzaCBvZiB0aGUgaXRlcmF0b3IsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge2Ftb3VudH0gb3B0aW9ucy5hbW91bnQgTnVtYmVyIG9mIGVudHJpZWQgdG8gcmV0dXJuIHRvIC8gZnJvbSB0aGUgZ3RlIC8gbHRlIGhhc2hcbiAgICogQHJldHVybnMge1N5bWJvbC5JdGVyYXRvcn0gSXRlcmF0b3Igb2JqZWN0IGNvbnRhaW5pbmcgbG9nIGVudHJpZXNcbiAgICpcbiAgICogQGV4YW1wbGVzXG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgbG9nMSA9IG5ldyBMb2coaXBmcywgdGVzdElkZW50aXR5LCB7IGxvZ0lkOiAnWCcgfSlcbiAgICpcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8PSAxMDA7IGkrKykge1xuICAgKiAgICAgYXdhaXQgbG9nMS5hcHBlbmQoJ2VudHJ5JyArIGkpXG4gICAqICAgfVxuICAgKlxuICAgKiAgIGxldCBpdCA9IGxvZzEuaXRlcmF0b3Ioe1xuICAgKiAgICAgbHRlOiAnemRwdUFwRmQ1WEFQa0NUbVN4N3FXUW1RenZ0ZEpQdHgySzVwOXRvNnl0Q1M3OWJmaycsXG4gICAqICAgICBhbW91bnQ6IDEwXG4gICAqICAgfSlcbiAgICpcbiAgICogICBbLi4uaXRdLmxlbmd0aCAvLyAxMFxuICAgKiB9KSgpXG4gICAqXG4gICAqXG4gICAqL1xuICBpdGVyYXRvciAoeyBndCA9IHVuZGVmaW5lZCwgZ3RlID0gdW5kZWZpbmVkLCBsdCA9IHVuZGVmaW5lZCwgbHRlID0gdW5kZWZpbmVkLCBhbW91bnQgPSAtMSB9ID1cbiAge30pIHtcbiAgICBpZiAoYW1vdW50ID09PSAwKSByZXR1cm4gKGZ1bmN0aW9uICogKCkge30pKClcbiAgICBpZiAodHlwZW9mIGx0ZSA9PT0gJ3N0cmluZycpIGx0ZSA9IFt0aGlzLmdldChsdGUpXVxuICAgIGlmICh0eXBlb2YgbHQgPT09ICdzdHJpbmcnKSBsdCA9IFt0aGlzLmdldCh0aGlzLmdldChsdCkubmV4dCldXG5cbiAgICBpZiAobHRlICYmICFBcnJheS5pc0FycmF5KGx0ZSkpIHRocm93IExvZ0Vycm9yLkx0T3JMdGVNdXN0QmVTdHJpbmdPckFycmF5KClcbiAgICBpZiAobHQgJiYgIUFycmF5LmlzQXJyYXkobHQpKSB0aHJvdyBMb2dFcnJvci5MdE9yTHRlTXVzdEJlU3RyaW5nT3JBcnJheSgpXG5cbiAgICBsZXQgc3RhcnQgPSBsdGUgfHwgKGx0IHx8IHRoaXMuaGVhZHMpXG4gICAgbGV0IGVuZEhhc2ggPSBndGUgPyB0aGlzLmdldChndGUpLmhhc2ggOiBndCA/IHRoaXMuZ2V0KGd0KS5oYXNoIDogbnVsbFxuICAgIGxldCBjb3VudCA9IGVuZEhhc2ggPyAtMSA6IGFtb3VudCB8fCAtMVxuXG4gICAgbGV0IGVudHJpZXMgPSB0aGlzLnRyYXZlcnNlKHN0YXJ0LCBjb3VudCwgZW5kSGFzaClcbiAgICBsZXQgZW50cnlWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGVudHJpZXMpXG5cbiAgICAvLyBTdHJpcCBvZmYgbGFzdCBlbnRyeSBpZiBndCBpcyBub24taW5jbHVzaXZlXG4gICAgaWYgKGd0KSBlbnRyeVZhbHVlcy5wb3AoKVxuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBhbW91bnQgYXJndW1lbnQgd29ya2luZyBiYWNrd2FyZHMgZnJvbSBndC9ndGVcbiAgICBpZiAoKGd0IHx8IGd0ZSkgJiYgYW1vdW50ID4gLTEpIHtcbiAgICAgIGVudHJ5VmFsdWVzID0gZW50cnlWYWx1ZXMuc2xpY2UoZW50cnlWYWx1ZXMubGVuZ3RoIC0gYW1vdW50LCBlbnRyeVZhbHVlcy5sZW5ndGgpXG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciAobGV0IGkgaW4gZW50cnlWYWx1ZXMpIHtcbiAgICAgICAgeWllbGQgZW50cnlWYWx1ZXNbaV1cbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0d28gbG9ncy5cbiAgICpcbiAgICogSm9pbnMgYW5vdGhlciBsb2cgaW50byB0aGlzIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtMb2d9IGxvZyBMb2cgdG8gam9pbiB3aXRoIHRoaXMgTG9nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0tMV0gTWF4IHNpemUgb2YgdGhlIGpvaW5lZCBsb2dcbiAgICogQHJldHVybnMge1Byb21pc2U8TG9nPn0gVGhpcyBMb2cgaW5zdGFuY2VcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgbG9nMS5qb2luKGxvZzIpXG4gICAqL1xuICBhc3luYyBqb2luIChsb2csIHNpemUgPSAtMSkge1xuICAgIGlmICghaXNEZWZpbmVkKGxvZykpIHRocm93IExvZ0Vycm9yLkxvZ05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFMb2cuaXNMb2cobG9nKSkgdGhyb3cgTG9nRXJyb3IuTm90QUxvZ0Vycm9yKClcbiAgICBpZiAodGhpcy5pZCAhPT0gbG9nLmlkKSByZXR1cm5cblxuICAgIC8vIEdldCB0aGUgZGlmZmVyZW5jZSBvZiB0aGUgbG9nc1xuICAgIGNvbnN0IG5ld0l0ZW1zID0gTG9nLmRpZmZlcmVuY2UobG9nLCB0aGlzKVxuXG4gICAgY29uc3QgaWRlbnRpdHlQcm92aWRlciA9IHRoaXMuX2lkZW50aXR5LnByb3ZpZGVyXG4gICAgLy8gVmVyaWZ5IGlmIGVudHJpZXMgYXJlIGFsbG93ZWQgdG8gYmUgYWRkZWQgdG8gdGhlIGxvZyBhbmQgdGhyb3dzIGlmXG4gICAgLy8gdGhlcmUncyBhbiBpbnZhbGlkIGVudHJ5XG4gICAgY29uc3QgcGVybWl0dGVkID0gYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBjYW5BcHBlbmQgPSBhd2FpdCB0aGlzLl9hY2Nlc3MuY2FuQXBwZW5kKGVudHJ5LCBpZGVudGl0eVByb3ZpZGVyKVxuICAgICAgaWYgKCFjYW5BcHBlbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgYXBwZW5kIGVudHJ5LCBrZXkgXCIke2VudHJ5LmlkZW50aXR5LmlkfVwiIGlzIG5vdCBhbGxvd2VkIHRvIHdyaXRlIHRvIHRoZSBsb2dgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcmlmeSBzaWduYXR1cmUgZm9yIGVhY2ggZW50cnkgYW5kIHRocm93cyBpZiB0aGVyZSdzIGFuIGludmFsaWQgc2lnbmF0dXJlXG4gICAgY29uc3QgdmVyaWZ5ID0gYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgRW50cnkudmVyaWZ5KGlkZW50aXR5UHJvdmlkZXIsIGVudHJ5KVxuICAgICAgY29uc3QgcHVibGljS2V5ID0gZW50cnkuaWRlbnRpdHkgPyBlbnRyeS5pZGVudGl0eS5wdWJsaWNLZXkgOiBlbnRyeS5rZXlcbiAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdmFsaWRhdGUgc2lnbmF0dXJlIFwiJHtlbnRyeS5zaWd9XCIgZm9yIGVudHJ5IFwiJHtlbnRyeS5oYXNofVwiIGFuZCBrZXkgXCIke3B1YmxpY0tleX1cImApXG4gICAgfVxuXG4gICAgY29uc3QgZW50cmllc1RvSm9pbiA9IE9iamVjdC52YWx1ZXMobmV3SXRlbXMpXG4gICAgYXdhaXQgcEVhY2hTZXJpZXMoZW50cmllc1RvSm9pbiwgYXN5bmMgZSA9PiB7XG4gICAgICBhd2FpdCBwZXJtaXR0ZWQoZSlcbiAgICAgIGF3YWl0IHZlcmlmeShlKVxuICAgIH0pXG5cbiAgICAvLyBVcGRhdGUgdGhlIGludGVybmFsIG5leHQgcG9pbnRlcnMgaW5kZXhcbiAgICBjb25zdCBhZGRUb05leHRzSW5kZXggPSBlID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5nZXQoZS5oYXNoKVxuICAgICAgaWYgKCFlbnRyeSkgdGhpcy5fbGVuZ3RoKysgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGUubmV4dC5mb3JFYWNoKGEgPT4gKHRoaXMuX25leHRzSW5kZXhbYV0gPSBlLmhhc2gpKVxuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKG5ld0l0ZW1zKS5mb3JFYWNoKGFkZFRvTmV4dHNJbmRleClcblxuICAgIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZW50cnkgaW5kZXhcbiAgICB0aGlzLl9lbnRyeUluZGV4LmFkZChuZXdJdGVtcylcblxuICAgIC8vIE1lcmdlIHRoZSBoZWFkc1xuICAgIGNvbnN0IG5vdFJlZmVyZW5jZWRCeU5ld0l0ZW1zID0gZSA9PiAhbmV4dHNGcm9tTmV3SXRlbXMuZmluZChhID0+IGEgPT09IGUuaGFzaClcbiAgICBjb25zdCBub3RJbkN1cnJlbnROZXh0cyA9IGUgPT4gIXRoaXMuX25leHRzSW5kZXhbZS5oYXNoXVxuICAgIGNvbnN0IG5leHRzRnJvbU5ld0l0ZW1zID0gT2JqZWN0LnZhbHVlcyhuZXdJdGVtcykubWFwKGdldE5leHRQb2ludGVycykucmVkdWNlKGZsYXRNYXAsIFtdKVxuICAgIGNvbnN0IG1lcmdlZEhlYWRzID0gTG9nLmZpbmRIZWFkcyhPYmplY3QudmFsdWVzKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2hlYWRzSW5kZXgsIGxvZy5faGVhZHNJbmRleCkpKVxuICAgICAgLmZpbHRlcihub3RSZWZlcmVuY2VkQnlOZXdJdGVtcylcbiAgICAgIC5maWx0ZXIobm90SW5DdXJyZW50TmV4dHMpXG4gICAgICAucmVkdWNlKHVuaXF1ZUVudHJpZXNSZWR1Y2VyLCB7fSlcblxuICAgIHRoaXMuX2hlYWRzSW5kZXggPSBtZXJnZWRIZWFkc1xuXG4gICAgLy8gU2xpY2UgdG8gdGhlIHJlcXVlc3RlZCBzaXplXG4gICAgaWYgKHNpemUgPiAtMSkge1xuICAgICAgbGV0IHRtcCA9IHRoaXMudmFsdWVzXG4gICAgICB0bXAgPSB0bXAuc2xpY2UoLXNpemUpXG4gICAgICB0aGlzLl9lbnRyeUluZGV4ID0gbnVsbFxuICAgICAgdGhpcy5fZW50cnlJbmRleCA9IG5ldyBFbnRyeUluZGV4KHRtcC5yZWR1Y2UodW5pcXVlRW50cmllc1JlZHVjZXIsIHt9KSlcbiAgICAgIHRoaXMuX2hlYWRzSW5kZXggPSBMb2cuZmluZEhlYWRzKHRtcCkucmVkdWNlKHVuaXF1ZUVudHJpZXNSZWR1Y2VyLCB7fSlcbiAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2VudHJ5SW5kZXgubGVuZ3RoXG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgbGF0ZXN0IGNsb2NrIGZyb20gdGhlIGhlYWRzXG4gICAgY29uc3QgbWF4Q2xvY2sgPSBPYmplY3QudmFsdWVzKHRoaXMuX2hlYWRzSW5kZXgpLnJlZHVjZShtYXhDbG9ja1RpbWVSZWR1Y2VyLCAwKVxuICAgIHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKHRoaXMuY2xvY2suaWQsIE1hdGgubWF4KHRoaXMuY2xvY2sudGltZSwgbWF4Q2xvY2spKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2cgaW4gSlNPTiBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBpZCBhbmQgaGVhZHMgcHJvcGVydGllc1xuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBoZWFkczogdGhpcy5oZWFkc1xuICAgICAgICAuc29ydCh0aGlzLl9zb3J0Rm4pIC8vIGRlZmF1bHQgc29ydGluZ1xuICAgICAgICAucmV2ZXJzZSgpIC8vIHdlIHdhbnQgdGhlIGxhdGVzdCBhcyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAubWFwKGdldEhhc2gpIC8vIHJldHVybiBvbmx5IHRoZSBoZWFkIGhhc2hlc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvZyBpbiBKU09OIGZvcm1hdCBhcyBhIHNuYXBzaG90LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgaWQsIGhlYWRzIGFuZCB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAqL1xuICB0b1NuYXBzaG90ICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBoZWFkczogdGhpcy5oZWFkcyxcbiAgICAgIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2cgYXMgYSBCdWZmZXIuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICB0b0J1ZmZlciAoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxvZyBlbnRyaWVzIGFzIGEgZm9ybWF0dGVkIHN0cmluZy5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogdHdvXG4gICAqIOKUlOKUgG9uZVxuICAgKiAgIOKUlOKUgHRocmVlXG4gICAqL1xuICB0b1N0cmluZyAocGF5bG9hZE1hcHBlcikge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5tYXAoKGUsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gRW50cnkuZmluZENoaWxkcmVuKGUsIHRoaXMudmFsdWVzKVxuICAgICAgICBjb25zdCBsZW4gPSBwYXJlbnRzLmxlbmd0aFxuICAgICAgICBsZXQgcGFkZGluZyA9IG5ldyBBcnJheShNYXRoLm1heChsZW4gLSAxLCAwKSlcbiAgICAgICAgcGFkZGluZyA9IGxlbiA+IDEgPyBwYWRkaW5nLmZpbGwoJyAgJykgOiBwYWRkaW5nXG4gICAgICAgIHBhZGRpbmcgPSBsZW4gPiAwID8gcGFkZGluZy5jb25jYXQoWyfilJTilIAnXSkgOiBwYWRkaW5nXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBwYWRkaW5nLmpvaW4oJycpICsgKHBheWxvYWRNYXBwZXIgPyBwYXlsb2FkTWFwcGVyKGUucGF5bG9hZCkgOiBlLnBheWxvYWQpXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcbicpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaXMgYSBMb2cgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2cgQW4gb2JqZWN0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTG9nIChsb2cpIHtcbiAgICByZXR1cm4gbG9nLmlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGxvZy5oZWFkcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBsb2cuX2VudHJ5SW5kZXggIT09IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9nJ3MgbXVsdGloYXNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBNdWx0aWhhc2ggb2YgdGhlIExvZyBhcyBCYXNlNTggZW5jb2RlZCBzdHJpbmd4XG4gICAqL1xuICB0b011bHRpaGFzaCAoeyBmb3JtYXQgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvZ0lPLnRvTXVsdGloYXNoKHRoaXMuX3N0b3JhZ2UsIHRoaXMsIHsgZm9ybWF0IH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9nIGZyb20gYSBoYXNoZXMuXG4gICAqIEBwYXJhbSB7SVBGU30gaXBmcyBBbiBJUEZTIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SWRlbnRpdHl9IGlkZW50aXR5IFRoZSBpZGVudGl0eSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBUaGUgbG9nIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtBY2Nlc3NDb250cm9sbGVyfSBvcHRpb25zLmFjY2VzcyBUaGUgYWNjZXNzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0FycmF5PEVudHJ5Pn0gb3B0aW9ucy5leGNsdWRlIEVudHJpZXMgdG8gbm90IGZldGNoIChjYWNoZWQpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFzaCwgZW50cnksIHBhcmVudCwgZGVwdGgpfSBvcHRpb25zLm9uUHJvZ3Jlc3NDYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNvcnRGbiBUaGUgc29ydCBmdW5jdGlvbiAtIGJ5IGRlZmF1bHQgTGFzdFdyaXRlV2luc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMb2c+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21NdWx0aWhhc2ggKGlwZnMsIGlkZW50aXR5LCBoYXNoLFxuICAgIHsgYWNjZXNzLCBsZW5ndGggPSAtMSwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCBzb3J0Rm4sIHRpbWVvdXQsIGZvcm1hdCB9ID0ge30pIHtcbiAgICAvLyBUT0RPOiBuZWVkIHRvIHZlcmlmeSB0aGUgZW50cmllcyB3aXRoICdrZXknXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IExvZ0lPLmZyb21NdWx0aWhhc2goaXBmcywgaGFzaCwgeyBsZW5ndGgsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCwgZm9ybWF0IH0pXG4gICAgcmV0dXJuIG5ldyBMb2coaXBmcywgaWRlbnRpdHksIHtcbiAgICAgIGxvZ0lkOiBkYXRhLmlkLFxuICAgICAgYWNjZXNzOiBhY2Nlc3MsXG4gICAgICBlbnRyaWVzOiBkYXRhLnZhbHVlcyxcbiAgICAgIGhlYWRzOiBkYXRhLmhlYWRzLFxuICAgICAgY2xvY2s6IG5ldyBDbG9jayhkYXRhLmNsb2NrLmlkLCBkYXRhLmNsb2NrLnRpbWUpLFxuICAgICAgc29ydEZuOiBzb3J0Rm5cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvZyBmcm9tIGEgc2luZ2xlIGVudHJ5J3MgaGFzaC5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIFRoZSBlbnRyeSdzIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9nSWQgVGhlIElEIG9mIHRoZSBsb2dcbiAgICogQHBhcmFtIHtBY2Nlc3NDb250cm9sbGVyfSBvcHRpb25zLmFjY2VzcyBUaGUgYWNjZXNzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGVudHJpZXMgdG8gaW5jbHVkZSBpbiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmV4Y2x1ZGUgRW50cmllcyB0byBub3QgZmV0Y2ggKGNhY2hlZClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihoYXNoLCBlbnRyeSwgcGFyZW50LCBkZXB0aCl9IG9wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc29ydEZuIFRoZSBzb3J0IGZ1bmN0aW9uIC0gYnkgZGVmYXVsdCBMYXN0V3JpdGVXaW5zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgVGltZW91dCBmb3IgZmV0Y2hpbmcgYSBsb2cgZW50cnkgZnJvbSBJUEZTXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TG9nPn0gTmV3IExvZ1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21FbnRyeUhhc2ggKGlwZnMsIGlkZW50aXR5LCBoYXNoLFxuICAgIHsgbG9nSWQsIGFjY2VzcywgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgc29ydEZuLCB0aW1lb3V0IH0pIHtcbiAgICAvLyBUT0RPOiBuZWVkIHRvIHZlcmlmeSB0aGUgZW50cmllcyB3aXRoICdrZXknXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IExvZ0lPLmZyb21FbnRyeUhhc2goaXBmcywgaGFzaCwgeyBsZW5ndGgsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KVxuICAgIHJldHVybiBuZXcgTG9nKGlwZnMsIGlkZW50aXR5LCB7IGxvZ0lkLCBhY2Nlc3MsIGVudHJpZXM6IGRhdGEudmFsdWVzLCBzb3J0Rm4gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhIExvZyBTbmFwc2hvdCBKU09OLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0lkZW50aXR5fSBpZGVudGl0eSBUaGUgaWRlbnRpdHkgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb24gTG9nIHNuYXBzaG90IGFzIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QWNjZXNzQ29udHJvbGxlcn0gb3B0aW9ucy5hY2Nlc3MgVGhlIGFjY2VzcyBjb250cm9sbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxlbmd0aCBIb3cgbWFueSBlbnRyaWVzIHRvIGluY2x1ZGUgaW4gdGhlIGxvZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50aW1lb3V0IE1heGltdW0gdGltZSB0byB3YWl0IGZvciBlYWNoIGZldGNoIG9wZXJhdGlvbiwgaW4gbXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbihoYXNoLCBlbnRyeSwgcGFyZW50LCBkZXB0aCl9IFtvcHRpb25zLm9uUHJvZ3Jlc3NDYWxsYmFja11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zb3J0Rm4gVGhlIHNvcnQgZnVuY3Rpb24gLSBieSBkZWZhdWx0IExhc3RXcml0ZVdpbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxMb2c+fSBOZXcgTG9nXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbUpTT04gKGlwZnMsIGlkZW50aXR5LCBqc29uLFxuICAgIHsgYWNjZXNzLCBsZW5ndGggPSAtMSwgdGltZW91dCwgb25Qcm9ncmVzc0NhbGxiYWNrLCBzb3J0Rm4gfSA9IHt9KSB7XG4gICAgLy8gVE9ETzogbmVlZCB0byB2ZXJpZnkgdGhlIGVudHJpZXMgd2l0aCAna2V5J1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBMb2dJTy5mcm9tSlNPTihpcGZzLCBqc29uLCB7IGxlbmd0aCwgdGltZW91dCwgb25Qcm9ncmVzc0NhbGxiYWNrIH0pXG4gICAgcmV0dXJuIG5ldyBMb2coaXBmcywgaWRlbnRpdHksIHsgbG9nSWQ6IGRhdGEuaWQsIGFjY2VzcywgZW50cmllczogZGF0YS52YWx1ZXMsIHNvcnRGbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsb2cgZnJvbSBhbiBFbnRyeSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7RW50cnl8QXJyYXk8RW50cnk+fSBzb3VyY2VFbnRyaWVzIEFuIEVudHJ5IG9yIGFuIGFycmF5IG9mIGVudHJpZXMgdG8gZmV0Y2ggYSBsb2cgZnJvbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FjY2Vzc0NvbnRyb2xsZXJ9IG9wdGlvbnMuYWNjZXNzIFRoZSBhY2Nlc3MgY29udHJvbGxlciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgZW50cmllcyB0byBpbmNsdWRlLiBEZWZhdWx0OiBpbmZpbml0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZXhjbHVkZSBFbnRyaWVzIHRvIG5vdCBmZXRjaCAoY2FjaGVkKVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gW29wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNvcnRGbiBUaGUgc29ydCBmdW5jdGlvbiAtIGJ5IGRlZmF1bHQgTGFzdFdyaXRlV2luc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPExvZz59IE5ldyBMb2dcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tRW50cnkgKGlwZnMsIGlkZW50aXR5LCBzb3VyY2VFbnRyaWVzLFxuICAgIHsgYWNjZXNzLCBsZW5ndGggPSAtMSwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0LCBzb3J0Rm4gfSA9IHt9KSB7XG4gICAgLy8gVE9ETzogbmVlZCB0byB2ZXJpZnkgdGhlIGVudHJpZXMgd2l0aCAna2V5J1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBMb2dJTy5mcm9tRW50cnkoaXBmcywgc291cmNlRW50cmllcyxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQgfSlcbiAgICByZXR1cm4gbmV3IExvZyhpcGZzLCBpZGVudGl0eSwgeyBsb2dJZDogZGF0YS5pZCwgYWNjZXNzLCBlbnRyaWVzOiBkYXRhLnZhbHVlcywgc29ydEZuIH0pXG4gIH1cblxuICAvKipcbiAgICogRmluZCBoZWFkcyBmcm9tIGEgY29sbGVjdGlvbiBvZiBlbnRyaWVzLlxuICAgKlxuICAgKiBGaW5kcyBlbnRyaWVzIHRoYXQgYXJlIHRoZSBoZWFkcyBvZiB0aGlzIGNvbGxlY3Rpb24sXG4gICAqIGllLiBlbnRyaWVzIHRoYXQgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IG90aGVyIGVudHJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBlbnRyaWVzIEVudHJpZXMgdG8gc2VhcmNoIGhlYWRzIGZyb21cbiAgICogQHJldHVybnMge0FycmF5PEVudHJ5Pn1cbiAgICovXG4gIHN0YXRpYyBmaW5kSGVhZHMgKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXhSZWR1Y2VyID0gKHJlcywgZW50cnksIGlkeCwgYXJyKSA9PiB7XG4gICAgICB2YXIgYWRkVG9SZXN1bHQgPSBlID0+IChyZXNbZV0gPSBlbnRyeS5oYXNoKVxuICAgICAgZW50cnkubmV4dC5mb3JFYWNoKGFkZFRvUmVzdWx0KVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIHZhciBpdGVtcyA9IGVudHJpZXMucmVkdWNlKGluZGV4UmVkdWNlciwge30pXG5cbiAgICB2YXIgZXhpc3RzID0gZSA9PiBpdGVtc1tlLmhhc2hdID09PSB1bmRlZmluZWRcbiAgICB2YXIgY29tcGFyZUlkcyA9IChhLCBiKSA9PiBhLmNsb2NrLmlkID4gYi5jbG9jay5pZFxuXG4gICAgcmV0dXJuIGVudHJpZXMuZmlsdGVyKGV4aXN0cykuc29ydChjb21wYXJlSWRzKVxuICB9XG5cbiAgLy8gRmluZCBlbnRyaWVzIHRoYXQgcG9pbnQgdG8gYW5vdGhlciBlbnRyeSB0aGF0IGlzIG5vdCBpbiB0aGVcbiAgLy8gaW5wdXQgYXJyYXlcbiAgc3RhdGljIGZpbmRUYWlscyAoZW50cmllcykge1xuICAgIC8vIFJldmVyc2UgaW5kZXggeyBuZXh0IC0+IGVudHJ5IH1cbiAgICB2YXIgcmV2ZXJzZUluZGV4ID0ge31cbiAgICAvLyBOdWxsIGluZGV4IGNvbnRhaW5pbmcgZW50cmllcyB0aGF0IGhhdmUgbm8gcGFyZW50cyAobmV4dHMpXG4gICAgdmFyIG51bGxJbmRleCA9IFtdXG4gICAgLy8gSGFzaGVzIGZvciBhbGwgZW50cmllcyBmb3IgcXVpY2sgbG9va3Vwc1xuICAgIHZhciBoYXNoZXMgPSB7fVxuICAgIC8vIEhhc2hlcyBvZiBhbGwgbmV4dCBlbnRyaWVzXG4gICAgdmFyIG5leHRzID0gW11cblxuICAgIHZhciBhZGRUb0luZGV4ID0gKGUpID0+IHtcbiAgICAgIGlmIChlLm5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG51bGxJbmRleC5wdXNoKGUpXG4gICAgICB9XG4gICAgICB2YXIgYWRkVG9SZXZlcnNlSW5kZXggPSAoYSkgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoIXJldmVyc2VJbmRleFthXSkgcmV2ZXJzZUluZGV4W2FdID0gW11cbiAgICAgICAgcmV2ZXJzZUluZGV4W2FdLnB1c2goZSlcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFsbCBlbnRyaWVzIGFuZCB0aGVpciBwYXJlbnRzIHRvIHRoZSByZXZlcnNlIGluZGV4XG4gICAgICBlLm5leHQuZm9yRWFjaChhZGRUb1JldmVyc2VJbmRleClcbiAgICAgIC8vIEdldCBhbGwgbmV4dCByZWZlcmVuY2VzXG4gICAgICBuZXh0cyA9IG5leHRzLmNvbmNhdChlLm5leHQpXG4gICAgICAvLyBHZXQgdGhlIGhhc2hlcyBvZiBpbnB1dCBlbnRyaWVzXG4gICAgICBoYXNoZXNbZS5oYXNoXSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgb3VyIGluZGljZXNcbiAgICBlbnRyaWVzLmZvckVhY2goYWRkVG9JbmRleClcblxuICAgIHZhciBhZGRVbmlxdWVzID0gKHJlcywgZW50cmllcywgaWR4LCBhcnIpID0+IHJlcy5jb25jYXQoZmluZFVuaXF1ZXMoZW50cmllcywgJ2hhc2gnKSlcbiAgICB2YXIgZXhpc3RzID0gZSA9PiBoYXNoZXNbZV0gPT09IHVuZGVmaW5lZFxuICAgIHZhciBmaW5kRnJvbVJldmVyc2VJbmRleCA9IGUgPT4gcmV2ZXJzZUluZGV4W2VdXG5cbiAgICAvLyBEcm9wIGhhc2hlcyB0aGF0IGFyZSBub3QgaW4gdGhlIGlucHV0IGVudHJpZXNcbiAgICBjb25zdCB0YWlscyA9IG5leHRzIC8vIEZvciBldmVyeSBoYXNoIGluIG5leHRzOlxuICAgICAgLmZpbHRlcihleGlzdHMpIC8vIFJlbW92ZSB1bmRlZmluZWRzIGFuZCBudWxsc1xuICAgICAgLm1hcChmaW5kRnJvbVJldmVyc2VJbmRleCkgLy8gR2V0IHRoZSBFbnRyeSBmcm9tIHRoZSByZXZlcnNlIGluZGV4XG4gICAgICAucmVkdWNlKGFkZFVuaXF1ZXMsIFtdKSAvLyBGbGF0dGVuIHRoZSByZXN1bHQgYW5kIHRha2Ugb25seSB1bmlxdWVzXG4gICAgICAuY29uY2F0KG51bGxJbmRleCkgLy8gQ29tYmluZSB3aXRoIHRhaWxzIHRoZSBoYXZlIG5vIG5leHQgcmVmcyAoaWUuIGZpcnN0LWluLXRoZWlyLWNoYWluKVxuXG4gICAgcmV0dXJuIGZpbmRVbmlxdWVzKHRhaWxzLCAnaGFzaCcpLnNvcnQoRW50cnkuY29tcGFyZSlcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGhhc2hlcyB0byBlbnRyaWVzIHRoYXQgYXJlIG5vdCBpbiBhIGNvbGxlY3Rpb25cbiAgLy8gYnV0IHJlZmVyZW5jZWQgYnkgb3RoZXIgZW50cmllc1xuICBzdGF0aWMgZmluZFRhaWxIYXNoZXMgKGVudHJpZXMpIHtcbiAgICB2YXIgaGFzaGVzID0ge31cbiAgICB2YXIgYWRkVG9JbmRleCA9IGUgPT4gKGhhc2hlc1tlLmhhc2hdID0gdHJ1ZSlcbiAgICB2YXIgcmVkdWNlVGFpbEhhc2hlcyA9IChyZXMsIGVudHJ5LCBpZHgsIGFycikgPT4ge1xuICAgICAgdmFyIGFkZFRvUmVzdWx0ID0gKGUpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGhhc2hlc1tlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzLnNwbGljZSgwLCAwLCBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnRyeS5uZXh0LnJldmVyc2UoKS5mb3JFYWNoKGFkZFRvUmVzdWx0KVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIGVudHJpZXMuZm9yRWFjaChhZGRUb0luZGV4KVxuICAgIHJldHVybiBlbnRyaWVzLnJlZHVjZShyZWR1Y2VUYWlsSGFzaGVzLCBbXSlcbiAgfVxuXG4gIHN0YXRpYyBkaWZmZXJlbmNlIChhLCBiKSB7XG4gICAgbGV0IHN0YWNrID0gT2JqZWN0LmtleXMoYS5faGVhZHNJbmRleClcbiAgICBsZXQgdHJhdmVyc2VkID0ge31cbiAgICBsZXQgcmVzID0ge31cblxuICAgIGNvbnN0IHB1c2hUb1N0YWNrID0gaGFzaCA9PiB7XG4gICAgICBpZiAoIXRyYXZlcnNlZFtoYXNoXSAmJiAhYi5nZXQoaGFzaCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChoYXNoKVxuICAgICAgICB0cmF2ZXJzZWRbaGFzaF0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBzdGFjay5zaGlmdCgpXG4gICAgICBjb25zdCBlbnRyeSA9IGEuZ2V0KGhhc2gpXG4gICAgICBpZiAoZW50cnkgJiYgIWIuZ2V0KGhhc2gpICYmIGVudHJ5LmlkID09PSBiLmlkKSB7XG4gICAgICAgIHJlc1tlbnRyeS5oYXNoXSA9IGVudHJ5XG4gICAgICAgIHRyYXZlcnNlZFtlbnRyeS5oYXNoXSA9IHRydWVcbiAgICAgICAgZW50cnkubmV4dC5mb3JFYWNoKHB1c2hUb1N0YWNrKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2dcbm1vZHVsZS5leHBvcnRzLlNvcnRpbmcgPSBTb3J0aW5nXG5tb2R1bGUuZXhwb3J0cy5BY2Nlc3NDb250cm9sbGVyID0gQWNjZXNzQ29udHJvbGxlclxuIiwiZnVuY3Rpb24gcihyKXtyZXR1cm4gciYmXCJvYmplY3RcIj09dHlwZW9mIHImJlwiZGVmYXVsdFwiaW4gcj9yLmRlZmF1bHQ6cn12YXIgZT1yZXF1aXJlKFwianMtc2hhMjU2XCIpLHQ9cmVxdWlyZShcImpzLXNoYTNcIiksbj1yZXF1aXJlKFwiZWxsaXB0aWNcIiksbz1yKHJlcXVpcmUoXCJ0d2VldG5hY2xcIikpLGk9cmVxdWlyZShcIkBzdGFibGVsaWIvdXRmOFwiKSxhPXJlcXVpcmUoXCJidWZmZXJcIiksdT1yKHJlcXVpcmUoXCJ1cG9ydC1iYXNlNjR1cmxcIikpLGM9cihyZXF1aXJlKFwiZGlkLXJlc29sdmVyXCIpKTtmdW5jdGlvbiBmKHIpe3JldHVybiBhLkJ1ZmZlci5mcm9tKGUuc2hhMjU2LmFycmF5QnVmZmVyKHIpKX1mdW5jdGlvbiBzKHIpe3JldHVyblwiMHhcIisoZT1hLkJ1ZmZlci5mcm9tKHIuc2xpY2UoMiksXCJoZXhcIiksYS5CdWZmZXIuZnJvbSh0LmtlY2Nha18yNTYuYXJyYXlCdWZmZXIoZSkpKS5zbGljZSgtMjApLnRvU3RyaW5nKFwiaGV4XCIpO3ZhciBlfXZhciBkPW5ldyBuLmVjKFwic2VjcDI1NmsxXCIpO2Z1bmN0aW9uIGgocixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9NjQpLHIubGVuZ3RoPT09ZT9yOlwiMFwiLnJlcGVhdChlLXIubGVuZ3RoKStyfWZ1bmN0aW9uIGwocil7cmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEJ1ZmZlci5mcm9tKHIsXCJiYXNlNjRcIiksMCkpfXZhciBwPW5ldyBuLmVjKFwic2VjcDI1NmsxXCIpO2Z1bmN0aW9uIHYocixlKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHQ9dS50b0J1ZmZlcihyKTtpZih0Lmxlbmd0aCE9PShlPzY1OjY0KSl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBzaWduYXR1cmUgbGVuZ3RoXCIpO3ZhciBuPXtyOnQuc2xpY2UoMCwzMikudG9TdHJpbmcoXCJoZXhcIiksczp0LnNsaWNlKDMyLDY0KS50b1N0cmluZyhcImhleFwiKX07cmV0dXJuIGUmJihuLnJlY292ZXJ5UGFyYW09dFs2NF0pLG59dmFyIHc9e0VTMjU2SzpmdW5jdGlvbihyLGUsdCl7dmFyIG49ZihyKSxvPXYoZSksaT10LmZpbmQoZnVuY3Rpb24ocil7cmV0dXJuIHAua2V5RnJvbVB1YmxpYyhyLnB1YmxpY0tleUhleCxcImhleFwiKS52ZXJpZnkobixvKX0pO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBpbnZhbGlkIGZvciBKV1RcIik7cmV0dXJuIGl9LFwiRVMyNTZLLVJcIjpmdW5jdGlvbihyLGUsdCl7dmFyIG49dihlLCEwKSxvPWYociksaT1wLnJlY292ZXJQdWJLZXkobyxuLG4ucmVjb3ZlcnlQYXJhbSksYT1pLmVuY29kZShcImhleFwiKSx1PWkuZW5jb2RlKFwiaGV4XCIsITApLGM9cyhhKSxkPXQuZmluZChmdW5jdGlvbihyKXt2YXIgZT1yLnB1YmxpY0tleUhleDtyZXR1cm4gZT09PWF8fGU9PT11fHxyLmV0aGVyZXVtQWRkcmVzcz09PWN9KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgaW52YWxpZCBmb3IgSldUXCIpO3JldHVybiBkfSxFZDI1NTE5OmZ1bmN0aW9uKHIsZSx0KXt2YXIgbj1pLmVuY29kZShyKSxhPWwodS50b0Jhc2U2NChlKSksYz10LmZpbmQoZnVuY3Rpb24ocil7cmV0dXJuIG8uc2lnbi5kZXRhY2hlZC52ZXJpZnkobixhLGwoci5wdWJsaWNLZXlCYXNlNjQpKX0pO2lmKCFjKXRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBpbnZhbGlkIGZvciBKV1RcIik7cmV0dXJuIGN9fTtmdW5jdGlvbiB5KHIpe3ZhciBlPXdbcl07aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiK3IpO3JldHVybiBlfWZ1bmN0aW9uIGcocil7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHImJlwiclwiaW4gciYmXCJzXCJpbiByfWZ1bmN0aW9uIG0ocil7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUodChlKSkudGhlbihmdW5jdGlvbihlKXtpZihnKGUpKXJldHVybiBmdW5jdGlvbih0KXt2YXIgbj1lLnIsbz1lLnMsaT1lLnJlY292ZXJ5UGFyYW0sYz1hLkJ1ZmZlci5hbGxvYyhyPzY1OjY0KTtpZihhLkJ1ZmZlci5mcm9tKG4sXCJoZXhcIikuY29weShjLDApLGEuQnVmZmVyLmZyb20obyxcImhleFwiKS5jb3B5KGMsMzIpLHIpe2lmKHZvaWQgMD09PWkpdGhyb3cgbmV3IEVycm9yKFwiU2lnbmVyIGRpZCBub3QgcmV0dXJuIGEgcmVjb3ZlcnlQYXJhbVwiKTtjWzY0XT1pfXJldHVybiB1LmVuY29kZShjKX0oKTt0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBhIHNpZ25lciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzaWduYXR1cmUgb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nXCIpfSl9Y2F0Y2gocil7cmV0dXJuIFByb21pc2UucmVqZWN0KHIpfX19eS50b1NpZ25hdHVyZU9iamVjdD12O3ZhciBFPXtFUzI1Nks6bSgpLFwiRVMyNTZLLVJcIjptKCEwKSxFZDI1NTE5OmZ1bmN0aW9uKHIsZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZShyKSkudGhlbihmdW5jdGlvbihyKXtpZihnKHIpKXRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGEgc2lnbmVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIHNpZ25hdHVyZSBvYmplY3RcIik7cmV0dXJuIHJ9KX1jYXRjaChyKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qocil9fX0sYj17RVMyNTZLOltcIlNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMThcIixcIlNlY3AyNTZrMVNpZ25hdHVyZVZlcmlmaWNhdGlvbktleTIwMThcIixcIkVjZHNhUHVibGljS2V5U2VjcDI1NmsxXCJdLFwiRVMyNTZLLVJcIjpbXCJTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE4XCIsXCJTZWNwMjU2azFTaWduYXR1cmVWZXJpZmljYXRpb25LZXkyMDE4XCIsXCJFY2RzYVB1YmxpY0tleVNlY3AyNTZrMVwiXSxFZDI1NTE5OltcIkVEMjU1MTlTaWduYXR1cmVWZXJpZmljYXRpb25cIl19O2Z1bmN0aW9uIFMocil7cmV0dXJuIHUuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHIpKX1mdW5jdGlvbiB4KHIpe3JldHVybiByLm1hdGNoKC9eWzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpdKyQvKX1mdW5jdGlvbiBQKHIpe2lmKHIubWF0Y2goL15kaWQ6LykpcmV0dXJuIHI7aWYoeChyKSlyZXR1cm5cImRpZDp1cG9ydDpcIityO3Rocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIERJRCAnXCIrcitcIidcIil9ZnVuY3Rpb24gayhyKXtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJubyBKV1QgcGFzc2VkIGludG8gZGVjb2RlSldUXCIpO3ZhciBlPXIubWF0Y2goL14oW2EtekEtWjAtOV8tXSspXFwuKFthLXpBLVowLTlfLV0rKVxcLihbYS16QS1aMC05Xy1dKykkLyk7aWYoZSlyZXR1cm57aGVhZGVyOkpTT04ucGFyc2UodS5kZWNvZGUoZVsxXSkpLHBheWxvYWQ6SlNPTi5wYXJzZSh1LmRlY29kZShlWzJdKSksc2lnbmF0dXJlOmVbM10sZGF0YTplWzFdK1wiLlwiK2VbMl19O3Rocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBmb3JtYXQgSldUXCIpfWV4cG9ydHMuU2ltcGxlU2lnbmVyPWZ1bmN0aW9uKHIpe3ZhciBlPWQua2V5RnJvbVByaXZhdGUocik7cmV0dXJuIGZ1bmN0aW9uKHIpe3RyeXt2YXIgdD1lLnNpZ24oZihyKSksbj10LnMsbz10LnJlY292ZXJ5UGFyYW07cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7cjpoKHQuci50b1N0cmluZyhcImhleFwiKSksczpoKG4udG9TdHJpbmcoXCJoZXhcIikpLHJlY292ZXJ5UGFyYW06b30pfWNhdGNoKHIpe3JldHVybiBQcm9taXNlLnJlamVjdChyKX19fSxleHBvcnRzLk5hY2xTaWduZXI9ZnVuY3Rpb24ocil7dmFyIGU9bChyKTtyZXR1cm4gZnVuY3Rpb24ocil7dHJ5e3ZhciB0PWkuZW5jb2RlKHIpLG49by5zaWduLmRldGFjaGVkKHQsZSksYz11LmVuY29kZShhLkJ1ZmZlci5mcm9tKG4pKTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGMpfWNhdGNoKHIpe3JldHVybiBQcm9taXNlLnJlamVjdChyKX19fSxleHBvcnRzLnZlcmlmeUpXVD1mdW5jdGlvbihyLGUpe3ZvaWQgMD09PWUmJihlPXthdXRoOm51bGwsYXVkaWVuY2U6bnVsbCxjYWxsYmFja1VybDpudWxsfSk7dHJ5e3ZhciB0PWUuYXVkaWVuY2U/UChlLmF1ZGllbmNlKTp2b2lkIDAsbj1rKHIpLG89bi5wYXlsb2FkLGk9bi5oZWFkZXIsYT1uLnNpZ25hdHVyZSx1PW4uZGF0YTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZ1bmN0aW9uKHIsZSx0KXt0cnl7dmFyIG49YltyXTtpZighbnx8MD09PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXMgZm9yIGFsZ29yaXRobSBcIityKTt2YXIgbz1QKGUpO3JldHVybiBQcm9taXNlLnJlc29sdmUoYyhvKSkudGhlbihmdW5jdGlvbihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBESUQgZG9jdW1lbnQgZm9yIFwiK28pO3ZhciBpPSF0fHwoZS5hdXRoZW50aWNhdGlvbnx8W10pLm1hcChmdW5jdGlvbihyKXtyZXR1cm4gci5wdWJsaWNLZXl9KSxhPShlLnB1YmxpY0tleXx8W10pLmZpbHRlcihmdW5jdGlvbihyKXt2YXIgZT1yLnR5cGUsbz1yLmlkO3JldHVybiBuLmZpbmQoZnVuY3Rpb24ocil7cmV0dXJuIHI9PT1lJiYoIXR8fEFycmF5LmlzQXJyYXkoaSkmJmkuaW5kZXhPZihvKT49MCl9KX0pO2lmKHQmJighYXx8MD09PWEubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJESUQgZG9jdW1lbnQgZm9yIFwiK28rXCIgZG9lcyBub3QgaGF2ZSBwdWJsaWMga2V5cyBzdWl0YWJsZSBmb3IgYXV0aGVudGljYXRpb25nIHVzZXJcIik7aWYoIWF8fDA9PT1hLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJESUQgZG9jdW1lbnQgZm9yIFwiK28rXCIgZG9lcyBub3QgaGF2ZSBwdWJsaWMga2V5cyBmb3IgXCIrcik7cmV0dXJue2F1dGhlbnRpY2F0b3JzOmEsaXNzdWVyOm8sZG9jOmV9fSl9Y2F0Y2gocil7cmV0dXJuIFByb21pc2UucmVqZWN0KHIpfX0oaS5hbGcsby5pc3MsZS5hdXRoKSkudGhlbihmdW5jdGlvbihuKXt2YXIgYyxmPW4uZG9jLHM9bi5hdXRoZW50aWNhdG9ycyxkPW4uaXNzdWVyLGg9eShpLmFsZykodSxhLHMpLGw9TWF0aC5mbG9vcihEYXRlLm5vdygpLzFlMyk7aWYoaCl7aWYoby5pYXQmJm8uaWF0PmwrMzAwKXRocm93IG5ldyBFcnJvcihcIkpXVCBub3QgdmFsaWQgeWV0IChpc3N1ZWQgaW4gdGhlIGZ1dHVyZSk6IGlhdDogXCIrby5pYXQrXCIgPiBub3c6IFwiK2wpO2lmKG8uZXhwJiZvLmV4cDw9bC0zMDApdGhyb3cgbmV3IEVycm9yKFwiSldUIGhhcyBleHBpcmVkOiBleHA6IFwiK28uZXhwK1wiIDwgbm93OiBcIitsKTtpZihvLmF1ZClpZigoYz1vLmF1ZCkmJihjLm1hdGNoKC9eZGlkOi8pfHx4KGMpKSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiSldUIGF1ZGllbmNlIGlzIHJlcXVpcmVkIGJ1dCB5b3VyIGFwcCBhZGRyZXNzIGhhcyBub3QgYmVlbiBjb25maWd1cmVkXCIpO2lmKHQhPT1QKG8uYXVkKSl0aHJvdyBuZXcgRXJyb3IoXCJKV1QgYXVkaWVuY2UgZG9lcyBub3QgbWF0Y2ggeW91ciBESUQ6IGF1ZDogXCIrby5hdWQrXCIgIT09IHlvdXJzOiBcIit0KX1lbHNle2lmKCFlLmNhbGxiYWNrVXJsKXRocm93IG5ldyBFcnJvcihcIkpXVCBhdWRpZW5jZSBtYXRjaGluZyB5b3VyIGNhbGxiYWNrIHVybCBpcyByZXF1aXJlZCBidXQgb25lIHdhc24ndCBwYXNzZWQgaW5cIik7aWYoby5hdWQhPT1lLmNhbGxiYWNrVXJsKXRocm93IG5ldyBFcnJvcihcIkpXVCBhdWRpZW5jZSBkb2VzIG5vdCBtYXRjaCB0aGUgY2FsbGJhY2sgdXJsOiBhdWQ6IFwiK28uYXVkK1wiICE9PSB1cmw6IFwiK2UuY2FsbGJhY2tVcmwpfXJldHVybntwYXlsb2FkOm8sZG9jOmYsaXNzdWVyOmQsc2lnbmVyOmgsand0OnJ9fX0pfWNhdGNoKHIpe3JldHVybiBQcm9taXNlLnJlamVjdChyKX19LGV4cG9ydHMuY3JlYXRlSldUPWZ1bmN0aW9uKHIsZSl7dmFyIHQ9ZS5pc3N1ZXIsbj1lLnNpZ25lcixvPWUuYWxnLGk9ZS5leHBpcmVzSW47dHJ5e2lmKCFuKXRocm93IG5ldyBFcnJvcihcIk5vIFNpZ25lciBmdW5jdGlvbmFsaXR5IGhhcyBiZWVuIGNvbmZpZ3VyZWRcIik7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiTm8gaXNzdWluZyBESUQgaGFzIGJlZW4gY29uZmlndXJlZFwiKTt2YXIgYT17dHlwOlwiSldUXCIsYWxnOm98fFwiRVMyNTZLXCJ9LHU9e2lhdDpNYXRoLmZsb29yKERhdGUubm93KCkvMWUzKSxleHA6dm9pZCAwfTtpZihpKXtpZihcIm51bWJlclwiIT10eXBlb2YgaSl0aHJvdyBuZXcgRXJyb3IoXCJKV1QgZXhwaXJlc0luIGlzIG5vdCBhIG51bWJlclwiKTt1LmV4cD11LmlhdCtNYXRoLmZsb29yKGkpfXZhciBjPVtTKGEpLFMoT2JqZWN0LmFzc2lnbih7fSx1LHIse2lzczp0fSkpXS5qb2luKFwiLlwiKSxmPWZ1bmN0aW9uKHIpe3ZhciBlPUVbcl07aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiK3IpO3JldHVybiBlfShhLmFsZyk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShmKGMsbikpLnRoZW4oZnVuY3Rpb24ocil7cmV0dXJuW2Mscl0uam9pbihcIi5cIil9KX1jYXRjaChyKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qocil9fSxleHBvcnRzLmRlY29kZUpXVD1rLGV4cG9ydHMudG9FdGhlcmV1bUFkZHJlc3M9cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBJZGVudGl0eVByb3ZpZGVyID0gcmVxdWlyZSgnLi9zcmMvaWRlbnRpdGllcycpXG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpdHlQcm92aWRlclxuIiwiY29uc3QgRElEX1BMQUNFSE9MREVSID0gJ0dFTkVTSVMnXG5cbi8qKlxuICogQSBjbGFzcyBmb3IgY3JlYXRpbmcgaXBmcyBiYXNlZCBESUQgRG9jdW1lbnRzLlxuICogQmFzZWQgb24gdGhlIERJRCBzcGVjOiBodHRwczovL3czYy1jY2cuZ2l0aHViLmlvL2RpZC1zcGVjL1xuICovXG5jbGFzcyBEaWREb2N1bWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRElEIERvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICBpcGZzICAgICAgICAgICAgQW4ganMtaXBmcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBtZXRob2QgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIERJRCBNZXRob2RcbiAgICogQHJldHVybiAgICB7RGlkRG9jdW1lbnR9ICAgICAgICAgICAgICAgICAgIHNlbGZcbiAgICovXG4gIGNvbnN0cnVjdG9yIChpcGZzLCBtZXRob2QpIHtcbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuX2NvbnRlbnQgPSB7XG4gICAgICBpZDogYGRpZDoke21ldGhvZH06JHtESURfUExBQ0VIT0xERVJ9YFxuICAgIH1cbiAgfVxuXG4gIGdldCBESUQgKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50LmlkLmluY2x1ZGVzKERJRF9QTEFDRUhPTERFUikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRElEIGlzIG5vdCBhdmFpbGFibGUgYmVmb3JlIGNvbW1pdCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb250ZW50LmlkXG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbiBhbHJlYWR5IGV4aXN0aW5nIERJRCBEb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgaXBmcyAgICAgICAgICAgIEFuIGpzLWlwZnMgaW5zdGFuY2VcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgZG9jdW1lbnRDaWQgICAgIFRoZSBDSUQgb2YgdGhlIGRvY3VtZW50XG4gICAqIEByZXR1cm4gICAge1Byb21pc2U8RGlkRG9jdW1lbnQ+fSAgICAgICAgICAgICAgICAgICBzZWxmXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZCAoaXBmcywgZG9jdW1lbnRDaWQpIHtcbiAgICBjb25zdCBkb2MgPSBuZXcgRGlkRG9jdW1lbnQoaXBmcylcbiAgICBkb2MuX2NvbnRlbnQgPSBhd2FpdCBEaWREb2N1bWVudC5jaWRUb0RvY3VtZW50KGlwZnMsIGRvY3VtZW50Q2lkKVxuICAgIGRvYy5fY29udGVudC5wcmV2aW91c0RvY3VtZW50ID0geyAnLyc6IGRvY3VtZW50Q2lkLnRvU3RyaW5nKCkgfVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBpZCAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBrZXksIGUuZy4gXCJrZXkxXCJcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgdHlwZSAgICAgICAgICAgIFRoZSB0eXBlIG9mIHRoZSBrZXlcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgZW5jb2RpbmcgICAgICAgIFRoZSBlbmNvZGluZyBvZiB0aGUga2V5XG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGtleSAgICAgICAgICAgICBUaGUgZW5jb2RlZCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIG93bmVyICAgICAgICAgICBUaGUgb3duZXIgb2YgdGhlIGtleSAob3B0aW9uYWwpXG4gICAqL1xuICBhZGRQdWJsaWNLZXkgKGlkLCB0eXBlLCBlbmNvZGluZywga2V5LCBvd25lcikge1xuICAgIGlmICghdGhpcy5fY29udGVudC5wdWJsaWNLZXkpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQucHVibGljS2V5ID0gW11cbiAgICB9XG4gICAgbGV0IGVudHJ5ID0ge1xuICAgICAgaWQ6IGAke3RoaXMuX2NvbnRlbnQuaWR9IyR7aWR9YCxcbiAgICAgIHR5cGVcbiAgICB9XG4gICAgZW50cnlbZW5jb2RpbmddID0ga2V5XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICBlbnRyeS5vd25lciA9IG93bmVyXG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnQucHVibGljS2V5LnB1c2goZW50cnkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBpZCAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBrZXksIGUuZy4gXCJrZXkxXCJcbiAgICovXG4gIHJlbW92ZVB1YmxpY0tleSAoaWQpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9jb250ZW50LnB1YmxpY0tleS5maW5kSW5kZXgoZSA9PiBlLmlkLmVuZHNXaXRoKGlkKSlcbiAgICB0aGlzLl9jb250ZW50LnB1YmxpY0tleS5zcGxpY2UoaWR4LCAxKVxuICAgIGlmICghdGhpcy5fY29udGVudC5wdWJsaWNLZXkubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY29udGVudC5wdWJsaWNLZXlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGF1dGhlbnRpY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIHR5cGUgICAgICAgICAgICBUaGUgdHlwZSBvZiB0aGUgYXV0aGVudGljYXRpb25cbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgaWQgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUga2V5IHRvIGJlIHVzZWQsIGUuZy4gXCJrZXkxXCJcbiAgICovXG4gIGFkZEF1dGhlbnRpY2F0aW9uICh0eXBlLCBpZCkge1xuICAgIGlmICghdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbikge1xuICAgICAgdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvbiA9IFtdXG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnQuYXV0aGVudGljYXRpb24ucHVzaCh7XG4gICAgICB0eXBlLFxuICAgICAgcHVibGljS2V5OiBgJHt0aGlzLl9jb250ZW50LmlkfSMke2lkfWBcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBhdXRoZW50aWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBpZCAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBrZXksIGUuZy4gXCJrZXkxXCJcbiAgICovXG4gIHJlbW92ZUF1dGhlbnRpY2F0aW9uIChpZCkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX2NvbnRlbnQuYXV0aGVudGljYXRpb24uZmluZEluZGV4KGUgPT4gZS5wdWJsaWNLZXkuZW5kc1dpdGgoaWQpKVxuICAgIHRoaXMuX2NvbnRlbnQuYXV0aGVudGljYXRpb24uc3BsaWNlKGlkeCwgMSlcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQuYXV0aGVudGljYXRpb24ubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY29udGVudC5hdXRoZW50aWNhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc2VydmljZVxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBpZCAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUga2V5IHRvIGJlIHVzZWQsIGUuZy4gXCJrZXkxXCJcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgdHlwZSAgICAgICAgICAgICAgICBUaGUgdHlwZSBvZiB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICBzZXJ2aWNlRW5kcG9pbnQgICAgIFRoZSBlbmRwb2ludCBvZiB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICBhZGRpdGlvbmFsRmllbGRzICAgIEFueSBhZGRpdGlvbmFsIGZpZWxkcyAob3B0aW9uYWwpXG4gICAqL1xuICBhZGRTZXJ2aWNlIChpZCwgdHlwZSwgc2VydmljZUVuZHBvaW50LCBhZGRpdGlvbmFsRmllbGRzKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50LnNlcnZpY2UpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuc2VydmljZSA9IFtdXG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnQuc2VydmljZS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgaWQ6IGAke3RoaXMuX2NvbnRlbnQuaWR9OyR7aWR9YCxcbiAgICAgIHR5cGUsXG4gICAgICBzZXJ2aWNlRW5kcG9pbnRcbiAgICB9LCBhZGRpdGlvbmFsRmllbGRzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzZXJ2aWNlXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIGlkICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIGtleSwgZS5nLiBcImtleTFcIlxuICAgKi9cbiAgcmVtb3ZlU2VydmljZSAoaWQpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9jb250ZW50LnNlcnZpY2UuZmluZEluZGV4KGUgPT4gZS5pZC5lbmRzV2l0aChpZCkpXG4gICAgdGhpcy5fY29udGVudC5zZXJ2aWNlLnNwbGljZShpZHgsIDEpXG4gICAgaWYgKCF0aGlzLl9jb250ZW50LnNlcnZpY2UubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fY29udGVudC5zZXJ2aWNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmV2b2NhdGlvbk1ldGhvZC4gVGhpcyBjYW4gYmUgb2YgYW55IGpzIG9iamVjdFxuICAgKiBhbmQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgaW1wbGVtZW50ZXIgb2YgYSByZXZvY2F0aW9uIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgbWV0aG9kRGVzY3JpcHRvciAgICB0aGUgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgcmV2b2NhdGlvbiBtZXRob2RcbiAgICovXG4gIHNldFJldm9jYXRpb25NZXRob2QgKG1ldGhvZERlc2NyaXB0b3IpIHtcbiAgICB0aGlzLl9jb250ZW50LnJldm9jYXRpb25NZXRob2QgPSBtZXRob2REZXNjcmlwdG9yXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIHByb3BOYW1lICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgIHByb3BWYWx1ZSAgICAgICAgICAgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgKi9cbiAgYWRkQ3VzdG9tUHJvcGVydHkgKHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZW50W3Byb3BOYW1lXSA9IHByb3BWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHByb3BlcnR5XG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgIHByb3BOYW1lICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAqL1xuICByZW1vdmVDdXN0b21Qcm9wZXJ0eSAocHJvcE5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fY29udGVudFtwcm9wTmFtZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21taXQgYWxsIGNoYW5nZXMgYW5kIGNyZWF0ZSBhIG5ldyBpcGZzIGRhZyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgIG9wdHMgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgICAgICBub1RpbWVzdGFtcCAgICAgICAgIERvbid0IHVzZSB0aW1lc3RhbXBzIGlmIHRydWVcbiAgICpcbiAgICogQHJldHVybiAgICB7UHJvbWlzZTxDSUQ+fSAgICAgICAgICAgICAgICAgICBUaGUgQ0lEIG9mIHRoZSBvYmplY3RcbiAgICovXG4gIGFzeW5jIGNvbW1pdCAob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50LmNyZWF0ZWQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRbJ0Bjb250ZXh0J10gPSAnaHR0cHM6Ly93M2lkLm9yZy9kaWQvdjEnXG4gICAgICBpZiAoIW9wdHMubm9UaW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy5fY29udGVudC5jcmVhdGVkID0gKG5ldyBEYXRlKERhdGUubm93KCkpKS50b0lTT1N0cmluZygpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0cy5ub1RpbWVzdGFtcCkge1xuICAgICAgdGhpcy5fY29udGVudC51cGRhdGVkID0gKG5ldyBEYXRlKERhdGUubm93KCkpKS50b0lTT1N0cmluZygpXG4gICAgfVxuICAgIGNvbnN0IGNpZCA9IGF3YWl0IHRoaXMuX2lwZnMuZGFnLnB1dCh0aGlzLl9jb250ZW50LCB7IGZvcm1hdDogJ2RhZy1jYm9yJywgaGFzaEFsZzogJ3NoYTItMjU2JyB9KVxuICAgIC8vIHNldCB1cCBmb3IgZnVydGhlciBjaGFuZ2VzOlxuICAgIHRoaXMuX2NvbnRlbnQgPSBhd2FpdCBEaWREb2N1bWVudC5jaWRUb0RvY3VtZW50KHRoaXMuX2lwZnMsIGNpZClcbiAgICB0aGlzLl9jb250ZW50LnByZXZpb3VzRG9jdW1lbnQgPSB7ICcvJzogY2lkLnRvU3RyaW5nKCkgfVxuICAgIHJldHVybiBjaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBESUQgZG9jdW1lbnQgb2YgYSBkb2N1bWVudCBDSURcbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgaXBmcyAgICAgICAgICAgIEFuIGpzLWlwZnMgaW5zdGFuY2VcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgZG9jdW1lbnRDaWQgICAgIFRoZSBDSUQgb2YgdGhlIGRvY3VtZW50XG4gICAqIEByZXR1cm4gICAge1Byb21pc2U8T2JqZWN0Pn0gICAgICAgICAgICAgICAgICAgICAgICBUaGUgRElEIGRvY3VtZW50IGFzIGEganMgb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY2lkVG9Eb2N1bWVudCAoaXBmcywgZG9jdW1lbnRDaWQpIHtcbiAgICBsZXQgZG9jID0gKGF3YWl0IGlwZnMuZGFnLmdldChkb2N1bWVudENpZCkpLnZhbHVlXG4gICAgLy8gSWYgZ2VuZXNpcyBkb2N1bWVudCByZXBsYWNlIHBsYWNlaG9sZGVyIGlkZW50aWZpZXIgd2l0aCBjaWRcbiAgICBpZiAoZG9jLmlkLmluY2x1ZGVzKERJRF9QTEFDRUhPTERFUikpIHtcbiAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChESURfUExBQ0VIT0xERVIsICdnaScpXG4gICAgICBkb2MuaWQgPSBkb2MuaWQucmVwbGFjZShyZSwgZG9jdW1lbnRDaWQpXG4gICAgICBpZiAoZG9jLnB1YmxpY0tleSkge1xuICAgICAgICBkb2MucHVibGljS2V5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkb2MucHVibGljS2V5KS5yZXBsYWNlKHJlLCBkb2N1bWVudENpZCkpXG4gICAgICB9XG4gICAgICBpZiAoZG9jLmF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIGRvYy5hdXRoZW50aWNhdGlvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZG9jLmF1dGhlbnRpY2F0aW9uKS5yZXBsYWNlKHJlLCBkb2N1bWVudENpZCkpXG4gICAgICB9XG4gICAgICBpZiAoZG9jLnNlcnZpY2UpIHtcbiAgICAgICAgZG9jLnNlcnZpY2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRvYy5zZXJ2aWNlKS5yZXBsYWNlKHJlLCBkb2N1bWVudENpZCkpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb2MucHJldmlvdXNEb2N1bWVudCkge1xuICAgICAgLy8gbWFrZSBDSUQgaHVtYW4gcmVhZGFibGVcbiAgICAgIGRvYy5wcmV2aW91c0RvY3VtZW50ID0geyAnLyc6IGRvYy5wcmV2aW91c0RvY3VtZW50LnRvU3RyaW5nKCkgfVxuICAgIH1cbiAgICByZXR1cm4gZG9jXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWREb2N1bWVudFxuIiwidmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvWE1MSHR0cFJlcXVlc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJUEZTO1xuXG4vKipcbiAqIFRoZSB2YXJydWN0b3Igb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYCB0aGUgcHJvdmlkZXIgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IGBpcGZzYCByZXR1cm5zIGFuIElQRlMgaW5zdGFuY2VcbiAqIEB0aHJvd3MgaWYgdGhlIGBuZXdgIGZsYWcgaXMgbm90IHVzZWRcbiAqL1xuZnVuY3Rpb24gSVBGUyhwcm92aWRlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSVBGUykpIHsgdGhyb3cgbmV3IEVycm9yKCdbaXBmcy1taW5pXSBJUEZTIGluc3RhbmNlIG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggXCJuZXdcIiBmbGFnIChlLmcuIHZhciBpcGZzID0gbmV3IElQRlMoXCJodHRwOi8vbG9jYWxob3N0Ojg1NDVcIik7KS4nKTsgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5zZXRQcm92aWRlcihwcm92aWRlciB8fCB7fSk7XG59XG5cbi8qKlxuICogTm8gb3BlcmF0aW9uIG1ldGhvZFxuICovXG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIG5ld1Byb21pc2UodmFsKSB7IHJldHVybiBuZXcgUHJvbWlzZSh2YWwpOyB9XG5mdW5jdGlvbiBub29wUHJvbWlzZSh2YWwpIHsgdmFsKG5vb3AsIG5vb3ApOyB9XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvdmlkZXIgb2YgdGhlIElQRlMgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgIHRoZSBwcm92aWRlciBvYmplY3RcbiAqIEB0aHJvd3MgaWYgdGhlIHByb3ZpZGVyIG9iamVjdCBpcyBub3QgYW4gb2JqZWN0XG4gKi9cbklQRlMucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gc2V0UHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgaWYgKHR5cGVvZiBwcm92aWRlciAhPT0gJ29iamVjdCcpIHsgdGhyb3cgbmV3IEVycm9yKGBbaWZwc2pzXSBwcm92aWRlciBtdXN0IGJlIHR5cGUgT2JqZWN0LCBnb3QgJyR7dHlwZW9mIHByb3ZpZGVyfScuYCk7IH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHNlbGYucHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKHtcbiAgICBob3N0OiAnMTI3LjAuMC4xJyxcbiAgICBwaW5uaW5nOiB0cnVlLFxuICAgIHBvcnQ6ICc1MDAxJyxcbiAgICBwcm90b2NvbDogJ2h0dHAnLFxuICAgIGJhc2U6ICcvYXBpL3YwJyB9LCBwcm92aWRlciB8fCB7fSk7XG4gIHNlbGYucmVxdWVzdEJhc2UgPSBTdHJpbmcoYCR7ZGF0YS5wcm90b2NvbH06Ly8ke2RhdGEuaG9zdH06JHtkYXRhLnBvcnR9JHtkYXRhLmJhc2V9YCk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGFuIGFzeW5jIGRhdGEgcGFja2V0IHRvIGFuIElQRlMgbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRzYCB0aGUgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBjYmAgdGhlIHByb3ZpZGVyIGNhbGxiYWNrXG4gKiBAY2FsbGJhY2sgcmV0dXJucyBhbiBlcnJvciBpZiBhbnksIG9yIHRoZSBkYXRhIGZyb20gSVBGU1xuICovXG5JUEZTLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiBzZW5kQXN5bmMob3B0cywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcblxuICByZXR1cm4gKGNiID8gbm9vcFByb21pc2UgOiBuZXdQcm9taXNlKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZSwgcil7XG4gICAgICAoY2IgfHwgbm9vcCkoZSwgb3B0aW9ucy50YWtlSGFzaCAmJiByID8gci5IYXNoIDogcik7XG4gICAgICBpZiAoZSkgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgIGlmICghZSAmJiByKSByZXR1cm4gcmVzb2x2ZShvcHRpb25zLnRha2VIYXNoID8gci5IYXNoIDogcik7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCAmJiByZXF1ZXN0LnRpbWVvdXQgIT09IDEpIHtcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYFtpcGZzLW1pbmldIHN0YXR1cyAke3JlcXVlc3Quc3RhdHVzfTogJHtyZXF1ZXN0LnJlc3BvbnNlVGV4dH1gKSwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIChvcHRpb25zLmpzb25QYXJzZSA/IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpIDogcmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgW2lwZnMtbWluaV0gd2hpbGUgcGFyc2luZyBkYXRhOiAnJHtTdHJpbmcocmVxdWVzdC5yZXNwb25zZVRleHQpfScsIGVycm9yOiAke1N0cmluZyhqc29uRXJyb3IpfSB3aXRoIHByb3ZpZGVyOiAnJHtzZWxmLnJlcXVlc3RCYXNlfSdgLCBudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcGlubmluZ1VSSSA9IHNlbGYucHJvdmlkZXIucGlubmluZyAmJiBvcHRzLnVyaSA9PT0gJy9hZGQnID8gJz9waW49dHJ1ZScgOiAnJztcblxuICAgICAgaWYgKG9wdGlvbnMucGF5bG9hZCkge1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ1BPU1QnLCBgJHtzZWxmLnJlcXVlc3RCYXNlfSR7b3B0cy51cml9JHtwaW5uaW5nVVJJfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBgJHtzZWxmLnJlcXVlc3RCYXNlfSR7b3B0cy51cml9JHtwaW5uaW5nVVJJfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hY2NlcHQpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdhY2NlcHQnLCBvcHRpb25zLmFjY2VwdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBheWxvYWQgJiYgb3B0aW9ucy5ib3VuZGFyeSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke29wdGlvbnMuYm91bmRhcnl9YCk7XG4gICAgICAgIHJlcXVlc3Quc2VuZChvcHRpb25zLnBheWxvYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIGNyZWF0ZXMgYSBib3VuZGFyeSB0aGF0IGlzbid0IHBhcnQgb2YgdGhlIHBheWxvYWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnkoZGF0YSkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBib3VuZGFyeSA9IGAtLS0tSVBGU01pbmkke01hdGgucmFuZG9tKCkgKiAxMDAwMDB9LiR7TWF0aC5yYW5kb20oKSAqIDEwMDAwMH1gO1xuICAgIGlmIChkYXRhLmluZGV4T2YoYm91bmRhcnkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGJvdW5kYXJ5O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBzdHJpbmcgb3IgYnVmZmVyIHRvIElQRlNcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gYGlucHV0YCBhIHNpbmdsZSBzdHJpbmcgb3IgYnVmZmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgY2FsbGJhY2tgIGEgY2FsbGJhY2ssIHdpdGggKGVycm9yLCBpcGZzSGFzaCBTdHJpbmcpXG4gKiBAY2FsbGJhY2sge1N0cmluZ30gYGlwZnNIYXNoYCByZXR1cm5zIGFuIElQRlMgaGFzaCBzdHJpbmdcbiAqL1xuSVBGUy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkRGF0YShpbnB1dCwgY2FsbGJhY2spIHtcbiAgdmFyIGRhdGEgPSAoKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQuaXNCdWZmZXIpID8gaW5wdXQudG9TdHJpbmcoJ2JpbmFyeScpIDogaW5wdXQpO1xuICB2YXIgYm91bmRhcnkgPSBjcmVhdGVCb3VuZGFyeShkYXRhKTtcbiAgdmFyIHBheWxvYWQgPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cInBhdGhcIlxcclxcbkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXFxyXFxuXFxyXFxuJHtkYXRhfVxcclxcbi0tJHtib3VuZGFyeX0tLWA7XG5cbiAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKHtcbiAgICBqc29uUGFyc2U6IHRydWUsXG4gICAgYWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgdXJpOiAnL2FkZCcsXG4gICAgdGFrZUhhc2g6IHRydWUsXG4gICAgcGF5bG9hZCwgYm91bmRhcnksXG4gIH0sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIEpTT04gb2JqZWN0IHRvIElQRlNcbiAqIEBwYXJhbSB7T2JqZWN0fSBganNvbkRhdGFgIGEgc2luZ2xlIEpTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgY2FsbGJhY2tgIGEgY2FsbGJhY2ssIHdpdGggKGVycm9yLCBpcGZzSGFzaCBTdHJpbmcpXG4gKiBAY2FsbGJhY2sge1N0cmluZ30gYGlwZnNIYXNoYCByZXR1cm5zIGFuIElQRlMgaGFzaCBzdHJpbmdcbiAqL1xuSVBGUy5wcm90b3R5cGUuYWRkSlNPTiA9IGZ1bmN0aW9uIGFkZEpzb24oanNvbkRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHNlbGYuYWRkKEpTT04uc3RyaW5naWZ5KGpzb25EYXRhKSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHN0YXQgYC9vYmplY3Qvc3RhdGAgZm9yIGFuIElQRlMgaGFzaFxuICogQHBhcmFtIHtTdHJpbmd9IGBpcGZzSGFzaGAgYSBzaW5nbGUgSVBGUyBoYXNoIFN0cmluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gYGNhbGxiYWNrYCBhIGNhbGxiYWNrLCB3aXRoIChlcnJvciwgc3RhdHMgT2JqZWN0KVxuICogQGNhbGxiYWNrIHtPYmplY3R9IGBzdGF0c2AgcmV0dXJucyB0aGUgc3RhdHMgb2JqZWN0IGZvciB0aGF0IElQRlMgaGFzaFxuICovXG5JUEZTLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gY2F0KGlwZnNIYXNoLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBzZWxmLnNlbmRBc3luYyh7IGpzb25QYXJzZTogdHJ1ZSwgdXJpOiBgL29iamVjdC9zdGF0LyR7aXBmc0hhc2h9YCB9LCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBmcm9tIGFuIElQRlMgaGFzaFxuICogQHBhcmFtIHtTdHJpbmd9IGBpcGZzSGFzaGAgYSBzaW5nbGUgSVBGUyBoYXNoIFN0cmluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gYGNhbGxiYWNrYCBhIGNhbGxiYWNrLCB3aXRoIChlcnJvciwgc3RhdHMgT2JqZWN0KVxuICogQGNhbGxiYWNrIHtTdHJpbmd9IGBkYXRhYCByZXR1cm5zIHRoZSBvdXRwdXQgZGF0YVxuICovXG5JUEZTLnByb3RvdHlwZS5jYXQgPSBmdW5jdGlvbiBjYXQoaXBmc0hhc2gsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHNlbGYuc2VuZEFzeW5jKHsgdXJpOiBgL2NhdC8ke2lwZnNIYXNofWAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgZnJvbSBhbiBJUEZTIGhhc2ggdGhhdCBpcyBhIEpTT04gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gYGlwZnNIYXNoYCBhIHNpbmdsZSBJUEZTIGhhc2ggU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgY2FsbGJhY2tgIGEgY2FsbGJhY2ssIHdpdGggKGVycm9yLCBqc29uIE9iamVjdClcbiAqIEBjYWxsYmFjayB7T2JqZWN0fSBgZGF0YWAgcmV0dXJucyB0aGUgb3V0cHV0IGRhdGEgSlNPTiBvYmplY3RcbiAqL1xuSVBGUy5wcm90b3R5cGUuY2F0SlNPTiA9IGZ1bmN0aW9uIGNhdEpTT04oaXBmc0hhc2gsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHNlbGYuc2VuZEFzeW5jKHsgdXJpOiBgL2NhdC8ke2lwZnNIYXNofWAsIGpzb25QYXJzZTogdHJ1ZSB9LCBjYWxsYmFjayk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kaWRKd3QgPSByZXF1aXJlKFwiZGlkLWp3dFwiKTtcblxudmFyIF9pcGZzRGlkRG9jdW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJpcGZzLWRpZC1kb2N1bWVudFwiKSk7XG5cbnZhciBfYmFzZTY0dXJsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmFzZTY0dXJsXCIpKTtcblxudmFyIF9kaWRSZXNvbHZlciA9IHJlcXVpcmUoXCJkaWQtcmVzb2x2ZXJcIik7XG5cbnZhciBQVUJLRVlfSURTID0gWydzaWduaW5nS2V5JywgJ21hbmFnZW1lbnRLZXknLCAnZW5jcnlwdGlvbktleSddO1xudmFyIFNVQl9QVUJLRVlfSURTID0gWydzdWJTaWduaW5nS2V5JywgJ3N1YkVuY3J5cHRpb25LZXknXTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoaXBmcykge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICgwLCBfZGlkUmVzb2x2ZXIucmVnaXN0ZXJNZXRob2QpKCczJywgZnVuY3Rpb24gKF8sIF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkO1xuICAgIHJldHVybiByZXNvbHZlKGlwZnMsIGlkKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgX3Jlc29sdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gIC8qI19fUFVSRV9fKi9cbiAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaXBmcywgY2lkLCBpc1Jvb3QpIHtcbiAgICB2YXIgZG9jLCByb290RG9jO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIF9pcGZzRGlkRG9jdW1lbnRbXCJkZWZhdWx0XCJdLmNpZFRvRG9jdW1lbnQoaXBmcywgY2lkKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRvYyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICB2YWxpZGF0ZURvYyhkb2MpO1xuXG4gICAgICAgICAgICBpZiAoIWRvYy5yb290KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNSb290KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBsYXllciBzdWJEb2MgYWxsb3dlZCcpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXBmcywgZG9jLnJvb3Quc3BsaXQoJzonKVsyXSwgdHJ1ZSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcm9vdERvYyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gdmVyaWZ5UHJvb2YoZG9jKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBkb2MgPSBtZXJnZURvY3VtZW50cyhyb290RG9jLCBkb2MpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgIHJldHVybiBpcGZzLnBpbi5ybShjaWQpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMztcbiAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxOCk7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIDNJRCcpO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZG9jKTtcblxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgMTZdLCBbMTgsIDIzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURvYyhkb2MpIHtcbiAgdmFyIHB1YktleUlkcyA9IFBVQktFWV9JRFM7XG5cbiAgaWYgKCFkb2MgfHwgIWRvYy5wdWJsaWNLZXkgfHwgIWRvYy5hdXRoZW50aWNhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgM0lEJyk7XG4gIH1cblxuICBpZiAoZG9jLnJvb3QpIHtcbiAgICBwdWJLZXlJZHMgPSBTVUJfUFVCS0VZX0lEUztcbiAgICBpZiAoIWRvYy5zcGFjZSkgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCAzSUQnKTtcbiAgfVxuXG4gIGRvYy5wdWJsaWNLZXkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBpZCA9IGVudHJ5LmlkLnNwbGl0KCcjJylbMV07XG4gICAgaWYgKCFwdWJLZXlJZHMuaW5jbHVkZXMoaWQpKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIDNJRCcpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU2VjdGlvbihkYXRhKSB7XG4gIHJldHVybiBfYmFzZTY0dXJsW1wiZGVmYXVsdFwiXS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlQcm9vZihfeDQpIHtcbiAgcmV0dXJuIF92ZXJpZnlQcm9vZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfdmVyaWZ5UHJvb2YoKSB7XG4gIF92ZXJpZnlQcm9vZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc3ViRG9jKSB7XG4gICAgdmFyIHN1YlNpZ25pbmdLZXksIHN1YkVuY3J5cHRpb25LZXksIHBheWxvYWQsIGhlYWRlciwgand0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgc3ViU2lnbmluZ0tleSA9IHN1YkRvYy5wdWJsaWNLZXkuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmlkLmluY2x1ZGVzKFNVQl9QVUJLRVlfSURTWzBdKTtcbiAgICAgICAgICAgIH0pLnB1YmxpY0tleUhleDtcbiAgICAgICAgICAgIHN1YkVuY3J5cHRpb25LZXkgPSBzdWJEb2MucHVibGljS2V5LmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbnRyeS5pZC5pbmNsdWRlcyhTVUJfUFVCS0VZX0lEU1sxXSk7XG4gICAgICAgICAgICB9KS5wdWJsaWNLZXlCYXNlNjQ7XG4gICAgICAgICAgICBwYXlsb2FkID0gZW5jb2RlU2VjdGlvbih7XG4gICAgICAgICAgICAgIGlhdDogbnVsbCxcbiAgICAgICAgICAgICAgc3ViU2lnbmluZ0tleTogc3ViU2lnbmluZ0tleSxcbiAgICAgICAgICAgICAgc3ViRW5jcnlwdGlvbktleTogc3ViRW5jcnlwdGlvbktleSxcbiAgICAgICAgICAgICAgc3BhY2U6IHN1YkRvYy5zcGFjZSxcbiAgICAgICAgICAgICAgaXNzOiBzdWJEb2Mucm9vdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWFkZXIgPSBlbmNvZGVTZWN0aW9uKHtcbiAgICAgICAgICAgICAgdHlwOiAnSldUJyxcbiAgICAgICAgICAgICAgYWxnOiBzdWJEb2MucHJvb2YuYWxnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGp3dCA9IFwiXCIuY29uY2F0KGhlYWRlciwgXCIuXCIpLmNvbmNhdChwYXlsb2FkLCBcIi5cIikuY29uY2F0KHN1YkRvYy5wcm9vZi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZGlkSnd0LnZlcmlmeUpXVCkoand0KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3ZlcmlmeVByb29mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRG9jdW1lbnRzKGRvYywgc3ViRG9jKSB7XG4gIHN1YkRvYy5wdWJsaWNLZXkgPSBkb2MucHVibGljS2V5LmNvbmNhdChzdWJEb2MucHVibGljS2V5KTtcbiAgcmV0dXJuIHN1YkRvYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBIRE5vZGUgPSByZXF1aXJlKCdldGhlcnMnKS51dGlscy5IRE5vZGU7XG5cbnZhciBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJyk7XG5cbm5hY2wudXRpbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbC11dGlsJyk7XG5cbnZhciBTaW1wbGVTaWduZXIgPSByZXF1aXJlKCdkaWQtand0JykuU2ltcGxlU2lnbmVyO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuLi91dGlscy9pbmRleCcpLFxuICAgIHNoYTI1NiA9IF9yZXF1aXJlLnNoYTI1NjtcblxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcbnZhciBCQVNFX1BBVEggPSBcIm0vNzY5NjUwMCcvMCcvMCdcIjtcbnZhciBNTV9QQVRIID0gXCJtLzQ0Jy82MCcvMCcvMFwiO1xuXG52YXIgS2V5cmluZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleXJpbmcoc2VlZCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgS2V5cmluZyk7XG4gICAgdGhpcy5fc2VlZCA9IHNlZWQ7XG4gICAgdmFyIHNlZWROb2RlID0gSEROb2RlLmZyb21TZWVkKHRoaXMuX3NlZWQpO1xuICAgIHZhciBiYXNlTm9kZSA9IHNlZWROb2RlLmRlcml2ZVBhdGgoQkFTRV9QQVRIKTtcbiAgICB0aGlzLnNpZ25pbmdLZXkgPSBiYXNlTm9kZS5kZXJpdmVQYXRoKFwiMFwiKTtcbiAgICB2YXIgdG1wRW5jS2V5ID0gQnVmZmVyLmZyb20oYmFzZU5vZGUuZGVyaXZlUGF0aChcIjJcIikucHJpdmF0ZUtleS5zbGljZSgyKSwgJ2hleCcpO1xuICAgIHRoaXMuYXN5bUVuY3J5cHRpb25LZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkobmV3IFVpbnQ4QXJyYXkodG1wRW5jS2V5KSk7XG4gICAgdGhpcy5zeW1FbmNyeXB0aW9uS2V5ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oYmFzZU5vZGUuZGVyaXZlUGF0aChcIjNcIikucHJpdmF0ZUtleS5zbGljZSgyKSwgJ2hleCcpKTtcbiAgICB0aGlzLmV0aGVyZXVtS2V5ID0gc2VlZE5vZGUuZGVyaXZlUGF0aChNTV9QQVRIKS5kZXJpdmVQYXRoKFwiMFwiKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoS2V5cmluZywgW3tcbiAgICBrZXk6IFwiYXN5bUVuY3J5cHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXN5bUVuY3J5cHQobXNnLCB0b1B1YmxpYywgbm9uY2UpIHtcbiAgICAgIG5vbmNlID0gbm9uY2UgfHwgcmFuZG9tTm9uY2UoKTtcbiAgICAgIHRvUHVibGljID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NCh0b1B1YmxpYyk7XG5cbiAgICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICBtc2cgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2cpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2lwaGVydGV4dCA9IG5hY2wuYm94KG1zZywgbm9uY2UsIHRvUHVibGljLCB0aGlzLmFzeW1FbmNyeXB0aW9uS2V5LnNlY3JldEtleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub25jZTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgIGNpcGhlcnRleHQ6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoY2lwaGVydGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzeW1EZWNyeXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzeW1EZWNyeXB0KGNpcGhlcnRleHQsIGZyb21QdWJsaWMsIG5vbmNlLCB0b0J1ZmZlcikge1xuICAgICAgZnJvbVB1YmxpYyA9IG5hY2wudXRpbC5kZWNvZGVCYXNlNjQoZnJvbVB1YmxpYyk7XG4gICAgICBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgICAgIG5vbmNlID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChub25jZSk7XG4gICAgICB2YXIgY2xlYXJ0ZXh0ID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZnJvbVB1YmxpYywgdGhpcy5hc3ltRW5jcnlwdGlvbktleS5zZWNyZXRLZXkpO1xuXG4gICAgICBpZiAodG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFydGV4dCA/IEJ1ZmZlci5mcm9tKGNsZWFydGV4dCkgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xlYXJ0ZXh0ID8gbmFjbC51dGlsLmVuY29kZVVURjgoY2xlYXJ0ZXh0KSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bUVuY3J5cHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ltRW5jcnlwdChtc2csIG5vbmNlKSB7XG4gICAgICByZXR1cm4gc3ltRW5jcnlwdEJhc2UobXNnLCB0aGlzLnN5bUVuY3J5cHRpb25LZXksIG5vbmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ltRGVjcnlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW1EZWNyeXB0KGNpcGhlcnRleHQsIG5vbmNlLCB0b0J1ZmZlcikge1xuICAgICAgcmV0dXJuIHN5bURlY3J5cHRCYXNlKGNpcGhlcnRleHQsIHRoaXMuc3ltRW5jcnlwdGlvbktleSwgbm9uY2UsIHRvQnVmZmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SldUU2lnbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEpXVFNpZ25lcigpIHtcbiAgICAgIHJldHVybiBTaW1wbGVTaWduZXIodGhpcy5zaWduaW5nS2V5LnByaXZhdGVLZXkuc2xpY2UoMikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREQlNhbHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0REJTYWx0KCkge1xuICAgICAgcmV0dXJuIHNoYTI1Nih0aGlzLnNpZ25pbmdLZXkuZGVyaXZlUGF0aCgnMCcpLnByaXZhdGVLZXkuc2xpY2UoMikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQdWJsaWNLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY0tleXModW5jb21wcmVzc2VkKSB7XG4gICAgICB2YXIgc2lnbmluZ0tleSA9IHRoaXMuc2lnbmluZ0tleS5wdWJsaWNLZXkuc2xpY2UoMik7XG4gICAgICB2YXIgZXRoZXJldW1LZXkgPSB0aGlzLmV0aGVyZXVtS2V5LnB1YmxpY0tleS5zbGljZSgyKTtcblxuICAgICAgaWYgKHVuY29tcHJlc3NlZCkge1xuICAgICAgICBzaWduaW5nS2V5ID0gZWMua2V5RnJvbVB1YmxpYyhCdWZmZXIuZnJvbShzaWduaW5nS2V5LCAnaGV4JykpLmdldFB1YmxpYyhmYWxzZSwgJ2hleCcpO1xuICAgICAgICBldGhlcmV1bUtleSA9IGVjLmtleUZyb21QdWJsaWMoQnVmZmVyLmZyb20oZXRoZXJldW1LZXksICdoZXgnKSkuZ2V0UHVibGljKGZhbHNlLCAnaGV4Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25pbmdLZXk6IHNpZ25pbmdLZXksXG4gICAgICAgIGV0aGVyZXVtS2V5OiBldGhlcmV1bUtleSxcbiAgICAgICAgYXN5bUVuY3J5cHRpb25LZXk6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQodGhpcy5hc3ltRW5jcnlwdGlvbktleS5wdWJsaWNLZXkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLZXlyaW5nO1xufSgpO1xuXG52YXIgcmFuZG9tTm9uY2UgPSBmdW5jdGlvbiByYW5kb21Ob25jZSgpIHtcbiAgcmV0dXJuIG5hY2wucmFuZG9tQnl0ZXMoMjQpO1xufTtcblxudmFyIHN5bUVuY3J5cHRCYXNlID0gZnVuY3Rpb24gc3ltRW5jcnlwdEJhc2UobXNnLCBzeW1LZXksIG5vbmNlKSB7XG4gIG5vbmNlID0gbm9uY2UgfHwgcmFuZG9tTm9uY2UoKTtcblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBtc2cgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2cpO1xuICB9XG5cbiAgdmFyIGNpcGhlcnRleHQgPSBuYWNsLnNlY3JldGJveChtc2csIG5vbmNlLCBzeW1LZXkpO1xuICByZXR1cm4ge1xuICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICBjaXBoZXJ0ZXh0OiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KGNpcGhlcnRleHQpXG4gIH07XG59O1xuXG52YXIgc3ltRGVjcnlwdEJhc2UgPSBmdW5jdGlvbiBzeW1EZWNyeXB0QmFzZShjaXBoZXJ0ZXh0LCBzeW1LZXksIG5vbmNlLCB0b0J1ZmZlcikge1xuICBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChjaXBoZXJ0ZXh0KTtcbiAgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG5vbmNlKTtcbiAgdmFyIGNsZWFydGV4dCA9IG5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIHN5bUtleSk7XG5cbiAgaWYgKHRvQnVmZmVyKSB7XG4gICAgcmV0dXJuIGNsZWFydGV4dCA/IEJ1ZmZlci5mcm9tKGNsZWFydGV4dCkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNsZWFydGV4dCA/IG5hY2wudXRpbC5lbmNvZGVVVEY4KGNsZWFydGV4dCkgOiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlyaW5nOyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBBY2Nlc3NDb250cm9sbGVyTWFuaWZlc3QgPSByZXF1aXJlKCcuL2FjY2Vzcy1jb250cm9sbGVyLW1hbmlmZXN0JylcbmNvbnN0IExlZ2FjeUlQRlNBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9sZWdhY3ktaXBmcy1hY2Nlc3MtY29udHJvbGxlcicpXG5jb25zdCBJUEZTQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vaXBmcy1hY2Nlc3MtY29udHJvbGxlcicpXG5jb25zdCBPcmJpdERCQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vb3JiaXRkYi1hY2Nlc3MtY29udHJvbGxlcicpXG5cbmxldCBzdXBwb3J0ZWRUeXBlcyA9IHtcbiAgJ2xlZ2FjeS1pcGZzJzogTGVnYWN5SVBGU0FjY2Vzc0NvbnRyb2xsZXIsXG4gICdpcGZzJzogSVBGU0FjY2Vzc0NvbnRyb2xsZXIsXG4gICdvcmJpdGRiJzogT3JiaXREQkFjY2Vzc0NvbnRyb2xsZXJcbn1cblxuY29uc3QgZ2V0SGFuZGxlckZvciA9ICh0eXBlKSA9PiB7XG4gIGlmICghQWNjZXNzQ29udHJvbGxlcnMuaXNTdXBwb3J0ZWQodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFjY2Vzc0NvbnRyb2xsZXIgdHlwZSAnJHt0eXBlfScgaXMgbm90IHN1cHBvcnRlZGApXG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZFR5cGVzW3R5cGVdXG59XG5cbmNsYXNzIEFjY2Vzc0NvbnRyb2xsZXJzIHtcbiAgc3RhdGljIGlzU3VwcG9ydGVkICh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN1cHBvcnRlZFR5cGVzKS5pbmNsdWRlcyh0eXBlKVxuICB9XG5cbiAgc3RhdGljIGFkZEFjY2Vzc0NvbnRyb2xsZXIgKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuQWNjZXNzQ29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2Nlc3NDb250cm9sbGVyIGNsYXNzIG5lZWRzIHRvIGJlIGdpdmVuIGFzIGFuIG9wdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLkFjY2Vzc0NvbnRyb2xsZXIudHlwZSB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMuQWNjZXNzQ29udHJvbGxlci50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiBBY2Nlc3NDb250cm9sbGVyIGNsYXNzIG5lZWRzIHRvIGltcGxlbWVudDogc3RhdGljIGdldCB0eXBlKCkgeyAvKiByZXR1cm4gYSBzdHJpbmcgKi99LicpXG4gICAgfVxuXG4gICAgc3VwcG9ydGVkVHlwZXNbb3B0aW9ucy5BY2Nlc3NDb250cm9sbGVyLnR5cGVdID0gb3B0aW9ucy5BY2Nlc3NDb250cm9sbGVyXG4gIH1cblxuICBzdGF0aWMgYWRkQWNjZXNzQ29udHJvbGxlcnMgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2Nlc3NDb250cm9sbGVycyA9IG9wdGlvbnMuQWNjZXNzQ29udHJvbGxlcnNcbiAgICBpZiAoIWFjY2Vzc0NvbnRyb2xsZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY2Vzc0NvbnRyb2xsZXIgY2xhc3NlcyBuZWVkIHRvIGJlIGdpdmVuIGFzIGFuIG9wdGlvbicpXG4gICAgfVxuXG4gICAgYWNjZXNzQ29udHJvbGxlcnMuZm9yRWFjaCgoYWNjZXNzQ29udHJvbGxlcikgPT4ge1xuICAgICAgQWNjZXNzQ29udHJvbGxlcnMuYWRkQWNjZXNzQ29udHJvbGxlcih7IEFjY2Vzc0NvbnRyb2xsZXI6IGFjY2Vzc0NvbnRyb2xsZXIgfSlcbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIHJlbW92ZUFjY2Vzc0NvbnRyb2xsZXIgKHR5cGUpIHtcbiAgICBkZWxldGUgc3VwcG9ydGVkVHlwZXNbdHlwZV1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyByZXNvbHZlIChvcmJpdGRiLCBtYW5pZmVzdEFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgdHlwZSwgcGFyYW1zIH0gPSBhd2FpdCBBY2Nlc3NDb250cm9sbGVyTWFuaWZlc3QucmVzb2x2ZShvcmJpdGRiLl9pcGZzLCBtYW5pZmVzdEFkZHJlc3MsIG9wdGlvbnMpXG4gICAgY29uc3QgQWNjZXNzQ29udHJvbGxlciA9IGdldEhhbmRsZXJGb3IodHlwZSlcbiAgICBjb25zdCBhY2Nlc3NDb250cm9sbGVyID0gYXdhaXQgQWNjZXNzQ29udHJvbGxlci5jcmVhdGUob3JiaXRkYiwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgcGFyYW1zKSlcbiAgICBhd2FpdCBhY2Nlc3NDb250cm9sbGVyLmxvYWQocGFyYW1zLmFkZHJlc3MpXG4gICAgcmV0dXJuIGFjY2Vzc0NvbnRyb2xsZXJcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSBnZXRIYW5kbGVyRm9yKHR5cGUpXG4gICAgY29uc3QgYWMgPSBhd2FpdCBBY2Nlc3NDb250cm9sbGVyLmNyZWF0ZShvcmJpdGRiLCBvcHRpb25zKVxuICAgIGNvbnN0IHBhcmFtcyA9IGF3YWl0IGFjLnNhdmUoKVxuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBBY2Nlc3NDb250cm9sbGVyTWFuaWZlc3QuY3JlYXRlKG9yYml0ZGIuX2lwZnMsIHR5cGUsIHBhcmFtcylcbiAgICByZXR1cm4gaGFzaFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzQ29udHJvbGxlcnNcbiIsImNvbnN0IHR5cGUgPSAnbW9kZXJhdG9yLWFjY2VzcydcblxuY29uc3QgTU9ERVJBVE9SID0gJ01PREVSQVRPUidcbmNvbnN0IE1FTUJFUiA9ICdNRU1CRVInXG5cbmNsYXNzIE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoZmlyc3RNb2RlcmF0b3IsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jYXBhYmlsaXR5VHlwZXMgPSBbTU9ERVJBVE9SXVxuICAgIHRoaXMuX3dyaXRlID0gW10gICAgIC8vIEFsbG93ZWQgdG8gYWRkIG90aGVyIG1vZHMgb3IgbWVtYmVyc1xuICAgIHRoaXMuX2ZpcnN0TW9kZXJhdG9yID0gZmlyc3RNb2RlcmF0b3JcbiAgICB0aGlzLl93cml0ZS5wdXNoKHRoaXMuX2ZpcnN0TW9kZXJhdG9yKVxuICAgIHRoaXMuX21lbWJlcnMgPSBCb29sZWFuKG9wdGlvbnMubWVtYmVycylcbiAgICBpZiAodGhpcy5fbWVtYmVycykgdGhpcy5fY2FwYWJpbGl0eVR5cGVzLnB1c2goTUVNQkVSKVxuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHsgcmV0dXJuIHR5cGUgfVxuXG4gIGlzTW9kKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRlLmluY2x1ZGVzKGlkKVxuICB9XG5cbiAgaXNWYWxpZENhcGFiaWxpdHkgKGNhcGFiaWxpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eVR5cGVzLmluY2x1ZGVzKGNhcGFiaWxpdHkpXG4gIH1cblxuICBnZXQgZmlyc3RNb2RlcmF0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdE1vZGVyYXRvclxuICB9XG5cbiAgYXN5bmMgY2FuQXBwZW5kIChlbnRyeSwgaWRlbnRpdHlQcm92aWRlcikge1xuICAgIGNvbnN0IGVudHJ5SUQgPSBlbnRyeS5pZGVudGl0eS5pZFxuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBlbnRyeS5wYXlsb2FkLnZhbHVlLmNhcGFiaWxpdHlcbiAgICBjb25zdCBpZEFkZCA9IGVudHJ5LnBheWxvYWQudmFsdWUuaWRcbiAgICBjb25zdCBpc01vZCA9IHRoaXMuaXNNb2QoZW50cnlJRClcbiAgICBjb25zdCB2YWxpZENhcGFiaWxpdHkgPSB0aGlzLmlzVmFsaWRDYXBhYmlsaXR5KGNhcGFiaWxpdHkpXG4gICAgY29uc3QgdmFsaWRTaWcgPSBhc3luYyAoKSA9PiBpZGVudGl0eVByb3ZpZGVyLnZlcmlmeUlkZW50aXR5KGVudHJ5LmlkZW50aXR5KVxuICAgIGlmIChpc01vZCAmJiB2YWxpZENhcGFiaWxpdHkgJiYgKGF3YWl0IHZhbGlkU2lnKCkpKSB7XG4gICAgICBpZiAoY2FwYWJpbGl0eSA9PT0gTU9ERVJBVE9SKSB0aGlzLl93cml0ZS5wdXNoKGlkQWRkKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGFzeW5jIGxvYWQgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBhZGRMaXN0ID0gYWRkcmVzcy5zcGxpdCgnLycpXG4gICAgY29uc3Qgc3VmZml4ID0gYWRkTGlzdC5wb3AoKVxuICAgIHRoaXMuX21lbWJlcnMgPSBzdWZmaXggPT09ICdtZW1iZXJzJ1xuICAgIGNvbnN0IG1vZCA9IHN1ZmZpeC5pbmNsdWRlcygnbW9kJykgPyBzdWZmaXggOiBhZGRMaXN0LnBvcCgpXG4gICAgdGhpcy5fZmlyc3RNb2RlcmF0b3IgPSBtb2Quc3BsaXQoJ18nKVsxXVxuICB9XG5cbiAgYXN5bmMgc2F2ZSAoKSB7XG4gICAgLy8gVE9ETyBpZiBlbnRpcmUgb2JqIHNhdmVkIGluIG1hbmZlc3QsIGNhbiBqdXN0IHBhc3Mgb3VyIG93biBmaWVsZHNcbiAgICBsZXQgYWRkcmVzcyA9IGAke3R5cGV9L21vZF8ke3RoaXMuX2ZpcnN0TW9kZXJhdG9yfWBcbiAgICBhZGRyZXNzICs9IHRoaXMuX21lbWJlcnMgPyAnL21lbWJlcnMnIDogJydcbiAgICByZXR1cm4geyBhZGRyZXNzIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5maXJzdE1vZGVyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdNb2RlcmF0b3IgQUM6IGZpcnN0TW9kZXJhdG9yIHJlcXVpcmVkJylcbiAgICByZXR1cm4gbmV3IE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXIob3B0aW9ucy5maXJzdE1vZGVyYXRvciwgb3B0aW9ucylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXJcbiIsImNvbnN0IGlvID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbi8vY29uc3QgQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vYWNjZXNzLWNvbnRyb2xsZXItaW50ZXJmYWNlJylcbmNvbnN0IHJlc29sdmUgPSByZXF1aXJlKCdkaWQtcmVzb2x2ZXInKS5kZWZhdWx0XG5jb25zdCB0eXBlID0gJ2xlZ2FjeS1pcGZzLTNib3gnXG5cbmNvbnN0IHB1YmxpY0tleUZyb21ESUQgPSBhc3luYyBkaWQgPT4ge1xuICAvLyBUT0RPIC0gdGhpcyBzaG91bGQgbG9vayBhdCBhdXRoZW50aWNhdGlvbiBrZXlzIGFuZCBnZXQgcHVibGljS2V5IGZyb20gdGhhdFxuICBjb25zdCBkb2MgPSBhd2FpdCByZXNvbHZlKGRpZClcbiAgcmV0dXJuIGRvYy5wdWJsaWNLZXkuZmluZChlbnRyeSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbnRyeS5pZC5zcGxpdCgnIycpXG4gICAgcmV0dXJuIGlkWzBdID09PSBkb2MuaWQgJiZcbiAgICAgIChpZFsxXSA9PT0gJ3N1YlNpZ25pbmdLZXknIHx8IGlkWzFdID09PSAnc2lnbmluZ0tleScpXG4gIH0pLnB1YmxpY0tleUhleFxufVxuXG5jbGFzcyBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgb3B0aW9ucykge1xuICAgIC8vc3VwZXIoKVxuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5fd3JpdGUgPSBBcnJheS5mcm9tKG9wdGlvbnMud3JpdGUgfHwgW10pXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBhY2Nlc3MgY29udHJvbGxlclxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgLy8gUmV0dXJuIGEgU2V0IG9mIGtleXMgdGhhdCBoYXZlIGBhY2Nlc3NgIGNhcGFiaWxpdHlcbiAgZ2V0IHdyaXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGVcbiAgfVxuXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICAvLyBBbGxvdyBpZiBhY2Nlc3MgbGlzdCBjb250YWluIHRoZSB3cml0ZXIncyBwdWJsaWNLZXkgb3IgaXMgJyonXG4gICAgY29uc3QgcHVibGljS2V5ID0gZW50cnkudiA9PT0gMCA/IGVudHJ5LmtleSA6IGF3YWl0IHB1YmxpY0tleUZyb21ESUQoZW50cnkuaWRlbnRpdHkuaWQpXG4gICAgaWYgKHRoaXMud3JpdGUuaW5jbHVkZXMocHVibGljS2V5KSB8fFxuICAgICAgdGhpcy53cml0ZS5pbmNsdWRlcygnKicpKSB7XG4gICAgICByZXR1cm4gZW50cnkudiA9PT0gMCA/IHRydWUgOiBhd2FpdCBpZGVudGl0eVByb3ZpZGVyLnZlcmlmeUlkZW50aXR5KGVudHJ5LmlkZW50aXR5KVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGFzeW5jIGxvYWQgKGFkZHJlc3MpIHtcbiAgICAvLyBUcmFuc2Zvcm0gJy9pcGZzL1FtUEZ0SGkzY21mWmVyeHRIOXlTTGR6cGcxeUZob2NZRFpnRVp5d2RVWEh4RlUnXG4gICAgLy8gdG8gJ1FtUEZ0SGkzY21mWmVyeHRIOXlTTGR6cGcxeUZob2NZRFpnRVp5d2RVWEh4RlUnXG4gICAgaWYgKGFkZHJlc3MuaW5kZXhPZignL2lwZnMnKSA9PT0gMCkgeyBhZGRyZXNzID0gYWRkcmVzcy5zcGxpdCgnLycpWzJdIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY2Nlc3MgPSBhd2FpdCBpby5yZWFkKHRoaXMuX2lwZnMsIGFkZHJlc3MpXG4gICAgICB0aGlzLl93cml0ZSA9IGFjY2Vzcy53cml0ZVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIubG9hZCBFUlJPUjonLCBlKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNhdmUgKG9wdGlvbnMpIHtcbiAgICBsZXQgY2lkXG4gICAgY29uc3QgYWNjZXNzID0geyBhZG1pbjogW10sIHdyaXRlOiB0aGlzLndyaXRlLCByZWFkOiBbXSB9XG4gICAgdHJ5IHtcbiAgICAgIGNpZCA9IGF3YWl0IGlvLndyaXRlKHRoaXMuX2lwZnMsICdyYXcnLCBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShhY2Nlc3MsIG51bGwsIDIpKSwgeyBmb3JtYXQ6ICdkYWctcGInfSlcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIuc2F2ZSBFUlJPUjonLCBlKVxuICAgIH1cbiAgICAvLyByZXR1cm4gdGhlIG1hbmlmZXN0IGRhdGFcbiAgICByZXR1cm4geyBhZGRyZXNzOiBjaWQsIHNraXBNYW5pZmVzdDogdHJ1ZSB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChvcmJpdGRiLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi57IHdyaXRlOiBvcHRpb25zLndyaXRlIHx8IFtvcmJpdGRiLmlkZW50aXR5LnB1YmxpY0tleV0gfSB9XG4gICAgcmV0dXJuIG5ldyBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIob3JiaXRkYi5faXBmcywgb3B0aW9ucylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2FjeUlQRlMzQm94QWNjZXNzQ29udHJvbGxlclxuIiwiY29uc3QgZW5zdXJlQWRkcmVzcyA9IHJlcXVpcmUoJ29yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVycy9zcmMvdXRpbHMvZW5zdXJlLWFjLWFkZHJlc3MnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBlbnRyeUlQRlMgPSByZXF1aXJlKCdpcGZzLWxvZy9zcmMvZW50cnknKVxuY29uc3QgaXNJUEZTID0gcmVxdWlyZSgnaXMtaXBmcycpXG5cbmNvbnN0IHR5cGUgPSAndGhyZWFkLWFjY2VzcydcbmNvbnN0IE1PREVSQVRPUiA9ICdNT0RFUkFUT1InXG5jb25zdCBNRU1CRVIgPSAnTUVNQkVSJ1xuXG5jb25zdCBpc1ZhbGlkM0lEID0gZGlkID0+IHtcbiAgY29uc3QgcGFydHMgPSBkaWQuc3BsaXQoJzonKVxuICBpZiAoIXBhcnRzWzBdID09PSAnZGlkJyB8fCAhcGFydHNbMV0gPT09ICczJykgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBpc0lQRlMuY2lkKHBhcnRzWzJdKVxufVxuXG5jbGFzcyBUaHJlYWRBY2Nlc3NDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVye1xuICBjb25zdHJ1Y3RvciAob3JiaXRkYiwgaXBmcywgaWRlbnRpdHksIGZpcnN0TW9kZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29yYml0ZGIgPSBvcmJpdGRiXG4gICAgdGhpcy5fZGIgPSBudWxsXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuX21lbWJlcnMgPSBCb29sZWFuKG9wdGlvbnMubWVtYmVycylcbiAgICB0aGlzLl9maXJzdE1vZGVyYXRvciA9IGZpcnN0TW9kZXJhdG9yXG4gICAgdGhpcy5fdGhyZWFkTmFtZSA9IG9wdGlvbnMudGhyZWFkTmFtZVxuICAgIHRoaXMuX2lkZW50aXR5ID0gaWRlbnRpdHlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7IHJldHVybiB0eXBlIH1cblxuICAvLyByZXR1cm4gYWRkcmVzIG9mIEFDIChpbiB0aGlzIGNhc2Ugb3JiaXRkYiBhZGRyZXNzIG9mIEFDKVxuICBnZXQgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLmFkZHJlc3NcbiAgfVxuXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICBjb25zdCB0cnVlSWZWYWxpZFNpZyA9IGFzeW5jICgpID0+IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIudmVyaWZ5SWRlbnRpdHkoZW50cnkuaWRlbnRpdHkpXG5cbiAgICBjb25zdCBvcCA9IGVudHJ5LnBheWxvYWQub3BcbiAgICBjb25zdCBtb2RzID0gdGhpcy5jYXBhYmlsaXRpZXNbJ21vZGVyYXRvcnMnXVxuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLmNhcGFiaWxpdGllc1snbWVtYmVycyddXG4gICAgY29uc3QgaXNNb2QgPSBtb2RzLmluY2x1ZGVzKGVudHJ5LmlkZW50aXR5LmlkKVxuICAgIGNvbnN0IGlzTWVtYmVyID0gbWVtYmVycy5pbmNsdWRlcyhlbnRyeS5pZGVudGl0eS5pZClcblxuICAgIGlmIChvcCA9PT0gJ0FERCcpIHtcbiAgICAgIC8vIEFueW9uZSBjYW4gYWRkIGVudHJ5IGlmIG9wZW4gdGhyZWFkXG4gICAgICBpZiAoIXRoaXMuX21lbWJlcnMpIHJldHVybiBhd2FpdCB0cnVlSWZWYWxpZFNpZygpXG4gICAgICAvLyBOb3Qgb3BlbiB0aHJlYWQsIGFueSBtZW1iZXIgb3IgbW9kIGNhbiBhZGQgdG8gdGhyZWFkXG4gICAgICBpZiAoaXNNZW1iZXIgfHwgaXNNb2QpIHJldHVybiBhd2FpdCB0cnVlSWZWYWxpZFNpZygpXG4gICAgfVxuXG4gICAgaWYgKG9wID09PSAnREVMJykge1xuICAgICAgY29uc3QgaGFzaCA9IGVudHJ5LnBheWxvYWQudmFsdWVcbiAgICAgIGNvbnN0IGRlbEVudHJ5ID0gYXdhaXQgZW50cnlJUEZTLmZyb21NdWx0aWhhc2godGhpcy5faXBmcywgaGFzaClcblxuICAgICAgLy8gQW4gaWQgY2FuIGRlbGV0ZSB0aGVpciBvd24gZW50cmllc1xuICAgICAgaWYgKGRlbEVudHJ5LmlkZW50aXR5LmlkID09PSBlbnRyeS5pZGVudGl0eS5pZCkgcmV0dXJuIGF3YWl0IHRydWVJZlZhbGlkU2lnKClcblxuICAgICAgLy8gTW9kcyBjYW4gZGVsZXRlIGFueSBlbnRyeVxuICAgICAgaWYgKGlzTW9kKSByZXR1cm4gYXdhaXQgdHJ1ZUlmVmFsaWRTaWcoKVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IGNhcGFiaWxpdGllcyAoKSB7XG4gICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMpIHRoaXMuX3VwZGF0ZUNhcGFiaWxpdGVzKClcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0aWVzXG4gIH1cblxuICBfdXBkYXRlQ2FwYWJpbGl0ZXMgKCkge1xuICAgIGxldCBtb2RlcmF0b3JzID0gW10sIG1lbWJlcnMgPSBbXVxuICAgIGlmICh0aGlzLl9kYikge1xuICAgICAgbW9kZXJhdG9ycy5wdXNoKHRoaXMuX2RiLmFjY2Vzcy5fZmlyc3RNb2RlcmF0b3IpXG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLl9kYi5pbmRleCkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBlbnRyeVsxXS5wYXlsb2FkLnZhbHVlLmNhcGFiaWxpdHlcbiAgICAgICAgY29uc3QgaWQgPSBlbnRyeVsxXS5wYXlsb2FkLnZhbHVlLmlkXG4gICAgICAgIGlmIChjYXBhYmlsaXR5ID09PSBNT0RFUkFUT1IpIG1vZGVyYXRvcnMucHVzaChpZClcbiAgICAgICAgaWYgKGNhcGFiaWxpdHkgPT09IE1FTUJFUikgbWVtYmVycy5wdXNoKGlkKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5fY2FwYWJpbGl0aWVzID0ge21vZGVyYXRvcnMsIG1lbWJlcnN9XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdGllc1xuICB9XG5cbiAgZ2V0IChjYXBhYmlsaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzW2NhcGFiaWxpdHldIHx8IFtdXG4gIH1cblxuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgYXdhaXQgdGhpcy5fZGIuY2xvc2UoKVxuICB9XG5cbiAgYXN5bmMgbG9hZCAoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLl9kYikgeyBhd2FpdCB0aGlzLl9kYi5jbG9zZSgpIH1cblxuICAgIC8vIFRPRE8gLSBza2lwIG1hbmlmZXN0IGZvciBtb2QtYWNjZXNzXG4gICAgdGhpcy5fZGIgPSBhd2FpdCB0aGlzLl9vcmJpdGRiLmZlZWQoZW5zdXJlQWRkcmVzcyhhZGRyZXNzKSwge1xuICAgICAgaWRlbnRpdHk6IHRoaXMuX2lkZW50aXR5LFxuICAgICAgYWNjZXNzQ29udHJvbGxlcjoge1xuICAgICAgICB0eXBlOiAnbW9kZXJhdG9yLWFjY2VzcycsXG4gICAgICAgIGZpcnN0TW9kZXJhdG9yOiB0aGlzLl9maXJzdE1vZGVyYXRvcixcbiAgICAgICAgbWVtYmVyczogdGhpcy5fbWVtYmVyc1xuICAgICAgfSxcbiAgICAgIHN5bmM6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZWFkeScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCd3cml0ZScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSlcblxuICAgIGF3YWl0IHRoaXMuX2RiLmxvYWQoKVxuICB9XG5cbiAgYXN5bmMgc2F2ZSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IHRoaXMuX2RiLmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgIGZpcnN0TW9kZXJhdG9yOiB0aGlzLl9maXJzdE1vZGVyYXRvcixcbiAgICAgIG1lbWJlcnM6IHRoaXMuX21lbWJlcnNcbiAgICB9XG4gIH1cblxuICBhc3luYyBncmFudCAoY2FwYWJpbGl0eSwgaWQpIHtcbiAgICBpZiAoIXRoaXMuX2RiLmFjY2Vzcy5pc1ZhbGlkQ2FwYWJpbGl0eShjYXBhYmlsaXR5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmFudDogSW52YWxpZCBjYXBhYmlsaXR5IHRvIGdyYW50JylcbiAgICB9XG4gICAgaWYgKGNhcGFiaWxpdHkgPT09IE1FTUJFUiAmJiB0aGlzLmNhcGFiaWxpdGllc1snbWVtYmVycyddLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyYW50OiBjYXBhYmlsaXR5ICR7Y2FwYWJpbGl0eX0gaGFzIGFscmVhZHkgYmVlbiBncmFudGVkIHRvICR7aWR9YClcbiAgICB9XG4gICAgaWYgKGNhcGFiaWxpdHkgPT09IE1PREVSQVRPUiAmJiB0aGlzLmNhcGFiaWxpdGllc1snbW9kZXJhdG9ycyddLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyYW50OiBjYXBhYmlsaXR5ICR7Y2FwYWJpbGl0eX0gaGFzIGFscmVhZHkgYmVlbiBncmFudGVkIHRvICR7aWR9YClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2RiLmFkZCh7Y2FwYWJpbGl0eSwgaWR9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ25vdCBhcHBlbmQgZW50cnknKSkgdGhyb3cgbmV3IEVycm9yKGBncmFudDogQ2FwYWJpbGl0eSAke2NhcGFiaWxpdHl9IGNhbiBub3QgYmUgZ3JhbnRlZCB0byAke2lkfWApXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgX29uVXBkYXRlICgpIHtcbiAgICB0aGlzLl91cGRhdGVDYXBhYmlsaXRlcygpXG4gICAgdGhpcy5lbWl0KCd1cGRhdGVkJylcbiAgfVxuXG4gIC8qIEZhY3RvcnkgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSAob3JiaXRkYiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFvcHRpb25zLmZpcnN0TW9kZXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ1RocmVhZCBBQzogZmlyc3RNb2RlcmF0b3IgcmVxdWlyZWQnKVxuICAgIGNvbnN0IGFjID0gbmV3IFRocmVhZEFjY2Vzc0NvbnRyb2xsZXIob3JiaXRkYiwgb3JiaXRkYi5faXBmcywgb3B0aW9ucy5pZGVudGl0eSwgb3B0aW9ucy5maXJzdE1vZGVyYXRvciwgb3B0aW9ucylcbiAgICBhd2FpdCBhYy5sb2FkKG9wdGlvbnMuYWRkcmVzcyB8fCBvcHRpb25zLnRocmVhZE5hbWUpXG4gICAgcmV0dXJuIGFjXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWRBY2Nlc3NDb250cm9sbGVyXG4iLCJjb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKCdiYXNlNjR1cmwnKVxuY29uc3QgeyB2ZXJpZnlKV1QgfSA9IHJlcXVpcmUoJ2RpZC1qd3QnKVxuXG5jb25zdCBlbmNvZGVTZWN0aW9uID0gZGF0YSA9PiBiYXNlNjR1cmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuXG5jb25zdCBUWVBFID0gJzNJRCdcbmNvbnN0IEpXVF9IRUFERVIgPSBlbmNvZGVTZWN0aW9uKHsgdHlwOiAnSldUJywgYWxnOiAnRVMyNTZLJyB9KVxuXG5cbmNsYXNzIE9kYklkZW50aXR5UHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAoeyB0aHJlZUlkIH0pIHtcbiAgICAvLyBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMudGhyZWVJZCA9IHRocmVlSWRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICczSUQnXG4gIH1cblxuICBhc3luYyBnZXRJZCAoeyBzcGFjZSB9KSB7XG4gICAgaWYgKHNwYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aHJlZUlkLmdldFN1YkRJRChzcGFjZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGhyZWVJZC5ESURcbiAgICB9XG4gIH1cblxuICBhc3luYyBzaWduSWRlbnRpdHkgKGRhdGEsIHsgc3BhY2UgfSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBkYXRhLFxuICAgICAgaWF0OiBudWxsXG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSAhc3BhY2UgPyB7IHVzZTNJRDogdHJ1ZSB9IDogeyBzcGFjZSB9XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLnRocmVlSWQuc2lnbkpXVChwYXlsb2FkLCBvcHRzKSkuc3BsaXQoJy4nKVsyXVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHZlcmlmeUlkZW50aXR5IChpZGVudGl0eSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSBlbmNvZGVTZWN0aW9uKHtcbiAgICAgIGlhdDogbnVsbCxcbiAgICAgIGRhdGE6IGlkZW50aXR5LnB1YmxpY0tleSArIGlkZW50aXR5LnNpZ25hdHVyZXMuaWQsXG4gICAgICBpc3M6IGlkZW50aXR5LmlkXG4gICAgfSlcbiAgICBjb25zdCBqd3QgPSBgJHtKV1RfSEVBREVSfS4ke3BheWxvYWR9LiR7aWRlbnRpdHkuc2lnbmF0dXJlcy5wdWJsaWNLZXl9YFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB2ZXJpZnlKV1Qoand0LCB7IGF1dGg6IHRydWUgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPZGJJZGVudGl0eVByb3ZpZGVyXG4iLCJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBpbyA9IHJlcXVpcmUoJ29yYml0LWRiLWlvJylcblxuLy8gQ3JlYXRlcyBhIERCIG1hbmlmZXN0IGZpbGUgYW5kIHNhdmVzIGl0IGluIElQRlNcbmNvbnN0IGNyZWF0ZURCTWFuaWZlc3QgPSBhc3luYyAoaXBmcywgbmFtZSwgdHlwZSwgYWNjZXNzQ29udHJvbGxlckFkZHJlc3MsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWFuaWZlc3QgPSB7XG4gICAgbmFtZTogbmFtZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGFjY2Vzc0NvbnRyb2xsZXI6IHBhdGguam9pbignL2lwZnMnLCBhY2Nlc3NDb250cm9sbGVyQWRkcmVzcyksXG4gIH1cblxuICByZXR1cm4gaW8ud3JpdGUoaXBmcywgb3B0aW9ucy5mb3JtYXQgfHwgJ2RhZy1jYm9yJywgbWFuaWZlc3QsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlREJNYW5pZmVzdFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5sZXQgaXNFbGVjdHJvblJlbmRlcmVyID0gcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJztcbmxldCBpc05vZGVqcyA9ICFpc0VsZWN0cm9uUmVuZGVyZXIgJiYgcHJvY2Vzcy52ZXJzaW9uID8gdHJ1ZSA6IGZhbHNlO1xuXG5jb25zdCBMb2dMZXZlbHMgPSB7XG4gICdERUJVRyc6ICdERUJVRycsXG4gICdJTkZPJzogICdJTkZPJyxcbiAgJ1dBUk4nOiAgJ1dBUk4nLFxuICAnRVJST1InOiAnRVJST1InLFxuICAnTk9ORSc6ICAnTk9ORScsXG59O1xuXG4vLyBHbG9iYWwgbG9nIGxldmVsXG5sZXQgR2xvYmFsTG9nTGV2ZWwgPSBMb2dMZXZlbHMuREVCVUc7XG5cbi8vIEdsb2JhbCBsb2cgZmlsZSBuYW1lXG5sZXQgR2xvYmFsTG9nZmlsZSA9IG51bGw7XG5cbmxldCBHbG9iYWxFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbi8vIEFOU0kgY29sb3JzXG5sZXQgQ29sb3JzID0ge1xuICAnQmxhY2snOiAgIDAsXG4gICdSZWQnOiAgICAgMSxcbiAgJ0dyZWVuJzogICAyLFxuICAnWWVsbG93JzogIDMsXG4gICdCbHVlJzogICAgNCxcbiAgJ01hZ2VudGEnOiA1LFxuICAnQ3lhbic6ICAgIDYsXG4gICdHcmV5JzogICAgNyxcbiAgJ1doaXRlJzogICA5LFxuICAnRGVmYXVsdCc6IDksXG59O1xuXG4vLyBDU1MgY29sb3JzXG5pZighaXNOb2RlanMpIHtcbiAgQ29sb3JzID0ge1xuICAgICdCbGFjayc6ICAgJ0JsYWNrJyxcbiAgICAnUmVkJzogICAgICdJbmRpYW5SZWQnLFxuICAgICdHcmVlbic6ICAgJ0xpbWVHcmVlbicsXG4gICAgJ1llbGxvdyc6ICAnT3JhbmdlJyxcbiAgICAnQmx1ZSc6ICAgICdSb3lhbEJsdWUnLFxuICAgICdNYWdlbnRhJzogJ09yY2hpZCcsXG4gICAgJ0N5YW4nOiAgICAnU2t5Qmx1ZScsXG4gICAgJ0dyZXknOiAgICAnRGltR3JleScsXG4gICAgJ1doaXRlJzogICAnV2hpdGUnLFxuICAgICdEZWZhdWx0JzogJ0JsYWNrJyxcbiAgfTtcbn1cblxuY29uc3QgbG9nbGV2ZWxDb2xvcnMgPSBbQ29sb3JzLkN5YW4sIENvbG9ycy5HcmVlbiwgQ29sb3JzLlllbGxvdywgQ29sb3JzLlJlZCwgQ29sb3JzLkRlZmF1bHRdO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgdXNlQ29sb3JzOiB0cnVlLFxuICBjb2xvcjogQ29sb3JzLkRlZmF1bHQsXG4gIHNob3dUaW1lc3RhbXA6IHRydWUsXG4gIHVzZUxvY2FsVGltZTogZmFsc2UsXG4gIHNob3dMZXZlbDogdHJ1ZSxcbiAgZmlsZW5hbWU6IEdsb2JhbExvZ2ZpbGUsXG4gIGFwcGVuZEZpbGU6IHRydWUsXG59O1xuXG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihjYXRlZ29yeSwgb3B0aW9ucykge1xuICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICBsZXQgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZGVmYXVsdE9wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgICB0aGlzLmRlYnVnID0gdGhpcy5kZWJ1Zy5iaW5kKHRoaXMpO1xuICAgIHRoaXMubG9nID0gdGhpcy5sb2cuYmluZCh0aGlzKTtcbiAgICB0aGlzLmluZm8gPSB0aGlzLmluZm8uYmluZCh0aGlzKTtcbiAgICB0aGlzLndhcm4gPSB0aGlzLndhcm4uYmluZCh0aGlzKTtcbiAgICB0aGlzLmVycm9yID0gdGhpcy5lcnJvci5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVidWcoKSB7XG4gICAgaWYodGhpcy5fc2hvdWxkTG9nKExvZ0xldmVscy5ERUJVRykpXG4gICAgICB0aGlzLl93cml0ZShMb2dMZXZlbHMuREVCVUcsIGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIGxvZygpIHtcbiAgICBpZih0aGlzLl9zaG91bGRMb2coTG9nTGV2ZWxzLkRFQlVHKSlcbiAgICAgIHRoaXMuZGVidWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGluZm8oKSB7XG4gICAgaWYodGhpcy5fc2hvdWxkTG9nKExvZ0xldmVscy5JTkZPKSlcbiAgICAgIHRoaXMuX3dyaXRlKExvZ0xldmVscy5JTkZPLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH1cblxuICB3YXJuKCkge1xuICAgIGlmKHRoaXMuX3Nob3VsZExvZyhMb2dMZXZlbHMuV0FSTikpXG4gICAgICB0aGlzLl93cml0ZShMb2dMZXZlbHMuV0FSTiwgZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgZXJyb3IoKSB7XG4gICAgaWYodGhpcy5fc2hvdWxkTG9nKExvZ0xldmVscy5FUlJPUikpXG4gICAgICB0aGlzLl93cml0ZShMb2dMZXZlbHMuRVJST1IsIGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF93cml0ZShsZXZlbCwgdGV4dCkge1xuICAgIGlmKCh0aGlzLm9wdGlvbnMuZmlsZW5hbWUgfHwgR2xvYmFsTG9nZmlsZSkgJiYgIXRoaXMuZmlsZVdyaXRlciAmJiBpc05vZGVqcylcbiAgICAgIHRoaXMuZmlsZVdyaXRlciA9IGZzLm9wZW5TeW5jKHRoaXMub3B0aW9ucy5maWxlbmFtZSB8fCBHbG9iYWxMb2dmaWxlLCB0aGlzLm9wdGlvbnMuYXBwZW5kRmlsZSA/ICdhKycgOiAndysnKTtcblxuICAgIGxldCBmb3JtYXQgPSB0aGlzLl9mb3JtYXQobGV2ZWwsIHRleHQpO1xuICAgIGxldCB1bmZvcm1hdHRlZFRleHQgPSB0aGlzLl9jcmVhdGVMb2dNZXNzYWdlKGxldmVsLCB0ZXh0KTtcbiAgICBsZXQgZm9ybWF0dGVkVGV4dCA9IHRoaXMuX2NyZWF0ZUxvZ01lc3NhZ2UobGV2ZWwsIHRleHQsIGZvcm1hdC50aW1lc3RhbXAsIGZvcm1hdC5sZXZlbCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dCk7XG5cbiAgICBpZih0aGlzLmZpbGVXcml0ZXIgJiYgaXNOb2RlanMpXG4gICAgICBmcy53cml0ZVN5bmModGhpcy5maWxlV3JpdGVyLCB1bmZvcm1hdHRlZFRleHQgKyAnXFxuJywgbnVsbCwgJ3V0Zi04Jyk7XG5cbiAgICBpZihpc05vZGVqcyB8fCAhdGhpcy5vcHRpb25zLnVzZUNvbG9ycykge1xuICAgICAgY29uc29sZS5sb2coZm9ybWF0dGVkVGV4dClcbiAgICAgIEdsb2JhbEV2ZW50cy5lbWl0KCdkYXRhJywgdGhpcy5jYXRlZ29yeSwgbGV2ZWwsIHRleHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGNsZWFuIHRoaXMgdXBcbiAgICAgIGlmKGxldmVsID09PSBMb2dMZXZlbHMuRVJST1IpIHtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgdGhpcy5vcHRpb25zLnNob3dMZXZlbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkVGV4dCwgZm9ybWF0LnRpbWVzdGFtcCwgZm9ybWF0LmxldmVsLCBmb3JtYXQuY2F0ZWdvcnksIGZvcm1hdC50ZXh0KVxuICAgICAgICB9IGVsc2UgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgIXRoaXMub3B0aW9ucy5zaG93TGV2ZWwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZFRleHQsIGZvcm1hdC50aW1lc3RhbXAsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpXG4gICAgICAgIH0gZWxzZSBpZighdGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgdGhpcy5vcHRpb25zLnNob3dMZXZlbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkVGV4dCwgZm9ybWF0LmxldmVsLCBmb3JtYXQuY2F0ZWdvcnksIGZvcm1hdC50ZXh0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkVGV4dCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgdGhpcy5vcHRpb25zLnNob3dMZXZlbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZFRleHQsIGZvcm1hdC50aW1lc3RhbXAsIGZvcm1hdC5sZXZlbCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5zaG93VGltZXN0YW1wICYmICF0aGlzLm9wdGlvbnMuc2hvd0xldmVsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZm9ybWF0dGVkVGV4dCwgZm9ybWF0LnRpbWVzdGFtcCwgZm9ybWF0LmNhdGVnb3J5LCBmb3JtYXQudGV4dClcbiAgICAgICAgfSBlbHNlIGlmKCF0aGlzLm9wdGlvbnMuc2hvd1RpbWVzdGFtcCAmJiB0aGlzLm9wdGlvbnMuc2hvd0xldmVsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZm9ybWF0dGVkVGV4dCwgZm9ybWF0LmxldmVsLCBmb3JtYXQuY2F0ZWdvcnksIGZvcm1hdC50ZXh0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdHRlZFRleHQsIGZvcm1hdC5jYXRlZ29yeSwgZm9ybWF0LnRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZm9ybWF0KGxldmVsLCB0ZXh0KSB7XG4gICAgbGV0IHRpbWVzdGFtcEZvcm1hdCA9ICcnO1xuICAgIGxldCBsZXZlbEZvcm1hdCAgICAgPSAnJztcbiAgICBsZXQgY2F0ZWdvcnlGb3JtYXQgID0gJyc7XG4gICAgbGV0IHRleHRGb3JtYXQgICAgICA9ICc6ICc7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMudXNlQ29sb3JzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsQ29sb3IgICAgPSBPYmplY3Qua2V5cyhMb2dMZXZlbHMpLm1hcCgoZikgPT4gTG9nTGV2ZWxzW2ZdKS5pbmRleE9mKGxldmVsKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvcjtcblxuICAgICAgaWYoaXNOb2RlanMpIHtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXApXG4gICAgICAgICAgdGltZXN0YW1wRm9ybWF0ID0gJ1xcdTAwMWJbMycgKyBDb2xvcnMuR3JleSArICdtJztcblxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd0xldmVsKVxuICAgICAgICAgIGxldmVsRm9ybWF0ID0gJ1xcdTAwMWJbMycgKyBsb2dsZXZlbENvbG9yc1tsZXZlbENvbG9yXSArICc7MjJtJztcblxuICAgICAgICBjYXRlZ29yeUZvcm1hdCA9ICdcXHUwMDFiWzMnICsgY2F0ZWdvcnlDb2xvciArICc7MW0nO1xuICAgICAgICB0ZXh0Rm9ybWF0ID0gJ1xcdTAwMWJbMG06ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMuc2hvd1RpbWVzdGFtcClcbiAgICAgICAgICB0aW1lc3RhbXBGb3JtYXQgPSAnY29sb3I6JyArIENvbG9ycy5HcmV5O1xuXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpXG4gICAgICAgICAgbGV2ZWxGb3JtYXQgPSAnY29sb3I6JyArIGxvZ2xldmVsQ29sb3JzW2xldmVsQ29sb3JdO1xuXG4gICAgICAgIGNhdGVnb3J5Rm9ybWF0ID0gJ2NvbG9yOicgKyBjYXRlZ29yeUNvbG9yICsgJzsgZm9udC13ZWlnaHQ6IGJvbGQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcEZvcm1hdCxcbiAgICAgIGxldmVsOiBsZXZlbEZvcm1hdCxcbiAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeUZvcm1hdCxcbiAgICAgIHRleHQ6IHRleHRGb3JtYXRcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUxvZ01lc3NhZ2UobGV2ZWwsIHRleHQsIHRpbWVzdGFtcEZvcm1hdCwgbGV2ZWxGb3JtYXQsIGNhdGVnb3J5Rm9ybWF0LCB0ZXh0Rm9ybWF0KSB7XG4gICAgdGltZXN0YW1wRm9ybWF0ID0gdGltZXN0YW1wRm9ybWF0IHx8ICcnO1xuICAgIGxldmVsRm9ybWF0ICAgICA9IGxldmVsRm9ybWF0ICAgICB8fCAnJztcbiAgICBjYXRlZ29yeUZvcm1hdCAgPSBjYXRlZ29yeUZvcm1hdCAgfHwgJyc7XG4gICAgdGV4dEZvcm1hdCAgICAgID0gdGV4dEZvcm1hdCAgICAgIHx8ICc6ICc7XG5cbiAgICBpZighaXNOb2RlanMgJiYgdGhpcy5vcHRpb25zLnVzZUNvbG9ycykge1xuICAgICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXApXG4gICAgICAgIHRpbWVzdGFtcEZvcm1hdCA9ICclYyc7XG5cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93TGV2ZWwpXG4gICAgICAgIGxldmVsRm9ybWF0ID0gJyVjJztcblxuICAgICAgY2F0ZWdvcnlGb3JtYXQgID0gJyVjJztcbiAgICAgIHRleHRGb3JtYXQgPSAnOiAlYyc7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgaWYodGhpcy5vcHRpb25zLnNob3dUaW1lc3RhbXAgJiYgIXRoaXMub3B0aW9ucy51c2VMb2NhbFRpbWUpXG4gICAgICByZXN1bHQgKz0gJycgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG5cbiAgICBpZih0aGlzLm9wdGlvbnMuc2hvd1RpbWVzdGFtcCAmJiB0aGlzLm9wdGlvbnMudXNlTG9jYWxUaW1lKVxuICAgICAgcmVzdWx0ICs9ICcnICsgbmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpICsgJyAnO1xuXG4gICAgcmVzdWx0ID0gdGltZXN0YW1wRm9ybWF0ICsgcmVzdWx0O1xuXG4gICAgaWYodGhpcy5vcHRpb25zLnNob3dMZXZlbClcbiAgICAgIHJlc3VsdCArPSBsZXZlbEZvcm1hdCArICdbJyArIGxldmVsICsnXScgKyAobGV2ZWwgPT09IExvZ0xldmVscy5JTkZPIHx8IGxldmVsID09PSBMb2dMZXZlbHMuV0FSTiA/ICcgJyA6ICcnKSArICcgJztcblxuICAgIHJlc3VsdCArPSBjYXRlZ29yeUZvcm1hdCArIHRoaXMuY2F0ZWdvcnk7XG4gICAgcmVzdWx0ICs9IHRleHRGb3JtYXQgKyB0ZXh0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfc2hvdWxkTG9nKGxldmVsKSB7XG4gICAgbGV0IGVudkxvZ0xldmVsID0gKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5lbnYuTE9HICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTE9HLnRvVXBwZXJDYXNlKCkgOiBudWxsO1xuICAgIGVudkxvZ0xldmVsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkxPRykgPyB3aW5kb3cuTE9HLnRvVXBwZXJDYXNlKCkgOiBlbnZMb2dMZXZlbDtcblxuICAgIGNvbnN0IGxvZ0xldmVsID0gZW52TG9nTGV2ZWwgfHwgR2xvYmFsTG9nTGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxzICAgPSBPYmplY3Qua2V5cyhMb2dMZXZlbHMpLm1hcCgoZikgPT4gTG9nTGV2ZWxzW2ZdKTtcbiAgICBjb25zdCBpbmRleCAgICA9IGxldmVscy5pbmRleE9mKGxldmVsKTtcbiAgICBjb25zdCBsZXZlbElkeCA9IGxldmVscy5pbmRleE9mKGxvZ0xldmVsKTtcbiAgICByZXR1cm4gaW5kZXggPj0gbGV2ZWxJZHg7XG4gIH1cbn07XG5cbi8qIFB1YmxpYyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb2xvcnM6IENvbG9ycyxcbiAgTG9nTGV2ZWxzOiBMb2dMZXZlbHMsXG4gIHNldExvZ0xldmVsOiAobGV2ZWwpID0+IHtcbiAgICBHbG9iYWxMb2dMZXZlbCA9IGxldmVsO1xuICB9LFxuICBzZXRMb2dmaWxlOiAoZmlsZW5hbWUpID0+IHtcbiAgICBHbG9iYWxMb2dmaWxlID0gZmlsZW5hbWU7XG4gIH0sXG4gIGNyZWF0ZTogKGNhdGVnb3J5LCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcihjYXRlZ29yeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGxvZ2dlcjtcbiAgfSxcbiAgZm9yY2VCcm93c2VyTW9kZTogKGZvcmNlKSA9PiBpc05vZGVqcyA9ICFmb3JjZSwgLy8gZm9yIHRlc3RpbmcsXG4gIGV2ZW50czogR2xvYmFsRXZlbnRzLFxufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItZXZlbnRzdG9yZScpXG5jb25zdCBGZWVkSW5kZXggID0gcmVxdWlyZSgnLi9GZWVkSW5kZXgnKVxuXG5jbGFzcyBGZWVkU3RvcmUgZXh0ZW5kcyBFdmVudFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKGlwZnMsIGlkLCBkYm5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9XG4gICAgaWYoIW9wdGlvbnMuSW5kZXgpIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBJbmRleDogRmVlZEluZGV4IH0pXG4gICAgc3VwZXIoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucylcbiAgICB0aGlzLl90eXBlID0gJ2ZlZWQnXG4gIH1cblxuICByZW1vdmUgKGhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5kZWwoaGFzaClcbiAgfVxuXG4gIGRlbCAoaGFzaCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIG9wOiAnREVMJyxcbiAgICAgIGtleTogbnVsbCxcbiAgICAgIHZhbHVlOiBoYXNoXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRPcGVyYXRpb24ob3BlcmF0aW9uKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmVlZFN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1zdG9yZScpXG5jb25zdCBFdmVudEluZGV4ID0gcmVxdWlyZSgnLi9FdmVudEluZGV4JylcblxuLy8gVE9ETzogZ2VuZXJhbGl6ZSB0aGUgSXRlcmF0b3IgZnVuY3Rpb25zIGFuZCBzcGluIHRvIGl0cyBvd24gbW9kdWxlXG5cbmNsYXNzIEV2ZW50U3RvcmUgZXh0ZW5kcyBTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChpcGZzLCBpZCwgZGJuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5JbmRleCA9PT0gdW5kZWZpbmVkKSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgSW5kZXg6IEV2ZW50SW5kZXggfSlcbiAgICBzdXBlcihpcGZzLCBpZCwgZGJuYW1lLCBvcHRpb25zKVxuICAgIHRoaXMuX3R5cGUgPSAnZXZlbnRsb2cnXG4gIH1cblxuICBhZGQgKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKHtcbiAgICAgIG9wOiAnQUREJyxcbiAgICAgIGtleTogbnVsbCxcbiAgICAgIHZhbHVlOiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGdldCAoaGFzaCkge1xuICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKHsgZ3RlOiBoYXNoLCBsaW1pdDogMSB9KS5jb2xsZWN0KClbMF1cbiAgfVxuXG4gIGl0ZXJhdG9yIChvcHRpb25zKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLl9xdWVyeShvcHRpb25zKVxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwXG4gICAgbGV0IGl0ZXJhdG9yID0ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIG5leHQgKCkge1xuICAgICAgICBsZXQgaXRlbSA9IHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfVxuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbSA9IHsgdmFsdWU6IG1lc3NhZ2VzW2N1cnJlbnRJbmRleF0sIGRvbmU6IGZhbHNlIH1cbiAgICAgICAgICBjdXJyZW50SW5kZXgrK1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgICB9LFxuICAgICAgY29sbGVjdDogKCkgPT4gbWVzc2FnZXNcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIF9xdWVyeSAob3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgICBjb25zdCBhbW91bnQgPSBvcHRzLmxpbWl0ID8gKG9wdHMubGltaXQgPiAtMSA/IG9wdHMubGltaXQgOiB0aGlzLl9pbmRleC5nZXQoKS5sZW5ndGgpIDogMSAvLyBSZXR1cm4gMSBpZiBubyBsaW1pdCBpcyBwcm92aWRlZFxuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2luZGV4LmdldCgpLnNsaWNlKClcbiAgICBsZXQgcmVzdWx0ID0gW11cblxuICAgIGlmIChvcHRzLmd0IHx8IG9wdHMuZ3RlKSB7XG4gICAgICAvLyBHcmVhdGVyIHRoYW4gY2FzZVxuICAgICAgcmVzdWx0ID0gdGhpcy5fcmVhZChldmVudHMsIG9wdHMuZ3QgPyBvcHRzLmd0IDogb3B0cy5ndGUsIGFtb3VudCwgISFvcHRzLmd0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG93ZXIgdGhhbiBhbmQgbGFzdE4gY2FzZSwgc2VhcmNoIGxhdGVzdCBmaXJzdCBieSByZXZlcnNpbmcgdGhlIHNlcXVlbmNlXG4gICAgICByZXN1bHQgPSB0aGlzLl9yZWFkKGV2ZW50cy5yZXZlcnNlKCksIG9wdHMubHQgPyBvcHRzLmx0IDogb3B0cy5sdGUsIGFtb3VudCwgb3B0cy5sdGUgfHwgIW9wdHMubHQpLnJldmVyc2UoKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIF9yZWFkIChvcHMsIGhhc2gsIGFtb3VudCwgaW5jbHVzaXZlKSB7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGd0L2x0IGhhc2gsIG9yIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgaWYgbm90IGZvdW5kXG4gICAgY29uc3QgaW5kZXggPSBvcHMubWFwKChlKSA9PiBlLmhhc2gpLmluZGV4T2YoaGFzaClcbiAgICBsZXQgc3RhcnRJbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKVxuICAgIC8vIElmIGd0ZS9sdGUgaXMgc2V0LCB3ZSBpbmNsdWRlIHRoZSBnaXZlbiBoYXNoLCBpZiBub3QsIHN0YXJ0IGZyb20gdGhlIG5leHQgZWxlbWVudFxuICAgIHN0YXJ0SW5kZXggKz0gaW5jbHVzaXZlID8gMCA6IDFcbiAgICAvLyBTbGljZSB0aGUgYXJyYXkgdG8gaXRzIHJlcXVlc3RlZCBzaXplXG4gICAgY29uc3QgcmVzID0gb3BzLnNsaWNlKHN0YXJ0SW5kZXgpLnNsaWNlKDAsIGFtb3VudClcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1zdG9yZScpXG5jb25zdCBLZXlWYWx1ZUluZGV4ID0gcmVxdWlyZSgnLi9LZXlWYWx1ZUluZGV4JylcblxuY2xhc3MgS2V5VmFsdWVTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBJbmRleDogS2V5VmFsdWVJbmRleCB9KVxuICAgIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0aW9ucylcbiAgICBzdXBlcihpcGZzLCBpZCwgZGJuYW1lLCBvcHRzKVxuICAgIHRoaXMuX3R5cGUgPSAna2V5dmFsdWUnXG4gIH1cblxuICBnZXQgYWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXguX2luZGV4XG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleC5nZXQoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQoa2V5LCBkYXRhKVxuICB9XG5cbiAgcHV0IChrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKHtcbiAgICAgIG9wOiAnUFVUJyxcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IGRhdGFcbiAgICB9KVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKHtcbiAgICAgIG9wOiAnREVMJyxcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5VmFsdWVTdG9yZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItc3RvcmUnKVxuY29uc3QgRG9jdW1lbnRJbmRleCA9IHJlcXVpcmUoJy4vRG9jdW1lbnRJbmRleCcpXG5jb25zdCBwTWFwID0gcmVxdWlyZSgncC1tYXAnKVxuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5jb25zdCByZXBsYWNlQWxsID0gKHN0ciwgc2VhcmNoLCByZXBsYWNlbWVudCkgPT4gc3RyLnRvU3RyaW5nKCkuc3BsaXQoc2VhcmNoKS5qb2luKHJlcGxhY2VtZW50KVxuXG5jbGFzcyBEb2N1bWVudFN0b3JlIGV4dGVuZHMgU3RvcmUge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG4gICAgaWYgKCFvcHRpb25zLmluZGV4QnkpIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBpbmRleEJ5OiAnX2lkJyB9KVxuICAgIGlmICghb3B0aW9ucy5JbmRleCkgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IEluZGV4OiBEb2N1bWVudEluZGV4IH0pXG4gICAgc3VwZXIoaXBmcywgaWQsIGRibmFtZSwgb3B0aW9ucylcbiAgICB0aGlzLl90eXBlID0gJ2RvY3N0b3JlJ1xuICB9XG5cbiAgZ2V0IChrZXksIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSkge1xuICAgIGtleSA9IGtleS50b1N0cmluZygpXG4gICAgY29uc3QgdGVybXMgPSBrZXkuc3BsaXQoJyAnKVxuICAgIGtleSA9IHRlcm1zLmxlbmd0aCA+IDEgPyByZXBsYWNlQWxsKGtleSwgJy4nLCAnICcpLnRvTG93ZXJDYXNlKCkgOiBrZXkudG9Mb3dlckNhc2UoKVxuXG4gICAgY29uc3Qgc2VhcmNoID0gKGUpID0+IHtcbiAgICAgIGlmICh0ZXJtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlQWxsKGUsICcuJywgJyAnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihrZXkpICE9PSAtMVxuICAgIH1cbiAgICBjb25zdCBtYXBwZXIgPSBlID0+IHRoaXMuX2luZGV4LmdldChlKVxuICAgIGNvbnN0IGZpbHRlciA9IGUgPT4gY2FzZVNlbnNpdGl2ZVxuICAgICAgPyBlLmluZGV4T2Yoa2V5KSAhPT0gLTEgXG4gICAgICA6IHNlYXJjaChlKVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2luZGV4Ll9pbmRleClcbiAgICAgIC5maWx0ZXIoZmlsdGVyKVxuICAgICAgLm1hcChtYXBwZXIpXG4gIH1cblxuICBxdWVyeSAobWFwcGVyLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBXaGV0aGVyIHdlIHJldHVybiB0aGUgZnVsbCBvcGVyYXRpb24gZGF0YSBvciBqdXN0IHRoZSBkYiB2YWx1ZVxuICAgIGNvbnN0IGZ1bGxPcCA9IG9wdGlvbnMuZnVsbE9wIHx8IGZhbHNlXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faW5kZXguX2luZGV4KVxuICAgICAgLm1hcCgoZSkgPT4gdGhpcy5faW5kZXguZ2V0KGUsIGZ1bGxPcCkpXG4gICAgICAuZmlsdGVyKG1hcHBlcilcbiAgfVxuXG4gIGJhdGNoUHV0IChkb2NzLCBvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXBwZXIgPSAoZG9jLCBpZHgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRPcGVyYXRpb25CYXRjaChcbiAgICAgICAge1xuICAgICAgICAgIG9wOiAnUFVUJyxcbiAgICAgICAgICBrZXk6IGRvY1t0aGlzLm9wdGlvbnMuaW5kZXhCeV0sXG4gICAgICAgICAgdmFsdWU6IGRvY1xuICAgICAgICB9LFxuICAgICAgICB0cnVlLFxuICAgICAgICBpZHggPT09IGRvY3MubGVuZ3RoIC0gMSxcbiAgICAgICAgb25Qcm9ncmVzc0NhbGxiYWNrXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBNYXAoZG9jcywgbWFwcGVyLCB7IGNvbmN1cnJlbmN5OiAxIH0pXG4gICAgICAudGhlbigoKSA9PiB0aGlzLnNhdmVTbmFwc2hvdCgpKVxuICB9XG5cbiAgcHV0IChkb2MpIHtcbiAgICBpZiAoIWRvY1t0aGlzLm9wdGlvbnMuaW5kZXhCeV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBkb2N1bWVudCBkb2Vzbid0IGNvbnRhaW4gZmllbGQgJyR7dGhpcy5vcHRpb25zLmluZGV4Qnl9J2ApXG5cbiAgICByZXR1cm4gdGhpcy5fYWRkT3BlcmF0aW9uKHtcbiAgICAgIG9wOiAnUFVUJyxcbiAgICAgIGtleTogZG9jW3RoaXMub3B0aW9ucy5pbmRleEJ5XSxcbiAgICAgIHZhbHVlOiBkb2NcbiAgICB9KVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBpZiAoIXRoaXMuX2luZGV4LmdldChrZXkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbnRyeSB3aXRoIGtleSAnJHtrZXl9JyBpbiB0aGUgZGF0YWJhc2VgKVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZE9wZXJhdGlvbih7XG4gICAgICBvcDogJ0RFTCcsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50U3RvcmUiLCIndXNlIHN0cmljdCdcblxuY29uc3QgaXNEZWZpbmVkID0gcmVxdWlyZSgnLi9pcy1kZWZpbmVkJylcbmNvbnN0IGlvID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWZpbmVkLFxuICBpb1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENoYW5uZWwgPSByZXF1aXJlKCdpcGZzLXB1YnN1Yi0xb24xJylcblxuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnbG9ncGxlYXNlJylcbmNvbnN0IGxvZ2dlciA9IExvZ2dlci5jcmVhdGUoXCJleGNoYW5nZS1oZWFkc1wiLCB7IGNvbG9yOiBMb2dnZXIuQ29sb3JzLlllbGxvdyB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbmNvbnN0IGdldEhlYWRzRm9yRGF0YWJhc2UgPSBzdG9yZSA9PiAoc3RvcmUgJiYgc3RvcmUuX29wbG9nKSA/IHN0b3JlLl9vcGxvZy5oZWFkcyA6IFtdXG5cbmNvbnN0IGV4Y2hhbmdlSGVhZHMgPSBhc3luYyAoaXBmcywgYWRkcmVzcywgcGVlciwgZ2V0U3RvcmUsIGdldERpcmVjdENvbm5lY3Rpb24sIG9uTWVzc2FnZSwgb25DaGFubmVsQ3JlYXRlZCkgPT4ge1xuICBjb25zdCBfaGFuZGxlTWVzc2FnZSA9IG1lc3NhZ2UgPT4ge1xuICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKVxuICAgIGNvbnN0IHsgYWRkcmVzcywgaGVhZHMgfSA9IG1zZ1xuICAgIG9uTWVzc2FnZShhZGRyZXNzLCBoZWFkcylcbiAgfVxuXG4gIGxldCBjaGFubmVsID0gZ2V0RGlyZWN0Q29ubmVjdGlvbihwZWVyKVxuICBpZiAoIWNoYW5uZWwpIHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBDcmVhdGUgYSBjaGFubmVsIHRvICR7cGVlcn1gKVxuICAgICAgY2hhbm5lbCA9IGF3YWl0IENoYW5uZWwub3BlbihpcGZzLCBwZWVyKVxuICAgICAgY2hhbm5lbC5vbignbWVzc2FnZScsIF9oYW5kbGVNZXNzYWdlKVxuICAgICAgbG9nZ2VyLmRlYnVnKGBDaGFubmVsIGNyZWF0ZWQgdG8gJHtwZWVyfWApXG4gICAgICBvbkNoYW5uZWxDcmVhdGVkKGNoYW5uZWwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGRpcmVjdCBjaGFubmVsIHRvIGJlIGZ1bGx5IGNvbm5lY3RlZFxuICBhd2FpdCBjaGFubmVsLmNvbm5lY3QoKVxuICBsb2dnZXIuZGVidWcoYENvbm5lY3RlZCB0byAke3BlZXJ9YClcblxuICAvLyBTZW5kIHRoZSBoZWFkcyBpZiB3ZSBoYXZlIGFueVxuICBjb25zdCBoZWFkcyA9IGdldEhlYWRzRm9yRGF0YWJhc2UoZ2V0U3RvcmUoYWRkcmVzcykpXG4gIGxvZ2dlci5kZWJ1ZyhgU2VuZCBsYXRlc3QgaGVhZHMgb2YgJyR7YWRkcmVzc30nOlxcbmAsIEpTT04uc3RyaW5naWZ5KGhlYWRzLm1hcChlID0+IGUuaGFzaCksIG51bGwsIDIpKVxuICBpZiAoaGVhZHMpIHtcbiAgICBhd2FpdCBjaGFubmVsLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBhZGRyZXNzOiBhZGRyZXNzLCBoZWFkczogaGVhZHMgfSkpXG4gIH1cblxuICByZXR1cm4gY2hhbm5lbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4Y2hhbmdlSGVhZHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLXN0b3JlJylcbmNvbnN0IENvdW50ZXJJbmRleCA9IHJlcXVpcmUoJy4vQ291bnRlckluZGV4JylcbmNvbnN0IENvdW50ZXIgPSByZXF1aXJlKCdjcmR0cy9zcmMvRy1Db3VudGVyJylcblxuY2xhc3MgQ291bnRlclN0b3JlIGV4dGVuZHMgU3RvcmUge1xuICBjb25zdHJ1Y3RvcihpcGZzLCBpZCwgZGJuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZighb3B0aW9ucy5JbmRleCkgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IEluZGV4OiBDb3VudGVySW5kZXggfSlcbiAgICBzdXBlcihpcGZzLCBpZCwgZGJuYW1lLCBvcHRpb25zKVxuICAgIHRoaXMuX3R5cGUgPSAnY291bnRlcidcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXguZ2V0KCkudmFsdWVcbiAgfVxuXG4gIGluYyhhbW91bnQpIHtcbiAgICBjb25zdCBjb3VudGVyID0gbmV3IENvdW50ZXIodGhpcy5pZGVudGl0eS5wdWJsaWNLZXksIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2luZGV4LmdldCgpLl9jb3VudGVycykpXG4gICAgY291bnRlci5pbmNyZW1lbnQoYW1vdW50KVxuICAgIHJldHVybiB0aGlzLl9hZGRPcGVyYXRpb24oe1xuICAgICAgb3A6ICdDT1VOVEVSJyxcbiAgICAgIGtleTogbnVsbCxcbiAgICAgIHZhbHVlOiBjb3VudGVyLnRvSlNPTigpLFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb3VudGVyU3RvcmVcbiIsImNvbnN0IGxldmVsID0gcmVxdWlyZSgnbGV2ZWwtanMnKVxuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL0NhY2hlJylcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGUobGV2ZWwpXG4iLCJjb25zdCBsZXZlbCA9IHJlcXVpcmUoJ2xldmVsLWpzJylcbmNvbnN0IEtleXN0b3JlID0gcmVxdWlyZSgnLi9zcmMva2V5c3RvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSBLZXlzdG9yZShsZXZlbClcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNTggPSByZXF1aXJlKCdiczU4JylcbmNvbnN0IG11bHRpaGFzaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCBNdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcblxuY29uc3QgdXJsUGF0dGVybiA9IC9eaHR0cHM/OlxcL1xcL1teL10rXFwvKGlwKGZ8bilzKVxcLygoXFx3KykuKikvXG5jb25zdCBwYXRoUGF0dGVybiA9IC9eXFwvKGlwKGZ8bilzKVxcLygoXFx3KykuKikvXG5jb25zdCBkZWZhdWx0UHJvdG9jb2xNYXRjaCA9IDFcbmNvbnN0IGRlZmF1bHRIYXNoTWF0aCA9IDRcblxuY29uc3QgZnFkblBhdHRlcm4gPSAvXmh0dHBzPzpcXC9cXC8oW14vXSspXFwuKGlwKD86ZnxuKXMpXFwuW14vXSsvXG5jb25zdCBmcWRuSGFzaE1hdGNoID0gMVxuY29uc3QgZnFkblByb3RvY29sTWF0Y2ggPSAyXG5cbmZ1bmN0aW9uIGlzTXVsdGloYXNoIChoYXNoKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGNvbnZlcnRUb1N0cmluZyhoYXNoKVxuICB0cnkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U1OC5kZWNvZGUoZm9ybWF0dGVkKSlcbiAgICBtdWx0aWhhc2guZGVjb2RlKGJ1ZmZlcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNdWx0aWJhc2UgKGhhc2gpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbXVsdGliYXNlLmlzRW5jb2RlZChoYXNoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDSUQgKGhhc2gpIHtcbiAgdHJ5IHtcbiAgICBuZXcgQ0lEKGhhc2gpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTXVsdGlhZGRyIChpbnB1dCkge1xuICBpZiAoIWlucHV0KSByZXR1cm4gZmFsc2VcbiAgaWYgKE11bHRpYWRkci5pc011bHRpYWRkcihpbnB1dCkpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgbmV3IE11bHRpYWRkcihpbnB1dCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQZWVyTXVsdGlhZGRyIChpbnB1dCkge1xuICByZXR1cm4gaXNNdWx0aWFkZHIoaW5wdXQpICYmIG1hZm10LklQRlMubWF0Y2hlcyhpbnB1dClcbn1cblxuZnVuY3Rpb24gaXNJcGZzIChpbnB1dCwgcGF0dGVybiwgcHJvdG9jb2xNYXRjaCA9IGRlZmF1bHRQcm90b2NvbE1hdGNoLCBoYXNoTWF0Y2ggPSBkZWZhdWx0SGFzaE1hdGgpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gY29udmVydFRvU3RyaW5nKGlucHV0KVxuICBpZiAoIWZvcm1hdHRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgbWF0Y2ggPSBmb3JtYXR0ZWQubWF0Y2gocGF0dGVybilcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1hdGNoW3Byb3RvY29sTWF0Y2hdICE9PSAnaXBmcycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBoYXNoID0gbWF0Y2hbaGFzaE1hdGNoXVxuXG4gIGlmIChoYXNoICYmIHBhdHRlcm4gPT09IGZxZG5QYXR0ZXJuKSB7XG4gICAgLy8gd2hlbiBkb2luZyBjaGVja3MgZm9yIHN1YmRvbWFpbiBjb250ZXh0XG4gICAgLy8gZW5zdXJlIGhhc2ggaXMgY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIChicm93c2VycyBmb3JjZS1sb3dlcmNhc2UgYXV0aG9yaXR5IGNvbXBvdGVudCBhbnl3YXkpXG4gICAgaGFzaCA9IGhhc2gudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgcmV0dXJuIGlzQ0lEKGhhc2gpXG59XG5cbmZ1bmN0aW9uIGlzSXBucyAoaW5wdXQsIHBhdHRlcm4sIHByb3RvY29sTWF0Y2ggPSBkZWZhdWx0UHJvdG9jb2xNYXRjaCwgaGFzaE1hdGNoKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGNvbnZlcnRUb1N0cmluZyhpbnB1dClcbiAgaWYgKCFmb3JtYXR0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBtYXRjaCA9IGZvcm1hdHRlZC5tYXRjaChwYXR0ZXJuKVxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWF0Y2hbcHJvdG9jb2xNYXRjaF0gIT09ICdpcG5zJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGhhc2hNYXRjaCAmJiBwYXR0ZXJuID09PSBmcWRuUGF0dGVybikge1xuICAgIGxldCBoYXNoID0gbWF0Y2hbaGFzaE1hdGNoXVxuICAgIC8vIHdoZW4gZG9pbmcgY2hlY2tzIGZvciBzdWJkb21haW4gY29udGV4dFxuICAgIC8vIGVuc3VyZSBoYXNoIGlzIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAvLyAoYnJvd3NlcnMgZm9yY2UtbG93ZXJjYXNlIGF1dGhvcml0eSBjb21wb3RlbnQgYW55d2F5KVxuICAgIGhhc2ggPSBoYXNoLnRvTG93ZXJDYXNlKClcbiAgICByZXR1cm4gaXNDSUQoaGFzaClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nIChpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJ1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9TdHJpbmcgKGlucHV0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGJhc2U1OC5lbmNvZGUoaW5wdXQpXG4gIH1cblxuICBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXBmc1N1YmRvbWFpbiA9ICh1cmwpID0+IGlzSXBmcyh1cmwsIGZxZG5QYXR0ZXJuLCBmcWRuUHJvdG9jb2xNYXRjaCwgZnFkbkhhc2hNYXRjaClcbmNvbnN0IGlwbnNTdWJkb21haW4gPSAodXJsKSA9PiBpc0lwbnModXJsLCBmcWRuUGF0dGVybiwgZnFkblByb3RvY29sTWF0Y2gsIGZxZG5IYXNoTWF0Y2gpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtdWx0aWhhc2g6IGlzTXVsdGloYXNoLFxuICBtdWx0aWFkZHI6IGlzTXVsdGlhZGRyLFxuICBwZWVyTXVsdGlhZGRyOiBpc1BlZXJNdWx0aWFkZHIsXG4gIGNpZDogaXNDSUQsXG4gIGJhc2UzMmNpZDogKGNpZCkgPT4gKGlzTXVsdGliYXNlKGNpZCkgPT09ICdiYXNlMzInICYmIGlzQ0lEKGNpZCkpLFxuICBpcGZzU3ViZG9tYWluOiBpcGZzU3ViZG9tYWluLFxuICBpcG5zU3ViZG9tYWluOiBpcG5zU3ViZG9tYWluLFxuICBzdWJkb21haW46ICh1cmwpID0+IChpcGZzU3ViZG9tYWluKHVybCkgfHwgaXBuc1N1YmRvbWFpbih1cmwpKSxcbiAgc3ViZG9tYWluUGF0dGVybjogZnFkblBhdHRlcm4sXG4gIGlwZnNVcmw6ICh1cmwpID0+IGlzSXBmcyh1cmwsIHVybFBhdHRlcm4pLFxuICBpcG5zVXJsOiAodXJsKSA9PiBpc0lwbnModXJsLCB1cmxQYXR0ZXJuKSxcbiAgdXJsOiAodXJsKSA9PiAoaXNJcGZzKHVybCwgdXJsUGF0dGVybikgfHwgaXNJcG5zKHVybCwgdXJsUGF0dGVybikpLFxuICB1cmxQYXR0ZXJuOiB1cmxQYXR0ZXJuLFxuICBpcGZzUGF0aDogKHBhdGgpID0+IGlzSXBmcyhwYXRoLCBwYXRoUGF0dGVybiksXG4gIGlwbnNQYXRoOiAocGF0aCkgPT4gaXNJcG5zKHBhdGgsIHBhdGhQYXR0ZXJuKSxcbiAgcGF0aDogKHBhdGgpID0+IChpc0lwZnMocGF0aCwgcGF0aFBhdHRlcm4pIHx8IGlzSXBucyhwYXRoLCBwYXRoUGF0dGVybikpLFxuICBwYXRoUGF0dGVybjogcGF0aFBhdHRlcm4sXG4gIHVybE9yUGF0aDogKHgpID0+IChpc0lwZnMoeCwgdXJsUGF0dGVybikgfHwgaXNJcG5zKHgsIHVybFBhdHRlcm4pIHx8IGlzSXBmcyh4LCBwYXRoUGF0dGVybikgfHwgaXNJcG5zKHgsIHBhdGhQYXR0ZXJuKSksXG4gIGNpZFBhdGg6IHBhdGggPT4gaXNTdHJpbmcocGF0aCkgJiYgIWlzQ0lEKHBhdGgpICYmIGlzSXBmcyhgL2lwZnMvJHtwYXRofWAsIHBhdGhQYXR0ZXJuKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNPcHRpb25PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmonKTtcblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gKG9iaiwgbmFtZSwgdmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcblx0dmFsdWUsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBnbG9iYWxUaGlzID0gdGhpcztcbmNvbnN0IGRlZmF1bHRNZXJnZU9wdHMgPSB7XG5cdGNvbmNhdEFycmF5czogZmFsc2Vcbn07XG5cbmNvbnN0IGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IGtleXMgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdGtleXMucHVzaChzeW1ib2xzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiBjbG9uZUFycmF5KHZhbHVlKTtcblx0fVxuXG5cdGlmIChpc09wdGlvbk9iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVPcHRpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XG5cdGNvbnN0IHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIDApO1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUoYXJyYXlba2V5XSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmopIHtcblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cblx0Z2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUob2JqW2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cbiAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XG4gKi9cbmNvbnN0IG1lcmdlS2V5cyA9IChtZXJnZWQsIHNvdXJjZSwga2V5cywgbWVyZ2VPcHRzKSA9PiB7XG5cdGtleXMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdC8vIERvIG5vdCByZWN1cnNlIGludG8gcHJvdG90eXBlIGNoYWluIG9mIG1lcmdlZFxuXHRcdGlmIChrZXkgaW4gbWVyZ2VkICYmIG1lcmdlZFtrZXldICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobWVyZ2VkKSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkobWVyZ2VkLCBrZXksIG1lcmdlKG1lcmdlZFtrZXldLCBzb3VyY2Vba2V5XSwgbWVyZ2VPcHRzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBjbG9uZShzb3VyY2Vba2V5XSkpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XG4gKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxuICpcbiAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcbiAqL1xuY29uc3QgY29uY2F0QXJyYXlzID0gKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpID0+IHtcblx0bGV0IHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcblx0bGV0IHJlc3VsdEluZGV4ID0gMDtcblxuXHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goYXJyYXkgPT4ge1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGByZXN1bHQuY29uY2F0KGFycmF5KWAgd2l0aCBjbG9uaW5nXG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7IGsrKykge1xuXHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aW5kaWNlcy5wdXNoKFN0cmluZyhrKSk7XG5cblx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XG5cdFx0XHRcdC8vIEFscmVhZHkgY2xvbmVkXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgYXJyYXlba10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCByZXN1bHRJbmRleCsrLCBjbG9uZShhcnJheVtrXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1lcmdlIG5vbi1pbmRleCBrZXlzXG5cdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihrZXkgPT4ge1xuXHRcdFx0cmV0dXJuIGluZGljZXMuaW5kZXhPZihrZXkpID09PSAtMTtcblx0XHR9KSwgbWVyZ2VPcHRzKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XG4gKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxuICovXG5mdW5jdGlvbiBtZXJnZShtZXJnZWQsIHNvdXJjZSwgbWVyZ2VPcHRzKSB7XG5cdGlmIChtZXJnZU9wdHMuY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobWVyZ2VkKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRyZXR1cm4gY29uY2F0QXJyYXlzKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpO1xuXHR9XG5cblx0aWYgKCFpc09wdGlvbk9iamVjdChzb3VyY2UpIHx8ICFpc09wdGlvbk9iamVjdChtZXJnZWQpKSB7XG5cdFx0cmV0dXJuIGNsb25lKHNvdXJjZSk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VLZXlzKG1lcmdlZCwgc291cmNlLCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKHNvdXJjZSksIG1lcmdlT3B0cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBtZXJnZU9wdHMgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRzKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdHMpO1xuXHRsZXQgbWVyZ2VkID0ge2Zvb2Jhcjoge319O1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gYXJndW1lbnRzW2ldO1xuXG5cdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzT3B0aW9uT2JqZWN0KG9wdGlvbikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcblx0XHR9XG5cblx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIHtmb29iYXI6IG9wdGlvbn0sIG1lcmdlT3B0cyk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkLmZvb2Jhcjtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgSVBGU1JlcG8gPSByZXF1aXJlKCdpcGZzLXJlcG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaXIpID0+IHtcbiAgY29uc3QgcmVwb1BhdGggPSBkaXIgfHwgJ2lwZnMnXG4gIHJldHVybiBuZXcgSVBGU1JlcG8ocmVwb1BhdGgpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6bWZzLXByZWxvYWQnKVxubG9nLmVycm9yID0gZGVidWcoJ2lwZnM6bWZzLXByZWxvYWQ6ZXJyb3InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChzZWxmKSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzZWxmLl9vcHRpb25zLnByZWxvYWQgfHwge31cbiAgb3B0aW9ucy5pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWwgfHwgMzAgKiAxMDAwXG5cbiAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICBsb2coJ01GUyBwcmVsb2FkIGRpc2FibGVkJylcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IChjYikgPT4gc2V0SW1tZWRpYXRlKGNiKSxcbiAgICAgIHN0b3A6IChjYikgPT4gc2V0SW1tZWRpYXRlKGNiKVxuICAgIH1cbiAgfVxuXG4gIGxldCByb290Q2lkXG4gIGxldCB0aW1lb3V0SWRcblxuICBjb25zdCBwcmVsb2FkTWZzID0gKCkgPT4ge1xuICAgIHNlbGYuZmlsZXMuc3RhdCgnLycsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQocHJlbG9hZE1mcywgb3B0aW9ucy5pbnRlcnZhbClcbiAgICAgICAgcmV0dXJuIGxvZy5lcnJvcignZmFpbGVkIHRvIHN0YXQgTUZTIHJvb3QgZm9yIHByZWxvYWQnLCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGlmIChyb290Q2lkICE9PSBzdGF0cy5oYXNoKSB7XG4gICAgICAgIGxvZyhgcHJlbG9hZGluZyB1cGRhdGVkIE1GUyByb290ICR7cm9vdENpZH0gLT4gJHtzdGF0cy5oYXNofWApXG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX3ByZWxvYWQoc3RhdHMuaGFzaCwgKGVycikgPT4ge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQocHJlbG9hZE1mcywgb3B0aW9ucy5pbnRlcnZhbClcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gbG9nLmVycm9yKGBmYWlsZWQgdG8gcHJlbG9hZCBNRlMgcm9vdCAke3N0YXRzLmhhc2h9YCwgZXJyKVxuICAgICAgICAgIHJvb3RDaWQgPSBzdGF0cy5oYXNoXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQocHJlbG9hZE1mcywgb3B0aW9ucy5pbnRlcnZhbClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydCAoY2IpIHtcbiAgICAgIHNlbGYuZmlsZXMuc3RhdCgnLycsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICAgIHJvb3RDaWQgPSBzdGF0cy5oYXNoXG4gICAgICAgIGxvZyhgbW9uaXRvcmluZyBNRlMgcm9vdCAke3Jvb3RDaWR9YClcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChwcmVsb2FkTWZzLCBvcHRpb25zLmludGVydmFsKVxuICAgICAgICBjYigpXG4gICAgICB9KVxuICAgIH0sXG4gICAgc3RvcCAoY2IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICBjYigpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5cbmZ1bmN0aW9uIGdldEI1OFN0ciAocGVlcikge1xuICBsZXQgYjU4U3RyXG5cbiAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgIGI1OFN0ciA9IHBlZXJcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIocGVlcikpIHtcbiAgICBiNThTdHIgPSBiczU4LmVuY29kZShwZWVyKS50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAoUGVlcklkLmlzUGVlcklkKHBlZXIpKSB7XG4gICAgYjU4U3RyID0gcGVlci50b0I1OFN0cmluZygpXG4gIH0gZWxzZSBpZiAoUGVlckluZm8uaXNQZWVySW5mbyhwZWVyKSkge1xuICAgIGI1OFN0ciA9IHBlZXIuaWQudG9CNThTdHJpbmcoKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IHZhbGlkIFBlZXJJZCBvciBQZWVySW5mbywgb3IgQjU4U3RyJylcbiAgfVxuXG4gIHJldHVybiBiNThTdHJcbn1cblxuY2xhc3MgUGVlckJvb2sge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fcGVlcnMgPSB7fVxuICB9XG5cbiAgLy8gY2hlY2tzIGlmIHBlZXIgZXhpc3RzXG4gIC8vIHBlZXIgY2FuIGJlIFBlZXJJZCwgYjU4U3RyaW5nIG9yIFBlZXJJbmZvXG4gIGhhcyAocGVlcikge1xuICAgIGNvbnN0IGI1OFN0ciA9IGdldEI1OFN0cihwZWVyKVxuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3BlZXJzW2I1OFN0cl0pXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgcGVlckluZm8sIGlmIGFscmVhZHkgZXhpc3QsIG1lcmdlcyB0aGUgbmV3IGludG8gdGhlIG9sZC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICogQHBhcmFtIHtCb29sZWFufSByZXBsYWNlXG4gICAqIEByZXR1cm5zIHtQZWVySW5mb31cbiAgICovXG4gIHB1dCAocGVlckluZm8sIHJlcGxhY2UpIHtcbiAgICBjb25zdCBsb2NhbFBlZXJJbmZvID0gdGhpcy5fcGVlcnNbcGVlckluZm8uaWQudG9CNThTdHJpbmcoKV1cblxuICAgIC8vIGluc2VydCBpZiBkb2Vzbid0IGV4aXN0IG9yIHJlcGxhY2UgaWYgcmVwbGFjZSBmbGFnIGlzIHRydWVcbiAgICBpZiAoIWxvY2FsUGVlckluZm8gfHwgcmVwbGFjZSkge1xuICAgICAgdGhpcy5fcGVlcnNbcGVlckluZm8uaWQudG9CNThTdHJpbmcoKV0gPSBwZWVySW5mb1xuICAgICAgcmV0dXJuIHBlZXJJbmZvXG4gICAgfVxuXG4gICAgLy8gcGVlckluZm8ucmVwbGFjZSBtZXJnZXMgYnkgZGVmYXVsdCBpZiBub25lIHRvIHJlcGxhY2UgYXJlIHBhc3NlZFxuICAgIHBlZXJJbmZvLm11bHRpYWRkcnMuZm9yRWFjaCgobWEpID0+IGxvY2FsUGVlckluZm8ubXVsdGlhZGRycy5hZGQobWEpKVxuXG4gICAgLy8gcGFzcyBhY3RpdmUgY29ubmVjdGlvbiBzdGF0ZVxuICAgIGNvbnN0IG1hID0gcGVlckluZm8uaXNDb25uZWN0ZWQoKVxuICAgIGlmIChtYSkge1xuICAgICAgbG9jYWxQZWVySW5mby5jb25uZWN0KG1hKVxuICAgIH1cblxuICAgIC8vIHBhc3Mga25vd24gcHJvdG9jb2xzXG4gICAgcGVlckluZm8ucHJvdG9jb2xzLmZvckVhY2goKHApID0+IGxvY2FsUGVlckluZm8ucHJvdG9jb2xzLmFkZChwKSlcblxuICAgIGlmICghbG9jYWxQZWVySW5mby5pZC5wcml2S2V5ICYmIHBlZXJJbmZvLmlkLnByaXZLZXkpIHtcbiAgICAgIGxvY2FsUGVlckluZm8uaWQucHJpdktleSA9IHBlZXJJbmZvLmlkLnByaXZLZXlcbiAgICB9XG5cbiAgICBpZiAoIWxvY2FsUGVlckluZm8uaWQucHViS2V5ICYmIHBlZXJJbmZvLmlkLnB1YktleSkge1xuICAgICAgbG9jYWxQZWVySW5mby5pZC5wdWJLZXkgPSBwZWVySW5mby5pZC5wdWJLZXlcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxQZWVySW5mb1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5mbyB0byB0aGUgZ2l2ZW4gUGVlcklkLCBQZWVySW5mbyBvciBiNThTdHIgaWRcbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHJldHVybnMge1BlZXJJbmZvfVxuICAgKi9cbiAgZ2V0IChwZWVyKSB7XG4gICAgY29uc3QgYjU4U3RyID0gZ2V0QjU4U3RyKHBlZXIpXG5cbiAgICBjb25zdCBwZWVySW5mbyA9IHRoaXMuX3BlZXJzW2I1OFN0cl1cblxuICAgIGlmIChwZWVySW5mbykge1xuICAgICAgcmV0dXJuIHBlZXJJbmZvXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUGVlckluZm8gbm90IGZvdW5kJylcbiAgfVxuXG4gIGdldEFsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJzXG4gIH1cblxuICBnZXRBbGxBcnJheSAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BlZXJzKS5tYXAoKGI1OFN0cikgPT4gdGhpcy5fcGVlcnNbYjU4U3RyXSlcbiAgfVxuXG4gIGdldE11bHRpYWRkcnMgKHBlZXIpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5nZXQocGVlcilcbiAgICByZXR1cm4gaW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKVxuICB9XG5cbiAgcmVtb3ZlIChwZWVyKSB7XG4gICAgY29uc3QgYjU4U3RyID0gZ2V0QjU4U3RyKHBlZXIpXG5cbiAgICBpZiAodGhpcy5fcGVlcnNbYjU4U3RyXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX3BlZXJzW2I1OFN0cl1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyQm9va1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzeW5jTWFwID0gcmVxdWlyZSgnYXN5bmMvbWFwJylcblxuLyoqXG4gKiBCbG9ja1NlcnZpY2UgaXMgYSBoeWJyaWQgYmxvY2sgZGF0YXN0b3JlLiBJdCBzdG9yZXMgZGF0YSBpbiBhIGxvY2FsXG4gKiBkYXRhc3RvcmUgYW5kIG1heSByZXRyaWV2ZSBkYXRhIGZyb20gYSByZW1vdGUgRXhjaGFuZ2UuXG4gKiBJdCB1c2VzIGFuIGludGVybmFsIGBkYXRhc3RvcmUuRGF0YXN0b3JlYCBpbnN0YW5jZSB0byBzdG9yZSB2YWx1ZXMuXG4gKi9cbmNsYXNzIEJsb2NrU2VydmljZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQmxvY2tTZXJ2aWNlXG4gICAqXG4gICAqIEBwYXJhbSB7SVBGU1JlcG99IGlwZnNSZXBvXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaXBmc1JlcG8pIHtcbiAgICB0aGlzLl9yZXBvID0gaXBmc1JlcG9cbiAgICB0aGlzLl9iaXRzd2FwID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGJpdHN3YXAgaW5zdGFuY2UgdGhhdCBjb21tdW5pY2F0ZXMgd2l0aCB0aGVcbiAgICogbmV0d29yayB0byByZXRyZWl2ZSBibG9ja3MgdGhhdCBhcmUgbm90IGluIHRoZSBsb2NhbCBzdG9yZS5cbiAgICpcbiAgICogSWYgdGhlIG5vZGUgaXMgb25saW5lIGFsbCByZXF1ZXN0cyBmb3IgYmxvY2tzIGZpcnN0XG4gICAqIGNoZWNrIGxvY2FsbHkgYW5kIGFmdGVyd2FyZHMgYXNrIHRoZSBuZXR3b3JrIGZvciB0aGUgYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge0JpdHN3YXB9IGJpdHN3YXBcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzZXRFeGNoYW5nZSAoYml0c3dhcCkge1xuICAgIHRoaXMuX2JpdHN3YXAgPSBiaXRzd2FwXG4gIH1cblxuICAvKipcbiAgICogR28gb2ZmbGluZSwgaS5lLiBkcm9wIHRoZSByZWZlcmVuY2UgdG8gYml0c3dhcC5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1bnNldEV4Y2hhbmdlICgpIHtcbiAgICB0aGlzLl9iaXRzd2FwID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBibG9ja3NlcnZpY2Ugb25saW5lLCBpLmUuIGlzIGJpdHN3YXAgcHJlc2VudC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2x9XG4gICAqL1xuICBoYXNFeGNoYW5nZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdHN3YXAgIT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBhIGJsb2NrIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGFzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2tcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHV0IChibG9jaywgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5oYXNFeGNoYW5nZSgpKSB7XG4gICAgICB0aGlzLl9iaXRzd2FwLnB1dChibG9jaywgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcG8uYmxvY2tzLnB1dChibG9jaywgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBhIG11bHRpcGxlIGJsb2NrcyB0byB0aGUgdW5kZXJseWluZyBkYXRhc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8QmxvY2s+fSBibG9ja3NcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHV0TWFueSAoYmxvY2tzLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc0V4Y2hhbmdlKCkpIHtcbiAgICAgIHRoaXMuX2JpdHN3YXAucHV0TWFueShibG9ja3MsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXBvLmJsb2Nrcy5wdXRNYW55KGJsb2NrcywgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJsb2NrIGJ5IGNpZC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IGNpZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCbG9jayl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0IChjaWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaGFzRXhjaGFuZ2UoKSkge1xuICAgICAgdGhpcy5fYml0c3dhcC5nZXQoY2lkLCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVwby5ibG9ja3MuZ2V0KGNpZCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtdWx0aXBsZSBibG9ja3MgYmFjayBmcm9tIGFuIGFycmF5IG9mIGNpZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8Q0lEPn0gY2lkc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCbG9jayl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZ2V0TWFueSAoY2lkcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2lkcykpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgYW4gYXJyYXkgb2YgY2lkcycpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNFeGNoYW5nZSgpKSB7XG4gICAgICB0aGlzLl9iaXRzd2FwLmdldE1hbnkoY2lkcywgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzeW5jTWFwKGNpZHMsIChjaWQsIGNiKSA9PiB0aGlzLl9yZXBvLmJsb2Nrcy5nZXQoY2lkLCBjYiksIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBibG9jayBmcm9tIHRoZSBibG9ja3N0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZGVsZXRlIChjaWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVwby5ibG9ja3MuZGVsZXRlKGNpZCwgY2FsbGJhY2spXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja1NlcnZpY2VcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdpcGZzOnN0YXRlJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOnN0YXRlOmVycm9yJylcblxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnNtLWV2ZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICBjb25zdCBzID0gZnNtKCd1bmluaXRpYWxpemVkJywge1xuICAgIHVuaW5pdGlhbGl6ZWQ6IHtcbiAgICAgIGluaXQ6ICdpbml0aWFsaXppbmcnLFxuICAgICAgaW5pdGlhbGl6ZWQ6ICdzdG9wcGVkJ1xuICAgIH0sXG4gICAgaW5pdGlhbGl6aW5nOiB7XG4gICAgICBpbml0aWFsaXplZDogJ3N0b3BwZWQnXG4gICAgfSxcbiAgICBzdG9wcGVkOiB7XG4gICAgICBzdGFydDogJ3N0YXJ0aW5nJ1xuICAgIH0sXG4gICAgc3RhcnRpbmc6IHtcbiAgICAgIHN0YXJ0ZWQ6ICdydW5uaW5nJ1xuICAgIH0sXG4gICAgcnVubmluZzoge1xuICAgICAgc3RvcDogJ3N0b3BwaW5nJ1xuICAgIH0sXG4gICAgc3RvcHBpbmc6IHtcbiAgICAgIHN0b3BwZWQ6ICdzdG9wcGVkJ1xuICAgIH1cbiAgfSlcblxuICAvLyBsb2cgZXZlbnRzXG4gIHMub24oJ2Vycm9yJywgKGVycikgPT4gbG9nLmVycm9yKGVycikpXG4gIHMub24oJ2RvbmUnLCAoKSA9PiBsb2coJy0+ICcgKyBzLl9zdGF0ZSkpXG5cbiAgLy8gLS0gQWN0aW9uc1xuXG4gIHMuaW5pdCA9ICgpID0+IHtcbiAgICBzKCdpbml0JylcbiAgfVxuXG4gIHMuaW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gICAgcygnaW5pdGlhbGl6ZWQnKVxuICB9XG5cbiAgcy5zdG9wID0gKCkgPT4ge1xuICAgIHMoJ3N0b3AnKVxuICB9XG5cbiAgcy5zdG9wcGVkID0gKCkgPT4ge1xuICAgIHMoJ3N0b3BwZWQnKVxuICB9XG5cbiAgcy5zdGFydCA9ICgpID0+IHtcbiAgICBzKCdzdGFydCcpXG4gIH1cblxuICBzLnN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgcygnc3RhcnRlZCcpXG4gIH1cblxuICBzLnN0YXRlID0gKCkgPT4gcy5fc3RhdGVcblxuICByZXR1cm4gc1xufVxuIiwiLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbXVsdGljb2RlYyBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgbXVsdGljb2RlY1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbiAqXG4gKiBjb25zdCBwcmVmaXhlZFByb3RvYnVmID0gbXVsdGljb2RlYy5hZGRQcmVmaXgoJ3Byb3RvYnVmJywgcHJvdG9idWZCdWZmZXIpXG4gKiAvLyBwcmVmaXhlZFByb3RvYnVmIDB4NTAuLi5cbiAqXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgY29kZWNOYW1lVG9Db2RlVmFyaW50ID0gcmVxdWlyZSgnLi92YXJpbnQtdGFibGUnKVxuY29uc3QgY29kZVRvQ29kZWNOYW1lID0gcmVxdWlyZSgnLi9uYW1lLXRhYmxlJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcblxuLyoqXG4gKiBQcmVmaXggYSBidWZmZXIgd2l0aCBhIG11bHRpY29kZWMtcGFja2VkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbXVsdGljb2RlY1N0ck9yQ29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuYWRkUHJlZml4ID0gKG11bHRpY29kZWNTdHJPckNvZGUsIGRhdGEpID0+IHtcbiAgbGV0IHByZWZpeFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIobXVsdGljb2RlY1N0ck9yQ29kZSkpIHtcbiAgICBwcmVmaXggPSB1dGlsLnZhcmludEJ1ZmZlckVuY29kZShtdWx0aWNvZGVjU3RyT3JDb2RlKVxuICB9IGVsc2Uge1xuICAgIGlmIChjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV0pIHtcbiAgICAgIHByZWZpeCA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpY29kZWMgbm90IHJlY29nbml6ZWQnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCBkYXRhXSlcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZSB0aGUgbXVsdGljb2RlYy1wYWNrZWQgcHJlZml4IGZyb20gdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucm1QcmVmaXggPSAoZGF0YSkgPT4ge1xuICB2YXJpbnQuZGVjb2RlKGRhdGEpXG4gIHJldHVybiBkYXRhLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0Q29kZWMgPSAocHJlZml4ZWREYXRhKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSB1dGlsLnZhcmludEJ1ZmZlckRlY29kZShwcmVmaXhlZERhdGEpXG4gIGNvbnN0IGNvZGVjTmFtZSA9IGNvZGVUb0NvZGVjTmFtZVtjb2RlLnRvU3RyaW5nKCdoZXgnKV1cbiAgaWYgKGNvZGVjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlIGAweCcgKyBjb2RlLnRvU3RyaW5nKCdoZXgnKSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIGNvZGVjTmFtZVxufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29kZWMuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZWNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0TmFtZSA9IChjb2RlYykgPT4ge1xuICByZXR1cm4gY29kZVRvQ29kZWNOYW1lW2NvZGVjLnRvU3RyaW5nKDE2KV1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIGNvZGVjXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXROdW1iZXIgPSAobmFtZSkgPT4ge1xuICBjb25zdCBjb2RlID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgbmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIHV0aWwudmFyaW50QnVmZmVyRGVjb2RlKGNvZGUpWzBdXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRDb2RlID0gKHByZWZpeGVkRGF0YSkgPT4ge1xuICByZXR1cm4gdmFyaW50LmRlY29kZShwcmVmaXhlZERhdGEpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGFzIHZhcmludCBvZiBhIGNvZGVjIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZWNOYW1lXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmdldENvZGVWYXJpbnQgPSAoY29kZWNOYW1lKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbY29kZWNOYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYyBgJyArIGNvZGVjTmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVxuICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICovXG5leHBvcnRzLmdldFZhcmludCA9IChjb2RlKSA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RlKGNvZGUpXG59XG5cbi8vIE1ha2UgdGhlIGNvbnN0YW50cyB0b3AtbGV2ZWwgY29uc3RhbnRzXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIGNvbnN0YW50cylcblxuLy8gSHVtYW4gZnJpZW5kbHkgbmFtZXMgZm9yIHByaW50aW5nLCBlLmcuIGluIGVycm9yIG1lc3NhZ2VzXG5leHBvcnRzLnByaW50ID0gcmVxdWlyZSgnLi9wcmludCcpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgY29kZWNzID0gcmVxdWlyZSgnbXVsdGljb2RlYy9zcmMvYmFzZS10YWJsZScpXG5jb25zdCBDSURVdGlsID0gcmVxdWlyZSgnLi9jaWQtdXRpbCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXplZENJRFxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVjXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvblxuICogQHBhcmFtIHtCdWZmZXJ9IG11bHRpaGFzaFxuICovXG5cbi8qKlxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSBDSUQuXG4gKiBAZnVuY3Rpb24gaXNDSURcbiAqIEBtZW1iZXJvZiBDSURcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7YW55fSBvdGhlclxuICogQHJldHVybnMge2Jvb2x9XG4gKi9cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBDSUQgYDxtYmFzZT48dmVyc2lvbj48bWNvZGVjPjxtaGFzaD5gXG4gKiAsIGFzIGRlZmluZWQgaW4gW2lwbGQvY2lkXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2NpZCkuXG4gKiBAY2xhc3MgQ0lEXG4gKi9cbmNsYXNzIENJRCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQ0lELlxuICAgKlxuICAgKiBUaGUgYWxnb3JpdGhtIGZvciBhcmd1bWVudCBpbnB1dCBpcyByb3VnaGx5OlxuICAgKiBgYGBcbiAgICogaWYgKGNpZClcbiAgICogICAtPiBjcmVhdGUgYSBjb3B5XG4gICAqIGVsc2UgaWYgKHN0cilcbiAgICogICBpZiAoMXN0IGNoYXIgaXMgb24gbXVsdGliYXNlIHRhYmxlKSAtPiBDSUQgU3RyaW5nXG4gICAqICAgZWxzZSAtPiBiczU4IGVuY29kZWQgbXVsdGloYXNoXG4gICAqIGVsc2UgaWYgKEJ1ZmZlcilcbiAgICogICBpZiAoMXN0IGJ5dGUgaXMgMCBvciAxKSAtPiBDSURcbiAgICogICBlbHNlIC0+IG11bHRpaGFzaFxuICAgKiBlbHNlIGlmIChOdW1iZXIpXG4gICAqICAgLT4gY29uc3RydWN0IENJRCBieSBwYXJ0c1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfENJRH0gdmVyc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVjXVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW211bHRpaGFzaF1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttdWx0aWJhc2VOYW1lXVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBuZXcgQ0lEKDx2ZXJzaW9uPiwgPGNvZGVjPiwgPG11bHRpaGFzaD4sIDxtdWx0aWJhc2VOYW1lPilcbiAgICogbmV3IENJRCg8Y2lkU3RyPilcbiAgICogbmV3IENJRCg8Y2lkLmJ1ZmZlcj4pXG4gICAqIG5ldyBDSUQoPG11bHRpaGFzaD4pXG4gICAqIG5ldyBDSUQoPGJzNTggZW5jb2RlZCBtdWx0aWhhc2g+KVxuICAgKiBuZXcgQ0lEKDxjaWQ+KVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIGNvZGVjLCBtdWx0aWhhc2gsIG11bHRpYmFzZU5hbWUpIHtcbiAgICBpZiAoX0NJRC5pc0NJRCh2ZXJzaW9uKSkge1xuICAgICAgLy8gdmVyc2lvbiBpcyBhbiBleGlzaW5nIENJRCBpbnN0YW5jZVxuICAgICAgY29uc3QgY2lkID0gdmVyc2lvblxuICAgICAgdGhpcy52ZXJzaW9uID0gY2lkLnZlcnNpb25cbiAgICAgIHRoaXMuY29kZWMgPSBjaWQuY29kZWNcbiAgICAgIHRoaXMubXVsdGloYXNoID0gQnVmZmVyLmZyb20oY2lkLm11bHRpaGFzaClcbiAgICAgIC8vIERlZmF1bHQgZ3VhcmQgZm9yIHdoZW4gYSBDSUQgPCAwLjcgaXMgcGFzc2VkIHdpdGggbm8gbXVsdGliYXNlTmFtZVxuICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gY2lkLm11bHRpYmFzZU5hbWUgfHwgKGNpZC52ZXJzaW9uID09PSAwID8gJ2Jhc2U1OGJ0YycgOiAnYmFzZTMyJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGUuZy4gJ2Jhc2UzMicgb3IgZmFsc2VcbiAgICAgIGNvbnN0IGJhc2VOYW1lID0gbXVsdGliYXNlLmlzRW5jb2RlZCh2ZXJzaW9uKVxuICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgIC8vIHZlcnNpb24gaXMgYSBDSUQgU3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UsIHNvIHYxXG4gICAgICAgIGNvbnN0IGNpZCA9IG11bHRpYmFzZS5kZWNvZGUodmVyc2lvbilcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcGFyc2VJbnQoY2lkLnNsaWNlKDAsIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpXG4gICAgICAgIHRoaXMuY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVjKGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWNvZGVjLnJtUHJlZml4KGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gYmFzZU5hbWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZlcnNpb24gaXMgYSBiYXNlNThidGMgc3RyaW5nIG11bHRpaGFzaCwgc28gdjBcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMFxuICAgICAgICB0aGlzLmNvZGVjID0gJ2RhZy1wYidcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBtaC5mcm9tQjU4U3RyaW5nKHZlcnNpb24pXG4gICAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9ICdiYXNlNThidGMnXG4gICAgICB9XG4gICAgICBDSUQudmFsaWRhdGVDSUQodGhpcylcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RyaW5nJywgeyB2YWx1ZTogdmVyc2lvbiB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZmlyc3RCeXRlID0gdmVyc2lvbi5zbGljZSgwLCAxKVxuICAgICAgY29uc3QgdiA9IHBhcnNlSW50KGZpcnN0Qnl0ZS50b1N0cmluZygnaGV4JyksIDE2KVxuICAgICAgaWYgKHYgPT09IDEpIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIENJRCBidWZmZXJcbiAgICAgICAgY29uc3QgY2lkID0gdmVyc2lvblxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2XG4gICAgICAgIHRoaXMuY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVjKGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWNvZGVjLnJtUHJlZml4KGNpZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2UzMidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZlcnNpb24gaXMgYSByYXcgbXVsdGloYXNoIGJ1ZmZlciwgc28gdjBcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMFxuICAgICAgICB0aGlzLmNvZGVjID0gJ2RhZy1wYidcbiAgICAgICAgdGhpcy5tdWx0aWhhc2ggPSB2ZXJzaW9uXG4gICAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9ICdiYXNlNThidGMnXG4gICAgICB9XG4gICAgICBDSUQudmFsaWRhdGVDSUQodGhpcylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSwgYXNzZW1ibGUgdGhlIENJRCBmcm9tIHRoZSBwYXJhbWV0ZXJzXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb25cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb2RlYyA9IGNvZGVjXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGloYXNoXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IG11bHRpYmFzZU5hbWUgfHwgKHZlcnNpb24gPT09IDAgPyAnYmFzZTU4YnRjJyA6ICdiYXNlMzInKVxuXG4gICAgQ0lELnZhbGlkYXRlQ0lEKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVGhlIENJRCBhcyBhIGBCdWZmZXJgXG4gICAqXG4gICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEBtZW1iZXJPZiBDSURcbiAgICovXG4gIGdldCBidWZmZXIgKCkge1xuICAgIGxldCBidWZmZXIgPSB0aGlzLl9idWZmZXJcblxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG4gICAgICAgIGJ1ZmZlciA9IHRoaXMubXVsdGloYXNoXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICBCdWZmZXIuZnJvbSgnMDEnLCAnaGV4JyksXG4gICAgICAgICAgbXVsdGljb2RlYy5nZXRDb2RlVmFyaW50KHRoaXMuY29kZWMpLFxuICAgICAgICAgIHRoaXMubXVsdGloYXNoXG4gICAgICAgIF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHZlcnNpb24nKVxuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSB0aGlzIGJ1ZmZlciBzbyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUgcmVjcmVhdGVkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19idWZmZXInLCB7IHZhbHVlOiBidWZmZXIgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmVmaXggb2YgdGhlIENJRC5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJlZml4ICgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShgMCR7dGhpcy52ZXJzaW9ufWAsICdoZXgnKSxcbiAgICAgIG11bHRpY29kZWMuZ2V0Q29kZVZhcmludCh0aGlzLmNvZGVjKSxcbiAgICAgIG1oLnByZWZpeCh0aGlzLm11bHRpaGFzaClcbiAgICBdKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBDSUQgb2YgdmVyc2lvbiBgMGAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDSUR9XG4gICAqL1xuICB0b1YwICgpIHtcbiAgICBpZiAodGhpcy5jb2RlYyAhPT0gJ2RhZy1wYicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgY29uc3QgeyBuYW1lLCBsZW5ndGggfSA9IG1oLmRlY29kZSh0aGlzLm11bHRpaGFzaClcblxuICAgIGlmIChuYW1lICE9PSAnc2hhMi0yNTYnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG5vbiBzaGEyLTI1NiBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJylcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoICE9PSAzMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gMzIgYnl0ZSBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IF9DSUQoMCwgdGhpcy5jb2RlYywgdGhpcy5tdWx0aWhhc2gpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIENJRCBvZiB2ZXJzaW9uIGAxYC5cbiAgICpcbiAgICogQHJldHVybnMge0NJRH1cbiAgICovXG4gIHRvVjEgKCkge1xuICAgIHJldHVybiBuZXcgX0NJRCgxLCB0aGlzLmNvZGVjLCB0aGlzLm11bHRpaGFzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIENJRCBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2U9dGhpcy5tdWx0aWJhc2VOYW1lXSAtIEJhc2UgZW5jb2RpbmcgdG8gdXNlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9CYXNlRW5jb2RlZFN0cmluZyAoYmFzZSA9IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgIGlmICh0aGlzLnN0cmluZyAmJiBiYXNlID09PSB0aGlzLm11bHRpYmFzZU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmluZ1xuICAgIH1cbiAgICBsZXQgc3RyID0gbnVsbFxuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChiYXNlICE9PSAnYmFzZTU4YnRjJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgd2l0aCBDSUR2MCwgdG8gc3VwcG9ydCBkaWZmZXJlbnQgYmFzZXMsIHBsZWFzZSBtaWdyYXRlIHRoZSBpbnN0YW5jZSBkbyBDSUR2MSwgeW91IGNhbiBkbyB0aGF0IHRocm91Z2ggY2lkLnRvVjEoKScpXG4gICAgICB9XG4gICAgICBzdHIgPSBtaC50b0I1OFN0cmluZyh0aGlzLm11bHRpaGFzaClcbiAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgc3RyID0gbXVsdGliYXNlLmVuY29kZShiYXNlLCB0aGlzLmJ1ZmZlcikudG9TdHJpbmcoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHZlcnNpb24nKVxuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgICAvLyBjYWNoZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0cmluZycsIHsgdmFsdWU6IHN0ciB9KVxuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICB0b1N0cmluZyAoYmFzZSkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZUVuY29kZWRTdHJpbmcoYmFzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdG8gYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXJpYWxpemVkQ0lEfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWM6IHRoaXMuY29kZWMsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICBoYXNoOiB0aGlzLm11bHRpaGFzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIGVxdWFsaXR5IHdpdGggYW5vdGhlciBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBvdGhlclxuICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICovXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYyA9PT0gb3RoZXIuY29kZWMgJiZcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gb3RoZXIudmVyc2lvbiAmJlxuICAgICAgdGhpcy5tdWx0aWhhc2guZXF1YWxzKG90aGVyLm11bHRpaGFzaClcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnaXZlbiBpbnB1dCBpcyBhIHZhbGlkIENJRCBvYmplY3QuXG4gICAqIFRocm93cyBpZiBpdCBpcyBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvdGhlclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZUNJRCAob3RoZXIpIHtcbiAgICBsZXQgZXJyb3JNc2cgPSBDSURVdGlsLmNoZWNrQ0lEQ29tcG9uZW50cyhvdGhlcilcbiAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZylcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgX0NJRCA9IHdpdGhJcyhDSUQsIHtcbiAgY2xhc3NOYW1lOiAnQ0lEJyxcbiAgc3ltYm9sTmFtZTogJ0BpcGxkL2pzLWNpZC9DSUQnXG59KVxuXG5fQ0lELmNvZGVjcyA9IGNvZGVjc1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9DSURcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IHsgZW5zdXJlTXVsdGlhZGRyIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IE11bHRpYWRkclNldCA9IHJlcXVpcmUoJy4vbXVsdGlhZGRyLXNldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG4vLyBQZWVyIHJlcHJlc2VudHMgYSBwZWVyIG9uIHRoZSBJUEZTIG5ldHdvcmtcbmNsYXNzIFBlZXJJbmZvIHtcbiAgY29uc3RydWN0b3IgKHBlZXJJZCkge1xuICAgIGFzc2VydChwZWVySWQsICdNaXNzaW5nIHBlZXJJZC4gVXNlIFBlZXIuY3JlYXRlKGNiKSB0byBjcmVhdGUgb25lJylcblxuICAgIHRoaXMuaWQgPSBwZWVySWRcbiAgICB0aGlzLm11bHRpYWRkcnMgPSBuZXcgTXVsdGlhZGRyU2V0KClcbiAgICB0aGlzLnByb3RvY29scyA9IG5ldyBTZXQoKVxuICAgIHRoaXMuX2Nvbm5lY3RlZE11bHRpYWRkciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gb25seSBzdG9yZXMgdGhlIGN1cnJlbnQgbXVsdGlhZGRyIGJlaW5nIHVzZWRcbiAgY29ubmVjdCAobWEpIHtcbiAgICBtYSA9IGVuc3VyZU11bHRpYWRkcihtYSlcbiAgICBpZiAoIXRoaXMubXVsdGlhZGRycy5oYXMobWEpICYmIG1hLnRvU3RyaW5nKCkgIT09IGAvaXBmcy8ke3RoaXMuaWQudG9CNThTdHJpbmcoKX1gKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYmUgY29ubmVjdGVkIHRvIG1pc3NpbmcgbXVsdGlhZGRyIGZyb20gc2V0JylcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkTXVsdGlhZGRyID0gbWFcbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZE11bHRpYWRkciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaXNDb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWRNdWx0aWFkZHJcbiAgfVxufVxuXG5QZWVySW5mby5jcmVhdGUgPSAocGVlcklkLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIHBlZXJJZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGVlcklkXG4gICAgcGVlcklkID0gbnVsbFxuXG4gICAgUGVlcklkLmNyZWF0ZSgoZXJyLCBpZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBuZXcgUGVlckluZm8oaWQpKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBBbHJlYWR5IGEgUGVlcklkIGluc3RhbmNlXG4gIGlmICh0eXBlb2YgcGVlcklkLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQZWVySW5mbyhwZWVySWQpKVxuICB9IGVsc2Uge1xuICAgIFBlZXJJZC5jcmVhdGVGcm9tSlNPTihwZWVySWQsIChlcnIsIGlkKSA9PiBjYWxsYmFjayhlcnIsIG5ldyBQZWVySW5mbyhpZCkpKVxuICB9XG59XG5cblBlZXJJbmZvLmlzUGVlckluZm8gPSAocGVlckluZm8pID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHBlZXJJbmZvID09PSAnb2JqZWN0JyAmJlxuICAgIHBlZXJJbmZvLmlkICYmXG4gICAgcGVlckluZm8ubXVsdGlhZGRycylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVySW5mb1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IE11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBtYWZtdCA9IHJlcXVpcmUoJ21hZm10JylcbmNvbnN0IHsgc3RydWN0LCBzdXBlcnN0cnVjdCB9ID0gcmVxdWlyZSgnc3VwZXJzdHJ1Y3QnKVxuXG5jb25zdCB7IG9wdGlvbmFsLCB1bmlvbiB9ID0gc3RydWN0XG5jb25zdCBzID0gc3VwZXJzdHJ1Y3Qoe1xuICB0eXBlczoge1xuICAgIG11bHRpYWRkcjogdiA9PiB7XG4gICAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYG11bHRpYWRkciBpbnZhbGlkLCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIG9yIGFub3RoZXIgTXVsdGlhZGRyIGdvdCAke3Z9YFxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBNdWx0aWFkZHIodilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYG11bHRpYWRkciBpbnZhbGlkLCAke2Vyci5tZXNzYWdlfWBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LFxuICAgICdtdWx0aWFkZHItaXBmcyc6IHYgPT4gbWFmbXQuSVBGUy5tYXRjaGVzKHYpID8gdHJ1ZSA6IGBtdWx0aWFkZHIgSVBGUyBpbnZhbGlkYFxuICB9XG59KVxuXG5jb25zdCBjb25maWdTY2hlbWEgPSBzKHtcbiAgcmVwbzogb3B0aW9uYWwocygnb2JqZWN0fHN0cmluZycpKSxcbiAgcmVwb093bmVyOiAnYm9vbGVhbj8nLFxuICBwcmVsb2FkOiBzKHtcbiAgICBlbmFibGVkOiAnYm9vbGVhbj8nLFxuICAgIGFkZHJlc3Nlczogb3B0aW9uYWwocyhbJ211bHRpYWRkciddKSksXG4gICAgaW50ZXJ2YWw6ICdudW1iZXI/J1xuICB9LCB7IGVuYWJsZWQ6IHRydWUsIGludGVydmFsOiAzMCAqIDEwMDAgfSksXG4gIGluaXQ6IG9wdGlvbmFsKHVuaW9uKFsnYm9vbGVhbicsIHMoe1xuICAgIGJpdHM6ICdudW1iZXI/JyxcbiAgICBlbXB0eVJlcG86ICdib29sZWFuPycsXG4gICAgcHJpdmF0ZUtleTogb3B0aW9uYWwocygnb2JqZWN0fHN0cmluZycpKSwgLy8gb2JqZWN0IHNob3VsZCBiZSBhIGN1c3RvbSB0eXBlIGZvciBQZWVySWQgdXNpbmcgJ2tpbmQtb2YnXG4gICAgcGFzczogJ3N0cmluZz8nXG4gIH0pXSkpLFxuICBzdGFydDogJ2Jvb2xlYW4/JyxcbiAgb2ZmbGluZTogJ2Jvb2xlYW4/JyxcbiAgcGFzczogJ3N0cmluZz8nLFxuICBzaWxlbnQ6ICdib29sZWFuPycsXG4gIHJlbGF5OiAnb2JqZWN0PycsIC8vIHJlbGF5IHZhbGlkYXRlcyBpbiBsaWJwMnBcbiAgRVhQRVJJTUVOVEFMOiBvcHRpb25hbChzKHtcbiAgICBwdWJzdWI6ICdib29sZWFuPycsXG4gICAgaXBuc1B1YnN1YjogJ2Jvb2xlYW4/JyxcbiAgICBzaGFyZGluZzogJ2Jvb2xlYW4/JyxcbiAgICBkaHQ6ICdib29sZWFuPydcbiAgfSkpLFxuICBjb25uZWN0aW9uTWFuYWdlcjogJ29iamVjdD8nLFxuICBjb25maWc6IG9wdGlvbmFsKHMoe1xuICAgIEFQSTogJ29iamVjdD8nLFxuICAgIEFkZHJlc3Nlczogb3B0aW9uYWwocyh7XG4gICAgICBTd2FybTogb3B0aW9uYWwocyhbJ211bHRpYWRkciddKSksXG4gICAgICBBUEk6ICdtdWx0aWFkZHI/JyxcbiAgICAgIEdhdGV3YXk6ICdtdWx0aWFkZHInXG4gICAgfSkpLFxuICAgIERpc2NvdmVyeTogb3B0aW9uYWwocyh7XG4gICAgICBNRE5TOiBvcHRpb25hbChzKHtcbiAgICAgICAgRW5hYmxlZDogJ2Jvb2xlYW4/JyxcbiAgICAgICAgSW50ZXJ2YWw6ICdudW1iZXI/J1xuICAgICAgfSkpLFxuICAgICAgd2ViUlRDU3Rhcjogb3B0aW9uYWwocyh7XG4gICAgICAgIEVuYWJsZWQ6ICdib29sZWFuPydcbiAgICAgIH0pKVxuICAgIH0pKSxcbiAgICBCb290c3RyYXA6IG9wdGlvbmFsKHMoWydtdWx0aWFkZHItaXBmcyddKSlcbiAgfSkpLFxuICBpcGxkOiAnb2JqZWN0PycsXG4gIGxpYnAycDogb3B0aW9uYWwodW5pb24oWydmdW5jdGlvbicsICdvYmplY3QnXSkpIC8vIGxpYnAycCB2YWxpZGF0ZXMgdGhpc1xufSwge1xuICByZXBvT3duZXI6IHRydWVcbn0pXG5cbmNvbnN0IHZhbGlkYXRlID0gKG9wdHMpID0+IHtcbiAgY29uc3QgW2Vyciwgb3B0aW9uc10gPSBjb25maWdTY2hlbWEudmFsaWRhdGUob3B0cylcblxuICBpZiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgdmFsaWRhdGUgfVxuIiwiLypcbiAqIElkIGlzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBlZXIgSWQuIGEgcGVlciBJZCBpcyBhIG11bHRpaGFzaFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJylcbmNvbnN0IGNyeXB0b0tleXMgPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvL3NyYy9rZXlzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG5jbGFzcyBQZWVySWQge1xuICBjb25zdHJ1Y3RvciAoaWQsIHByaXZLZXksIHB1YktleSkge1xuICAgIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoaWQpLCAnaW52YWxpZCBpZCBwcm92aWRlZCcpXG5cbiAgICBpZiAocHJpdktleSAmJiBwdWJLZXkpIHtcbiAgICAgIGFzc2VydChwcml2S2V5LnB1YmxpYy5ieXRlcy5lcXVhbHMocHViS2V5LmJ5dGVzKSwgJ2luY29uc2lzdGVudCBhcmd1bWVudHMnKVxuICAgIH1cblxuICAgIHRoaXMuX2lkID0gaWRcbiAgICB0aGlzLl9pZEI1OFN0cmluZyA9IG1oLnRvQjU4U3RyaW5nKHRoaXMuaWQpXG4gICAgdGhpcy5fcHJpdktleSA9IHByaXZLZXlcbiAgICB0aGlzLl9wdWJLZXkgPSBwdWJLZXlcbiAgfVxuXG4gIGdldCBpZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkXG4gIH1cblxuICBzZXQgaWQgKHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWQgaXMgaW1tdXRhYmxlJylcbiAgfVxuXG4gIGdldCBwcml2S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdktleVxuICB9XG5cbiAgc2V0IHByaXZLZXkgKHByaXZLZXkpIHtcbiAgICB0aGlzLl9wcml2S2V5ID0gcHJpdktleVxuICB9XG5cbiAgZ2V0IHB1YktleSAoKSB7XG4gICAgaWYgKHRoaXMuX3B1YktleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1YktleVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcml2S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdktleS5wdWJsaWNcbiAgICB9XG4gIH1cblxuICBzZXQgcHViS2V5IChwdWJLZXkpIHtcbiAgICB0aGlzLl9wdWJLZXkgPSBwdWJLZXlcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcHJvdG9idWYgdmVyc2lvbiBvZiB0aGUgcHVibGljIGtleSwgbWF0Y2hpbmcgZ28gaXBmcyBmb3JtYXR0aW5nXG4gIG1hcnNoYWxQdWJLZXkgKCkge1xuICAgIGlmICh0aGlzLnB1YktleSkge1xuICAgICAgcmV0dXJuIGNyeXB0b0tleXMubWFyc2hhbFB1YmxpY0tleSh0aGlzLnB1YktleSlcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHByb3RvYnVmIHZlcnNpb24gb2YgdGhlIHByaXZhdGUga2V5LCBtYXRjaGluZyBnbyBpcGZzIGZvcm1hdHRpbmdcbiAgbWFyc2hhbFByaXZLZXkgKCkge1xuICAgIGlmICh0aGlzLnByaXZLZXkpIHtcbiAgICAgIHJldHVybiBjcnlwdG9LZXlzLm1hcnNoYWxQcml2YXRlS2V5KHRoaXMucHJpdktleSlcbiAgICB9XG4gIH1cblxuICB0b1ByaW50ICgpIHtcbiAgICBsZXQgcGlkID0gdGhpcy50b0I1OFN0cmluZygpXG4gICAgLy8gQWxsIHNoYTI1NiBub2RlcyBzdGFydCB3aXRoIFFtXG4gICAgLy8gV2UgY2FuIHNraXAgdGhlIFFtIHRvIG1ha2UgdGhlIHBlZXIuSUQgbW9yZSB1c2VmdWxcbiAgICBpZiAocGlkLnN0YXJ0c1dpdGgoJ1FtJykpIHtcbiAgICAgIHBpZCA9IHBpZC5zbGljZSgyKVxuICAgIH1cbiAgICBsZXQgbWF4UnVuZXMgPSA2XG4gICAgaWYgKHBpZC5sZW5ndGggPCBtYXhSdW5lcykge1xuICAgICAgbWF4UnVuZXMgPSBwaWQubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuICc8cGVlci5JRCAnICsgcGlkLnN1YnN0cigwLCBtYXhSdW5lcykgKyAnPidcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUganNvbmlmaWVkIHZlcnNpb24gb2YgdGhlIGtleSwgbWF0Y2hpbmcgdGhlIGZvcm1hdHRpbmdcbiAgLy8gb2YgZ28taXBmcyBmb3IgaXRzIGNvbmZpZyBmaWxlXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLnRvQjU4U3RyaW5nKCksXG4gICAgICBwcml2S2V5OiB0b0I2NE9wdCh0aGlzLm1hcnNoYWxQcml2S2V5KCkpLFxuICAgICAgcHViS2V5OiB0b0I2NE9wdCh0aGlzLm1hcnNoYWxQdWJLZXkoKSlcbiAgICB9XG4gIH1cblxuICAvLyBlbmNvZGUvZGVjb2RlIGZ1bmN0aW9uc1xuICB0b0hleFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIG1oLnRvSGV4U3RyaW5nKHRoaXMuaWQpXG4gIH1cblxuICB0b0J5dGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZFxuICB9XG5cbiAgdG9CNThTdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9pZEI1OFN0cmluZ1xuICB9XG5cbiAgaXNFcXVhbCAoaWQpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaWQuZXF1YWxzKGlkKVxuICAgIH0gZWxzZSBpZiAoaWQuaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkLmVxdWFscyhpZC5pZClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgdmFsaWQgSWQnKVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoaXMgUGVlcklkIGluc3RhbmNlIGlzIHZhbGlkIChwcml2S2V5IC0+IHB1YktleSAtPiBJZClcbiAgICovXG4gIGlzVmFsaWQgKGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETyBOZWVkcyBiZXR0ZXIgY2hlY2tpbmdcbiAgICBpZiAodGhpcy5wcml2S2V5ICYmXG4gICAgICB0aGlzLnByaXZLZXkucHVibGljICYmXG4gICAgICB0aGlzLnByaXZLZXkucHVibGljLmJ5dGVzICYmXG4gICAgICBCdWZmZXIuaXNCdWZmZXIodGhpcy5wdWJLZXkuYnl0ZXMpICYmXG4gICAgICB0aGlzLnByaXZLZXkucHVibGljLmJ5dGVzLmVxdWFscyh0aGlzLnB1YktleS5ieXRlcykpIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdLZXlzIG5vdCBtYXRjaCcpKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBQZWVySWRXaXRoSXMgPSB3aXRoSXMoUGVlcklkLCB7IGNsYXNzTmFtZTogJ1BlZXJJZCcsIHN5bWJvbE5hbWU6ICdAbGlicDJwL2pzLXBlZXItaWQvUGVlcklkJyB9KVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQZWVySWRXaXRoSXNcblxuY29uc3QgY29tcHV0ZURpZ2VzdCA9IChwdWJLZXksIGNiKSA9PiB7XG4gIGlmIChwdWJLZXkuYnl0ZXMubGVuZ3RoIDw9IDQyKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gbWguZW5jb2RlKHB1YktleS5ieXRlcywgJ2lkZW50aXR5JylcbiAgICBjYihudWxsLCBkaWdlc3QpXG4gIH0gZWxzZSB7XG4gICAgcHViS2V5Lmhhc2goKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgICBjYihlcnIsIGRpZ2VzdClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNvbXB1dGVQZWVySWQgPSAocHJpdktleSwgcHViS2V5LCBjYikgPT4ge1xuICBjb21wdXRlRGlnZXN0KHB1YktleSwgKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICBjYihlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIG5ldyBQZWVySWRXaXRoSXMoZGlnZXN0LCBwcml2S2V5LCBwdWJLZXkpKVxuICAgIH1cbiAgfSlcbn1cblxuLy8gZ2VuZXJhdGlvblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5iaXRzID0gb3B0cy5iaXRzIHx8IDIwNDhcbiAgb3B0cy5rZXlUeXBlID0gb3B0cy5rZXlUeXBlIHx8ICdSU0EnXG5cbiAgY3J5cHRvS2V5cy5nZW5lcmF0ZUtleVBhaXIob3B0cy5rZXlUeXBlLCBvcHRzLmJpdHMsIChlcnIsIHByaXZLZXkpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZVBlZXJJZChwcml2S2V5LCBwcml2S2V5LnB1YmxpYywgY2FsbGJhY2spXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuZXcgUGVlcklkV2l0aElzKG1oLmZyb21IZXhTdHJpbmcoc3RyKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVGcm9tQnl0ZXMgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBuZXcgUGVlcklkV2l0aElzKGJ1Zilcbn1cblxuZXhwb3J0cy5jcmVhdGVGcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gbmV3IFBlZXJJZFdpdGhJcyhtaC5mcm9tQjU4U3RyaW5nKHN0cikpXG59XG5cbi8vIFB1YmxpYyBLZXkgaW5wdXQgd2lsbCBiZSBhIGJ1ZmZlclxuZXhwb3J0cy5jcmVhdGVGcm9tUHViS2V5ID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgbGV0IHB1YktleVxuXG4gIHRyeSB7XG4gICAgbGV0IGJ1ZiA9IGtleVxuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oa2V5LCAnYmFzZTY0JylcbiAgICB9XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGtleSBpcyBuZWl0aGVyIGEgYmFzZTY0IHN0cmluZyBub3IgYSBidWZmZXInKVxuXG4gICAgcHViS2V5ID0gY3J5cHRvS2V5cy51bm1hcnNoYWxQdWJsaWNLZXkoYnVmKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICB9XG5cbiAgY29tcHV0ZVBlZXJJZChudWxsLCBwdWJLZXksIGNhbGxiYWNrKVxufVxuXG4vLyBQcml2YXRlIGtleSBpbnB1dCB3aWxsIGJlIGEgc3RyaW5nXG5leHBvcnRzLmNyZWF0ZUZyb21Qcml2S2V5ID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgbGV0IGJ1ZiA9IGtleVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKVxuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQga2V5IGlzIG5laXRoZXIgYSBiYXNlNjQgc3RyaW5nIG5vciBhIGJ1ZmZlcicpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gIH1cblxuICBjcnlwdG9LZXlzLnVubWFyc2hhbFByaXZhdGVLZXkoYnVmLCAoZXJyLCBwcml2S2V5KSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXB1dGVQZWVySWQocHJpdktleSwgcHJpdktleS5wdWJsaWMsIGNhbGxiYWNrKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0cy5jcmVhdGVGcm9tSlNPTiA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGxldCBpZFxuICBsZXQgcmF3UHJpdktleVxuICBsZXQgcmF3UHViS2V5XG4gIGxldCBwdWJcblxuICB0cnkge1xuICAgIGlkID0gbWguZnJvbUI1OFN0cmluZyhvYmouaWQpXG4gICAgcmF3UHJpdktleSA9IG9iai5wcml2S2V5ICYmIEJ1ZmZlci5mcm9tKG9iai5wcml2S2V5LCAnYmFzZTY0JylcbiAgICByYXdQdWJLZXkgPSBvYmoucHViS2V5ICYmIEJ1ZmZlci5mcm9tKG9iai5wdWJLZXksICdiYXNlNjQnKVxuICAgIHB1YiA9IHJhd1B1YktleSAmJiBjcnlwdG9LZXlzLnVubWFyc2hhbFB1YmxpY0tleShyYXdQdWJLZXkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gIH1cblxuICBpZiAoIXJhd1ByaXZLZXkpIHtcbiAgICBjYWxsYmFjayhudWxsLCBuZXcgUGVlcklkV2l0aElzKGlkLCBudWxsLCBwdWIpKVxuICAgIHJldHVyblxuICB9XG5cbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IGNyeXB0b0tleXMudW5tYXJzaGFsUHJpdmF0ZUtleShyYXdQcml2S2V5LCBjYiksXG4gICAgKHByaXYsIGNiKSA9PiB7XG4gICAgICBjb21wdXRlRGlnZXN0KHByaXYucHVibGljLCAoZXJyLCBkaWdlc3QpID0+IHtcbiAgICAgICAgY2IoZXJyLCBkaWdlc3QsIHByaXYpXG4gICAgICB9KVxuICAgIH0sXG4gICAgKHByaXZEaWdlc3QsIHByaXYsIGNiKSA9PiB7XG4gICAgICBpZiAocHViKSB7XG4gICAgICAgIGNvbXB1dGVEaWdlc3QocHViLCAoZXJyLCBwdWJEaWdlc3QpID0+IHtcbiAgICAgICAgICBjYihlcnIsIHByaXZEaWdlc3QsIHByaXYsIHB1YkRpZ2VzdClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIHByaXZEaWdlc3QsIHByaXYpXG4gICAgICB9XG4gICAgfVxuICBdLCAoZXJyLCBwcml2RGlnZXN0LCBwcml2LCBwdWJEaWdlc3QpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGlmIChwdWIgJiYgIXByaXZEaWdlc3QuZXF1YWxzKHB1YkRpZ2VzdCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ1B1YmxpYyBhbmQgcHJpdmF0ZSBrZXkgZG8gbm90IG1hdGNoJykpXG4gICAgfVxuXG4gICAgaWYgKGlkICYmICFwcml2RGlnZXN0LmVxdWFscyhpZCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0lkIGFuZCBwcml2YXRlIGtleSBkbyBub3QgbWF0Y2gnKSlcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBuZXcgUGVlcklkV2l0aElzKGlkLCBwcml2LCBwdWIpKVxuICB9KVxufVxuXG5leHBvcnRzLmlzUGVlcklkID0gZnVuY3Rpb24gKHBlZXJJZCkge1xuICByZXR1cm4gQm9vbGVhbih0eXBlb2YgcGVlcklkID09PSAnb2JqZWN0JyAmJlxuICAgIHBlZXJJZC5faWQgJiZcbiAgICBwZWVySWQuX2lkQjU4U3RyaW5nKVxufVxuXG5mdW5jdGlvbiB0b0I2NE9wdCAodmFsKSB7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCdiYXNlNjQnKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmxvY2sgPSByZXF1aXJlKCdpcGZzLWJsb2NrJylcbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnbWVyZ2Utb3B0aW9ucycpXG5jb25zdCBpcGxkRGFnQ2JvciA9IHJlcXVpcmUoJ2lwbGQtZGFnLWNib3InKVxuY29uc3QgaXBsZERhZ1BiID0gcmVxdWlyZSgnaXBsZC1kYWctcGInKVxuY29uc3QgaXBsZFJhdyA9IHJlcXVpcmUoJ2lwbGQtcmF3JylcbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuY29uc3QgdHlwaWNhbCA9IHJlcXVpcmUoJ3R5cGljYWwnKVxuY29uc3QgeyBleHRlbmRJdGVyYXRvciB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY2xhc3MgSVBMRFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IgKHVzZXJPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhJUExEUmVzb2x2ZXIuZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuXG4gICAgaWYgKCFvcHRpb25zLmJsb2NrU2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGJsb2Nrc2VydmljZScpXG4gICAgfVxuICAgIHRoaXMuYnMgPSBvcHRpb25zLmJsb2NrU2VydmljZVxuXG4gICAgLy8gT2JqZWN0IHdpdGggY3VycmVudCBsaXN0IG9mIGFjdGl2ZSByZXNvbHZlcnNcbiAgICB0aGlzLnJlc29sdmVycyA9IHt9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9hZEZvcm1hdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5sb2FkRm9ybWF0ID0gYXN5bmMgKGNvZGVjKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvZGVjTmFtZSA9IG11bHRpY29kZWMucHJpbnRbY29kZWNdXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVzb2x2ZXIgZm91bmQgZm9yIGNvZGVjIFwiJHtjb2RlY05hbWV9XCJgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRGb3JtYXQgPSBvcHRpb25zLmxvYWRGb3JtYXRcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgYWxsIHN1cHBsaWVkIGZvcm1hdHNcbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBvcHRpb25zLmZvcm1hdHMpIHtcbiAgICAgIHRoaXMuYWRkRm9ybWF0KGZvcm1hdClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHN1cHBvcnQgZm9yIGFuIElQTEQgRm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0IC0gVGhlIGltcGxlbWVudGF0aW9uIG9mIGFuIElQTEQgRm9ybWF0LlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIGFkZEZvcm1hdCAoZm9ybWF0KSB7XG4gICAgY29uc3QgY29kZWMgPSBmb3JtYXQuY29kZWNcbiAgICBpZiAodGhpcy5yZXNvbHZlcnNbZm9ybWF0LmZvcm1hdF0pIHtcbiAgICAgIGNvbnN0IGNvZGVjTmFtZSA9IG11bHRpY29kZWMucHJpbnRbY29kZWNdXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc29sdmVyIGFscmVhZHkgZXhpc3RzIGZvciBjb2RlYyBcIiR7Y29kZWNOYW1lfVwiYClcbiAgICB9XG5cbiAgICB0aGlzLnJlc29sdmVyc1tjb2RlY10gPSBmb3JtYXRcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHN1cHBvcnQgZm9yIGFuIElQTEQgRm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZWMgLSBUaGUgY29kZWMgb2YgdGhlIElQTEQgRm9ybWF0IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICByZW1vdmVGb3JtYXQgKGNvZGVjKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZXJzW2NvZGVjXSkge1xuICAgICAgZGVsZXRlIHRoaXMucmVzb2x2ZXJzW2NvZGVjXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIElQTEQgTm9kZXMgYWxvbmcgdGhlIGBwYXRoYCB0aGF0IGlzIHJvb3RlZCBhdCBgY2lkYC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IGNpZCAtIHRoZSBDSUQgdGhlIHJlc29sdmluZyBzdGFydHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdGhhdCBzaG91bGQgYmUgcmVzb2x2ZWQuXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZS48UHJvbWlzZS48e3JlbWFpbmRlclBhdGg6IHN0cmluZywgdmFsdWV9Pj59IC0gUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciBvZiBhbGwgdGhlIElQTEQgTm9kZXMgdGhhdCB3ZXJlIHRyYXZlcnNlZCBkdXJpbmcgdGhlIHBhdGggcmVzb2x2aW5nLiBFdmVyeSBlbGVtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZXNlIGZpZWxkczpcbiAgICogICAtIGByZW1haW5kZXJQYXRoYDogdGhlIHBhcnQgb2YgdGhlIHBhdGggdGhhdCB3YXNu4oCZdCByZXNvbHZlZCB5ZXQuXG4gICAqICAgLSBgdmFsdWVgOiB0aGUgdmFsdWUgd2hlcmUgdGhlIHJlc29sdmVkIHBhdGggcG9pbnRzIHRvLiBJZiBmdXJ0aGVyIHRyYXZlcnNpbmcgaXMgcG9zc2libGUsIHRoZW4gdGhlIHZhbHVlIGlzIGEgQ0lEIG9iamVjdCBsaW5raW5nIHRvIGFub3RoZXIgSVBMRCBOb2RlLiBJZiBpdCB3YXMgcG9zc2libGUgdG8gZnVsbHkgcmVzb2x2ZSB0aGUgcGF0aCwgdmFsdWUgaXMgdGhlIHZhbHVlIHRoZSBwYXRoIHBvaW50cyB0by4gU28gaWYgeW91IG5lZWQgdGhlIENJRCBvZiB0aGUgSVBMRCBOb2RlIHlvdeKAmXJlIGN1cnJlbnRseSBhdCwganVzdCB0YWtlIHRoZSB2YWx1ZSBvZiB0aGUgcHJldmlvdXNseSByZXR1cm5lZCBJUExEIE5vZGUuXG4gICAqL1xuICByZXNvbHZlIChjaWQsIHBhdGgpIHtcbiAgICBpZiAoIUNJRC5pc0NJRChjaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BjaWRgIGFyZ3VtZW50IG11c3QgYmUgYSBDSUQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwYXRoYCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIC8vIEVuZCBpdGVyYXRpb24gaWYgdGhlcmUgaXNuJ3QgYSBDSUQgdG8gZm9sbG93IGFueW1vcmVcbiAgICAgIHdoaWxlIChjaWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gYXdhaXQgdGhpcy5fZ2V0Rm9ybWF0KGNpZC5jb2RlYylcblxuICAgICAgICAvLyBnZXQgYmxvY2tcbiAgICAgICAgLy8gdXNlIGxvY2FsIHJlc29sdmVyXG4gICAgICAgIC8vIHVwZGF0ZSBwYXRoIHZhbHVlXG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvbWlzaWZ5KHRoaXMuYnMuZ2V0LmJpbmQodGhpcy5icykpKGNpZClcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0LnJlc29sdmVyLnJlc29sdmUoYmxvY2suZGF0YSwgcGF0aClcblxuICAgICAgICAvLyBQcmVwYXJlIGZvciB0aGUgbmV4dCBpdGVyYXRpb24gaWYgdGhlcmUgaXMgYSBgcmVtYWluZGVyUGF0aGBcbiAgICAgICAgcGF0aCA9IHJlc3VsdC5yZW1haW5kZXJQYXRoXG4gICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdC52YWx1ZVxuICAgICAgICAvLyBOT1RFIHZteCAyMDE4LTExLTI5OiBOb3QgYWxsIElQTEQgRm9ybWF0cyByZXR1cm4gbGlua3MgYXNcbiAgICAgICAgLy8gQ0lEcyB5ZXQuIEhlbmNlIHRyeSB0byBjb252ZXJ0IG9sZCBzdHlsZSBsaW5rcyB0byBDSURzXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxICYmICcvJyBpbiB2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDSUQodmFsdWVbJy8nXSlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaWQgPSBDSUQuaXNDSUQodmFsdWUpID8gdmFsdWUgOiBudWxsXG5cbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJlbWFpbmRlclBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIGV4dGVuZEl0ZXJhdG9yKGdlbmVyYXRvcigpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG5vZGUgYnkgQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkIC0gVGhlIENJRCBvZiB0aGUgSVBMRCBOb2RlIHRoYXQgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59IC0gUmV0dXJucyBhIFByb21pc2Ugd2l0aCB0aGUgSVBMRCBOb2RlIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gYGNpZGAuXG4gICAqL1xuICBhc3luYyBnZXQgKGNpZCkge1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvbWlzaWZ5KHRoaXMuYnMuZ2V0LmJpbmQodGhpcy5icykpKGNpZClcbiAgICBjb25zdCBmb3JtYXQgPSBhd2FpdCB0aGlzLl9nZXRGb3JtYXQoYmxvY2suY2lkLmNvZGVjKVxuICAgIGNvbnN0IG5vZGUgPSBmb3JtYXQudXRpbC5kZXNlcmlhbGl6ZShibG9jay5kYXRhKVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbXVsdGlwbGUgbm9kZXMgYmFjayBmcm9tIGFuIGFycmF5IG9mIENJRHMuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGUuPENJRD59IGNpZHMgLSBUaGUgQ0lEcyBvZiB0aGUgSVBMRCBOb2RlcyB0aGF0IHNob3VsZCBiZSByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZS48UHJvbWlzZS48T2JqZWN0Pj59IC0gUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB3aXRoIHRoZSBJUExEIE5vZGVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gYGNpZHNgLlxuICAgKi9cbiAgZ2V0TWFueSAoY2lkcykge1xuICAgIGlmICghdHlwaWNhbC5pc0l0ZXJhYmxlKGNpZHMpIHx8IHR5cGVvZiBjaWRzID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIoY2lkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGNpZHNgIG11c3QgYmUgYW4gaXRlcmFibGUgb2YgQ0lEcycpXG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGNpZCBvZiBjaWRzKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZ2V0KGNpZClcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcblxuICAgIHJldHVybiBleHRlbmRJdGVyYXRvcihnZW5lcmF0b3IoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIElQTEQgTm9kZSBvZiBhIHJlY29nbml6ZWQgSVBMRCBGb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gVGhlIGRlc2VyaWFsaXplZCBJUExEIG5vZGUgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgLSBUaGUgbXVsdGljb2RlYyBvZiB0aGUgZm9ybWF0IHRoYXQgSVBMRCBOb2RlIHNob3VsZCBiZSBlbmNvZGVkIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3VzZXJPcHRpb25zXSAtICBPcHRpb25zIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3Rpb25zLmhhc2hBbGc9aGFzaCBhbGdvcml0aG0gb2YgdGhlIGdpdmVuIG11bHRpY29kZWNdIC0gVGhlIGhhc2hpbmcgYWxnb3JpdGhtIHRoYXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIENJRC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5jaWRWZXJzaW9uPTFdIC0gVGhlIENJRCB2ZXJzaW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdXNlck9wdGlvbnMub25seUhhc2g9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBJUExEIE5vZGUgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGJsb2NrIHN0b3JlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48Q0lEPn0gLSBSZXR1cm5zIHRoZSBDSUQgb2YgdGhlIHNlcmlhbGl6ZWQgSVBMRCBOb2Rlcy5cbiAgICovXG4gIGFzeW5jIHB1dCAobm9kZSwgZm9ybWF0LCB1c2VyT3B0aW9ucykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHV0YCByZXF1aXJlcyBhIGZvcm1hdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZm9ybWF0YCBwYXJhbWV0ZXIgbXVzdCBiZSBudW1iZXIgKG11bHRpY29kZWMpJylcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRJbXBsID0gYXdhaXQgdGhpcy5fZ2V0Rm9ybWF0KGZvcm1hdClcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGhhc2hBbGc6IGZvcm1hdEltcGwuZGVmYXVsdEhhc2hBbGcsXG4gICAgICBjaWRWZXJzaW9uOiAxLFxuICAgICAgb25seUhhc2g6IGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuXG4gICAgY29uc3QgY2lkT3B0aW9ucyA9IHtcbiAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICAgIGhhc2hBbGc6IG9wdGlvbnMuaGFzaEFsZyxcbiAgICAgIG9ubHlIYXNoOiBvcHRpb25zLm9ubHlIYXNoXG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBmb3JtYXRJbXBsLnV0aWwuc2VyaWFsaXplKG5vZGUpXG4gICAgY29uc3QgY2lkID0gYXdhaXQgZm9ybWF0SW1wbC51dGlsLmNpZChzZXJpYWxpemVkLCBjaWRPcHRpb25zKVxuXG4gICAgaWYgKCFvcHRpb25zLm9ubHlIYXNoKSB7XG4gICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayhzZXJpYWxpemVkLCBjaWQpXG4gICAgICBhd2FpdCBwcm9taXNpZnkodGhpcy5icy5wdXQuYmluZCh0aGlzLmJzKSkoYmxvY2spXG4gICAgfVxuXG4gICAgcmV0dXJuIGNpZFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gSVBMRCBOb2RlcyBvZiBhIHJlY29nbml6ZWQgSVBMRCBGb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGUuPE9iamVjdD59IG5vZGVzIC0gRGVzZXJpYWxpemVkIElQTEQgbm9kZXMgdGhhdCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgLSBUaGUgbXVsdGljb2RlYyBvZiB0aGUgZm9ybWF0IHRoYXQgSVBMRCBOb2RlIHNob3VsZCBiZSBlbmNvZGVkIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3VzZXJPcHRpb25zXSAtICBPcHRpb25zIGFyZSBhcHBsaWVkIHRvIGFueSBvZiB0aGUgYG5vZGVzYCBhbmQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPdGlvbnMuaGFzaEFsZz1oYXNoIGFsZ29yaXRobSBvZiB0aGUgZ2l2ZW4gbXVsdGljb2RlY10gLSBUaGUgaGFzaGluZyBhbGdvcml0aG0gdGhhdCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgQ0lELlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3VzZXJPcHRpb25zLmNpZFZlcnNpb249MV0gLSBUaGUgQ0lEIHZlcnNpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VyT3B0aW9ucy5vbmx5SGFzaD1mYWxzZV0gLSBJZiB0cnVlIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIElQTEQgTm9kZSB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgYmxvY2sgc3RvcmUuXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZS48UHJvbWlzZS48Q0lEPj59IC0gUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB3aXRoIHRoZSBDSURzIG9mIHRoZSBzZXJpYWxpemVkIElQTEQgTm9kZXMuXG4gICAqL1xuICBwdXRNYW55IChub2RlcywgZm9ybWF0LCB1c2VyT3B0aW9ucykge1xuICAgIGlmICghdHlwaWNhbC5pc0l0ZXJhYmxlKG5vZGVzKSB8fCB0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihub2RlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYG5vZGVzYCBtdXN0IGJlIGFuIGl0ZXJhYmxlJylcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwdXRgIHJlcXVpcmVzIGEgZm9ybWF0JylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bmb3JtYXRgIHBhcmFtZXRlciBtdXN0IGJlIG51bWJlciAobXVsdGljb2RlYyknKVxuICAgIH1cblxuICAgIGxldCBvcHRpb25zXG4gICAgbGV0IGZvcm1hdEltcGxcblxuICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIC8vIExhenkgbG9hZCB0aGUgb3B0aW9ucyBub3Qgd2hlbiB0aGUgaXRlcmF0b3IgaXMgaW5pdGlhbGl6ZWQsIGJ1dFxuICAgICAgICAvLyB3aGVuIHdlIGhpdCB0aGUgZmlyc3QgaXRlcmF0aW9uLiBUaGlzIHdheSB0aGUgY29uc3RydWN0b3IgY2FuIGJlXG4gICAgICAgIC8vIGEgc3luY2hyb25vdXMgZnVuY3Rpb24uXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3JtYXRJbXBsID0gYXdhaXQgdGhpcy5fZ2V0Rm9ybWF0KGZvcm1hdClcbiAgICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhhc2hBbGc6IGZvcm1hdEltcGwuZGVmYXVsdEhhc2hBbGcsXG4gICAgICAgICAgICBjaWRWZXJzaW9uOiAxLFxuICAgICAgICAgICAgb25seUhhc2g6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuICAgICAgICB9XG5cbiAgICAgICAgeWllbGQgdGhpcy5wdXQobm9kZSwgZm9ybWF0LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIGV4dGVuZEl0ZXJhdG9yKGdlbmVyYXRvcigpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBJUExEIE5vZGUgYnkgdGhlIGdpdmVuIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtDSUR9IGNpZCAtIFRoZSBDSUQgb2YgdGhlIElQTEQgTm9kZSB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxDSUQ+fSBUaGUgQ0lEIG9mIHRoZSByZW1vdmVkIElQTEQgTm9kZS5cbiAgICovXG4gIGFzeW5jIHJlbW92ZSAoY2lkKSB7XG4gICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLmJzLmRlbGV0ZS5iaW5kKHRoaXMuYnMpKShjaWQpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIElQTEQgTm9kZXMgYnkgdGhlIGdpdmVuIENJRHMuXG4gICAqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIEJsb2NrcyBjYW7igJl0IGJlIHJlbW92ZWQuIFRoaXMgb3BlcmF0aW9uIGlzXG4gICAqICpub3QqIGF0b21pYywgc29tZSBCbG9ja3MgbWlnaHQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZS48Q0lEPn0gY2lkcyAtIFRoZSBDSURzIG9mIHRoZSBJUExEIE5vZGVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlLjxQcm9taXNlLjxDSUQ+Pn0gUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB3aXRoIHRoZSBDSURzIG9mIHRoZSByZW1vdmVkIElQTEQgTm9kZXMuXG4gICAqL1xuICByZW1vdmVNYW55IChjaWRzKSB7XG4gICAgaWYgKCF0eXBpY2FsLmlzSXRlcmFibGUoY2lkcykgfHwgdHlwZW9mIGNpZHMgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihjaWRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgY2lkc2AgbXVzdCBiZSBhbiBpdGVyYWJsZSBvZiBDSURzJylcbiAgICB9XG5cbiAgICBjb25zdCBnZW5lcmF0b3IgPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIGNpZHMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZW1vdmUoY2lkKVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIGV4dGVuZEl0ZXJhdG9yKGdlbmVyYXRvcigpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSBwYXRocyB0aGF0IGNhbiBiZSByZXNvbHZlZCBpbnRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2lkIC0gVGhlIElEIHRvIGdldCB0aGUgcGF0aHMgZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29mZnNldFBhdGg9JyddIC0gdGhlIHBhdGggdG8gc3RhcnQgdG8gcmV0cmlldmUgdGhlIG90aGVyIHBhdGhzIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlck9wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck9wdGlvbnMucmVjdXJzaXZlPWZhbHNlXSAtIHdoZXRoZXIgdG8gZ2V0IHRoZSBwYXRocyByZWN1cnNpdmVseSBvciBub3QuIGBmYWxzZWAgcmVzb2x2ZXMgb25seSB0aGUgcGF0aHMgb2YgdGhlIGdpdmVuIENJRC5cbiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxQcm9taXNlLjxTdHJpbmc+Pn0gLSBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHdpdGggcGF0aHMgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgaW50b1xuICAgKi9cbiAgdHJlZSAoY2lkLCBvZmZzZXRQYXRoLCB1c2VyT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0UGF0aCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHVzZXJPcHRpb25zID0gb2Zmc2V0UGF0aFxuICAgICAgb2Zmc2V0UGF0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBvZmZzZXRQYXRoID0gb2Zmc2V0UGF0aCB8fCAnJ1xuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICByZWN1cnNpdmU6IGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuXG4gICAgLy8gSWYgYSBwYXRoIGlzIGEgbGluayB0aGVuIGZvbGxvdyBpdCBhbmQgcmV0dXJuIGl0cyBDSURcbiAgICBjb25zdCBtYXliZVJlY3Vyc2UgPSBhc3luYyAoYmxvY2ssIHRyZWVQYXRoKSA9PiB7XG4gICAgICAvLyBBIHRyZWVwYXRoIHdlIG1pZ2h0IHdhbnQgdG8gZm9sbG93IHJlY3Vyc2l2ZWx5XG4gICAgICBjb25zdCBmb3JtYXQgPSBhd2FpdCB0aGlzLl9nZXRGb3JtYXQoYmxvY2suY2lkLmNvZGVjKVxuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0LnJlc29sdmVyLnJlc29sdmUoYmxvY2suZGF0YSwgdHJlZVBhdGgpXG4gICAgICAvLyBTb21ldGhpbmcgdG8gZm9sbG93IHJlY3VzaXZlbHksIGhlbmNlIHB1c2ggaXQgaW50byB0aGUgcXVldWVcbiAgICAgIGlmIChDSUQuaXNDSUQocmVzdWx0LnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uICogKCkge1xuICAgICAgLy8gVGhlIGxpc3Qgb2YgcGF0aHMgdGhhdCB3aWxsIGdldCByZXR1cm5lZFxuICAgICAgY29uc3QgdHJlZVBhdGhzID0gW11cbiAgICAgIC8vIFRoZSBjdXJyZW50IGJsb2NrLCBuZWVkZWQgdG8gY2FsbCBgaXNMaW5rKClgIG9uIGV2ZXJ5IGludGVyYXRpb25cbiAgICAgIGxldCBibG9ja1xuICAgICAgLy8gVGhlIGxpc3Qgb2YgaXRlbXMgd2Ugd2FudCB0byBmb2xsb3cgcmVjdXJzaXZlbHkuIFRoZSBpdGVtcyBhcmVcbiAgICAgIC8vIGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIHRoZSBDSUQgYW5kIHRoZSBjdXJyZW50bHkgYWxyZWFkeSByZXNvbHZlZFxuICAgICAgLy8gcGF0aFxuICAgICAgY29uc3QgcXVldWUgPSBbeyBjaWQsIGJhc2VQYXRoOiAnJyB9XVxuICAgICAgLy8gVGhlIHBhdGggdGhhdCB3YXMgYWxyZWFkeSB0cmF2ZXJzZWRcbiAgICAgIGxldCBiYXNlUGF0aFxuXG4gICAgICAvLyBFbmQgb2YgaXRlcmF0aW9uIGlmIHRoZXJlIGFyZW4ndCBhbnkgcGF0aHMgbGVmdCB0byByZXR1cm4gb3JcbiAgICAgIC8vIGlmIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2UgcmVjdXJzaXZlbHkgYW5kIGhhdmUgYWxyZWFkeVxuICAgICAgLy8gcmV0dXJuZSB0aGUgZmlyc3QgbGV2ZWxcbiAgICAgIHdoaWxlICh0cmVlUGF0aHMubGVuZ3RoID4gMCB8fCBxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZW4ndCBhbnkgcGF0aHMgbGVmdCwgZ2V0IHRoZW0gZnJvbSB0aGUgZ2l2ZW4gQ0lEXG4gICAgICAgIGlmICh0cmVlUGF0aHMubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAoeyBjaWQsIGJhc2VQYXRoIH0gPSBxdWV1ZS5zaGlmdCgpKVxuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGF3YWl0IHRoaXMuX2dldEZvcm1hdChjaWQuY29kZWMpXG4gICAgICAgICAgYmxvY2sgPSBhd2FpdCBwcm9taXNpZnkodGhpcy5icy5nZXQuYmluZCh0aGlzLmJzKSkoY2lkKVxuXG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBmb3JtYXQucmVzb2x2ZXIudHJlZShibG9jay5kYXRhKVxuICAgICAgICAgIHRyZWVQYXRocy5wdXNoKC4uLnBhdGhzKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJlZVBhdGggPSB0cmVlUGF0aHMuc2hpZnQoKVxuICAgICAgICBsZXQgZnVsbFBhdGggPSBiYXNlUGF0aCArIHRyZWVQYXRoXG5cbiAgICAgICAgLy8gT25seSBmb2xsb3cgbGlua3MgaWYgcmVjdXJzaW9uIGlzIGludGVuZGVkXG4gICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgICAgICAgIGNpZCA9IGF3YWl0IG1heWJlUmVjdXJzZShibG9jaywgdHJlZVBhdGgpXG4gICAgICAgICAgaWYgKGNpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUucHVzaCh7IGNpZCwgYmFzZVBhdGg6IGZ1bGxQYXRoICsgJy8nIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMgdGhlIGdpdmVuIG9mZnNldCBwYXRoLCBidXQgaXMgbm90IHRoZVxuICAgICAgICAvLyBvZmZzZXQgcGF0aCBpdHNlbGZcbiAgICAgICAgaWYgKGZ1bGxQYXRoLnN0YXJ0c1dpdGgob2Zmc2V0UGF0aCkgJiZcbiAgICAgICAgICAgIGZ1bGxQYXRoLmxlbmd0aCA+IG9mZnNldFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9mZnNldFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZnVsbFBhdGggPSBmdWxsUGF0aC5zbGljZShvZmZzZXRQYXRoLmxlbmd0aCArIDEpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeWllbGQgZnVsbFBhdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgcmV0dXJuIGV4dGVuZEl0ZXJhdG9yKGdlbmVyYXRvcigpKVxuICB9XG5cbiAgLyogICAgICAgICAgICovXG4gIC8qIGludGVybmFscyAqL1xuICAvKiAgICAgICAgICAgKi9cbiAgYXN5bmMgX2dldEZvcm1hdCAoY29kZWMpIHtcbiAgICAvLyBUT0RPIHZteCAyMDE5LTAxLTI0OiBPbmNlIGFsbCBDSURzIHN1cHBvcnQgYWNjZXNzaW5nIHRoZSBjb2RlYyBjb2RlXG4gICAgLy8gaW5zdGVhZCBvZiB0aGUgbmFtZSwgcmVtb3ZlIHRoaXMgcGFydFxuICAgIGlmICh0eXBlb2YgY29kZWMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjb25zdGFudE5hbWUgPSBjb2RlYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgY29kZWMgPSBtdWx0aWNvZGVjW2NvbnN0YW50TmFtZV1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXNvbHZlcnNbY29kZWNdKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnNbY29kZWNdXG4gICAgfVxuXG4gICAgLy8gSWYgbm90IHN1cHBvcnRlZCwgYXR0ZW1wdCB0byBkeW5hbWljYWxseSBsb2FkIHRoaXMgZm9ybWF0XG4gICAgY29uc3QgZm9ybWF0ID0gYXdhaXQgdGhpcy5sb2FkRm9ybWF0KGNvZGVjKVxuICAgIHRoaXMuYWRkRm9ybWF0KGZvcm1hdClcbiAgICByZXR1cm4gZm9ybWF0XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIElQTEQuXG4gKi9cbklQTERSZXNvbHZlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgZm9ybWF0czogW2lwbGREYWdDYm9yLCBpcGxkRGFnUGIsIGlwbGRSYXddXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSVBMRFJlc29sdmVyXG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbbXVsdGliYXNlXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYmFzZSkgc3BlY2lmaWNhdGlvbi5cbiAqIEBtb2R1bGUgTXVsdGliYXNlXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG11bHRpYmFzZVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmlzRW5jb2RlZCA9IGlzRW5jb2RlZFxuZXhwb3J0cy5uYW1lcyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmtleXMoY29uc3RhbnRzLm5hbWVzKSlcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5rZXlzKGNvbnN0YW50cy5jb2RlcykpXG5cbmNvbnN0IGVyck5vdFN1cHBvcnRlZCA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW5jb2RpbmcnKVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBidWZmZXIgd2l0aCB0aGUgbXVsdGliYXNlIHZhcmludCtjb2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgLSBUaGUgZGF0YSB0byBiZSBwcmVmaXhlZCB3aXRoIG11bHRpYmFzZS5cbiAqIEBtZW1iZXJvZiBNdWx0aWJhc2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIG11bHRpYmFzZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGlmICghYnVmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBhbiBlbmNvZGVkIGJ1ZmZlcicpXG4gIH1cbiAgY29uc3QgYmFzZSA9IGdldEJhc2UobmFtZU9yQ29kZSlcbiAgY29uc3QgY29kZUJ1ZiA9IEJ1ZmZlci5mcm9tKGJhc2UuY29kZSlcblxuICBjb25zdCBuYW1lID0gYmFzZS5uYW1lXG4gIHZhbGlkRW5jb2RlKG5hbWUsIGJ1ZilcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NvZGVCdWYsIGJ1Zl0pXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIGJhc2UgYW5kIGFkZCB0aGUgbXVsdGliYXNlIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAbWVtYmVyb2YgTXVsdGliYXNlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGNvbnN0IGJhc2UgPSBnZXRCYXNlKG5hbWVPckNvZGUpXG4gIGNvbnN0IG5hbWUgPSBiYXNlLm5hbWVcblxuICByZXR1cm4gbXVsdGliYXNlKG5hbWUsIEJ1ZmZlci5mcm9tKGJhc2UuZW5jb2RlKGJ1ZikpKVxufVxuXG4vKipcbiAqIFRha2VzIGEgYnVmZmVyIG9yIHN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlIGhlYWRlciwgZGVjb2RlcyBpdCBhbmRcbiAqIHJldHVybnMgdGhlIGRlY29kZWQgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBidWZPclN0cmluZ1xuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEBtZW1iZXJvZiBNdWx0aWJhc2VcbiAqXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoYnVmT3JTdHJpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZPclN0cmluZykpIHtcbiAgICBidWZPclN0cmluZyA9IGJ1Zk9yU3RyaW5nLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSBidWZPclN0cmluZy5zdWJzdHJpbmcoMCwgMSlcbiAgYnVmT3JTdHJpbmcgPSBidWZPclN0cmluZy5zdWJzdHJpbmcoMSwgYnVmT3JTdHJpbmcubGVuZ3RoKVxuXG4gIGlmICh0eXBlb2YgYnVmT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmT3JTdHJpbmcgPSBCdWZmZXIuZnJvbShidWZPclN0cmluZylcbiAgfVxuXG4gIGNvbnN0IGJhc2UgPSBnZXRCYXNlKGNvZGUpXG4gIHJldHVybiBCdWZmZXIuZnJvbShiYXNlLmRlY29kZShidWZPclN0cmluZy50b1N0cmluZygpKSlcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0YSBtdWx0aWJhc2UgZW5jb2RlZD9cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGJ1Zk9yU3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBtZW1iZXJvZiBNdWx0aWJhc2VcbiAqL1xuZnVuY3Rpb24gaXNFbmNvZGVkIChidWZPclN0cmluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1Zk9yU3RyaW5nKSkge1xuICAgIGJ1Zk9yU3RyaW5nID0gYnVmT3JTdHJpbmcudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gRW5zdXJlIGJ1Zk9yU3RyaW5nIGlzIGEgc3RyaW5nXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYnVmT3JTdHJpbmcpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgY29kZSA9IGJ1Zk9yU3RyaW5nLnN1YnN0cmluZygwLCAxKVxuICB0cnkge1xuICAgIGNvbnN0IGJhc2UgPSBnZXRCYXNlKGNvZGUpXG4gICAgcmV0dXJuIGJhc2UubmFtZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRFbmNvZGUgKG5hbWUsIGJ1Zikge1xuICBjb25zdCBiYXNlID0gZ2V0QmFzZShuYW1lKVxuICBiYXNlLmRlY29kZShidWYudG9TdHJpbmcoKSlcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZSAobmFtZU9yQ29kZSkge1xuICBsZXQgYmFzZVxuXG4gIGlmIChjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV0pIHtcbiAgICBiYXNlID0gY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSBpZiAoY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdKSB7XG4gICAgYmFzZSA9IGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXVxuICB9IGVsc2Uge1xuICAgIHRocm93IGVyck5vdFN1cHBvcnRlZFxuICB9XG5cbiAgaWYgKCFiYXNlLmlzSW1wbGVtZW50ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFzZSAnICsgbmFtZU9yQ29kZSArICcgaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cblxuICByZXR1cm4gYmFzZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvZGVjID0gcmVxdWlyZSgnLi9jb2RlYycpXG5jb25zdCBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scy10YWJsZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBbbXVsdGlhZGRyXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkcikgZnJvbVxuICogYSBCdWZmZXIsIFN0cmluZyBvciBhbm90aGVyIE11bHRpYWRkciBpbnN0YW5jZVxuICogcHVibGljIGtleS5cbiAqIEBjbGFzcyBNdWx0aWFkZHJcbiAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXJ8TXVsdGlhZGRyKX0gYWRkciAtIElmIFN0cmluZyBvciBCdWZmZXIsIG5lZWRzIHRvIGFkaGVyZVxuICogdG8gdGhlIGFkZHJlc3MgZm9ybWF0IG9mIGEgW211bHRpYWRkcl0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWFkZHIjc3RyaW5nLWZvcm1hdClcbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICovXG5jb25zdCBNdWx0aWFkZHIgPSB3aXRoSXMucHJvdG8oZnVuY3Rpb24gKGFkZHIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpYWRkcikpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpYWRkcihhZGRyKVxuICB9XG5cbiAgLy8gZGVmYXVsdFxuICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgYWRkciA9ICcnXG4gIH1cblxuICBpZiAoYWRkciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9IC0gVGhlIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBtdWx0aWFkZHJlc3NcbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlciA9IGNvZGVjLmZyb21CdWZmZXIoYWRkcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWRkciA9PT0gJ3N0cmluZycgfHwgYWRkciBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGlmIChhZGRyLmxlbmd0aCA+IDAgJiYgYWRkci5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWFkZHIgXCIke2FkZHJ9XCIgbXVzdCBzdGFydCB3aXRoIGEgXCIvXCJgKVxuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciA9IGNvZGVjLmZyb21TdHJpbmcoYWRkcilcbiAgfSBlbHNlIGlmIChhZGRyLmJ1ZmZlciAmJiBhZGRyLnByb3RvcyAmJiBhZGRyLnByb3RvQ29kZXMpIHsgLy8gTXVsdGlhZGRyXG4gICAgdGhpcy5idWZmZXIgPSBjb2RlYy5mcm9tQnVmZmVyKGFkZHIuYnVmZmVyKSAvLyB2YWxpZGF0ZSArIGNvcHkgYnVmZmVyXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyIG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgYW5vdGhlciBNdWx0aWFkZHInKVxuICB9XG59LCB7IGNsYXNzTmFtZTogJ011bHRpYWRkcicsIHN5bWJvbE5hbWU6ICdAbXVsdGlmb3JtYXRzL2pzLW11bHRpYWRkci9tdWx0aWFkZHInIH0pXG5cbi8qKlxuICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBTdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS50b1N0cmluZygpXG4gKiAvLyAnL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnXG4gKi9cbk11bHRpYWRkci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBjb2RlYy5idWZmZXJUb1N0cmluZyh0aGlzLmJ1ZmZlcilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIEpTT04gZW5jb2RlZCBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqIEpTT04uc3RyaW5naWZ5KE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKSlcbiAqIC8vICcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMSdcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS50b0pTT04gPSBNdWx0aWFkZHIucHJvdG90eXBlLnRvU3RyaW5nXG5cbi8qKlxuICogUmV0dXJucyBNdWx0aWFkZHIgYXMgYSBjb252aW5pZW50IG9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgd2l0aCBuZXQuY3JlYXRlQ29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIHt7ZmFtaWx5OiBTdHJpbmcsIGhvc3Q6IFN0cmluZywgdHJhbnNwb3J0OiBTdHJpbmcsIHBvcnQ6IFN0cmluZ319XG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLnRvT3B0aW9ucygpXG4gKiAvLyB7IGZhbWlseTogJ2lwdjQnLCBob3N0OiAnMTI3LjAuMC4xJywgdHJhbnNwb3J0OiAndGNwJywgcG9ydDogJzQwMDEnIH1cbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS50b09wdGlvbnMgPSBmdW5jdGlvbiB0b09wdGlvbnMgKCkge1xuICBjb25zdCBvcHRzID0ge31cbiAgY29uc3QgcGFyc2VkID0gdGhpcy50b1N0cmluZygpLnNwbGl0KCcvJylcbiAgb3B0cy5mYW1pbHkgPSBwYXJzZWRbMV0gPT09ICdpcDQnID8gJ2lwdjQnIDogJ2lwdjYnXG4gIG9wdHMuaG9zdCA9IHBhcnNlZFsyXVxuICBvcHRzLnRyYW5zcG9ydCA9IHBhcnNlZFszXVxuICBvcHRzLnBvcnQgPSBwYXJzZWRbNF1cbiAgcmV0dXJuIG9wdHNcbn1cblxuLyoqXG4gKiBSZXR1cm5zIE11bHRpYWRkciBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLmluc3BlY3QoKVxuICogLy8gJzxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPidcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHJldHVybiAnPE11bHRpYWRkciAnICtcbiAgICB0aGlzLmJ1ZmZlci50b1N0cmluZygnaGV4JykgKyAnIC0gJyArXG4gICAgY29kZWMuYnVmZmVyVG9TdHJpbmcodGhpcy5idWZmZXIpICsgJz4nXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdG9jb2xzIHRoZSBNdWx0aWFkZHIgaXMgZGVmaW5lZCB3aXRoLCBhcyBhbiBhcnJheSBvZiBvYmplY3RzLCBpblxuICogbGVmdC10by1yaWdodCBvcmRlci4gRWFjaCBvYmplY3QgY29udGFpbnMgdGhlIHByb3RvY29sIGNvZGUsIHByb3RvY29sIG5hbWUsXG4gKiBhbmQgdGhlIHNpemUgb2YgaXRzIGFkZHJlc3Mgc3BhY2UgaW4gYml0cy5cbiAqIFtTZWUgbGlzdCBvZiBwcm90b2NvbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGlhZGRyL2Jsb2IvbWFzdGVyL3Byb3RvY29scy5jc3YpXG4gKlxuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fSBwcm90b2NvbHMgLSBBbGwgdGhlIHByb3RvY29scyB0aGUgYWRkcmVzcyBpcyBjb21wb3NlZCBvZlxuICogQHJldHVybnMge051bWJlcn0gcHJvdG9jb2xzW10uY29kZVxuICogQHJldHVybnMge051bWJlcn0gcHJvdG9jb2xzW10uc2l6ZVxuICogQHJldHVybnMge1N0cmluZ30gcHJvdG9jb2xzW10ubmFtZVxuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5wcm90b3MoKVxuICogLy8gWyB7IGNvZGU6IDQsIHNpemU6IDMyLCBuYW1lOiAnaXA0JyB9LFxuICogLy8gICB7IGNvZGU6IDYsIHNpemU6IDE2LCBuYW1lOiAndGNwJyB9IF1cbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5wcm90b3MgPSBmdW5jdGlvbiBwcm90b3MgKCkge1xuICByZXR1cm4gdGhpcy5wcm90b0NvZGVzKCkubWFwKGNvZGUgPT4gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG9jb2xzKGNvZGUpKSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb2RlcyBvZiB0aGUgcHJvdG9jb2xzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gKiBbU2VlIGxpc3Qgb2YgcHJvdG9jb2xzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkci9ibG9iL21hc3Rlci9wcm90b2NvbHMuY3N2KVxuICpcbiAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gcHJvdG9jb2wgY29kZXNcbiAqIEBleGFtcGxlXG4gKiBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJykucHJvdG9Db2RlcygpXG4gKiAvLyBbIDQsIDYgXVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnByb3RvQ29kZXMgPSBmdW5jdGlvbiBwcm90b0NvZGVzICgpIHtcbiAgY29uc3QgY29kZXMgPSBbXVxuICBjb25zdCBidWYgPSB0aGlzLmJ1ZmZlclxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBidWYubGVuZ3RoKSB7XG4gICAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmLCBpKVxuICAgIGNvbnN0IG4gPSB2YXJpbnQuZGVjb2RlLmJ5dGVzXG5cbiAgICBjb25zdCBwID0gcHJvdG9jb2xzKGNvZGUpXG4gICAgY29uc3Qgc2l6ZSA9IGNvZGVjLnNpemVGb3JBZGRyKHAsIGJ1Zi5zbGljZShpICsgbikpXG5cbiAgICBpICs9IChzaXplICsgbilcbiAgICBjb2Rlcy5wdXNoKGNvZGUpXG4gIH1cblxuICByZXR1cm4gY29kZXNcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgcHJvdG9jb2xzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gKiBbU2VlIGxpc3Qgb2YgcHJvdG9jb2xzXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYWRkci9ibG9iL21hc3Rlci9wcm90b2NvbHMuY3N2KVxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBwcm90b2NvbCBuYW1lc1xuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKS5wcm90b05hbWVzKClcbiAqIC8vIFsgJ2lwNCcsICd0Y3AnIF1cbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5wcm90b05hbWVzID0gZnVuY3Rpb24gcHJvdG9OYW1lcyAoKSB7XG4gIHJldHVybiB0aGlzLnByb3RvcygpLm1hcChwcm90byA9PiBwcm90by5uYW1lKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSBvZiBwYXJ0c1xuICpcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheT59IHR1cGxlc1xuICogQHJldHVybiB7TnVtYmVyfSB0dXBsZXNbXS4wIGNvZGUgb2YgcHJvdG9jb2xcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdHVwbGVzW10uMSBjb250ZW50cyBvZiBhZGRyZXNzXG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKFwiL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDFcIikudHVwbGVzKClcbiAqIC8vIFsgWyA0LCA8QnVmZmVyIDdmIDAwIDAwIDAxPiBdLCBbIDYsIDxCdWZmZXIgMGYgYTE+IF0gXVxuICovXG5NdWx0aWFkZHIucHJvdG90eXBlLnR1cGxlcyA9IGZ1bmN0aW9uIHR1cGxlcyAoKSB7XG4gIHJldHVybiBjb2RlYy5idWZmZXJUb1R1cGxlcyh0aGlzLmJ1ZmZlcilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgb2Ygc3RyaW5nL251bWJlciBwYXJ0c1xuICpcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheT59IHR1cGxlc1xuICogQHJldHVybiB7TnVtYmVyfSB0dXBsZXNbXS4wIGNvZGUgb2YgcHJvdG9jb2xcbiAqIEByZXR1cm4geyhTdHJpbmd8TnVtYmVyKX0gdHVwbGVzW10uMSBjb250ZW50cyBvZiBhZGRyZXNzXG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKFwiL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDFcIikuc3RyaW5nVHVwbGVzKClcbiAqIC8vIFsgWyA0LCAnMTI3LjAuMC4xJyBdLCBbIDYsIDQwMDEgXSBdXG4gKi9cbk11bHRpYWRkci5wcm90b3R5cGUuc3RyaW5nVHVwbGVzID0gZnVuY3Rpb24gc3RyaW5nVHVwbGVzICgpIHtcbiAgY29uc3QgdCA9IGNvZGVjLmJ1ZmZlclRvVHVwbGVzKHRoaXMuYnVmZmVyKVxuICByZXR1cm4gY29kZWMudHVwbGVzVG9TdHJpbmdUdXBsZXModClcbn1cblxuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgYSBNdWx0aWFkZHIgaW4gYW5vdGhlciBNdWx0aWFkZHJcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkciAtIE11bHRpYWRkciB0byBhZGQgaW50byB0aGlzIE11bHRpYWRkclxuICogQHJldHVybiB7TXVsdGlhZGRyfVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAqXG4gKiBjb25zdCBtaDIgPSBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICpcbiAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzgwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC84LjguOC44L3RjcC8xMDgwL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKlxuICogbWgzLnRvU3RyaW5nKClcbiAqIC8vICcvaXA0LzguOC44LjgvdGNwLzEwODAvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMSdcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5lbmNhcHN1bGF0ZSA9IGZ1bmN0aW9uIGVuY2Fwc3VsYXRlIChhZGRyKSB7XG4gIGFkZHIgPSBNdWx0aWFkZHIoYWRkcilcbiAgcmV0dXJuIE11bHRpYWRkcih0aGlzLnRvU3RyaW5nKCkgKyBhZGRyLnRvU3RyaW5nKCkpXG59XG5cbi8qKlxuICogRGVjYXBzdWxhdGVzIGEgTXVsdGlhZGRyIGZyb20gYW5vdGhlciBNdWx0aWFkZHJcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkciAtIE11bHRpYWRkciB0byByZW1vdmUgZnJvbSB0aGlzIE11bHRpYWRkclxuICogQHJldHVybiB7TXVsdGlhZGRyfVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAqXG4gKiBjb25zdCBtaDIgPSBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICpcbiAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gKiAvLyA8TXVsdGlhZGRyIDA0MDgwODA4MDgwNjA0MzgwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC84LjguOC44L3RjcC8xMDgwL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKlxuICogbWgzLmRlY2Fwc3VsYXRlKG1oMikudG9TdHJpbmcoKVxuICogLy8gJy9pcDQvOC44LjguOC90Y3AvMTA4MCdcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5kZWNhcHN1bGF0ZSA9IGZ1bmN0aW9uIGRlY2Fwc3VsYXRlIChhZGRyKSB7XG4gIGFkZHIgPSBhZGRyLnRvU3RyaW5nKClcbiAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKVxuICBjb25zdCBpID0gcy5sYXN0SW5kZXhPZihhZGRyKVxuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgJyArIHRoaXMgKyAnIGRvZXMgbm90IGNvbnRhaW4gc3ViYWRkcmVzczogJyArIGFkZHIpXG4gIH1cbiAgcmV0dXJuIE11bHRpYWRkcihzLnNsaWNlKDAsIGkpKVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHBlZXJJZCBpZiB0aGUgbXVsdGlhZGRyIGNvbnRhaW5zIG9uZVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfSBwZWVySWQgLSBUaGUgaWQgb2YgdGhlIHBlZXIgb3IgbnVsbCBpZiBpbnZhbGlkIG9yIG1pc3NpbmcgZnJvbSB0aGUgbWFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtaDEgPSBNdWx0aWFkZHIoJy9pcDQvOC44LjguOC90Y3AvMTA4MC9pcGZzL1FtVmFsaWRCYXNlNThzdHJpbmcnKVxuICogLy8gPE11bHRpYWRkciAwNDA4MDgwODA4MDYwNDM4IC0gL2lwNC84LjguOC44L3RjcC8xMDgwL2lwZnMvUW1WYWxpZEJhc2U1OHN0cmluZz5cbiAqXG4gKiAvLyBzaG91bGQgcmV0dXJuIFFtVmFsaWRCYXNlNThzdHJpbmcgb3IgbnVsbCBpZiB0aGUgaWQgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gKiBjb25zdCBwZWVySWQgPSBtaDEuZ2V0UGVlcklkKClcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5nZXRQZWVySWQgPSBmdW5jdGlvbiBnZXRQZWVySWQgKCkge1xuICBsZXQgYjU4c3RyID0gbnVsbFxuICB0cnkge1xuICAgIGI1OHN0ciA9IHRoaXMuc3RyaW5nVHVwbGVzKCkuZmlsdGVyKCh0dXBsZSkgPT4ge1xuICAgICAgaWYgKHR1cGxlWzBdID09PSBwcm90b2NvbHMubmFtZXMuaXBmcy5jb2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlbMF1bMV1cblxuICAgIGJzNTguZGVjb2RlKGI1OHN0cilcbiAgfSBjYXRjaCAoZSkge1xuICAgIGI1OHN0ciA9IG51bGxcbiAgfVxuXG4gIHJldHVybiBiNThzdHJcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSBwYXRoIGlmIHRoZSBtdWx0aWFkZHIgY29udGFpbnMgb25lXG4gKlxuICogQHJldHVybiB7U3RyaW5nfG51bGx9IHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgbXVsdGlhZGRyLCBvciBudWxsIGlmIG5vIHBhdGggcHJvdG9jb2wgaXMgcHJlc2VudFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwL3VuaXgvdG1wL3AycC5zb2NrJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MC91bml4L3RtcC9wMnAuc29jaz5cbiAqXG4gKiAvLyBzaG91bGQgcmV0dXJuIHV0Zjggc3RyaW5nIG9yIG51bGwgaWYgdGhlIGlkIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICogY29uc3QgcGF0aCA9IG1oMS5nZXRQYXRoKClcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCAoKSB7XG4gIGxldCBwYXRoID0gbnVsbFxuICB0cnkge1xuICAgIHBhdGggPSB0aGlzLnN0cmluZ1R1cGxlcygpLmZpbHRlcigodHVwbGUpID0+IHtcbiAgICAgIGNvbnN0IHByb3RvID0gcHJvdG9jb2xzKHR1cGxlWzBdKVxuICAgICAgaWYgKHByb3RvLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVswXVsxXVxuICB9IGNhdGNoIChlKSB7XG4gICAgcGF0aCA9IG51bGxcbiAgfVxuXG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBNdWx0aWFkZHJzIGFyZSB0aGUgc2FtZVxuICpcbiAqIEBwYXJhbSB7TXVsdGlhZGRyfSBhZGRyXG4gKiBAcmV0dXJuIHtCb29sfVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC84LjguOC44L3RjcC8xMDgwJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQwODA4MDgwODA2MDQzOCAtIC9pcDQvOC44LjguOC90Y3AvMTA4MD5cbiAqXG4gKiBjb25zdCBtaDIgPSBNdWx0aWFkZHIoJy9pcDQvMTI3LjAuMC4xL3RjcC80MDAxJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICpcbiAqIG1oMS5lcXVhbHMobWgxKVxuICogLy8gdHJ1ZVxuICpcbiAqIG1oMS5lcXVhbHMobWgyKVxuICogLy8gZmFsc2VcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGFkZHIpIHtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyLmVxdWFscyhhZGRyLmJ1ZmZlcilcbn1cblxuLyoqXG4gKiBHZXRzIGEgTXVsdGlhZGRycyBub2RlLWZyaWVuZGx5IGFkZHJlc3Mgb2JqZWN0LiBOb3RlIHRoYXQgcHJvdG9jb2wgaW5mb3JtYXRpb25cbiAqIGlzIGxlZnQgb3V0OiBpbiBOb2RlIChhbmQgbW9zdCBuZXR3b3JrIHN5c3RlbXMpIHRoZSBwcm90b2NvbCBpcyB1bmtub3dhYmxlXG4gKiBnaXZlbiBvbmx5IHRoZSBhZGRyZXNzLlxuICpcbiAqIEhhcyB0byBiZSBhIFRoaW5XYWlzdCBBZGRyZXNzLCBvdGhlcndpc2UgdGhyb3dzIGVycm9yXG4gKlxuICogQHJldHVybnMge3tmYW1pbHk6IFN0cmluZywgYWRkcmVzczogU3RyaW5nLCBwb3J0OiBTdHJpbmd9fVxuICogQHRocm93cyB7RXJyb3J9IFRocm93cyBlcnJvciBpZiBNdWx0aWFkZHIgaXMgbm90IGEgVGhpbiBXYWlzdCBhZGRyZXNzXG4gKiBAZXhhbXBsZVxuICogTXVsdGlhZGRyKCcvaXA0LzEyNy4wLjAuMS90Y3AvNDAwMScpLm5vZGVBZGRyZXNzKClcbiAqIC8vIHtmYW1pbHk6ICdJUHY0JywgYWRkcmVzczogJzEyNy4wLjAuMScsIHBvcnQ6ICc0MDAxJ31cbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5ub2RlQWRkcmVzcyA9IGZ1bmN0aW9uIG5vZGVBZGRyZXNzICgpIHtcbiAgY29uc3QgY29kZXMgPSB0aGlzLnByb3RvQ29kZXMoKVxuICBjb25zdCBuYW1lcyA9IHRoaXMucHJvdG9OYW1lcygpXG4gIGNvbnN0IHBhcnRzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KCcvJykuc2xpY2UoMSlcblxuICBpZiAocGFydHMubGVuZ3RoIDwgNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlhZGRyIG11c3QgaGF2ZSBhIHZhbGlkIGZvcm1hdDogXCIve2lwNCwgaXA2LCBkbnM0LCBkbnM2fS97YWRkcmVzc30ve3RjcCwgdWRwfS97cG9ydH1cIi4nKVxuICB9IGVsc2UgaWYgKGNvZGVzWzBdICE9PSA0ICYmIGNvZGVzWzBdICE9PSA0MSAmJiBjb2Rlc1swXSAhPT0gNTQgJiYgY29kZXNbMF0gIT09IDU1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcm90b2NvbCB3aXRoIG5hbWU6IFwiJyR7bmFtZXNbMF19J1wiLiBNdXN0IGhhdmUgYSB2YWxpZCBmYW1pbHkgbmFtZTogXCJ7aXA0LCBpcDYsIGRuczQsIGRuczZ9XCIuYClcbiAgfSBlbHNlIGlmIChwYXJ0c1syXSAhPT0gJ3RjcCcgJiYgcGFydHNbMl0gIT09ICd1ZHAnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcm90b2NvbCB3aXRoIG5hbWU6IFwiJyR7bmFtZXNbMV19J1wiLiBNdXN0IGhhdmUgYSB2YWxpZCB0cmFuc3BvcnQgcHJvdG9jb2w6IFwie3RjcCwgdWRwfVwiLmApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZhbWlseTogKGNvZGVzWzBdID09PSA0MSB8fCBjb2Rlc1swXSA9PT0gNTUpID8gNiA6IDQsXG4gICAgYWRkcmVzczogcGFydHNbMV0sIC8vIGlwIGFkZHJcbiAgICBwb3J0OiBwYXJ0c1szXSAvLyB0Y3Agb3IgdWRwIHBvcnRcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBNdWx0aWFkZHIgZnJvbSBhIG5vZGUtZnJpZW5kbHkgYWRkcmVzcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkclxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydFxuICogQHJldHVybnMge011bHRpYWRkcn0gbXVsdGlhZGRyXG4gKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGVycm9yIGlmIGFkZHIgaXMgbm90IHRydXRoeVxuICogQHRocm93cyB7RXJyb3J9IFRocm93cyBlcnJvciBpZiB0cmFuc3BvcnQgaXMgbm90IHRydXRoeVxuICogQGV4YW1wbGVcbiAqIE11bHRpYWRkci5mcm9tTm9kZUFkZHJlc3Moe2FkZHJlc3M6ICcxMjcuMC4wLjEnLCBwb3J0OiAnNDAwMSd9LCAndGNwJylcbiAqIC8vIDxNdWx0aWFkZHIgMDQ3ZjAwMDAwMTA2MGZhMSAtIC9pcDQvMTI3LjAuMC4xL3RjcC80MDAxPlxuICovXG5NdWx0aWFkZHIuZnJvbU5vZGVBZGRyZXNzID0gZnVuY3Rpb24gZnJvbU5vZGVBZGRyZXNzIChhZGRyLCB0cmFuc3BvcnQpIHtcbiAgaWYgKCFhZGRyKSB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIG5vZGUgYWRkcmVzcyBvYmplY3QnKVxuICBpZiAoIXRyYW5zcG9ydCkgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyB0cmFuc3BvcnQgcHJvdG9jb2wnKVxuICBjb25zdCBpcCA9IChhZGRyLmZhbWlseSA9PT0gJ0lQdjYnKSA/ICdpcDYnIDogJ2lwNCdcbiAgcmV0dXJuIE11bHRpYWRkcignLycgKyBbaXAsIGFkZHIuYWRkcmVzcywgdHJhbnNwb3J0LCBhZGRyLnBvcnRdLmpvaW4oJy8nKSlcbn1cblxuLy8gVE9ETyBmaW5kIGEgYmV0dGVyIGV4YW1wbGUsIG5vdCBzdXJlIGFib3V0IGl0J3MgZ29vZCBlbm91Z2hcbi8qKlxuICogUmV0dXJucyBpZiBhIE11bHRpYWRkciBpcyBhIFRoaW4gV2Fpc3QgYWRkcmVzcyBvciBub3QuXG4gKlxuICogVGhpbiBXYWlzdCBpcyBpZiBhIE11bHRpYWRkciBhZGhlcmVzIHRvIHRoZSBzdGFuZGFyZCBjb21iaW5hdGlvbiBvZjpcbiAqXG4gKiBge0lQdjQsIElQdjZ9L3tUQ1AsIFVEUH1gXG4gKlxuICogQHBhcmFtIHtNdWx0aWFkZHJ9IFthZGRyXSAtIERlZmF1bHRzIHRvIHVzaW5nIGB0aGlzYCBpbnN0YW5jZVxuICogQHJldHVybnMge0Jvb2xlYW59IGlzVGhpbldhaXN0QWRkcmVzc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1oMSA9IE11bHRpYWRkcignL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNDdmMDAwMDAxMDYwZmExIC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDE+XG4gKiBjb25zdCBtaDIgPSBNdWx0aWFkZHIoJy9pcDQvMTkyLjE2OC4yLjEvdGNwLzUwMDEnKVxuICogLy8gPE11bHRpYWRkciAwNGMwYTgwMjAxMDYxMzg5IC0gL2lwNC8xOTIuMTY4LjIuMS90Y3AvNTAwMT5cbiAqIGNvbnN0IG1oMyA9IG1oMS5lbmNhcHN1bGF0ZShtaDIpXG4gKiAvLyA8TXVsdGlhZGRyIDA0N2YwMDAwMDEwNjBmYTEwNGMwYTgwMjAxMDYxMzg5IC0gL2lwNC8xMjcuMC4wLjEvdGNwLzQwMDEvaXA0LzE5Mi4xNjguMi4xL3RjcC81MDAxPlxuICogbWgxLmlzVGhpbldhaXN0QWRkcmVzcygpXG4gKiAvLyB0cnVlXG4gKiBtaDIuaXNUaGluV2Fpc3RBZGRyZXNzKClcbiAqIC8vIHRydWVcbiAqIG1oMy5pc1RoaW5XYWlzdEFkZHJlc3MoKVxuICogLy8gZmFsc2VcbiAqL1xuTXVsdGlhZGRyLnByb3RvdHlwZS5pc1RoaW5XYWlzdEFkZHJlc3MgPSBmdW5jdGlvbiBpc1RoaW5XYWlzdEFkZHJlc3MgKGFkZHIpIHtcbiAgY29uc3QgcHJvdG9zID0gKGFkZHIgfHwgdGhpcykucHJvdG9zKClcblxuICBpZiAocHJvdG9zLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHByb3Rvc1swXS5jb2RlICE9PSA0ICYmIHByb3Rvc1swXS5jb2RlICE9PSA0MSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChwcm90b3NbMV0uY29kZSAhPT0gNiAmJiBwcm90b3NbMV0uY29kZSAhPT0gMjczKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyB0YWJsZSwgbmFtZXMgYW5kIGNvZGVzIG9mIGFsbCBzdXBwb3J0ZWQgcHJvdG9jb2xzLlxuICogVG8gZ2V0IHRoZSBwcm90b2NvbCB2YWx1ZXMgZnJvbSBhIE11bHRpYWRkciwgeW91IGNhbiB1c2VcbiAqIFtgLnByb3RvcygpYF0oI211bHRpYWRkcnByb3RvcyksXG4gKiBbYC5wcm90b0NvZGVzKClgXSgjbXVsdGlhZGRycHJvdG9jb2Rlcykgb3JcbiAqIFtgLnByb3RvTmFtZXMoKWBdKCNtdWx0aWFkZHJwcm90b25hbWVzKVxuICpcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybnMge3t0YWJsZTogQXJyYXksIG5hbWVzOiBPYmplY3QsIGNvZGVzOiBPYmplY3R9fVxuICpcbiAqL1xuTXVsdGlhZGRyLnByb3RvY29scyA9IHByb3RvY29sc1xuXG4vKipcbiAqIFJldHVybnMgaWYgc29tZXRoaW5nIGlzIGEgTXVsdGlhZGRyIHRoYXQgaXMgYSBuYW1lXG4gKlxuICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAqIEByZXR1cm4ge0Jvb2x9IGlzTmFtZVxuICovXG5NdWx0aWFkZHIuaXNOYW1lID0gZnVuY3Rpb24gaXNOYW1lIChhZGRyKSB7XG4gIGlmICghTXVsdGlhZGRyLmlzTXVsdGlhZGRyKGFkZHIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBpZiBhIHBhcnQgb2YgdGhlIG11bHRpYWRkciBpcyByZXNvbHZhYmxlLCB0aGVuIHJldHVybiB0cnVlXG4gIHJldHVybiBhZGRyLnByb3RvcygpLnNvbWUoKHByb3RvKSA9PiBwcm90by5yZXNvbHZhYmxlKVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbXVsdGlhZGRycywgYnkgcmVzb2x2aW5nIHRoZSBtdWx0aWFkZHIgdGhhdCBpcyBhIG5hbWVcbiAqXG4gKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkclxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtCb29sfSBpc05hbWVcbiAqL1xuTXVsdGlhZGRyLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChhZGRyLCBjYWxsYmFjaykge1xuICBpZiAoIU11bHRpYWRkci5pc011bHRpYWRkcihhZGRyKSB8fCAhTXVsdGlhZGRyLmlzTmFtZShhZGRyKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ25vdCBhIHZhbGlkIG5hbWUnKSlcbiAgfVxuXG4gIC8qXG4gICAqIE5lZWRzIG1vcmUgY29uc2lkZXJhdGlvbiBmcm9tIHNwZWMgZGVzaWduOlxuICAgKiAgIC0gd2hhdCB0byByZXR1cm5cbiAgICogICAtIGhvdyB0byBhY2hpZXZlIGl0IGluIHRoZSBicm93c2VyP1xuICAgKi9cbiAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkIHlldCcpKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNdWx0aWFkZHJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdhc3luYy9yZXRyeScpXG5jb25zdCB0b1VyaSA9IHJlcXVpcmUoJ211bHRpYWRkci10by11cmknKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHByZWxvYWQgPSByZXF1aXJlKCcuL3J1bnRpbWUvcHJlbG9hZC1ub2RlanMnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnaXBmczpwcmVsb2FkJylcbmxvZy5lcnJvciA9IGRlYnVnKCdpcGZzOnByZWxvYWQ6ZXJyb3InKVxuXG5jb25zdCBub29wID0gKGVycikgPT4geyBpZiAoZXJyKSBsb2cuZXJyb3IoZXJyKSB9XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZiA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzZWxmLl9vcHRpb25zLnByZWxvYWQgfHwge31cbiAgb3B0aW9ucy5lbmFibGVkID0gQm9vbGVhbihvcHRpb25zLmVuYWJsZWQpXG4gIG9wdGlvbnMuYWRkcmVzc2VzID0gb3B0aW9ucy5hZGRyZXNzZXMgfHwgW11cblxuICBpZiAoIW9wdGlvbnMuZW5hYmxlZCB8fCAhb3B0aW9ucy5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgbG9nKCdwcmVsb2FkIGRpc2FibGVkJylcbiAgICBjb25zdCBhcGkgPSAoXywgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgIH1cbiAgICB9XG4gICAgYXBpLnN0YXJ0ID0gKCkgPT4ge31cbiAgICBhcGkuc3RvcCA9ICgpID0+IHt9XG4gICAgcmV0dXJuIGFwaVxuICB9XG5cbiAgbGV0IHN0b3BwZWQgPSB0cnVlXG4gIGxldCByZXF1ZXN0cyA9IFtdXG4gIGNvbnN0IGFwaVVyaXMgPSBvcHRpb25zLmFkZHJlc3Nlcy5tYXAoYXBpQWRkclRvVXJpKVxuXG4gIGNvbnN0IGFwaSA9IChjaWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wXG5cbiAgICBpZiAodHlwZW9mIGNpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNpZCA9IG5ldyBDSUQoY2lkKS50b0Jhc2VFbmNvZGVkU3RyaW5nKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmFsbGJhY2tBcGlVcmlzID0gQXJyYXkuZnJvbShhcGlVcmlzKVxuICAgIGxldCByZXF1ZXN0XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gICAgcmV0cnkoeyB0aW1lczogZmFsbGJhY2tBcGlVcmlzLmxlbmd0aCB9LCAoY2IpID0+IHtcbiAgICAgIGlmIChzdG9wcGVkKSByZXR1cm4gY2IobmV3IEVycm9yKGBwcmVsb2FkIGFib3J0ZWQgZm9yICR7Y2lkfWApKVxuXG4gICAgICAvLyBSZW1vdmUgZmFpbGVkIHJlcXVlc3QgZnJvbSBhIHByZXZpb3VzIGF0dGVtcHRcbiAgICAgIHJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHIgPT4gciAhPT0gcmVxdWVzdClcblxuICAgICAgY29uc3QgYXBpVXJpID0gZmFsbGJhY2tBcGlVcmlzLnNoaWZ0KClcblxuICAgICAgcmVxdWVzdCA9IHByZWxvYWQoYCR7YXBpVXJpfS9hcGkvdjAvcmVmcz9yPXRydWUmYXJnPSR7Y2lkfWAsIGNiKVxuICAgICAgcmVxdWVzdHMgPSByZXF1ZXN0cy5jb25jYXQocmVxdWVzdClcbiAgICB9LCAoZXJyKSA9PiB7XG4gICAgICByZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcihyID0+IHIgIT09IHJlcXVlc3QpXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgbG9nKGBwcmVsb2FkZWQgJHtjaWR9IGluICR7RGF0ZS5ub3coKSAtIG5vd31tc2ApXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGFwaS5zdGFydCA9ICgpID0+IHtcbiAgICBzdG9wcGVkID0gZmFsc2VcbiAgfVxuXG4gIGFwaS5zdG9wID0gKCkgPT4ge1xuICAgIHN0b3BwZWQgPSB0cnVlXG4gICAgbG9nKGBjYW5jZWxpbmcgJHtyZXF1ZXN0cy5sZW5ndGh9IHBlbmRpbmcgcHJlbG9hZCByZXF1ZXN0KHMpYClcbiAgICByZXF1ZXN0cy5mb3JFYWNoKHIgPT4gci5jYW5jZWwoKSlcbiAgICByZXF1ZXN0cyA9IFtdXG4gIH1cblxuICByZXR1cm4gYXBpXG59XG5cbmZ1bmN0aW9uIGFwaUFkZHJUb1VyaSAoYWRkcikge1xuICBpZiAoIShhZGRyLmVuZHNXaXRoKCdodHRwJykgfHwgYWRkci5lbmRzV2l0aCgnaHR0cHMnKSkpIHtcbiAgICBhZGRyID0gYWRkciArICcvaHR0cCdcbiAgfVxuICByZXR1cm4gdG9VcmkoYWRkcilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWhhc2ggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpXG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGloYXNoaW5nXG5cbi8qKlxuICogSGFzaCB0aGUgZ2l2ZW4gYGJ1ZmAgdXNpbmcgdGhlIGFsZ29yaXRobSBzcGVjaWZpZWRcbiAqIGJ5IGBmdW5jYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIHZhbHVlIHRvIGhhc2guXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZ1bmMgLSBUaGUgYWxnb3JpdGhtIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSAtIE9wdGlvbmFsbHkgdHJpbSB0aGUgcmVzdWx0IHRvIHRoaXMgbGVuZ3RoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIE11bHRpaGFzaGluZyAoYnVmLCBmdW5jLCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsZW5ndGhcbiAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2snKVxuICB9XG5cbiAgTXVsdGloYXNoaW5nLmRpZ2VzdChidWYsIGZ1bmMsIGxlbmd0aCwgKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBtdWx0aWhhc2guZW5jb2RlKGRpZ2VzdCwgZnVuYywgbGVuZ3RoKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBUaGUgYGJ1ZmZlcmAgbW9kdWxlIGZvciBlYXN5IHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAdHlwZSB7QnVmZmVyfVxuICovXG5NdWx0aWhhc2hpbmcuQnVmZmVyID0gQnVmZmVyIC8vIGZvciBicm93c2VyIHRoaW5nc1xuXG4vKipcbiAqIEV4cG9zZSBtdWx0aWhhc2ggaXRzZWxmLCB0byBhdm9pZCBzaWxseSBkb3VibGUgcmVxdWlyZXMuXG4gKi9cbk11bHRpaGFzaGluZy5tdWx0aWhhc2ggPSBtdWx0aWhhc2hcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gVGhlIHZhbHVlIHRvIGhhc2guXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZ1bmMgLSBUaGUgYWxnb3JpdGhtIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSAtIE9wdGlvbmFsbHkgdHJpbSB0aGUgcmVzdWx0IHRvIHRoaXMgbGVuZ3RoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQnVmZmVyKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbk11bHRpaGFzaGluZy5kaWdlc3QgPSBmdW5jdGlvbiAoYnVmLCBmdW5jLCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsZW5ndGhcbiAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2snKVxuICB9XG5cbiAgbGV0IGNiID0gY2FsbGJhY2tcbiAgaWYgKGxlbmd0aCkge1xuICAgIGNiID0gKGVyciwgZGlnZXN0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRpZ2VzdC5zbGljZSgwLCBsZW5ndGgpKVxuICAgIH1cbiAgfVxuXG4gIGxldCBoYXNoXG4gIHRyeSB7XG4gICAgaGFzaCA9IE11bHRpaGFzaGluZy5jcmVhdGVIYXNoKGZ1bmMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpXG4gIH1cblxuICBoYXNoKGJ1ZiwgY2IpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBmdW5jXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIFRoZSB0byBgZnVuY2AgY29ycmVzcG9uZGluZyBoYXNoIGZ1bmN0aW9uLlxuICovXG5NdWx0aWhhc2hpbmcuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGZ1bmMgPSBtdWx0aWhhc2guY29lcmNlQ29kZShmdW5jKVxuICBpZiAoIU11bHRpaGFzaGluZy5mdW5jdGlvbnNbZnVuY10pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBmdW5jdGlvbiAnICsgZnVuYyArICcgbm90IHlldCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgcmV0dXJuIE11bHRpaGFzaGluZy5mdW5jdGlvbnNbZnVuY11cbn1cblxuLyoqXG4gKiBNYXBwaW5nIG9mIG11bHRpaGFzaCBjb2RlcyB0byB0aGVpciBoYXNoaW5nIGZ1bmN0aW9ucy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk11bHRpaGFzaGluZy5mdW5jdGlvbnMgPSB7XG4gIC8vIHNoYTFcbiAgMHgxMTogY3J5cHRvLnNoYTEsXG4gIC8vIHNoYTItMjU2XG4gIDB4MTI6IGNyeXB0by5zaGEyMjU2LFxuICAvLyBzaGEyLTUxMlxuICAweDEzOiBjcnlwdG8uc2hhMjUxMixcbiAgLy8gc2hhMy01MTJcbiAgMHgxNDogY3J5cHRvLnNoYTM1MTIsXG4gIC8vIHNoYTMtMzg0XG4gIDB4MTU6IGNyeXB0by5zaGEzMzg0LFxuICAvLyBzaGEzLTI1NlxuICAweDE2OiBjcnlwdG8uc2hhMzI1NixcbiAgLy8gc2hhMy0yMjRcbiAgMHgxNzogY3J5cHRvLnNoYTMyMjQsXG4gIC8vIHNoYWtlLTEyOFxuICAweDE4OiBjcnlwdG8uc2hha2UxMjgsXG4gIC8vIHNoYWtlLTI1NlxuICAweDE5OiBjcnlwdG8uc2hha2UyNTYsXG4gIC8vIGtlY2Nhay0yMjRcbiAgMHgxQTogY3J5cHRvLmtlY2NhazIyNCxcbiAgLy8ga2VjY2FrLTI1NlxuICAweDFCOiBjcnlwdG8ua2VjY2FrMjU2LFxuICAvLyBrZWNjYWstMzg0XG4gIDB4MUM6IGNyeXB0by5rZWNjYWszODQsXG4gIC8vIGtlY2Nhay01MTJcbiAgMHgxRDogY3J5cHRvLmtlY2NhazUxMixcbiAgLy8gbXVybXVyMy0xMjhcbiAgMHgyMjogY3J5cHRvLm11cm11cjMxMjgsXG4gIC8vIG11cm11cjMtMzJcbiAgMHgyMzogY3J5cHRvLm11cm11cjMzMixcbiAgLy8gZGJsLXNoYTItMjU2XG4gIDB4NTY6IGNyeXB0by5kYmxTaGEyMjU2XG59XG5cbi8vIGFkZCBibGFrZSBmdW5jdGlvbnNcbmNyeXB0by5hZGRCbGFrZShNdWx0aWhhc2hpbmcuZnVuY3Rpb25zKVxuXG5NdWx0aWhhc2hpbmcudmFsaWRhdGUgPSAoZGF0YSwgaGFzaCwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGFsZ28gPSBtdWx0aWhhc2guZGVjb2RlKGhhc2gpLm5hbWVcbiAgTXVsdGloYXNoaW5nKGRhdGEsIGFsZ28sIChlcnIsIG5ld0hhc2gpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGNhbGxiYWNrKGVyciwgQnVmZmVyLmNvbXBhcmUoaGFzaCwgbmV3SGFzaCkgPT09IDApXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IG1lcmdlT3B0aW9ucyA9IHJlcXVpcmUoJ21lcmdlLW9wdGlvbnMnKVxuY29uc3QgaXBsZERhZ0Nib3IgPSByZXF1aXJlKCdpcGxkLWRhZy1jYm9yJylcbmNvbnN0IGlwbGREYWdQYiA9IHJlcXVpcmUoJ2lwbGQtZGFnLXBiJylcbmNvbnN0IGlwbGRSYXcgPSByZXF1aXJlKCdpcGxkLXJhdycpXG5cbm1vZHVsZS5leHBvcnRzID0gKGJsb2NrU2VydmljZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiBtZXJnZU9wdGlvbnMuY2FsbChcbiAgICAvLyBlbnN1cmUgd2UgaGF2ZSB0aGUgZGVmYXVsdHMgZm9ybWF0cyBldmVuIGlmIHRoZSB1c2VyIG92ZXJyaWRlcyBgZm9ybWF0czogW11gXG4gICAgeyBjb25jYXRBcnJheXM6IHRydWUgfSxcbiAgICB7XG4gICAgICBibG9ja1NlcnZpY2U6IGJsb2NrU2VydmljZSxcbiAgICAgIGZvcm1hdHM6IFtpcGxkRGFnQ2JvciwgaXBsZERhZ1BiLCBpcGxkUmF3XVxuICAgIH0sIG9wdGlvbnMpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IFJlcG9FcnJvcnMgPSByZXF1aXJlKCdpcGZzLXJlcG8nKS5lcnJvcnNcblxuLy8gQm9vdCBhbiBJUEZTIG5vZGUgZGVwZW5kaW5nIG9uIHRoZSBvcHRpb25zIHNldFxubW9kdWxlLmV4cG9ydHMgPSAoc2VsZikgPT4ge1xuICBzZWxmLmxvZygnYm9vdGluZycpXG4gIGNvbnN0IG9wdGlvbnMgPSBzZWxmLl9vcHRpb25zXG4gIGNvbnN0IGRvSW5pdCA9IG9wdGlvbnMuaW5pdFxuICBjb25zdCBkb1N0YXJ0ID0gb3B0aW9ucy5zdGFydFxuXG4gIC8vIERvIHRoZSBhY3R1YWwgYm9vdCBzZXF1ZW5jZVxuICB3YXRlcmZhbGwoW1xuICAgIC8vIENoZWNrcyBpZiBhIHJlcG8gZXhpc3RzLCBhbmQgaWYgc28gb3BlbnMgaXRcbiAgICAvLyBXaWxsIHJldHVybiBjYWxsYmFjayB3aXRoIGEgYm9vbCBpbmRpY2F0aW5nIHRoZSBleGlzdGVuY2VcbiAgICAvLyBvZiB0aGUgcmVwb1xuICAgIChjYikgPT4ge1xuICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgaWYgKCFzZWxmLl9yZXBvLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5fcmVwby5vcGVuKChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoaXNSZXBvVW5pbml0aWFsaXplZEVycm9yKGVycikpIHJldHVybiBjYihudWxsLCBmYWxzZSlcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgY2IobnVsbCwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICAocmVwb09wZW5lZCwgY2IpID0+IHtcbiAgICAgIC8vIEluaXQgd2l0aCBleGlzdGluZyBpbml0aWFsaXplZCwgb3BlbmVkLCByZXBvXG4gICAgICBpZiAocmVwb09wZW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5pbml0KHsgcmVwbzogc2VsZi5fcmVwbyB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKE9iamVjdC5hc3NpZ24oZXJyLCB7IGVtaXR0ZWQ6IHRydWUgfSkpXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoZG9Jbml0KSB7XG4gICAgICAgIGNvbnN0IGluaXRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7IGJpdHM6IDIwNDgsIHBhc3M6IHNlbGYuX29wdGlvbnMucGFzcyB9LFxuICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmluaXQgPT09ICdvYmplY3QnID8gb3B0aW9ucy5pbml0IDoge31cbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gc2VsZi5pbml0KGluaXRPcHRpb25zLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKE9iamVjdC5hc3NpZ24oZXJyLCB7IGVtaXR0ZWQ6IHRydWUgfSkpXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjYigpXG4gICAgfSxcbiAgICAoY2IpID0+IHtcbiAgICAgIC8vIE5vIHByb2JsZW0sIHdlIGRvbid0IGhhdmUgdG8gc3RhcnQgdGhlIG5vZGVcbiAgICAgIGlmICghZG9TdGFydCkge1xuICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgfVxuXG4gICAgICBzZWxmLnN0YXJ0KChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKE9iamVjdC5hc3NpZ24oZXJyLCB7IGVtaXR0ZWQ6IHRydWUgfSkpXG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgfVxuICBdLCAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKCFlcnIuZW1pdHRlZCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlbGYubG9nKCdib290ZWQnKVxuICAgIHNlbGYuZW1pdCgncmVhZHknKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc1JlcG9VbmluaXRpYWxpemVkRXJyb3IgKGVycikge1xuICBpZiAoIWVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgdGhlIGVycm9yIGlzIHRoYXQgbm8gcmVwbyBleGlzdHMsXG4gIC8vIHdoaWNoIGhhcHBlbnMgd2hlbiB0aGUgdmVyc2lvbiBmaWxlIGlzIG5vdCBmb3VuZFxuICAvLyB3ZSBqdXN0IHdhbnQgdG8gc2lnbmFsIHRoYXQgbm8gcmVwbyBleGlzdCwgbm90XG4gIC8vIGZhaWwgdGhlIHdob2xlIHByb2Nlc3MuXG5cbiAgLy8gVXNlIHN0YW5kYXJkaXplZCBlcnJvcnMgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICBpZiAoZXJyLmNvZGUgPT09IFJlcG9FcnJvcnMuRVJSX1JFUE9fTk9UX0lOSVRJQUxJWkVEKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFRPRE86IEFzIGVycm9yIGNvZGVzIGNvbnRpbnVlIHRvIGJlIHN0YW5kYXJkaXplZCwgdGhpcyBsb2dpYyBjYW4gYmUgcGhhc2Ugb3V0O1xuICAvLyBpdCBpcyBoZXJlIHRvIG1haW50YWluIGNvbXBhdGliaWxpdHlcbiAgaWYgKGVyci5tZXNzYWdlLm1hdGNoKC9ub3QgZm91bmQvKSB8fCAvLyBpbmRleGVkZGJcbiAgICBlcnIubWVzc2FnZS5tYXRjaCgvRU5PRU5ULykgfHwgLy8gZnNcbiAgICBlcnIubWVzc2FnZS5tYXRjaCgvTm8gdmFsdWUvKSAvLyBtZW1vcnlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGhtYWMgPSByZXF1aXJlKCcuL2htYWMnKVxuY29uc3QgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxuY29uc3Qga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5leHBvcnRzLmFlcyA9IGFlc1xuZXhwb3J0cy5obWFjID0gaG1hY1xuZXhwb3J0cy5rZXlzID0ga2V5c1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJlcXVpcmUoJy4vcmFuZG9tLWJ5dGVzJylcbmV4cG9ydHMucGJrZGYyID0gcmVxdWlyZSgnLi9wYmtkZjInKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucHJlU3RhcnQgPSByZXF1aXJlKCcuL3ByZS1zdGFydCcpXG5leHBvcnRzLnN0YXJ0ID0gcmVxdWlyZSgnLi9zdGFydCcpXG5leHBvcnRzLnN0b3AgPSByZXF1aXJlKCcuL3N0b3AnKVxuZXhwb3J0cy5pc09ubGluZSA9IHJlcXVpcmUoJy4vaXMtb25saW5lJylcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpXG5leHBvcnRzLmlkID0gcmVxdWlyZSgnLi9pZCcpXG5leHBvcnRzLnJlcG8gPSByZXF1aXJlKCcuL3JlcG8nKVxuZXhwb3J0cy5pbml0ID0gcmVxdWlyZSgnLi9pbml0JylcbmV4cG9ydHMuYm9vdHN0cmFwID0gcmVxdWlyZSgnLi9ib290c3RyYXAnKVxuZXhwb3J0cy5jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG5leHBvcnRzLmJsb2NrID0gcmVxdWlyZSgnLi9ibG9jaycpXG5leHBvcnRzLm9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0JylcbmV4cG9ydHMuZGFnID0gcmVxdWlyZSgnLi9kYWcnKVxuZXhwb3J0cy5saWJwMnAgPSByZXF1aXJlKCcuL2xpYnAycCcpXG5leHBvcnRzLnN3YXJtID0gcmVxdWlyZSgnLi9zd2FybScpXG5leHBvcnRzLnBpbmcgPSByZXF1aXJlKCcuL3BpbmcnKVxuZXhwb3J0cy5waW5nUHVsbFN0cmVhbSA9IHJlcXVpcmUoJy4vcGluZy1wdWxsLXN0cmVhbScpXG5leHBvcnRzLnBpbmdSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJy4vcGluZy1yZWFkYWJsZS1zdHJlYW0nKVxuZXhwb3J0cy5waW4gPSByZXF1aXJlKCcuL3BpbicpXG5leHBvcnRzLmZpbGVzUmVndWxhciA9IHJlcXVpcmUoJy4vZmlsZXMtcmVndWxhcicpXG5leHBvcnRzLmZpbGVzTUZTID0gcmVxdWlyZSgnLi9maWxlcy1tZnMnKVxuZXhwb3J0cy5iaXRzd2FwID0gcmVxdWlyZSgnLi9iaXRzd2FwJylcbmV4cG9ydHMucHVic3ViID0gcmVxdWlyZSgnLi9wdWJzdWInKVxuZXhwb3J0cy5kaHQgPSByZXF1aXJlKCcuL2RodCcpXG5leHBvcnRzLmRucyA9IHJlcXVpcmUoJy4vZG5zJylcbmV4cG9ydHMua2V5ID0gcmVxdWlyZSgnLi9rZXknKVxuZXhwb3J0cy5zdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKVxuZXhwb3J0cy5yZXNvbHZlID0gcmVxdWlyZSgnLi9yZXNvbHZlJylcbmV4cG9ydHMubmFtZSA9IHJlcXVpcmUoJy4vbmFtZScpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBrZXlMaXN0ID0gT2JqZWN0LmtleXM7XG52YXIgaGFzUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIHZhciBhcnJBID0gaXNBcnJheShhKVxuICAgICAgLCBhcnJCID0gaXNBcnJheShiKVxuICAgICAgLCBpXG4gICAgICAsIGxlbmd0aFxuICAgICAgLCBrZXk7XG5cbiAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGFyckEgIT0gYXJyQikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGRhdGVBID0gYSBpbnN0YW5jZW9mIERhdGVcbiAgICAgICwgZGF0ZUIgPSBiIGluc3RhbmNlb2YgRGF0ZTtcbiAgICBpZiAoZGF0ZUEgIT0gZGF0ZUIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGF0ZUEgJiYgZGF0ZUIpIHJldHVybiBhLmdldFRpbWUoKSA9PSBiLmdldFRpbWUoKTtcblxuICAgIHZhciByZWdleHBBID0gYSBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgLCByZWdleHBCID0gYiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICBpZiAocmVnZXhwQSAhPSByZWdleHBCKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHJlZ2V4cEEgJiYgcmVnZXhwQikgcmV0dXJuIGEudG9TdHJpbmcoKSA9PSBiLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIga2V5cyA9IGtleUxpc3QoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoICE9PSBrZXlMaXN0KGIpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghaGFzUHJvcC5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHBhc3NlZCBVaW50OEFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYlxuICovXG5mdW5jdGlvbiBlcXVhbHMgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxzXG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXNzZWQgQXJyYXlMaWtlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlMaWtlPG51bWJlcj4+fSBhcnJheXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXVxuICovXG5mdW5jdGlvbiBjb25jYXQgKGFycmF5cywgbGVuZ3RoKSB7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmxlbmd0aCwgMClcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IG9mZnNldCA9IDBcblxuICBmb3IgKGNvbnN0IGFyciBvZiBhcnJheXMpIHtcbiAgICBvdXRwdXQuc2V0KGFyciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uY2F0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5cbmNvbnN0IENJRFV0aWwgPSB7XG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnaXZlbiBpbnB1dCBpcyBhIHZhbGlkIENJRCBvYmplY3QuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgbWVzc2FnZSBpZiBpdCBpcyBub3QuXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGl0IGlzIGEgdmFsaWQgQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb3RoZXJcbiAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICBjaGVja0NJRENvbXBvbmVudHM6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwgdmFsdWVzIGFyZSBub3QgdmFsaWQgQ0lEcydcbiAgICB9XG5cbiAgICBpZiAoIShvdGhlci52ZXJzaW9uID09PSAwIHx8IG90aGVyLnZlcnNpb24gPT09IDEpKSB7XG4gICAgICByZXR1cm4gJ0ludmFsaWQgdmVyc2lvbiwgbXVzdCBiZSBhIG51bWJlciBlcXVhbCB0byAxIG9yIDAnXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdGhlci5jb2RlYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnY29kZWMgbXVzdCBiZSBzdHJpbmcnXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChvdGhlci5jb2RlYyAhPT0gJ2RhZy1wYicpIHtcbiAgICAgICAgcmV0dXJuIFwiY29kZWMgbXVzdCBiZSAnZGFnLXBiJyBmb3IgQ0lEdjBcIlxuICAgICAgfVxuICAgICAgaWYgKG90aGVyLm11bHRpYmFzZU5hbWUgIT09ICdiYXNlNThidGMnKSB7XG4gICAgICAgIHJldHVybiBcIm11bHRpYmFzZU5hbWUgbXVzdCBiZSAnYmFzZTU4YnRjJyBmb3IgQ0lEdjBcIlxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG90aGVyLm11bHRpaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICByZXR1cm4gJ211bHRpaGFzaCBtdXN0IGJlIGEgVWludDhBcnJheSdcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbWgudmFsaWRhdGUob3RoZXIubXVsdGloYXNoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbGV0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2VcbiAgICAgIGlmICghZXJyb3JNc2cpIHsgLy8gSnVzdCBpbiBjYXNlIG1oLnZhbGlkYXRlKCkgdGhyb3dzIGFuIGVycm9yIHdpdGggZW1wdHkgZXJyb3IgbWVzc2FnZVxuICAgICAgICBlcnJvck1zZyA9ICdNdWx0aWhhc2ggdmFsaWRhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JNc2dcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDSURVdGlsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbmNvZGluZzogZ2V0Q29kZWMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpXG5cbi8qKlxuICogQHR5cGVkZWYge19faW1wb3J0X18oJ211bHRpYmFzZS9zcmMvdHlwZXMnKS5CYXNlTmFtZSB8ICd1dGY4JyB8ICd1dGYtOCcgfCAnYXNjaWknIHwgdW5kZWZpbmVkfSBTdXBwb3J0ZWRFbmNvZGluZ3NcbiAqL1xuXG4vKipcbiAqIFR1cm5zIGEgVWludDhBcnJheSBvZiBieXRlcyBpbnRvIGEgc3RyaW5nIHdpdGggZWFjaFxuICogY2hhcmFjdGVyIGJlaW5nIHRoZSBjaGFyIGNvZGUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgYnl0ZVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nIChhcnJheSkge1xuICBsZXQgc3RyaW5nID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pXG4gIH1cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFR1cm5zIGEgYFVpbnQ4QXJyYXlgIGludG8gYSBzdHJpbmcuXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHR1cm4gaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHtTdXBwb3J0ZWRFbmNvZGluZ3N9IFtlbmNvZGluZz11dGY4XSAtIFRoZSBlbmNvZGluZyB0byB1c2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nIChhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKGFycmF5KVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nKGFycmF5KVxuICB9XG5cbiAgcmV0dXJuIGdldENvZGVjKGVuY29kaW5nKS5lbmNvZGUoYXJyYXkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmdcbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG11bHRpY29kZWMgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIG11bHRpY29kZWNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG4gKlxuICogY29uc3QgcHJlZml4ZWRQcm90b2J1ZiA9IG11bHRpY29kZWMuYWRkUHJlZml4KCdwcm90b2J1ZicsIHByb3RvYnVmQnVmZmVyKVxuICogLy8gcHJlZml4ZWRQcm90b2J1ZiAweDUwLi4uXG4gKlxuICovXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNDb2RlfSBDb2RlY0NvZGUgKi9cblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHVpbnQ4QXJyYXlDb25jYXQgPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IG5hbWVUb1ZhcmludCwgY29uc3RhbnRUb0NvZGUsIG5hbWVUb0NvZGUsIGNvZGVUb05hbWUgfSA9IHJlcXVpcmUoJy4vbWFwcycpXG5cbi8qKlxuICogUHJlZml4IGEgYnVmZmVyIHdpdGggYSBtdWx0aWNvZGVjLXBhY2tlZC5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZXxVaW50OEFycmF5fSBtdWx0aWNvZGVjU3RyT3JDb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBhZGRQcmVmaXggKG11bHRpY29kZWNTdHJPckNvZGUsIGRhdGEpIHtcbiAgbGV0IHByZWZpeFxuXG4gIGlmIChtdWx0aWNvZGVjU3RyT3JDb2RlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHByZWZpeCA9IHV0aWwudmFyaW50VWludDhBcnJheUVuY29kZShtdWx0aWNvZGVjU3RyT3JDb2RlKVxuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lVG9WYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV0pIHtcbiAgICAgIHByZWZpeCA9IG5hbWVUb1ZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpY29kZWMgbm90IHJlY29nbml6ZWQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1aW50OEFycmF5Q29uY2F0KFtwcmVmaXgsIGRhdGFdLCBwcmVmaXgubGVuZ3RoICsgZGF0YS5sZW5ndGgpXG59XG5cbi8qKlxuICogRGVjYXBzdWxhdGUgdGhlIG11bHRpY29kZWMtcGFja2VkIHByZWZpeCBmcm9tIHRoZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJtUHJlZml4IChkYXRhKSB7XG4gIHZhcmludC5kZWNvZGUoLyoqIEB0eXBlIHtCdWZmZXJ9ICovKGRhdGEpKVxuICByZXR1cm4gZGF0YS5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgbmFtZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZUZyb21EYXRhIChwcmVmaXhlZERhdGEpIHtcbiAgY29uc3QgY29kZSA9IC8qKiBAdHlwZSB7Q29kZWNDb2RlfSAqLyh2YXJpbnQuZGVjb2RlKC8qKiBAdHlwZSB7QnVmZmVyfSAqLyhwcmVmaXhlZERhdGEpKSlcbiAgY29uc3QgbmFtZSA9IGNvZGVUb05hbWVbY29kZV1cbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZSBcIiR7Y29kZX1cIiBub3QgZm91bmRgKVxuICB9XG4gIHJldHVybiBuYW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBuYW1lIGZyb20gYSBjb2RlLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNDb2RlfSBjb2RlY1xuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZUZyb21Db2RlIChjb2RlYykge1xuICByZXR1cm4gY29kZVRvTmFtZVtjb2RlY11cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIGNvZGVjXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtDb2RlY0NvZGV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVGcm9tTmFtZSAobmFtZSkge1xuICBjb25zdCBjb2RlID0gbmFtZVRvQ29kZVtuYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlYyBcIiR7bmFtZX1cIiBub3QgZm91bmRgKVxuICB9XG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlRnJvbURhdGEgKHByZWZpeGVkRGF0YSkge1xuICByZXR1cm4gLyoqIEB0eXBlIHtDb2RlY0NvZGV9ICovKHZhcmludC5kZWNvZGUoLyoqIEB0eXBlIHtCdWZmZXJ9ICovKHByZWZpeGVkRGF0YSkpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBhcyB2YXJpbnQgb2YgYSBjb2RlYyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFyaW50RnJvbU5hbWUgKG5hbWUpIHtcbiAgY29uc3QgY29kZSA9IG5hbWVUb1ZhcmludFtuYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlYyBcIiR7bmFtZX1cIiBub3QgZm91bmRgKVxuICB9XG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogR2V0IHRoZSB2YXJpbnQgb2YgYSBjb2RlLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0VmFyaW50RnJvbUNvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIHV0aWwudmFyaW50RW5jb2RlKGNvZGUpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBuYW1lIG9mIHRoZSBwcmVmaXhlZCBkYXRhLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXROYW1lRnJvbURhdGEgaW5zdGVhZC5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcHJlZml4ZWREYXRhXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlYyAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiBnZXROYW1lRnJvbURhdGEocHJlZml4ZWREYXRhKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgbmFtZSBmcm9tIGEgY29kZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0TmFtZUZyb21Db2RlIGluc3RlYWQuXG4gKiBAcGFyYW0ge0NvZGVjQ29kZX0gY29kZWNcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUgKGNvZGVjKSB7XG4gIHJldHVybiBnZXROYW1lRnJvbUNvZGUoY29kZWMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBjb2RlY1xuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXRDb2RlRnJvbU5hbWUgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICovXG5mdW5jdGlvbiBnZXROdW1iZXIgKG5hbWUpIHtcbiAgcmV0dXJuIGdldENvZGVGcm9tTmFtZShuYW1lKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0Q29kZUZyb21EYXRhIGluc3RlYWQuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjQ29kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZSAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiBnZXRDb2RlRnJvbURhdGEocHJlZml4ZWREYXRhKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBhcyB2YXJpbnQgb2YgYSBjb2RlYyBuYW1lLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXRWYXJpbnRGcm9tTmFtZSBpbnN0ZWFkLlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBnZXRDb2RlVmFyaW50IChuYW1lKSB7XG4gIHJldHVybiBnZXRWYXJpbnRGcm9tTmFtZShuYW1lKVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFyaW50IG9mIGEgY29kZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZ2V0VmFyaW50RnJvbUNvZGUgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Q29kZWNDb2RlfSBjb2RlXG4gKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gKi9cbmZ1bmN0aW9uIGdldFZhcmludCAoY29kZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbShnZXRWYXJpbnRGcm9tQ29kZShjb2RlKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFByZWZpeCxcbiAgcm1QcmVmaXgsXG4gIGdldE5hbWVGcm9tRGF0YSxcbiAgZ2V0TmFtZUZyb21Db2RlLFxuICBnZXRDb2RlRnJvbU5hbWUsXG4gIGdldENvZGVGcm9tRGF0YSxcbiAgZ2V0VmFyaW50RnJvbU5hbWUsXG4gIGdldFZhcmludEZyb21Db2RlLFxuICAvLyBEZXByZWNhdGVkXG4gIGdldENvZGVjLFxuICBnZXROYW1lLFxuICBnZXROdW1iZXIsXG4gIGdldENvZGUsXG4gIGdldENvZGVWYXJpbnQsXG4gIGdldFZhcmludCxcbiAgLy8gTWFrZSB0aGUgY29uc3RhbnRzIHRvcC1sZXZlbCBjb25zdGFudHNcbiAgLi4uY29uc3RhbnRUb0NvZGUsXG4gIC8vIEV4cG9ydCB0aGUgbWFwc1xuICBuYW1lVG9WYXJpbnQsXG4gIG5hbWVUb0NvZGUsXG4gIGNvZGVUb05hbWVcbn1cbiIsIi8qKlxuICogTXVsdGloYXNoIGltcGxlbWVudGF0aW9uIGluIEphdmFTY3JpcHQuXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHVpbnQ4QXJyYXlUb1N0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5jb25zdCB1aW50OEFycmF5RnJvbVN0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlDb25jYXQgPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG5jb25zdCBjb2RlcyA9IC8qKiBAdHlwZSB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVOYW1lTWFwfSAqLyh7fSlcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuZm9yIChjb25zdCBrZXkgaW4gbmFtZXMpIHtcbiAgY29uc3QgbmFtZSA9IC8qKiBAdHlwZSB7SGFzaE5hbWV9ICovKGtleSlcbiAgY29kZXNbbmFtZXNbbmFtZV1dID0gbmFtZVxufVxuT2JqZWN0LmZyZWV6ZShjb2RlcylcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b0hleFN0cmluZyAoaGFzaCkge1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgVWludDhBcnJheScpXG4gIH1cblxuICByZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKGhhc2gsICdiYXNlMTYnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZyb21IZXhTdHJpbmcgKGhhc2gpIHtcbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhhc2gsICdiYXNlMTYnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGJhc2U1OCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvQjU4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcobXVsdGliYXNlLmVuY29kZSgnYmFzZTU4YnRjJywgaGFzaCkpLnNsaWNlKDEpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYmFzZTU4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBmcm9tQjU4U3RyaW5nIChoYXNoKSB7XG4gIGNvbnN0IGVuY29kZWQgPSBoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgID8gdWludDhBcnJheVRvU3RyaW5nKGhhc2gpXG4gICAgOiBoYXNoXG5cbiAgcmV0dXJuIG11bHRpYmFzZS5kZWNvZGUoJ3onICsgZW5jb2RlZClcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBoYXNoIGZyb20gdGhlIGdpdmVuIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJucyB7e2NvZGU6IEhhc2hDb2RlLCBuYW1lOiBIYXNoTmFtZSwgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogVWludDhBcnJheX19IHJlc3VsdFxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGJ5dGVzKSB7XG4gIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBtdXN0IGJlIGEgVWludDhBcnJheScpXG4gIH1cblxuICBpZiAoYnl0ZXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIHRvbyBzaG9ydC4gbXVzdCBiZSA+IDIgYnl0ZXMuJylcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSAvKiogQHR5cGUge0hhc2hDb2RlfSAqLyh2YXJpbnQuZGVjb2RlKGJ5dGVzKSlcbiAgaWYgKCFpc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIHVua25vd24gZnVuY3Rpb24gY29kZTogMHgke2NvZGUudG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnl0ZXMgPSBieXRlcy5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGNvbnN0IGxlbiA9IHZhcmludC5kZWNvZGUoYnl0ZXMpXG4gIGlmIChsZW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggaW52YWxpZCBsZW5ndGg6ICR7bGVufWApXG4gIH1cbiAgYnl0ZXMgPSBieXRlcy5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGlmIChieXRlcy5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGxlbmd0aCBpbmNvbnNpc3RlbnQ6IDB4JHt1aW50OEFycmF5VG9TdHJpbmcoYnl0ZXMsICdiYXNlMTYnKX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlLFxuICAgIG5hbWU6IGNvZGVzW2NvZGVdLFxuICAgIGxlbmd0aDogbGVuLFxuICAgIGRpZ2VzdDogYnl0ZXNcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBhIGhhc2ggZGlnZXN0IGFsb25nIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjb2RlLlxuICpcbiAqID4gKipOb3RlOioqIHRoZSBsZW5ndGggaXMgZGVyaXZlZCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2VzdCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkaWdlc3RcbiAqIEBwYXJhbSB7SGFzaE5hbWUgfCBIYXNoQ29kZX0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChkaWdlc3QsIGNvZGUsIGxlbmd0aCkge1xuICBpZiAoIWRpZ2VzdCB8fCBjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBlbmNvZGUgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGFyZ3M6IGRpZ2VzdCwgY29kZScpXG4gIH1cblxuICAvLyBlbnN1cmUgaXQncyBhIGhhc2hmdW5jdGlvbiBjb2RlLlxuICBjb25zdCBoYXNoZm4gPSBjb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoZGlnZXN0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBzaG91bGQgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICBjb25zdCBoYXNoID0gdmFyaW50LmVuY29kZShoYXNoZm4pXG4gIGNvbnN0IGxlbiA9IHZhcmludC5lbmNvZGUobGVuZ3RoKVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbaGFzaCwgbGVuLCBkaWdlc3RdLCBoYXNoLmxlbmd0aCArIGxlbi5sZW5ndGggKyBkaWdlc3QubGVuZ3RoKVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGFzaCBmdW5jdGlvbiBuYW1lIGludG8gdGhlIG1hdGNoaW5nIGNvZGUuXG4gKiBJZiBwYXNzZWQgYSBudW1iZXIgaXQgd2lsbCByZXR1cm4gdGhlIG51bWJlciBpZiBpdCdzIGEgdmFsaWQgY29kZS5cbiAqXG4gKiBAcGFyYW0ge0hhc2hOYW1lIHwgbnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb2VyY2VDb2RlIChuYW1lKSB7XG4gIGxldCBjb2RlID0gbmFtZVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobmFtZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgaGFzaCBmdW5jdGlvbiBuYW1lZDogJHtuYW1lfWApXG4gICAgfVxuICAgIGNvZGUgPSBuYW1lc1tuYW1lXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSGFzaCBmdW5jdGlvbiBjb2RlIHNob3VsZCBiZSBhIG51bWJlci4gR290OiAke2NvZGV9YClcbiAgfVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGNvZGVzW2NvZGVdID09PSB1bmRlZmluZWQgJiYgIWlzQXBwQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGZ1bmN0aW9uIGNvZGU6ICR7Y29kZX1gKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjb2RlIGlzIHBhcnQgb2YgdGhlIGFwcCByYW5nZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBcHBDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID4gMCAmJiBjb2RlIDwgMHgxMFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbXVsdGloYXNoIGNvZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtIYXNoQ29kZX0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb2RlIChjb2RlKSB7XG4gIGlmIChpc0FwcENvZGUoY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBidWZmZXIgaXMgYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlIChtdWx0aWhhc2gpIHtcbiAgZGVjb2RlKG11bHRpaGFzaCkgLy8gdGhyb3dzIGlmIGJhZC5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHByZWZpeCAobXVsdGloYXNoKSB7XG4gIHZhbGlkYXRlKG11bHRpaGFzaClcblxuICByZXR1cm4gbXVsdGloYXNoLnN1YmFycmF5KDAsIDIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lcyxcbiAgY29kZXMsXG4gIHRvSGV4U3RyaW5nLFxuICBmcm9tSGV4U3RyaW5nLFxuICB0b0I1OFN0cmluZyxcbiAgZnJvbUI1OFN0cmluZyxcbiAgZGVjb2RlLFxuICBlbmNvZGUsXG4gIGNvZXJjZUNvZGUsXG4gIGlzQXBwQ29kZSxcbiAgdmFsaWRhdGUsXG4gIHByZWZpeCxcbiAgaXNWYWxpZENvZGVcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7IF9faW1wb3J0X18oXCIuL2NvbnN0YW50c1wiKS5IYXNoQ29kZSB9IEhhc2hDb2RlXG4gKiBAdHlwZWRlZiB7IF9faW1wb3J0X18oXCIuL2NvbnN0YW50c1wiKS5IYXNoTmFtZSB9IEhhc2hOYW1lXG4gKi9cbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFttdWx0aWJhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZW5jb2RlVGV4dCwgZGVjb2RlVGV4dCwgY29uY2F0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vYmFzZScpfSBCYXNlICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VOYW1lT3JDb2RlfSBCYXNlTmFtZU9yQ29kZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWV9IEJhc2VOYW1lICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFVpbnQ4QXJyYXkgd2l0aCB0aGUgbXVsdGliYXNlIHZhcmludCtjb2RlLlxuICpcbiAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBtdWx0aWJhc2UgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBpZiAoIWJ1Zikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYW4gZW5jb2RlZCBVaW50OEFycmF5JylcbiAgfVxuICBjb25zdCB7IG5hbWUsIGNvZGVCdWYgfSA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG4gIHZhbGlkRW5jb2RlKG5hbWUsIGJ1ZilcblxuICByZXR1cm4gY29uY2F0KFtjb2RlQnVmLCBidWZdLCBjb2RlQnVmLmxlbmd0aCArIGJ1Zi5sZW5ndGgpXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIGJhc2UgYW5kIGFkZCB0aGUgbXVsdGliYXNlIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcbiAgY29uc3QgZGF0YSA9IGVuY29kZVRleHQoZW5jLmVuY29kZShidWYpKVxuXG4gIHJldHVybiBjb25jYXQoW2VuYy5jb2RlQnVmLCBkYXRhXSwgZW5jLmNvZGVCdWYubGVuZ3RoICsgZGF0YS5sZW5ndGgpXG59XG5cbi8qKlxuICogVGFrZXMgYSBVaW50OEFycmF5IG9yIHN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlIGhlYWRlciwgZGVjb2RlcyBpdCBhbmRcbiAqIHJldHVybnMgdGhlIGRlY29kZWQgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZGF0YVswXVxuXG4gIC8vIE1ha2UgYWxsIGVuY29kaW5ncyBjYXNlLWluc2Vuc2l0aXZlIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGluY2x1ZGUgdXBwZXIgYW5kIGxvd2VyIGNoYXJzIGluIHRoZSBhbHBoYWJldFxuICBpZiAoWydmJywgJ0YnLCAndicsICdWJywgJ3QnLCAnVCcsICdiJywgJ0InLCAnYycsICdDJywgJ2gnLCAnaycsICdLJ10uaW5jbHVkZXMocHJlZml4KSkge1xuICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKClcbiAgfVxuICBjb25zdCBlbmMgPSBlbmNvZGluZygvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhkYXRhWzBdKSlcbiAgcmV0dXJuIGVuYy5kZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSkpXG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGRhdGEgbXVsdGliYXNlIGVuY29kZWQ/XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIC8vIEVuc3VyZSBidWZPclN0cmluZyBpcyBhIHN0cmluZ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZygvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhkYXRhWzBdKSlcbiAgICByZXR1cm4gZW5jLm5hbWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWUpXG4gIGVuYy5kZWNvZGUoZGVjb2RlVGV4dChidWYpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgZW5jb2RpbmcgYnkgbmFtZSBvciBjb2RlXG4gKlxuICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gbmFtZU9yQ29kZVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZyAobmFtZU9yQ29kZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnN0YW50cy5uYW1lcywgLyoqIEB0eXBlIHtCYXNlTmFtZX0gKi8obmFtZU9yQ29kZSkpKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5uYW1lc1svKiogQHR5cGUge0Jhc2VOYW1lfSAqLyhuYW1lT3JDb2RlKV1cbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uc3RhbnRzLmNvZGVzLCAvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhuYW1lT3JDb2RlKSkpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmNvZGVzWy8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKG5hbWVPckNvZGUpXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7bmFtZU9yQ29kZX1gKVxuICB9XG59XG5cbi8qKlxuICogR2V0IGVuY29kaW5nIGZyb20gZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmdGcm9tRGF0YSAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5nKC8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKGRhdGFbMF0pKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBtdWx0aWJhc2VcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5pc0VuY29kZWQgPSBpc0VuY29kZWRcbmV4cG9ydHMuZW5jb2RpbmcgPSBlbmNvZGluZ1xuZXhwb3J0cy5lbmNvZGluZ0Zyb21EYXRhID0gZW5jb2RpbmdGcm9tRGF0YVxuY29uc3QgbmFtZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5uYW1lcylcbmNvbnN0IGNvZGVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMuY29kZXMpXG5leHBvcnRzLm5hbWVzID0gbmFtZXNcbmV4cG9ydHMuY29kZXMgPSBjb2Rlc1xuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsKSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCIvLyBAdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IHJmYzQ2NDggPSByZXF1aXJlKCcuL3JmYzQ2NDgnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5jb25zdCBpZGVudGl0eSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGRlY29kZVRleHQsXG4gICAgZGVjb2RlOiBlbmNvZGVUZXh0XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9iYXNlJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnlcbiAqXG4gKiBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbiAqIEB0eXBlIHtBcnJheTxbc3RyaW5nLCBzdHJpbmcsIENvZGVjRmFjdG9yeSwgc3RyaW5nXT59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydpZGVudGl0eScsICdcXHgwMCcsIGlkZW50aXR5LCAnJ10sXG4gIFsnYmFzZTInLCAnMCcsIHJmYzQ2NDgoMSksICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCByZmM0NjQ4KDMpLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMTZ1cHBlcicsICdGJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlBQkNERUYnXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHVwcGVyJywgJ1YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJoZXhwYWR1cHBlcicsICdUJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPSddLFxuICBbJ2Jhc2UzMicsICdiJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMydXBwZXInLCAnQicsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMnBhZHVwcGVyJywgJ0MnLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyeicsICdoJywgcmZjNDY0OCg1KSwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTM2JywgJ2snLCBiYXNlWCwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2UzNnVwcGVyJywgJ0snLCBiYXNlWCwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNjQnLCAnbScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG5jb25zdCBuYW1lcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVswXV0gPSBuZXcgQmFzZSh0dXBwbGVbMF0sIHR1cHBsZVsxXSwgdHVwcGxlWzJdLCB0dXBwbGVbM10pXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwge30pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lcyxcbiAgY29kZXNcbn1cbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBkZWNvZGVUZXh0ID0gKGJ5dGVzKSA9PiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVUZXh0ID0gKHRleHQpID0+IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBieXRlc1xuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuY29uc3QgYXNCdWZmZXIgPSAoeyBidWZmZXIsIGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQgfSkgPT5cbiAgQnVmZmVyLmZyb20oYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCwgYXNCdWZmZXIgfVxuIiwiLy8gRE8gTk9UIENIQU5HRSBUSElTIEZJTEUuIElUIElTIEdFTkVSQVRFRCBCWSB0b29scy91cGRhdGUtdGFibGUuanNcbi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAdHlwZSB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OYW1lTnVtYmVyTWFwfVxuICovXG5jb25zdCBiYXNlVGFibGUgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogMHgwMCxcbiAgJ2NpZHYxJzogMHgwMSxcbiAgJ2NpZHYyJzogMHgwMixcbiAgJ2NpZHYzJzogMHgwMyxcbiAgJ2lwNCc6IDB4MDQsXG4gICd0Y3AnOiAweDA2LFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ2RjY3AnOiAweDIxLFxuICAnbXVybXVyMy0xMjgnOiAweDIyLFxuICAnbXVybXVyMy0zMic6IDB4MjMsXG4gICdpcDYnOiAweDI5LFxuICAnaXA2em9uZSc6IDB4MmEsXG4gICdwYXRoJzogMHgyZixcbiAgJ211bHRpY29kZWMnOiAweDMwLFxuICAnbXVsdGloYXNoJzogMHgzMSxcbiAgJ211bHRpYWRkcic6IDB4MzIsXG4gICdtdWx0aWJhc2UnOiAweDMzLFxuICAnZG5zJzogMHgzNSxcbiAgJ2RuczQnOiAweDM2LFxuICAnZG5zNic6IDB4MzcsXG4gICdkbnNhZGRyJzogMHgzOCxcbiAgJ3Byb3RvYnVmJzogMHg1MCxcbiAgJ2Nib3InOiAweDUxLFxuICAncmF3JzogMHg1NSxcbiAgJ2RibC1zaGEyLTI1Nic6IDB4NTYsXG4gICdybHAnOiAweDYwLFxuICAnYmVuY29kZSc6IDB4NjMsXG4gICdkYWctcGInOiAweDcwLFxuICAnZGFnLWNib3InOiAweDcxLFxuICAnbGlicDJwLWtleSc6IDB4NzIsXG4gICdnaXQtcmF3JzogMHg3OCxcbiAgJ3RvcnJlbnQtaW5mbyc6IDB4N2IsXG4gICd0b3JyZW50LWZpbGUnOiAweDdjLFxuICAnbGVvZmNvaW4tYmxvY2snOiAweDgxLFxuICAnbGVvZmNvaW4tdHgnOiAweDgyLFxuICAnbGVvZmNvaW4tcHInOiAweDgzLFxuICAnc2N0cCc6IDB4ODQsXG4gICdkYWctam9zZSc6IDB4ODUsXG4gICdkYWctY29zZSc6IDB4ODYsXG4gICdldGgtYmxvY2snOiAweDkwLFxuICAnZXRoLWJsb2NrLWxpc3QnOiAweDkxLFxuICAnZXRoLXR4LXRyaWUnOiAweDkyLFxuICAnZXRoLXR4JzogMHg5MyxcbiAgJ2V0aC10eC1yZWNlaXB0LXRyaWUnOiAweDk0LFxuICAnZXRoLXR4LXJlY2VpcHQnOiAweDk1LFxuICAnZXRoLXN0YXRlLXRyaWUnOiAweDk2LFxuICAnZXRoLWFjY291bnQtc25hcHNob3QnOiAweDk3LFxuICAnZXRoLXN0b3JhZ2UtdHJpZSc6IDB4OTgsXG4gICdiaXRjb2luLWJsb2NrJzogMHhiMCxcbiAgJ2JpdGNvaW4tdHgnOiAweGIxLFxuICAnYml0Y29pbi13aXRuZXNzLWNvbW1pdG1lbnQnOiAweGIyLFxuICAnemNhc2gtYmxvY2snOiAweGMwLFxuICAnemNhc2gtdHgnOiAweGMxLFxuICAnZG9jaWQnOiAweGNlLFxuICAnc3RlbGxhci1ibG9jayc6IDB4ZDAsXG4gICdzdGVsbGFyLXR4JzogMHhkMSxcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ2RlY3JlZC1ibG9jayc6IDB4ZTAsXG4gICdkZWNyZWQtdHgnOiAweGUxLFxuICAnaXBsZC1ucyc6IDB4ZTIsXG4gICdpcGZzLW5zJzogMHhlMyxcbiAgJ3N3YXJtLW5zJzogMHhlNCxcbiAgJ2lwbnMtbnMnOiAweGU1LFxuICAnemVyb25ldCc6IDB4ZTYsXG4gICdzZWNwMjU2azEtcHViJzogMHhlNyxcbiAgJ2JsczEyXzM4MS1nMS1wdWInOiAweGVhLFxuICAnYmxzMTJfMzgxLWcyLXB1Yic6IDB4ZWIsXG4gICd4MjU1MTktcHViJzogMHhlYyxcbiAgJ2VkMjU1MTktcHViJzogMHhlZCxcbiAgJ2JsczEyXzM4MS1nMWcyLXB1Yic6IDB4ZWUsXG4gICdkYXNoLWJsb2NrJzogMHhmMCxcbiAgJ2Rhc2gtdHgnOiAweGYxLFxuICAnc3dhcm0tbWFuaWZlc3QnOiAweGZhLFxuICAnc3dhcm0tZmVlZCc6IDB4ZmIsXG4gICd1ZHAnOiAweDAxMTEsXG4gICdwMnAtd2VicnRjLXN0YXInOiAweDAxMTMsXG4gICdwMnAtd2VicnRjLWRpcmVjdCc6IDB4MDExNCxcbiAgJ3AycC1zdGFyZHVzdCc6IDB4MDExNSxcbiAgJ3AycC1jaXJjdWl0JzogMHgwMTIyLFxuICAnZGFnLWpzb24nOiAweDAxMjksXG4gICd1ZHQnOiAweDAxMmQsXG4gICd1dHAnOiAweDAxMmUsXG4gICd1bml4JzogMHgwMTkwLFxuICAncDJwJzogMHgwMWE1LFxuICAnaXBmcyc6IDB4MDFhNSxcbiAgJ2h0dHBzJzogMHgwMWJiLFxuICAnb25pb24nOiAweDAxYmMsXG4gICdvbmlvbjMnOiAweDAxYmQsXG4gICdnYXJsaWM2NCc6IDB4MDFiZSxcbiAgJ2dhcmxpYzMyJzogMHgwMWJmLFxuICAndGxzJzogMHgwMWMwLFxuICAncXVpYyc6IDB4MDFjYyxcbiAgJ3dzJzogMHgwMWRkLFxuICAnd3NzJzogMHgwMWRlLFxuICAncDJwLXdlYnNvY2tldC1zdGFyJzogMHgwMWRmLFxuICAnaHR0cCc6IDB4MDFlMCxcbiAgJ2pzb24nOiAweDAyMDAsXG4gICdtZXNzYWdlcGFjayc6IDB4MDIwMSxcbiAgJ2xpYnAycC1wZWVyLXJlY29yZCc6IDB4MDMwMSxcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdwMjU2LXB1Yic6IDB4MTIwMCxcbiAgJ3AzODQtcHViJzogMHgxMjAxLFxuICAncDUyMS1wdWInOiAweDEyMDIsXG4gICdlZDQ0OC1wdWInOiAweDEyMDMsXG4gICd4NDQ4LXB1Yic6IDB4MTIwNCxcbiAgJ2VkMjU1MTktcHJpdic6IDB4MTMwMCxcbiAgJ2thbmdhcm9vdHdlbHZlJzogMHgxZDAxLFxuICAnc20zLTI1Nic6IDB4NTM0ZCxcbiAgJ2JsYWtlMmItOCc6IDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAweGIyMDIsXG4gICdibGFrZTJiLTI0JzogMHhiMjAzLFxuICAnYmxha2UyYi0zMic6IDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAweGIyMDUsXG4gICdibGFrZTJiLTQ4JzogMHhiMjA2LFxuICAnYmxha2UyYi01Nic6IDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAweGIyMDgsXG4gICdibGFrZTJiLTcyJzogMHhiMjA5LFxuICAnYmxha2UyYi04MCc6IDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAweGIyMGIsXG4gICdibGFrZTJiLTk2JzogMHhiMjBjLFxuICAnYmxha2UyYi0xMDQnOiAweGIyMGQsXG4gICdibGFrZTJiLTExMic6IDB4YjIwZSxcbiAgJ2JsYWtlMmItMTIwJzogMHhiMjBmLFxuICAnYmxha2UyYi0xMjgnOiAweGIyMTAsXG4gICdibGFrZTJiLTEzNic6IDB4YjIxMSxcbiAgJ2JsYWtlMmItMTQ0JzogMHhiMjEyLFxuICAnYmxha2UyYi0xNTInOiAweGIyMTMsXG4gICdibGFrZTJiLTE2MCc6IDB4YjIxNCxcbiAgJ2JsYWtlMmItMTY4JzogMHhiMjE1LFxuICAnYmxha2UyYi0xNzYnOiAweGIyMTYsXG4gICdibGFrZTJiLTE4NCc6IDB4YjIxNyxcbiAgJ2JsYWtlMmItMTkyJzogMHhiMjE4LFxuICAnYmxha2UyYi0yMDAnOiAweGIyMTksXG4gICdibGFrZTJiLTIwOCc6IDB4YjIxYSxcbiAgJ2JsYWtlMmItMjE2JzogMHhiMjFiLFxuICAnYmxha2UyYi0yMjQnOiAweGIyMWMsXG4gICdibGFrZTJiLTIzMic6IDB4YjIxZCxcbiAgJ2JsYWtlMmItMjQwJzogMHhiMjFlLFxuICAnYmxha2UyYi0yNDgnOiAweGIyMWYsXG4gICdibGFrZTJiLTI1Nic6IDB4YjIyMCxcbiAgJ2JsYWtlMmItMjY0JzogMHhiMjIxLFxuICAnYmxha2UyYi0yNzInOiAweGIyMjIsXG4gICdibGFrZTJiLTI4MCc6IDB4YjIyMyxcbiAgJ2JsYWtlMmItMjg4JzogMHhiMjI0LFxuICAnYmxha2UyYi0yOTYnOiAweGIyMjUsXG4gICdibGFrZTJiLTMwNCc6IDB4YjIyNixcbiAgJ2JsYWtlMmItMzEyJzogMHhiMjI3LFxuICAnYmxha2UyYi0zMjAnOiAweGIyMjgsXG4gICdibGFrZTJiLTMyOCc6IDB4YjIyOSxcbiAgJ2JsYWtlMmItMzM2JzogMHhiMjJhLFxuICAnYmxha2UyYi0zNDQnOiAweGIyMmIsXG4gICdibGFrZTJiLTM1Mic6IDB4YjIyYyxcbiAgJ2JsYWtlMmItMzYwJzogMHhiMjJkLFxuICAnYmxha2UyYi0zNjgnOiAweGIyMmUsXG4gICdibGFrZTJiLTM3Nic6IDB4YjIyZixcbiAgJ2JsYWtlMmItMzg0JzogMHhiMjMwLFxuICAnYmxha2UyYi0zOTInOiAweGIyMzEsXG4gICdibGFrZTJiLTQwMCc6IDB4YjIzMixcbiAgJ2JsYWtlMmItNDA4JzogMHhiMjMzLFxuICAnYmxha2UyYi00MTYnOiAweGIyMzQsXG4gICdibGFrZTJiLTQyNCc6IDB4YjIzNSxcbiAgJ2JsYWtlMmItNDMyJzogMHhiMjM2LFxuICAnYmxha2UyYi00NDAnOiAweGIyMzcsXG4gICdibGFrZTJiLTQ0OCc6IDB4YjIzOCxcbiAgJ2JsYWtlMmItNDU2JzogMHhiMjM5LFxuICAnYmxha2UyYi00NjQnOiAweGIyM2EsXG4gICdibGFrZTJiLTQ3Mic6IDB4YjIzYixcbiAgJ2JsYWtlMmItNDgwJzogMHhiMjNjLFxuICAnYmxha2UyYi00ODgnOiAweGIyM2QsXG4gICdibGFrZTJiLTQ5Nic6IDB4YjIzZSxcbiAgJ2JsYWtlMmItNTA0JzogMHhiMjNmLFxuICAnYmxha2UyYi01MTInOiAweGIyNDAsXG4gICdibGFrZTJzLTgnOiAweGIyNDEsXG4gICdibGFrZTJzLTE2JzogMHhiMjQyLFxuICAnYmxha2Uycy0yNCc6IDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAweGIyNDQsXG4gICdibGFrZTJzLTQwJzogMHhiMjQ1LFxuICAnYmxha2Uycy00OCc6IDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAweGIyNDcsXG4gICdibGFrZTJzLTY0JzogMHhiMjQ4LFxuICAnYmxha2Uycy03Mic6IDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAweGIyNGEsXG4gICdibGFrZTJzLTg4JzogMHhiMjRiLFxuICAnYmxha2Uycy05Nic6IDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdza2VpbjI1Ni04JzogMHhiMzAxLFxuICAnc2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdza2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ3NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnc2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdza2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ3NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnc2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdza2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ3NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnc2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdza2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ3NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ3NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ3NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ3NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ3NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ3NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ3NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ3NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ3NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ3NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ3NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ3NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ3NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ3NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ3NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ3NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ3NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ3NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ3NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ3NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ3NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdza2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ3NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnc2tlaW41MTItMzInOiAweGIzMjQsXG4gICdza2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ3NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnc2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdza2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ3NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnc2tlaW41MTItODAnOiAweGIzMmEsXG4gICdza2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ3NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnc2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnc2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnc2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnc2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnc2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnc2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnc2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnc2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnc2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnc2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnc2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnc2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnc2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnc2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnc2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnc2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnc2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnc2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnc2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnc2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnc2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnc2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnc2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnc2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnc2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnc2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnc2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnc2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnc2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnc2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnc2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnc2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnc2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnc2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnc2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnc2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnc2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnc2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnc2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnc2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnc2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnc2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnc2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnc2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnc2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnc2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnc2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnc2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnc2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnc2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnc2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnc2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnc2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdza2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdza2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdza2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdza2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdza2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdza2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdza2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdza2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdza2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdza2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdza2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdza2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnc2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ3NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdza2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnc2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ3NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdza2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnc2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ3NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdza2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnc2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ3NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdza2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnc2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ3NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdza2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnc2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ3NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdza2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnc2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ3NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdza2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnc2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ3NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdza2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnc2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ3NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdza2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnc2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ3NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdza2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnc2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ3NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdza2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnc2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ3NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdza2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnc2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ3NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdza2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnc2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ3NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdza2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnc2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ3NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdza2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnc2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ3NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdza2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnc2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ3NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdza2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnc2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ3NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdza2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnc2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ3NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdza2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnc2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ3NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdza2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnc2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ3NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdza2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnc2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ3NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdza2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnc2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ3NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdza2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnc2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ3NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdza2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnc2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ3NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdza2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnc2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ3NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdza2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnc2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ3NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdza2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnc2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ3NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdza2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnc2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ3NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdza2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnc2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ3NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdza2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnc2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ3NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdza2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnc2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ3NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdza2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnc2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ3NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdza2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnc2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ3NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdza2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnc2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ3NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdza2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnc2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ3NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdza2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnc2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ3NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdza2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnc2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdza2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ3NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnc2tlaW4xMDI0LTEwMjQnOiAweGIzZTAsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxJzogMHhiNDAxLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMS1zYyc6IDB4YjQwMixcbiAgJ3plcm94Y2VydC1pbXByaW50LTI1Nic6IDB4Y2UxMSxcbiAgJ2ZpbC1jb21taXRtZW50LXVuc2VhbGVkJzogMHhmMTAxLFxuICAnZmlsLWNvbW1pdG1lbnQtc2VhbGVkJzogMHhmMTAyLFxuICAnaG9sb2NoYWluLWFkci12MCc6IDB4ODA3MTI0LFxuICAnaG9sb2NoYWluLWFkci12MSc6IDB4ODE3MTI0LFxuICAnaG9sb2NoYWluLWtleS12MCc6IDB4OTQ3MTI0LFxuICAnaG9sb2NoYWluLWtleS12MSc6IDB4OTU3MTI0LFxuICAnaG9sb2NoYWluLXNpZy12MCc6IDB4YTI3MTI0LFxuICAnaG9sb2NoYWluLXNpZy12MSc6IDB4YTM3MTI0LFxuICAnc2t5bmV0LW5zJzogMHhiMTk5MTBcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBiYXNlVGFibGUgfVxuIiwibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5hbWVzIH0gPSByZXF1aXJlKCdtdWx0aWJhc2Uvc3JjL2NvbnN0YW50cycpXG5jb25zdCB7IFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKVxuXG4vKipcbiAqIFR1cm5zIGEgVWludDhBcnJheSBvZiBieXRlcyBpbnRvIGEgc3RyaW5nIHdpdGggZWFjaFxuICogY2hhcmFjdGVyIGJlaW5nIHRoZSBjaGFyIGNvZGUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgYnl0ZVxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHR1cm4gaW50byBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvQXNjaWlTdHJpbmcgKGFycmF5KSB7XG4gIGxldCBzdHJpbmcgPSAnJ1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSlcbiAgfVxuICByZXR1cm4gc3RyaW5nXG59XG5cbi8qKlxuICogVHVybnMgYSBgVWludDhBcnJheWAgaW50byBhIHN0cmluZy5cbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHR1cm4gaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz11dGY4XSBUaGUgZW5jb2RpbmcgdG8gdXNlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVsdGliYXNlfG11bHRpYmFzZX0gZm9yIHN1cHBvcnRlZCBlbmNvZGluZ3Mgb3RoZXIgdGhhbiBgdXRmOGBcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKGFycmF5LCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUoYXJyYXkpXG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICByZXR1cm4gdWludDhBcnJheVRvQXNjaWlTdHJpbmcoYXJyYXkpXG4gIH1cblxuICBjb25zdCBjb2RlYyA9IG5hbWVzW2VuY29kaW5nXVxuXG4gIGlmICghY29kZWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmFzZScpXG4gIH1cblxuICByZXR1cm4gY29kZWMuZW5jb2RlKGFycmF5KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlL3NyYy9jb25zdGFudHMnKVxuY29uc3QgeyBUZXh0RW5jb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcbmNvbnN0IHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBJbnRlcnBlcmV0cyBlYWNoIGNoYXJhY3RlciBpbiBhIHN0cmluZyBhcyBhIGJ5dGUgYW5kXG4gKiByZXR1cm5zIGEgVWludDhBcnJheSBvZiB0aG9zZSBieXRlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHVybiBpbnRvIGFuIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkgKHN0cmluZykge1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgVWludDhBcnJheWAgZnJvbSB0aGUgcGFzc2VkIHN0cmluZ1xuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz11dGY4XSB1dGY4LCBiYXNlMTYsIGJhc2U2NCwgYmFzZTY0dXJscGFkLCBldGNcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXVsdGliYXNlfG11bHRpYmFzZX0gZm9yIHN1cHBvcnRlZCBlbmNvZGluZ3Mgb3RoZXIgdGhhbiBgdXRmOGBcbiAqL1xuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgIHJldHVybiB1dGY4RW5jb2Rlci5lbmNvZGUoc3RyaW5nKVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgcmV0dXJuIGFzY2lpU3RyaW5nVG9VaW50OEFycmF5KHN0cmluZylcbiAgfVxuXG4gIGNvbnN0IGNvZGVjID0gbmFtZXNbZW5jb2RpbmddXG5cbiAgaWYgKCFjb2RlYykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBiYXNlJylcbiAgfVxuXG4gIHJldHVybiBjb2RlYy5kZWNvZGUoc3RyaW5nKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZyb21TdHJpbmdcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFdISVRFTElTVCA9IFtcblx0J0VUSU1FRE9VVCcsXG5cdCdFQ09OTlJFU0VUJyxcblx0J0VBRERSSU5VU0UnLFxuXHQnRVNPQ0tFVFRJTUVET1VUJyxcblx0J0VDT05OUkVGVVNFRCcsXG5cdCdFUElQRScsXG5cdCdFSE9TVFVOUkVBQ0gnLFxuXHQnRUFJX0FHQUlOJ1xuXTtcblxudmFyIEJMQUNLTElTVCA9IFtcblx0J0VOT1RGT1VORCcsXG5cdCdFTkVUVU5SRUFDSCcsXG5cblx0Ly8gU1NMIGVycm9ycyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2VkM2Q4YjEzZWU5YTcwNWQ4OWY5ZTAzOTdkOWU5NjUxOWU3ZTQ3YWMvc3JjL25vZGVfY3J5cHRvLmNjI0wxOTUwXG5cdCdVTkFCTEVfVE9fR0VUX0lTU1VFUl9DRVJUJyxcblx0J1VOQUJMRV9UT19HRVRfQ1JMJyxcblx0J1VOQUJMRV9UT19ERUNSWVBUX0NFUlRfU0lHTkFUVVJFJyxcblx0J1VOQUJMRV9UT19ERUNSWVBUX0NSTF9TSUdOQVRVUkUnLFxuXHQnVU5BQkxFX1RPX0RFQ09ERV9JU1NVRVJfUFVCTElDX0tFWScsXG5cdCdDRVJUX1NJR05BVFVSRV9GQUlMVVJFJyxcblx0J0NSTF9TSUdOQVRVUkVfRkFJTFVSRScsXG5cdCdDRVJUX05PVF9ZRVRfVkFMSUQnLFxuXHQnQ0VSVF9IQVNfRVhQSVJFRCcsXG5cdCdDUkxfTk9UX1lFVF9WQUxJRCcsXG5cdCdDUkxfSEFTX0VYUElSRUQnLFxuXHQnRVJST1JfSU5fQ0VSVF9OT1RfQkVGT1JFX0ZJRUxEJyxcblx0J0VSUk9SX0lOX0NFUlRfTk9UX0FGVEVSX0ZJRUxEJyxcblx0J0VSUk9SX0lOX0NSTF9MQVNUX1VQREFURV9GSUVMRCcsXG5cdCdFUlJPUl9JTl9DUkxfTkVYVF9VUERBVEVfRklFTEQnLFxuXHQnT1VUX09GX01FTScsXG5cdCdERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlQnLFxuXHQnU0VMRl9TSUdORURfQ0VSVF9JTl9DSEFJTicsXG5cdCdVTkFCTEVfVE9fR0VUX0lTU1VFUl9DRVJUX0xPQ0FMTFknLFxuXHQnVU5BQkxFX1RPX1ZFUklGWV9MRUFGX1NJR05BVFVSRScsXG5cdCdDRVJUX0NIQUlOX1RPT19MT05HJyxcblx0J0NFUlRfUkVWT0tFRCcsXG5cdCdJTlZBTElEX0NBJyxcblx0J1BBVEhfTEVOR1RIX0VYQ0VFREVEJyxcblx0J0lOVkFMSURfUFVSUE9TRScsXG5cdCdDRVJUX1VOVFJVU1RFRCcsXG5cdCdDRVJUX1JFSkVDVEVEJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdGlmICghZXJyIHx8ICFlcnIuY29kZSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKFdISVRFTElTVC5pbmRleE9mKGVyci5jb2RlKSAhPT0gLTEpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChCTEFDS0xJU1QuaW5kZXhPZihlcnIuY29kZSkgIT09IC0xKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJylcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vY29yZS9lbmhhbmNlRXJyb3InKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDoge1xuICAgIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG4gIH0sXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSB8fCAoaGVhZGVycyAmJiBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsO1xuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgdmFyIGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICB2YXIgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmIChzdHJpY3RKU09OUGFyc2luZyB8fCAoZm9yY2VkSlNPTlBhcnNpbmcgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZW5oYW5jZUVycm9yKGUsIHRoaXMsICdFX0pTT05fUEFSU0UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4gICAgLy8gYmVnaW5cbiAgICAweDMwLFxuICAgIDB4ODEsXG4gICAgMHhkMyxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDA0LFxuICAgIDB4MjAsXG4gICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgLy8gbWlkZGxlXG4gICAgMHhhMCxcbiAgICAweDgxLFxuICAgIDB4ODUsXG4gICAgMHgzMCxcbiAgICAweDgxLFxuICAgIDB4ODIsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgzMCxcbiAgICAweDJjLFxuICAgIDB4MDYsXG4gICAgMHgwNyxcbiAgICAweDJhLFxuICAgIDB4ODYsXG4gICAgMHg0OCxcbiAgICAweGNlLFxuICAgIDB4M2QsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmMsXG4gICAgMHgyZixcbiAgICAweDMwLFxuICAgIDB4MDYsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDAsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwNCxcbiAgICAweDIxLFxuICAgIDB4MDIsXG4gICAgMHg3OSxcbiAgICAweGJlLFxuICAgIDB4NjYsXG4gICAgMHg3ZSxcbiAgICAweGY5LFxuICAgIDB4ZGMsXG4gICAgMHhiYixcbiAgICAweGFjLFxuICAgIDB4NTUsXG4gICAgMHhhMCxcbiAgICAweDYyLFxuICAgIDB4OTUsXG4gICAgMHhjZSxcbiAgICAweDg3LFxuICAgIDB4MGIsXG4gICAgMHgwNyxcbiAgICAweDAyLFxuICAgIDB4OWIsXG4gICAgMHhmYyxcbiAgICAweGRiLFxuICAgIDB4MmQsXG4gICAgMHhjZSxcbiAgICAweDI4LFxuICAgIDB4ZDksXG4gICAgMHg1OSxcbiAgICAweGYyLFxuICAgIDB4ODEsXG4gICAgMHg1YixcbiAgICAweDE2LFxuICAgIDB4ZjgsXG4gICAgMHgxNyxcbiAgICAweDk4LFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhiYSxcbiAgICAweGFlLFxuICAgIDB4ZGMsXG4gICAgMHhlNixcbiAgICAweGFmLFxuICAgIDB4NDgsXG4gICAgMHhhMCxcbiAgICAweDNiLFxuICAgIDB4YmYsXG4gICAgMHhkMixcbiAgICAweDVlLFxuICAgIDB4OGMsXG4gICAgMHhkMCxcbiAgICAweDM2LFxuICAgIDB4NDEsXG4gICAgMHg0MSxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweGExLFxuICAgIDB4MjQsXG4gICAgMHgwMyxcbiAgICAweDIyLFxuICAgIDB4MDAsXG4gICAgLy8gcHVibGljIGtleVxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuXSk7XG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgICAvLyBiZWdpblxuICAgIDB4MzAsXG4gICAgMHg4MixcbiAgICAweDAxLFxuICAgIDB4MTMsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgwNCxcbiAgICAweDIwLFxuICAgIC8vIHByaXZhdGUga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIC8vIG1pZGRsZVxuICAgIDB4YTAsXG4gICAgMHg4MSxcbiAgICAweGE1LFxuICAgIDB4MzAsXG4gICAgMHg4MSxcbiAgICAweGEyLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MzAsXG4gICAgMHgyYyxcbiAgICAweDA2LFxuICAgIDB4MDcsXG4gICAgMHgyYSxcbiAgICAweDg2LFxuICAgIDB4NDgsXG4gICAgMHhjZSxcbiAgICAweDNkLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDAyLFxuICAgIDB4MjEsXG4gICAgMHgwMCxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZlLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZjLFxuICAgIDB4MmYsXG4gICAgMHgzMCxcbiAgICAweDA2LFxuICAgIDB4MDQsXG4gICAgMHgwMSxcbiAgICAweDAwLFxuICAgIDB4MDQsXG4gICAgMHgwMSxcbiAgICAweDA3LFxuICAgIDB4MDQsXG4gICAgMHg0MSxcbiAgICAweDA0LFxuICAgIDB4NzksXG4gICAgMHhiZSxcbiAgICAweDY2LFxuICAgIDB4N2UsXG4gICAgMHhmOSxcbiAgICAweGRjLFxuICAgIDB4YmIsXG4gICAgMHhhYyxcbiAgICAweDU1LFxuICAgIDB4YTAsXG4gICAgMHg2MixcbiAgICAweDk1LFxuICAgIDB4Y2UsXG4gICAgMHg4NyxcbiAgICAweDBiLFxuICAgIDB4MDcsXG4gICAgMHgwMixcbiAgICAweDliLFxuICAgIDB4ZmMsXG4gICAgMHhkYixcbiAgICAweDJkLFxuICAgIDB4Y2UsXG4gICAgMHgyOCxcbiAgICAweGQ5LFxuICAgIDB4NTksXG4gICAgMHhmMixcbiAgICAweDgxLFxuICAgIDB4NWIsXG4gICAgMHgxNixcbiAgICAweGY4LFxuICAgIDB4MTcsXG4gICAgMHg5OCxcbiAgICAweDQ4LFxuICAgIDB4M2EsXG4gICAgMHhkYSxcbiAgICAweDc3LFxuICAgIDB4MjYsXG4gICAgMHhhMyxcbiAgICAweGM0LFxuICAgIDB4NjUsXG4gICAgMHg1ZCxcbiAgICAweGE0LFxuICAgIDB4ZmIsXG4gICAgMHhmYyxcbiAgICAweDBlLFxuICAgIDB4MTEsXG4gICAgMHgwOCxcbiAgICAweGE4LFxuICAgIDB4ZmQsXG4gICAgMHgxNyxcbiAgICAweGI0LFxuICAgIDB4NDgsXG4gICAgMHhhNixcbiAgICAweDg1LFxuICAgIDB4NTQsXG4gICAgMHgxOSxcbiAgICAweDljLFxuICAgIDB4NDcsXG4gICAgMHhkMCxcbiAgICAweDhmLFxuICAgIDB4ZmIsXG4gICAgMHgxMCxcbiAgICAweGQ0LFxuICAgIDB4YjgsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGJhLFxuICAgIDB4YWUsXG4gICAgMHhkYyxcbiAgICAweGU2LFxuICAgIDB4YWYsXG4gICAgMHg0OCxcbiAgICAweGEwLFxuICAgIDB4M2IsXG4gICAgMHhiZixcbiAgICAweGQyLFxuICAgIDB4NWUsXG4gICAgMHg4YyxcbiAgICAweGQwLFxuICAgIDB4MzYsXG4gICAgMHg0MSxcbiAgICAweDQxLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4YTEsXG4gICAgMHg0NCxcbiAgICAweDAzLFxuICAgIDB4NDIsXG4gICAgMHgwMCxcbiAgICAvLyBwdWJsaWMga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuXSk7XG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShjb21wcmVzc2VkID8gRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgOiBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEKTtcbiAgICBwcml2YXRlS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gOCA6IDkpO1xuICAgIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aDtcbiAgICAvLyBzZXF1ZW5jZSBoZWFkZXJcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGluZGV4ICs9IDE7XG4gICAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmO1xuICAgIGluZGV4ICs9IDE7XG4gICAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW5iKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzZXF1ZW5jZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICAgIGluZGV4ICs9IGxlbmI7XG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGluZGV4ICs9IDM7XG4gICAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMiB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8XG4gICAgICAgIGxlbmd0aCA8IGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVLZXkuc2xpY2UoaW5kZXggKyAyLCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pO1xufTtcbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICAgIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MzApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHNlcXVlbmNlIGxlbmd0aCBieXRlXG4gICAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciByXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gbGVuZ3RoIGZvciByXG4gICAgdmFyIHJsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MDtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICAgIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByaW5kZXggPSBpbmRleDtcbiAgICBpbmRleCArPSBybGVuO1xuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gbGVuZ3RoIGZvciBzXG4gICAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIHNsZW4gPSAoc2xlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICAgIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzaW5kZXggPSBpbmRleDtcbiAgICBpbmRleCArPSBzbGVuO1xuICAgIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnbmF0dXJlW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpXG4gICAgICAgIDtcbiAgICAvLyBjb3B5IHIgdmFsdWVcbiAgICBpZiAocmxlbiA+IDMyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcnZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbik7XG4gICAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcbiAgICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gICAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ25hdHVyZVtzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKVxuICAgICAgICA7XG4gICAgLy8gY29weSBzIHZhbHVlXG4gICAgaWYgKHNsZW4gPiAzMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShzaW5kZXgsIHNpbmRleCArIHNsZW4pO1xuICAgIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcbnZhciBlY3BhcmFtcyA9IGVjLmN1cnZlO1xuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gICAgaWYgKGQudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGV4cG9ydCB0byBERVIgZm9ybWF0XCIpO1xuICAgIH1cbiAgICB2YXIgcG9pbnQgPSBlYy5nLm11bChkKTtcbiAgICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcbmV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgICBpZiAoYm4udWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYm4uaW52bShlY3BhcmFtcy5uKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbn07XG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgICB2YXIgciA9IG5ldyBCTihzaWdPYmoucik7XG4gICAgaWYgKHIudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgICAgIHIgPSBuZXcgQk4oMCk7XG4gICAgfVxuICAgIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKTtcbiAgICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICAgICAgcyA9IG5ldyBCTigwKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuICAgIHZhciBwb2ludCA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5KTtcbiAgICB2YXIgc2NhbGFyID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICAgIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknKTtcbiAgICB9XG4gICAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgICByZXR1cm4gdG9QdWJsaWNLZXkoc2hhcmVkLmdldFgoKSwgc2hhcmVkLmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gKHgsIHksIGNvbXByZXNzZWQpIHtcbiAgICB2YXIgcHVibGljS2V5O1xuICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYygzMyk7XG4gICAgICAgIHB1YmxpY0tleVswXSA9IHkuaXNPZGQoKSA/IDB4MDMgOiAweDAyO1xuICAgICAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYyg2NSk7XG4gICAgICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgICAgICB5LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAzMyk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmdCbG9ja1RyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19yYW5kb21faWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1ycGMtcmFuZG9tLWlkXCIpKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSBqc29uX3JwY19yYW5kb21faWRfMS5kZWZhdWx0KCk7XG5jb25zdCBzZWMgPSAxMDAwO1xuY2xhc3MgUG9sbGluZ0Jsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2xsaW5nQmxvY2tUcmFja2VyIC0gbm8gcHJvdmlkZXIgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGJsb2NrUmVzZXREdXJhdGlvbjogb3B0cy5wb2xsaW5nSW50ZXJ2YWwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlYztcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gb3B0cy5yZXRyeVRpbWVvdXQgfHwgdGhpcy5fcG9sbGluZ0ludGVydmFsIC8gMTA7XG4gICAgICAgIHRoaXMuX2tlZXBFdmVudExvb3BBY3RpdmUgPSBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmU7XG4gICAgICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgYmxvY2sgcG9sbGluZ1xuICAgIGFzeW5jIGNoZWNrRm9yTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUxhdGVzdEJsb2NrKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKCk7XG4gICAgfVxuICAgIF9zdGFydCgpIHtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemUoKS5jYXRjaCgoZXJyKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgfVxuICAgIGFzeW5jIF9zeW5jaHJvbml6ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXJyID0gbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byB1cGRhdGUgbGF0ZXN0IGJsb2NrOlxcbiR7ZXJyLnN0YWNrfWApO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXdFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZW1pdEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ld0Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0LCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZUxhdGVzdEJsb2NrKCkge1xuICAgICAgICAvLyBmZXRjaCArIHNldCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKCk7XG4gICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChsYXRlc3RCbG9jayk7XG4gICAgfVxuICAgIGFzeW5jIF9mZXRjaExhdGVzdEJsb2NrKCkge1xuICAgICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9zZXRTa2lwQ2FjaGVGbGFnKSB7XG4gICAgICAgICAgICByZXEuc2tpcENhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBwaWZ5XzEuZGVmYXVsdCgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKTtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgZXJyb3IgZmV0Y2hpbmcgYmxvY2s6XFxuJHtyZXMuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUcmFja2VyID0gUG9sbGluZ0Jsb2NrVHJhY2tlcjtcbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24sIHVucmVmKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICAgICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICAgICAgaWYgKHRpbWVvdXRSZWYudW5yZWYgJiYgdW5yZWYpIHtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9sbGluZ0Jsb2NrVHJhY2tlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSBqc29uX3JwY19yYW5kb21faWRfMS5kZWZhdWx0KCk7XG5jbGFzcyBTdWJzY3JpYmVCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQmxvY2tUcmFja2VyXzEuQmFzZUJsb2NrVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIHBhcnNlICsgdmFsaWRhdGUgYXJnc1xuICAgICAgICBpZiAoIW9wdHMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3Vic2NyaWJlQmxvY2tUcmFja2VyIC0gbm8gcHJvdmlkZXIgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhc2VCbG9ja1RyYWNrZXIgY29uc3RydWN0b3JcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICB9XG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9zdWJzY3JpcHRpb25JZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF9ibG9ja051bWJlcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fY2FsbCgnZXRoX3N1YnNjcmliZScsICduZXdIZWFkcycsIHt9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm92aWRlci5vbignZGF0YScsIHRoaXMuX2hhbmRsZVN1YkRhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV3UG90ZW50aWFsTGF0ZXN0KGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9lbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25JZCAhPT0gbnVsbCAmJiB0aGlzLl9zdWJzY3JpcHRpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF91bnN1YnNjcmliZScsIHRoaXMuX3N1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25JZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FsbChtZXRob2QsIC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXIuc2VuZEFzeW5jKHtcbiAgICAgICAgICAgICAgICBpZDogY3JlYXRlUmFuZG9tSWQoKSwgbWV0aG9kLCBwYXJhbXMsIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgfSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaGFuZGxlU3ViRGF0YShfLCByZXNwb25zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChyZXNwb25zZS5tZXRob2QgPT09ICdldGhfc3Vic2NyaXB0aW9uJyAmJiAoKF9hID0gcmVzcG9uc2UucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaXB0aW9uKSA9PT0gdGhpcy5fc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChyZXNwb25zZS5wYXJhbXMucmVzdWx0Lm51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZUJsb2NrVHJhY2tlciA9IFN1YnNjcmliZUJsb2NrVHJhY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZUJsb2NrVHJhY2tlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUJsb2NrVHJhY2tlciA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNvbnN0IHNlYyA9IDEwMDA7XG5jb25zdCBjYWxjdWxhdGVTdW0gPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWU7XG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbJ3N5bmMnLCAnbGF0ZXN0J107XG5jbGFzcyBCYXNlQmxvY2tUcmFja2VyIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24gPSBvcHRzLmJsb2NrUmVzZXREdXJhdGlvbiB8fCAyMCAqIHNlYztcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGJpbmQgZnVuY3Rpb25zIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lciA9IHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBsaXN0ZW4gZm9yIGhhbmRsZXIgY2hhbmdlc1xuICAgICAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZztcbiAgICB9XG4gICAgZ2V0Q3VycmVudEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhaXQgZm9yIGEgbmV3IGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB0aGlzLm9uY2UoJ2xhdGVzdCcsIHJlc29sdmUpKTtcbiAgICAgICAgLy8gcmV0dXJuIG5ld2x5IHNldCBjdXJyZW50IGJsb2NrXG4gICAgICAgIHJldHVybiBsYXRlc3RCbG9jaztcbiAgICB9XG4gICAgLy8gZG9udCBhbGxvdyBtb2R1bGUgY29uc3VtZXIgdG8gcmVtb3ZlIG91ciBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIC8vIHBlcmZvcm0gZGVmYXVsdCBiZWhhdmlvciwgcHJlc2VydmUgZm4gYXJpdHlcbiAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS1hZGQgaW50ZXJuYWwgZXZlbnRzXG4gICAgICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgICAgICAgLy8gdHJpZ2dlciBzdG9wIGNoZWNrIGp1c3QgaW4gY2FzZVxuICAgICAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBfc3RhcnQoKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm9vcFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cbiAgICAgKi9cbiAgICBfZW5kKCkge1xuICAgICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgICB9XG4gICAgX3NldHVwSW50ZXJuYWxFdmVudHMoKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmNlXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICAgICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgX29uTmV3TGlzdGVuZXIoZXZlbnROYW1lKSB7XG4gICAgICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAgICBpZiAoYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21heWJlU3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxuICAgICAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heWJlRW5kKCk7XG4gICAgfVxuICAgIF9tYXliZVN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FuY2VsIHNldHRpbmcgbGF0ZXN0IGJsb2NrIHRvIHN0YWxlXG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgfVxuICAgIF9tYXliZUVuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpO1xuICAgICAgICB0aGlzLl9lbmQoKTtcbiAgICB9XG4gICAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQoKSB7XG4gICAgICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHNcbiAgICAgICAgICAgIC5tYXAoKGV2ZW50TmFtZSkgPT4gdGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkpXG4gICAgICAgICAgICAucmVkdWNlKGNhbGN1bGF0ZVN1bSk7XG4gICAgfVxuICAgIF9uZXdQb3RlbnRpYWxMYXRlc3QobmV3QmxvY2spIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJsb2NrID0gdGhpcy5fY3VycmVudEJsb2NrO1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBpZiBibG9rIG51bWJlciBpcyBoaWdoZXJcbiAgICAgICAgaWYgKGN1cnJlbnRCbG9jayAmJiAoaGV4VG9JbnQobmV3QmxvY2spIDw9IGhleFRvSW50KGN1cnJlbnRCbG9jaykpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKTtcbiAgICB9XG4gICAgX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jaykge1xuICAgICAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbmV3QmxvY2s7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF0ZXN0JywgbmV3QmxvY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KTtcbiAgICB9XG4gICAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9yZXNldEN1cnJlbnRCbG9jaywgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uKTtcbiAgICAgICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2V0Q3VycmVudEJsb2NrKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUJsb2NrVHJhY2tlciA9IEJhc2VCbG9ja1RyYWNrZXI7XG5mdW5jdGlvbiBoZXhUb0ludChoZXhJbnQpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGhleEludCwgMTYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUJsb2NrVHJhY2tlci5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiQ09NUFJFU1NFRF9UWVBFX0lOVkFMSURcIjogXCJjb21wcmVzc2VkIHNob3VsZCBiZSBhIGJvb2xlYW5cIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRFwiOiBcInByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfUkFOR0VfSU5WQUxJRFwiOiBcInByaXZhdGUga2V5IHJhbmdlIGlzIGludmFsaWRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZSBvciByZXN1bHRpbmcgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1RXRUFLX01VTF9GQUlMXCI6IFwidHdlYWsgb3V0IG9mIHJhbmdlXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9JTVBPUlRfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIsXG4gIFwiRUNfUFVCTElDX0tFWVNfVFlQRV9JTlZBTElEXCI6IFwicHVibGljIGtleXMgc2hvdWxkIGJlIGFuIEFycmF5XCIsXG4gIFwiRUNfUFVCTElDX0tFWVNfTEVOR1RIX0lOVkFMSURcIjogXCJwdWJsaWMga2V5cyBBcnJheSBzaG91bGQgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXkgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUxcIjogXCJ0aGUgcHVibGljIGtleSBjb3VsZCBub3QgYmUgcGFyc2VkIG9yIGlzIGludmFsaWRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX0NSRUFURV9GQUlMXCI6IFwicHJpdmF0ZSB3YXMgaW52YWxpZCwgdHJ5IGFnYWluXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZSBvciByZXN1bHRpbmcgcHVibGljIGtleSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UV0VBS19NVUxfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZVwiLFxuICBcIkVDX1BVQkxJQ19LRVlfQ09NQklORV9GQUlMXCI6IFwidGhlIHN1bSBvZiB0aGUgcHVibGljIGtleXMgaXMgbm90IHZhbGlkXCIsXG4gIFwiRUNESF9GQUlMXCI6IFwic2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KVwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSURcIjogXCJzaWduYXR1cmUgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEXCI6IFwic2lnbmF0dXJlIGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUxcIjogXCJjb3VsZG4ndCBwYXJzZSBzaWduYXR1cmVcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1NFUklBTElaRV9ERVJfRkFJTFwiOiBcImNvdWxkbid0IHNlcmlhbGl6ZSBzaWduYXR1cmUgdG8gREVSIGZvcm1hdFwiLFxuICBcIkVDRFNBX1NJR05fRkFJTFwiOiBcIm5vbmNlIGdlbmVyYXRpb24gZnVuY3Rpb24gZmFpbGVkIG9yIHByaXZhdGUga2V5IGlzIGludmFsaWRcIixcbiAgXCJFQ0RTQV9SRUNPVkVSX0ZBSUxcIjogXCJjb3VsZG4ndCByZWNvdmVyIHB1YmxpYyBrZXkgZnJvbSBzaWduYXR1cmVcIixcbiAgXCJNU0czMl9UWVBFX0lOVkFMSURcIjogXCJtZXNzYWdlIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIk1TRzMyX0xFTkdUSF9JTlZBTElEXCI6IFwibWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIk9QVElPTlNfVFlQRV9JTlZBTElEXCI6IFwib3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0XCIsXG4gIFwiT1BUSU9OU19EQVRBX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJPUFRJT05TX0RBVEFfTEVOR1RIX0lOVkFMSURcIjogXCJvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJPUFRJT05TX05PTkNFRk5fVFlQRV9JTlZBTElEXCI6IFwib3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uXCIsXG4gIFwiUkVDT1ZFUllfSURfVFlQRV9JTlZBTElEXCI6IFwicmVjb3Zlcnkgc2hvdWxkIGJlIGEgTnVtYmVyXCIsXG4gIFwiUkVDT1ZFUllfSURfVkFMVUVfSU5WQUxJRFwiOiBcInJlY292ZXJ5IHNob3VsZCBoYXZlIHZhbHVlIGJldHdlZW4gLTEgYW5kIDRcIixcbiAgXCJUV0VBS19UWVBFX0lOVkFMSURcIjogXCJ0d2VhayBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJUV0VBS19MRU5HVEhfSU5WQUxJRFwiOiBcInR3ZWFrIGxlbmd0aCBpcyBpbnZhbGlkXCJcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vLyBUeXBlRXJyb3JcbmV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBCb29sZWFuXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG4vLyBSYW5nZUVycm9yXG5leHBvcnRzLmlzQnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGVuZ3RoLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0J1ZmZlckxlbmd0aDIgPSBmdW5jdGlvbiAoYnVmZmVyLCBsZW5ndGgxLCBsZW5ndGgyLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgxICYmIGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aDIpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0xlbmd0aEdUWmVybyA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB0aHJvdyBSYW5nZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNOdW1iZXJJbkludGVydmFsID0gZnVuY3Rpb24gKG51bWJlciwgeCwgeSwgbWVzc2FnZSkge1xuICBpZiAobnVtYmVyIDw9IHggfHwgbnVtYmVyID49IHkpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgYmlwNjYgPSByZXF1aXJlKCdiaXA2NicpXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgLy8gYmVnaW5cbiAgMHgzMCwgMHg4MSwgMHhkMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbiAgLy8gcHJpdmF0ZSBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgLy8gbWlkZGxlXG4gIDB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsXG4gIDB4Y0UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsXG4gIDB4MjEsIDB4MDIsIDB4NzksIDB4YkUsIDB4NjYsIDB4N0UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y0UsIDB4ODcsXG4gIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y0UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsXG4gIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4YmEsIDB4YUUsIDB4ZGMsIDB4RTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NUUsXG4gIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4gIC8vIHB1YmxpYyBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMFxuXSlcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4gIC8vIGJlZ2luXG4gIDB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4gIC8vIHByaXZhdGUga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIC8vIG1pZGRsZVxuICAweGEwLCAweDgxLCAweGE1LCAweDMwLCAweDgxLCAweGEyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LFxuICAweGNFLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZFLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LFxuICAweDQxLCAweDA0LCAweDc5LCAweGJFLCAweDY2LCAweDdFLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNFLCAweDg3LFxuICAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNFLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LFxuICAweDE3LCAweDk4LCAweDQ4LCAweDNhLCAweGRhLCAweDc3LCAweDI2LCAweGEzLCAweGM0LCAweDY1LCAweDVkLCAweGE0LCAweGZiLCAweGZjLCAweDBFLCAweDExLFxuICAweDA4LCAweGE4LCAweGZkLCAweDE3LCAweGI0LCAweDQ4LCAweGE2LCAweDg1LCAweDU0LCAweDE5LCAweDljLCAweDQ3LCAweGQwLCAweDhmLCAweGZiLCAweDEwLFxuICAweGQ0LCAweGI4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZFLCAweGJhLCAweGFFLCAweGRjLCAweEU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVFLFxuICAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDQ0LCAweDAzLCAweDQyLCAweDAwLFxuICAvLyBwdWJsaWMga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDBcbl0pXG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpXG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSlcbiAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aFxuXG4gIC8vIHNlcXVlbmNlIGhlYWRlclxuICB2YXIgaW5kZXggPSAwXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVyblxuICBpbmRleCArPSAxXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgIShwcml2YXRlS2V5W2luZGV4XSAmIDB4ODApKSByZXR1cm5cblxuICB2YXIgbGVuYiA9IHByaXZhdGVLZXlbaW5kZXhdICYgMHg3ZlxuICBpbmRleCArPSAxXG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuXG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVyblxuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApXG4gIGluZGV4ICs9IGxlbmJcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKSByZXR1cm5cblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMyB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDJdICE9PSAweDAxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5kZXggKz0gM1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdID4gMHgyMCB8fFxuICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnJdKVxuICBmb3IgKHZhciBsZW5SID0gMzMsIHBvc1IgPSAwOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gIHZhciBzID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnNdKVxuICBmb3IgKHZhciBsZW5TID0gMzMsIHBvc1MgPSAwOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gIHJldHVybiBiaXA2Ni5lbmNvZGUoci5zbGljZShwb3NSKSwgcy5zbGljZShwb3NTKSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB0cnkge1xuICAgIHZhciBzaWdPYmogPSBiaXA2Ni5kZWNvZGUoc2lnKVxuICAgIGlmIChzaWdPYmouci5sZW5ndGggPT09IDMzICYmIHNpZ09iai5yWzBdID09PSAweDAwKSBzaWdPYmouciA9IHNpZ09iai5yLnNsaWNlKDEpXG4gICAgaWYgKHNpZ09iai5yLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgICBpZiAoc2lnT2JqLnMubGVuZ3RoID09PSAzMyAmJiBzaWdPYmouc1swXSA9PT0gMHgwMCkgc2lnT2JqLnMgPSBzaWdPYmoucy5zbGljZSgxKVxuICAgIGlmIChzaWdPYmoucy5sZW5ndGggPiAzMikgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2lnT2JqLnIuY29weShyLCAzMiAtIHNpZ09iai5yLmxlbmd0aClcbiAgc2lnT2JqLnMuY29weShzLCAzMiAtIHNpZ09iai5zLmxlbmd0aClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB2YXIgbGVuZ3RoID0gc2lnLmxlbmd0aFxuICB2YXIgaW5kZXggPSAwXG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgzMCkgcmV0dXJuXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWdbaW5kZXgrK11cbiAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODBcbiAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHJldHVyblxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgwMikgcmV0dXJuXG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnW2luZGV4KytdXG4gIGlmIChybGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MFxuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHJldHVyblxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWdbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpO1xuICAgIGZvciAocmxlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ1tpbmRleF1cbiAgfVxuICBpZiAocmxlbiA+IGxlbmd0aCAtIGluZGV4KSByZXR1cm5cbiAgdmFyIHJpbmRleCA9IGluZGV4XG4gIGluZGV4ICs9IHJsZW5cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDAyKSByZXR1cm5cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWdbaW5kZXgrK11cbiAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwXG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ1tpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSk7XG4gICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnW2luZGV4XVxuICB9XG4gIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHJldHVyblxuICB2YXIgc2luZGV4ID0gaW5kZXhcbiAgaW5kZXggKz0gc2xlblxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ1tyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKTtcbiAgLy8gY29weSByIHZhbHVlXG4gIGlmIChybGVuID4gMzIpIHJldHVyblxuICB2YXIgcnZhbHVlID0gc2lnLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbilcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKVxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ1tzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKTtcbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHJldHVyblxuICB2YXIgc3ZhbHVlID0gc2lnLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbilcbiAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBrZWNjYWtTdGF0ZSA9IHJlcXVpcmUoJy4va2VjY2FrLXN0YXRlLXVucm9sbCcpXG5cbmZ1bmN0aW9uIEtlY2NhayAoKSB7XG4gIC8vIG11Y2ggZmFzdGVyIHRoYW4gYG5ldyBBcnJheSg1MClgXG4gIHRoaXMuc3RhdGUgPSBbXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwXG4gIF1cblxuICB0aGlzLmJsb2NrU2l6ZSA9IG51bGxcbiAgdGhpcy5jb3VudCA9IDBcbiAgdGhpcy5zcXVlZXppbmcgPSBmYWxzZVxufVxuXG5LZWNjYWsucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAocmF0ZSwgY2FwYWNpdHkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB0aGlzLnN0YXRlW2ldID0gMFxuICB0aGlzLmJsb2NrU2l6ZSA9IHJhdGUgLyA4XG4gIHRoaXMuY291bnQgPSAwXG4gIHRoaXMuc3F1ZWV6aW5nID0gZmFsc2Vcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5hYnNvcmIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gXj0gZGF0YVtpXSA8PCAoOCAqICh0aGlzLmNvdW50ICUgNCkpXG4gICAgdGhpcy5jb3VudCArPSAxXG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICAgICAgdGhpcy5jb3VudCA9IDBcbiAgICB9XG4gIH1cbn1cblxuS2VjY2FrLnByb3RvdHlwZS5hYnNvcmJMYXN0RmV3Qml0cyA9IGZ1bmN0aW9uIChiaXRzKSB7XG4gIHRoaXMuc3RhdGVbfn4odGhpcy5jb3VudCAvIDQpXSBePSBiaXRzIDw8ICg4ICogKHRoaXMuY291bnQgJSA0KSlcbiAgaWYgKChiaXRzICYgMHg4MCkgIT09IDAgJiYgdGhpcy5jb3VudCA9PT0gKHRoaXMuYmxvY2tTaXplIC0gMSkpIGtlY2Nha1N0YXRlLnAxNjAwKHRoaXMuc3RhdGUpXG4gIHRoaXMuc3RhdGVbfn4oKHRoaXMuYmxvY2tTaXplIC0gMSkgLyA0KV0gXj0gMHg4MCA8PCAoOCAqICgodGhpcy5ibG9ja1NpemUgLSAxKSAlIDQpKVxuICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICB0aGlzLmNvdW50ID0gMFxuICB0aGlzLnNxdWVlemluZyA9IHRydWVcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5zcXVlZXplID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICBpZiAoIXRoaXMuc3F1ZWV6aW5nKSB0aGlzLmFic29yYkxhc3RGZXdCaXRzKDB4MDEpXG5cbiAgdmFyIG91dHB1dCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBvdXRwdXRbaV0gPSAodGhpcy5zdGF0ZVt+fih0aGlzLmNvdW50IC8gNCldID4+PiAoOCAqICh0aGlzLmNvdW50ICUgNCkpKSAmIDB4ZmZcbiAgICB0aGlzLmNvdW50ICs9IDFcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgIGtlY2Nha1N0YXRlLnAxNjAwKHRoaXMuc3RhdGUpXG4gICAgICB0aGlzLmNvdW50ID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSBkZXN0LnN0YXRlW2ldID0gdGhpcy5zdGF0ZVtpXVxuICBkZXN0LmJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplXG4gIGRlc3QuY291bnQgPSB0aGlzLmNvdW50XG4gIGRlc3Quc3F1ZWV6aW5nID0gdGhpcy5zcXVlZXppbmdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLZWNjYWtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGNyZWF0ZUtlY2NhayA9IHJlcXVpcmUoJy4va2VjY2FrJylcbnZhciBjcmVhdGVTaGFrZSA9IHJlcXVpcmUoJy4vc2hha2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLZWNjYWtTdGF0ZSkge1xuICB2YXIgS2VjY2FrID0gY3JlYXRlS2VjY2FrKEtlY2Nha1N0YXRlKVxuICB2YXIgU2hha2UgPSBjcmVhdGVTaGFrZShLZWNjYWtTdGF0ZSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGFsZ29yaXRobSwgb3B0aW9ucykge1xuICAgIHZhciBoYXNoID0gdHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycgPyBhbGdvcml0aG0udG9Mb3dlckNhc2UoKSA6IGFsZ29yaXRobVxuICAgIHN3aXRjaCAoaGFzaCkge1xuICAgICAgY2FzZSAna2VjY2FrMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCBudWxsLCAyMjQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWsyNTYnOiByZXR1cm4gbmV3IEtlY2NhaygxMDg4LCA1MTIsIG51bGwsIDI1Niwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ2tlY2NhazM4NCc6IHJldHVybiBuZXcgS2VjY2FrKDgzMiwgNzY4LCBudWxsLCAzODQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWs1MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIG51bGwsIDUxMiwgb3B0aW9ucylcblxuICAgICAgY2FzZSAnc2hhMy0yMjQnOiByZXR1cm4gbmV3IEtlY2NhaygxMTUyLCA0NDgsIDB4MDYsIDIyNCwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ3NoYTMtMjU2JzogcmV0dXJuIG5ldyBLZWNjYWsoMTA4OCwgNTEyLCAweDA2LCAyNTYsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTM4NCc6IHJldHVybiBuZXcgS2VjY2FrKDgzMiwgNzY4LCAweDA2LCAzODQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTUxMic6IHJldHVybiBuZXcgS2VjY2FrKDU3NiwgMTAyNCwgMHgwNiwgNTEyLCBvcHRpb25zKVxuXG4gICAgICBjYXNlICdzaGFrZTEyOCc6IHJldHVybiBuZXcgU2hha2UoMTM0NCwgMjU2LCAweDFmLCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hha2UyNTYnOiByZXR1cm4gbmV3IFNoYWtlKDEwODgsIDUxMiwgMHgxZiwgb3B0aW9ucylcblxuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKShyZXF1aXJlKCcuL2xpYi9lbGxpcHRpYycpKVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2FwaScpKHJlcXVpcmUoJy4vbGliL2tlY2NhaycpKVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cclxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxyXG5jb25zdCBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcclxuXHJcbnZhciBBQkkgPSBmdW5jdGlvbiAoKSB7XHJcbn1cclxuXHJcbi8vIENvbnZlcnQgZnJvbSBzaG9ydCB0byBjYW5vbmljYWwgbmFtZXNcclxuLy8gRklYTUU6IG9wdGltaXNlIG9yIG1ha2UgdGhpcyBuaWNlcj9cclxuZnVuY3Rpb24gZWxlbWVudGFyeU5hbWUgKG5hbWUpIHtcclxuICBpZiAobmFtZS5zdGFydHNXaXRoKCdpbnRbJykpIHtcclxuICAgIHJldHVybiAnaW50MjU2JyArIG5hbWUuc2xpY2UoMylcclxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XHJcbiAgICByZXR1cm4gJ2ludDI1NidcclxuICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgndWludFsnKSkge1xyXG4gICAgcmV0dXJuICd1aW50MjU2JyArIG5hbWUuc2xpY2UoNClcclxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1aW50Jykge1xyXG4gICAgcmV0dXJuICd1aW50MjU2J1xyXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xyXG4gICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg1KVxyXG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2ZpeGVkJykge1xyXG4gICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnXHJcbiAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZFsnKSkge1xyXG4gICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNilcclxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XHJcbiAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnXHJcbiAgfVxyXG4gIHJldHVybiBuYW1lXHJcbn1cclxuXHJcbkFCSS5ldmVudElEID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVzKSB7XHJcbiAgLy8gRklYTUU6IHVzZSBub2RlLmpzIHV0aWwuZm9ybWF0P1xyXG4gIHZhciBzaWcgPSBuYW1lICsgJygnICsgdHlwZXMubWFwKGVsZW1lbnRhcnlOYW1lKS5qb2luKCcsJykgKyAnKSdcclxuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHNpZykpXHJcbn1cclxuXHJcbkFCSS5tZXRob2RJRCA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlcykge1xyXG4gIHJldHVybiBBQkkuZXZlbnRJRChuYW1lLCB0eXBlcykuc2xpY2UoMCwgNClcclxufVxyXG5cclxuLy8gUGFyc2UgTiBmcm9tIHR5cGU8Tj5cclxuZnVuY3Rpb24gcGFyc2VUeXBlTiAodHlwZSkge1xyXG4gIHJldHVybiBwYXJzZUludCgvXlxcRCsoXFxkKykkLy5leGVjKHR5cGUpWzFdLCAxMClcclxufVxyXG5cclxuLy8gUGFyc2UgTixNIGZyb20gdHlwZTxOPng8TT5cclxuZnVuY3Rpb24gcGFyc2VUeXBlTnhNICh0eXBlKSB7XHJcbiAgdmFyIHRtcCA9IC9eXFxEKyhcXGQrKXgoXFxkKykkLy5leGVjKHR5cGUpXHJcbiAgcmV0dXJuIFsgcGFyc2VJbnQodG1wWzFdLCAxMCksIHBhcnNlSW50KHRtcFsyXSwgMTApIF1cclxufVxyXG5cclxuLy8gUGFyc2UgTiBpbiB0eXBlWzxOPl0gd2hlcmUgXCJ0eXBlXCIgY2FuIGl0c2VsZiBiZSBhbiBhcnJheSB0eXBlLlxyXG5mdW5jdGlvbiBwYXJzZVR5cGVBcnJheSAodHlwZSkge1xyXG4gIHZhciB0bXAgPSB0eXBlLm1hdGNoKC8oLiopXFxbKC4qPylcXF0kLylcclxuICBpZiAodG1wKSB7XHJcbiAgICByZXR1cm4gdG1wWzJdID09PSAnJyA/ICdkeW5hbWljJyA6IHBhcnNlSW50KHRtcFsyXSwgMTApXHJcbiAgfVxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTnVtYmVyIChhcmcpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmdcclxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIGlmICh1dGlscy5pc0hleFByZWZpeGVkKGFyZykpIHtcclxuICAgICAgcmV0dXJuIG5ldyBCTih1dGlscy5zdHJpcEhleFByZWZpeChhcmcpLCAxNilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgQk4oYXJnLCAxMClcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gbmV3IEJOKGFyZylcclxuICB9IGVsc2UgaWYgKGFyZy50b0FycmF5KSB7XHJcbiAgICAvLyBhc3N1bWUgdGhpcyBpcyBhIEJOIGZvciB0aGUgbW9tZW50LCByZXBsYWNlIHdpdGggQk4uaXNCTiBzb29uXHJcbiAgICByZXR1cm4gYXJnXHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgaXMgbm90IGEgbnVtYmVyJylcclxuICB9XHJcbn1cclxuXHJcbi8vIHNvbWVNZXRob2QoYnl0ZXMsdWludClcclxuLy8gc29tZU1ldGhvZChieXRlcyx1aW50KTooYm9vbGVhbilcclxuZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUgKHNpZykge1xyXG4gIHZhciB0bXAgPSAvXihcXHcrKVxcKCguKilcXCkkLy5leGVjKHNpZylcclxuXHJcbiAgaWYgKHRtcC5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlJylcclxuICB9XHJcblxyXG4gIHZhciBhcmdzID0gL14oLispXFwpOlxcKCguKykkLy5leGVjKHRtcFsyXSlcclxuXHJcbiAgaWYgKGFyZ3MgIT09IG51bGwgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1ldGhvZDogdG1wWzFdLFxyXG4gICAgICBhcmdzOiBhcmdzWzFdLnNwbGl0KCcsJyksXHJcbiAgICAgIHJldGFyZ3M6IGFyZ3NbMl0uc3BsaXQoJywnKVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgcGFyYW1zID0gdG1wWzJdLnNwbGl0KCcsJylcclxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxICYmIHBhcmFtc1swXSA9PT0gJycpIHtcclxuICAgICAgLy8gU3BlY2lhbC1jYXNlIChwb3NzaWJseSBuYWl2ZSkgZml4dXAgZm9yIGZ1bmN0aW9ucyB0aGF0IHRha2Ugbm8gYXJndW1lbnRzLlxyXG4gICAgICAvLyBUT0RPOiBzcGVjaWFsIGNhc2VzIGFyZSBhbHdheXMgYmFkLCBidXQgdGhpcyBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuXHJcbiAgICAgIC8vIG1hdGNoIHdoYXQgdGhlIGNhbGxpbmcgZnVuY3Rpb25zIGV4cGVjdFxyXG4gICAgICBwYXJhbXMgPSBbXVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWV0aG9kOiB0bXBbMV0sXHJcbiAgICAgIGFyZ3M6IHBhcmFtc1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRW5jb2RlcyBhIHNpbmdsZSBpdGVtIChjYW4gYmUgZHluYW1pYyBhcnJheSlcclxuLy8gQHJldHVybnM6IEJ1ZmZlclxyXG5mdW5jdGlvbiBlbmNvZGVTaW5nbGUgKHR5cGUsIGFyZykge1xyXG4gIHZhciBzaXplLCBudW0sIHJldCwgaVxyXG5cclxuICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XHJcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCd1aW50MTYwJywgcGFyc2VOdW1iZXIoYXJnKSlcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xyXG4gICAgcmV0dXJuIGVuY29kZVNpbmdsZSgndWludDgnLCBhcmcgPyAxIDogMClcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIEJ1ZmZlci5mcm9tKGFyZywgJ3V0ZjgnKSlcclxuICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcclxuICAgIC8vIHRoaXMgcGFydCBoYW5kbGVzIGZpeGVkLWxlbmd0aCAoWzJdKSBhbmQgdmFyaWFibGUgbGVuZ3RoIChbXSkgYXJyYXlzXHJcbiAgICAvLyBOT1RFOiB3ZSBjYXRjaCBoZXJlIGFsbCBjYWxscyB0byBhcnJheXMsIHRoYXQgc2ltcGxpZmllcyB0aGUgcmVzdFxyXG4gICAgaWYgKHR5cGVvZiBhcmcubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBhcnJheT8nKVxyXG4gICAgfVxyXG4gICAgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXHJcbiAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnICYmIHNpemUgIT09IDAgJiYgYXJnLmxlbmd0aCA+IHNpemUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJyArIHNpemUpXHJcbiAgICB9XHJcbiAgICByZXQgPSBbXVxyXG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKVxyXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGFyZyA9IEpTT04ucGFyc2UoYXJnKVxyXG4gICAgfVxyXG4gICAgZm9yIChpIGluIGFyZykge1xyXG4gICAgICByZXQucHVzaChlbmNvZGVTaW5nbGUodHlwZSwgYXJnW2ldKSlcclxuICAgIH1cclxuICAgIGlmIChzaXplID09PSAnZHluYW1pYycpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpXHJcbiAgICAgIHJldC51bnNoaWZ0KGxlbmd0aClcclxuICAgIH1cclxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHJldClcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcclxuICAgIGFyZyA9IEJ1ZmZlci5mcm9tKGFyZylcclxuXHJcbiAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aCksIGFyZyBdKVxyXG5cclxuICAgIGlmICgoYXJnLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xyXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgcmV0LCB1dGlscy56ZXJvcygzMiAtIChhcmcubGVuZ3RoICUgMzIpKSBdKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXRcclxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xyXG4gICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcclxuICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzPE4+IHdpZHRoOiAnICsgc2l6ZSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXRpbHMuc2V0TGVuZ3RoUmlnaHQoYXJnLCAzMilcclxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XHJcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxyXG4gICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKVxyXG4gICAgfVxyXG5cclxuICAgIG51bSA9IHBhcnNlTnVtYmVyKGFyZylcclxuICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAobnVtIDwgMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgaXMgbmVnYXRpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW0udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcclxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcclxuICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXHJcbiAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcclxuICAgIH1cclxuXHJcbiAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpXHJcbiAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVtLnRvVHdvcygyNTYpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXHJcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XHJcbiAgICBzaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpXHJcblxyXG4gICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKVxyXG5cclxuICAgIGlmIChudW0gPCAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWZpeGVkIGlzIG5lZ2F0aXZlJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgbnVtLm11bChuZXcgQk4oMikucG93KG5ldyBCTihzaXplWzFdKSkpKVxyXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdmaXhlZCcpKSB7XHJcbiAgICBzaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpXHJcblxyXG4gICAgcmV0dXJuIGVuY29kZVNpbmdsZSgnaW50MjU2JywgcGFyc2VOdW1iZXIoYXJnKS5tdWwobmV3IEJOKDIpLnBvdyhuZXcgQk4oc2l6ZVsxXSkpKSlcclxuICB9XHJcblxyXG4gIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgdHlwZSlcclxufVxyXG5cclxuLy8gRGVjb2RlcyBhIHNpbmdsZSBpdGVtIChjYW4gYmUgZHluYW1pYyBhcnJheSlcclxuLy8gQHJldHVybnM6IGFycmF5XHJcbi8vIEZJWE1FOiB0aGlzIG1ldGhvZCB3aWxsIG5lZWQgYSBsb3Qgb2YgYXR0ZW50aW9uIGF0IGNoZWNraW5nIGxpbWl0cyBhbmQgdmFsaWRhdGlvblxyXG5mdW5jdGlvbiBkZWNvZGVTaW5nbGUgKHBhcnNlZFR5cGUsIGRhdGEsIG9mZnNldCkge1xyXG4gIGlmICh0eXBlb2YgcGFyc2VkVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHBhcnNlZFR5cGUgPSBwYXJzZVR5cGUocGFyc2VkVHlwZSlcclxuICB9XHJcbiAgdmFyIHNpemUsIG51bSwgcmV0LCBpXHJcblxyXG4gIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdhZGRyZXNzJykge1xyXG4gICAgcmV0dXJuIGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldCkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAyMCkudG9TdHJpbmcoJ2hleCcpXHJcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdib29sJykge1xyXG4gICAgcmV0dXJuIGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldCkudG9TdHJpbmcoKSA9PT0gbmV3IEJOKDEpLnRvU3RyaW5nKClcclxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBieXRlcyA9IGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldClcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKS50b1N0cmluZygpXHJcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLmlzQXJyYXkpIHtcclxuICAgIC8vIHRoaXMgcGFydCBoYW5kbGVzIGZpeGVkLWxlbmd0aCBhcnJheXMgKFsyXSkgYW5kIHZhcmlhYmxlIGxlbmd0aCAoW10pIGFycmF5c1xyXG4gICAgLy8gTk9URTogd2UgY2F0Y2ggaGVyZSBhbGwgY2FsbHMgdG8gYXJyYXlzLCB0aGF0IHNpbXBsaWZpZXMgdGhlIHJlc3RcclxuICAgIHJldCA9IFtdXHJcbiAgICBzaXplID0gcGFyc2VkVHlwZS5zaXplXHJcblxyXG4gICAgaWYgKHBhcnNlZFR5cGUuc2l6ZSA9PT0gJ2R5bmFtaWMnKSB7XHJcbiAgICAgIG9mZnNldCA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKVxyXG4gICAgICBzaXplID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpXHJcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDMyXHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlU2luZ2xlKHBhcnNlZFR5cGUuc3ViQXJyYXksIGRhdGEsIG9mZnNldClcclxuICAgICAgcmV0LnB1c2goZGVjb2RlZClcclxuICAgICAgb2Zmc2V0ICs9IHBhcnNlZFR5cGUuc3ViQXJyYXkubWVtb3J5VXNhZ2VcclxuICAgIH1cclxuICAgIHJldHVybiByZXRcclxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZSA9PT0gJ2J5dGVzJykge1xyXG4gICAgb2Zmc2V0ID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpXHJcbiAgICBzaXplID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpXHJcbiAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBzaXplKVxyXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcclxuICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcGFyc2VkVHlwZS5zaXplKVxyXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xyXG4gICAgbnVtID0gbmV3IEJOKGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMiksIDE2LCAnYmUnKVxyXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBwYXJzZWRUeXBlLnNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtXHJcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUuc3RhcnRzV2l0aCgnaW50JykpIHtcclxuICAgIG51bSA9IG5ldyBCTihkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpLCAxNiwgJ2JlJykuZnJvbVR3b3MoMjU2KVxyXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgcGFyc2VkVHlwZS5zaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW1cclxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZS5zdGFydHNXaXRoKCd1Zml4ZWQnKSkge1xyXG4gICAgc2l6ZSA9IG5ldyBCTigyKS5wb3cobmV3IEJOKHBhcnNlZFR5cGUuc2l6ZVsxXSkpXHJcbiAgICBudW0gPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBkYXRhLCBvZmZzZXQpXHJcbiAgICBpZiAoIW51bS5tb2Qoc2l6ZSkuaXNaZXJvKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNpbWFscyBub3Qgc3VwcG9ydGVkIHlldCcpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtLmRpdihzaXplKVxyXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcclxuICAgIHNpemUgPSBuZXcgQk4oMikucG93KG5ldyBCTihwYXJzZWRUeXBlLnNpemVbMV0pKVxyXG4gICAgbnVtID0gZGVjb2RlU2luZ2xlKCdpbnQyNTYnLCBkYXRhLCBvZmZzZXQpXHJcbiAgICBpZiAoIW51bS5tb2Qoc2l6ZSkuaXNaZXJvKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNpbWFscyBub3Qgc3VwcG9ydGVkIHlldCcpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtLmRpdihzaXplKVxyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHBhcnNlZFR5cGUubmFtZSlcclxufVxyXG5cclxuLy8gUGFyc2UgdGhlIGdpdmVuIHR5cGVcclxuLy8gQHJldHVybnM6IHt9IGNvbnRhaW5pbmcgdGhlIHR5cGUgaXRzZWxmLCBtZW1vcnkgdXNhZ2UgYW5kIChpbmNsdWRpbmcgc2l6ZSBhbmQgc3ViQXJyYXkgaWYgYXBwbGljYWJsZSlcclxuZnVuY3Rpb24gcGFyc2VUeXBlICh0eXBlKSB7XHJcbiAgdmFyIHNpemVcclxuICB2YXIgcmV0XHJcbiAgaWYgKGlzQXJyYXkodHlwZSkpIHtcclxuICAgIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKVxyXG4gICAgdmFyIHN1YkFycmF5ID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXHJcbiAgICBzdWJBcnJheSA9IHBhcnNlVHlwZShzdWJBcnJheSlcclxuICAgIHJldCA9IHtcclxuICAgICAgaXNBcnJheTogdHJ1ZSxcclxuICAgICAgbmFtZTogdHlwZSxcclxuICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgbWVtb3J5VXNhZ2U6IHNpemUgPT09ICdkeW5hbWljJyA/IDMyIDogc3ViQXJyYXkubWVtb3J5VXNhZ2UgKiBzaXplLFxyXG4gICAgICBzdWJBcnJheTogc3ViQXJyYXlcclxuICAgIH1cclxuICAgIHJldHVybiByZXRcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIHJhd1R5cGVcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdhZGRyZXNzJzpcclxuICAgICAgICByYXdUeXBlID0gJ3VpbnQxNjAnXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnYm9vbCc6XHJcbiAgICAgICAgcmF3VHlwZSA9ICd1aW50OCdcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgIHJhd1R5cGUgPSAnYnl0ZXMnXHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICAgIHJldCA9IHtcclxuICAgICAgcmF3VHlwZTogcmF3VHlwZSxcclxuICAgICAgbmFtZTogdHlwZSxcclxuICAgICAgbWVtb3J5VXNhZ2U6IDMyXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykgJiYgdHlwZSAhPT0gJ2J5dGVzJykgfHwgdHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgdHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xyXG4gICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcclxuICAgIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1Zml4ZWQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcclxuICAgICAgcmV0LnNpemUgPSBwYXJzZVR5cGVOeE0odHlwZSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpICYmIHR5cGUgIT09ICdieXRlcycgJiYgKHJldC5zaXplIDwgMSB8fCByZXQuc2l6ZSA+IDMyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyByZXQuc2l6ZSlcclxuICAgIH1cclxuICAgIGlmICgodHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgdHlwZS5zdGFydHNXaXRoKCdpbnQnKSkgJiYgKHJldC5zaXplICUgOCB8fCByZXQuc2l6ZSA8IDggfHwgcmV0LnNpemUgPiAyNTYpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQvdWludDxOPiB3aWR0aDogJyArIHJldC5zaXplKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldFxyXG4gIH1cclxufVxyXG5cclxuLy8gSXMgYSB0eXBlIGR5bmFtaWM/XHJcbmZ1bmN0aW9uIGlzRHluYW1pYyAodHlwZSkge1xyXG4gIC8vIEZJWE1FOiBoYW5kbGUgYWxsIHR5cGVzPyBJIGRvbid0IHRoaW5rIGFueXRoaW5nIGlzIG1pc3Npbmcgbm93XHJcbiAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJykgfHwgKHR5cGUgPT09ICdieXRlcycpIHx8IChwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKVxyXG59XHJcblxyXG4vLyBJcyBhIHR5cGUgYW4gYXJyYXk/XHJcbmZ1bmN0aW9uIGlzQXJyYXkgKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDFcclxufVxyXG5cclxuLy8gRW5jb2RlIGEgbWV0aG9kL2V2ZW50IHdpdGggYXJndW1lbnRzXHJcbi8vIEB0eXBlcyBhbiBhcnJheSBvZiBzdHJpbmcgdHlwZSBuYW1lc1xyXG4vLyBAYXJncyAgYW4gYXJyYXkgb2YgdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xyXG5BQkkucmF3RW5jb2RlID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcclxuICB2YXIgb3V0cHV0ID0gW11cclxuICB2YXIgZGF0YSA9IFtdXHJcblxyXG4gIHZhciBoZWFkTGVuZ3RoID0gMFxyXG5cclxuICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICB2YXIgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXHJcblxyXG4gICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnKSB7XHJcbiAgICAgICAgaGVhZExlbmd0aCArPSAzMiAqIHNpemVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoZWFkTGVuZ3RoICs9IDMyXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhlYWRMZW5ndGggKz0gMzJcclxuICAgIH1cclxuICB9KVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGVzW2ldKVxyXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXHJcbiAgICB2YXIgY3VyID0gZW5jb2RlU2luZ2xlKHR5cGUsIHZhbHVlKVxyXG5cclxuICAgIC8vIFVzZSB0aGUgaGVhZC90YWlsIG1ldGhvZCBmb3Igc3RvcmluZyBkeW5hbWljIGRhdGFcclxuICAgIGlmIChpc0R5bmFtaWModHlwZSkpIHtcclxuICAgICAgb3V0cHV0LnB1c2goZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgaGVhZExlbmd0aCkpXHJcbiAgICAgIGRhdGEucHVzaChjdXIpXHJcbiAgICAgIGhlYWRMZW5ndGggKz0gY3VyLmxlbmd0aFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3V0cHV0LnB1c2goY3VyKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0cHV0LmNvbmNhdChkYXRhKSlcclxufVxyXG5cclxuQUJJLnJhd0RlY29kZSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSkge1xyXG4gIHZhciByZXQgPSBbXVxyXG4gIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxyXG4gIHZhciBvZmZzZXQgPSAwXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSlcclxuICAgIHZhciBwYXJzZWQgPSBwYXJzZVR5cGUodHlwZSwgZGF0YSwgb2Zmc2V0KVxyXG4gICAgdmFyIGRlY29kZWQgPSBkZWNvZGVTaW5nbGUocGFyc2VkLCBkYXRhLCBvZmZzZXQpXHJcbiAgICBvZmZzZXQgKz0gcGFyc2VkLm1lbW9yeVVzYWdlXHJcbiAgICByZXQucHVzaChkZWNvZGVkKVxyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbkFCSS5zaW1wbGVFbmNvZGUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDEpXHJcbiAgdmFyIHNpZyA9IHBhcnNlU2lnbmF0dXJlKG1ldGhvZClcclxuXHJcbiAgLy8gRklYTUU6IHZhbGlkYXRlL2NvbnZlcnQgYXJndW1lbnRzXHJcbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWcuYXJncy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgY291bnQgbWlzbWF0Y2gnKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWyBBQkkubWV0aG9kSUQoc2lnLm1ldGhvZCwgc2lnLmFyZ3MpLCBBQkkucmF3RW5jb2RlKHNpZy5hcmdzLCBhcmdzKSBdKVxyXG59XHJcblxyXG5BQkkuc2ltcGxlRGVjb2RlID0gZnVuY3Rpb24gKG1ldGhvZCwgZGF0YSkge1xyXG4gIHZhciBzaWcgPSBwYXJzZVNpZ25hdHVyZShtZXRob2QpXHJcblxyXG4gIC8vIEZJWE1FOiB2YWxpZGF0ZS9jb252ZXJ0IGFyZ3VtZW50c1xyXG4gIGlmICghc2lnLnJldGFyZ3MpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gcmV0dXJuIHZhbHVlcyBpbiBtZXRob2QnKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEFCSS5yYXdEZWNvZGUoc2lnLnJldGFyZ3MsIGRhdGEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeSAodHlwZSwgdmFsdWUpIHtcclxuICBpZiAodHlwZS5zdGFydHNXaXRoKCdhZGRyZXNzJykgfHwgdHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XHJcbiAgICByZXR1cm4gJzB4JyArIHZhbHVlLnRvU3RyaW5nKCdoZXgnKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxyXG4gIH1cclxufVxyXG5cclxuQUJJLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XHJcbiAgdmFyIHJldCA9IFtdXHJcblxyXG4gIGZvciAodmFyIGkgaW4gdHlwZXMpIHtcclxuICAgIHZhciB0eXBlID0gdHlwZXNbaV1cclxuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXVxyXG5cclxuICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IHR5cGUsIGNvbmNhdCB0aGUgaXRlbXNcclxuICAgIGlmICgvXlteXFxbXStcXFsuKlxcXSQvLnRlc3QodHlwZSkpIHtcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHR5cGUsIGl0ZW0pXHJcbiAgICAgIH0pLmpvaW4oJywgJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gc3RyaW5naWZ5KHR5cGUsIHZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIHJldC5wdXNoKHZhbHVlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG5BQkkuc29saWRpdHlQYWNrID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcclxuICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB0eXBlcyBhcmUgbm90IG1hdGNoaW5nIHRoZSB2YWx1ZXMnKVxyXG4gIH1cclxuXHJcbiAgdmFyIHNpemUsIG51bVxyXG4gIHZhciByZXQgPSBbXVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGVzW2ldKVxyXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcclxuICAgICAgcmV0LnB1c2godmFsdWUpXHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldC5wdXNoKEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcclxuICAgICAgcmV0LnB1c2goQnVmZmVyLmZyb20odmFsdWUgPyAnMDEnIDogJzAwJywgJ2hleCcpKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcclxuICAgICAgcmV0LnB1c2godXRpbHMuc2V0TGVuZ3RoTGVmdCh2YWx1ZSwgMjApKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcclxuICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcclxuICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlczxOPiB3aWR0aDogJyArIHNpemUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldC5wdXNoKHV0aWxzLnNldExlbmd0aFJpZ2h0KHZhbHVlLCBzaXplKSlcclxuICAgIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcclxuICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcclxuICAgICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdWludDxOPiB3aWR0aDogJyArIHNpemUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG51bSA9IHBhcnNlTnVtYmVyKHZhbHVlKVxyXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0LnB1c2gobnVtLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgc2l6ZSAvIDgpKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XHJcbiAgICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXHJcbiAgICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludDxOPiB3aWR0aDogJyArIHNpemUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG51bSA9IHBhcnNlTnVtYmVyKHZhbHVlKVxyXG4gICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXQucHVzaChudW0udG9Ud29zKHNpemUpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgc2l6ZSAvIDgpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgYWxsIG90aGVyIHR5cGVzXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgdHlwZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KHJldClcclxufVxyXG5cclxuQUJJLnNvbGlkaXR5U0hBMyA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XHJcbiAgcmV0dXJuIHV0aWxzLmtlY2NhazI1NihBQkkuc29saWRpdHlQYWNrKHR5cGVzLCB2YWx1ZXMpKVxyXG59XHJcblxyXG5BQkkuc29saWRpdHlTSEEyNTYgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xyXG4gIHJldHVybiB1dGlscy5zaGEyNTYoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSlcclxufVxyXG5cclxuQUJJLnNvbGlkaXR5UklQRU1EMTYwID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcclxuICByZXR1cm4gdXRpbHMucmlwZW1kMTYwKEFCSS5zb2xpZGl0eVBhY2sodHlwZXMsIHZhbHVlcyksIHRydWUpXHJcbn1cclxuXHJcbi8vIFNlcnBlbnQncyB1c2VycyBhcmUgZmFtaWxpYXIgd2l0aCB0aGlzIGVuY29kaW5nXHJcbi8vIC0gczogc3RyaW5nXHJcbi8vIC0gYjogYnl0ZXNcclxuLy8gLSBiPE4+OiBieXRlczxOPlxyXG4vLyAtIGk6IGludDI1NlxyXG4vLyAtIGE6IGludDI1NltdXHJcblxyXG5mdW5jdGlvbiBpc051bWVyaWMgKGMpIHtcclxuICAvLyBGSVhNRTogaXMgdGhpcyBjb3JyZWN0PyBTZWVtcyB0byB3b3JrXHJcbiAgcmV0dXJuIChjID49ICcwJykgJiYgKGMgPD0gJzknKVxyXG59XHJcblxyXG4vLyBGb3IgYSBcImRvY3VtZW50YXRpb25cIiByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vc2VycGVudC9ibG9iL2RldmVsb3AvcHJlcHJvY2Vzcy5jcHBcclxuQUJJLmZyb21TZXJwZW50ID0gZnVuY3Rpb24gKHNpZykge1xyXG4gIHZhciByZXQgPSBbXVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdHlwZSA9IHNpZ1tpXVxyXG4gICAgaWYgKHR5cGUgPT09ICdzJykge1xyXG4gICAgICByZXQucHVzaCgnYnl0ZXMnKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYicpIHtcclxuICAgICAgdmFyIHRtcCA9ICdieXRlcydcclxuICAgICAgdmFyIGogPSBpICsgMVxyXG4gICAgICB3aGlsZSAoKGogPCBzaWcubGVuZ3RoKSAmJiBpc051bWVyaWMoc2lnW2pdKSkge1xyXG4gICAgICAgIHRtcCArPSBzaWdbal0gLSAnMCdcclxuICAgICAgICBqKytcclxuICAgICAgfVxyXG4gICAgICBpID0gaiAtIDFcclxuICAgICAgcmV0LnB1c2godG1wKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaScpIHtcclxuICAgICAgcmV0LnB1c2goJ2ludDI1NicpXHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhJykge1xyXG4gICAgICByZXQucHVzaCgnaW50MjU2W10nKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbkFCSS50b1NlcnBlbnQgPSBmdW5jdGlvbiAodHlwZXMpIHtcclxuICB2YXIgcmV0ID0gW11cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2ldXHJcbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xyXG4gICAgICByZXQucHVzaCgncycpXHJcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xyXG4gICAgICByZXQucHVzaCgnYicgKyBwYXJzZVR5cGVOKHR5cGUpKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50MjU2Jykge1xyXG4gICAgICByZXQucHVzaCgnaScpXHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnQyNTZbXScpIHtcclxuICAgICAgcmV0LnB1c2goJ2EnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmV0LmpvaW4oJycpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQUJJXHJcbiIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNPd25Qcm9wZXJ0eVwiLCB7IHZhbHVlOiBoYXNPd25Qcm9wZXJ0eSB9KTtcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAga2V5c1trXSA9IFwiXCIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmV4cG9ydHMuX29iamVjdEtleXMgPSBfb2JqZWN0S2V5cztcbjtcbi8qKlxuKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cbiogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcbiogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXG4qL1xuZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iajsgLy9ubyBuZWVkIHRvIGNsb25lIHByaW1pdGl2ZXNcbiAgICB9XG59XG5leHBvcnRzLl9kZWVwQ2xvbmUgPSBfZGVlcENsb25lO1xuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5mdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbi8qKlxuKiBFc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4qIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxuKi9cbmZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGVzY2FwZVBhdGhDb21wb25lbnQ7XG4vKipcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50O1xuZnVuY3Rpb24gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGZvciAodmFyIGtleSBpbiByb290KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShyb290LCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArICcvJyArIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5leHBvcnRzLl9nZXRQYXRoUmVjdXJzaXZlID0gX2dldFBhdGhSZWN1cnNpdmU7XG5mdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xuICAgIGlmIChyb290ID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9XG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XG4gICAgfVxuICAgIHJldHVybiAnLycgKyBwYXRoO1xufVxuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcbi8qKlxuKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cbiovXG5mdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNVbmRlZmluZWQgPSBoYXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCBhcmdzKSB7XG4gICAgdmFyIG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJnc1trZXldID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGFyZ3Nba2V5XSwgbnVsbCwgMikgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goa2V5ICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbignXFxuJyk7XG59XG52YXIgUGF0Y2hFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGF0Y2hFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXRjaEVycm9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7IG5hbWU6IG5hbWUsIGluZGV4OiBpbmRleCwgb3BlcmF0aW9uOiBvcGVyYXRpb24sIHRyZWU6IHRyZWUgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGF0Y2hFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzX2pzXzEuUGF0Y2hFcnJvcjtcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbnZhciBvYmpPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxuICAgICAgICBhbmQgaXMgcG90ZW50aWFsbHkgdW5uZWVkZWQgKi9cbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiB0aGlzLmZyb20gfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IG9yaWdpbmFsVmFsdWUgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKHZhbHVlVG9Db3B5KSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogX2FyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9XG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaGVscGVyc19qc18xLmlzSW50ZWdlcihpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXRcbn07XG4vKipcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gYSBKU09OIGRvY3VtZW50IGJ5IGEgSlNPTiBwb2ludGVyLlxuICogUmV0dXJucyB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBnZXQgdGhlIHZhbHVlIGZyb21cbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHBvaW50ZXIpIHtcbiAgICBpZiAocG9pbnRlciA9PSAnJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcbiAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbik7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XG59XG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gZ2V0VmFsdWVCeVBvaW50ZXI7XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgb3BlcmF0aW9uLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShvcGVyYXRpb24pKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaW5kZXgpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gPT09IHZvaWQgMCkgeyB2YWxpZGF0ZU9wZXJhdGlvbiA9IGZhbHNlOyB9XG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XG4gICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPT09IHZvaWQgMCkgeyBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZTsgfVxuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlT3BlcmF0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIG9wZXJhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihvcGVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGlmIChvcGVyYXRpb24ucGF0aCA9PT0gXCJcIikge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSAnYWRkJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50OyAvL2RvY3VtZW50IHdlIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgeyAvLyBpdCdzIGEgbW92ZSBvciBjb3B5IHRvIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScpIHsgLy8gcmVwb3J0IHJlbW92ZWQgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICd0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IF9hcmVFcXVhbHMoZG9jdW1lbnQsIG9wZXJhdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7IC8vIGEgcmVtb3ZlIG9uIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8qIGJhZCBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgIHZhciB2YWxpZGF0ZUZ1bmN0aW9uID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBoZWxwZXJzX2pzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyAmJiBrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2AgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgIWhlbHBlcnNfanNfMS5pc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVscGVyc19qc18xLmlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiAmJiBrZXkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gYXBwbHlPcGVyYXRpb247XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50LCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zKSB7XG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XG4gICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPT09IHZvaWQgMCkgeyBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZTsgfVxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gaGVscGVyc19qc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICB2YXIgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvblJlc3VsdC50ZXN0ID09PSBmYWxzZSkgeyAvLyBmYWlsZWQgdGVzdFxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBhcHBseVJlZHVjZXI7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09ICdvYmplY3QnIHx8IG9wZXJhdGlvbiA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZycsICdPUEVSQVRJT05fUEFUSF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5pbmRleE9mKCcvJykgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgaGVscGVyc19qc18xLmhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBhbiBgYWRkYCBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IG9wZXJhdGlvbi5mcm9tLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGZyb20gYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3QnLCAnT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaChoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShkb2N1bWVudCksIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBleHBvcnRzLkpzb25QYXRjaEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vZmFzdC1kZWVwLWVxdWFsXG4vLyBNSVQgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEV2Z2VueSBQb2JlcmV6a2luXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4vLyBTT0ZUV0FSRS5cbmZ1bmN0aW9uIF9hcmVFcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5leHBvcnRzLl9hcmVFcXVhbHMgPSBfYXJlRXF1YWxzO1xuO1xuIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNyBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xudmFyIGhlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIik7XG52YXIgY29yZV9qc18xID0gcmVxdWlyZShcIi4vY29yZS5qc1wiKTtcbnZhciBiZWZvcmVEaWN0ID0gbmV3IFdlYWtNYXAoKTtcbnZhciBNaXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWlycm9yKG9iaikge1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiBNaXJyb3I7XG59KCkpO1xudmFyIE9ic2VydmVySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZXJJbmZvO1xufSgpKTtcbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKSB7XG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xufVxuLyoqXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdW5vYnNlcnZlKHJvb3QsIG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKCk7XG59XG5leHBvcnRzLnVub2JzZXJ2ZSA9IHVub2JzZXJ2ZTtcbi8qKlxuICogT2JzZXJ2ZXMgY2hhbmdlcyBtYWRlIHRvIGFuIG9iamVjdCwgd2hpY2ggY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGdlbmVyYXRlXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcbiAgICBpZiAoIW1pcnJvcikge1xuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBvYnNlcnZlckluZm8gPSBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjayk7XG4gICAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJJbmZvICYmIG9ic2VydmVySW5mby5vYnNlcnZlcjtcbiAgICB9XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSB7fTtcbiAgICBtaXJyb3IudmFsdWUgPSBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShvYmopO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcnR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYXN0Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vbm90IE5vZGVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcbiAgICBvYnNlcnZlci51bm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1pcnJvci5vYnNlcnZlcnMuc2V0KGNhbGxiYWNrLCBuZXcgT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmV4cG9ydHMub2JzZXJ2ZSA9IG9ic2VydmU7XG4vKipcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSBhbiBvYnNlcnZlclxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlciwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChpbnZlcnRpYmxlID09PSB2b2lkIDApIHsgaW52ZXJ0aWJsZSA9IGZhbHNlOyB9XG4gICAgdmFyIG1pcnJvciA9IGJlZm9yZURpY3QuZ2V0KG9ic2VydmVyLm9iamVjdCk7XG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICBpZiAob2JzZXJ2ZXIucGF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgY29yZV9qc18xLmFwcGx5UGF0Y2gobWlycm9yLnZhbHVlLCBvYnNlcnZlci5wYXRjaGVzKTtcbiAgICB9XG4gICAgdmFyIHRlbXAgPSBvYnNlcnZlci5wYXRjaGVzO1xuICAgIGlmICh0ZW1wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHRlbXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wO1xufVxuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuLy8gRGlydHkgY2hlY2sgaWYgb2JqIGlzIGRpZmZlcmVudCBmcm9tIG1pcnJvciwgZ2VuZXJhdGUgcGF0Y2hlcyBhbmQgdXBkYXRlIG1pcnJvclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKG9iaiA9PT0gbWlycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICB2YXIgbmV3S2V5cyA9IGhlbHBlcnNfanNfMS5fb2JqZWN0S2V5cyhvYmopO1xuICAgIHZhciBvbGRLZXlzID0gaGVscGVyc19qc18xLl9vYmplY3RLZXlzKG1pcnJvcik7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuICAgIC8vaWYgZXZlciBcIm1vdmVcIiBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaGVyZSwgbWFrZSBzdXJlIHRoaXMgdGVzdCBydW5zIE9LOiBcInNob3VsZCBub3QgZ2VuZXJhdGUgdGhlIHNhbWUgcGF0Y2ggdHdpY2UgKG1vdmUpXCJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2xkS2V5c1t0XTtcbiAgICAgICAgdmFyIG9sZFZhbCA9IG1pcnJvcltrZXldO1xuICAgICAgICBpZiAoaGVscGVyc19qc18xLmhhc093blByb3BlcnR5KG9iaiwga2V5KSAmJiAhKG9ialtrZXldID09PSB1bmRlZmluZWQgJiYgb2xkVmFsICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiYgb2xkVmFsICE9IG51bGwgJiYgdHlwZW9mIG5ld1ZhbCA9PSBcIm9iamVjdFwiICYmIG5ld1ZhbCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkob2xkVmFsKSA9PT0gQXJyYXkuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgX2dlbmVyYXRlKG9sZFZhbCwgbmV3VmFsLCBwYXRjaGVzLCBwYXRoICsgXCIvXCIgKyBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCBpbnZlcnRpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInRlc3RcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc19qc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfanNfMS5fZGVlcENsb25lKG9sZFZhbCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc19qc18xLl9kZWVwQ2xvbmUobmV3VmFsKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc19qc18xLl9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhlbHBlcnNfanNfMS5oYXNPd25Qcm9wZXJ0eShtaXJyb3IsIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwiYWRkXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZShvYmpba2V5XSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gdGhlIGRpZmZlcmVuY2VzIGluIHR3byBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKGludmVydGlibGUgPT09IHZvaWQgMCkgeyBpbnZlcnRpYmxlID0gZmFsc2U7IH1cbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIF9nZW5lcmF0ZSh0cmVlMSwgdHJlZTIsIHBhdGNoZXMsICcnLCBpbnZlcnRpYmxlKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbn1cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMC4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjAgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IDIgLSBpc09kZChuKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQsIHkucyA9IC15LnM7XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkgemMgPSB4YywgeGMgPSB5YywgeWMgPSB6YywgaSA9IHhjTCwgeGNMID0geWNMLCB5Y0wgPSBpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCkge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC8qdmFyYXJncyovKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7Zm46Zm4sIGFyZ3VtZW50czphcmd1bWVudHN9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbihyZXEpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJndW1lbnRzKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnQ7XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cclxuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXHJcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICB9XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaChvcHRpb24pIHtcbiAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gdGltZW91dCBvcHRpb25cIiwgb3B0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIHJldHJ5KGNvdW50LCBmbil7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXNcIik7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkge1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobnVsbCA9PT0gbmFtZSB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICB0aGlzLmZpZWxkKG5hbWUsIHZhbFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWwpIHtcbiAgICB2YWwgPSAnJyArIHZhbDtcbiAgfVxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJhc2U2NEVuY29kZXIodXNlciArICc6JyArIHBhc3MpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB1c2VyKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24ob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpemUgb2YgYnVmZmVyZWQgcmVzcG9uc2UgYm9keSwgaW4gYnl0ZXMuIENvdW50cyB1bmNvbXByZXNzZWQgc2l6ZS5cbiAqIERlZmF1bHQgMjAwTUIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24obil7XG4gIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIG4pIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB9XG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXIsXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbihzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBxdWVyeUFyciA9IHRoaXMudXJsLnN1YnN0cmluZyhpbmRleCArIDEpLnNwbGl0KCcmJyk7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX3NvcnQpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpIHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihyZWFzb24gKyB0aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIHZhciBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7XG5cbiAgICAvLyBwYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgICAvLyBzdGF0dXMgLyBjbGFzc1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBiYXNpY3NcbiAgICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gICAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgICB0aGlzLnJlZGlyZWN0ID0gMyA9PSB0eXBlO1xuICAgIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gICAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgICAgID8gdGhpcy50b0Vycm9yKClcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8vIHN1Z2FyXG4gICAgdGhpcy5jcmVhdGVkID0gMjAxID09IHN0YXR1cztcbiAgICB0aGlzLmFjY2VwdGVkID0gMjAyID09IHN0YXR1cztcbiAgICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgICB0aGlzLnVuYXV0aG9yaXplZCA9IDQwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgICB0aGlzLmZvcmJpZGRlbiA9IDQwMyA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gNDIyID09IHN0YXR1cztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9CaXRzID0gdm9pZCAwO1xudmFyIHRvX2JpdHNfMSA9IHJlcXVpcmUoXCIuL3RvLWJpdHNcIik7XG5leHBvcnRzLnRvQml0cyA9IHRvX2JpdHNfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0geyB0b0JpdHM6IHRvX2JpdHNfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueG9yID0gZXhwb3J0cy54bm9yID0gZXhwb3J0cy50b1N0cmluZyA9IGV4cG9ydHMudG9Cb29sZWFuID0gZXhwb3J0cy5yZWR1Y2VYb3IgPSBleHBvcnRzLnJlZHVjZVhub3IgPSBleHBvcnRzLnJlZHVjZU9yID0gZXhwb3J0cy5yZWR1Y2VOb3IgPSBleHBvcnRzLnJlZHVjZU5hbmQgPSBleHBvcnRzLnJlZHVjZUFuZCA9IGV4cG9ydHMub3IgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMubm9yID0gZXhwb3J0cy5uYW5kID0gZXhwb3J0cy5jaXJjdWxhclNoaWZ0UmlnaHQgPSBleHBvcnRzLmNpcmN1bGFyU2hpZnRMZWZ0ID0gZXhwb3J0cy5hbmQgPSB2b2lkIDA7XG52YXIgYW5kXzEgPSByZXF1aXJlKFwiLi9hbmRcIik7XG5leHBvcnRzLmFuZCA9IGFuZF8xLmRlZmF1bHQ7XG52YXIgY2lyY3VsYXJfc2hpZnRfbGVmdF8xID0gcmVxdWlyZShcIi4vY2lyY3VsYXItc2hpZnQtbGVmdFwiKTtcbmV4cG9ydHMuY2lyY3VsYXJTaGlmdExlZnQgPSBjaXJjdWxhcl9zaGlmdF9sZWZ0XzEuZGVmYXVsdDtcbnZhciBjaXJjdWxhcl9zaGlmdF9yaWdodF8xID0gcmVxdWlyZShcIi4vY2lyY3VsYXItc2hpZnQtcmlnaHRcIik7XG5leHBvcnRzLmNpcmN1bGFyU2hpZnRSaWdodCA9IGNpcmN1bGFyX3NoaWZ0X3JpZ2h0XzEuZGVmYXVsdDtcbnZhciBuYW5kXzEgPSByZXF1aXJlKFwiLi9uYW5kXCIpO1xuZXhwb3J0cy5uYW5kID0gbmFuZF8xLmRlZmF1bHQ7XG52YXIgbm9yXzEgPSByZXF1aXJlKFwiLi9ub3JcIik7XG5leHBvcnRzLm5vciA9IG5vcl8xLmRlZmF1bHQ7XG52YXIgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5leHBvcnRzLm5vdCA9IG5vdF8xLmRlZmF1bHQ7XG52YXIgb3JfMSA9IHJlcXVpcmUoXCIuL29yXCIpO1xuZXhwb3J0cy5vciA9IG9yXzEuZGVmYXVsdDtcbnZhciByZWR1Y2VfYW5kXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2UtYW5kXCIpO1xuZXhwb3J0cy5yZWR1Y2VBbmQgPSByZWR1Y2VfYW5kXzEuZGVmYXVsdDtcbnZhciByZWR1Y2VfbmFuZF8xID0gcmVxdWlyZShcIi4vcmVkdWNlLW5hbmRcIik7XG5leHBvcnRzLnJlZHVjZU5hbmQgPSByZWR1Y2VfbmFuZF8xLmRlZmF1bHQ7XG52YXIgcmVkdWNlX25vcl8xID0gcmVxdWlyZShcIi4vcmVkdWNlLW5vclwiKTtcbmV4cG9ydHMucmVkdWNlTm9yID0gcmVkdWNlX25vcl8xLmRlZmF1bHQ7XG52YXIgcmVkdWNlX29yXzEgPSByZXF1aXJlKFwiLi9yZWR1Y2Utb3JcIik7XG5leHBvcnRzLnJlZHVjZU9yID0gcmVkdWNlX29yXzEuZGVmYXVsdDtcbnZhciByZWR1Y2VfeG5vcl8xID0gcmVxdWlyZShcIi4vcmVkdWNlLXhub3JcIik7XG5leHBvcnRzLnJlZHVjZVhub3IgPSByZWR1Y2VfeG5vcl8xLmRlZmF1bHQ7XG52YXIgcmVkdWNlX3hvcl8xID0gcmVxdWlyZShcIi4vcmVkdWNlLXhvclwiKTtcbmV4cG9ydHMucmVkdWNlWG9yID0gcmVkdWNlX3hvcl8xLmRlZmF1bHQ7XG52YXIgdG9fYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vdG8tYm9vbGVhblwiKTtcbmV4cG9ydHMudG9Cb29sZWFuID0gdG9fYm9vbGVhbl8xLmRlZmF1bHQ7XG52YXIgdG9fc3RyaW5nXzEgPSByZXF1aXJlKFwiLi90by1zdHJpbmdcIik7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9fc3RyaW5nXzEuZGVmYXVsdDtcbnZhciB4bm9yXzEgPSByZXF1aXJlKFwiLi94bm9yXCIpO1xuZXhwb3J0cy54bm9yID0geG5vcl8xLmRlZmF1bHQ7XG52YXIgeG9yXzEgPSByZXF1aXJlKFwiLi94b3JcIik7XG5leHBvcnRzLnhvciA9IHhvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgYW5kOiBhbmRfMS5kZWZhdWx0LFxuICAgIGNpcmN1bGFyU2hpZnRMZWZ0OiBjaXJjdWxhcl9zaGlmdF9sZWZ0XzEuZGVmYXVsdCxcbiAgICBjaXJjdWxhclNoaWZ0UmlnaHQ6IGNpcmN1bGFyX3NoaWZ0X3JpZ2h0XzEuZGVmYXVsdCxcbiAgICBuYW5kOiBuYW5kXzEuZGVmYXVsdCxcbiAgICBub3I6IG5vcl8xLmRlZmF1bHQsXG4gICAgbm90OiBub3RfMS5kZWZhdWx0LFxuICAgIG9yOiBvcl8xLmRlZmF1bHQsXG4gICAgcmVkdWNlQW5kOiByZWR1Y2VfYW5kXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VOYW5kOiByZWR1Y2VfbmFuZF8xLmRlZmF1bHQsXG4gICAgcmVkdWNlTm9yOiByZWR1Y2Vfbm9yXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VPcjogcmVkdWNlX29yXzEuZGVmYXVsdCxcbiAgICByZWR1Y2VYbm9yOiByZWR1Y2VfeG5vcl8xLmRlZmF1bHQsXG4gICAgcmVkdWNlWG9yOiByZWR1Y2VfeG9yXzEuZGVmYXVsdCxcbiAgICB0b0Jvb2xlYW46IHRvX2Jvb2xlYW5fMS5kZWZhdWx0LFxuICAgIHRvU3RyaW5nOiB0b19zdHJpbmdfMS5kZWZhdWx0LFxuICAgIHhub3I6IHhub3JfMS5kZWZhdWx0LFxuICAgIHhvcjogeG9yXzEuZGVmYXVsdCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGUgPSBleHBvcnRzLnJlYWQgPSB2b2lkIDA7XG52YXIgcmVhZF8xID0gcmVxdWlyZShcIi4vcmVhZFwiKTtcbmV4cG9ydHMucmVhZCA9IHJlYWRfMS5kZWZhdWx0O1xudmFyIHdyaXRlXzEgPSByZXF1aXJlKFwiLi93cml0ZVwiKTtcbmV4cG9ydHMud3JpdGUgPSB3cml0ZV8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7IHJlYWQ6IHJlYWRfMS5kZWZhdWx0LCB3cml0ZTogd3JpdGVfMS5kZWZhdWx0IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9nZ2xlQml0ID0gZXhwb3J0cy5zZXRCaXQgPSBleHBvcnRzLmdldEJpdCA9IHZvaWQgMDtcbnZhciBnZXRfYml0XzEgPSByZXF1aXJlKFwiLi9nZXQtYml0XCIpO1xuZXhwb3J0cy5nZXRCaXQgPSBnZXRfYml0XzEuZGVmYXVsdDtcbnZhciBzZXRfYml0XzEgPSByZXF1aXJlKFwiLi9zZXQtYml0XCIpO1xuZXhwb3J0cy5zZXRCaXQgPSBzZXRfYml0XzEuZGVmYXVsdDtcbnZhciB0b2dnbGVfYml0XzEgPSByZXF1aXJlKFwiLi90b2dnbGUtYml0XCIpO1xuZXhwb3J0cy50b2dnbGVCaXQgPSB0b2dnbGVfYml0XzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IHsgZ2V0Qml0OiBnZXRfYml0XzEuZGVmYXVsdCwgc2V0Qml0OiBzZXRfYml0XzEuZGVmYXVsdCwgdG9nZ2xlQml0OiB0b2dnbGVfYml0XzEuZGVmYXVsdCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyaXRlID0gZXhwb3J0cy5yZWFkID0gdm9pZCAwO1xudmFyIHJlYWRfMSA9IHJlcXVpcmUoXCIuL3JlYWRcIik7XG5leHBvcnRzLnJlYWQgPSByZWFkXzEuZGVmYXVsdDtcbnZhciB3cml0ZV8xID0gcmVxdWlyZShcIi4vd3JpdGVcIik7XG5leHBvcnRzLndyaXRlID0gd3JpdGVfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0geyByZWFkOiByZWFkXzEuZGVmYXVsdCwgd3JpdGU6IHdyaXRlXzEuZGVmYXVsdCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnhvciA9IGV4cG9ydHMueG5vciA9IGV4cG9ydHMucmVhZFVJbnQgPSBleHBvcnRzLnJlYWRJbnQgPSBleHBvcnRzLnJlYWQgPSBleHBvcnRzLm9yID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLm5vciA9IGV4cG9ydHMubmFuZCA9IGV4cG9ydHMubW9kaWZ5ID0gZXhwb3J0cy5jcmVhdGUgPSBleHBvcnRzLmFuZCA9IHZvaWQgMDtcbnZhciBhbmRfMSA9IHJlcXVpcmUoXCIuL2FuZFwiKTtcbmV4cG9ydHMuYW5kID0gYW5kXzEuZGVmYXVsdDtcbnZhciBjcmVhdGVfMSA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlXzEuZGVmYXVsdDtcbnZhciBtb2RpZnlfMSA9IHJlcXVpcmUoXCIuL21vZGlmeVwiKTtcbmV4cG9ydHMubW9kaWZ5ID0gbW9kaWZ5XzEuZGVmYXVsdDtcbnZhciBuYW5kXzEgPSByZXF1aXJlKFwiLi9uYW5kXCIpO1xuZXhwb3J0cy5uYW5kID0gbmFuZF8xLmRlZmF1bHQ7XG52YXIgbm9yXzEgPSByZXF1aXJlKFwiLi9ub3JcIik7XG5leHBvcnRzLm5vciA9IG5vcl8xLmRlZmF1bHQ7XG52YXIgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5leHBvcnRzLm5vdCA9IG5vdF8xLmRlZmF1bHQ7XG52YXIgb3JfMSA9IHJlcXVpcmUoXCIuL29yXCIpO1xuZXhwb3J0cy5vciA9IG9yXzEuZGVmYXVsdDtcbnZhciByZWFkXzEgPSByZXF1aXJlKFwiLi9yZWFkXCIpO1xuZXhwb3J0cy5yZWFkID0gcmVhZF8xLmRlZmF1bHQ7XG52YXIgcmVhZF9pbnRfMSA9IHJlcXVpcmUoXCIuL3JlYWQtaW50XCIpO1xuZXhwb3J0cy5yZWFkSW50ID0gcmVhZF9pbnRfMS5kZWZhdWx0O1xudmFyIHJlYWRfdV9pbnRfMSA9IHJlcXVpcmUoXCIuL3JlYWQtdS1pbnRcIik7XG5leHBvcnRzLnJlYWRVSW50ID0gcmVhZF91X2ludF8xLmRlZmF1bHQ7XG52YXIgeG5vcl8xID0gcmVxdWlyZShcIi4veG5vclwiKTtcbmV4cG9ydHMueG5vciA9IHhub3JfMS5kZWZhdWx0O1xudmFyIHhvcl8xID0gcmVxdWlyZShcIi4veG9yXCIpO1xuZXhwb3J0cy54b3IgPSB4b3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGFuZDogYW5kXzEuZGVmYXVsdCxcbiAgICBjcmVhdGU6IGNyZWF0ZV8xLmRlZmF1bHQsXG4gICAgbW9kaWZ5OiBtb2RpZnlfMS5kZWZhdWx0LFxuICAgIG5hbmQ6IG5hbmRfMS5kZWZhdWx0LFxuICAgIG5vcjogbm9yXzEuZGVmYXVsdCxcbiAgICBub3Q6IG5vdF8xLmRlZmF1bHQsXG4gICAgb3I6IG9yXzEuZGVmYXVsdCxcbiAgICByZWFkOiByZWFkXzEuZGVmYXVsdCxcbiAgICByZWFkSW50OiByZWFkX2ludF8xLmRlZmF1bHQsXG4gICAgcmVhZFVJbnQ6IHJlYWRfdV9pbnRfMS5kZWZhdWx0LFxuICAgIHhub3I6IHhub3JfMS5kZWZhdWx0LFxuICAgIHhvcjogeG9yXzEuZGVmYXVsdCxcbn07XG4iLCJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlclxuLyoqXG4gKiBSTFAgRW5jb2RpbmcgYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvJTVCRW5nbGlzaCU1RC1STFBcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gYSBkYXRhLCBjb252ZXJ0IGl0IHRvIGJ1ZmZlciBpZiBub3QsIGFuZCBhIGxlbmd0aCBmb3IgcmVjdXJzaW9uXG4gKlxuICogQHBhcmFtIHtCdWZmZXIsU3RyaW5nLEludGVnZXIsQXJyYXl9IGRhdGEgLSB3aWxsIGJlIGNvbnZlcnRlZCB0byBidWZmZXJcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBvdXRwdXQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydHMuZW5jb2RlKGlucHV0W2ldKSlcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQob3V0cHV0KVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNvZGVMZW5ndGgoYnVmLmxlbmd0aCwgMTkyKSwgYnVmXSlcbiAgfSBlbHNlIHtcbiAgICBpbnB1dCA9IHRvQnVmZmVyKGlucHV0KVxuICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDEgJiYgaW5wdXRbMF0gPCAxMjgpIHtcbiAgICAgIHJldHVybiBpbnB1dFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jb2RlTGVuZ3RoKGlucHV0Lmxlbmd0aCwgMTI4KSwgaW5wdXRdKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlUGFyc2VJbnQgKHYsIGJhc2UpIHtcbiAgaWYgKHYuc2xpY2UoMCwgMikgPT09ICcwMCcpIHtcbiAgICB0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXh0cmEgemVyb3MnKSlcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh2LCBiYXNlKVxufVxuXG5mdW5jdGlvbiBlbmNvZGVMZW5ndGggKGxlbiwgb2Zmc2V0KSB7XG4gIGlmIChsZW4gPCA1Nikge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKFtsZW4gKyBvZmZzZXRdKVxuICB9IGVsc2Uge1xuICAgIHZhciBoZXhMZW5ndGggPSBpbnRUb0hleChsZW4pXG4gICAgdmFyIGxMZW5ndGggPSBoZXhMZW5ndGgubGVuZ3RoIC8gMlxuICAgIHZhciBmaXJzdEJ5dGUgPSBpbnRUb0hleChvZmZzZXQgKyA1NSArIGxMZW5ndGgpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoZmlyc3RCeXRlICsgaGV4TGVuZ3RoLCAnaGV4JylcbiAgfVxufVxuXG4vKipcbiAqIFJMUCBEZWNvZGluZyBiYXNlZCBvbjoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvJTVCRW5nbGlzaCU1RC1STFB8UkxQfVxuICogQHBhcmFtIHtCdWZmZXIsU3RyaW5nLEludGVnZXIsQXJyYXl9IGRhdGEgLSB3aWxsIGJlIGNvbnZlcnRlZCB0byBidWZmZXJcbiAqIEByZXR1cm5zIHtBcnJheX0gLSByZXR1cm5zIGRlY29kZSBBcnJheSBvZiBCdWZmZXJzIGNvbnRhaW5nIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gKiovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChpbnB1dCwgc3RyZWFtKSB7XG4gIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoW10pXG4gIH1cblxuICBpbnB1dCA9IHRvQnVmZmVyKGlucHV0KVxuICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoaW5wdXQpXG5cbiAgaWYgKHN0cmVhbSkge1xuICAgIHJldHVybiBkZWNvZGVkXG4gIH1cblxuICBhc3NlcnQuZXF1YWwoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoLCAwLCAnaW52YWxpZCByZW1haW5kZXInKVxuICByZXR1cm4gZGVjb2RlZC5kYXRhXG59XG5cbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoW10pXG4gIH1cblxuICBpbnB1dCA9IHRvQnVmZmVyKGlucHV0KVxuICB2YXIgZmlyc3RCeXRlID0gaW5wdXRbMF1cbiAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgcmV0dXJuIGlucHV0Lmxlbmd0aFxuICB9IGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4N2ZcbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGI2XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4YmZcbiAgfSBlbHNlIHtcbiAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgIHZhciBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNlxuICAgIHZhciBsZW5ndGggPSBzYWZlUGFyc2VJbnQoaW5wdXQuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNilcbiAgICByZXR1cm4gbGxlbmd0aCArIGxlbmd0aFxuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWNvZGUgKGlucHV0KSB7XG4gIHZhciBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkXG4gIHZhciBkZWNvZGVkID0gW11cbiAgdmFyIGZpcnN0Qnl0ZSA9IGlucHV0WzBdXG5cbiAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGlucHV0LnNsaWNlKDAsIDEpLFxuICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAvLyBUaGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGJ5dGUgaXMgWzB4ODAsIDB4YjddXG4gICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHg3ZlxuXG4gICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXG4gICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoW10pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgxLCBsZW5ndGgpXG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gMiAmJiBkYXRhWzBdIDwgMHg4MCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscCBlbmNvZGluZzogYnl0ZSBtdXN0IGJlIGxlc3MgMHg4MCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNlxuICAgIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dC5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZygnaGV4JyksIDE2KVxuICAgIGRhdGEgPSBpbnB1dC5zbGljZShsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKVxuICAgIGlmIChkYXRhLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgdGhyb3cgKG5ldyBFcnJvcignaW52YWxpZCBSTFAnKSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoICsgbGxlbmd0aClcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZlxuICAgIGlubmVyUmVtYWluZGVyID0gaW5wdXQuc2xpY2UoMSwgbGVuZ3RoKVxuICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKVxuICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSlcbiAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXJcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhIGxpc3QgIG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2XG4gICAgbGVuZ3RoID0gc2FmZVBhcnNlSW50KGlucHV0LnNsaWNlKDEsIGxsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKSwgMTYpXG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aFxuICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhJylcbiAgICB9XG5cbiAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIHRvdGFsTGVuZ3RoKVxuICAgIGlmIChpbm5lclJlbWFpbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBybHAsIExpc3QgaGFzIGEgaW52YWxpZCBsZW5ndGgnKVxuICAgIH1cblxuICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKVxuICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSlcbiAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXJcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4J1xufVxuXG4vLyBSZW1vdmVzIDB4IGZyb20gYSBnaXZlbiBTdHJpbmdcbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4IChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHJcbn1cblxuZnVuY3Rpb24gaW50VG9IZXggKGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpXG4gIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgIGhleCA9ICcwJyArIGhleFxuICB9XG5cbiAgcmV0dXJuIGhleFxufVxuXG5mdW5jdGlvbiBwYWRUb0V2ZW4gKGEpIHtcbiAgaWYgKGEubGVuZ3RoICUgMikgYSA9ICcwJyArIGFcbiAgcmV0dXJuIGFcbn1cblxuZnVuY3Rpb24gaW50VG9CdWZmZXIgKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpXG4gIHJldHVybiBuZXcgQnVmZmVyKGhleCwgJ2hleCcpXG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgdiA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gbmV3IEJ1ZmZlcih2KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoIXYpIHtcbiAgICAgICAgdiA9IG5ldyBCdWZmZXIoW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gaW50VG9CdWZmZXIodilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gbmV3IEJ1ZmZlcihbXSlcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IG5ldyBCdWZmZXIodi50b0FycmF5KCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZcbn1cbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgYWJpID0gcmVxdWlyZSgnLi9hYmknKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlclxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICB0eXBlOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJpbWFyeVR5cGU6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgZG9tYWluOiB7dHlwZTogJ29iamVjdCd9LFxuICAgIG1lc3NhZ2U6IHt0eXBlOiAnb2JqZWN0J30sXG4gIH0sXG4gIHJlcXVpcmVkOiBbJ3R5cGVzJywgJ3ByaW1hcnlUeXBlJywgJ2RvbWFpbicsICdtZXNzYWdlJ10sXG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgZm9yIHNpZ25pbmcgdHlwZWQgZGF0YVxuICovXG5jb25zdCBUeXBlZERhdGFVdGlscyA9IHtcbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmKHVzZVY0KSB7XG4gICAgICBjb25zdCBlbmNvZGVGaWVsZCA9IChuYW1lLCB0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCB2YWx1ZSA9PSBudWxsID9cbiAgICAgICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnIDpcbiAgICAgICAgICAgIHV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHVzZVY0KSldXG4gICAgICAgIH1cblxuICAgICAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCB1dGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoaXRlbSA9PlxuICAgICAgICAgICAgZW5jb2RlRmllbGQobmFtZSwgcGFyc2VkVHlwZSwgaXRlbSkpXG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHV0aWwua2VjY2FrKGFiaS5yYXdFbmNvZGUoXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFt0eXBlXSkgPT4gdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIHZhbHVlXSkgPT4gdmFsdWUpLFxuICAgICAgICAgICkpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pXG4gICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpXG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLmtlY2Nhayh2YWx1ZSlcbiAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2ZpZWxkLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKGZpZWxkLnR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZS5sYXN0SW5kZXhPZignXScpID09PSBmaWVsZC50eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGN1cnJlbnRseSB1bmltcGxlbWVudGVkIGluIGVuY29kZURhdGEnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaChmaWVsZC50eXBlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcylcbiAgfSxcblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgZW5jb2RlVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgbGV0IGRlcHMgPSB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcykuZmlsdGVyKGRlcCA9PiBkZXAgIT09IHByaW1hcnlUeXBlKVxuICAgIGRlcHMgPSBbcHJpbWFyeVR5cGVdLmNvbmNhdChkZXBzLnNvcnQoKSlcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlc1t0eXBlXVxuICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICcgKyB0eXBlKVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHR5cGUgKyAnKCcgKyB0eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB0eXBlICsgJyAnICsgbmFtZSkuam9pbignLCcpICsgJyknXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW50aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHRzIC0gY3VycmVudCBzZXQgb2YgYWNjdW11bGF0ZWQgdHlwZXNcbiAgICogQHJldHVybnMge0FycmF5fSAtIFNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxuICAgKi9cbiAgZmluZFR5cGVEZXBlbmRlbmNpZXMgKHByaW1hcnlUeXBlLCB0eXBlcywgcmVzdWx0cyA9IFtdKSB7XG4gICAgcHJpbWFyeVR5cGUgPSBwcmltYXJ5VHlwZS5tYXRjaCgvXlxcdyovKVswXVxuICAgIGlmIChyZXN1bHRzLmluY2x1ZGVzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gcmVzdWx0cyB9XG4gICAgcmVzdWx0cy5wdXNoKHByaW1hcnlUeXBlKVxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKSkge1xuICAgICAgICAhcmVzdWx0cy5pbmNsdWRlcyhkZXApICYmIHJlc3VsdHMucHVzaChkZXApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzXG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhc2hlcyBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEhhc2ggb2YgYW4gb2JqZWN0XG4gICAqL1xuICBoYXNoU3RydWN0IChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB1dGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCkpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlIHRvIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEhhc2ggb2YgYW4gb2JqZWN0XG4gICAqL1xuICBoYXNoVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgcmV0dXJuIHV0aWwua2VjY2FrKHRoaXMuZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHByb3BlcnRpZXMgZnJvbSBhIG1lc3NhZ2Ugb2JqZWN0IHRoYXQgYXJlIG5vdCBkZWZpbmVkIHBlciBFSVAtNzEyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdHlwZWQgbWVzc2FnZSBvYmplY3RcbiAgICogQHJldHVybnMge09iamVjdH0gLSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHNcbiAgICovXG4gIHNhbml0aXplRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IGluIFRZUEVEX01FU1NBR0VfU0NIRU1BLnByb3BlcnRpZXMpIHtcbiAgICAgIGRhdGFba2V5XSAmJiAoc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldKVxuICAgIH1cbiAgICBpZiAoc2FuaXRpemVkRGF0YS50eXBlcykge1xuICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IE9iamVjdC5hc3NpZ24oeyBFSVA3MTJEb21haW46IFtdIH0sIHNhbml0aXplZERhdGEudHlwZXMpXG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWREYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhhc2ggb2YgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGZvciBzaWduaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZERhdGEgLSBUeXBlcyBtZXNzYWdlIGRhdGEgdG8gc2lnblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHNoYTMgaGFzaCBmb3Igc2lnbmluZ1xuICAgKi9cbiAgaGFzaCAodHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gdGhpcy5zYW5pdGl6ZURhdGEodHlwZWREYXRhKVxuICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXVxuICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZWREYXRhLmRvbWFpbiwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSAnRUlQNzEyRG9tYWluJykge1xuICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3Qoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgfVxuICAgIHJldHVybiB1dGlsLmtlY2NhayhCdWZmZXIuY29uY2F0KHBhcnRzKSlcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRZUEVEX01FU1NBR0VfU0NIRU1BLFxuICBUeXBlZERhdGFVdGlscyxcblxuICBoYXNoRm9yU2lnblR5cGVkRGF0YUxlZ2FjeTogZnVuY3Rpb24gKG1zZ1BhcmFtcykge1xuICAgIHJldHVybiB0eXBlZFNpZ25hdHVyZUhhc2hMZWdhY3kobXNnUGFyYW1zLmRhdGEpXG4gIH0sXG5cbiAgaGFzaEZvclNpZ25UeXBlZERhdGFfdjM6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuaGFzaChtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gIH0sXG5cbiAgaGFzaEZvclNpZ25UeXBlZERhdGFfdjQ6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICByZXR1cm4gVHlwZWREYXRhVXRpbHMuaGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgfSxcbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaExlZ2FjeSh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gdXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gYWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgYWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBleHBvcnRzLkNvbW1lbnRlZCA9IHJlcXVpcmUoJy4vY29tbWVudGVkJylcbmV4cG9ydHMuRGlhZ25vc2UgPSByZXF1aXJlKCcuL2RpYWdub3NlJylcbmV4cG9ydHMuRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5leHBvcnRzLkVuY29kZXIgPSByZXF1aXJlKCcuL2VuY29kZXInKVxuZXhwb3J0cy5TaW1wbGUgPSByZXF1aXJlKCcuL3NpbXBsZScpXG5leHBvcnRzLlRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcblxuLy8gZXhwb3J0cy5jb21tZW50ID0gZXhwb3J0cy5Db21tZW50ZWQuY29tbWVudFxuZXhwb3J0cy5kZWNvZGVBbGwgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlQWxsXG5leHBvcnRzLmRlY29kZUZpcnN0ID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZUZpcnN0XG5leHBvcnRzLmRpYWdub3NlID0gZXhwb3J0cy5EaWFnbm9zZS5kaWFnbm9zZVxuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLkVuY29kZXIuZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVcblxuZXhwb3J0cy5sZXZlbGRiID0ge1xuICBkZWNvZGU6IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVBbGwsXG4gIGVuY29kZTogZXhwb3J0cy5FbmNvZGVyLmVuY29kZSxcbiAgYnVmZmVyOiB0cnVlLFxuICBuYW1lOiAnY2Jvcidcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gdm9pZCAwO1xuY29uc3QgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnO1xuY29uc3QgQUxQSEFCRVRfTUFQID0ge307XG5mb3IgKGxldCB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gICAgY29uc3QgeCA9IEFMUEhBQkVULmNoYXJBdCh6KTtcbiAgICBBTFBIQUJFVF9NQVBbeF0gPSB6O1xufVxuZnVuY3Rpb24gcG9seW1vZFN0ZXAocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICByZXR1cm4gKCgocHJlICYgMHgxZmZmZmZmKSA8PCA1KSBeXG4gICAgICAgICgtKChiID4+IDApICYgMSkgJiAweDNiNmE1N2IyKSBeXG4gICAgICAgICgtKChiID4+IDEpICYgMSkgJiAweDI2NTA4ZTZkKSBeXG4gICAgICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgICAgICgtKChiID4+IDMpICYgMSkgJiAweDNkNDIzM2RkKSBeXG4gICAgICAgICgtKChiID4+IDQpICYgMSkgJiAweDJhMTQ2MmIzKSk7XG59XG5mdW5jdGlvbiBwcmVmaXhDaGsocHJlZml4KSB7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdiA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBjb25zdCBtYXhWID0gKDEgPDwgb3V0Qml0cykgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXTtcbiAgICAgICAgYml0cyArPSBpbkJpdHM7XG4gICAgICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gb3V0Qml0cztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpdHMgPj0gaW5CaXRzKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlc3MgcGFkZGluZyc7XG4gICAgICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKVxuICAgICAgICAgICAgcmV0dXJuICdOb24temVybyBwYWRkaW5nJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvV29yZHMoYnl0ZXMpIHtcbiAgICByZXR1cm4gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZyb21Xb3Jkcyh3b3Jkcykge1xuICAgIGNvbnN0IHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGlicmFyeUZyb21FbmNvZGluZyhlbmNvZGluZykge1xuICAgIGxldCBFTkNPRElOR19DT05TVDtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiZWNoMzInKSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMHgyYmM4MzBhMztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG4gICAgICAgIExJTUlUID0gTElNSVQgfHwgOTA7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGRldGVybWluZSBjaGsgbW9kXG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoayk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXggKyAnMSc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB3b3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh4ID4+IDUgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpO1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHg7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgICAgICB9XG4gICAgICAgIGNoayBePSBFTkNPRElOR19DT05TVDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX19kZWNvZGUoc3RyLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJyB0b28gc2hvcnQnO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCc7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB1cHBlcmVkID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKVxuICAgICAgICAgICAgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc3BsaXQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICdObyBzZXBhcmF0b3IgY2hhcmFjdGVyIGZvciAnICsgc3RyO1xuICAgICAgICBpZiAoc3BsaXQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3BsaXQpO1xuICAgICAgICBjb25zdCB3b3JkQ2hhcnMgPSBzdHIuc2xpY2Uoc3BsaXQgKyAxKTtcbiAgICAgICAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCc7XG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNoaztcbiAgICAgICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB3b3JkQ2hhcnMuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29uc3QgdiA9IEFMUEhBQkVUX01BUFtjXTtcbiAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIGNoYXJhY3RlciAnICsgYztcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2O1xuICAgICAgICAgICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICAgICAgICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgd29yZHMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hrICE9PSBFTkNPRElOR19DT05TVClcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0cjtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc3RyLCBMSU1JVCkge1xuICAgICAgICBjb25zdCByZXMgPSBfX2RlY29kZShzdHIsIExJTUlUKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICB0b1dvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdldExpYnJhcnlGcm9tRW5jb2RpbmcoJ2JlY2gzMm0nKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJDT01QUkVTU0VEX1RZUEVfSU5WQUxJRFwiOiBcImNvbXByZXNzZWQgc2hvdWxkIGJlIGEgYm9vbGVhblwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRFwiOiBcInByaXZhdGUga2V5IHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEXCI6IFwicHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9SQU5HRV9JTlZBTElEXCI6IFwicHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1RXRUFLX0FERF9GQUlMXCI6IFwidHdlYWsgb3V0IG9mIHJhbmdlIG9yIHJlc3VsdGluZyBwcml2YXRlIGtleSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfVFdFQUtfTVVMX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2VcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9FWFBPUlRfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBleHBvcnQgdG8gREVSIGZvcm1hdFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX0lNUE9SVF9ERVJfRkFJTFwiOiBcImNvdWxkbid0IGltcG9ydCBmcm9tIERFUiBmb3JtYXRcIixcbiAgXCJFQ19QVUJMSUNfS0VZU19UWVBFX0lOVkFMSURcIjogXCJwdWJsaWMga2V5cyBzaG91bGQgYmUgYW4gQXJyYXlcIixcbiAgXCJFQ19QVUJMSUNfS0VZU19MRU5HVEhfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXlzIEFycmF5IHNob3VsZCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudFwiLFxuICBcIkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEXCI6IFwicHVibGljIGtleSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJFQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEXCI6IFwicHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTFwiOiBcInRoZSBwdWJsaWMga2V5IGNvdWxkIG5vdCBiZSBwYXJzZWQgb3IgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BVQkxJQ19LRVlfQ1JFQVRFX0ZBSUxcIjogXCJwcml2YXRlIHdhcyBpbnZhbGlkLCB0cnkgYWdhaW5cIixcbiAgXCJFQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMXCI6IFwidHdlYWsgb3V0IG9mIHJhbmdlIG9yIHJlc3VsdGluZyBwdWJsaWMga2V5IGlzIGludmFsaWRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX1RXRUFLX01VTF9GQUlMXCI6IFwidHdlYWsgb3V0IG9mIHJhbmdlXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9DT01CSU5FX0ZBSUxcIjogXCJ0aGUgc3VtIG9mIHRoZSBwdWJsaWMga2V5cyBpcyBub3QgdmFsaWRcIixcbiAgXCJFQ0RIX0ZBSUxcIjogXCJzY2FsYXIgd2FzIGludmFsaWQgKHplcm8gb3Igb3ZlcmZsb3cpXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRFwiOiBcInNpZ25hdHVyZSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSURcIjogXCJzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTFwiOiBcImNvdWxkbid0IHBhcnNlIHNpZ25hdHVyZVwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9QQVJTRV9ERVJfRkFJTFwiOiBcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfU0VSSUFMSVpFX0RFUl9GQUlMXCI6IFwiY291bGRuJ3Qgc2VyaWFsaXplIHNpZ25hdHVyZSB0byBERVIgZm9ybWF0XCIsXG4gIFwiRUNEU0FfU0lHTl9GQUlMXCI6IFwibm9uY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbiBmYWlsZWQgb3IgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZFwiLFxuICBcIkVDRFNBX1JFQ09WRVJfRkFJTFwiOiBcImNvdWxkbid0IHJlY292ZXIgcHVibGljIGtleSBmcm9tIHNpZ25hdHVyZVwiLFxuICBcIk1TRzMyX1RZUEVfSU5WQUxJRFwiOiBcIm1lc3NhZ2Ugc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiTVNHMzJfTEVOR1RIX0lOVkFMSURcIjogXCJtZXNzYWdlIGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiT1BUSU9OU19UWVBFX0lOVkFMSURcIjogXCJvcHRpb25zIHNob3VsZCBiZSBhbiBPYmplY3RcIixcbiAgXCJPUFRJT05TX0RBVEFfVFlQRV9JTlZBTElEXCI6IFwib3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIk9QVElPTlNfREFUQV9MRU5HVEhfSU5WQUxJRFwiOiBcIm9wdGlvbnMuZGF0YSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIk9QVElPTlNfTk9OQ0VGTl9UWVBFX0lOVkFMSURcIjogXCJvcHRpb25zLm5vbmNlZm4gc2hvdWxkIGJlIGEgRnVuY3Rpb25cIixcbiAgXCJSRUNPVkVSWV9JRF9UWVBFX0lOVkFMSURcIjogXCJyZWNvdmVyeSBzaG91bGQgYmUgYSBOdW1iZXJcIixcbiAgXCJSRUNPVkVSWV9JRF9WQUxVRV9JTlZBTElEXCI6IFwicmVjb3Zlcnkgc2hvdWxkIGhhdmUgdmFsdWUgYmV0d2VlbiAtMSBhbmQgNFwiLFxuICBcIlRXRUFLX1RZUEVfSU5WQUxJRFwiOiBcInR3ZWFrIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIlRXRUFLX0xFTkdUSF9JTlZBTElEXCI6IFwidHdlYWsgbGVuZ3RoIGlzIGludmFsaWRcIlxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbi8vIFR5cGVFcnJvclxuZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEJvb2xlYW5dJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBOdW1iZXJdJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbi8vIFJhbmdlRXJyb3JcbmV4cG9ydHMuaXNCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyLCBsZW5ndGgsIG1lc3NhZ2UpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQnVmZmVyTGVuZ3RoMiA9IGZ1bmN0aW9uIChidWZmZXIsIGxlbmd0aDEsIGxlbmd0aDIsIG1lc3NhZ2UpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aDEgJiYgYnVmZmVyLmxlbmd0aCAhPT0gbGVuZ3RoMikgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzTGVuZ3RoR1RaZXJvID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc051bWJlckluSW50ZXJ2YWwgPSBmdW5jdGlvbiAobnVtYmVyLCB4LCB5LCBtZXNzYWdlKSB7XG4gIGlmIChudW1iZXIgPD0geCB8fCBudW1iZXIgPj0geSkgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBiaXA2NiA9IHJlcXVpcmUoJ2JpcDY2JylcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuICAvLyBiZWdpblxuICAweDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuICAvLyBwcml2YXRlIGtleVxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAvLyBtaWRkbGVcbiAgMHhhMCwgMHg4MSwgMHg4NSwgMHgzMCwgMHg4MSwgMHg4MiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCxcbiAgMHhjRSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmRSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCxcbiAgMHgyMSwgMHgwMiwgMHg3OSwgMHhiRSwgMHg2NiwgMHg3RSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjRSwgMHg4NyxcbiAgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjRSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCxcbiAgMHgxNywgMHg5OCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmRSwgMHhiYSwgMHhhRSwgMHhkYywgMHhFNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1RSxcbiAgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHgyNCwgMHgwMywgMHgyMiwgMHgwMCxcbiAgLy8gcHVibGljIGtleVxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwXG5dKVxuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgLy8gYmVnaW5cbiAgMHgzMCwgMHg4MiwgMHgwMSwgMHgxMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbiAgLy8gcHJpdmF0ZSBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgLy8gbWlkZGxlXG4gIDB4YTAsIDB4ODEsIDB4YTUsIDB4MzAsIDB4ODEsIDB4YTIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsXG4gIDB4Y0UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsXG4gIDB4NDEsIDB4MDQsIDB4NzksIDB4YkUsIDB4NjYsIDB4N0UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y0UsIDB4ODcsXG4gIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y0UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsXG4gIDB4MTcsIDB4OTgsIDB4NDgsIDB4M2EsIDB4ZGEsIDB4NzcsIDB4MjYsIDB4YTMsIDB4YzQsIDB4NjUsIDB4NWQsIDB4YTQsIDB4ZmIsIDB4ZmMsIDB4MEUsIDB4MTEsXG4gIDB4MDgsIDB4YTgsIDB4ZmQsIDB4MTcsIDB4YjQsIDB4NDgsIDB4YTYsIDB4ODUsIDB4NTQsIDB4MTksIDB4OWMsIDB4NDcsIDB4ZDAsIDB4OGYsIDB4ZmIsIDB4MTAsXG4gIDB4ZDQsIDB4YjgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4YmEsIDB4YUUsIDB4ZGMsIDB4RTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NUUsXG4gIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4NDQsIDB4MDMsIDB4NDIsIDB4MDAsXG4gIC8vIHB1YmxpYyBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMFxuXSlcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRClcbiAgcHJpdmF0ZUtleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDggOiA5KVxuICBwdWJsaWNLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyAxODEgOiAyMTQpXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoXG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDBcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMCkgcmV0dXJuXG4gIGluZGV4ICs9IDFcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpIHJldHVyblxuXG4gIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmXG4gIGluZGV4ICs9IDFcbiAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKSByZXR1cm5cbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuYikgcmV0dXJuXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoXG4gIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMClcbiAgaW5kZXggKz0gbGVuYlxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVyblxuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwMiB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpbmRleCArPSAzXG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDIgfHxcbiAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8XG4gICAgICBsZW5ndGggPCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHJldHVybiBwcml2YXRlS2V5LnNsaWNlKGluZGV4ICsgMiwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBzaWdPYmoucl0pXG4gIGZvciAodmFyIGxlblIgPSAzMywgcG9zUiA9IDA7IGxlblIgPiAxICYmIHJbcG9zUl0gPT09IDB4MDAgJiYgIShyW3Bvc1IgKyAxXSAmIDB4ODApOyAtLWxlblIsICsrcG9zUik7XG5cbiAgdmFyIHMgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBzaWdPYmouc10pXG4gIGZvciAodmFyIGxlblMgPSAzMywgcG9zUyA9IDA7IGxlblMgPiAxICYmIHNbcG9zU10gPT09IDB4MDAgJiYgIShzW3Bvc1MgKyAxXSAmIDB4ODApOyAtLWxlblMsICsrcG9zUyk7XG5cbiAgcmV0dXJuIGJpcDY2LmVuY29kZShyLnNsaWNlKHBvc1IpLCBzLnNsaWNlKHBvc1MpKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuXG4gIHRyeSB7XG4gICAgdmFyIHNpZ09iaiA9IGJpcDY2LmRlY29kZShzaWcpXG4gICAgaWYgKHNpZ09iai5yLmxlbmd0aCA9PT0gMzMgJiYgc2lnT2JqLnJbMF0gPT09IDB4MDApIHNpZ09iai5yID0gc2lnT2JqLnIuc2xpY2UoMSlcbiAgICBpZiAoc2lnT2JqLnIubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKVxuICAgIGlmIChzaWdPYmoucy5sZW5ndGggPT09IDMzICYmIHNpZ09iai5zWzBdID09PSAweDAwKSBzaWdPYmoucyA9IHNpZ09iai5zLnNsaWNlKDEpXG4gICAgaWYgKHNpZ09iai5zLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzaWdPYmouci5jb3B5KHIsIDMyIC0gc2lnT2JqLnIubGVuZ3RoKVxuICBzaWdPYmoucy5jb3B5KHMsIDMyIC0gc2lnT2JqLnMubGVuZ3RoKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuXG4gIHZhciBsZW5ndGggPSBzaWcubGVuZ3RoXG4gIHZhciBpbmRleCA9IDBcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDMwKSByZXR1cm5cblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggYnl0ZVxuICB2YXIgbGVuYnl0ZSA9IHNpZ1tpbmRleCsrXVxuICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICBpbmRleCArPSBsZW5ieXRlIC0gMHg4MFxuICAgIGlmIChpbmRleCA+IGxlbmd0aCkgcmV0dXJuXG4gIH1cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3IgclxuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDAyKSByZXR1cm5cblxuICAvLyBsZW5ndGggZm9yIHJcbiAgdmFyIHJsZW4gPSBzaWdbaW5kZXgrK11cbiAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwXG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ1tpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSk7XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnW2luZGV4XVxuICB9XG4gIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHJldHVyblxuICB2YXIgcmluZGV4ID0gaW5kZXhcbiAgaW5kZXggKz0gcmxlblxuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gIGlmIChzaWdbaW5kZXgrK10gIT09IDB4MDIpIHJldHVyblxuXG4gIC8vIGxlbmd0aCBmb3Igc1xuICB2YXIgc2xlbiA9IHNpZ1tpbmRleCsrXVxuICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gc2xlbiAtIDB4ODBcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSByZXR1cm5cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKTtcbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWdbaW5kZXhdXG4gIH1cbiAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkgcmV0dXJuXG4gIHZhciBzaW5kZXggPSBpbmRleFxuICBpbmRleCArPSBzbGVuXG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpO1xuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikgcmV0dXJuXG4gIHZhciBydmFsdWUgPSBzaWcuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKVxuICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpXG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gc1xuICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpO1xuICAvLyBjb3B5IHMgdmFsdWVcbiAgaWYgKHNsZW4gPiAzMikgcmV0dXJuXG4gIHZhciBzdmFsdWUgPSBzaWcuc2xpY2Uoc2luZGV4LCBzaW5kZXggKyBzbGVuKVxuICBzdmFsdWUuY29weShzLCAzMiAtIHN2YWx1ZS5sZW5ndGgpXG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRW51bV9UZXpvc0JhbGxvdFR5cGUgPSBleHBvcnRzLkVudW1fVGV6b3NDb250cmFjdFR5cGUgPSBleHBvcnRzLkVudW1fU3RlbGxhclNpZ25lclR5cGUgPSBleHBvcnRzLkVudW1fU3RlbGxhck1lbW9UeXBlID0gZXhwb3J0cy5FbnVtX1N0ZWxsYXJBc3NldFR5cGUgPSBleHBvcnRzLkVudW1fTkVNSW1wb3J0YW5jZVRyYW5zZmVyTW9kZSA9IGV4cG9ydHMuRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5FbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBleHBvcnRzLkVudW1fTkVNTW9zYWljTGV2eSA9IGV4cG9ydHMuRW51bV9Xb3JkUmVxdWVzdFR5cGUgPSBleHBvcnRzLkVudW1fUmVjb3ZlcnlEZXZpY2VUeXBlID0gZXhwb3J0cy5FbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGUgPSBleHBvcnRzLkVudW1fQ2FwYWJpbGl0eSA9IGV4cG9ydHMuRW51bV9TYWZldHlDaGVja0xldmVsID0gZXhwb3J0cy5FbnVtX0JhY2t1cFR5cGUgPSBleHBvcnRzLkVudW1fRXRoZXJldW1EYXRhVHlwZSA9IGV4cG9ydHMuRW51bV9QaW5NYXRyaXhSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9CdXR0b25SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9GYWlsdXJlVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub0NlcnRpZmljYXRlVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBleHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub0FkZHJlc3NUeXBlID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9EZXJpdmF0aW9uVHlwZSA9IGV4cG9ydHMuRW51bV9SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9BbW91bnRVbml0ID0gZXhwb3J0cy5FbnVtX0RlY3JlZFN0YWtpbmdTcGVuZFR5cGUgPSBleHBvcnRzLkVudW1fT3V0cHV0U2NyaXB0VHlwZSA9IGV4cG9ydHMuRW51bV9JbnB1dFNjcmlwdFR5cGUgPSBleHBvcnRzLkVudW1fQmluYW5jZVRpbWVJbkZvcmNlID0gZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclNpZGUgPSBleHBvcnRzLkVudW1fQmluYW5jZU9yZGVyVHlwZSA9IHZvaWQgMDtcbi8vIFRoaXMgZmlsZSBpcyBhdXRvIGdlbmVyYXRlZCBmcm9tIGRhdGEvbWVzc2FnZXMvbWVzc2FnZS5qc29uXG4vLyBjdXN0b20gdHlwZSB1aW50MzIvNjQgbWF5IGJlIHJlcHJlc2VudGVkIGFzIHN0cmluZ1xuLy8gQmluYW5jZUdldEFkZHJlc3Ncbi8vIEJpbmFuY2VBZGRyZXNzXG4vLyBCaW5hbmNlR2V0UHVibGljS2V5XG4vLyBCaW5hbmNlUHVibGljS2V5XG4vLyBCaW5hbmNlU2lnblR4XG4vLyBCaW5hbmNlVHhSZXF1ZXN0XG4vLyBCaW5hbmNlVHJhbnNmZXJNc2dcbnZhciBFbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgT1RfVU5LTk9XTjogMCxcbiAgTUFSS0VUOiAxLFxuICBMSU1JVDogMixcbiAgT1RfUkVTRVJWRUQ6IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBFbnVtX0JpbmFuY2VPcmRlclR5cGU7XG52YXIgRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNJREVfVU5LTk9XTjogMCxcbiAgQlVZOiAxLFxuICBTRUxMOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gRW51bV9CaW5hbmNlT3JkZXJTaWRlO1xudmFyIEVudW1fQmluYW5jZVRpbWVJbkZvcmNlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRJRl9VTktOT1dOOiAwLFxuICBHVEU6IDEsXG4gIFRJRl9SRVNFUlZFRDogMixcbiAgSU9DOiAzXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlVGltZUluRm9yY2UgPSBFbnVtX0JpbmFuY2VUaW1lSW5Gb3JjZTtcbnZhciBFbnVtX0lucHV0U2NyaXB0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTUEVOREFERFJFU1M6IDAsXG4gIFNQRU5ETVVMVElTSUc6IDEsXG4gIEVYVEVSTkFMOiAyLFxuICBTUEVORFdJVE5FU1M6IDMsXG4gIFNQRU5EUDJTSFdJVE5FU1M6IDQsXG4gIFNQRU5EVEFQUk9PVDogNVxufSk7XG5leHBvcnRzLkVudW1fSW5wdXRTY3JpcHRUeXBlID0gRW51bV9JbnB1dFNjcmlwdFR5cGU7XG52YXIgRW51bV9PdXRwdXRTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBBWVRPQUREUkVTUzogMCxcbiAgUEFZVE9TQ1JJUFRIQVNIOiAxLFxuICBQQVlUT01VTFRJU0lHOiAyLFxuICBQQVlUT09QUkVUVVJOOiAzLFxuICBQQVlUT1dJVE5FU1M6IDQsXG4gIFBBWVRPUDJTSFdJVE5FU1M6IDUsXG4gIFBBWVRPVEFQUk9PVDogNlxufSk7XG5leHBvcnRzLkVudW1fT3V0cHV0U2NyaXB0VHlwZSA9IEVudW1fT3V0cHV0U2NyaXB0VHlwZTtcbnZhciBFbnVtX0RlY3JlZFN0YWtpbmdTcGVuZFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1NHZW46IDAsXG4gIFNTUlRYOiAxXG59KTtcbmV4cG9ydHMuRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlID0gRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlO1xudmFyIEVudW1fQW1vdW50VW5pdCA9IE9iamVjdC5mcmVlemUoe1xuICBCSVRDT0lOOiAwLFxuICBNSUxMSUJJVENPSU46IDEsXG4gIE1JQ1JPQklUQ09JTjogMixcbiAgU0FUT1NISTogM1xufSk7XG5leHBvcnRzLkVudW1fQW1vdW50VW5pdCA9IEVudW1fQW1vdW50VW5pdDtcbnZhciBFbnVtX1JlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRYSU5QVVQ6IDAsXG4gIFRYT1VUUFVUOiAxLFxuICBUWE1FVEE6IDIsXG4gIFRYRklOSVNIRUQ6IDMsXG4gIFRYRVhUUkFEQVRBOiA0LFxuICBUWE9SSUdJTlBVVDogNSxcbiAgVFhPUklHT1VUUFVUOiA2XG59KTtcbmV4cG9ydHMuRW51bV9SZXF1ZXN0VHlwZSA9IEVudW1fUmVxdWVzdFR5cGU7XG52YXIgRW51bV9DYXJkYW5vRGVyaXZhdGlvblR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTEVER0VSOiAwLFxuICBJQ0FSVVM6IDEsXG4gIElDQVJVU19UUkVaT1I6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9EZXJpdmF0aW9uVHlwZSA9IEVudW1fQ2FyZGFub0Rlcml2YXRpb25UeXBlO1xudmFyIEVudW1fQ2FyZGFub0FkZHJlc3NUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJBU0U6IDAsXG4gIEJBU0VfU0NSSVBUX0tFWTogMSxcbiAgQkFTRV9LRVlfU0NSSVBUOiAyLFxuICBCQVNFX1NDUklQVF9TQ1JJUFQ6IDMsXG4gIFBPSU5URVI6IDQsXG4gIFBPSU5URVJfU0NSSVBUOiA1LFxuICBFTlRFUlBSSVNFOiA2LFxuICBFTlRFUlBSSVNFX1NDUklQVDogNyxcbiAgQllST046IDgsXG4gIFJFV0FSRDogMTQsXG4gIFJFV0FSRF9TQ1JJUFQ6IDE1XG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vQWRkcmVzc1R5cGUgPSBFbnVtX0NhcmRhbm9BZGRyZXNzVHlwZTtcbnZhciBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBVQl9LRVk6IDAsXG4gIEFMTDogMSxcbiAgQU5ZOiAyLFxuICBOX09GX0s6IDMsXG4gIElOVkFMSURfQkVGT1JFOiA0LFxuICBJTlZBTElEX0hFUkVBRlRFUjogNVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlO1xudmFyIEVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEhJREU6IDAsXG4gIEJFQ0gzMjogMSxcbiAgUE9MSUNZX0lEOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRIYXNoRGlzcGxheUZvcm1hdDtcbnZhciBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1RBS0VfUkVHSVNUUkFUSU9OOiAwLFxuICBTVEFLRV9ERVJFR0lTVFJBVElPTjogMSxcbiAgU1RBS0VfREVMRUdBVElPTjogMixcbiAgU1RBS0VfUE9PTF9SRUdJU1RSQVRJT046IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGU7XG52YXIgRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTSU5HTEVfSE9TVF9JUDogMCxcbiAgU0lOR0xFX0hPU1RfTkFNRTogMSxcbiAgTVVMVElQTEVfSE9TVF9OQU1FOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IEVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTk9ORTogMCxcbiAgQ0FUQUxZU1RfUkVHSVNUUkFUSU9OX1NJR05BVFVSRTogMVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub1R4QXV4aWxpYXJ5RGF0YVN1cHBsZW1lbnRUeXBlID0gRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IE9iamVjdC5mcmVlemUoe1xuICBPUkRJTkFSWV9UUkFOU0FDVElPTjogMCxcbiAgUE9PTF9SRUdJU1RSQVRJT05fQVNfT1dORVI6IDEsXG4gIE1VTFRJU0lHX1RSQU5TQUNUSU9OOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IEVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGU7XG52YXIgRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBCWVJPTl9XSVRORVNTOiAwLFxuICBTSEVMTEVZX1dJVE5FU1M6IDFcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9UeFdpdG5lc3NUeXBlID0gRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZTtcbnZhciBFbnVtX0ZhaWx1cmVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEZhaWx1cmVfVW5leHBlY3RlZE1lc3NhZ2U6IDEsXG4gIEZhaWx1cmVfQnV0dG9uRXhwZWN0ZWQ6IDIsXG4gIEZhaWx1cmVfRGF0YUVycm9yOiAzLFxuICBGYWlsdXJlX0FjdGlvbkNhbmNlbGxlZDogNCxcbiAgRmFpbHVyZV9QaW5FeHBlY3RlZDogNSxcbiAgRmFpbHVyZV9QaW5DYW5jZWxsZWQ6IDYsXG4gIEZhaWx1cmVfUGluSW52YWxpZDogNyxcbiAgRmFpbHVyZV9JbnZhbGlkU2lnbmF0dXJlOiA4LFxuICBGYWlsdXJlX1Byb2Nlc3NFcnJvcjogOSxcbiAgRmFpbHVyZV9Ob3RFbm91Z2hGdW5kczogMTAsXG4gIEZhaWx1cmVfTm90SW5pdGlhbGl6ZWQ6IDExLFxuICBGYWlsdXJlX1Bpbk1pc21hdGNoOiAxMixcbiAgRmFpbHVyZV9XaXBlQ29kZU1pc21hdGNoOiAxMyxcbiAgRmFpbHVyZV9JbnZhbGlkU2Vzc2lvbjogMTQsXG4gIEZhaWx1cmVfRmlybXdhcmVFcnJvcjogOTlcbn0pO1xuZXhwb3J0cy5FbnVtX0ZhaWx1cmVUeXBlID0gRW51bV9GYWlsdXJlVHlwZTtcbnZhciBFbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJ1dHRvblJlcXVlc3RfT3RoZXI6IDEsXG4gIEJ1dHRvblJlcXVlc3RfRmVlT3ZlclRocmVzaG9sZDogMixcbiAgQnV0dG9uUmVxdWVzdF9Db25maXJtT3V0cHV0OiAzLFxuICBCdXR0b25SZXF1ZXN0X1Jlc2V0RGV2aWNlOiA0LFxuICBCdXR0b25SZXF1ZXN0X0NvbmZpcm1Xb3JkOiA1LFxuICBCdXR0b25SZXF1ZXN0X1dpcGVEZXZpY2U6IDYsXG4gIEJ1dHRvblJlcXVlc3RfUHJvdGVjdENhbGw6IDcsXG4gIEJ1dHRvblJlcXVlc3RfU2lnblR4OiA4LFxuICBCdXR0b25SZXF1ZXN0X0Zpcm13YXJlQ2hlY2s6IDksXG4gIEJ1dHRvblJlcXVlc3RfQWRkcmVzczogMTAsXG4gIEJ1dHRvblJlcXVlc3RfUHVibGljS2V5OiAxMSxcbiAgQnV0dG9uUmVxdWVzdF9NbmVtb25pY1dvcmRDb3VudDogMTIsXG4gIEJ1dHRvblJlcXVlc3RfTW5lbW9uaWNJbnB1dDogMTMsXG4gIF9EZXByZWNhdGVkX0J1dHRvblJlcXVlc3RfUGFzc3BocmFzZVR5cGU6IDE0LFxuICBCdXR0b25SZXF1ZXN0X1Vua25vd25EZXJpdmF0aW9uUGF0aDogMTUsXG4gIEJ1dHRvblJlcXVlc3RfUmVjb3ZlcnlIb21lcGFnZTogMTYsXG4gIEJ1dHRvblJlcXVlc3RfU3VjY2VzczogMTcsXG4gIEJ1dHRvblJlcXVlc3RfV2FybmluZzogMTgsXG4gIEJ1dHRvblJlcXVlc3RfUGFzc3BocmFzZUVudHJ5OiAxOSxcbiAgQnV0dG9uUmVxdWVzdF9QaW5FbnRyeTogMjBcbn0pO1xuZXhwb3J0cy5FbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gRW51bV9CdXR0b25SZXF1ZXN0VHlwZTtcbnZhciBFbnVtX1Bpbk1hdHJpeFJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX0N1cnJlbnQ6IDEsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX05ld0ZpcnN0OiAyLFxuICBQaW5NYXRyaXhSZXF1ZXN0VHlwZV9OZXdTZWNvbmQ6IDMsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlRmlyc3Q6IDQsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlU2Vjb25kOiA1XG59KTtcbmV4cG9ydHMuRW51bV9QaW5NYXRyaXhSZXF1ZXN0VHlwZSA9IEVudW1fUGluTWF0cml4UmVxdWVzdFR5cGU7XG52YXIgRW51bV9FdGhlcmV1bURhdGFUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFVJTlQ6IDEsXG4gIElOVDogMixcbiAgQllURVM6IDMsXG4gIFNUUklORzogNCxcbiAgQk9PTDogNSxcbiAgQUREUkVTUzogNixcbiAgQVJSQVk6IDcsXG4gIFNUUlVDVDogOFxufSk7XG5leHBvcnRzLkVudW1fRXRoZXJldW1EYXRhVHlwZSA9IEVudW1fRXRoZXJldW1EYXRhVHlwZTtcbnZhciBFbnVtX0JhY2t1cFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgQmlwMzk6IDAsXG4gIFNsaXAzOV9CYXNpYzogMSxcbiAgU2xpcDM5X0FkdmFuY2VkOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CYWNrdXBUeXBlID0gRW51bV9CYWNrdXBUeXBlO1xudmFyIEVudW1fU2FmZXR5Q2hlY2tMZXZlbCA9IE9iamVjdC5mcmVlemUoe1xuICBTdHJpY3Q6IDAsXG4gIFByb21wdEFsd2F5czogMSxcbiAgUHJvbXB0VGVtcG9yYXJpbHk6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1NhZmV0eUNoZWNrTGV2ZWwgPSBFbnVtX1NhZmV0eUNoZWNrTGV2ZWw7XG52YXIgRW51bV9DYXBhYmlsaXR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENhcGFiaWxpdHlfQml0Y29pbjogMSxcbiAgQ2FwYWJpbGl0eV9CaXRjb2luX2xpa2U6IDIsXG4gIENhcGFiaWxpdHlfQmluYW5jZTogMyxcbiAgQ2FwYWJpbGl0eV9DYXJkYW5vOiA0LFxuICBDYXBhYmlsaXR5X0NyeXB0bzogNSxcbiAgQ2FwYWJpbGl0eV9FT1M6IDYsXG4gIENhcGFiaWxpdHlfRXRoZXJldW06IDcsXG4gIENhcGFiaWxpdHlfTGlzazogOCxcbiAgQ2FwYWJpbGl0eV9Nb25lcm86IDksXG4gIENhcGFiaWxpdHlfTkVNOiAxMCxcbiAgQ2FwYWJpbGl0eV9SaXBwbGU6IDExLFxuICBDYXBhYmlsaXR5X1N0ZWxsYXI6IDEyLFxuICBDYXBhYmlsaXR5X1Rlem9zOiAxMyxcbiAgQ2FwYWJpbGl0eV9VMkY6IDE0LFxuICBDYXBhYmlsaXR5X1NoYW1pcjogMTUsXG4gIENhcGFiaWxpdHlfU2hhbWlyR3JvdXBzOiAxNixcbiAgQ2FwYWJpbGl0eV9QYXNzcGhyYXNlRW50cnk6IDE3XG59KTtcbmV4cG9ydHMuRW51bV9DYXBhYmlsaXR5ID0gRW51bV9DYXBhYmlsaXR5O1xudmFyIEVudW1fU2RQcm90ZWN0T3BlcmF0aW9uVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBESVNBQkxFOiAwLFxuICBFTkFCTEU6IDEsXG4gIFJFRlJFU0g6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGUgPSBFbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGU7XG52YXIgRW51bV9SZWNvdmVyeURldmljZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVjb3ZlcnlEZXZpY2VUeXBlX1NjcmFtYmxlZFdvcmRzOiAwLFxuICBSZWNvdmVyeURldmljZVR5cGVfTWF0cml4OiAxXG59KTtcbmV4cG9ydHMuRW51bV9SZWNvdmVyeURldmljZVR5cGUgPSBFbnVtX1JlY292ZXJ5RGV2aWNlVHlwZTtcbnZhciBFbnVtX1dvcmRSZXF1ZXN0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBXb3JkUmVxdWVzdFR5cGVfUGxhaW46IDAsXG4gIFdvcmRSZXF1ZXN0VHlwZV9NYXRyaXg5OiAxLFxuICBXb3JkUmVxdWVzdFR5cGVfTWF0cml4NjogMlxufSk7XG5leHBvcnRzLkVudW1fV29yZFJlcXVlc3RUeXBlID0gRW51bV9Xb3JkUmVxdWVzdFR5cGU7XG52YXIgRW51bV9ORU1Nb3NhaWNMZXZ5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE1vc2FpY0xldnlfQWJzb2x1dGU6IDEsXG4gIE1vc2FpY0xldnlfUGVyY2VudGlsZTogMlxufSk7XG5leHBvcnRzLkVudW1fTkVNTW9zYWljTGV2eSA9IEVudW1fTkVNTW9zYWljTGV2eTtcbnZhciBFbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU3VwcGx5Q2hhbmdlX0luY3JlYXNlOiAxLFxuICBTdXBwbHlDaGFuZ2VfRGVjcmVhc2U6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBFbnVtX05FTVN1cHBseUNoYW5nZVR5cGU7XG52YXIgRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENvc2lnbmF0b3J5TW9kaWZpY2F0aW9uX0FkZDogMSxcbiAgQ29zaWduYXRvcnlNb2RpZmljYXRpb25fRGVsZXRlOiAyXG59KTtcbmV4cG9ydHMuRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlO1xudmFyIEVudW1fTkVNSW1wb3J0YW5jZVRyYW5zZmVyTW9kZSA9IE9iamVjdC5mcmVlemUoe1xuICBJbXBvcnRhbmNlVHJhbnNmZXJfQWN0aXZhdGU6IDEsXG4gIEltcG9ydGFuY2VUcmFuc2Zlcl9EZWFjdGl2YXRlOiAyXG59KTtcbmV4cG9ydHMuRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlID0gRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlO1xudmFyIEVudW1fU3RlbGxhckFzc2V0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBOQVRJVkU6IDAsXG4gIEFMUEhBTlVNNDogMSxcbiAgQUxQSEFOVU0xMjogMlxufSk7XG5leHBvcnRzLkVudW1fU3RlbGxhckFzc2V0VHlwZSA9IEVudW1fU3RlbGxhckFzc2V0VHlwZTtcbnZhciBFbnVtX1N0ZWxsYXJNZW1vVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBOT05FOiAwLFxuICBURVhUOiAxLFxuICBJRDogMixcbiAgSEFTSDogMyxcbiAgUkVUVVJOOiA0XG59KTtcbmV4cG9ydHMuRW51bV9TdGVsbGFyTWVtb1R5cGUgPSBFbnVtX1N0ZWxsYXJNZW1vVHlwZTtcbnZhciBFbnVtX1N0ZWxsYXJTaWduZXJUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEFDQ09VTlQ6IDAsXG4gIFBSRV9BVVRIOiAxLFxuICBIQVNIOiAyXG59KTtcbmV4cG9ydHMuRW51bV9TdGVsbGFyU2lnbmVyVHlwZSA9IEVudW1fU3RlbGxhclNpZ25lclR5cGU7XG52YXIgRW51bV9UZXpvc0NvbnRyYWN0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBJbXBsaWNpdDogMCxcbiAgT3JpZ2luYXRlZDogMVxufSk7XG5leHBvcnRzLkVudW1fVGV6b3NDb250cmFjdFR5cGUgPSBFbnVtX1Rlem9zQ29udHJhY3RUeXBlO1xudmFyIEVudW1fVGV6b3NCYWxsb3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFlheTogMCxcbiAgTmF5OiAxLFxuICBQYXNzOiAyXG59KTtcbmV4cG9ydHMuRW51bV9UZXpvc0JhbGxvdFR5cGUgPSBFbnVtX1Rlem9zQmFsbG90VHlwZTsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBpc05hdGl2ZUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vaXNOYXRpdmVGdW5jdGlvbi5qc1wiKTtcblxudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIWlzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXI7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyZWF0ZUFzeW5jID0gY3JlYXRlQXN5bmM7XG5leHBvcnRzLnJlc29sdmVUaW1lb3V0UHJvbWlzZSA9IHJlc29sdmVUaW1lb3V0UHJvbWlzZTtcbmV4cG9ydHMucmVqZWN0VGltZW91dFByb21pc2UgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBjcmVhdGUoYXJnLCBkZXZpY2UpIHtcbiAgdmFyIGxvY2FsUmVzb2x2ZSA9IGZ1bmN0aW9uIGxvY2FsUmVzb2x2ZShfdCkge307XG5cbiAgdmFyIGxvY2FsUmVqZWN0ID0gZnVuY3Rpb24gbG9jYWxSZWplY3QoX2UpIHt9O1xuXG4gIHZhciBpZDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcblxuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBsb2NhbFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICBsb2NhbFJlamVjdCA9IHJlamVjdDtcblxuICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZygpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDg7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgcmVqZWN0KF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSBpZCA9IGFyZztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMywgOF1dKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogaWQsXG4gICAgZGV2aWNlOiBkZXZpY2UsXG4gICAgcmVzb2x2ZTogbG9jYWxSZXNvbHZlLFxuICAgIHJlamVjdDogbG9jYWxSZWplY3QsXG4gICAgcHJvbWlzZTogcHJvbWlzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luYyhpbm5lckZuKSB7XG4gIHZhciBsb2NhbFJlc29sdmUgPSBmdW5jdGlvbiBsb2NhbFJlc29sdmUoX3QpIHt9O1xuXG4gIHZhciBsb2NhbFJlamVjdCA9IGZ1bmN0aW9uIGxvY2FsUmVqZWN0KF9lKSB7fTtcblxuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsb2NhbFJlc29sdmUgPSByZXNvbHZlO1xuICAgIGxvY2FsUmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICB2YXIgaW5uZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBpbm5lckZuKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMik7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHJldHVybiB7XG4gICAgcmVzb2x2ZTogbG9jYWxSZXNvbHZlLFxuICAgIHJlamVjdDogbG9jYWxSZWplY3QsXG4gICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGlubmVyKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUaW1lb3V0UHJvbWlzZShkZWxheSwgcmVzdWx0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59XG5cbnZhciByZWplY3RUaW1lb3V0UHJvbWlzZSA9IGZ1bmN0aW9uIHJlamVjdFRpbWVvdXRQcm9taXNlKGRlbGF5LCBlcnJvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9LCBkZWxheSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5yZWplY3RUaW1lb3V0UHJvbWlzZSA9IHJlamVjdFRpbWVvdXRQcm9taXNlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0T3JpZ2luID0gZXhwb3J0cy5odHRwUmVxdWVzdCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY3Jvc3NGZXRjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNyb3NzLWZldGNoXCIpKTtcblxudmFyIGh0dHBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1cmwsIHR5cGUpIHtcbiAgICB2YXIgcmVzcG9uc2UsIHR4dDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2Nyb3NzRmV0Y2hbXCJkZWZhdWx0XCJdKSh1cmwsIHtcbiAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHR5cGUgPT09ICdqc29uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgdHh0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgSlNPTi5wYXJzZSh0eHQpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBpZiAoISh0eXBlID09PSAnYmluYXJ5JykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlLnRleHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaHR0cFJlcXVlc3QgZXJyb3I6IFwiICsgdXJsICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBSZXF1ZXN0KF94LCBfeDIpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmh0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG5cbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiBnZXRPcmlnaW4odXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwKSByZXR1cm4gJ2ZpbGU6Ly8nOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICB2YXIgcGFydHMgPSB1cmwubWF0Y2goL14uK1xcOlxcL1xcL1teXFwvXSsvKTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFydHMpICYmIHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICd1bmtub3duJztcbn07XG5cbmV4cG9ydHMuZ2V0T3JpZ2luID0gZ2V0T3JpZ2luOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zaG93UG9wdXBSZXF1ZXN0ID0gdm9pZCAwO1xudmFyIExBWUVSX0lEID0gJ1RyZXpvckNvbm5lY3RJbnRlcmFjdGlvbkxheWVyJztcbnZhciBIVE1MID0gXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jb250YWluZXJcXFwiIGlkPVxcXCJcIiArIExBWUVSX0lEICsgXCJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC13aW5kb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtaGVhZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtbG9nb1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNjMuNyA0MS45XFxcIiB3aWR0aD1cXFwiNzhweFxcXCIgaGVpZ2h0PVxcXCIyMHB4XFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWluWU1pbiBtZWV0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiMTAxLjEsMTIuOCAxMTguMiwxMi44IDExOC4yLDE3LjMgMTA4LjksMjkuOSAxMTguMiwyOS45IDExOC4yLDM1LjIgMTAxLjEsMzUuMiAxMDEuMSwzMC43IDExMC40LDE4LjEgMTAxLjEsMTguMVxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTE1OC44LDI2LjljMi4xLTAuOCw0LjMtMi45LDQuMy02LjZjMC00LjUtMy4xLTcuNC03LjctNy40aC0xMC41djIyLjNoNS44di03LjVoMi4ybDQuMSw3LjVoNi43TDE1OC44LDI2Ljl6IE0xNTQuNywyMi41IGgtNFYxOGg0YzEuNSwwLDIuNSwwLjksMi41LDIuMkMxNTcuMiwyMS42LDE1Ni4yLDIyLjUsMTU0LjcsMjIuNXpcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XFxcIk0xMzAuOCwxMi41Yy02LjgsMC0xMS42LDQuOS0xMS42LDExLjVzNC45LDExLjUsMTEuNiwxMS41czExLjctNC45LDExLjctMTEuNVMxMzcuNiwxMi41LDEzMC44LDEyLjV6IE0xMzAuOCwzMC4zIGMtMy40LDAtNS43LTIuNi01LjctNi4zYzAtMy44LDIuMy02LjMsNS43LTYuM2MzLjQsMCw1LjgsMi42LDUuOCw2LjNDMTM2LjYsMjcuNywxMzQuMiwzMC4zLDEzMC44LDMwLjN6XFxcIi8+XFxuICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XFxcIjgyLjEsMTIuOCA5OC4zLDEyLjggOTguMywxOCA4Ny45LDE4IDg3LjksMjEuMyA5OCwyMS4zIDk4LDI2LjQgODcuOSwyNi40IDg3LjksMzAgOTguMywzMCA5OC4zLDM1LjIgODIuMSwzNS4yIFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTI0LjYsOS43QzI0LjYsNC40LDIwLDAsMTQuNCwwUzQuMiw0LjQsNC4yLDkuN3YzLjFIMHYyMi4zaDBsMTQuNCw2LjdsMTQuNC02LjdoMFYxMi45aC00LjJWOS43eiBNOS40LDkuNyBjMC0yLjUsMi4yLTQuNSw1LTQuNXM1LDIsNSw0LjV2My4xSDkuNFY5Ljd6IE0yMywzMS41bC04LjYsNGwtOC42LTRWMTguMUgyM1YzMS41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTc5LjQsMjAuM2MwLTQuNS0zLjEtNy40LTcuNy03LjRINjEuMnYyMi4zSDY3di03LjVoMi4ybDQuMSw3LjVIODBsLTQuOS04LjNDNzcuMiwyNi4xLDc5LjQsMjQsNzkuNCwyMC4zeiBNNzEsMjIuNWgtNFYxOCBoNGMxLjUsMCwyLjUsMC45LDIuNSwyLjJDNzMuNSwyMS42LDcyLjUsMjIuNSw3MSwyMi41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVxcXCI0MC41LDEyLjggNTguNiwxMi44IDU4LjYsMTguMSA1Mi40LDE4LjEgNTIuNCwzNS4yIDQ2LjYsMzUuMiA0Ni42LDE4LjEgNDAuNSwxOC4xIFxcXCIvPlxcbiAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jbG9zZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIyNCAyNCA2MCA2MFxcXCIgd2lkdGg9XFxcIjI0cHhcXFwiIGhlaWdodD1cXFwiMjRweFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pbllNaW4gbWVldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9XFxcInN0MFxcXCIgcG9pbnRzPVxcXCI0MCw2Ny45IDQyLjEsNzAgNTUsNTcuMSA2Ny45LDcwIDcwLDY3LjkgNTcuMSw1NSA3MCw0Mi4xIDY3LjksNDAgNTUsNTIuOSA0Mi4xLDQwIDQwLDQyLjEgNTIuOSw1NSBcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDM+UG9wdXAgd2FzIGJsb2NrZWQ8L2gzPlxcbiAgICAgICAgICAgICAgICA8cD5QbGVhc2UgY2xpY2sgdG8gXFx1MjAxQ0NvbnRpbnVlXFx1MjAxRCB0byBvcGVuIHBvcHVwIG1hbnVhbGx5PC9wPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LW9wZW5cXFwiPkNvbnRpbnVlPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXCI7XG5cbnZhciBzaG93UG9wdXBSZXF1ZXN0ID0gZnVuY3Rpb24gc2hvd1BvcHVwUmVxdWVzdChvcGVuLCBjYW5jZWwpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKExBWUVSX0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gTEFZRVJfSUQ7XG4gIGRpdi5jbGFzc05hbWUgPSAndHJlem9yY29ubmVjdC1jb250YWluZXInO1xuICBkaXYuaW5uZXJIVE1MID0gSFRNTDtcblxuICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHZhciBidXR0b24gPSBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndHJlem9yY29ubmVjdC1vcGVuJylbMF07XG5cbiAgYnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3BlbigpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RyZXpvcmNvbm5lY3QtY2xvc2UnKVswXTtcblxuICBjbG9zZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbmNlbCgpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLnNob3dQb3B1cFJlcXVlc3QgPSBzaG93UG9wdXBSZXF1ZXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgY3NzID0gJy50cmV6b3Jjb25uZWN0LWNvbnRhaW5lcntwb3NpdGlvbjpmaXhlZCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWJveCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWZsZXghaW1wb3J0YW50O2Rpc3BsYXk6LW1zLWZsZXhib3ghaW1wb3J0YW50O2Rpc3BsYXk6ZmxleCFpbXBvcnRhbnQ7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsIWltcG9ydGFudDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsIWltcG9ydGFudDstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbiFpbXBvcnRhbnQ7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbiFpbXBvcnRhbnQ7ZmxleC1kaXJlY3Rpb246Y29sdW1uIWltcG9ydGFudDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXIhaW1wb3J0YW50Oy13ZWJraXQtYWxpZ24taXRlbXM6Y2VudGVyIWltcG9ydGFudDstbXMtZmxleC1hbGlnbjpjZW50ZXIhaW1wb3J0YW50O2FsaWduLWl0ZW1zOmNlbnRlciFpbXBvcnRhbnQ7ei1pbmRleDoxMDAwMCFpbXBvcnRhbnQ7d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50O3RvcDowIWltcG9ydGFudDtsZWZ0OjAhaW1wb3J0YW50O2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzUpIWltcG9ydGFudDtvdmVyZmxvdzphdXRvIWltcG9ydGFudDtwYWRkaW5nOjIwcHghaW1wb3J0YW50O21hcmdpbjowIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93e3Bvc2l0aW9uOnJlbGF0aXZlIWltcG9ydGFudDtkaXNwbGF5OmJsb2NrIWltcG9ydGFudDt3aWR0aDozNzBweCFpbXBvcnRhbnQ7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXCJTZWdvZSBVSVwiLFJvYm90byxcIkhlbHZldGljYSBOZXVlXCIsQXJpYWwsc2Fucy1zZXJpZiFpbXBvcnRhbnQ7bWFyZ2luOmF1dG8haW1wb3J0YW50O2JvcmRlci1yYWRpdXM6M3B4IWltcG9ydGFudDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmYhaW1wb3J0YW50O3RleHQtYWxpZ246Y2VudGVyIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW4haW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtaGVhZHt0ZXh0LWFsaWduOmxlZnQ7cGFkZGluZzoxMnB4IDI0cHghaW1wb3J0YW50O2Rpc3BsYXk6LXdlYmtpdC1ib3ghaW1wb3J0YW50O2Rpc3BsYXk6LXdlYmtpdC1mbGV4IWltcG9ydGFudDtkaXNwbGF5Oi1tcy1mbGV4Ym94IWltcG9ydGFudDtkaXNwbGF5OmZsZXghaW1wb3J0YW50Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXIhaW1wb3J0YW50Oy1tcy1mbGV4LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7YWxpZ24taXRlbXM6Y2VudGVyIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtbG9nb3std2Via2l0LWJveC1mbGV4OjE7LXdlYmtpdC1mbGV4OjE7LW1zLWZsZXg6MTtmbGV4OjF9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1oZWFkIC50cmV6b3Jjb25uZWN0LWNsb3Nle2N1cnNvcjpwb2ludGVyIWltcG9ydGFudDtoZWlnaHQ6MjRweCFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1oZWFkIC50cmV6b3Jjb25uZWN0LWNsb3NlIHN2Z3tmaWxsOiM3NTc1NzU7LXdlYmtpdC10cmFuc2l0aW9uOmZpbGwgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudDt0cmFuc2l0aW9uOmZpbGwgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtY2xvc2U6aG92ZXIgc3Zne2ZpbGw6IzQ5NDk0OX0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHl7cGFkZGluZzoyNHB4IDI0cHggMzJweCFpbXBvcnRhbnQ7YmFja2dyb3VuZDojRkJGQkZCIWltcG9ydGFudDtib3JkZXItdG9wOjFweCBzb2xpZCAjRUJFQkVCfS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtYm9keSBoM3tjb2xvcjojNTA1MDUwIWltcG9ydGFudDtmb250LXNpemU6MTZweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6NTAwIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgcHttYXJnaW46OHB4IDAgMjRweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6NDAwIWltcG9ydGFudDtjb2xvcjojQTlBOUE5IWltcG9ydGFudDtmb250LXNpemU6MTJweCFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1ib2R5IGJ1dHRvbnt3aWR0aDoxMDAlIWltcG9ydGFudDtwYWRkaW5nOjEycHggMjRweCFpbXBvcnRhbnQ7bWFyZ2luOjAhaW1wb3J0YW50O2JvcmRlci1yYWRpdXM6M3B4IWltcG9ydGFudDtmb250LXNpemU6MTRweCFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6MzAwIWltcG9ydGFudDtjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnQ7YmFja2dyb3VuZDojMDFCNzU3IWltcG9ydGFudDtjb2xvcjojZmZmIWltcG9ydGFudDtib3JkZXI6MCFpbXBvcnRhbnQ7LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGVhc2UtaW4tb3V0IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzAwQUI1MSFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1ib2R5IGJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMDA5NTQ2IWltcG9ydGFudH0vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1sdWNIVjBJaXdpSkhOMFpHbHVJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRV05CTEhsQ1FVTkpMRk5CUVVFc1owSkJRMEVzVVVGQlFTeHpRa0ZEUVN4UlFVRkJMSFZDUVVOQkxGRkJRVUVzYzBKQlJVRXNVVUZCUVN4bFFVTkJMRzFDUVVGQkxHMUNRVU5CTEhOQ1FVRkJMR2xDUVVOQkxIVkNRVUZCTEdsQ1FVTkJMRzFDUVVGQkxHbENRVU5CTEdWQlFVRXNhVUpCUlVFc2EwSkJRVUVzYVVKQlEwRXNiMEpCUVVFc2FVSkJRMEVzWlVGQlFTeHBRa05tVFN4WlFVRmhMR2xDUkVGeVFpeFJRVUZUTEdkQ1FXdENTQ3hOUVVGQkxHVkJRMEVzVDBGQlFTeGxRVU5CTEVsQlFVRXNXVUZEUVN4TFFVRkJMRmxCUTBFc1YwRkJRU3d3UWtGRFFTeFRRVUZCTEdWQlEwRXNVVUZCUVN4bFFVTkJMRTlCUVVFc1dVTmtVaXdyUTBSWVJTeFRRVUZWTEcxQ1FUWkNRU3hSUVVGQkxHZENRVU5CTEUxQlFVRXNaMEpCUTBFc1dVRkJRU3hqUVVGQkxHMUNRVUZCTEZkQlFVRXNUMEZCUVN4cFFrRkJRU3hOUVVGQkxIRkNRVU5CTEU5QlFVRXNaVU5tVml4alFVRmxMR05FYWtKbUxHbENRV2xDUlN4bFFXdENXU3hYUVVGQkxHbENRMlprTEZOQlFWVXNhVUpFYlVKSkxHMUZRVU5CTEZkQlFVRXNTME5vUW1Rc1VVRkJVeXhMUVVGTExHVkVlRUprTEZGQlFWTXNjMEpCTUVOVExGRkJRVUVzZFVKQlEwRXNVVUZCUVN4elFrTm1iRUlzVVVGQlV5eGxSR2xDU3l4clFrRTFRbG9zYVVKQk9FSnZRaXh2UWtGQlFTeHBRa05vUW14Q0xHVkJRV2RDTEdsQ1JDOUNXaXhaUVdsQ1RpeHBRa0Z6UTFFc2RVWkJRMEVzYVVKQlFVRXNSVU53UWxZc1lVRkJZeXhGUkhCRFZpeFRRVUZWTEVWQk1rUkJMRXRCUVVFc1JVRkZRU3gzUmtOd1FtUXNUMEZCVVN4clFrUjZRMUlzVDBGQlVTeGxRV2xGVFN3MFJrRkRRU3hMUVVGQkxGRkJRMEVzYlVKQlFVRXNTMEZCUVN4SlFVRkJMSE5DUTNCQ1pDeFhRVUZaTEV0QlFVc3NTVUZCU3l4elFrUjNRbElzYTBkQlEwRXNTMEZCUVN4UlFVVkJMRzFGUVVOQkxGRkJRVUVzUzBGQlFTeExRVUZCTEdWQlEwRXNWMEZCUVN4clFrRkRRU3hYUVVGQkxFbEJRVUVzVFVGQlFTeFJRVVZCTEhORlFVTkJMRTFCUVVFc2EwSkJRMEVzVlVGQlFTeGxRM0pDWkN4WlFVRmhMR05FZDBKTExIRkZRM0pDYkVJc1QwRkJVU3hKUVVGSkxFVkJRVWtzWlVSM1FrWXNXVUZCUVN4alFVTkpMRTFCUVVFc2EwSkRkRUpzUWl4VlFVRlhMR1ZCUldJc01FVkJRMFVzVFVGQlR5eGxRVU5RTEZGQlFWTXNTMEZCU3l4bFFVTmtMRTlCUVZFc1dVRkRVaXhqUVVGbExHTkJRMllzVlVGQlZ5eGxRVU5ZTEZsQlFXRXNZMEZEWWl4UFFVRlJMR3RDUVVOU0xGZEJRVmtzYTBKQlExb3NUVUZCVHl4bFFVTlFMRTlCUVZFc1dVRkRVaXh0UWtGQmIwSXNhVUpCUVdsQ0xFbEJRVXNzYzBKQlF6RkRMRmRCUVZrc2FVSkJRV2xDTEVsQlFVc3NjMEpCUlhCRExHZEdRVU5GTEdsQ1FVRnJRaXhyUWtGRmNFSXNhVVpCUTBVc2FVSkJRV3RDSW4wPSAqLyc7XG52YXIgX2RlZmF1bHQgPSBjc3M7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBleHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG5leHBvcnRzLkJOID0gQk47XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbmV4cG9ydHMucmxwID0gcmxwO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBldGhqc1V0aWwpO1xuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFB1YmxpYy1rZXkgY3J5cHRvZ3JhcGh5IChzZWNwMjU2azEpIGFuZCBhZGRyZXNzZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIYXNoIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEVDRFNBIHNpZ25hdHVyZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRnVuY3Rpb24gZm9yIGRlZmluaW5pbmcgcHJvcGVydGllcyBvbiBhbiBvYmplY3RcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKSk7XG4gICAgfVxuICAgIF91cGRhdGVXaG9sZVN0YXRlKCkge1xuICAgICAgICBjb25zdCBjaGlsZFN0YXRlcyA9IHRoaXMuX2NoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBhcHBseSBzaGFsbG93IG1lcmdlIG92ZXIgc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uY2hpbGRTdGF0ZXMpO1xuICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gTWVyZ2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW4gfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKS5mb3JFYWNoKChjaGlsZEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltjaGlsZEtleV07XG4gICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVGcm9tQ2hpbGQgPSAoY2hpbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdGF0ZVtjaGlsZEtleV0gPSBjaGlsZFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSh1cGRhdGVGcm9tQ2hpbGQpO1xuICAgICAgICB1cGRhdGVGcm9tQ2hpbGQoY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gQ29tcG9zZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaW5pdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0L2RlZmF1bHQgc3RhdGU6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBwdXRTdGF0ZVxuICAgIHB1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgcGFydGlhbFN0YXRlKSk7XG4gICAgICAgICAgICAvLyBpZiBub3Qgb2JqZWN0LCB1c2UgbmV3IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gcHJpdmF0ZVxuICAgIC8vXG4gICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gICAgX3B1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSBPYnNlcnZhYmxlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgdGhyb3VnaDJfMSA9IHJlcXVpcmUoXCJ0aHJvdWdoMlwiKTtcbmZ1bmN0aW9uIHN0b3JlVHJhbnNmb3JtU3RyZWFtKHN5bmNUcmFuc2Zvcm1Gbikge1xuICAgIHJldHVybiB0aHJvdWdoMl8xLm9iaigoc3RhdGUsIF9lbmNvZGluZywgY2IpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3luY1RyYW5zZm9ybUZuKHN0YXRlKTtcbiAgICAgICAgICAgIGNiKG51bGwsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSBzdG9yZVRyYW5zZm9ybVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbm1vZHVsZS5leHBvcnRzID0geyB1cmxBbHBoYWJldCB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBibCA9IHJlcXVpcmUoJ2JsJylcbnZhciBoZWFkZXJzID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuV3JpdGFibGVcbnZhciBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlBhc3NUaHJvdWdoXG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxudmFyIG92ZXJmbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgc2l6ZSAmPSA1MTFcbiAgcmV0dXJuIHNpemUgJiYgNTEyIC0gc2l6ZVxufVxuXG52YXIgZW1wdHlTdHJlYW0gPSBmdW5jdGlvbiAoc2VsZiwgb2Zmc2V0KSB7XG4gIHZhciBzID0gbmV3IFNvdXJjZShzZWxmLCBvZmZzZXQpXG4gIHMuZW5kKClcbiAgcmV0dXJuIHNcbn1cblxudmFyIG1peGluUGF4ID0gZnVuY3Rpb24gKGhlYWRlciwgcGF4KSB7XG4gIGlmIChwYXgucGF0aCkgaGVhZGVyLm5hbWUgPSBwYXgucGF0aFxuICBpZiAocGF4LmxpbmtwYXRoKSBoZWFkZXIubGlua25hbWUgPSBwYXgubGlua3BhdGhcbiAgaWYgKHBheC5zaXplKSBoZWFkZXIuc2l6ZSA9IHBhcnNlSW50KHBheC5zaXplLCAxMClcbiAgaGVhZGVyLnBheCA9IHBheFxuICByZXR1cm4gaGVhZGVyXG59XG5cbnZhciBTb3VyY2UgPSBmdW5jdGlvbiAoc2VsZiwgb2Zmc2V0KSB7XG4gIHRoaXMuX3BhcmVudCA9IHNlbGZcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcbiAgUGFzc1Rocm91Z2guY2FsbCh0aGlzLCB7IGF1dG9EZXN0cm95OiBmYWxzZSB9KVxufVxuXG51dGlsLmluaGVyaXRzKFNvdXJjZSwgUGFzc1Rocm91Z2gpXG5cblNvdXJjZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5fcGFyZW50LmRlc3Ryb3koZXJyKVxufVxuXG52YXIgRXh0cmFjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFeHRyYWN0KSkgcmV0dXJuIG5ldyBFeHRyYWN0KG9wdHMpXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIHRoaXMuX29mZnNldCA9IDBcbiAgdGhpcy5fYnVmZmVyID0gYmwoKVxuICB0aGlzLl9taXNzaW5nID0gMFxuICB0aGlzLl9wYXJ0aWFsID0gZmFsc2VcbiAgdGhpcy5fb25wYXJzZSA9IG5vb3BcbiAgdGhpcy5faGVhZGVyID0gbnVsbFxuICB0aGlzLl9zdHJlYW0gPSBudWxsXG4gIHRoaXMuX292ZXJmbG93ID0gbnVsbFxuICB0aGlzLl9jYiA9IG51bGxcbiAgdGhpcy5fbG9ja2VkID0gZmFsc2VcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2VcbiAgdGhpcy5fcGF4ID0gbnVsbFxuICB0aGlzLl9wYXhHbG9iYWwgPSBudWxsXG4gIHRoaXMuX2dudUxvbmdQYXRoID0gbnVsbFxuICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBudWxsXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBiID0gc2VsZi5fYnVmZmVyXG5cbiAgdmFyIG9uY29udGludWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fY29udGludWUoKVxuICB9XG5cbiAgdmFyIG9udW5sb2NrID0gZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX2xvY2tlZCA9IGZhbHNlXG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgaWYgKCFzZWxmLl9zdHJlYW0pIG9uY29udGludWUoKVxuICB9XG5cbiAgdmFyIG9uc3RyZWFtZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0cmVhbSA9IG51bGxcbiAgICB2YXIgZHJhaW4gPSBvdmVyZmxvdyhzZWxmLl9oZWFkZXIuc2l6ZSlcbiAgICBpZiAoZHJhaW4pIHNlbGYuX3BhcnNlKGRyYWluLCBvbmRyYWluKVxuICAgIGVsc2Ugc2VsZi5fcGFyc2UoNTEyLCBvbmhlYWRlcilcbiAgICBpZiAoIXNlbGYuX2xvY2tlZCkgb25jb250aW51ZSgpXG4gIH1cblxuICB2YXIgb25kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9idWZmZXIuY29uc3VtZShvdmVyZmxvdyhzZWxmLl9oZWFkZXIuc2l6ZSkpXG4gICAgc2VsZi5fcGFyc2UoNTEyLCBvbmhlYWRlcilcbiAgICBvbmNvbnRpbnVlKClcbiAgfVxuXG4gIHZhciBvbnBheGdsb2JhbGhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2l6ZSA9IHNlbGYuX2hlYWRlci5zaXplXG4gICAgc2VsZi5fcGF4R2xvYmFsID0gaGVhZGVycy5kZWNvZGVQYXgoYi5zbGljZSgwLCBzaXplKSlcbiAgICBiLmNvbnN1bWUoc2l6ZSlcbiAgICBvbnN0cmVhbWVuZCgpXG4gIH1cblxuICB2YXIgb25wYXhoZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSBzZWxmLl9oZWFkZXIuc2l6ZVxuICAgIHNlbGYuX3BheCA9IGhlYWRlcnMuZGVjb2RlUGF4KGIuc2xpY2UoMCwgc2l6ZSkpXG4gICAgaWYgKHNlbGYuX3BheEdsb2JhbCkgc2VsZi5fcGF4ID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZi5fcGF4R2xvYmFsLCBzZWxmLl9wYXgpXG4gICAgYi5jb25zdW1lKHNpemUpXG4gICAgb25zdHJlYW1lbmQoKVxuICB9XG5cbiAgdmFyIG9uZ251bG9uZ3BhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSBzZWxmLl9oZWFkZXIuc2l6ZVxuICAgIHRoaXMuX2dudUxvbmdQYXRoID0gaGVhZGVycy5kZWNvZGVMb25nUGF0aChiLnNsaWNlKDAsIHNpemUpLCBvcHRzLmZpbGVuYW1lRW5jb2RpbmcpXG4gICAgYi5jb25zdW1lKHNpemUpXG4gICAgb25zdHJlYW1lbmQoKVxuICB9XG5cbiAgdmFyIG9uZ251bG9uZ2xpbmtwYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gc2VsZi5faGVhZGVyLnNpemVcbiAgICB0aGlzLl9nbnVMb25nTGlua1BhdGggPSBoZWFkZXJzLmRlY29kZUxvbmdQYXRoKGIuc2xpY2UoMCwgc2l6ZSksIG9wdHMuZmlsZW5hbWVFbmNvZGluZylcbiAgICBiLmNvbnN1bWUoc2l6ZSlcbiAgICBvbnN0cmVhbWVuZCgpXG4gIH1cblxuICB2YXIgb25oZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldCA9IHNlbGYuX29mZnNldFxuICAgIHZhciBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gc2VsZi5faGVhZGVyID0gaGVhZGVycy5kZWNvZGUoYi5zbGljZSgwLCA1MTIpLCBvcHRzLmZpbGVuYW1lRW5jb2RpbmcsIG9wdHMuYWxsb3dVbmtub3duRm9ybWF0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG4gICAgYi5jb25zdW1lKDUxMilcblxuICAgIGlmICghaGVhZGVyKSB7XG4gICAgICBzZWxmLl9wYXJzZSg1MTIsIG9uaGVhZGVyKVxuICAgICAgb25jb250aW51ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGhlYWRlci50eXBlID09PSAnZ251LWxvbmctcGF0aCcpIHtcbiAgICAgIHNlbGYuX3BhcnNlKGhlYWRlci5zaXplLCBvbmdudWxvbmdwYXRoKVxuICAgICAgb25jb250aW51ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGhlYWRlci50eXBlID09PSAnZ251LWxvbmctbGluay1wYXRoJykge1xuICAgICAgc2VsZi5fcGFyc2UoaGVhZGVyLnNpemUsIG9uZ251bG9uZ2xpbmtwYXRoKVxuICAgICAgb25jb250aW51ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGhlYWRlci50eXBlID09PSAncGF4LWdsb2JhbC1oZWFkZXInKSB7XG4gICAgICBzZWxmLl9wYXJzZShoZWFkZXIuc2l6ZSwgb25wYXhnbG9iYWxoZWFkZXIpXG4gICAgICBvbmNvbnRpbnVlKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdwYXgtaGVhZGVyJykge1xuICAgICAgc2VsZi5fcGFyc2UoaGVhZGVyLnNpemUsIG9ucGF4aGVhZGVyKVxuICAgICAgb25jb250aW51ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZ251TG9uZ1BhdGgpIHtcbiAgICAgIGhlYWRlci5uYW1lID0gc2VsZi5fZ251TG9uZ1BhdGhcbiAgICAgIHNlbGYuX2dudUxvbmdQYXRoID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChzZWxmLl9nbnVMb25nTGlua1BhdGgpIHtcbiAgICAgIGhlYWRlci5saW5rbmFtZSA9IHNlbGYuX2dudUxvbmdMaW5rUGF0aFxuICAgICAgc2VsZi5fZ251TG9uZ0xpbmtQYXRoID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChzZWxmLl9wYXgpIHtcbiAgICAgIHNlbGYuX2hlYWRlciA9IGhlYWRlciA9IG1peGluUGF4KGhlYWRlciwgc2VsZi5fcGF4KVxuICAgICAgc2VsZi5fcGF4ID0gbnVsbFxuICAgIH1cblxuICAgIHNlbGYuX2xvY2tlZCA9IHRydWVcblxuICAgIGlmICghaGVhZGVyLnNpemUgfHwgaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICBzZWxmLl9wYXJzZSg1MTIsIG9uaGVhZGVyKVxuICAgICAgc2VsZi5lbWl0KCdlbnRyeScsIGhlYWRlciwgZW1wdHlTdHJlYW0oc2VsZiwgb2Zmc2V0KSwgb251bmxvY2spXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZWxmLl9zdHJlYW0gPSBuZXcgU291cmNlKHNlbGYsIG9mZnNldClcblxuICAgIHNlbGYuZW1pdCgnZW50cnknLCBoZWFkZXIsIHNlbGYuX3N0cmVhbSwgb251bmxvY2spXG4gICAgc2VsZi5fcGFyc2UoaGVhZGVyLnNpemUsIG9uc3RyZWFtZW5kKVxuICAgIG9uY29udGludWUoKVxuICB9XG5cbiAgdGhpcy5fb25oZWFkZXIgPSBvbmhlYWRlclxuICB0aGlzLl9wYXJzZSg1MTIsIG9uaGVhZGVyKVxufVxuXG51dGlsLmluaGVyaXRzKEV4dHJhY3QsIFdyaXRhYmxlKVxuXG5FeHRyYWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxuICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9zdHJlYW0uZW1pdCgnY2xvc2UnKVxufVxuXG5FeHRyYWN0LnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAoc2l6ZSwgb25wYXJzZSkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fb2Zmc2V0ICs9IHNpemVcbiAgdGhpcy5fbWlzc2luZyA9IHNpemVcbiAgaWYgKG9ucGFyc2UgPT09IHRoaXMuX29uaGVhZGVyKSB0aGlzLl9wYXJ0aWFsID0gZmFsc2VcbiAgdGhpcy5fb25wYXJzZSA9IG9ucGFyc2Vcbn1cblxuRXh0cmFjdC5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGNiID0gdGhpcy5fY2JcbiAgdGhpcy5fY2IgPSBub29wXG4gIGlmICh0aGlzLl9vdmVyZmxvdykgdGhpcy5fd3JpdGUodGhpcy5fb3ZlcmZsb3csIHVuZGVmaW5lZCwgY2IpXG4gIGVsc2UgY2IoKVxufVxuXG5FeHRyYWN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBjYikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cblxuICB2YXIgcyA9IHRoaXMuX3N0cmVhbVxuICB2YXIgYiA9IHRoaXMuX2J1ZmZlclxuICB2YXIgbWlzc2luZyA9IHRoaXMuX21pc3NpbmdcbiAgaWYgKGRhdGEubGVuZ3RoKSB0aGlzLl9wYXJ0aWFsID0gdHJ1ZVxuXG4gIC8vIHdlIGRvIG5vdCByZWFjaCBlbmQtb2YtY2h1bmsgbm93LiBqdXN0IGZvcndhcmQgaXRcblxuICBpZiAoZGF0YS5sZW5ndGggPCBtaXNzaW5nKSB7XG4gICAgdGhpcy5fbWlzc2luZyAtPSBkYXRhLmxlbmd0aFxuICAgIHRoaXMuX292ZXJmbG93ID0gbnVsbFxuICAgIGlmIChzKSByZXR1cm4gcy53cml0ZShkYXRhLCBjYilcbiAgICBiLmFwcGVuZChkYXRhKVxuICAgIHJldHVybiBjYigpXG4gIH1cblxuICAvLyBlbmQtb2YtY2h1bmsuIHRoZSBwYXJzZXIgc2hvdWxkIGNhbGwgY2IuXG5cbiAgdGhpcy5fY2IgPSBjYlxuICB0aGlzLl9taXNzaW5nID0gMFxuXG4gIHZhciBvdmVyZmxvdyA9IG51bGxcbiAgaWYgKGRhdGEubGVuZ3RoID4gbWlzc2luZykge1xuICAgIG92ZXJmbG93ID0gZGF0YS5zbGljZShtaXNzaW5nKVxuICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIG1pc3NpbmcpXG4gIH1cblxuICBpZiAocykgcy5lbmQoZGF0YSlcbiAgZWxzZSBiLmFwcGVuZChkYXRhKVxuXG4gIHRoaXMuX292ZXJmbG93ID0gb3ZlcmZsb3dcbiAgdGhpcy5fb25wYXJzZSgpXG59XG5cbkV4dHJhY3QucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5fcGFydGlhbCkgcmV0dXJuIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKSlcbiAgY2IoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV4dHJhY3RcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdmcy1jb25zdGFudHMnKVxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGFsbG9jID0gQnVmZmVyLmFsbG9jXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5Xcml0YWJsZVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcblxudmFyIGhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuXG52YXIgRE1PREUgPSBwYXJzZUludCgnNzU1JywgOClcbnZhciBGTU9ERSA9IHBhcnNlSW50KCc2NDQnLCA4KVxuXG52YXIgRU5EX09GX1RBUiA9IGFsbG9jKDEwMjQpXG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxudmFyIG92ZXJmbG93ID0gZnVuY3Rpb24gKHNlbGYsIHNpemUpIHtcbiAgc2l6ZSAmPSA1MTFcbiAgaWYgKHNpemUpIHNlbGYucHVzaChFTkRfT0ZfVEFSLnNsaWNlKDAsIDUxMiAtIHNpemUpKVxufVxuXG5mdW5jdGlvbiBtb2RlVG9UeXBlIChtb2RlKSB7XG4gIHN3aXRjaCAobW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpIHtcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQkxLOiByZXR1cm4gJ2Jsb2NrLWRldmljZSdcbiAgICBjYXNlIGNvbnN0YW50cy5TX0lGQ0hSOiByZXR1cm4gJ2NoYXJhY3Rlci1kZXZpY2UnXG4gICAgY2FzZSBjb25zdGFudHMuU19JRkRJUjogcmV0dXJuICdkaXJlY3RvcnknXG4gICAgY2FzZSBjb25zdGFudHMuU19JRklGTzogcmV0dXJuICdmaWZvJ1xuICAgIGNhc2UgY29uc3RhbnRzLlNfSUZMTks6IHJldHVybiAnc3ltbGluaydcbiAgfVxuXG4gIHJldHVybiAnZmlsZSdcbn1cblxudmFyIFNpbmsgPSBmdW5jdGlvbiAodG8pIHtcbiAgV3JpdGFibGUuY2FsbCh0aGlzKVxuICB0aGlzLndyaXR0ZW4gPSAwXG4gIHRoaXMuX3RvID0gdG9cbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoU2luaywgV3JpdGFibGUpXG5cblNpbmsucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIHRoaXMud3JpdHRlbiArPSBkYXRhLmxlbmd0aFxuICBpZiAodGhpcy5fdG8ucHVzaChkYXRhKSkgcmV0dXJuIGNiKClcbiAgdGhpcy5fdG8uX2RyYWluID0gY2Jcbn1cblxuU2luay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbnZhciBMaW5rU2luayA9IGZ1bmN0aW9uICgpIHtcbiAgV3JpdGFibGUuY2FsbCh0aGlzKVxuICB0aGlzLmxpbmtuYW1lID0gJydcbiAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCd1dGYtOCcpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKExpbmtTaW5rLCBXcml0YWJsZSlcblxuTGlua1NpbmsucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIHRoaXMubGlua25hbWUgKz0gdGhpcy5fZGVjb2Rlci53cml0ZShkYXRhKVxuICBjYigpXG59XG5cbkxpbmtTaW5rLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxudmFyIFZvaWQgPSBmdW5jdGlvbiAoKSB7XG4gIFdyaXRhYmxlLmNhbGwodGhpcylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoVm9pZCwgV3JpdGFibGUpXG5cblZvaWQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignTm8gYm9keSBhbGxvd2VkIGZvciB0aGlzIGVudHJ5JykpXG59XG5cblZvaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG52YXIgUGFjayA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYWNrKSkgcmV0dXJuIG5ldyBQYWNrKG9wdHMpXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLl9kcmFpbiA9IG5vb3BcbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2VcbiAgdGhpcy5fZmluYWxpemluZyA9IGZhbHNlXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMuX3N0cmVhbSA9IG51bGxcbn1cblxuaW5oZXJpdHMoUGFjaywgUmVhZGFibGUpXG5cblBhY2sucHJvdG90eXBlLmVudHJ5ID0gZnVuY3Rpb24gKGhlYWRlciwgYnVmZmVyLCBjYWxsYmFjaykge1xuICBpZiAodGhpcy5fc3RyZWFtKSB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgcGlwaW5nIGFuIGVudHJ5JylcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCB8fCB0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBidWZmZXJcbiAgICBidWZmZXIgPSBudWxsXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3BcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIWhlYWRlci5zaXplIHx8IGhlYWRlci50eXBlID09PSAnc3ltbGluaycpIGhlYWRlci5zaXplID0gMFxuICBpZiAoIWhlYWRlci50eXBlKSBoZWFkZXIudHlwZSA9IG1vZGVUb1R5cGUoaGVhZGVyLm1vZGUpXG4gIGlmICghaGVhZGVyLm1vZGUpIGhlYWRlci5tb2RlID0gaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknID8gRE1PREUgOiBGTU9ERVxuICBpZiAoIWhlYWRlci51aWQpIGhlYWRlci51aWQgPSAwXG4gIGlmICghaGVhZGVyLmdpZCkgaGVhZGVyLmdpZCA9IDBcbiAgaWYgKCFoZWFkZXIubXRpbWUpIGhlYWRlci5tdGltZSA9IG5ldyBEYXRlKClcblxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgaGVhZGVyLnNpemUgPSBidWZmZXIubGVuZ3RoXG4gICAgdGhpcy5fZW5jb2RlKGhlYWRlcilcbiAgICB2YXIgb2sgPSB0aGlzLnB1c2goYnVmZmVyKVxuICAgIG92ZXJmbG93KHNlbGYsIGhlYWRlci5zaXplKVxuICAgIGlmIChvaykgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbiAgICBlbHNlIHRoaXMuX2RyYWluID0gY2FsbGJhY2tcbiAgICByZXR1cm4gbmV3IFZvaWQoKVxuICB9XG5cbiAgaWYgKGhlYWRlci50eXBlID09PSAnc3ltbGluaycgJiYgIWhlYWRlci5saW5rbmFtZSkge1xuICAgIHZhciBsaW5rU2luayA9IG5ldyBMaW5rU2luaygpXG4gICAgZW9zKGxpbmtTaW5rLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7IC8vIHN0cmVhbSB3YXMgY2xvc2VkXG4gICAgICAgIHNlbGYuZGVzdHJveSgpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGhlYWRlci5saW5rbmFtZSA9IGxpbmtTaW5rLmxpbmtuYW1lXG4gICAgICBzZWxmLl9lbmNvZGUoaGVhZGVyKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG5cbiAgICByZXR1cm4gbGlua1NpbmtcbiAgfVxuXG4gIHRoaXMuX2VuY29kZShoZWFkZXIpXG5cbiAgaWYgKGhlYWRlci50eXBlICE9PSAnZmlsZScgJiYgaGVhZGVyLnR5cGUgIT09ICdjb250aWd1b3VzLWZpbGUnKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbiAgICByZXR1cm4gbmV3IFZvaWQoKVxuICB9XG5cbiAgdmFyIHNpbmsgPSBuZXcgU2luayh0aGlzKVxuXG4gIHRoaXMuX3N0cmVhbSA9IHNpbmtcblxuICBlb3Moc2luaywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX3N0cmVhbSA9IG51bGxcblxuICAgIGlmIChlcnIpIHsgLy8gc3RyZWFtIHdhcyBjbG9zZWRcbiAgICAgIHNlbGYuZGVzdHJveSgpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIGlmIChzaW5rLndyaXR0ZW4gIT09IGhlYWRlci5zaXplKSB7IC8vIGNvcnJ1cHRpbmcgdGFyXG4gICAgICBzZWxmLmRlc3Ryb3koKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignc2l6ZSBtaXNtYXRjaCcpKVxuICAgIH1cblxuICAgIG92ZXJmbG93KHNlbGYsIGhlYWRlci5zaXplKVxuICAgIGlmIChzZWxmLl9maW5hbGl6aW5nKSBzZWxmLmZpbmFsaXplKClcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgcmV0dXJuIHNpbmtcbn1cblxuUGFjay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9zdHJlYW0pIHtcbiAgICB0aGlzLl9maW5hbGl6aW5nID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgcmV0dXJuXG4gIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcbiAgdGhpcy5wdXNoKEVORF9PRl9UQVIpXG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5QYWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxuICBpZiAodGhpcy5fc3RyZWFtICYmIHRoaXMuX3N0cmVhbS5kZXN0cm95KSB0aGlzLl9zdHJlYW0uZGVzdHJveSgpXG59XG5cblBhY2sucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gIGlmICghaGVhZGVyLnBheCkge1xuICAgIHZhciBidWYgPSBoZWFkZXJzLmVuY29kZShoZWFkZXIpXG4gICAgaWYgKGJ1Zikge1xuICAgICAgdGhpcy5wdXNoKGJ1ZilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICB0aGlzLl9lbmNvZGVQYXgoaGVhZGVyKVxufVxuXG5QYWNrLnByb3RvdHlwZS5fZW5jb2RlUGF4ID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICB2YXIgcGF4SGVhZGVyID0gaGVhZGVycy5lbmNvZGVQYXgoe1xuICAgIG5hbWU6IGhlYWRlci5uYW1lLFxuICAgIGxpbmtuYW1lOiBoZWFkZXIubGlua25hbWUsXG4gICAgcGF4OiBoZWFkZXIucGF4XG4gIH0pXG5cbiAgdmFyIG5ld0hlYWRlciA9IHtcbiAgICBuYW1lOiAnUGF4SGVhZGVyJyxcbiAgICBtb2RlOiBoZWFkZXIubW9kZSxcbiAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgIHNpemU6IHBheEhlYWRlci5sZW5ndGgsXG4gICAgbXRpbWU6IGhlYWRlci5tdGltZSxcbiAgICB0eXBlOiAncGF4LWhlYWRlcicsXG4gICAgbGlua25hbWU6IGhlYWRlci5saW5rbmFtZSAmJiAnUGF4SGVhZGVyJyxcbiAgICB1bmFtZTogaGVhZGVyLnVuYW1lLFxuICAgIGduYW1lOiBoZWFkZXIuZ25hbWUsXG4gICAgZGV2bWFqb3I6IGhlYWRlci5kZXZtYWpvcixcbiAgICBkZXZtaW5vcjogaGVhZGVyLmRldm1pbm9yXG4gIH1cblxuICB0aGlzLnB1c2goaGVhZGVycy5lbmNvZGUobmV3SGVhZGVyKSlcbiAgdGhpcy5wdXNoKHBheEhlYWRlcilcbiAgb3ZlcmZsb3codGhpcywgcGF4SGVhZGVyLmxlbmd0aClcblxuICBuZXdIZWFkZXIuc2l6ZSA9IGhlYWRlci5zaXplXG4gIG5ld0hlYWRlci50eXBlID0gaGVhZGVyLnR5cGVcbiAgdGhpcy5wdXNoKGhlYWRlcnMuZW5jb2RlKG5ld0hlYWRlcikpXG59XG5cblBhY2sucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGRyYWluID0gdGhpcy5fZHJhaW5cbiAgdGhpcy5fZHJhaW4gPSBub29wXG4gIGRyYWluKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWNrXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICghYnVmIHx8IGJ1Zi5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGJ1ZlswXSA9PT0gMHg3OCAmJiAoYnVmWzFdID09PSAxIHx8IGJ1ZlsxXSA9PT0gMHg5YyB8fCBidWZbMV0gPT09IDB4ZGEpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBCdWZmZXIvVWludDhBcnJheSBpcyBhIEdaSVAgZmlsZVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgaWYgKCFidWYgfHwgYnVmLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBidWZbMF0gPT09IDMxICYmIGJ1ZlsxXSA9PT0gMTM5ICYmIGJ1ZlsyXSA9PT0gODtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwidmFyIHB1bXAgPSByZXF1aXJlKCdwdW1wJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBEdXBsZXhpZnkgPSByZXF1aXJlKCdkdXBsZXhpZnknKVxuXG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgaWYgKCFhcmdzLmxlbmd0aCkgcmV0dXJuIFtdXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpXG59XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBQdW1waWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmVhbXMgPSB0b0FycmF5KGFyZ3VtZW50cylcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHVtcGlmeSkpIHJldHVybiBuZXcgUHVtcGlmeShzdHJlYW1zKVxuICAgIER1cGxleGlmeS5jYWxsKHRoaXMsIG51bGwsIG51bGwsIG9wdHMpXG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoKSB0aGlzLnNldFBpcGVsaW5lKHN0cmVhbXMpXG4gIH1cblxuICBpbmhlcml0cyhQdW1waWZ5LCBEdXBsZXhpZnkpXG5cbiAgUHVtcGlmeS5wcm90b3R5cGUuc2V0UGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyZWFtcyA9IHRvQXJyYXkoYXJndW1lbnRzKVxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBlbmRlZCA9IGZhbHNlXG4gICAgdmFyIHcgPSBzdHJlYW1zWzBdXG4gICAgdmFyIHIgPSBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoLTFdXG5cbiAgICByID0gci5yZWFkYWJsZSA/IHIgOiBudWxsXG4gICAgdyA9IHcud3JpdGFibGUgPyB3IDogbnVsbFxuXG4gICAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbXNbMF0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbSB3YXMgZGVzdHJveWVkJykpXG4gICAgfVxuXG4gICAgdGhpcy5vbignY2xvc2UnLCBvbmNsb3NlKVxuICAgIHRoaXMub24oJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFlbmRlZCkgc2VsZi5jb3JrKClcbiAgICB9KVxuXG4gICAgcHVtcChzdHJlYW1zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmRlc3Ryb3koZXJyKVxuICAgICAgZW5kZWQgPSB0cnVlXG4gICAgICBzZWxmLnVuY29yaygpXG4gICAgfSlcblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIG9uY2xvc2UoKVxuICAgIHRoaXMuc2V0V3JpdGFibGUodylcbiAgICB0aGlzLnNldFJlYWRhYmxlKHIpXG4gIH1cblxuICByZXR1cm4gUHVtcGlmeVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZSh7ZGVzdHJveTpmYWxzZX0pXG5tb2R1bGUuZXhwb3J0cy5vYmogPSBkZWZpbmUoe2Rlc3Ryb3k6ZmFsc2UsIG9iamVjdE1vZGU6dHJ1ZSwgaGlnaFdhdGVyTWFyazoxNn0pXG4iLCJ2YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciB0aHJvdWdoID0gcmVxdWlyZSgndGhyb3VnaDInKVxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpXG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fVxuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiAhQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJ1xufVxuXG52YXIgcGVlayA9IGZ1bmN0aW9uKG9wdHMsIG9ucGVlaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdudW1iZXInKSBvcHRzID0ge21heEJ1ZmZlcjpvcHRzfVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBwZWVrKG51bGwsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIG1heEJ1ZmZlciA9IHR5cGVvZiBvcHRzLm1heEJ1ZmZlciA9PT0gJ251bWJlcicgPyBvcHRzLm1heEJ1ZmZlciA6IDY1NTM1XG4gIHZhciBzdHJpY3QgPSBvcHRzLnN0cmljdFxuICB2YXIgbmV3bGluZSA9IG9wdHMubmV3bGluZSAhPT0gZmFsc2VcblxuICB2YXIgYnVmZmVyID0gW11cbiAgdmFyIGJ1ZmZlclNpemUgPSAwXG4gIHZhciBkdXAgPSBkdXBsZXhpZnkub2JqKClcblxuICB2YXIgcGVla2VyID0gdGhyb3VnaC5vYmooe2hpZ2hXYXRlck1hcms6MX0sIGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHJldHVybiByZWFkeShkYXRhLCBudWxsLCBjYilcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IGJ1ZmZlckZyb20oZGF0YSlcblxuICAgIGlmIChuZXdsaW5lKSB7XG4gICAgICB2YXIgbmwgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGRhdGEsIDEwKVxuICAgICAgaWYgKG5sID4gMCAmJiBkYXRhW25sLTFdID09PSAxMykgbmwtLVxuXG4gICAgICBpZiAobmwgPiAtMSkge1xuICAgICAgICBidWZmZXIucHVzaChkYXRhLnNsaWNlKDAsIG5sKSlcbiAgICAgICAgcmV0dXJuIHJlYWR5KEJ1ZmZlci5jb25jYXQoYnVmZmVyKSwgZGF0YS5zbGljZShubCksIGNiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgYnVmZmVyU2l6ZSArPSBkYXRhLmxlbmd0aFxuXG4gICAgaWYgKGJ1ZmZlclNpemUgPCBtYXhCdWZmZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHN0cmljdCkgcmV0dXJuIGNiKG5ldyBFcnJvcignTm8gbmV3bGluZSBmb3VuZCcpKVxuICAgIHJlYWR5KEJ1ZmZlci5jb25jYXQoYnVmZmVyKSwgbnVsbCwgY2IpXG4gIH0pXG5cbiAgdmFyIG9ucHJlZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0cmljdCkgcmV0dXJuIGR1cC5kZXN0cm95KG5ldyBFcnJvcignTm8gbmV3bGluZSBmb3VuZCcpKVxuICAgIGR1cC5jb3JrKClcbiAgICByZWFkeShCdWZmZXIuY29uY2F0KGJ1ZmZlciksIG51bGwsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGR1cC5kZXN0cm95KGVycilcbiAgICAgIGR1cC51bmNvcmsoKVxuICAgIH0pXG4gIH1cblxuICB2YXIgcmVhZHkgPSBmdW5jdGlvbihkYXRhLCBvdmVyZmxvdywgY2IpIHtcbiAgICBkdXAucmVtb3ZlTGlzdGVuZXIoJ3ByZWVuZCcsIG9ucHJlZW5kKVxuICAgIG9ucGVlayhkYXRhLCBmdW5jdGlvbihlcnIsIHBhcnNlcikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgICAgZHVwLnNldFdyaXRhYmxlKHBhcnNlcilcbiAgICAgIGR1cC5zZXRSZWFkYWJsZShwYXJzZXIpXG5cbiAgICAgIGlmIChkYXRhKSBwYXJzZXIud3JpdGUoZGF0YSlcbiAgICAgIGlmIChvdmVyZmxvdykgcGFyc2VyLndyaXRlKG92ZXJmbG93KVxuXG4gICAgICBvdmVyZmxvdyA9IGJ1ZmZlciA9IHBlZWtlciA9IG51bGwgLy8gZnJlZSB0aGUgZGF0YVxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBkdXAub24oJ3ByZWVuZCcsIG9ucHJlZW5kKVxuICBkdXAuc2V0V3JpdGFibGUocGVla2VyKVxuXG4gIHJldHVybiBkdXBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZWVrXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9ICgxNiAqIDEwMjQpO1xuXG5iaW5kaW5nLlpfTUlOX01FTUxFVkVMID0gMTtcbmJpbmRpbmcuWl9NQVhfTUVNTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTUVNTEVWRUwgPSA4O1xuXG5iaW5kaW5nLlpfTUlOX0xFVkVMID0gLTE7XG5iaW5kaW5nLlpfTUFYX0xFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX0xFVkVMID0gYmluZGluZy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG5cbi8vIGV4cG9zZSBhbGwgdGhlIHpsaWIgY29uc3RhbnRzXG5PYmplY3Qua2V5cyhiaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgaWYgKGsubWF0Y2goL15aLykpIGV4cG9ydHNba10gPSBiaW5kaW5nW2tdO1xufSk7XG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG5leHBvcnRzLmNvZGVzID0ge1xuICBaX09LOiBiaW5kaW5nLlpfT0ssXG4gIFpfU1RSRUFNX0VORDogYmluZGluZy5aX1NUUkVBTV9FTkQsXG4gIFpfTkVFRF9ESUNUOiBiaW5kaW5nLlpfTkVFRF9ESUNULFxuICBaX0VSUk5POiBiaW5kaW5nLlpfRVJSTk8sXG4gIFpfU1RSRUFNX0VSUk9SOiBiaW5kaW5nLlpfU1RSRUFNX0VSUk9SLFxuICBaX0RBVEFfRVJST1I6IGJpbmRpbmcuWl9EQVRBX0VSUk9SLFxuICBaX01FTV9FUlJPUjogYmluZGluZy5aX01FTV9FUlJPUixcbiAgWl9CVUZfRVJST1I6IGJpbmRpbmcuWl9CVUZfRVJST1IsXG4gIFpfVkVSU0lPTl9FUlJPUjogYmluZGluZy5aX1ZFUlNJT05fRVJST1Jcbn07XG5cbk9iamVjdC5rZXlzKGV4cG9ydHMuY29kZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBleHBvcnRzLmNvZGVzW2V4cG9ydHMuY29kZXNba11dID0gaztcbn0pO1xuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXc7XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVEZWZsYXRlUmF3ID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHdW56aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVVbnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcy5cbi8vIGNvbXByZXNzL2RlY29tcHJlc3MgYSBzdHJpbmcgb3IgYnVmZmVyIGluIG9uZSBzdGVwLlxuZXhwb3J0cy5kZWZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3ppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy51bnppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgVW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy51bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICBjYWxsYmFjayhudWxsLCBidWYpO1xuICAgIGVuZ2luZS5jbG9zZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIHZhciBmbHVzaEZsYWcgPSBiaW5kaW5nLlpfRklOSVNIO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG5cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuZnVuY3Rpb24gR3ppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHemlwKSkgcmV0dXJuIG5ldyBHemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HWklQKTtcbn1cblxuZnVuY3Rpb24gR3VuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd1bnppcCkpIHJldHVybiBuZXcgR3VuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HVU5aSVApO1xufVxuXG5cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGVSYXcpKSByZXR1cm4gbmV3IERlZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEVSQVcpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGVSYXcpKSByZXR1cm4gbmV3IEluZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEVSQVcpO1xufVxuXG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmZ1bmN0aW9uIFVuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuemlwKSkgcmV0dXJuIG5ldyBVbnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuVU5aSVApO1xufVxuXG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5cbmZ1bmN0aW9uIFpsaWIob3B0cywgbW9kZSkge1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoKSB7XG4gICAgaWYgKG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9OT19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfU1lOQ19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRklOSVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9CTE9DSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZmx1c2hGbGFnID0gb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fFxuICAgICAgICBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8XG4gICAgICAgIG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8XG4gICAgICAgIG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fFxuICAgICAgICBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2JpbmRpbmcgPSBuZXcgYmluZGluZy5abGliKG1vZGUpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5faGFkRXJyb3IgPSBmYWxzZTtcbiAgdGhpcy5fYmluZGluZy5vbmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgZXJybm8pIHtcbiAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICBzZWxmLl9iaW5kaW5nID0gbnVsbDtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5fYmluZGluZy5pbml0KG9wdHMud2luZG93Qml0cyB8fCBleHBvcnRzLlpfREVGQVVMVF9XSU5ET1dCSVRTLFxuICAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLFxuICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLmRpY3Rpb25hcnkpO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcbn1cblxudXRpbC5pbmhlcml0cyhabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgIGxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgc3RyYXRlZ3kpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLl9zdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaChiaW5kaW5nLlpfU1lOQ19GTFVTSCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9iaW5kaW5nLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaW5kaW5nLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0obmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwgKGtpbmQgPT09IHZvaWQgMCAmJiAhY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBraW5kO1xuICAgIGtpbmQgPSBiaW5kaW5nLlpfRlVMTF9GTFVTSDtcbiAgfVxuXG4gIGlmICh3cy5lbmRlZCkge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUobmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9iaW5kaW5nLmNsb3NlKCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5abGliLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoIWNodW5rID09PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KVxuICAgIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG4gIGVsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBmbHVzaEZsYWcsIGNiKSB7XG4gIHZhciBhdmFpbEluQmVmb3JlID0gY2h1bmsgJiYgY2h1bmsubGVuZ3RoO1xuICB2YXIgYXZhaWxPdXRCZWZvcmUgPSB0aGlzLl9jaHVua1NpemUgLSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBpbk9mZiA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBhc3luYyA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgbnJlYWQgPSAwO1xuXG4gICAgdmFyIGVycm9yO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXIpIHtcbiAgICAgIGVycm9yID0gZXI7XG4gICAgfSk7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fYmluZGluZy53cml0ZVN5bmMoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgICBpZiAodGhpcy5faGFkRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgdmFyIHJlcSA9IHRoaXMuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG5cbiAgcmVxLmJ1ZmZlciA9IGNodW5rO1xuICByZXEuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBmdW5jdGlvbiBjYWxsYmFjayhhdmFpbEluQWZ0ZXIsIGF2YWlsT3V0QWZ0ZXIpIHtcbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG4gICAgICAvLyBzZXJ2ZSBzb21lIG91dHB1dCB0byB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgc2VsZi5wdXNoKG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2gob3V0KTtcbiAgICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IG5ldyBCdWZmZXIoc2VsZi5fY2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IGRvbmUuICBOZWVkIHRvIHJlcHJvY2Vzcy5cbiAgICAgIC8vIEFsc28sIHVwZGF0ZSB0aGUgYXZhaWxJbkJlZm9yZSB0byB0aGUgYXZhaWxJbkFmdGVyIHZhbHVlLFxuICAgICAgLy8gc28gdGhhdCBpZiB3ZSBoYXZlIHRvIGhpdCBpdCBhIHRoaXJkIChmb3VydGgsIGV0Yy4pIHRpbWUsXG4gICAgICAvLyBpdCdsbCBoYXZlIHRoZSBjb3JyZWN0IGJ5dGUgY291bnRzLlxuICAgICAgaW5PZmYgKz0gKGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXIpO1xuICAgICAgYXZhaWxJbkJlZm9yZSA9IGF2YWlsSW5BZnRlcjtcblxuICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBuZXdSZXEgPSBzZWxmLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2h1bmtTaXplKTtcbiAgICAgIG5ld1JlcS5jYWxsYmFjayA9IGNhbGxiYWNrOyAvLyB0aGlzIHNhbWUgZnVuY3Rpb25cbiAgICAgIG5ld1JlcS5idWZmZXIgPSBjaHVuaztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFzeW5jKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PYmplY3RNdWx0aXBsZXggPSB2b2lkIDA7XG5jb25zdCByZWFkYWJsZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIik7XG5jb25zdCBlbmRfb2Zfc3RyZWFtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVuZC1vZi1zdHJlYW1cIikpO1xuY29uc3Qgb25jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJvbmNlXCIpKTtcbmNvbnN0IFN1YnN0cmVhbV8xID0gcmVxdWlyZShcIi4vU3Vic3RyZWFtXCIpO1xuY29uc3QgSUdOT1JFX1NVQlNUUkVBTSA9IFN5bWJvbCgnSUdOT1JFX1NVQlNUUkVBTScpO1xuY2xhc3MgT2JqZWN0TXVsdGlwbGV4IGV4dGVuZHMgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBvYmplY3RNb2RlOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5fc3Vic3RyZWFtcyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVTdHJlYW0obmFtZSkge1xuICAgICAgICAvLyBndWFyZCBzdHJlYW0gYWdhaW5zdCBkZXN0cm95ZWQgYWxyZWFkeVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gcGFyZW50IHN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGRlc3Ryb3llZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGd1YXJkIHN0cmVhbSBhZ2FpbnN0IGVuZGVkIGFscmVhZHlcbiAgICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3RNdWx0aXBsZXggLSBwYXJlbnQgc3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZW5kZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSBuYW1lXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHN1YnN0cmVhbVxuICAgICAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtXzEuU3Vic3RyZWFtKHsgcGFyZW50OiB0aGlzLCBuYW1lIH0pO1xuICAgICAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtO1xuICAgICAgICAvLyBsaXN0ZW4gZm9yIHBhcmVudCBzdHJlYW0gdG8gZW5kXG4gICAgICAgIGFueVN0cmVhbUVuZCh0aGlzLCAoX2Vycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic3RyZWFtLmRlc3Ryb3koX2Vycm9yIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3Vic3RyZWFtO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgc3RyZWFtcyAoZG9udCBkaXNwbGF5IG9ycGhhbmVkIGRhdGEgd2FybmluZylcbiAgICBpZ25vcmVTdHJlYW0obmFtZSkge1xuICAgICAgICAvLyB2YWxpZGF0ZSBuYW1lXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0XG4gICAgICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNO1xuICAgIH1cbiAgICBfcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGF0YSB9ID0gY2h1bms7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBtYWxmb3JtZWQgY2h1bmsgd2l0aG91dCBuYW1lIFwiJHtjaHVua31cImApO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtXG4gICAgICAgIGNvbnN0IHN1YnN0cmVhbSA9IHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgICAgIGlmICghc3Vic3RyZWFtKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG9ycGhhbmVkIGRhdGEgZm9yIHN0cmVhbSBcIiR7bmFtZX1cImApO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVzaCBkYXRhIGludG8gc3Vic3RyZWFtXG4gICAgICAgIGlmIChzdWJzdHJlYW0gIT09IElHTk9SRV9TVUJTVFJFQU0pIHtcbiAgICAgICAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmV4cG9ydHMuT2JqZWN0TXVsdGlwbGV4ID0gT2JqZWN0TXVsdGlwbGV4O1xuLy8gdXRpbFxuZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7XG4gICAgY29uc3QgY2IgPSBvbmNlXzEuZGVmYXVsdChfY2IpO1xuICAgIGVuZF9vZl9zdHJlYW1fMS5kZWZhdWx0KHN0cmVhbSwgeyByZWFkYWJsZTogZmFsc2UgfSwgY2IpO1xuICAgIGVuZF9vZl9zdHJlYW1fMS5kZWZhdWx0KHN0cmVhbSwgeyB3cml0YWJsZTogZmFsc2UgfSwgY2IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0TXVsdGlwbGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TVFJFQU1fTkFNRVMgPSB2b2lkIDA7XG4vLyBJIGhhdmUgbm8gaWRlYSB3aHkgdGhpcyBydWxlIGZpcmVzIGJ1dCB5b3UgZG8geW91IGVzbGludFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIFNUUkVBTV9OQU1FUztcbihmdW5jdGlvbiAoU1RSRUFNX05BTUVTKSB7XG4gICAgU1RSRUFNX05BTUVTW1wiSlNPTl9SUENcIl0gPSBcImpzb25ScGNcIjtcbiAgICBTVFJFQU1fTkFNRVNbXCJDT01NQU5EXCJdID0gXCJjb21tYW5kXCI7XG59KShTVFJFQU1fTkFNRVMgPSBleHBvcnRzLlNUUkVBTV9OQU1FUyB8fCAoZXhwb3J0cy5TVFJFQU1fTkFNRVMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWFkYWJsZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIik7XG4vKipcbiAqIFRha2VzIGEgSnNvblJwY0VuZ2luZSBhbmQgcmV0dXJucyBhIER1cGxleCBzdHJlYW0gd3JhcHBpbmcgaXQuXG4gKlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRzLmVuZ2luZSAtIFRoZSBKc29uUnBjRW5naW5lIHRvIHdyYXAgaW4gYSBzdHJlYW0uXG4gKiBAcmV0dXJucyBUaGUgc3RyZWFtIHdyYXBwaW5nIHRoZSBlbmdpbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbShvcHRzKSB7XG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmVuZ2luZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5naW5lIHBhcmFtZXRlciEnKTtcbiAgICB9XG4gICAgY29uc3QgeyBlbmdpbmUgfSA9IG9wdHM7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCh7IG9iamVjdE1vZGU6IHRydWUsIHJlYWQsIHdyaXRlIH0pO1xuICAgIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICAgIGlmIChlbmdpbmUub24pIHtcbiAgICAgICAgZW5naW5lLm9uKCdub3RpZmljYXRpb24nLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlKHJlcSwgX2VuY29kaW5nLCBjYikge1xuICAgICAgICBlbmdpbmUuaGFuZGxlKHJlcSwgKF9lcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLnB1c2gocmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlRW5naW5lU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlRW5naW5lU3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3QgcmVhZGFibGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgSnNvblJwY0VuZ2luZSBtaWRkbGV3YXJlIHdpdGggYW4gYXNzb2NpYXRlZCBEdXBsZXggc3RyZWFtIGFuZFxuICogRXZlbnRFbWl0dGVyLiBUaGUgbWlkZGxld2FyZSwgYW5kIGJ5IGV4dGVuc2lvbiBzdHJlYW0sIGFzc3VtZSB0aGF0IG1pZGRsZXdhcmVcbiAqIHBhcmFtZXRlcnMgYXJlIHByb3Blcmx5IGZvcm1hdHRlZC4gTm8gcnVudGltZSB0eXBlIGNoZWNraW5nIG9yIHZhbGlkYXRpb24gaXNcbiAqIHBlcmZvcm1lZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZXZlbnQgZW1pdHRlciwgbWlkZGxld2FyZSwgYW5kIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpIHtcbiAgICBjb25zdCBpZE1hcCA9IHt9O1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyByZWFkYWJsZV9zdHJlYW1fMS5EdXBsZXgoe1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICByZWFkOiByZWFkTm9vcCxcbiAgICAgICAgd3JpdGU6IHByb2Nlc3NNZXNzYWdlLFxuICAgIH0pO1xuICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHdyaXRlIHJlcSB0byBzdHJlYW1cbiAgICAgICAgc3RyZWFtLnB1c2gocmVxKTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgcmVxdWVzdCBvbiBpZCBtYXBcbiAgICAgICAgaWRNYXBbcmVxLmlkXSA9IHsgcmVxLCByZXMsIG5leHQsIGVuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXZlbnRzLCBtaWRkbGV3YXJlLCBzdHJlYW0gfTtcbiAgICBmdW5jdGlvbiByZWFkTm9vcCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShyZXMsIF9lbmNvZGluZywgY2IpIHtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlzTm90aWZpY2F0aW9uID0gIXJlcy5pZDtcbiAgICAgICAgICAgIGlmIChpc05vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NOb3RpZmljYXRpb24ocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NSZXNwb25zZShyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtXG4gICAgICAgIGNiKGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF07XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCBcIiR7cmVzLmlkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGlkTWFwW3Jlcy5pZF07XG4gICAgICAgIC8vIGNvcHkgd2hvbGUgcmVzIG9udG8gb3JpZ2luYWwgcmVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5yZXMsIHJlcyk7XG4gICAgICAgIC8vIHJ1biBjYWxsYmFjayBvbiBlbXB0eSBzdGFjayxcbiAgICAgICAgLy8gcHJldmVudCBpbnRlcm5hbCBzdHJlYW0taGFuZGxlciBmcm9tIGNhdGNoaW5nIGVycm9yc1xuICAgICAgICBzZXRUaW1lb3V0KGNvbnRleHQuZW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpIHtcbiAgICAgICAgZXZlbnRzLmVtaXQoJ25vdGlmaWNhdGlvbicsIHJlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgQmFzZVBvc3RNZXNzYWdlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9CYXNlUG9zdE1lc3NhZ2VTdHJlYW1cIik7XG4vKipcbiAqIFdpbmRvdy5wb3N0TWVzc2FnZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFdpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtXzEuQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyZWFtIGZvciBjb21tdW5pY2F0aW5nIHdpdGggb3RoZXIgc3RyZWFtcyBhY3Jvc3MgdGhlIHNhbWUgb3JcbiAgICAgKiBkaWZmZXJlbnQgd2luZG93IG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cmVhbS4gVXNlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAgKiBtdWx0aXBsZSBzdHJlYW1zIHNoYXJpbmcgdGhlIHNhbWUgd2luZG93IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYXJncy50YXJnZXQgLSBUaGUgbmFtZSBvZiB0aGUgc3RyZWFtIHRvIGV4Y2hhbmdlIG1lc3NhZ2VzIHdpdGguXG4gICAgICogQHBhcmFtIGFyZ3MudGFyZ2V0V2luZG93IC0gVGhlIHdpbmRvdyBvYmplY3Qgb2YgdGhlIHRhcmdldCBzdHJlYW0uIERlZmF1bHRzXG4gICAgICogdG8gYHdpbmRvd2AuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBuYW1lLCB0YXJnZXQsIHRhcmdldFdpbmRvdyB9KSB7XG4gICAgICAgIGlmICghbmFtZSB8fCAhdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0T3JpZ2luID0gdGFyZ2V0V2luZG93ID8gJyonIDogbG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB0aGlzLl90YXJnZXRXaW5kb3cgPSB0YXJnZXRXaW5kb3cgfHwgd2luZG93O1xuICAgICAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5faGFuZHNoYWtlKCk7XG4gICAgfVxuICAgIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0sIHRoaXMuX3RhcmdldE9yaWdpbik7XG4gICAgfVxuICAgIF9vbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIC8vIHZhbGlkYXRlIG1lc3NhZ2VcbiAgICAgICAgaWYgKCh0aGlzLl90YXJnZXRPcmlnaW4gIT09ICcqJyAmJiBldmVudC5vcmlnaW4gIT09IHRoaXMuX3RhcmdldE9yaWdpbikgfHxcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZSAhPT0gdGhpcy5fdGFyZ2V0V2luZG93IHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UudGFyZ2V0ICE9PSB0aGlzLl9uYW1lIHx8XG4gICAgICAgICAgICAhbWVzc2FnZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EYXRhKG1lc3NhZ2UuZGF0YSk7XG4gICAgfVxuICAgIF9kZXN0cm95KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZSwgZmFsc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2luZG93UG9zdE1lc3NhZ2VTdHJlYW0gPSBXaW5kb3dQb3N0TWVzc2FnZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbSA9IHZvaWQgMDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG4vLyBXZSBpZ25vcmUgY292ZXJhZ2UgZm9yIHRoZSBlbnRpcmUgZmlsZSBkdWUgdG8gbGltaXRzIG9uIG91ciBpbnN0cnVtZW50YXRpb24sXG4vLyBidXQgaXQgaXMgaW4gZmFjdCBjb3ZlcmVkIGJ5IG91ciB0ZXN0cy5cbmNvbnN0IEJhc2VQb3N0TWVzc2FnZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vQmFzZVBvc3RNZXNzYWdlU3RyZWFtXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuLyoqXG4gKiBXb3JrZXItc2lkZSBkZWRpY2F0ZWQgd2ViIHdvcmtlciBgcG9zdE1lc3NhZ2VgIHN0cmVhbS5cbiAqL1xuY2xhc3MgV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW1fMS5CYXNlUG9zdE1lc3NhZ2VTdHJlYW0ge1xuICAgIC8qKlxuICAgICAqIE5vdGU6IERlc2lnbmVkIGZvciB1c2UgaW4gd2ViIHdvcmtlcnMgb25seS5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBzdHJlYW0gZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgd2luZG93IHRoYXQgY3JlYXRlZCB0aGlzIHdlYlxuICAgICAqIHdvcmtlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IGVudW1zXzEuREVESUNBVEVEX1dPUktFUl9OQU1FO1xuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kc2hha2UoKTtcbiAgICB9XG4gICAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgLy8gQ2FzdCBvZiBzZWxmLnBvc3RNZXNzYWdlIGR1ZSB0byB1c2FnZSBvZiBET00gbGliXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBkYXRhIH0pO1xuICAgIH1cbiAgICBfb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UudGFyZ2V0ICE9PSB0aGlzLl9uYW1lIHx8XG4gICAgICAgICAgICAhbWVzc2FnZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EYXRhKG1lc3NhZ2UuZGF0YSk7XG4gICAgfVxuICAgIC8vIHdvcmtlciBzdHJlYW0gbGlmZWN5Y2xlIGFzc3VtZWQgdG8gYmUgY290ZXJtaW5vdXMgd2l0aCBnbG9iYWwgc2NvcGVcbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLldvcmtlclBvc3RNZXNzYWdlU3RyZWFtID0gV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBCYXNlUG9zdE1lc3NhZ2VTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL0Jhc2VQb3N0TWVzc2FnZVN0cmVhbVwiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbi8qKlxuICogUGFyZW50LXNpZGUgZGVkaWNhdGVkIHdlYiB3b3JrZXIgYHBvc3RNZXNzYWdlYCBzdHJlYW0uXG4gKi9cbmNsYXNzIFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgQmFzZVBvc3RNZXNzYWdlU3RyZWFtXzEuQmFzZVBvc3RNZXNzYWdlU3RyZWFtIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyZWFtIGZvciBjb21tdW5pY2F0aW5nIHdpdGggYSBkZWRpY2F0ZWQgd2ViIHdvcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzLndvcmtlciAtIFRoZSBXZWIgV29ya2VyIHRvIGV4Y2hhbmdlIG1lc3NhZ2VzIHdpdGguIFRoZSB3b3JrZXJcbiAgICAgKiBtdXN0IGluc3RhbnRpYXRlIGEgV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW0uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB3b3JrZXIgfSkge1xuICAgICAgICBpZiAoIXdvcmtlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IGVudW1zXzEuREVESUNBVEVEX1dPUktFUl9OQU1FO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuX3dvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFuZHNoYWtlKCk7XG4gICAgfVxuICAgIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRGF0YShtZXNzYWdlLmRhdGEpO1xuICAgIH1cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Xb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbSA9IFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyUGFyZW50UG9zdE1lc3NhZ2VTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNuYXBzSGFuZGxlciA9IHZvaWQgMDtcbi8qKlxuICogYHdhbGxldF9nZXRTbmFwc2AgZ2V0cyB0aGUgcmVxdWVzdGVyJ3MgcGVybWl0dGVkIGFuZCBpbnN0YWxsZWQgU25hcHMuXG4gKi9cbmV4cG9ydHMuZ2V0U25hcHNIYW5kbGVyID0ge1xuICAgIG1ldGhvZE5hbWVzOiBbJ3dhbGxldF9nZXRTbmFwcyddLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRTbmFwc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICBnZXRTbmFwczogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldFNuYXBzSW1wbGVtZW50YXRpb24oX3JlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldFNuYXBzIH0pIHtcbiAgICAvLyBnZXRTbmFwcyBpcyBhbHJlYWR5IGJvdW5kIHRvIHRoZSBvcmlnaW5cbiAgICByZXMucmVzdWx0ID0gZ2V0U25hcHMoKTtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTbmFwcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXBwS2V5SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKipcbiAqIGBzbmFwX2dldEFwcEtleWAgZ2V0cyB0aGUgU25hcCdzIGFwcCBrZXkuXG4gKi9cbmV4cG9ydHMuZ2V0QXBwS2V5SGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogWydzbmFwX2dldEFwcEtleSddLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRBcHBLZXlJbXBsZW1lbnRhdGlvbixcbiAgICBob29rTmFtZXM6IHtcbiAgICAgICAgZ2V0QXBwS2V5OiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXBwS2V5SW1wbGVtZW50YXRpb24ocmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgZ2V0QXBwS2V5IH0pIHtcbiAgICBjb25zdCBbcmVxdWVzdGVkQWNjb3VudF0gPSAocmVxID09PSBudWxsIHx8IHJlcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVxLnBhcmFtcykgfHwgW107XG4gICAgaWYgKHJlcXVlc3RlZEFjY291bnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoIXJlcXVlc3RlZEFjY291bnQgfHwgdHlwZW9mIHJlcXVlc3RlZEFjY291bnQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZW5kKGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IG9taXQgcGFyYW1zIGNvbXBsZXRlbHkgb3Igc3BlY2lmeSBhIHNpbmdsZSBoZXhhZGVjaW1hbCBzdHJpbmcgRXRoZXJldW0gYWNjb3VudC4nLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRBcHBLZXkocmVxdWVzdGVkQWNjb3VudCk7XG4gICAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFwcEtleS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5hYmxlV2FsbGV0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBzbmFwX2NvbnRyb2xsZXJzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnNcIik7XG5jb25zdCBzbmFwSW5zdGFsbGF0aW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb24vc25hcEluc3RhbGxhdGlvblwiKTtcbi8qKlxuICogYHdhbGxldF9lbmFibGVgIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgdGFrZXMgYSByZXF1ZXN0IHBlcm1pc3Npb25zXG4gKiBvYmplY3QgYXMgaXRzIHNpbmdsZSBwYXJhbWV0ZXIsIGFuZCB0aGVuIGNhbGxzIGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zYCxcbiAqIGB3YWxsZXRfaW5zdGFsbFNuYXBzYCwgYW5kIGBldGhfYWNjb3VudHNgIGFzIGFwcHJvcHJpYXRlIGJhc2VkIG9uIHRoZVxuICogcmVxdWVzdGVkIHBlcm1pc3Npb25zLiBUaGUgbWV0aG9kIHJldHVybnMgYSBzaW5nbGUgb2JqZWN0IHJlc3VsdCB3aXRoXG4gKiBzZXBhcmF0ZSBwcm9wZXJ0aWVzIGZvciB0aGUgcmV0dXJuIHZhbHVlcyBvZiBlYWNoIG1ldGhvZCwgYW5kIGFueSBlcnJvcnNcbiAqIHRoYXQgb2NjdXJyZWQ6XG4gKlxuICogYHsgYWNjb3VudHMsIHBlcm1pc3Npb25zLCBzbmFwcywgZXJyb3JzPyB9YFxuICovXG5leHBvcnRzLmVuYWJsZVdhbGxldEhhbmRsZXIgPSB7XG4gICAgbWV0aG9kTmFtZXM6IFsnd2FsbGV0X2VuYWJsZSddLFxuICAgIGltcGxlbWVudGF0aW9uOiBlbmFibGVXYWxsZXQsXG4gICAgaG9va05hbWVzOiB7XG4gICAgICAgIGdldEFjY291bnRzOiB0cnVlLFxuICAgICAgICBpbnN0YWxsU25hcHM6IHRydWUsXG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uczogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZVdhbGxldChyZXEsIHJlcywgX25leHQsIGVuZCwgeyBnZXRBY2NvdW50cywgaW5zdGFsbFNuYXBzLCByZXF1ZXN0UGVybWlzc2lvbnMgfSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXEucGFyYW1zKSkge1xuICAgICAgICByZXR1cm4gZW5kKGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdcInBhcmFtc1wiIG11c3QgYmUgYW4gYXJyYXkuJyxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGFjY291bnRzOiBbXSxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtdLFxuICAgICAgICBzbmFwczoge30sXG4gICAgfTtcbiAgICAvLyByZXF1ZXN0IHRoZSBwZXJtaXNzaW9uc1xuICAgIGxldCByZXF1ZXN0ZWRQZXJtaXNzaW9ucztcbiAgICB0cnkge1xuICAgICAgICAvLyB3ZSBleHBlY3QgdGhlIHBhcmFtcyB0byBiZSB0aGUgc2FtZSBhcyB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zXG4gICAgICAgIHJlcXVlc3RlZFBlcm1pc3Npb25zID0gc25hcEluc3RhbGxhdGlvbl8xLnByZXByb2Nlc3NSZXF1ZXN0ZWRQZXJtaXNzaW9ucyhyZXEucGFyYW1zWzBdKTtcbiAgICAgICAgcmVzdWx0LnBlcm1pc3Npb25zID0gYXdhaXQgcmVxdWVzdFBlcm1pc3Npb25zKHJlcXVlc3RlZFBlcm1pc3Npb25zKTtcbiAgICAgICAgaWYgKCFyZXN1bHQucGVybWlzc2lvbnMgfHwgIXJlc3VsdC5wZXJtaXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoeyBkYXRhOiByZXEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgfVxuICAgIC8vIGluc3RhbGwgc25hcHMsIGlmIGFueVxuICAgIC8vIGdldCB0aGUgbmFtZXMgb2YgdGhlIGFwcHJvdmVkIHNuYXBzXG4gICAgY29uc3QgcmVxdWVzdGVkU25hcHMgPSByZXN1bHQucGVybWlzc2lvbnNcbiAgICAgICAgLy8gcmVxdWVzdFBlcm1pc3Npb25zIHJldHVybnMgYWxsIHBlcm1pc3Npb25zIGZvciB0aGUgZG9tYWluLFxuICAgICAgICAvLyBzbyB3ZSdyZSBmaWx0ZXJpbmcgb3V0IG5vbi1zbmFwIGFuZCBwcmVleGlzdGluZyBwZXJtaXNzaW9uc1xuICAgICAgICAuZmlsdGVyKChwZXJtKSA9PiBwZXJtLnBhcmVudENhcGFiaWxpdHkuc3RhcnRzV2l0aChzbmFwX2NvbnRyb2xsZXJzXzEuU05BUF9QUkVGSVgpICYmXG4gICAgICAgIHBlcm0ucGFyZW50Q2FwYWJpbGl0eSBpbiByZXF1ZXN0ZWRQZXJtaXNzaW9ucylcbiAgICAgICAgLy8gY29udmVydCBmcm9tIG5hbWVzcGFjZWQgcGVybWlzc2lvbnMgdG8gc25hcCBpZHNcbiAgICAgICAgLnJlZHVjZSgoX3JlcXVlc3RlZFNuYXBzLCBwZXJtKSA9PiB7XG4gICAgICAgIGNvbnN0IHNuYXBJZCA9IHBlcm0ucGFyZW50Q2FwYWJpbGl0eS5yZXBsYWNlKHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWF9SRUdFWCwgJycpO1xuICAgICAgICBfcmVxdWVzdGVkU25hcHNbc25hcElkXSA9IHJlcXVlc3RlZFBlcm1pc3Npb25zW3Blcm0ucGFyZW50Q2FwYWJpbGl0eV07XG4gICAgICAgIHJldHVybiBfcmVxdWVzdGVkU25hcHM7XG4gICAgfSwge30pO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRTbmFwcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyB0aHJvd3MgaWYgcmVxdWVzdGVkU25hcHMgaXMgZW1wdHlcbiAgICAgICAgICAgIHJlc3VsdC5zbmFwcyA9IGF3YWl0IHNuYXBJbnN0YWxsYXRpb25fMS5oYW5kbGVJbnN0YWxsU25hcHMocmVxdWVzdGVkU25hcHMsIGluc3RhbGxTbmFwcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goZXRoX3JwY19lcnJvcnNfMS5zZXJpYWxpemVFcnJvcihlcnIpKTtcbiAgICB9XG4gICAgLy8gZ2V0IHdoYXRldmVyIGFjY291bnRzIHdlIGhhdmVcbiAgICByZXN1bHQuYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cygpO1xuICAgIC8vIHJldHVybiB0aGUgcmVzdWx0XG4gICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludm9rZVNuYXBTdWdhckhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qgc25hcF9jb250cm9sbGVyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8qKlxuICogYHdhbGxldF9pbnZva2VTbmFwYCBhdHRlbXB0cyB0byBpbnZva2UgYW4gUlBDIG1ldGhvZCBvZiB0aGUgc3BlY2lmaWVkIFNuYXAuXG4gKi9cbmV4cG9ydHMuaW52b2tlU25hcFN1Z2FySGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogWyd3YWxsZXRfaW52b2tlU25hcCddLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbnZva2VTbmFwU3VnYXIsXG4gICAgaG9va05hbWVzOiB1bmRlZmluZWQsXG59O1xuYXN5bmMgZnVuY3Rpb24gaW52b2tlU25hcFN1Z2FyKHJlcSwgX3JlcywgbmV4dCwgZW5kKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpIHx8XG4gICAgICAgIHR5cGVvZiByZXEucGFyYW1zWzBdICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhdXRpbHNfMS5pc1BsYWluT2JqZWN0KHJlcS5wYXJhbXNbMV0pKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ011c3Qgc3BlY2lmeSBhIHN0cmluZyBzbmFwIElEIGFuZCBhIHBsYWluIHJlcXVlc3Qgb2JqZWN0LicsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVxLm1ldGhvZCA9IHNuYXBfY29udHJvbGxlcnNfMS5TTkFQX1BSRUZJWCArIHJlcS5wYXJhbXNbMF07XG4gICAgcmVxLnBhcmFtcyA9IFtyZXEucGFyYW1zWzFdXTtcbiAgICByZXR1cm4gbmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52b2tlU25hcFN1Z2FyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnN0YWxsU25hcHNIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IHNuYXBJbnN0YWxsYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9zbmFwSW5zdGFsbGF0aW9uXCIpO1xuLyoqXG4gKiBgd2FsbGV0X2luc3RhbGxTbmFwc2AgaW5zdGFsbHMgdGhlIHJlcXVlc3RlZCBTbmFwcywgaWYgdGhleSBhcmUgcGVybWl0dGVkLlxuICovXG5leHBvcnRzLmluc3RhbGxTbmFwc0hhbmRsZXIgPSB7XG4gICAgbWV0aG9kTmFtZXM6IFsnd2FsbGV0X2luc3RhbGxTbmFwcyddLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbnN0YWxsU25hcHNJbXBsZW1lbnRhdGlvbixcbiAgICBob29rTmFtZXM6IHtcbiAgICAgICAgaW5zdGFsbFNuYXBzOiB0cnVlLFxuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gaW5zdGFsbFNuYXBzSW1wbGVtZW50YXRpb24ocmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgaW5zdGFsbFNuYXBzIH0pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVxLnBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuIGVuZChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiAnXCJwYXJhbXNcIiBtdXN0IGJlIGFuIGFycmF5LicsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHNuYXBJbnN0YWxsYXRpb25fMS5oYW5kbGVJbnN0YWxsU25hcHMocmVxLnBhcmFtc1swXSwgaW5zdGFsbFNuYXBzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXMuZXJyb3IgPSBlcnI7XG4gICAgfVxuICAgIHJldHVybiBlbmQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RhbGxTbmFwcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFuYWdlU3RhdGVPcGVyYXRpb24gPSBleHBvcnRzLm1hbmFnZVN0YXRlQnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbWV0aG9kTmFtZSA9ICdzbmFwX21hbmFnZVN0YXRlJztcbi8qKlxuICogYHNuYXBfbWFuYWdlU3RhdGVgIGxldCdzIHRoZSBTbmFwIHN0b3JlIGFuZCBtYW5hZ2Ugc29tZSBvZiBpdHMgc3RhdGUgb25cbiAqIHlvdXIgZGV2aWNlLlxuICovXG5jb25zdCBzcGVjaWZpY2F0aW9uQnVpbGRlciA9ICh7IGFsbG93ZWRDYXZlYXRzID0gbnVsbCwgbWV0aG9kSG9va3MsIH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwZXJtaXNzaW9uVHlwZTogc25hcF9jb250cm9sbGVyc18xLlBlcm1pc3Npb25UeXBlLlJlc3RyaWN0ZWRNZXRob2QsXG4gICAgICAgIHRhcmdldEtleTogbWV0aG9kTmFtZSxcbiAgICAgICAgYWxsb3dlZENhdmVhdHMsXG4gICAgICAgIG1ldGhvZEltcGxlbWVudGF0aW9uOiBnZXRNYW5hZ2VTdGF0ZUltcGxlbWVudGF0aW9uKG1ldGhvZEhvb2tzKSxcbiAgICB9O1xufTtcbmV4cG9ydHMubWFuYWdlU3RhdGVCdWlsZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdGFyZ2V0S2V5OiBtZXRob2ROYW1lLFxuICAgIHNwZWNpZmljYXRpb25CdWlsZGVyLFxuICAgIG1ldGhvZEhvb2tzOiB7XG4gICAgICAgIGNsZWFyU25hcFN0YXRlOiB0cnVlLFxuICAgICAgICBnZXRTbmFwU3RhdGU6IHRydWUsXG4gICAgICAgIHVwZGF0ZVNuYXBTdGF0ZTogdHJ1ZSxcbiAgICB9LFxufSk7XG52YXIgTWFuYWdlU3RhdGVPcGVyYXRpb247XG4oZnVuY3Rpb24gKE1hbmFnZVN0YXRlT3BlcmF0aW9uKSB7XG4gICAgTWFuYWdlU3RhdGVPcGVyYXRpb25bXCJjbGVhclN0YXRlXCJdID0gXCJjbGVhclwiO1xuICAgIE1hbmFnZVN0YXRlT3BlcmF0aW9uW1wiZ2V0U3RhdGVcIl0gPSBcImdldFwiO1xuICAgIE1hbmFnZVN0YXRlT3BlcmF0aW9uW1widXBkYXRlU3RhdGVcIl0gPSBcInVwZGF0ZVwiO1xufSkoTWFuYWdlU3RhdGVPcGVyYXRpb24gPSBleHBvcnRzLk1hbmFnZVN0YXRlT3BlcmF0aW9uIHx8IChleHBvcnRzLk1hbmFnZVN0YXRlT3BlcmF0aW9uID0ge30pKTtcbmZ1bmN0aW9uIGdldE1hbmFnZVN0YXRlSW1wbGVtZW50YXRpb24oeyBjbGVhclNuYXBTdGF0ZSwgZ2V0U25hcFN0YXRlLCB1cGRhdGVTbmFwU3RhdGUsIH0pIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gbWFuYWdlU3RhdGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHBhcmFtcyA9IFtdLCBtZXRob2QsIGNvbnRleHQ6IHsgb3JpZ2luIH0sIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBbb3BlcmF0aW9uLCBuZXdTdGF0ZV0gPSBwYXJhbXM7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1hbmFnZVN0YXRlT3BlcmF0aW9uLmNsZWFyU3RhdGU6XG4gICAgICAgICAgICAgICAgYXdhaXQgY2xlYXJTbmFwU3RhdGUob3JpZ2luKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgTWFuYWdlU3RhdGVPcGVyYXRpb24uZ2V0U3RhdGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldFNuYXBTdGF0ZShvcmlnaW4pO1xuICAgICAgICAgICAgY2FzZSBNYW5hZ2VTdGF0ZU9wZXJhdGlvbi51cGRhdGVTdGF0ZTpcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaXNQbGFpbk9iamVjdChuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEludmFsaWQgJHttZXRob2R9IFwidXBkYXRlU3RhdGVcIiBwYXJhbWV0ZXI6IFRoZSBuZXcgc3RhdGUgbXVzdCBiZSBhIHBsYWluIG9iamVjdC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkTmV3U3RhdGU6IHR5cGVvZiBuZXdTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVNuYXBTdGF0ZShvcmlnaW4sIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgJHttZXRob2R9IG9wZXJhdGlvbjogXCIke29wZXJhdGlvbn1cImApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hbmFnZVN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnZva2VTbmFwQnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbWV0aG9kUHJlZml4ID0gc25hcF9jb250cm9sbGVyc18xLlNOQVBfUFJFRklYO1xuY29uc3QgdGFyZ2V0S2V5ID0gYCR7bWV0aG9kUHJlZml4fSpgO1xuLyoqXG4gKiBgd2FsbGV0X3NuYXBfKmAgYXR0ZW1wdHMgdG8gaW52b2tlIGFuIFJQQyBtZXRob2Qgb2YgdGhlIHNwZWNpZmllZCBTbmFwLlxuICogUmVxdWVzdGluZyBpdHMgY29ycmVzcG9uZGluZyBwZXJtaXNzaW9uIHdpbGwgYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBTbmFwLFxuICogYW5kIGluc3RhbGwgaXQgaWYgaXQncyBub3QgYXZhaWFsYmxlIHlldC5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoeyBhbGxvd2VkQ2F2ZWF0cyA9IG51bGwsIG1ldGhvZEhvb2tzLCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGVybWlzc2lvblR5cGU6IHNuYXBfY29udHJvbGxlcnNfMS5QZXJtaXNzaW9uVHlwZS5SZXN0cmljdGVkTWV0aG9kLFxuICAgICAgICB0YXJnZXRLZXksXG4gICAgICAgIGFsbG93ZWRDYXZlYXRzLFxuICAgICAgICBtZXRob2RJbXBsZW1lbnRhdGlvbjogZ2V0SW52b2tlU25hcEltcGxlbWVudGF0aW9uKG1ldGhvZEhvb2tzKSxcbiAgICB9O1xufTtcbmV4cG9ydHMuaW52b2tlU25hcEJ1aWxkZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICB0YXJnZXRLZXksXG4gICAgc3BlY2lmaWNhdGlvbkJ1aWxkZXIsXG4gICAgbWV0aG9kSG9va3M6IHtcbiAgICAgICAgZ2V0U25hcDogdHJ1ZSxcbiAgICAgICAgYWRkU25hcDogdHJ1ZSxcbiAgICAgICAgZ2V0U25hcFJwY0hhbmRsZXI6IHRydWUsXG4gICAgfSxcbn0pO1xuZnVuY3Rpb24gZ2V0SW52b2tlU25hcEltcGxlbWVudGF0aW9uKHsgZ2V0U25hcCwgYWRkU25hcCwgZ2V0U25hcFJwY0hhbmRsZXIsIH0pIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gaW52b2tlU25hcChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zID0gW10sIG1ldGhvZCwgY29udGV4dCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgc25hcFJwY1JlcXVlc3QgPSBwYXJhbXNbMF07XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHNuYXBScGNSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IHNwZWNpZnkgc25hcCBSUEMgcmVxdWVzdCBvYmplY3QgYXMgc2luZ2xlIHBhcmFtZXRlci4nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc25hcElkU3RyaW5nID0gbWV0aG9kLnN1YnN0cihzbmFwX2NvbnRyb2xsZXJzXzEuU05BUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFnZXRTbmFwKHNuYXBJZFN0cmluZykpIHtcbiAgICAgICAgICAgIGF3YWl0IGFkZFNuYXAoe1xuICAgICAgICAgICAgICAgIGlkOiBzbmFwSWRTdHJpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgZ2V0U25hcFJwY0hhbmRsZXIoc25hcElkU3RyaW5nKTtcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTbmFwIFJQQyBtZXNzYWdlIGhhbmRsZXIgbm90IGZvdW5kIGZvciBzbmFwIFwiJHtzbmFwSWRTdHJpbmd9XCIuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb21TdWJqZWN0ID0gY29udGV4dC5vcmlnaW47XG4gICAgICAgIC8vIEhhbmRsZXIgaXMgYW4gYXN5bmMgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBzbmFwT3JpZ2luU3RyaW5nIHN0cmluZyBhbmQgYSByZXF1ZXN0IG9iamVjdC5cbiAgICAgICAgLy8gSXQgc2hvdWxkIHJldHVybiB0aGUgcmVzdWx0IGl0IHdvdWxkIGxpa2UgcmV0dXJuZWQgdG8gdGhlIGZyb21Eb21haW4gYXMgcGFydCBvZiByZXNwb25zZS5yZXN1bHRcbiAgICAgICAgcmV0dXJuIChhd2FpdCBoYW5kbGVyKGZyb21TdWJqZWN0LCBzbmFwUnBjUmVxdWVzdCkpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZva2VTbmFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25maXJtQnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IHNuYXBfY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc25hcC1jb250cm9sbGVyc1wiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbWV0aG9kTmFtZSA9ICdzbmFwX2NvbmZpcm0nO1xuLyoqXG4gKiBgc25hcF9jb25maXJtYCBsZXRzIHRoZSBTbmFwIGRpc3BsYXkgYSBjb25maXJtYXRpb24gZGlhbG9nIHRvIHRoZSB1c2VyLlxuICovXG5jb25zdCBzcGVjaWZpY2F0aW9uQnVpbGRlciA9ICh7IGFsbG93ZWRDYXZlYXRzID0gbnVsbCwgbWV0aG9kSG9va3MsIH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwZXJtaXNzaW9uVHlwZTogc25hcF9jb250cm9sbGVyc18xLlBlcm1pc3Npb25UeXBlLlJlc3RyaWN0ZWRNZXRob2QsXG4gICAgICAgIHRhcmdldEtleTogbWV0aG9kTmFtZSxcbiAgICAgICAgYWxsb3dlZENhdmVhdHMsXG4gICAgICAgIG1ldGhvZEltcGxlbWVudGF0aW9uOiBnZXRDb25maXJtSW1wbGVtZW50YXRpb24obWV0aG9kSG9va3MpLFxuICAgIH07XG59O1xuZXhwb3J0cy5jb25maXJtQnVpbGRlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRhcmdldEtleTogbWV0aG9kTmFtZSxcbiAgICBzcGVjaWZpY2F0aW9uQnVpbGRlcixcbiAgICBtZXRob2RIb29rczoge1xuICAgICAgICBzaG93Q29uZmlybWF0aW9uOiB0cnVlLFxuICAgIH0sXG59KTtcbmZ1bmN0aW9uIGdldENvbmZpcm1JbXBsZW1lbnRhdGlvbih7IHNob3dDb25maXJtYXRpb24gfSkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBjb25maXJtSW1wbGVtZW50YXRpb24oYXJncykge1xuICAgICAgICBjb25zdCB7IHBhcmFtcywgY29udGV4dDogeyBvcmlnaW4gfSwgfSA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBhd2FpdCBzaG93Q29uZmlybWF0aW9uKG9yaWdpbiwgZ2V0VmFsaWRhdGVkUGFyYW1zKHBhcmFtcykpO1xuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgY29uZmlybSBtZXRob2QgYHBhcmFtc2AgYW5kIHJldHVybnMgdGhlbSBjYXN0IHRvIHRoZSBjb3JyZWN0XG4gKiB0eXBlLiBUaHJvd3MgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHVudmFsaWRhdGVkIHBhcmFtcyBvYmplY3QgZnJvbSB0aGUgbWV0aG9kIHJlcXVlc3QuXG4gKiBAcmV0dXJucyBUaGUgdmFsaWRhdGVkIGNvbmZpcm0gbWV0aG9kIHBhcmFtZXRlciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbGlkYXRlZFBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSB8fCAhdXRpbHNfMS5pc1BsYWluT2JqZWN0KHBhcmFtc1swXSkpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFycmF5IHBhcmFtcyB3aXRoIHNpbmdsZSBvYmplY3QuJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvbXB0LCBkZXNjcmlwdGlvbiwgdGV4dEFyZWFDb250ZW50IH0gPSBwYXJhbXNbMF07XG4gICAgaWYgKCFwcm9tcHQgfHwgdHlwZW9mIHByb21wdCAhPT0gJ3N0cmluZycgfHwgcHJvbXB0Lmxlbmd0aCA+IDQwKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IHNwZWNpZnkgYSBub24tZW1wdHkgc3RyaW5nIFwicHJvbXB0XCIgbGVzcyB0aGFuIDQwIGNoYXJhY3RlcnMgbG9uZy4nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0aW9uICYmXG4gICAgICAgICh0eXBlb2YgZGVzY3JpcHRpb24gIT09ICdzdHJpbmcnIHx8IGRlc2NyaXB0aW9uLmxlbmd0aCA+IDE0MCkpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1wiZGVzY3JpcHRpb25cIiBtdXN0IGJlIGEgc3RyaW5nIG5vIG1vcmUgdGhhbiAxNDAgY2hhcmFjdGVycyBsb25nIGlmIHNwZWNpZmllZC4nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRleHRBcmVhQ29udGVudCAmJlxuICAgICAgICAodHlwZW9mIHRleHRBcmVhQ29udGVudCAhPT0gJ3N0cmluZycgfHwgdGV4dEFyZWFDb250ZW50Lmxlbmd0aCA+IDE4MDApKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdcInRleHRBcmVhQ29udGVudFwiIG11c3QgYmUgYSBzdHJpbmcgbm8gbW9yZSB0aGFuIDE4MDAgY2hhcmFjdGVycyBsb25nIGlmIHNwZWNpZmllZC4nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc1swXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEJpcDQ0RW50cm9weUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBzbmFwX2NvbnRyb2xsZXJzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnNcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qga2V5X3RyZWVfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2sva2V5LXRyZWVcIik7XG5jb25zdCBtZXRob2RQcmVmaXggPSAnc25hcF9nZXRCaXA0NEVudHJvcHlfJztcbmNvbnN0IHRhcmdldEtleSA9IGAke21ldGhvZFByZWZpeH0qYDtcbi8qKlxuICogYHNuYXBfZ2V0QmlwNDRFbnRyb3B5XypgIGxldHMgdGhlIFNuYXAgY29udHJvbCBwcml2YXRlIGtleXMgZm9yIGEgcGFydGljdWxhclxuICogQklQLTMyIGNvaW4gdHlwZS5cbiAqL1xuY29uc3Qgc3BlY2lmaWNhdGlvbkJ1aWxkZXIgPSAoeyBhbGxvd2VkQ2F2ZWF0cyA9IG51bGwsIG1ldGhvZEhvb2tzLCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGVybWlzc2lvblR5cGU6IHNuYXBfY29udHJvbGxlcnNfMS5QZXJtaXNzaW9uVHlwZS5SZXN0cmljdGVkTWV0aG9kLFxuICAgICAgICB0YXJnZXRLZXksXG4gICAgICAgIGFsbG93ZWRDYXZlYXRzLFxuICAgICAgICBtZXRob2RJbXBsZW1lbnRhdGlvbjogZ2V0QmlwNDRFbnRyb3B5SW1wbGVtZW50YXRpb24obWV0aG9kSG9va3MpLFxuICAgIH07XG59O1xuZXhwb3J0cy5nZXRCaXA0NEVudHJvcHlCdWlsZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdGFyZ2V0S2V5LFxuICAgIHNwZWNpZmljYXRpb25CdWlsZGVyLFxuICAgIG1ldGhvZEhvb2tzOiB7XG4gICAgICAgIGdldE1uZW1vbmljOiB0cnVlLFxuICAgIH0sXG59KTtcbmNvbnN0IEFMTF9ESUdJVF9SRUdFWCA9IC9eXFxkKyQvdTtcbmZ1bmN0aW9uIGdldEJpcDQ0RW50cm9weUltcGxlbWVudGF0aW9uKHsgZ2V0TW5lbW9uaWMsIH0pIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gZ2V0QmlwNDRFbnRyb3B5KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYmlwNDRDb2RlID0gYXJncy5tZXRob2Quc3Vic3RyKG1ldGhvZFByZWZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAoIUFMTF9ESUdJVF9SRUdFWC50ZXN0KGJpcDQ0Q29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEludmFsaWQgQklQLTQ0IGNvZGU6ICR7YmlwNDRDb2RlfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGtleV90cmVlXzEuQklQNDRDb2luVHlwZU5vZGUoW1xuICAgICAgICAgICAgYGJpcDM5OiR7YXdhaXQgZ2V0TW5lbW9uaWMoKX1gLFxuICAgICAgICAgICAgYGJpcDMyOjQ0J2AsXG4gICAgICAgICAgICBgYmlwMzI6JHtOdW1iZXIoYmlwNDRDb2RlKX0nYCxcbiAgICAgICAgXSkudG9KU09OKCk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEJpcDQ0RW50cm9weS5qcy5tYXAiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uXzEuZGVmYXVsdDsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2JjLXVyLXJlZ2lzdHJ5LWV0aC5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc3VwZXJQcm9wQmFzZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXNzaWduID0gbWFrZV9hc3NpZ24oKVxudmFyIGNyZWF0ZSA9IG1ha2VfY3JlYXRlKClcbnZhciB0cmltID0gbWFrZV90cmltKClcbnZhciBHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0Y3JlYXRlOiBjcmVhdGUsXG5cdHRyaW06IHRyaW0sXG5cdGJpbmQ6IGJpbmQsXG5cdHNsaWNlOiBzbGljZSxcblx0ZWFjaDogZWFjaCxcblx0bWFwOiBtYXAsXG5cdHBsdWNrOiBwbHVjayxcblx0aXNMaXN0OiBpc0xpc3QsXG5cdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0R2xvYmFsOiBHbG9iYWxcbn1cblxuZnVuY3Rpb24gbWFrZV9hc3NpZ24oKSB7XG5cdGlmIChPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ25cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2hpbUFzc2lnbihvYmosIHByb3BzMSwgcHJvcHMyLCBldGMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGVhY2goT2JqZWN0KGFyZ3VtZW50c1tpXSksIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0XHRcdFx0b2JqW2tleV0gPSB2YWxcblx0XHRcdFx0fSlcblx0XHRcdH1cdFx0XHRcblx0XHRcdHJldHVybiBvYmpcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbWFrZV9jcmVhdGUoKSB7XG5cdGlmIChPYmplY3QuY3JlYXRlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW09iamVjdC5jcmVhdGUob2JqKV0uY29uY2F0KGFzc2lnbkFyZ3NMaXN0KSlcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZnVuY3Rpb24gRigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdEYucHJvdG90eXBlID0gb2JqXG5cdFx0XHRyZXR1cm4gYXNzaWduLmFwcGx5KHRoaXMsIFtuZXcgRigpXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX3RyaW0oKSB7XG5cdGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJpbShzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGJpbmQob2JqLCBmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSlcblx0fVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnIsIGluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIsIGluZGV4IHx8IDApXG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0Zm4odmFsLCBrZXkpXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdHZhciByZXMgPSAoaXNMaXN0KG9iaikgPyBbXSA6IHt9KVxuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRyZXNba10gPSBmbih2LCBrKVxuXHRcdHJldHVybiBmYWxzZVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHBsdWNrKG9iaiwgZm4pIHtcblx0aWYgKGlzTGlzdChvYmopKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGZuKG9ialtpXSwgaSkpIHtcblx0XHRcdFx0cmV0dXJuIG9ialtpXVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aWYgKGZuKG9ialtrZXldLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9ialtrZXldXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0KHZhbCkge1xuXHRyZXR1cm4gKHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLmxlbmd0aCA9PSAnbnVtYmVyJylcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG5cdHJldHVybiB2YWwgJiYge30udG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gIGpzb24yLmpzXG4vLyAgMjAxNi0xMC0yOFxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuLy8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4vLyAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4vLyAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGE7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuLy8gICAgICAgICAgICAgICAgICBhID1cbi8vICAgL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBkO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSBcIkRhdGUoXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4vLyAgcmVkaXN0cmlidXRlLlxuXG4vKmpzbGludFxuICAgIGV2YWwsIGZvciwgdGhpc1xuKi9cblxuLypwcm9wZXJ0eVxuICAgIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxuaWYgKHR5cGVvZiBKU09OICE9PSBcIm9iamVjdFwiKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvO1xuICAgIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICAgIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgICB2YXIgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbiAgICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMFxuICAgICAgICAgICAgPyBcIjBcIiArIG5cbiAgICAgICAgICAgIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIH1cblxuICAgIHZhciBnYXA7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgbWV0YTtcbiAgICB2YXIgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgXCJcXFwiXCJcbiAgICAgICAgICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIHZhciBrOyAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICB2YXIgcGFydGlhbDtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogXCJudWxsXCI7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSBcIm51bGxcIi4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIltdXCJcbiAgICAgICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgIFwiXFxiXCI6IFwiXFxcXGJcIixcbiAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgICAgICAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG4gICAgICAgIH07XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gXCJcIjtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCBcIigpXCIgYW5kIFwibmV3XCJcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kIFwiPVwiIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoIFwiQFwiIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCBcIl1cIiBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yIFwiXVwiIG9yXG4vLyBcIixcIiBvciBcIjpcIiBvciBcIntcIiBvciBcIn1cIi4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCBcIlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlIFwie1wiIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9ICgwLGV2YWwpKFwiKFwiICsgdGV4dCArIFwiKVwiKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHJldml2ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgPyB3YWxrKHtcIlwiOiBqfSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkpTT04ucGFyc2VcIik7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTsiLCIvLyBtZW1vcnlTdG9yYWdlIGlzIGEgdXNlZnVsIGxhc3QgZmFsbGJhY2sgdG8gZW5zdXJlIHRoYXQgdGhlIHN0b3JlXG4vLyBpcyBmdW5jdGlvbnMgKG1lYW5pbmcgc3RvcmUuZ2V0KCksIHN0b3JlLnNldCgpLCBldGMgd2lsbCBhbGwgZnVuY3Rpb24pLlxuLy8gSG93ZXZlciwgc3RvcmVkIHZhbHVlcyB3aWxsIG5vdCBwZXJzaXN0IHdoZW4gdGhlIGJyb3dzZXIgbmF2aWdhdGVzIHRvXG4vLyBhIG5ldyBwYWdlIG9yIHJlbG9hZHMgdGhlIGN1cnJlbnQgcGFnZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdtZW1vcnlTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgbWVtb3J5U3RvcmFnZSA9IHt9XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdG1lbW9yeVN0b3JhZ2Vba2V5XSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHRmb3IgKHZhciBrZXkgaW4gbWVtb3J5U3RvcmFnZSkge1xuXHRcdGlmIChtZW1vcnlTdG9yYWdlLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKG1lbW9yeVN0b3JhZ2Vba2V5XSwga2V5KVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdGRlbGV0ZSBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoa2V5KSB7XG5cdG1lbW9yeVN0b3JhZ2UgPSB7fVxufVxuIiwiLy8gY29va2llU3RvcmFnZSBpcyB1c2VmdWwgU2FmYXJpIHByaXZhdGUgYnJvd3NlciBtb2RlLCB3aGVyZSBsb2NhbFN0b3JhZ2Vcbi8vIGRvZXNuJ3Qgd29yayBidXQgY29va2llcyBkby4gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhZG9wdGVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdG9yYWdlL0xvY2FsU3RvcmFnZVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxudmFyIHRyaW0gPSB1dGlsLnRyaW1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdjb29raWVTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgZG9jID0gR2xvYmFsLmRvY3VtZW50XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdGlmICgha2V5IHx8ICFfaGFzKGtleSkpIHsgcmV0dXJuIG51bGwgfVxuXHR2YXIgcmVnZXhwU3RyID0gXCIoPzpefC4qO1xcXFxzKilcIiArXG5cdFx0ZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgK1xuXHRcdFwiXFxcXHMqXFxcXD1cXFxccyooKD86W147XSg/ITspKSpbXjtdPykuKlwiXG5cdHJldHVybiB1bmVzY2FwZShkb2MuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChyZWdleHBTdHIpLCBcIiQxXCIpKVxufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdHZhciBjb29raWVzID0gZG9jLmNvb2tpZS5zcGxpdCgvOyA/L2cpXG5cdGZvciAodmFyIGkgPSBjb29raWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKCF0cmltKGNvb2tpZXNbaV0pKSB7XG5cdFx0XHRjb250aW51ZVxuXHRcdH1cblx0XHR2YXIga3ZwID0gY29va2llc1tpXS5zcGxpdCgnPScpXG5cdFx0dmFyIGtleSA9IHVuZXNjYXBlKGt2cFswXSlcblx0XHR2YXIgdmFsID0gdW5lc2NhcGUoa3ZwWzFdKVxuXHRcdGNhbGxiYWNrKHZhbCwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRpZigha2V5KSB7IHJldHVybiB9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPVwiICsgZXNjYXBlKGRhdGEpICsgXCI7IGV4cGlyZXM9VHVlLCAxOSBKYW4gMjAzOCAwMzoxNDowNyBHTVQ7IHBhdGg9L1wiXG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0aWYgKCFrZXkgfHwgIV9oYXMoa2V5KSkge1xuXHRcdHJldHVyblxuXHR9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIEdNVDsgcGF0aD0vXCJcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdGVhY2goZnVuY3Rpb24oXywga2V5KSB7XG5cdFx0cmVtb3ZlKGtleSlcblx0fSlcbn1cblxuZnVuY3Rpb24gX2hhcyhrZXkpIHtcblx0cmV0dXJuIChuZXcgUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiICsgZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgKyBcIlxcXFxzKlxcXFw9XCIpKS50ZXN0KGRvYy5jb29raWUpXG59XG4iLCIvLyBvbGRGRi1nbG9iYWxTdG9yYWdlIHByb3ZpZGVzIHN0b3JhZ2UgZm9yIEZpcmVmb3hcbi8vIHZlcnNpb25zIDYgYW5kIDcsIHdoZXJlIG5vIGxvY2FsU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkRkYtZ2xvYmFsU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIGdsb2JhbFN0b3JhZ2UgPSBHbG9iYWwuZ2xvYmFsU3RvcmFnZVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gZ2xvYmFsU3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRnbG9iYWxTdG9yYWdlW2tleV0gPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IGdsb2JhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gZ2xvYmFsU3RvcmFnZS5rZXkoaSlcblx0XHRmbihnbG9iYWxTdG9yYWdlW2tleV0sIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBnbG9iYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0ZWFjaChmdW5jdGlvbihrZXksIF8pIHtcblx0XHRkZWxldGUgZ2xvYmFsU3RvcmFnZVtrZXldXG5cdH0pXG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ2xvY2FsU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLmxvY2FsU3RvcmFnZVxufVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuZ2V0SXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZSgpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dmFyIGtleSA9IGxvY2FsU3RvcmFnZSgpLmtleShpKVxuXHRcdGZuKHJlYWQoa2V5KSwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLmNsZWFyKClcbn1cbiIsIi8vIG9sZElFLXVzZXJEYXRhU3RvcmFnZSBwcm92aWRlcyBzdG9yYWdlIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuLy8gdmVyc2lvbnMgNiBhbmQgNywgd2hlcmUgbm8gbG9jYWxTdG9yYWdlLCBzZXNzaW9uU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkSUUtdXNlckRhdGFTdG9yYWdlJyxcblx0d3JpdGU6IHdyaXRlLFxuXHRyZWFkOiByZWFkLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgc3RvcmFnZU5hbWUgPSAnc3RvcmVqcydcbnZhciBkb2MgPSBHbG9iYWwuZG9jdW1lbnRcbnZhciBfd2l0aFN0b3JhZ2VFbCA9IF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpXG52YXIgZGlzYWJsZSA9IChHbG9iYWwubmF2aWdhdG9yID8gR2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQgOiAnJykubWF0Y2goLyAoTVNJRSA4fE1TSUUgOXxNU0lFIDEwKVxcLi8pIC8vIE1TSUUgOS54LCBNU0lFIDEwLnhcblxuZnVuY3Rpb24gd3JpdGUodW5maXhlZEtleSwgZGF0YSkge1xuXHRpZiAoZGlzYWJsZSkgeyByZXR1cm4gfVxuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0c3RvcmFnZUVsLnNldEF0dHJpYnV0ZShmaXhlZEtleSwgZGF0YSlcblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuZnVuY3Rpb24gcmVhZCh1bmZpeGVkS2V5KSB7XG5cdGlmIChkaXNhYmxlKSB7IHJldHVybiB9XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHR2YXIgcmVzID0gbnVsbFxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRyZXMgPSBzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGZpeGVkS2V5KVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2ldXG5cdFx0XHRjYWxsYmFjayhzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGF0dHIubmFtZSksIGF0dHIubmFtZSlcblx0XHR9XG5cdH0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZSh1bmZpeGVkS2V5KSB7XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRzdG9yYWdlRWwucmVtb3ZlQXR0cmlidXRlKGZpeGVkS2V5KVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRzdG9yYWdlRWwubG9hZChzdG9yYWdlTmFtZSlcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0c3RvcmFnZUVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldLm5hbWUpXG5cdFx0fVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG4vLyBIZWxwZXJzXG4vLy8vLy8vLy8vXG5cbi8vIEluIElFNywga2V5cyBjYW5ub3Qgc3RhcnQgd2l0aCBhIGRpZ2l0IG9yIGNvbnRhaW4gY2VydGFpbiBjaGFycy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFyY3Vzd2VzdGluL3N0b3JlLmpzL2lzc3Vlcy80MFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjdXN3ZXN0aW4vc3RvcmUuanMvaXNzdWVzLzgzXG52YXIgZm9yYmlkZGVuQ2hhcnNSZWdleCA9IG5ldyBSZWdFeHAoXCJbIVxcXCIjJCUmJygpKissL1xcXFxcXFxcOjs8PT4/QFtcXFxcXV5ge3x9fl1cIiwgXCJnXCIpXG5mdW5jdGlvbiBmaXhLZXkoa2V5KSB7XG5cdHJldHVybiBrZXkucmVwbGFjZSgvXlxcZC8sICdfX18kJicpLnJlcGxhY2UoZm9yYmlkZGVuQ2hhcnNSZWdleCwgJ19fXycpXG59XG5cbmZ1bmN0aW9uIF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpIHtcblx0aWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3IpIHtcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cdHZhciBzY3JpcHRUYWcgPSAnc2NyaXB0Jyxcblx0XHRzdG9yYWdlT3duZXIsXG5cdFx0c3RvcmFnZUNvbnRhaW5lcixcblx0XHRzdG9yYWdlRWxcblxuXHQvLyBTaW5jZSAjdXNlckRhdGEgc3RvcmFnZSBhcHBsaWVzIG9ubHkgdG8gc3BlY2lmaWMgcGF0aHMsIHdlIG5lZWQgdG9cblx0Ly8gc29tZWhvdyBsaW5rIG91ciBkYXRhIHRvIGEgc3BlY2lmaWMgcGF0aC4gIFdlIGNob29zZSAvZmF2aWNvbi5pY29cblx0Ly8gYXMgYSBwcmV0dHkgc2FmZSBvcHRpb24sIHNpbmNlIGFsbCBicm93c2VycyBhbHJlYWR5IG1ha2UgYSByZXF1ZXN0IHRvXG5cdC8vIHRoaXMgVVJMIGFueXdheSBhbmQgYmVpbmcgYSA0MDQgd2lsbCBub3QgaHVydCB1cyBoZXJlLiAgV2Ugd3JhcCBhblxuXHQvLyBpZnJhbWUgcG9pbnRpbmcgdG8gdGhlIGZhdmljb24gaW4gYW4gQWN0aXZlWE9iamVjdChodG1sZmlsZSkgb2JqZWN0XG5cdC8vIChzZWU6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9hYTc1MjU3NCh2PVZTLjg1KS5hc3B4KVxuXHQvLyBzaW5jZSB0aGUgaWZyYW1lIGFjY2VzcyBydWxlcyBhcHBlYXIgdG8gYWxsb3cgZGlyZWN0IGFjY2VzcyBhbmRcblx0Ly8gbWFuaXB1bGF0aW9uIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LCBldmVuIGZvciBhIDQwNCBwYWdlLiAgVGhpc1xuXHQvLyBkb2N1bWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50ICh3aGljaCB3b3VsZFxuXHQvLyBoYXZlIGJlZW4gbGltaXRlZCB0byB0aGUgY3VycmVudCBwYXRoKSB0byBwZXJmb3JtICN1c2VyRGF0YSBzdG9yYWdlLlxuXHR0cnkge1xuXHRcdC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG5cdFx0c3RvcmFnZUNvbnRhaW5lciA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5vcGVuKClcblx0XHRzdG9yYWdlQ29udGFpbmVyLndyaXRlKCc8JytzY3JpcHRUYWcrJz5kb2N1bWVudC53PXdpbmRvdzwvJytzY3JpcHRUYWcrJz48aWZyYW1lIHNyYz1cIi9mYXZpY29uLmljb1wiPjwvaWZyYW1lPicpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5jbG9zZSgpXG5cdFx0c3RvcmFnZU93bmVyID0gc3RvcmFnZUNvbnRhaW5lci53LmZyYW1lc1swXS5kb2N1bWVudFxuXHRcdHN0b3JhZ2VFbCA9IHN0b3JhZ2VPd25lci5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHR9IGNhdGNoKGUpIHtcblx0XHQvLyBzb21laG93IEFjdGl2ZVhPYmplY3QgaW5zdGFudGlhdGlvbiBmYWlsZWQgKHBlcmhhcHMgc29tZSBzcGVjaWFsXG5cdFx0Ly8gc2VjdXJpdHkgc2V0dGluZ3Mgb3Igb3RoZXJ3c2UpLCBmYWxsIGJhY2sgdG8gcGVyLXBhdGggc3RvcmFnZVxuXHRcdHN0b3JhZ2VFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdHN0b3JhZ2VPd25lciA9IGRvYy5ib2R5XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oc3RvcmVGdW5jdGlvbikge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cdFx0YXJncy51bnNoaWZ0KHN0b3JhZ2VFbClcblx0XHQvLyBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMDgxKHY9VlMuODUpLmFzcHhcblx0XHQvLyBhbmQgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxNDI0KHY9VlMuODUpLmFzcHhcblx0XHRzdG9yYWdlT3duZXIuYXBwZW5kQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHN0b3JhZ2VFbC5hZGRCZWhhdmlvcignI2RlZmF1bHQjdXNlckRhdGEnKVxuXHRcdHN0b3JhZ2VFbC5sb2FkKHN0b3JhZ2VOYW1lKVxuXHRcdHN0b3JlRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncylcblx0XHRzdG9yYWdlT3duZXIucmVtb3ZlQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHJldHVyblxuXHR9XG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ3Nlc3Npb25TdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsXG59XG5cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLnNlc3Npb25TdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IHNlc3Npb25TdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gc2Vzc2lvblN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRpZF9yZXNvbHZlcl8xID0gcmVxdWlyZShcImRpZC1yZXNvbHZlclwiKTtcbnZhciBET0NfUEFUSCA9ICcvLndlbGwta25vd24vZGlkLmpzb24nO1xuZnVuY3Rpb24gZ2V0KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIGRlY2xhcmUgWE1MSHR0cFJlcXVlc3QgaW4gaGVyZSBzbyBpdCBjYW4gYmUgbW9ja2VkIGZvciB0ZXN0c1xuICAgICAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB3aW5kb3cuWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIDogcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKS5YTUxIdHRwUmVxdWVzdDtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKFwiSW52YWxpZCBodHRwIHJlc3BvbnNlIHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIgXCIgKyByZXF1ZXN0LnJlc3BvbnNlVGV4dCkudHJpbSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlKGRpZCwgcGFyc2VkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmwsIHJlc3BvbnNlLCBlcnJvcl8xLCBkYXRhLCBoYXNDb250ZXh0LCBkb2NJZE1hdGNoZXNEaWQsIGRvY0hhc1B1YmxpY0tleTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9cIiArIHBhcnNlZC5pZCArIERPQ19QQVRIO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0KHVybCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRElEIG11c3QgcmVzb2x2ZSB0byBhIHZhbGlkIGh0dHBzIFVSTDogXCIgKyBlcnJvcl8xLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgbXVzdCByZXNvbHZlIHRvIGEgSlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGV4dCA9IGRhdGFbJ0Bjb250ZXh0J10gPT09ICdodHRwczovL3czaWQub3JnL2RpZC92MSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgZG9jdW1lbnQgbWlzc2luZyBjb250ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NJZE1hdGNoZXNEaWQgPSBkYXRhLmlkID09PSBkaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY0lkTWF0Y2hlc0RpZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RJRCBkb2N1bWVudCBpZCBkb2VzIG5vdCBtYXRjaCByZXF1ZXN0ZWQgZGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NIYXNQdWJsaWNLZXkgPSBBcnJheS5pc0FycmF5KGRhdGEucHVibGljS2V5KSAmJiBkYXRhLnB1YmxpY0tleS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NIYXNQdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdESUQgZG9jdW1lbnQgaGFzIG5vIHB1YmxpYyBrZXlzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaWRfcmVzb2x2ZXJfMS5yZWdpc3Rlck1ldGhvZCgnaHR0cHMnLCByZXNvbHZlKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHJlZ2lzdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kaWRSZXNvbHZlciA9IHJlcXVpcmUoXCJkaWQtcmVzb2x2ZXJcIik7XG5cbnZhciBfbm9kZUZldGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5cbnZhciBJTkZVUkEgPSAnaHR0cHM6Ly9pcGZzLmluZnVyYS5pby9pcGZzLyc7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKGlwZnMpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc29sdmUoX3gsIF94Mikge1xuICAgIHJldHVybiBfcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgX3Jlc29sdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRpZCwgcGFyc2VkKSB7XG4gICAgICB2YXIgZG9jO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaE11UG9ydERvYyhpcGZzLCBwYXJzZWQuaWQpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGRvYyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgd3JhcERvY3VtZW50KGRpZCwgZG9jKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3Jlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfZGlkUmVzb2x2ZXIucmVnaXN0ZXJNZXRob2QpKCdtdXBvcnQnLCByZXNvbHZlKTtcbn1cblxuZnVuY3Rpb24gZmV0Y2hNdVBvcnREb2MoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9mZXRjaE11UG9ydERvYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hNdVBvcnREb2MoKSB7XG4gIF9mZXRjaE11UG9ydERvYyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoaXBmcywgaXBmc0hhc2gpIHtcbiAgICB2YXIgZG9jO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIWlwZnMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gSlNPTjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiBpcGZzLmNhdChpcGZzSGFzaCk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDIudDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi50MS5wYXJzZS5jYWxsKF9jb250ZXh0Mi50MSwgX2NvbnRleHQyLnQyKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gaHR0cEZldGNoKGlwZnNIYXNoKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBkb2MgPSBfY29udGV4dDIudDA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MyA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGlmICghKCFkb2MgfHwgZG9jLnZlcnNpb24gIT09IDEgfHwgIWRvYy5zaWduaW5nS2V5IHx8ICFkb2MubWFuYWdlbWVudEtleSB8fCAhZG9jLmFzeW1FbmNyeXB0aW9uS2V5KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGlwZnMpIGlwZnMucGluLnJtKGlwZnNIYXNoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtdXBvcnQgZGlkJyk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZG9jKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1swLCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZldGNoTXVQb3J0RG9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGh0dHBGZXRjaChfeDUpIHtcbiAgcmV0dXJuIF9odHRwRmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2h0dHBGZXRjaCgpIHtcbiAgX2h0dHBGZXRjaCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoY2lkKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9ub2RlRmV0Y2hbXCJkZWZhdWx0XCJdKShJTkZVUkEgKyBjaWQpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQuanNvbigpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuICByZXR1cm4gX2h0dHBGZXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3cmFwRG9jdW1lbnQoZGlkLCBtdXBvcnREb2N1bWVudCkge1xuICB2YXIgZG9jID0ge1xuICAgIFwiQGNvbnRleHRcIjogXCJodHRwczovL3czaWQub3JnL2RpZC92MVwiLFxuICAgIFwiaWRcIjogZGlkLFxuICAgIFwicHVibGljS2V5XCI6IFt7XG4gICAgICBcImlkXCI6IGRpZCArIFwiI3NpZ25pbmdLZXlcIixcbiAgICAgIFwidHlwZVwiOiBcIlNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMThcIixcbiAgICAgIFwib3duZXJcIjogZGlkLFxuICAgICAgXCJwdWJsaWNLZXlIZXhcIjogbXVwb3J0RG9jdW1lbnQuc2lnbmluZ0tleVxuICAgIH0sIHtcbiAgICAgIFwiaWRcIjogZGlkICsgXCIjbWFuYWdlbWVudEtleVwiLFxuICAgICAgXCJ0eXBlXCI6IFwiU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOFwiLFxuICAgICAgXCJvd25lclwiOiBkaWRcbiAgICB9LCB7XG4gICAgICBcImlkXCI6IGRpZCArIFwiI2VuY3J5cHRpb25LZXlcIixcbiAgICAgIFwidHlwZVwiOiBcIkN1cnZlMjU1MTlFbmNyeXB0aW9uUHVibGljS2V5XCIsXG4gICAgICBcIm93bmVyXCI6IGRpZCxcbiAgICAgIFwicHVibGljS2V5QmFzZTY0XCI6IG11cG9ydERvY3VtZW50LmFzeW1FbmNyeXB0aW9uS2V5XG4gICAgfV0sXG4gICAgXCJhdXRoZW50aWNhdGlvblwiOiBbe1xuICAgICAgXCJ0eXBlXCI6IFwiU2VjcDI1NmsxU2lnbmF0dXJlQXV0aGVudGljYXRpb24yMDE4XCIsXG4gICAgICBcInB1YmxpY0tleVwiOiBkaWQgKyBcIiNzaWduaW5nS2V5XCJcbiAgICB9XSxcbiAgICBcIm11cG9ydERhdGFcIjoge31cbiAgfTtcblxuICBpZiAobXVwb3J0RG9jdW1lbnQubWFuYWdlbWVudEtleS5sZW5ndGggPT09IDQyKSB7XG4gICAgZG9jLnB1YmxpY0tleVsxXS5ldGhlcmV1bUFkZHJlc3MgPSBtdXBvcnREb2N1bWVudC5tYW5hZ2VtZW50S2V5O1xuICB9IGVsc2Uge1xuICAgIGRvYy5wdWJsaWNLZXlbMV0ucHVibGljS2V5SGV4ID0gbXVwb3J0RG9jdW1lbnQubWFuYWdlbWVudEtleTtcbiAgfVxuXG4gIGlmIChtdXBvcnREb2N1bWVudC5wdWJsaWNQcm9maWxlKSBkb2MudXBvcnRQcm9maWxlID0gbXVwb3J0RG9jdW1lbnQucHVibGljUHJvZmlsZTtcbiAgaWYgKG11cG9ydERvY3VtZW50LnN5bUVuY3J5cHRlZERhdGEpIGRvYy5tdXBvcnREYXRhLnN5bUVuY3J5cHRlZERhdGEgPSBtdXBvcnREb2N1bWVudC5zeW1FbmNyeXB0ZWREYXRhO1xuICBpZiAobXVwb3J0RG9jdW1lbnQucmVjb3ZlcnlOZXR3b3JrKSBkb2MubXVwb3J0RGF0YS5yZWNvdmVyeU5ldHdvcmsgPSBtdXBvcnREb2N1bWVudC5yZWNvdmVyeU5ldHdvcms7XG4gIHJldHVybiBkb2M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDbGllbnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xpZW50RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xpZW50RXJyb3IocmVzcG9uc2UsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBDbGllbnRFcnJvci5leHRyYWN0TWVzc2FnZShyZXNwb25zZSkgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeSh7IHJlc3BvbnNlOiByZXNwb25zZSwgcmVxdWVzdDogcmVxdWVzdCB9KTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgYXMgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCAuY2FwdHVyZVN0YWNrVHJhY2VcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDbGllbnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGllbnRFcnJvci5leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmVycm9yc1swXS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJHcmFwaFFMIEVycm9yIChDb2RlOiBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkNsaWVudEVycm9yID0gQ2xpZW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCIoZnVuY3Rpb24oc2VsZikge1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0JztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJyk7XG4gICAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1cztcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJztcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJyc7XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpO1xuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfTtcblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pO1xuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InO1xuICAgIHJldHVybiByZXNwb25zZVxuICB9O1xuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTtcblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9O1xuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9O1xuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4vKiBlc2xpbnQga2V5LXNwYWNpbmc6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMubmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogICAweDAsXG4gICdzaGExJzogICAgICAgMHgxMSxcbiAgJ3NoYTItMjU2JzogICAweDEyLFxuICAnc2hhMi01MTInOiAgIDB4MTMsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAnc2hhMy0yMjQnOiAgIDB4MTcsXG4gICdzaGEzLTI1Nic6ICAgMHgxNixcbiAgJ3NoYTMtMzg0JzogICAweDE1LFxuICAnc2hhMy01MTInOiAgIDB4MTQsXG4gICdzaGFrZS0xMjgnOiAgMHgxOCxcbiAgJ3NoYWtlLTI1Nic6ICAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MUEsXG4gICdrZWNjYWstMjU2JzogMHgxQixcbiAgJ2tlY2Nhay0zODQnOiAweDFDLFxuICAna2VjY2FrLTUxMic6IDB4MUQsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogIDB4MjMsXG4gICdibGFrZTJiLTgnOiAgIDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAgMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6ICAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogIDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAgMHhiMjA1LFxuICAnYmxha2UyYi00OCc6ICAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogIDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAgMHhiMjA4LFxuICAnYmxha2UyYi03Mic6ICAweGIyMDksXG4gICdibGFrZTJiLTgwJzogIDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAgMHhiMjBiLFxuICAnYmxha2UyYi05Nic6ICAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6ICAgMHhiMjQxLFxuICAnYmxha2Uycy0xNic6ICAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogIDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAgMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6ICAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogIDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAgMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6ICAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogIDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAgMHhiMjRhLFxuICAnYmxha2Uycy04OCc6ICAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogIDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdTa2VpbjI1Ni04JzogMHhiMzAxLFxuICAnU2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdTa2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ1NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnU2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdTa2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ1NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnU2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdTa2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ1NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnU2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdTa2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ1NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ1NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ1NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ1NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ1NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ1NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ1NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ1NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ1NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ1NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ1NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ1NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ1NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ1NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ1NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ1NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ1NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ1NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ1NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ1NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ1NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdTa2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ1NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnU2tlaW41MTItMzInOiAweGIzMjQsXG4gICdTa2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ1NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnU2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdTa2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ1NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnU2tlaW41MTItODAnOiAweGIzMmEsXG4gICdTa2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ1NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnU2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnU2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnU2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnU2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnU2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnU2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnU2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnU2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnU2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnU2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnU2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnU2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnU2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnU2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnU2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnU2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnU2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnU2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnU2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnU2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnU2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnU2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnU2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnU2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnU2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnU2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnU2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnU2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnU2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnU2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnU2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnU2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnU2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnU2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnU2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnU2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnU2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnU2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnU2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnU2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnU2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnU2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnU2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnU2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnU2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnU2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnU2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnU2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnU2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnU2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnU2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnU2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnU2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdTa2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdTa2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdTa2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdTa2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdTa2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdTa2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdTa2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdTa2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdTa2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdTa2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdTa2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdTa2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnU2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ1NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdTa2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnU2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ1NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdTa2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnU2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ1NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdTa2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnU2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ1NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdTa2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnU2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ1NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdTa2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnU2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ1NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdTa2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnU2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ1NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdTa2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnU2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ1NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdTa2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnU2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ1NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdTa2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnU2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ1NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdTa2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnU2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ1NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdTa2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnU2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ1NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdTa2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnU2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ1NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdTa2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnU2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ1NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdTa2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnU2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ1NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdTa2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnU2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ1NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdTa2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnU2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ1NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdTa2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnU2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ1NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdTa2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnU2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ1NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdTa2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnU2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ1NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdTa2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnU2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ1NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdTa2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnU2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ1NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdTa2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnU2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ1NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdTa2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnU2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ1NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdTa2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnU2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ1NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdTa2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnU2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ1NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdTa2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnU2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ1NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdTa2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnU2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ1NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdTa2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnU2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ1NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdTa2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnU2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ1NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdTa2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnU2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ1NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdTa2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnU2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ1NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdTa2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnU2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ1NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdTa2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnU2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ1NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdTa2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnU2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ1NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdTa2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnU2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ1NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdTa2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnU2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ1NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdTa2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnU2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdTa2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ1NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnU2tlaW4xMDI0LTEwMjQnOiAweGIzZTBcbn0pXG5cbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgMHgwOiAnaWRlbnRpdHknLFxuXG4gIC8vIHNoYSBmYW1pbHlcbiAgMHgxMTogJ3NoYTEnLFxuICAweDEyOiAnc2hhMi0yNTYnLFxuICAweDEzOiAnc2hhMi01MTInLFxuICAweDU2OiAnZGJsLXNoYTItMjU2JyxcbiAgMHgxNzogJ3NoYTMtMjI0JyxcbiAgMHgxNjogJ3NoYTMtMjU2JyxcbiAgMHgxNTogJ3NoYTMtMzg0JyxcbiAgMHgxNDogJ3NoYTMtNTEyJyxcbiAgMHgxODogJ3NoYWtlLTEyOCcsXG4gIDB4MTk6ICdzaGFrZS0yNTYnLFxuICAweDFBOiAna2VjY2FrLTIyNCcsXG4gIDB4MUI6ICdrZWNjYWstMjU2JyxcbiAgMHgxQzogJ2tlY2Nhay0zODQnLFxuICAweDFEOiAna2VjY2FrLTUxMicsXG5cbiAgMHgyMjogJ211cm11cjMtMTI4JyxcbiAgMHgyMzogJ211cm11cjMtMzInLFxuXG4gIC8vIGJsYWtlMlxuICAweGIyMDE6ICdibGFrZTJiLTgnLFxuICAweGIyMDI6ICdibGFrZTJiLTE2JyxcbiAgMHhiMjAzOiAnYmxha2UyYi0yNCcsXG4gIDB4YjIwNDogJ2JsYWtlMmItMzInLFxuICAweGIyMDU6ICdibGFrZTJiLTQwJyxcbiAgMHhiMjA2OiAnYmxha2UyYi00OCcsXG4gIDB4YjIwNzogJ2JsYWtlMmItNTYnLFxuICAweGIyMDg6ICdibGFrZTJiLTY0JyxcbiAgMHhiMjA5OiAnYmxha2UyYi03MicsXG4gIDB4YjIwYTogJ2JsYWtlMmItODAnLFxuICAweGIyMGI6ICdibGFrZTJiLTg4JyxcbiAgMHhiMjBjOiAnYmxha2UyYi05NicsXG4gIDB4YjIwZDogJ2JsYWtlMmItMTA0JyxcbiAgMHhiMjBlOiAnYmxha2UyYi0xMTInLFxuICAweGIyMGY6ICdibGFrZTJiLTEyMCcsXG4gIDB4YjIxMDogJ2JsYWtlMmItMTI4JyxcbiAgMHhiMjExOiAnYmxha2UyYi0xMzYnLFxuICAweGIyMTI6ICdibGFrZTJiLTE0NCcsXG4gIDB4YjIxMzogJ2JsYWtlMmItMTUyJyxcbiAgMHhiMjE0OiAnYmxha2UyYi0xNjAnLFxuICAweGIyMTU6ICdibGFrZTJiLTE2OCcsXG4gIDB4YjIxNjogJ2JsYWtlMmItMTc2JyxcbiAgMHhiMjE3OiAnYmxha2UyYi0xODQnLFxuICAweGIyMTg6ICdibGFrZTJiLTE5MicsXG4gIDB4YjIxOTogJ2JsYWtlMmItMjAwJyxcbiAgMHhiMjFhOiAnYmxha2UyYi0yMDgnLFxuICAweGIyMWI6ICdibGFrZTJiLTIxNicsXG4gIDB4YjIxYzogJ2JsYWtlMmItMjI0JyxcbiAgMHhiMjFkOiAnYmxha2UyYi0yMzInLFxuICAweGIyMWU6ICdibGFrZTJiLTI0MCcsXG4gIDB4YjIxZjogJ2JsYWtlMmItMjQ4JyxcbiAgMHhiMjIwOiAnYmxha2UyYi0yNTYnLFxuICAweGIyMjE6ICdibGFrZTJiLTI2NCcsXG4gIDB4YjIyMjogJ2JsYWtlMmItMjcyJyxcbiAgMHhiMjIzOiAnYmxha2UyYi0yODAnLFxuICAweGIyMjQ6ICdibGFrZTJiLTI4OCcsXG4gIDB4YjIyNTogJ2JsYWtlMmItMjk2JyxcbiAgMHhiMjI2OiAnYmxha2UyYi0zMDQnLFxuICAweGIyMjc6ICdibGFrZTJiLTMxMicsXG4gIDB4YjIyODogJ2JsYWtlMmItMzIwJyxcbiAgMHhiMjI5OiAnYmxha2UyYi0zMjgnLFxuICAweGIyMmE6ICdibGFrZTJiLTMzNicsXG4gIDB4YjIyYjogJ2JsYWtlMmItMzQ0JyxcbiAgMHhiMjJjOiAnYmxha2UyYi0zNTInLFxuICAweGIyMmQ6ICdibGFrZTJiLTM2MCcsXG4gIDB4YjIyZTogJ2JsYWtlMmItMzY4JyxcbiAgMHhiMjJmOiAnYmxha2UyYi0zNzYnLFxuICAweGIyMzA6ICdibGFrZTJiLTM4NCcsXG4gIDB4YjIzMTogJ2JsYWtlMmItMzkyJyxcbiAgMHhiMjMyOiAnYmxha2UyYi00MDAnLFxuICAweGIyMzM6ICdibGFrZTJiLTQwOCcsXG4gIDB4YjIzNDogJ2JsYWtlMmItNDE2JyxcbiAgMHhiMjM1OiAnYmxha2UyYi00MjQnLFxuICAweGIyMzY6ICdibGFrZTJiLTQzMicsXG4gIDB4YjIzNzogJ2JsYWtlMmItNDQwJyxcbiAgMHhiMjM4OiAnYmxha2UyYi00NDgnLFxuICAweGIyMzk6ICdibGFrZTJiLTQ1NicsXG4gIDB4YjIzYTogJ2JsYWtlMmItNDY0JyxcbiAgMHhiMjNiOiAnYmxha2UyYi00NzInLFxuICAweGIyM2M6ICdibGFrZTJiLTQ4MCcsXG4gIDB4YjIzZDogJ2JsYWtlMmItNDg4JyxcbiAgMHhiMjNlOiAnYmxha2UyYi00OTYnLFxuICAweGIyM2Y6ICdibGFrZTJiLTUwNCcsXG4gIDB4YjI0MDogJ2JsYWtlMmItNTEyJyxcbiAgMHhiMjQxOiAnYmxha2Uycy04JyxcbiAgMHhiMjQyOiAnYmxha2Uycy0xNicsXG4gIDB4YjI0MzogJ2JsYWtlMnMtMjQnLFxuICAweGIyNDQ6ICdibGFrZTJzLTMyJyxcbiAgMHhiMjQ1OiAnYmxha2Uycy00MCcsXG4gIDB4YjI0NjogJ2JsYWtlMnMtNDgnLFxuICAweGIyNDc6ICdibGFrZTJzLTU2JyxcbiAgMHhiMjQ4OiAnYmxha2Uycy02NCcsXG4gIDB4YjI0OTogJ2JsYWtlMnMtNzInLFxuICAweGIyNGE6ICdibGFrZTJzLTgwJyxcbiAgMHhiMjRiOiAnYmxha2Uycy04OCcsXG4gIDB4YjI0YzogJ2JsYWtlMnMtOTYnLFxuICAweGIyNGQ6ICdibGFrZTJzLTEwNCcsXG4gIDB4YjI0ZTogJ2JsYWtlMnMtMTEyJyxcbiAgMHhiMjRmOiAnYmxha2Uycy0xMjAnLFxuICAweGIyNTA6ICdibGFrZTJzLTEyOCcsXG4gIDB4YjI1MTogJ2JsYWtlMnMtMTM2JyxcbiAgMHhiMjUyOiAnYmxha2Uycy0xNDQnLFxuICAweGIyNTM6ICdibGFrZTJzLTE1MicsXG4gIDB4YjI1NDogJ2JsYWtlMnMtMTYwJyxcbiAgMHhiMjU1OiAnYmxha2Uycy0xNjgnLFxuICAweGIyNTY6ICdibGFrZTJzLTE3NicsXG4gIDB4YjI1NzogJ2JsYWtlMnMtMTg0JyxcbiAgMHhiMjU4OiAnYmxha2Uycy0xOTInLFxuICAweGIyNTk6ICdibGFrZTJzLTIwMCcsXG4gIDB4YjI1YTogJ2JsYWtlMnMtMjA4JyxcbiAgMHhiMjViOiAnYmxha2Uycy0yMTYnLFxuICAweGIyNWM6ICdibGFrZTJzLTIyNCcsXG4gIDB4YjI1ZDogJ2JsYWtlMnMtMjMyJyxcbiAgMHhiMjVlOiAnYmxha2Uycy0yNDAnLFxuICAweGIyNWY6ICdibGFrZTJzLTI0OCcsXG4gIDB4YjI2MDogJ2JsYWtlMnMtMjU2JyxcblxuICAvLyBza2VpblxuICAweGIzMDE6ICdTa2VpbjI1Ni04JyxcbiAgMHhiMzAyOiAnU2tlaW4yNTYtMTYnLFxuICAweGIzMDM6ICdTa2VpbjI1Ni0yNCcsXG4gIDB4YjMwNDogJ1NrZWluMjU2LTMyJyxcbiAgMHhiMzA1OiAnU2tlaW4yNTYtNDAnLFxuICAweGIzMDY6ICdTa2VpbjI1Ni00OCcsXG4gIDB4YjMwNzogJ1NrZWluMjU2LTU2JyxcbiAgMHhiMzA4OiAnU2tlaW4yNTYtNjQnLFxuICAweGIzMDk6ICdTa2VpbjI1Ni03MicsXG4gIDB4YjMwYTogJ1NrZWluMjU2LTgwJyxcbiAgMHhiMzBiOiAnU2tlaW4yNTYtODgnLFxuICAweGIzMGM6ICdTa2VpbjI1Ni05NicsXG4gIDB4YjMwZDogJ1NrZWluMjU2LTEwNCcsXG4gIDB4YjMwZTogJ1NrZWluMjU2LTExMicsXG4gIDB4YjMwZjogJ1NrZWluMjU2LTEyMCcsXG4gIDB4YjMxMDogJ1NrZWluMjU2LTEyOCcsXG4gIDB4YjMxMTogJ1NrZWluMjU2LTEzNicsXG4gIDB4YjMxMjogJ1NrZWluMjU2LTE0NCcsXG4gIDB4YjMxMzogJ1NrZWluMjU2LTE1MicsXG4gIDB4YjMxNDogJ1NrZWluMjU2LTE2MCcsXG4gIDB4YjMxNTogJ1NrZWluMjU2LTE2OCcsXG4gIDB4YjMxNjogJ1NrZWluMjU2LTE3NicsXG4gIDB4YjMxNzogJ1NrZWluMjU2LTE4NCcsXG4gIDB4YjMxODogJ1NrZWluMjU2LTE5MicsXG4gIDB4YjMxOTogJ1NrZWluMjU2LTIwMCcsXG4gIDB4YjMxYTogJ1NrZWluMjU2LTIwOCcsXG4gIDB4YjMxYjogJ1NrZWluMjU2LTIxNicsXG4gIDB4YjMxYzogJ1NrZWluMjU2LTIyNCcsXG4gIDB4YjMxZDogJ1NrZWluMjU2LTIzMicsXG4gIDB4YjMxZTogJ1NrZWluMjU2LTI0MCcsXG4gIDB4YjMxZjogJ1NrZWluMjU2LTI0OCcsXG4gIDB4YjMyMDogJ1NrZWluMjU2LTI1NicsXG4gIDB4YjMyMTogJ1NrZWluNTEyLTgnLFxuICAweGIzMjI6ICdTa2VpbjUxMi0xNicsXG4gIDB4YjMyMzogJ1NrZWluNTEyLTI0JyxcbiAgMHhiMzI0OiAnU2tlaW41MTItMzInLFxuICAweGIzMjU6ICdTa2VpbjUxMi00MCcsXG4gIDB4YjMyNjogJ1NrZWluNTEyLTQ4JyxcbiAgMHhiMzI3OiAnU2tlaW41MTItNTYnLFxuICAweGIzMjg6ICdTa2VpbjUxMi02NCcsXG4gIDB4YjMyOTogJ1NrZWluNTEyLTcyJyxcbiAgMHhiMzJhOiAnU2tlaW41MTItODAnLFxuICAweGIzMmI6ICdTa2VpbjUxMi04OCcsXG4gIDB4YjMyYzogJ1NrZWluNTEyLTk2JyxcbiAgMHhiMzJkOiAnU2tlaW41MTItMTA0JyxcbiAgMHhiMzJlOiAnU2tlaW41MTItMTEyJyxcbiAgMHhiMzJmOiAnU2tlaW41MTItMTIwJyxcbiAgMHhiMzMwOiAnU2tlaW41MTItMTI4JyxcbiAgMHhiMzMxOiAnU2tlaW41MTItMTM2JyxcbiAgMHhiMzMyOiAnU2tlaW41MTItMTQ0JyxcbiAgMHhiMzMzOiAnU2tlaW41MTItMTUyJyxcbiAgMHhiMzM0OiAnU2tlaW41MTItMTYwJyxcbiAgMHhiMzM1OiAnU2tlaW41MTItMTY4JyxcbiAgMHhiMzM2OiAnU2tlaW41MTItMTc2JyxcbiAgMHhiMzM3OiAnU2tlaW41MTItMTg0JyxcbiAgMHhiMzM4OiAnU2tlaW41MTItMTkyJyxcbiAgMHhiMzM5OiAnU2tlaW41MTItMjAwJyxcbiAgMHhiMzNhOiAnU2tlaW41MTItMjA4JyxcbiAgMHhiMzNiOiAnU2tlaW41MTItMjE2JyxcbiAgMHhiMzNjOiAnU2tlaW41MTItMjI0JyxcbiAgMHhiMzNkOiAnU2tlaW41MTItMjMyJyxcbiAgMHhiMzNlOiAnU2tlaW41MTItMjQwJyxcbiAgMHhiMzNmOiAnU2tlaW41MTItMjQ4JyxcbiAgMHhiMzQwOiAnU2tlaW41MTItMjU2JyxcbiAgMHhiMzQxOiAnU2tlaW41MTItMjY0JyxcbiAgMHhiMzQyOiAnU2tlaW41MTItMjcyJyxcbiAgMHhiMzQzOiAnU2tlaW41MTItMjgwJyxcbiAgMHhiMzQ0OiAnU2tlaW41MTItMjg4JyxcbiAgMHhiMzQ1OiAnU2tlaW41MTItMjk2JyxcbiAgMHhiMzQ2OiAnU2tlaW41MTItMzA0JyxcbiAgMHhiMzQ3OiAnU2tlaW41MTItMzEyJyxcbiAgMHhiMzQ4OiAnU2tlaW41MTItMzIwJyxcbiAgMHhiMzQ5OiAnU2tlaW41MTItMzI4JyxcbiAgMHhiMzRhOiAnU2tlaW41MTItMzM2JyxcbiAgMHhiMzRiOiAnU2tlaW41MTItMzQ0JyxcbiAgMHhiMzRjOiAnU2tlaW41MTItMzUyJyxcbiAgMHhiMzRkOiAnU2tlaW41MTItMzYwJyxcbiAgMHhiMzRlOiAnU2tlaW41MTItMzY4JyxcbiAgMHhiMzRmOiAnU2tlaW41MTItMzc2JyxcbiAgMHhiMzUwOiAnU2tlaW41MTItMzg0JyxcbiAgMHhiMzUxOiAnU2tlaW41MTItMzkyJyxcbiAgMHhiMzUyOiAnU2tlaW41MTItNDAwJyxcbiAgMHhiMzUzOiAnU2tlaW41MTItNDA4JyxcbiAgMHhiMzU0OiAnU2tlaW41MTItNDE2JyxcbiAgMHhiMzU1OiAnU2tlaW41MTItNDI0JyxcbiAgMHhiMzU2OiAnU2tlaW41MTItNDMyJyxcbiAgMHhiMzU3OiAnU2tlaW41MTItNDQwJyxcbiAgMHhiMzU4OiAnU2tlaW41MTItNDQ4JyxcbiAgMHhiMzU5OiAnU2tlaW41MTItNDU2JyxcbiAgMHhiMzVhOiAnU2tlaW41MTItNDY0JyxcbiAgMHhiMzViOiAnU2tlaW41MTItNDcyJyxcbiAgMHhiMzVjOiAnU2tlaW41MTItNDgwJyxcbiAgMHhiMzVkOiAnU2tlaW41MTItNDg4JyxcbiAgMHhiMzVlOiAnU2tlaW41MTItNDk2JyxcbiAgMHhiMzVmOiAnU2tlaW41MTItNTA0JyxcbiAgMHhiMzYwOiAnU2tlaW41MTItNTEyJyxcbiAgMHhiMzYxOiAnU2tlaW4xMDI0LTgnLFxuICAweGIzNjI6ICdTa2VpbjEwMjQtMTYnLFxuICAweGIzNjM6ICdTa2VpbjEwMjQtMjQnLFxuICAweGIzNjQ6ICdTa2VpbjEwMjQtMzInLFxuICAweGIzNjU6ICdTa2VpbjEwMjQtNDAnLFxuICAweGIzNjY6ICdTa2VpbjEwMjQtNDgnLFxuICAweGIzNjc6ICdTa2VpbjEwMjQtNTYnLFxuICAweGIzNjg6ICdTa2VpbjEwMjQtNjQnLFxuICAweGIzNjk6ICdTa2VpbjEwMjQtNzInLFxuICAweGIzNmE6ICdTa2VpbjEwMjQtODAnLFxuICAweGIzNmI6ICdTa2VpbjEwMjQtODgnLFxuICAweGIzNmM6ICdTa2VpbjEwMjQtOTYnLFxuICAweGIzNmQ6ICdTa2VpbjEwMjQtMTA0JyxcbiAgMHhiMzZlOiAnU2tlaW4xMDI0LTExMicsXG4gIDB4YjM2ZjogJ1NrZWluMTAyNC0xMjAnLFxuICAweGIzNzA6ICdTa2VpbjEwMjQtMTI4JyxcbiAgMHhiMzcxOiAnU2tlaW4xMDI0LTEzNicsXG4gIDB4YjM3MjogJ1NrZWluMTAyNC0xNDQnLFxuICAweGIzNzM6ICdTa2VpbjEwMjQtMTUyJyxcbiAgMHhiMzc0OiAnU2tlaW4xMDI0LTE2MCcsXG4gIDB4YjM3NTogJ1NrZWluMTAyNC0xNjgnLFxuICAweGIzNzY6ICdTa2VpbjEwMjQtMTc2JyxcbiAgMHhiMzc3OiAnU2tlaW4xMDI0LTE4NCcsXG4gIDB4YjM3ODogJ1NrZWluMTAyNC0xOTInLFxuICAweGIzNzk6ICdTa2VpbjEwMjQtMjAwJyxcbiAgMHhiMzdhOiAnU2tlaW4xMDI0LTIwOCcsXG4gIDB4YjM3YjogJ1NrZWluMTAyNC0yMTYnLFxuICAweGIzN2M6ICdTa2VpbjEwMjQtMjI0JyxcbiAgMHhiMzdkOiAnU2tlaW4xMDI0LTIzMicsXG4gIDB4YjM3ZTogJ1NrZWluMTAyNC0yNDAnLFxuICAweGIzN2Y6ICdTa2VpbjEwMjQtMjQ4JyxcbiAgMHhiMzgwOiAnU2tlaW4xMDI0LTI1NicsXG4gIDB4YjM4MTogJ1NrZWluMTAyNC0yNjQnLFxuICAweGIzODI6ICdTa2VpbjEwMjQtMjcyJyxcbiAgMHhiMzgzOiAnU2tlaW4xMDI0LTI4MCcsXG4gIDB4YjM4NDogJ1NrZWluMTAyNC0yODgnLFxuICAweGIzODU6ICdTa2VpbjEwMjQtMjk2JyxcbiAgMHhiMzg2OiAnU2tlaW4xMDI0LTMwNCcsXG4gIDB4YjM4NzogJ1NrZWluMTAyNC0zMTInLFxuICAweGIzODg6ICdTa2VpbjEwMjQtMzIwJyxcbiAgMHhiMzg5OiAnU2tlaW4xMDI0LTMyOCcsXG4gIDB4YjM4YTogJ1NrZWluMTAyNC0zMzYnLFxuICAweGIzOGI6ICdTa2VpbjEwMjQtMzQ0JyxcbiAgMHhiMzhjOiAnU2tlaW4xMDI0LTM1MicsXG4gIDB4YjM4ZDogJ1NrZWluMTAyNC0zNjAnLFxuICAweGIzOGU6ICdTa2VpbjEwMjQtMzY4JyxcbiAgMHhiMzhmOiAnU2tlaW4xMDI0LTM3NicsXG4gIDB4YjM5MDogJ1NrZWluMTAyNC0zODQnLFxuICAweGIzOTE6ICdTa2VpbjEwMjQtMzkyJyxcbiAgMHhiMzkyOiAnU2tlaW4xMDI0LTQwMCcsXG4gIDB4YjM5MzogJ1NrZWluMTAyNC00MDgnLFxuICAweGIzOTQ6ICdTa2VpbjEwMjQtNDE2JyxcbiAgMHhiMzk1OiAnU2tlaW4xMDI0LTQyNCcsXG4gIDB4YjM5NjogJ1NrZWluMTAyNC00MzInLFxuICAweGIzOTc6ICdTa2VpbjEwMjQtNDQwJyxcbiAgMHhiMzk4OiAnU2tlaW4xMDI0LTQ0OCcsXG4gIDB4YjM5OTogJ1NrZWluMTAyNC00NTYnLFxuICAweGIzOWE6ICdTa2VpbjEwMjQtNDY0JyxcbiAgMHhiMzliOiAnU2tlaW4xMDI0LTQ3MicsXG4gIDB4YjM5YzogJ1NrZWluMTAyNC00ODAnLFxuICAweGIzOWQ6ICdTa2VpbjEwMjQtNDg4JyxcbiAgMHhiMzllOiAnU2tlaW4xMDI0LTQ5NicsXG4gIDB4YjM5ZjogJ1NrZWluMTAyNC01MDQnLFxuICAweGIzYTA6ICdTa2VpbjEwMjQtNTEyJyxcbiAgMHhiM2ExOiAnU2tlaW4xMDI0LTUyMCcsXG4gIDB4YjNhMjogJ1NrZWluMTAyNC01MjgnLFxuICAweGIzYTM6ICdTa2VpbjEwMjQtNTM2JyxcbiAgMHhiM2E0OiAnU2tlaW4xMDI0LTU0NCcsXG4gIDB4YjNhNTogJ1NrZWluMTAyNC01NTInLFxuICAweGIzYTY6ICdTa2VpbjEwMjQtNTYwJyxcbiAgMHhiM2E3OiAnU2tlaW4xMDI0LTU2OCcsXG4gIDB4YjNhODogJ1NrZWluMTAyNC01NzYnLFxuICAweGIzYTk6ICdTa2VpbjEwMjQtNTg0JyxcbiAgMHhiM2FhOiAnU2tlaW4xMDI0LTU5MicsXG4gIDB4YjNhYjogJ1NrZWluMTAyNC02MDAnLFxuICAweGIzYWM6ICdTa2VpbjEwMjQtNjA4JyxcbiAgMHhiM2FkOiAnU2tlaW4xMDI0LTYxNicsXG4gIDB4YjNhZTogJ1NrZWluMTAyNC02MjQnLFxuICAweGIzYWY6ICdTa2VpbjEwMjQtNjMyJyxcbiAgMHhiM2IwOiAnU2tlaW4xMDI0LTY0MCcsXG4gIDB4YjNiMTogJ1NrZWluMTAyNC02NDgnLFxuICAweGIzYjI6ICdTa2VpbjEwMjQtNjU2JyxcbiAgMHhiM2IzOiAnU2tlaW4xMDI0LTY2NCcsXG4gIDB4YjNiNDogJ1NrZWluMTAyNC02NzInLFxuICAweGIzYjU6ICdTa2VpbjEwMjQtNjgwJyxcbiAgMHhiM2I2OiAnU2tlaW4xMDI0LTY4OCcsXG4gIDB4YjNiNzogJ1NrZWluMTAyNC02OTYnLFxuICAweGIzYjg6ICdTa2VpbjEwMjQtNzA0JyxcbiAgMHhiM2I5OiAnU2tlaW4xMDI0LTcxMicsXG4gIDB4YjNiYTogJ1NrZWluMTAyNC03MjAnLFxuICAweGIzYmI6ICdTa2VpbjEwMjQtNzI4JyxcbiAgMHhiM2JjOiAnU2tlaW4xMDI0LTczNicsXG4gIDB4YjNiZDogJ1NrZWluMTAyNC03NDQnLFxuICAweGIzYmU6ICdTa2VpbjEwMjQtNzUyJyxcbiAgMHhiM2JmOiAnU2tlaW4xMDI0LTc2MCcsXG4gIDB4YjNjMDogJ1NrZWluMTAyNC03NjgnLFxuICAweGIzYzE6ICdTa2VpbjEwMjQtNzc2JyxcbiAgMHhiM2MyOiAnU2tlaW4xMDI0LTc4NCcsXG4gIDB4YjNjMzogJ1NrZWluMTAyNC03OTInLFxuICAweGIzYzQ6ICdTa2VpbjEwMjQtODAwJyxcbiAgMHhiM2M1OiAnU2tlaW4xMDI0LTgwOCcsXG4gIDB4YjNjNjogJ1NrZWluMTAyNC04MTYnLFxuICAweGIzYzc6ICdTa2VpbjEwMjQtODI0JyxcbiAgMHhiM2M4OiAnU2tlaW4xMDI0LTgzMicsXG4gIDB4YjNjOTogJ1NrZWluMTAyNC04NDAnLFxuICAweGIzY2E6ICdTa2VpbjEwMjQtODQ4JyxcbiAgMHhiM2NiOiAnU2tlaW4xMDI0LTg1NicsXG4gIDB4YjNjYzogJ1NrZWluMTAyNC04NjQnLFxuICAweGIzY2Q6ICdTa2VpbjEwMjQtODcyJyxcbiAgMHhiM2NlOiAnU2tlaW4xMDI0LTg4MCcsXG4gIDB4YjNjZjogJ1NrZWluMTAyNC04ODgnLFxuICAweGIzZDA6ICdTa2VpbjEwMjQtODk2JyxcbiAgMHhiM2QxOiAnU2tlaW4xMDI0LTkwNCcsXG4gIDB4YjNkMjogJ1NrZWluMTAyNC05MTInLFxuICAweGIzZDM6ICdTa2VpbjEwMjQtOTIwJyxcbiAgMHhiM2Q0OiAnU2tlaW4xMDI0LTkyOCcsXG4gIDB4YjNkNTogJ1NrZWluMTAyNC05MzYnLFxuICAweGIzZDY6ICdTa2VpbjEwMjQtOTQ0JyxcbiAgMHhiM2Q3OiAnU2tlaW4xMDI0LTk1MicsXG4gIDB4YjNkODogJ1NrZWluMTAyNC05NjAnLFxuICAweGIzZDk6ICdTa2VpbjEwMjQtOTY4JyxcbiAgMHhiM2RhOiAnU2tlaW4xMDI0LTk3NicsXG4gIDB4YjNkYjogJ1NrZWluMTAyNC05ODQnLFxuICAweGIzZGM6ICdTa2VpbjEwMjQtOTkyJyxcbiAgMHhiM2RkOiAnU2tlaW4xMDI0LTEwMDAnLFxuICAweGIzZGU6ICdTa2VpbjEwMjQtMTAwOCcsXG4gIDB4YjNkZjogJ1NrZWluMTAyNC0xMDE2JyxcbiAgMHhiM2UwOiAnU2tlaW4xMDI0LTEwMjQnXG59KVxuXG5leHBvcnRzLmRlZmF1bHRMZW5ndGhzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIDB4MTE6IDIwLFxuICAweDEyOiAzMixcbiAgMHgxMzogNjQsXG4gIDB4NTY6IDMyLFxuICAweDE3OiAyOCxcbiAgMHgxNjogMzIsXG4gIDB4MTU6IDQ4LFxuICAweDE0OiA2NCxcbiAgMHgxODogMzIsXG4gIDB4MTk6IDY0LFxuICAweDFBOiAyOCxcbiAgMHgxQjogMzIsXG4gIDB4MUM6IDQ4LFxuICAweDFEOiA2NCxcbiAgMHgyMjogMzIsXG5cbiAgMHhiMjAxOiAweDAxLFxuICAweGIyMDI6IDB4MDIsXG4gIDB4YjIwMzogMHgwMyxcbiAgMHhiMjA0OiAweDA0LFxuICAweGIyMDU6IDB4MDUsXG4gIDB4YjIwNjogMHgwNixcbiAgMHhiMjA3OiAweDA3LFxuICAweGIyMDg6IDB4MDgsXG4gIDB4YjIwOTogMHgwOSxcbiAgMHhiMjBhOiAweDBhLFxuICAweGIyMGI6IDB4MGIsXG4gIDB4YjIwYzogMHgwYyxcbiAgMHhiMjBkOiAweDBkLFxuICAweGIyMGU6IDB4MGUsXG4gIDB4YjIwZjogMHgwZixcbiAgMHhiMjEwOiAweDEwLFxuICAweGIyMTE6IDB4MTEsXG4gIDB4YjIxMjogMHgxMixcbiAgMHhiMjEzOiAweDEzLFxuICAweGIyMTQ6IDB4MTQsXG4gIDB4YjIxNTogMHgxNSxcbiAgMHhiMjE2OiAweDE2LFxuICAweGIyMTc6IDB4MTcsXG4gIDB4YjIxODogMHgxOCxcbiAgMHhiMjE5OiAweDE5LFxuICAweGIyMWE6IDB4MWEsXG4gIDB4YjIxYjogMHgxYixcbiAgMHhiMjFjOiAweDFjLFxuICAweGIyMWQ6IDB4MWQsXG4gIDB4YjIxZTogMHgxZSxcbiAgMHhiMjFmOiAweDFmLFxuICAweGIyMjA6IDB4MjAsXG4gIDB4YjIyMTogMHgyMSxcbiAgMHhiMjIyOiAweDIyLFxuICAweGIyMjM6IDB4MjMsXG4gIDB4YjIyNDogMHgyNCxcbiAgMHhiMjI1OiAweDI1LFxuICAweGIyMjY6IDB4MjYsXG4gIDB4YjIyNzogMHgyNyxcbiAgMHhiMjI4OiAweDI4LFxuICAweGIyMjk6IDB4MjksXG4gIDB4YjIyYTogMHgyYSxcbiAgMHhiMjJiOiAweDJiLFxuICAweGIyMmM6IDB4MmMsXG4gIDB4YjIyZDogMHgyZCxcbiAgMHhiMjJlOiAweDJlLFxuICAweGIyMmY6IDB4MmYsXG4gIDB4YjIzMDogMHgzMCxcbiAgMHhiMjMxOiAweDMxLFxuICAweGIyMzI6IDB4MzIsXG4gIDB4YjIzMzogMHgzMyxcbiAgMHhiMjM0OiAweDM0LFxuICAweGIyMzU6IDB4MzUsXG4gIDB4YjIzNjogMHgzNixcbiAgMHhiMjM3OiAweDM3LFxuICAweGIyMzg6IDB4MzgsXG4gIDB4YjIzOTogMHgzOSxcbiAgMHhiMjNhOiAweDNhLFxuICAweGIyM2I6IDB4M2IsXG4gIDB4YjIzYzogMHgzYyxcbiAgMHhiMjNkOiAweDNkLFxuICAweGIyM2U6IDB4M2UsXG4gIDB4YjIzZjogMHgzZixcbiAgMHhiMjQwOiAweDQwLFxuICAweGIyNDE6IDB4MDEsXG4gIDB4YjI0MjogMHgwMixcbiAgMHhiMjQzOiAweDAzLFxuICAweGIyNDQ6IDB4MDQsXG4gIDB4YjI0NTogMHgwNSxcbiAgMHhiMjQ2OiAweDA2LFxuICAweGIyNDc6IDB4MDcsXG4gIDB4YjI0ODogMHgwOCxcbiAgMHhiMjQ5OiAweDA5LFxuICAweGIyNGE6IDB4MGEsXG4gIDB4YjI0YjogMHgwYixcbiAgMHhiMjRjOiAweDBjLFxuICAweGIyNGQ6IDB4MGQsXG4gIDB4YjI0ZTogMHgwZSxcbiAgMHhiMjRmOiAweDBmLFxuICAweGIyNTA6IDB4MTAsXG4gIDB4YjI1MTogMHgxMSxcbiAgMHhiMjUyOiAweDEyLFxuICAweGIyNTM6IDB4MTMsXG4gIDB4YjI1NDogMHgxNCxcbiAgMHhiMjU1OiAweDE1LFxuICAweGIyNTY6IDB4MTYsXG4gIDB4YjI1NzogMHgxNyxcbiAgMHhiMjU4OiAweDE4LFxuICAweGIyNTk6IDB4MTksXG4gIDB4YjI1YTogMHgxYSxcbiAgMHhiMjViOiAweDFiLFxuICAweGIyNWM6IDB4MWMsXG4gIDB4YjI1ZDogMHgxZCxcbiAgMHhiMjVlOiAweDFlLFxuICAweGIyNWY6IDB4MWYsXG4gIDB4YjI2MDogMHgyMCxcbiAgMHhiMzAxOiAweDAxLFxuICAweGIzMDI6IDB4MDIsXG4gIDB4YjMwMzogMHgwMyxcbiAgMHhiMzA0OiAweDA0LFxuICAweGIzMDU6IDB4MDUsXG4gIDB4YjMwNjogMHgwNixcbiAgMHhiMzA3OiAweDA3LFxuICAweGIzMDg6IDB4MDgsXG4gIDB4YjMwOTogMHgwOSxcbiAgMHhiMzBhOiAweDBhLFxuICAweGIzMGI6IDB4MGIsXG4gIDB4YjMwYzogMHgwYyxcbiAgMHhiMzBkOiAweDBkLFxuICAweGIzMGU6IDB4MGUsXG4gIDB4YjMwZjogMHgwZixcbiAgMHhiMzEwOiAweDEwLFxuICAweGIzMTE6IDB4MTEsXG4gIDB4YjMxMjogMHgxMixcbiAgMHhiMzEzOiAweDEzLFxuICAweGIzMTQ6IDB4MTQsXG4gIDB4YjMxNTogMHgxNSxcbiAgMHhiMzE2OiAweDE2LFxuICAweGIzMTc6IDB4MTcsXG4gIDB4YjMxODogMHgxOCxcbiAgMHhiMzE5OiAweDE5LFxuICAweGIzMWE6IDB4MWEsXG4gIDB4YjMxYjogMHgxYixcbiAgMHhiMzFjOiAweDFjLFxuICAweGIzMWQ6IDB4MWQsXG4gIDB4YjMxZTogMHgxZSxcbiAgMHhiMzFmOiAweDFmLFxuICAweGIzMjA6IDB4MjAsXG4gIDB4YjMyMTogMHgwMSxcbiAgMHhiMzIyOiAweDAyLFxuICAweGIzMjM6IDB4MDMsXG4gIDB4YjMyNDogMHgwNCxcbiAgMHhiMzI1OiAweDA1LFxuICAweGIzMjY6IDB4MDYsXG4gIDB4YjMyNzogMHgwNyxcbiAgMHhiMzI4OiAweDA4LFxuICAweGIzMjk6IDB4MDksXG4gIDB4YjMyYTogMHgwYSxcbiAgMHhiMzJiOiAweDBiLFxuICAweGIzMmM6IDB4MGMsXG4gIDB4YjMyZDogMHgwZCxcbiAgMHhiMzJlOiAweDBlLFxuICAweGIzMmY6IDB4MGYsXG4gIDB4YjMzMDogMHgxMCxcbiAgMHhiMzMxOiAweDExLFxuICAweGIzMzI6IDB4MTIsXG4gIDB4YjMzMzogMHgxMyxcbiAgMHhiMzM0OiAweDE0LFxuICAweGIzMzU6IDB4MTUsXG4gIDB4YjMzNjogMHgxNixcbiAgMHhiMzM3OiAweDE3LFxuICAweGIzMzg6IDB4MTgsXG4gIDB4YjMzOTogMHgxOSxcbiAgMHhiMzNhOiAweDFhLFxuICAweGIzM2I6IDB4MWIsXG4gIDB4YjMzYzogMHgxYyxcbiAgMHhiMzNkOiAweDFkLFxuICAweGIzM2U6IDB4MWUsXG4gIDB4YjMzZjogMHgxZixcbiAgMHhiMzQwOiAweDIwLFxuICAweGIzNDE6IDB4MjEsXG4gIDB4YjM0MjogMHgyMixcbiAgMHhiMzQzOiAweDIzLFxuICAweGIzNDQ6IDB4MjQsXG4gIDB4YjM0NTogMHgyNSxcbiAgMHhiMzQ2OiAweDI2LFxuICAweGIzNDc6IDB4MjcsXG4gIDB4YjM0ODogMHgyOCxcbiAgMHhiMzQ5OiAweDI5LFxuICAweGIzNGE6IDB4MmEsXG4gIDB4YjM0YjogMHgyYixcbiAgMHhiMzRjOiAweDJjLFxuICAweGIzNGQ6IDB4MmQsXG4gIDB4YjM0ZTogMHgyZSxcbiAgMHhiMzRmOiAweDJmLFxuICAweGIzNTA6IDB4MzAsXG4gIDB4YjM1MTogMHgzMSxcbiAgMHhiMzUyOiAweDMyLFxuICAweGIzNTM6IDB4MzMsXG4gIDB4YjM1NDogMHgzNCxcbiAgMHhiMzU1OiAweDM1LFxuICAweGIzNTY6IDB4MzYsXG4gIDB4YjM1NzogMHgzNyxcbiAgMHhiMzU4OiAweDM4LFxuICAweGIzNTk6IDB4MzksXG4gIDB4YjM1YTogMHgzYSxcbiAgMHhiMzViOiAweDNiLFxuICAweGIzNWM6IDB4M2MsXG4gIDB4YjM1ZDogMHgzZCxcbiAgMHhiMzVlOiAweDNlLFxuICAweGIzNWY6IDB4M2YsXG4gIDB4YjM2MDogMHg0MCxcbiAgMHhiMzYxOiAweDAxLFxuICAweGIzNjI6IDB4MDIsXG4gIDB4YjM2MzogMHgwMyxcbiAgMHhiMzY0OiAweDA0LFxuICAweGIzNjU6IDB4MDUsXG4gIDB4YjM2NjogMHgwNixcbiAgMHhiMzY3OiAweDA3LFxuICAweGIzNjg6IDB4MDgsXG4gIDB4YjM2OTogMHgwOSxcbiAgMHhiMzZhOiAweDBhLFxuICAweGIzNmI6IDB4MGIsXG4gIDB4YjM2YzogMHgwYyxcbiAgMHhiMzZkOiAweDBkLFxuICAweGIzNmU6IDB4MGUsXG4gIDB4YjM2ZjogMHgwZixcbiAgMHhiMzcwOiAweDEwLFxuICAweGIzNzE6IDB4MTEsXG4gIDB4YjM3MjogMHgxMixcbiAgMHhiMzczOiAweDEzLFxuICAweGIzNzQ6IDB4MTQsXG4gIDB4YjM3NTogMHgxNSxcbiAgMHhiMzc2OiAweDE2LFxuICAweGIzNzc6IDB4MTcsXG4gIDB4YjM3ODogMHgxOCxcbiAgMHhiMzc5OiAweDE5LFxuICAweGIzN2E6IDB4MWEsXG4gIDB4YjM3YjogMHgxYixcbiAgMHhiMzdjOiAweDFjLFxuICAweGIzN2Q6IDB4MWQsXG4gIDB4YjM3ZTogMHgxZSxcbiAgMHhiMzdmOiAweDFmLFxuICAweGIzODA6IDB4MjAsXG4gIDB4YjM4MTogMHgyMSxcbiAgMHhiMzgyOiAweDIyLFxuICAweGIzODM6IDB4MjMsXG4gIDB4YjM4NDogMHgyNCxcbiAgMHhiMzg1OiAweDI1LFxuICAweGIzODY6IDB4MjYsXG4gIDB4YjM4NzogMHgyNyxcbiAgMHhiMzg4OiAweDI4LFxuICAweGIzODk6IDB4MjksXG4gIDB4YjM4YTogMHgyYSxcbiAgMHhiMzhiOiAweDJiLFxuICAweGIzOGM6IDB4MmMsXG4gIDB4YjM4ZDogMHgyZCxcbiAgMHhiMzhlOiAweDJlLFxuICAweGIzOGY6IDB4MmYsXG4gIDB4YjM5MDogMHgzMCxcbiAgMHhiMzkxOiAweDMxLFxuICAweGIzOTI6IDB4MzIsXG4gIDB4YjM5MzogMHgzMyxcbiAgMHhiMzk0OiAweDM0LFxuICAweGIzOTU6IDB4MzUsXG4gIDB4YjM5NjogMHgzNixcbiAgMHhiMzk3OiAweDM3LFxuICAweGIzOTg6IDB4MzgsXG4gIDB4YjM5OTogMHgzOSxcbiAgMHhiMzlhOiAweDNhLFxuICAweGIzOWI6IDB4M2IsXG4gIDB4YjM5YzogMHgzYyxcbiAgMHhiMzlkOiAweDNkLFxuICAweGIzOWU6IDB4M2UsXG4gIDB4YjM5ZjogMHgzZixcbiAgMHhiM2EwOiAweDQwLFxuICAweGIzYTE6IDB4NDEsXG4gIDB4YjNhMjogMHg0MixcbiAgMHhiM2EzOiAweDQzLFxuICAweGIzYTQ6IDB4NDQsXG4gIDB4YjNhNTogMHg0NSxcbiAgMHhiM2E2OiAweDQ2LFxuICAweGIzYTc6IDB4NDcsXG4gIDB4YjNhODogMHg0OCxcbiAgMHhiM2E5OiAweDQ5LFxuICAweGIzYWE6IDB4NGEsXG4gIDB4YjNhYjogMHg0YixcbiAgMHhiM2FjOiAweDRjLFxuICAweGIzYWQ6IDB4NGQsXG4gIDB4YjNhZTogMHg0ZSxcbiAgMHhiM2FmOiAweDRmLFxuICAweGIzYjA6IDB4NTAsXG4gIDB4YjNiMTogMHg1MSxcbiAgMHhiM2IyOiAweDUyLFxuICAweGIzYjM6IDB4NTMsXG4gIDB4YjNiNDogMHg1NCxcbiAgMHhiM2I1OiAweDU1LFxuICAweGIzYjY6IDB4NTYsXG4gIDB4YjNiNzogMHg1NyxcbiAgMHhiM2I4OiAweDU4LFxuICAweGIzYjk6IDB4NTksXG4gIDB4YjNiYTogMHg1YSxcbiAgMHhiM2JiOiAweDViLFxuICAweGIzYmM6IDB4NWMsXG4gIDB4YjNiZDogMHg1ZCxcbiAgMHhiM2JlOiAweDVlLFxuICAweGIzYmY6IDB4NWYsXG4gIDB4YjNjMDogMHg2MCxcbiAgMHhiM2MxOiAweDYxLFxuICAweGIzYzI6IDB4NjIsXG4gIDB4YjNjMzogMHg2MyxcbiAgMHhiM2M0OiAweDY0LFxuICAweGIzYzU6IDB4NjUsXG4gIDB4YjNjNjogMHg2NixcbiAgMHhiM2M3OiAweDY3LFxuICAweGIzYzg6IDB4NjgsXG4gIDB4YjNjOTogMHg2OSxcbiAgMHhiM2NhOiAweDZhLFxuICAweGIzY2I6IDB4NmIsXG4gIDB4YjNjYzogMHg2YyxcbiAgMHhiM2NkOiAweDZkLFxuICAweGIzY2U6IDB4NmUsXG4gIDB4YjNjZjogMHg2ZixcbiAgMHhiM2QwOiAweDcwLFxuICAweGIzZDE6IDB4NzEsXG4gIDB4YjNkMjogMHg3MixcbiAgMHhiM2QzOiAweDczLFxuICAweGIzZDQ6IDB4NzQsXG4gIDB4YjNkNTogMHg3NSxcbiAgMHhiM2Q2OiAweDc2LFxuICAweGIzZDc6IDB4NzcsXG4gIDB4YjNkODogMHg3OCxcbiAgMHhiM2Q5OiAweDc5LFxuICAweGIzZGE6IDB4N2EsXG4gIDB4YjNkYjogMHg3YixcbiAgMHhiM2RjOiAweDdjLFxuICAweGIzZGQ6IDB4N2QsXG4gIDB4YjNkZTogMHg3ZSxcbiAgMHhiM2RmOiAweDdmLFxuICAweGIzZTA6IDB4ODBcbn0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBkaWZmZXJlbmNlfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBzdGFydDogdHJ1ZSxcbiAgcG9sbEludGVydmFsOiAxMDAwLFxufVxuXG5jbGFzcyBJcGZzUHVic3ViUGVlck1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmc1B1YnN1YiwgdG9waWMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fcHVic3ViID0gaXBmc1B1YnN1YlxuICAgIHRoaXMuX3RvcGljID0gdG9waWNcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKVxuICAgIHRoaXMuX3BlZXJzID0gW11cbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnN0YXJ0KVxuICAgICAgdGhpcy5zdGFydCgpXG4gIH1cblxuICBnZXQgc3RhcnRlZCAoKSB7IHJldHVybiB0aGlzLl9pbnRlcnZhbCAhPT0gbnVsbCB9XG4gIHNldCBzdGFydGVkICh2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFwiJ3N0YXJ0ZWQnIGlzIHJlYWQtb25seVwiKSB9XG5cbiAgc3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuc3RvcCgpXG5cbiAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgdGhpcy5fcG9sbFBlZXJzLmJpbmQodGhpcyksIFxuICAgICAgdGhpcy5fb3B0aW9ucy5wb2xsSW50ZXJ2YWxcbiAgICApXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2pvaW4nKVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdsZWF2ZScpXG4gIH1cblxuICBhc3luYyBnZXRQZWVycyAoKSB7XG4gICAgdGhpcy5fcGVlcnMgPSBhd2FpdCB0aGlzLl9wdWJzdWIucGVlcnModGhpcy5fdG9waWMpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJzLnNsaWNlKClcbiAgfVxuXG4gIGhhc1BlZXIgKHBlZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlcnMuaW5jbHVkZXMocGVlcilcbiAgfVxuXG4gIGFzeW5jIF9wb2xsUGVlcnMgKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwZWVycyA9IGF3YWl0IHRoaXMuX3B1YnN1Yi5wZWVycyh0aGlzLl90b3BpYylcbiAgICAgIElwZnNQdWJzdWJQZWVyTW9uaXRvci5fZW1pdEpvaW5zQW5kTGVhdmVzKG5ldyBTZXQodGhpcy5fcGVlcnMpLCBuZXcgU2V0KHBlZXJzKSwgdGhpcylcbiAgICAgIHRoaXMuX3BlZXJzID0gcGVlcnNcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfZW1pdEpvaW5zQW5kTGVhdmVzIChvbGRWYWx1ZXMsIG5ld1ZhbHVlcywgZXZlbnRzKSB7XG4gICAgY29uc3QgZW1pdEpvaW4gPSBhZGRlZFBlZXIgPT4gZXZlbnRzLmVtaXQoJ2pvaW4nLCBhZGRlZFBlZXIpXG4gICAgY29uc3QgZW1pdExlYXZlID0gcmVtb3ZlZFBlZXIgPT4gZXZlbnRzLmVtaXQoJ2xlYXZlJywgcmVtb3ZlZFBlZXIpXG4gICAgZGlmZmVyZW5jZShuZXdWYWx1ZXMsIG9sZFZhbHVlcykuZm9yRWFjaChlbWl0Sm9pbilcbiAgICBkaWZmZXJlbmNlKG9sZFZhbHVlcywgbmV3VmFsdWVzKS5mb3JFYWNoKGVtaXRMZWF2ZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElwZnNQdWJzdWJQZWVyTW9uaXRvclxuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcFJlZHVjZSA9IHJlcXVpcmUoJ3AtcmVkdWNlJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJ0BzaW5kcmVzb3JodXMvaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpdGVyYWJsZSA9PiB7XG5cdGNvbnN0IHJldCA9IFtdO1xuXG5cdGZvciAoY29uc3QgdGFzayBvZiBpdGVyYWJsZSkge1xuXHRcdGNvbnN0IHR5cGUgPSBpcyh0YXNrKTtcblxuXHRcdGlmICh0eXBlICE9PSAnRnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGFzayB0byBiZSBhIFxcYEZ1bmN0aW9uXFxgLCByZWNlaXZlZCBcXGAke3R5cGV9XFxgYCkpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwUmVkdWNlKGl0ZXJhYmxlLCAoXywgZm4pID0+IHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbikudGhlbih2YWwgPT4ge1xuXHRcdFx0cmV0LnB1c2godmFsKTtcblx0XHR9KTtcblx0fSkudGhlbigoKSA9PiByZXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBJUEZTTm90RGVmaW5lZEVycm9yID0gKCkgPT4gbmV3IEVycm9yKCdJUEZTIGluc3RhbmNlIG5vdCBkZWZpbmVkJylcbmNvbnN0IExvZ05vdERlZmluZWRFcnJvciA9ICgpID0+IG5ldyBFcnJvcignTG9nIGluc3RhbmNlIG5vdCBkZWZpbmVkJylcbmNvbnN0IE5vdEFMb2dFcnJvciA9ICgpID0+IG5ldyBFcnJvcignR2l2ZW4gYXJndW1lbnQgaXMgbm90IGFuIGluc3RhbmNlIG9mIExvZycpXG5jb25zdCBDYW5ub3RKb2luV2l0aERpZmZlcmVudElkID0gKCkgPT4gbmV3IEVycm9yKCdDYW5cXCd0IGpvaW4gbG9ncyB3aXRoIGRpZmZlcmVudCBJRHMnKVxuY29uc3QgTHRPckx0ZU11c3RCZVN0cmluZ09yQXJyYXkgPSAoKSA9PiBuZXcgRXJyb3IoJ2x0IG9yIGx0ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5IG9mIEVudHJpZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSVBGU05vdERlZmluZWRFcnJvcjogSVBGU05vdERlZmluZWRFcnJvcixcbiAgTG9nTm90RGVmaW5lZEVycm9yOiBMb2dOb3REZWZpbmVkRXJyb3IsXG4gIE5vdEFMb2dFcnJvcjogTm90QUxvZ0Vycm9yLFxuICBDYW5ub3RKb2luV2l0aERpZmZlcmVudElkOiBDYW5ub3RKb2luV2l0aERpZmZlcmVudElkLFxuICBMdE9yTHRlTXVzdEJlU3RyaW5nT3JBcnJheTogTHRPckx0ZU11c3RCZVN0cmluZ09yQXJyYXlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgRy1TZXQgQ1JEVFxuICpcbiAqIEZyb206XG4gKiBcIkEgY29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBDb252ZXJnZW50IGFuZCBDb21tdXRhdGl2ZSBSZXBsaWNhdGVkIERhdGEgVHlwZXNcIlxuICogaHR0cHM6Ly9oYWwuaW5yaWEuZnIvaW5yaWEtMDA1NTU1ODhcbiAqL1xuY2xhc3MgR1NldCB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZXMpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgYXBwZW5kICh2YWx1ZSkge31cbiAgbWVyZ2UgKHNldCkge31cbiAgZ2V0ICh2YWx1ZSkge31cbiAgaGFzICh2YWx1ZSkge31cbiAgZ2V0IHZhbHVlcyAoKSB7fVxuICBnZXQgbGVuZ3RoICgpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1NldFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIExhbXBvcnRDbG9jayB7XG4gIGNvbnN0cnVjdG9yIChpZCwgdGltZSkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMudGltZSA9IHRpbWUgfHwgMFxuICB9XG5cbiAgdGljayAoKSB7XG4gICAgcmV0dXJuIG5ldyBMYW1wb3J0Q2xvY2sodGhpcy5pZCwgKyt0aGlzLnRpbWUpXG4gIH1cblxuICBtZXJnZSAoY2xvY2spIHtcbiAgICB0aGlzLnRpbWUgPSBNYXRoLm1heCh0aGlzLnRpbWUsIGNsb2NrLnRpbWUpXG4gICAgcmV0dXJuIG5ldyBMYW1wb3J0Q2xvY2sodGhpcy5pZCwgdGhpcy50aW1lKVxuICB9XG5cbiAgY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTGFtcG9ydENsb2NrKHRoaXMuaWQsIHRoaXMudGltZSlcbiAgfVxuXG4gIHN0YXRpYyBjb21wYXJlIChhLCBiKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBcImRpc3RhbmNlXCIgYmFzZWQgb24gdGhlIGNsb2NrLCBpZS4gbG93ZXIgb3IgZ3JlYXRlclxuICAgIHZhciBkaXN0ID0gYS50aW1lIC0gYi50aW1lXG5cbiAgICAvLyBJZiB0aGUgc2VxdWVuY2UgbnVtYmVyIGlzIHRoZSBzYW1lIChjb25jdXJyZW50IGV2ZW50cyksXG4gICAgLy8gYW5kIHRoZSBJRHMgYXJlIGRpZmZlcmVudCwgdGFrZSB0aGUgb25lIHdpdGggYSBcImxvd2VyXCIgaWRcbiAgICBpZiAoZGlzdCA9PT0gMCAmJiBhLmlkICE9PSBiLmlkKSByZXR1cm4gYS5pZCA8IGIuaWQgPyAtMSA6IDFcblxuICAgIHJldHVybiBkaXN0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYW1wb3J0Q2xvY2tcbiIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBFbnRyeUluZGV4IHtcbiAgY29uc3RydWN0b3IgKGVudHJpZXMgPSB7fSkge1xuICAgIHRoaXMuX2NhY2hlID0gZW50cmllc1xuICB9XG5cbiAgc2V0IChrLCB2KSB7XG4gICAgdGhpcy5fY2FjaGVba10gPSB2XG4gIH1cblxuICBnZXQgKGspIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVba11cbiAgfVxuXG4gIGRlbGV0ZSAoaykge1xuICAgIHJldHVybiBkZWxldGUgdGhpcy5fY2FjaGVba11cbiAgfVxuXG4gIGFkZCAobmV3SXRlbXMpIHtcbiAgICB0aGlzLl9jYWNoZSA9IE9iamVjdC5hc3NpZ24odGhpcy5fY2FjaGUsIG5ld0l0ZW1zKVxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY2FjaGUpLmxlbmd0aFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW50cnlJbmRleFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEFjY2Vzc0NvbnRyb2xsZXIge1xuICBhc3luYyBjYW5BcHBlbmQgKGVudHJ5LCBpZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2Vzc0NvbnRyb2xsZXJcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcEVhY2hTZXJpZXMgPSBhc3luYyAoaXRlcmFibGUsIGl0ZXJhdG9yKSA9PiB7XG5cdGxldCBpbmRleCA9IDA7XG5cblx0Zm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG5cdFx0YXdhaXQgaXRlcmF0b3IoYXdhaXQgdmFsdWUsIGluZGV4KyspO1xuXHR9XG5cblx0cmV0dXJuIGl0ZXJhYmxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwRWFjaFNlcmllcztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcEVhY2hTZXJpZXM7XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCcuL2xhbXBvcnQtY2xvY2snKVxuXG4vKipcbiAqIFNvcnQgdHdvIGVudHJpZXMgYXMgTGFzdC1Xcml0ZS1XaW5zIChMV1cpLlxuICpcbiAqIExhc3QgV3JpdGUgV2lucyBpcyBhIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgZm9yIHNvcnRpbmcgZWxlbWVudHNcbiAqIHdoZXJlIHRoZSBlbGVtZW50IHdpdGggYSBncmVhdGVyIGNsb2NrIChsYXRlc3QpIGlzIGNob3NlbiBhcyB0aGUgd2lubmVyLlxuICpcbiAqIEBwYXJhbSB7RW50cnl9IGEgRmlyc3QgZW50cnlcbiAqIEBwYXJhbSB7RW50cnl9IGIgU2Vjb25kIGVudHJ5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSAxIGlmIGEgaXMgbGF0ZXN0LCAtMSBpZiBiIGlzIGxhdGVzdFxuICovXG5mdW5jdGlvbiBMYXN0V3JpdGVXaW5zIChhLCBiKSB7XG4gIC8vIFVsdGltYXRlIGNvbmZsaWN0IHJlc29sdXRpb24gKHRha2UgdGhlIGZpcnN0L2xlZnQgYXJnKVxuICBjb25zdCBGaXJzdCA9IChhLCBiKSA9PiBhXG4gIC8vIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgY2xvY2sgaWQsIGlmIHRoZSBzYW1lIGFsd2F5cyB0YWtlIHRoZSBmaXJzdFxuICBjb25zdCBzb3J0QnlJZCA9IChhLCBiKSA9PiBTb3J0QnlDbG9ja0lkKGEsIGIsIEZpcnN0KVxuICAvLyBTb3J0IHR3byBlbnRyaWVzIGJ5IHRoZWlyIGNsb2NrIHRpbWUsIGlmIGNvbmN1cnJlbnQsXG4gIC8vIGRldGVybWluZSBzb3J0aW5nIHVzaW5nIHByb3ZpZGVkIGNvbmZsaWN0IHJlc29sdXRpb24gZnVuY3Rpb25cbiAgY29uc3Qgc29ydEJ5RW50cnlDbG9ja3MgPSAoYSwgYikgPT4gU29ydEJ5Q2xvY2tzKGEsIGIsIHNvcnRCeUlkKVxuICAvLyBTb3J0IGVudHJpZXMgYnkgY2xvY2sgdGltZSBhcyB0aGUgcHJpbWFyeSBzb3J0IGNyaXRlcmlhXG4gIHJldHVybiBzb3J0QnlFbnRyeUNsb2NrcyhhLCBiKVxufVxuXG4vKipcbiAqIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgaGFzaC5cbiAqXG4gKiBAcGFyYW0ge0VudHJ5fSBhIEZpcnN0IGVudHJ5XG4gKiBAcGFyYW0ge0VudHJ5fSBiIFNlY29uZCBlbnRyeVxuICogQHJldHVybnMge251bWJlcn0gMSBpZiBhIGlzIGxhdGVzdCwgLTEgaWYgYiBpcyBsYXRlc3RcbiAqL1xuZnVuY3Rpb24gU29ydEJ5RW50cnlIYXNoIChhLCBiKSB7XG4gIC8vIFVsdGltYXRlIGNvbmZsaWN0IHJlc29sdXRpb24gKGNvbXBhcmUgaGFzaGVzKVxuICBjb25zdCBjb21wYXJlSGFzaCA9IChhLCBiKSA9PiBhLmhhc2ggPCBiLmhhc2ggPyAtMSA6IDFcbiAgLy8gU29ydCB0d28gZW50cmllcyBieSB0aGVpciBjbG9jayBpZCwgaWYgdGhlIHNhbWUgdGhlbiBjb21wYXJlIGhhc2hlc1xuICBjb25zdCBzb3J0QnlJZCA9IChhLCBiKSA9PiBTb3J0QnlDbG9ja0lkKGEsIGIsIGNvbXBhcmVIYXNoKVxuICAvLyBTb3J0IHR3byBlbnRyaWVzIGJ5IHRoZWlyIGNsb2NrIHRpbWUsIGlmIGNvbmN1cnJlbnQsXG4gIC8vIGRldGVybWluZSBzb3J0aW5nIHVzaW5nIHByb3ZpZGVkIGNvbmZsaWN0IHJlc29sdXRpb24gZnVuY3Rpb25cbiAgY29uc3Qgc29ydEJ5RW50cnlDbG9ja3MgPSAoYSwgYikgPT4gU29ydEJ5Q2xvY2tzKGEsIGIsIHNvcnRCeUlkKVxuICAvLyBTb3J0IGVudHJpZXMgYnkgY2xvY2sgdGltZSBhcyB0aGUgcHJpbWFyeSBzb3J0IGNyaXRlcmlhXG4gIHJldHVybiBzb3J0QnlFbnRyeUNsb2NrcyhhLCBiKVxufVxuXG4vKipcbiAqIFNvcnQgdHdvIGVudHJpZXMgYnkgdGhlaXIgY2xvY2sgdGltZS5cbiAqIEBwYXJhbSB7RW50cnl9IGEgRmlyc3QgZW50cnkgdG8gY29tcGFyZVxuICogQHBhcmFtIHtFbnRyeX0gYiBTZWNvbmQgZW50cnkgdG8gY29tcGFyZVxuICogQHBhcmFtIHtmdW5jdGlvbihhLCBiKX0gcmVzb2x2ZUNvbmZsaWN0IEEgZnVuY3Rpb24gdG8gY2FsbCBpZiBlbnRyaWVzIGFyZSBjb25jdXJyZW50IChoYXBwZW5lZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhlIGZ1bmN0aW9uIHNob3VsZCB0YWtlIGluIHR3byBlbnRyaWVzIGFuZCByZXR1cm4gMSBpZiB0aGUgZmlyc3QgZW50cnkgc2hvdWxkIGJlIGNob3NlbiBhbmQgLTEgaWYgdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgY2hvc2VuLlxuICogQHJldHVybnMge251bWJlcn0gMSBpZiBhIGlzIGdyZWF0ZXIsIC0xIGlmIGIgaXMgZ3JlYXRlclxuICovXG5mdW5jdGlvbiBTb3J0QnlDbG9ja3MgKGEsIGIsIHJlc29sdmVDb25mbGljdCkge1xuICAvLyBDb21wYXJlIHRoZSBjbG9ja3NcbiAgY29uc3QgZGlmZiA9IENsb2NrLmNvbXBhcmUoYS5jbG9jaywgYi5jbG9jaylcbiAgLy8gSWYgdGhlIGNsb2NrcyBhcmUgY29uY3VycmVudCwgdXNlIHRoZSBwcm92aWRlZFxuICAvLyBjb25mbGljdCByZXNvbHV0aW9uIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjb21lcyBmaXJzdFxuICByZXR1cm4gZGlmZiA9PT0gMCA/IHJlc29sdmVDb25mbGljdChhLCBiKSA6IGRpZmZcbn1cblxuLyoqXG4gKiBTb3J0IHR3byBlbnRyaWVzIGJ5IHRoZWlyIGNsb2NrIGlkLlxuICogQHBhcmFtIHtFbnRyeX0gYSBGaXJzdCBlbnRyeSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0VudHJ5fSBiIFNlY29uZCBlbnRyeSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGEsIGIpfSByZXNvbHZlQ29uZmxpY3QgQSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBjbG9ja3MgaWRzIGFyZSB0aGUgc2FtZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCB0YWtlIGluIHR3byBlbnRyaWVzIGFuZCByZXR1cm4gMSBpZiB0aGUgZmlyc3QgZW50cnkgc2hvdWxkIGJlIGNob3NlbiBhbmQgLTEgaWYgdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgY2hvc2VuLlxuICogQHJldHVybnMge251bWJlcn0gMSBpZiBhIGlzIGdyZWF0ZXIsIC0xIGlmIGIgaXMgZ3JlYXRlclxuICovXG5mdW5jdGlvbiBTb3J0QnlDbG9ja0lkIChhLCBiLCByZXNvbHZlQ29uZmxpY3QpIHtcbiAgLy8gU29ydCBieSBJRCBpZiBjbG9ja3MgYXJlIGNvbmN1cnJlbnQsXG4gIC8vIHRha2UgdGhlIGVudHJ5IHdpdGggYSBcImdyZWF0ZXJcIiBjbG9jayBpZFxuICByZXR1cm4gYS5jbG9jay5pZCA9PT0gYi5jbG9jay5pZFxuICAgID8gcmVzb2x2ZUNvbmZsaWN0KGEsIGIpXG4gICAgOiBhLmNsb2NrLmlkIDwgYi5jbG9jay5pZCA/IC0xIDogMVxufVxuXG4vKipcbiAqIEEgd3JhcHBlciBmdW5jdGlvbiB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVzdWx0cyBvZiBhIHBhc3NlZCBmdW5jdGlvbiByZXR1cm4gemVyb1xuICogQHBhcmFtIHtmdW5jdGlvbihhLCBiKX0gW3RpZWJyZWFrZXJdIFRoZSB0aWVicmVha2VyIGZ1bmN0aW9uIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMge2Z1bmN0aW9uKGEsIGIpfSAxIGlmIGEgaXMgZ3JlYXRlciwgLTEgaWYgYiBpcyBncmVhdGVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgZnVuYyBldmVyIHJldHVybnMgMFxuICovXG5mdW5jdGlvbiBOb1plcm9lcyAoZnVuYykge1xuICBjb25zdCBtc2cgPSBgWW91ciBsb2cncyB0aWVicmVha2VyIGZ1bmN0aW9uLCAke2Z1bmMubmFtZX0sIGhhcyByZXR1cm5lZCB6ZXJvIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlYFxuXG4gIGNvbnN0IGNvbXBhcmF0b3IgPSAoYSwgYikgPT4ge1xuICAgIC8vIFZhbGlkYXRlIGJ5IGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAgY29uc3QgcmVzdWx0ID0gZnVuYyhhLCBiKVxuICAgIGlmIChyZXN1bHQgPT09IDApIHsgdGhyb3cgRXJyb3IobXNnKSB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmF0b3Jcbn1cblxuZXhwb3J0cy5Tb3J0QnlDbG9ja3MgPSBTb3J0QnlDbG9ja3NcbmV4cG9ydHMuU29ydEJ5Q2xvY2tJZCA9IFNvcnRCeUNsb2NrSWRcbmV4cG9ydHMuTGFzdFdyaXRlV2lucyA9IExhc3RXcml0ZVdpbnNcbmV4cG9ydHMuU29ydEJ5RW50cnlIYXNoID0gU29ydEJ5RW50cnlIYXNoXG5leHBvcnRzLk5vWmVyb2VzID0gTm9aZXJvZXNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9kaWZmZXJlbmNlJylcbmNvbnN0IGZpbmRVbmlxdWVzID0gcmVxdWlyZSgnLi9maW5kLXVuaXF1ZXMnKVxuY29uc3QgaXNEZWZpbmVkID0gcmVxdWlyZSgnLi9pcy1kZWZpbmVkJylcbmNvbnN0IGlvID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlmZmVyZW5jZSxcbiAgZmluZFVuaXF1ZXMsXG4gIGlzRGVmaW5lZCxcbiAgaW9cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vZW50cnknKVxuY29uc3QgRW50cnlJTyA9IHJlcXVpcmUoJy4vZW50cnktaW8nKVxuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCcuL2xhbXBvcnQtY2xvY2snKVxuY29uc3QgTG9nRXJyb3IgPSByZXF1aXJlKCcuL2xvZy1lcnJvcnMnKVxuY29uc3QgeyBpc0RlZmluZWQsIGZpbmRVbmlxdWVzLCBkaWZmZXJlbmNlLCBpbyB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IElQTERfTElOS1MgPSBbJ2hlYWRzJ11cbmNvbnN0IGxhc3QgPSAoYXJyLCBuKSA9PiBhcnIuc2xpY2UoYXJyLmxlbmd0aCAtIG4sIGFyci5sZW5ndGgpXG5cbmNsYXNzIExvZ0lPIHtcbiAgLy9cbiAgLyoqXG4gICAqIEdldCB0aGUgbXVsdGloYXNoIG9mIGEgTG9nLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0xvZ30gbG9nIExvZyB0byBnZXQgYSBtdWx0aWhhc2ggZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdG9NdWx0aWhhc2ggKGlwZnMsIGxvZywgeyBmb3JtYXQgfSA9IHt9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKGxvZykpIHRocm93IExvZ0Vycm9yLkxvZ05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFpc0RlZmluZWQoZm9ybWF0KSkgZm9ybWF0ID0gJ2RhZy1jYm9yJ1xuICAgIGlmIChsb2cudmFsdWVzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VyaWFsaXplIGFuIGVtcHR5IGxvZ2ApXG5cbiAgICByZXR1cm4gaW8ud3JpdGUoaXBmcywgZm9ybWF0LCBsb2cudG9KU09OKCksIHsgbGlua3M6IElQTERfTElOS1MgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhIGhhc2hlcy5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGhhc2ggb2YgdGhlIGxvZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgbG9nXG4gICAqIEBwYXJhbSB7QXJyYXk8RW50cnk+fSBvcHRpb25zLmV4Y2x1ZGUgRW50cmllcyB0byBub3QgZmV0Y2ggKGNhY2hlZClcbiAgICogQHBhcmFtIHtmdW5jdGlvbihoYXNoLCBlbnRyeSwgcGFyZW50LCBkZXB0aCl9IG9wdGlvbnMub25Qcm9ncmVzc0NhbGxiYWNrXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU11bHRpaGFzaCAoaXBmcywgaGFzaCwgeyBsZW5ndGggPSAtMSwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0IH0gPSB7fSkge1xuICAgIGlmICghaXNEZWZpbmVkKGlwZnMpKSB0aHJvdyBMb2dFcnJvci5JUEZTTm90RGVmaW5lZEVycm9yKClcbiAgICBpZiAoIWlzRGVmaW5lZChoYXNoKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhc2g6ICR7aGFzaH1gKVxuXG4gICAgY29uc3QgbG9nRGF0YSA9IGF3YWl0IGlvLnJlYWQoaXBmcywgaGFzaCwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuICAgIGlmICghbG9nRGF0YS5oZWFkcyB8fCAhbG9nRGF0YS5pZCkgdGhyb3cgTG9nRXJyb3IuTm90QUxvZ0Vycm9yKClcblxuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBFbnRyeUlPLmZldGNoQWxsKGlwZnMsIGxvZ0RhdGEuaGVhZHMsXG4gICAgICB7IGxlbmd0aCwgZXhjbHVkZSwgb25Qcm9ncmVzc0NhbGxiYWNrLCB0aW1lb3V0IH0pXG5cbiAgICAvLyBGaW5kIGxhdGVzdCBjbG9ja1xuICAgIGNvbnN0IGNsb2NrID0gZW50cmllcy5yZWR1Y2UoKGNsb2NrLCBlbnRyeSkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmNsb2NrLnRpbWUgPiBjbG9jay50aW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xvY2soZW50cnkuY2xvY2suaWQsIGVudHJ5LmNsb2NrLnRpbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvY2tcbiAgICB9LCBuZXcgQ2xvY2sobG9nRGF0YS5pZCkpXG5cbiAgICBjb25zdCBmaW5hbEVudHJpZXMgPSBlbnRyaWVzLnNsaWNlKCkuc29ydChFbnRyeS5jb21wYXJlKVxuICAgIGNvbnN0IGhlYWRzID0gZmluYWxFbnRyaWVzLmZpbHRlcihlID0+IGxvZ0RhdGEuaGVhZHMuaW5jbHVkZXMoZS5oYXNoKSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGxvZ0RhdGEuaWQsXG4gICAgICB2YWx1ZXM6IGZpbmFsRW50cmllcyxcbiAgICAgIGhlYWRzOiBoZWFkcyxcbiAgICAgIGNsb2NrOiBjbG9ja1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2cgZnJvbSBhbiBlbnRyeSBoYXNoLlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBUaGUgaGFzaCBvZiB0aGUgZW50cnlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGVuZ3RoIEhvdyBtYW55IGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIGxvZ1xuICAgKiBAcGFyYW0ge0FycmF5PEVudHJ5Pn0gb3B0aW9ucy5leGNsdWRlIEVudHJpZXMgdG8gbm90IGZldGNoIChjYWNoZWQpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFzaCwgZW50cnksIHBhcmVudCwgZGVwdGgpfSBvcHRpb25zLm9uUHJvZ3Jlc3NDYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50aW1lb3V0IFRpbWVvdXQgZm9yIGZldGNoaW5nIGEgbG9nIGVudHJ5IGZyb20gSVBGU1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21FbnRyeUhhc2ggKGlwZnMsIGhhc2gsIHsgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklwZnNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKGhhc2gpKSB0aHJvdyBuZXcgRXJyb3IoXCInaGFzaCcgbXVzdCBiZSBkZWZpbmVkXCIpXG4gICAgLy8gQ29udmVydCBpbnB1dCBoYXNoKHMpIHRvIGFuIGFycmF5XG4gICAgY29uc3QgaGFzaGVzID0gQXJyYXkuaXNBcnJheShoYXNoKSA/IGhhc2ggOiBbaGFzaF1cbiAgICAvLyBGZXRjaCBnaXZlbiBsZW5ndGgsIHJldHVybiBzaXplIGF0IGxlYXN0IHRoZSBnaXZlbiBpbnB1dCBlbnRyaWVzXG4gICAgbGVuZ3RoID0gbGVuZ3RoID4gLTEgPyBNYXRoLm1heChsZW5ndGgsIDEpIDogbGVuZ3RoXG5cbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhhc2hlcyxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQgfSlcbiAgICAvLyBDYXAgdGhlIHJlc3VsdCBhdCB0aGUgcmlnaHQgc2l6ZSBieSB0YWtpbmcgdGhlIGxhc3QgbiBlbnRyaWVzLFxuICAgIC8vIG9yIGlmIGdpdmVuIGxlbmd0aCBpcyAtMSwgdGhlbiB0YWtlIGFsbFxuICAgIGNvbnN0IHNsaWNlZCA9IGxlbmd0aCA+IC0xID8gbGFzdChlbnRyaWVzLCBsZW5ndGgpIDogZW50cmllc1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZXM6IHNsaWNlZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9nIGRhdGEgZnJvbSBhIEpTT04gb2JqZWN0LCB0byBiZSBwYXNzZWQgdG8gYSBMb2cgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtqc29ufSBqc29uIEEganNvbiBvYmplY3QgY29udGFpbmluZyB2YWxpZCBsb2cgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5sZW5ndGggSG93IG1hbnkgZW50cmllcyB0byBpbmNsdWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgTWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIGVhY2ggZmV0Y2ggb3BlcmF0aW9uLCBpbiBtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICoqL1xuICBzdGF0aWMgYXN5bmMgZnJvbUpTT04gKGlwZnMsIGpzb24sIHsgbGVuZ3RoID0gLTEsIHRpbWVvdXQsIG9uUHJvZ3Jlc3NDYWxsYmFjayB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGNvbnN0IGhlYWRIYXNoZXMgPSBqc29uLmhlYWRzLm1hcChlID0+IGUuaGFzaClcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhlYWRIYXNoZXMsXG4gICAgICB7IGxlbmd0aCwgZXhjbHVkZTogW10sIGNvbmN1cnJlbmN5OiAxNiwgdGltZW91dCwgb25Qcm9ncmVzc0NhbGxiYWNrIH0pXG4gICAgY29uc3QgZmluYWxFbnRyaWVzID0gZW50cmllcy5zbGljZSgpLnNvcnQoRW50cnkuY29tcGFyZSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGpzb24uaWQsXG4gICAgICB2YWx1ZXM6IGZpbmFsRW50cmllcyxcbiAgICAgIGhlYWRzOiBqc29uLmhlYWRzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsb2cgc3RhcnRpbmcgZnJvbSBhbiBlbnRyeS5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtFbnRyeXxBcnJheTxFbnRyeT59IHNvdXJjZUVudHJpZXMgQW4gZW50cnkgb3IgYW4gYXJyYXkgb2YgZW50cmllcyB0byBmZXRjaCBhIGxvZyBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmxlbmd0aCBIb3cgbWFueSBlbnRyaWVzIHRvIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IG9wdGlvbnMuZXhjbHVkZSBFbnRyaWVzIHRvIG5vdCBmZXRjaCAoY2FjaGVkKVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhc2gsIGVudHJ5LCBwYXJlbnQsIGRlcHRoKX0gb3B0aW9ucy5vblByb2dyZXNzQ2FsbGJhY2tcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tRW50cnkgKGlwZnMsIHNvdXJjZUVudHJpZXMsIHsgbGVuZ3RoID0gLTEsIGV4Y2x1ZGUsIG9uUHJvZ3Jlc3NDYWxsYmFjaywgdGltZW91dCB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoaXBmcykpIHRocm93IExvZ0Vycm9yLklQRlNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaXNEZWZpbmVkKHNvdXJjZUVudHJpZXMpKSB0aHJvdyBuZXcgRXJyb3IoXCInc291cmNlRW50cmllcycgbXVzdCBiZSBkZWZpbmVkXCIpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBoYXZlIEVudHJ5IG9iamVjdHMgYXMgaW5wdXRcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlRW50cmllcykgJiYgIUVudHJ5LmlzRW50cnkoc291cmNlRW50cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ3NvdXJjZUVudHJpZXMnIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb2YgRW50cnkgaW5zdGFuY2VzIG9yIGEgc2luZ2xlIEVudHJ5YClcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlRW50cmllcykpIHtcbiAgICAgIHNvdXJjZUVudHJpZXMgPSBbc291cmNlRW50cmllc11cbiAgICB9XG5cbiAgICAvLyBGZXRjaCBnaXZlbiBsZW5ndGgsIHJldHVybiBzaXplIGF0IGxlYXN0IHRoZSBnaXZlbiBpbnB1dCBlbnRyaWVzXG4gICAgbGVuZ3RoID0gbGVuZ3RoID4gLTEgPyBNYXRoLm1heChsZW5ndGgsIHNvdXJjZUVudHJpZXMubGVuZ3RoKSA6IGxlbmd0aFxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIHBhc3MgaGFzaGVzIGluc3RlYWQgb2Ygb2JqZWN0cyB0byB0aGUgZmV0Y2hlciBmdW5jdGlvblxuICAgIGNvbnN0IGhhc2hlcyA9IHNvdXJjZUVudHJpZXMubWFwKGUgPT4gZS5oYXNoKVxuXG4gICAgLy8gRmV0Y2ggdGhlIGVudHJpZXNcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgRW50cnlJTy5mZXRjaFBhcmFsbGVsKGlwZnMsIGhhc2hlcyxcbiAgICAgIHsgbGVuZ3RoLCBleGNsdWRlLCBvblByb2dyZXNzQ2FsbGJhY2ssIHRpbWVvdXQgfSlcblxuICAgIC8vIENvbWJpbmUgdGhlIGZldGNoZXMgd2l0aCB0aGUgc291cmNlIGVudHJpZXMgYW5kIHRha2Ugb25seSB1bmlxdWVzXG4gICAgY29uc3QgY29tYmluZWQgPSBzb3VyY2VFbnRyaWVzLmNvbmNhdChlbnRyaWVzKVxuICAgIGNvbnN0IHVuaXF1ZXMgPSBmaW5kVW5pcXVlcyhjb21iaW5lZCwgJ2hhc2gnKS5zb3J0KEVudHJ5LmNvbXBhcmUpXG5cbiAgICAvLyBDYXAgdGhlIHJlc3VsdCBhdCB0aGUgcmlnaHQgc2l6ZSBieSB0YWtpbmcgdGhlIGxhc3QgbiBlbnRyaWVzXG4gICAgY29uc3Qgc2xpY2VkID0gdW5pcXVlcy5zbGljZShsZW5ndGggPiAtMSA/IC1sZW5ndGggOiAtdW5pcXVlcy5sZW5ndGgpXG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZ2l2ZW4gaW5wdXQgZW50cmllcyBhcmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0XG4gICAgLy8gaW4gb3JkZXIgdG8gbm90IGxvc2UgcmVmZXJlbmNlc1xuICAgIGNvbnN0IG1pc3NpbmdTb3VyY2VFbnRyaWVzID0gZGlmZmVyZW5jZShzbGljZWQsIHNvdXJjZUVudHJpZXMsICdoYXNoJylcblxuICAgIGNvbnN0IHJlcGxhY2VJbkZyb250ID0gKGEsIHdpdGhFbnRyaWVzKSA9PiB7XG4gICAgICB2YXIgc2xpY2VkID0gYS5zbGljZSh3aXRoRW50cmllcy5sZW5ndGgsIGEubGVuZ3RoKVxuICAgICAgcmV0dXJuIHdpdGhFbnRyaWVzLmNvbmNhdChzbGljZWQpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBpbnB1dCBlbnRyaWVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFuZCByZW1vdmVcbiAgICAvLyBhcyBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5IGJlZm9yZSBpbnNlcnRpbmcgdGhlIG9yaWdpbmFsIGVudHJpZXNcbiAgICBjb25zdCByZXN1bHQgPSByZXBsYWNlSW5Gcm9udChzbGljZWQsIG1pc3NpbmdTb3VyY2VFbnRyaWVzKVxuICAgIHJldHVybiB7XG4gICAgICBpZDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5pZCxcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nSU9cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vbGFtcG9ydC1jbG9jaycpXG5jb25zdCB7IGlzRGVmaW5lZCwgaW8gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdHJpbmdpZnktZGV0ZXJtaW5pc3RpYycpXG5jb25zdCBJUExEX0xJTktTID0gWyduZXh0J11cbmNvbnN0IElwZnNOb3REZWZpbmVkRXJyb3IgPSAoKSA9PiBuZXcgRXJyb3IoJ0lwZnMgaW5zdGFuY2Ugbm90IGRlZmluZWQnKVxuY29uc3Qgd3JpdGVGb3JtYXRzID0ge1xuICAwOiAnZGFnLXBiJyxcbiAgMTogJ2RhZy1jYm9yJ1xufVxuXG5jbGFzcyBFbnRyeSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRW50cnlcbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgVGhlIGlkZW50aXR5IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dJZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgbG9nXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBEYXRhIG9mIHRoZSBlbnRyeSB0byBiZSBhZGRlZC4gQ2FuIGJlIGFueSBKU09OLnN0cmluZ2lmeWFibGUgZGF0YVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xFbnRyeT59IFtuZXh0PVtdXSBQYXJlbnQgaGFzaGVzIG9yIGVudHJpZXNcbiAgICogQHBhcmFtIHtMYW1wb3J0Q2xvY2t9IFtjbG9ja10gVGhlIGxhbXBvcnQgY2xvY2tcbiAgICogQHJldHVybnMge1Byb21pc2U8RW50cnk+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbnRyeSA9IGF3YWl0IEVudHJ5LmNyZWF0ZShpcGZzLCBpZGVudGl0eSwgJ2hlbGxvJylcbiAgICogY29uc29sZS5sb2coZW50cnkpXG4gICAqIC8vIHsgaGFzaDogbnVsbCwgcGF5bG9hZDogXCJoZWxsb1wiLCBuZXh0OiBbXSB9XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChpcGZzLCBpZGVudGl0eSwgbG9nSWQsIGRhdGEsIG5leHQgPSBbXSwgY2xvY2spIHtcbiAgICBpZiAoIWlzRGVmaW5lZChpcGZzKSkgdGhyb3cgSXBmc05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFpc0RlZmluZWQoaWRlbnRpdHkpKSB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IGlzIHJlcXVpcmVkLCBjYW5ub3QgY3JlYXRlIGVudHJ5JylcbiAgICBpZiAoIWlzRGVmaW5lZChsb2dJZCkpIHRocm93IG5ldyBFcnJvcignRW50cnkgcmVxdWlyZXMgYW4gaWQnKVxuICAgIGlmICghaXNEZWZpbmVkKGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ0VudHJ5IHJlcXVpcmVzIGRhdGEnKVxuICAgIGlmICghaXNEZWZpbmVkKG5leHQpIHx8ICFBcnJheS5pc0FycmF5KG5leHQpKSB0aHJvdyBuZXcgRXJyb3IoXCInbmV4dCcgYXJndW1lbnQgaXMgbm90IGFuIGFycmF5XCIpXG5cbiAgICAvLyBDbGVhbiB0aGUgbmV4dCBvYmplY3RzIGFuZCBjb252ZXJ0IHRvIGhhc2hlc1xuICAgIGNvbnN0IHRvRW50cnkgPSAoZSkgPT4gZS5oYXNoID8gZS5oYXNoIDogZVxuICAgIGNvbnN0IG5leHRzID0gbmV4dC5maWx0ZXIoaXNEZWZpbmVkKS5tYXAodG9FbnRyeSlcblxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaGFzaDogbnVsbCwgLy8gXCJ6ZC4uLkZvb1wiLCB3ZSdsbCBzZXQgdGhlIGhhc2ggYWZ0ZXIgcGVyc2lzdGluZyB0aGUgZW50cnlcbiAgICAgIGlkOiBsb2dJZCwgLy8gRm9yIGRldGVybWluaW5nIGEgdW5pcXVlIGNoYWluXG4gICAgICBwYXlsb2FkOiBkYXRhLCAvLyBDYW4gYmUgYW55IEpTT04uc3RyaW5naWZ5YWJsZSBkYXRhXG4gICAgICBuZXh0OiBuZXh0cywgLy8gQXJyYXkgb2YgaGFzaGVzXG4gICAgICB2OiAxLCAvLyBUbyB0YWcgdGhlIHZlcnNpb24gb2YgdGhpcyBkYXRhIHN0cnVjdHVyZVxuICAgICAgY2xvY2s6IGNsb2NrIHx8IG5ldyBDbG9jayhpZGVudGl0eS5wdWJsaWNLZXkpXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgaWRlbnRpdHkucHJvdmlkZXIuc2lnbihpZGVudGl0eSwgRW50cnkudG9CdWZmZXIoZW50cnkpKVxuXG4gICAgZW50cnkua2V5ID0gaWRlbnRpdHkucHVibGljS2V5XG4gICAgZW50cnkuaWRlbnRpdHkgPSBpZGVudGl0eS50b0pTT04oKVxuICAgIGVudHJ5LnNpZyA9IHNpZ25hdHVyZVxuICAgIGVudHJ5Lmhhc2ggPSBhd2FpdCBFbnRyeS50b011bHRpaGFzaChpcGZzLCBlbnRyeSlcblxuICAgIHJldHVybiBlbnRyeVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGFuIGVudHJ5IHNpZ25hdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtJZGVudGl0eVByb3ZpZGVyfSBpZGVudGl0eVByb3ZpZGVyIFRoZSBpZGVudGl0eSBwcm92aWRlciB0byB1c2VcbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgVGhlIGVudHJ5IGJlaW5nIHZlcmlmaWVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnkgKGlkZW50aXR5UHJvdmlkZXIsIGVudHJ5KSB7XG4gICAgaWYgKCFpZGVudGl0eVByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5LXByb3ZpZGVyIGlzIHJlcXVpcmVkLCBjYW5ub3QgdmVyaWZ5IGVudHJ5JylcbiAgICBpZiAoIUVudHJ5LmlzRW50cnkoZW50cnkpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTG9nIGVudHJ5JylcbiAgICBpZiAoIWVudHJ5LmtleSkgdGhyb3cgbmV3IEVycm9yKFwiRW50cnkgZG9lc24ndCBoYXZlIGEga2V5XCIpXG4gICAgaWYgKCFlbnRyeS5zaWcpIHRocm93IG5ldyBFcnJvcihcIkVudHJ5IGRvZXNuJ3QgaGF2ZSBhIHNpZ25hdHVyZVwiKVxuXG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBpZDogZW50cnkuaWQsXG4gICAgICBwYXlsb2FkOiBlbnRyeS5wYXlsb2FkLFxuICAgICAgbmV4dDogZW50cnkubmV4dCxcbiAgICAgIHY6IGVudHJ5LnYsXG4gICAgICBjbG9jazogZW50cnkuY2xvY2tcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnRpdHlQcm92aWRlci52ZXJpZnkoZW50cnkuc2lnLCBlbnRyeS5rZXksIEVudHJ5LnRvQnVmZmVyKGUpLCAndicgKyBlbnRyeS52KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gZW50cnkgaW50byBhIEJ1ZmZlci5cbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgVGhlIGVudHJ5XG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHRvQnVmZmVyIChlbnRyeSkge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkRW50cnkgPSBlbnRyeS52ID09PSAwID8gSlNPTi5zdHJpbmdpZnkoZW50cnkpIDogc3RyaW5naWZ5KGVudHJ5KVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmdpZmllZEVudHJ5KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbXVsdGloYXNoIG9mIGFuIEVudHJ5LlxuICAgKiBAcGFyYW0ge0lQRlN9IGlwZnMgQW4gSVBGUyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0VudHJ5fSBlbnRyeSBFbnRyeSB0byBnZXQgYSBtdWx0aWhhc2ggZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG11bHRpaGFzaCA9IGF3YWl0IEVudHJ5LnRvTXVsdGloYXNoKGlwZnMsIGVudHJ5KVxuICAgKiBjb25zb2xlLmxvZyhtdWx0aWhhc2gpXG4gICAqIC8vIFwiUW0uLi5Gb29cIlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHRvTXVsdGloYXNoIChpcGZzLCBlbnRyeSkge1xuICAgIGlmICghaXBmcykgdGhyb3cgSXBmc05vdERlZmluZWRFcnJvcigpXG4gICAgaWYgKCFFbnRyeS5pc0VudHJ5KGVudHJ5KSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9iamVjdCBmb3JtYXQsIGNhbm5vdCBnZW5lcmF0ZSBlbnRyeSBoYXNoJylcblxuICAgIC8vIEVuc3VyZSBgZW50cnlgIGZvbGxvd3MgdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBpZDogZW50cnkuaWQsXG4gICAgICBwYXlsb2FkOiBlbnRyeS5wYXlsb2FkLFxuICAgICAgbmV4dDogZW50cnkubmV4dCxcbiAgICAgIHY6IGVudHJ5LnYsXG4gICAgICBjbG9jazogZW50cnkuY2xvY2tcbiAgICB9XG5cbiAgICBpZiAoZW50cnkua2V5KSBPYmplY3QuYXNzaWduKGUsIHsga2V5OiBlbnRyeS5rZXkgfSlcbiAgICBpZiAoZW50cnkuaWRlbnRpdHkpIE9iamVjdC5hc3NpZ24oZSwgeyBpZGVudGl0eTogZW50cnkuaWRlbnRpdHkgfSlcbiAgICBpZiAoZW50cnkuc2lnKSBPYmplY3QuYXNzaWduKGUsIHsgc2lnOiBlbnRyeS5zaWcgfSlcblxuICAgIHJldHVybiBpby53cml0ZShpcGZzLCB3cml0ZUZvcm1hdHNbZS52XSwgZSwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFbnRyeSBmcm9tIGEgaGFzaC5cbiAgICogQHBhcmFtIHtJUEZTfSBpcGZzIEFuIElQRlMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggVGhlIGhhc2ggdG8gY3JlYXRlIGFuIEVudHJ5IGZyb21cbiAgICogQHJldHVybnMge1Byb21pc2U8RW50cnk+fVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBlbnRyeSA9IGF3YWl0IEVudHJ5LmZyb21NdWx0aWhhc2goaXBmcywgXCJ6ZC4uLkZvb1wiKVxuICAgKiBjb25zb2xlLmxvZyhlbnRyeSlcbiAgICogLy8geyBoYXNoOiBcIlpkLi4uRm9vXCIsIHBheWxvYWQ6IFwiaGVsbG9cIiwgbmV4dDogW10gfVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21NdWx0aWhhc2ggKGlwZnMsIGhhc2gpIHtcbiAgICBpZiAoIWlwZnMpIHRocm93IElwZnNOb3REZWZpbmVkRXJyb3IoKVxuICAgIGlmICghaGFzaCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhc2g6ICR7aGFzaH1gKVxuXG4gICAgY29uc3QgZSA9IGF3YWl0IGlvLnJlYWQoaXBmcywgaGFzaCwgeyBsaW5rczogSVBMRF9MSU5LUyB9KVxuXG4gICAgbGV0IGVudHJ5ID0ge1xuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIGlkOiBlLmlkLFxuICAgICAgcGF5bG9hZDogZS5wYXlsb2FkLFxuICAgICAgbmV4dDogZS5uZXh0LFxuICAgICAgdjogZS52LFxuICAgICAgY2xvY2s6IG5ldyBDbG9jayhlLmNsb2NrLmlkLCBlLmNsb2NrLnRpbWUpXG4gICAgfVxuXG4gICAgaWYgKGUua2V5KSBPYmplY3QuYXNzaWduKGVudHJ5LCB7IGtleTogZS5rZXkgfSlcbiAgICBpZiAoZS5pZGVudGl0eSkgT2JqZWN0LmFzc2lnbihlbnRyeSwgeyBpZGVudGl0eTogZS5pZGVudGl0eSB9KVxuICAgIGlmIChlLnNpZykgT2JqZWN0LmFzc2lnbihlbnRyeSwgeyBzaWc6IGUuc2lnIH0pXG5cbiAgICByZXR1cm4gZW50cnlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gRW50cnkuXG4gICAqIEBwYXJhbSB7RW50cnl9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0VudHJ5IChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoubmV4dCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoudiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmouaGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmouY2xvY2sgIT09IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBlbnRyaWVzLlxuICAgKiBAcGFyYW0ge0VudHJ5fSBhXG4gICAqIEBwYXJhbSB7RW50cnl9IGJcbiAgICogQHJldHVybnMge251bWJlcn0gMSBpZiBhIGlzIGdyZWF0ZXIsIC0xIGlzIGIgaXMgZ3JlYXRlclxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUgKGEsIGIpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSBDbG9jay5jb21wYXJlKGEuY2xvY2ssIGIuY2xvY2spXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSByZXR1cm4gYS5jbG9jay5pZCA8IGIuY2xvY2suaWQgPyAtMSA6IDFcbiAgICByZXR1cm4gZGlzdGFuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbnRyeSBlcXVhbHMgYW5vdGhlciBlbnRyeS5cbiAgICogQHBhcmFtIHtFbnRyeX0gYVxuICAgKiBAcGFyYW0ge0VudHJ5fSBiXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRXF1YWwgKGEsIGIpIHtcbiAgICByZXR1cm4gYS5oYXNoID09PSBiLmhhc2hcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbnRyeSBpcyBhIHBhcmVudCB0byBhbm90aGVyIGVudHJ5LlxuICAgKiBAcGFyYW0ge0VudHJ5fSBlbnRyeTEgRW50cnkgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkyIFRoZSBwYXJlbnQgRW50cnlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNQYXJlbnQgKGVudHJ5MSwgZW50cnkyKSB7XG4gICAgcmV0dXJuIGVudHJ5Mi5uZXh0LmluZGV4T2YoZW50cnkxLmhhc2gpID4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGVudHJ5J3MgY2hpbGRyZW4gZnJvbSBhbiBBcnJheSBvZiBlbnRyaWVzLlxuICAgKiBSZXR1cm5zIGVudHJ5J3MgY2hpbGRyZW4gYXMgYW4gQXJyYXkgdXAgdG8gdGhlIGxhc3Qga25vdyBjaGlsZC5cbiAgICogQHBhcmFtIHtFbnRyeX0gZW50cnkgRW50cnkgZm9yIHdoaWNoIHRvIGZpbmQgdGhlIHBhcmVudHNcbiAgICogQHBhcmFtIHtBcnJheTxFbnRyeT59IHZhbHVlcyBFbnRyaWVzIHRvIHNlYXJjaCBwYXJlbnRzIGZyb21cbiAgICogQHJldHVybnMge0FycmF5PEVudHJ5Pn1cbiAgICovXG4gIHN0YXRpYyBmaW5kQ2hpbGRyZW4gKGVudHJ5LCB2YWx1ZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBbXVxuICAgIHZhciBwYXJlbnQgPSB2YWx1ZXMuZmluZCgoZSkgPT4gRW50cnkuaXNQYXJlbnQoZW50cnksIGUpKVxuICAgIHZhciBwcmV2ID0gZW50cnlcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBzdGFjay5wdXNoKHBhcmVudClcbiAgICAgIHByZXYgPSBwYXJlbnRcbiAgICAgIHBhcmVudCA9IHZhbHVlcy5maW5kKChlKSA9PiBFbnRyeS5pc1BhcmVudChwcmV2LCBlKSlcbiAgICB9XG4gICAgc3RhY2sgPSBzdGFjay5zb3J0KChhLCBiKSA9PiBhLmNsb2NrLnRpbWUgPiBiLmNsb2NrLnRpbWUpXG4gICAgcmV0dXJuIHN0YWNrXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnRyeVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbE9iamVjdDtcbnZhciBSRUdJU1RSWTtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGdsb2JhbE9iamVjdCA9IHdpbmRvdztcbn1cbmVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnKSB7XG4gICAgZ2xvYmFsT2JqZWN0ID0gZ2xvYmFsO1xufVxuZWxzZSB7XG4gICAgZ2xvYmFsT2JqZWN0ID0ge1xuICAgICAgICBESURfUkVHSVNUUlk6IHt9XG4gICAgfTtcbn1cbmlmIChnbG9iYWxPYmplY3QuRElEX1JFR0lTVFJZKSB7XG4gICAgUkVHSVNUUlkgPSBnbG9iYWxPYmplY3QuRElEX1JFR0lTVFJZO1xufVxuZWxzZSB7XG4gICAgUkVHSVNUUlkgPSBnbG9iYWxPYmplY3QuRElEX1JFR0lTVFJZID0ge307XG59XG5mdW5jdGlvbiByZWdpc3Rlck1ldGhvZChtZXRob2QsIHJlc29sdmVyKSB7XG4gICAgUkVHSVNUUllbbWV0aG9kXSA9IHJlc29sdmVyO1xufVxuZXhwb3J0cy5yZWdpc3Rlck1ldGhvZCA9IHJlZ2lzdGVyTWV0aG9kO1xuZnVuY3Rpb24gcGFyc2UoZGlkKSB7XG4gICAgaWYgKGRpZCA9PT0gJycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBESUQnKTtcbiAgICB2YXIgc2VjdGlvbnMgPSBkaWQubWF0Y2goL15kaWQ6KFthLXpBLVowLTlfXSspOihbW2EtekEtWjAtOV8uLV0rKShcXC9bXiNdKik/KCMuKik/JC8pO1xuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICB2YXIgcGFydHMgPSB7IGRpZDogc2VjdGlvbnNbMF0sIG1ldGhvZDogc2VjdGlvbnNbMV0sIGlkOiBzZWN0aW9uc1syXSB9O1xuICAgICAgICBpZiAoc2VjdGlvbnNbM10pXG4gICAgICAgICAgICBwYXJ0cy5wYXRoID0gc2VjdGlvbnNbM107XG4gICAgICAgIGlmIChzZWN0aW9uc1s0XSlcbiAgICAgICAgICAgIHBhcnRzLmZyYWdtZW50ID0gc2VjdGlvbnNbNF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBESUQgXCIgKyBkaWQpO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZnVuY3Rpb24gcmVzb2x2ZShkaWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJzZWQsIHJlc29sdmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBwYXJzZShkaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IFJFR0lTVFJZW3BhcnNlZC5tZXRob2RdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZXIoZGlkLCBwYXJzZWQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgRElEIG1ldGhvZDogJ1wiICsgcGFyc2VkLm1ldGhvZCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSByZXNvbHZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIiwiLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuOC4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIElOUFVUX0VSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7XG4gIHZhciBGSU5BTElaRV9FUlJPUiA9ICdmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZCc7XG4gIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbiAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTtcbiAgaWYgKHJvb3QuSlNfU0hBM19OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdO1xuICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07XG4gIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07XG4gIHZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTtcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxuICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcbiAgICAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSxcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcbiAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XG4gIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07XG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheScsICdkaWdlc3QnXTtcbiAgdmFyIENTSEFLRV9CWVRFUEFEID0ge1xuICAgICcxMjgnOiAxNjgsXG4gICAgJzI1Nic6IDEzNlxuICB9O1xuXG4gIGlmIChyb290LkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1snY3NoYWtlJyArIGJpdHNdLnVwZGF0ZShtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kLCBjcmVhdGVNZXRob2QsIGJpdHMsIHBhZGRpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVNZXRob2QoYml0cywgcGFkZGluZywgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIGlmICghbiAmJiAhcykge1xuICAgICAgICByZXR1cm4gbWV0aG9kc1snc2hha2UnICsgYml0c10uY3JlYXRlKG91dHB1dEJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbbiwgc10sIHcpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzLCBuLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUttYWNPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbmV3IEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbJ0tNQUMnLCBzXSwgdykuYnl0ZXBhZChba2V5XSwgdyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5LCBvdXRwdXRCaXRzLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBhbGdvcml0aG1zID0gW1xuICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2ttYWMnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVLbWFjTWV0aG9kIH1cbiAgXTtcblxuICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxnb3JpdGhtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xuICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgJ18nICsgYml0c1tqXTtcbiAgICAgIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gICAgICBpZiAoYWxnb3JpdGhtLm5hbWUgIT09ICdzaGEzJykge1xuICAgICAgICB2YXIgbmV3TWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgYml0c1tqXTtcbiAgICAgICAgbWV0aG9kTmFtZXMucHVzaChuZXdNZXRob2ROYW1lKTtcbiAgICAgICAgbWV0aG9kc1tuZXdNZXRob2ROYW1lXSA9IG1ldGhvZHNbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgIHRoaXMucyA9IFtdO1xuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy5vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmxvY2sgPSAwO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcbiAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcbiAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XG4gICAgICB0aGlzLnNbaV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihGSU5BTElaRV9FUlJPUik7XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGJ5dGVDb3VudCA9IHRoaXMuYnl0ZUNvdW50LCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmKHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh4LCByaWdodCkge1xuICAgIHZhciBvID0geCAmIDI1NSwgbiA9IDE7XG4gICAgdmFyIGJ5dGVzID0gW29dO1xuICAgIHggPSB4ID4+IDg7XG4gICAgbyA9IHggJiAyNTU7XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG8pO1xuICAgICAgeCA9IHggPj4gODtcbiAgICAgIG8gPSB4ICYgMjU1O1xuICAgICAgKytuO1xuICAgIH1cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIGJ5dGVzLnB1c2gobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzLnVuc2hpZnQobik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2Ygc3RyO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBzdHIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgYnl0ZXMgPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJ5dGVzICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGUoYnl0ZXMgKiA4KTtcbiAgICB0aGlzLnVwZGF0ZShzdHIpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3Rycywgdykge1xuICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7XG4gICAgfVxuICAgIHZhciBwYWRkaW5nQnl0ZXMgPSB3IC0gYnl0ZXMgJSB3O1xuICAgIHZhciB6ZXJvcyA9IFtdO1xuICAgIHplcm9zLmxlbmd0aCA9IHBhZGRpbmdCeXRlcztcbiAgICB0aGlzLnVwZGF0ZSh6ZXJvcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleCwgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xuICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBibG9ja3NbYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xuICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgfVxuICAgIGYocyk7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBhcnJheVtpXSA9IHNbaV07XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcblxuICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgZnVuY3Rpb24gS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgS2VjY2FrLmNhbGwodGhpcywgYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gIH1cblxuICBLbWFjLnByb3RvdHlwZSA9IG5ldyBLZWNjYWsoKTtcblxuICBLbWFjLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsIHRydWUpO1xuICAgIHJldHVybiBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSxcbiAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNyxcbiAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMyxcbiAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XG4gICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XG4gICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XG4gICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XG5cbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XG4gICAgICBsID0gYzkgXiAoKGMzIDw8IDEpIHwgKGMyID4+PiAzMSkpO1xuICAgICAgc1swXSBePSBoO1xuICAgICAgc1sxXSBePSBsO1xuICAgICAgc1sxMF0gXj0gaDtcbiAgICAgIHNbMTFdIF49IGw7XG4gICAgICBzWzIwXSBePSBoO1xuICAgICAgc1syMV0gXj0gbDtcbiAgICAgIHNbMzBdIF49IGg7XG4gICAgICBzWzMxXSBePSBsO1xuICAgICAgc1s0MF0gXj0gaDtcbiAgICAgIHNbNDFdIF49IGw7XG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xuICAgICAgbCA9IGMxIF4gKChjNSA8PCAxKSB8IChjNCA+Pj4gMzEpKTtcbiAgICAgIHNbMl0gXj0gaDtcbiAgICAgIHNbM10gXj0gbDtcbiAgICAgIHNbMTJdIF49IGg7XG4gICAgICBzWzEzXSBePSBsO1xuICAgICAgc1syMl0gXj0gaDtcbiAgICAgIHNbMjNdIF49IGw7XG4gICAgICBzWzMyXSBePSBoO1xuICAgICAgc1szM10gXj0gbDtcbiAgICAgIHNbNDJdIF49IGg7XG4gICAgICBzWzQzXSBePSBsO1xuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMyBeICgoYzcgPDwgMSkgfCAoYzYgPj4+IDMxKSk7XG4gICAgICBzWzRdIF49IGg7XG4gICAgICBzWzVdIF49IGw7XG4gICAgICBzWzE0XSBePSBoO1xuICAgICAgc1sxNV0gXj0gbDtcbiAgICAgIHNbMjRdIF49IGg7XG4gICAgICBzWzI1XSBePSBsO1xuICAgICAgc1szNF0gXj0gaDtcbiAgICAgIHNbMzVdIF49IGw7XG4gICAgICBzWzQ0XSBePSBoO1xuICAgICAgc1s0NV0gXj0gbDtcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XG4gICAgICBsID0gYzUgXiAoKGM5IDw8IDEpIHwgKGM4ID4+PiAzMSkpO1xuICAgICAgc1s2XSBePSBoO1xuICAgICAgc1s3XSBePSBsO1xuICAgICAgc1sxNl0gXj0gaDtcbiAgICAgIHNbMTddIF49IGw7XG4gICAgICBzWzI2XSBePSBoO1xuICAgICAgc1syN10gXj0gbDtcbiAgICAgIHNbMzZdIF49IGg7XG4gICAgICBzWzM3XSBePSBsO1xuICAgICAgc1s0Nl0gXj0gaDtcbiAgICAgIHNbNDddIF49IGw7XG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xuICAgICAgbCA9IGM3IF4gKChjMSA8PCAxKSB8IChjMCA+Pj4gMzEpKTtcbiAgICAgIHNbOF0gXj0gaDtcbiAgICAgIHNbOV0gXj0gbDtcbiAgICAgIHNbMThdIF49IGg7XG4gICAgICBzWzE5XSBePSBsO1xuICAgICAgc1syOF0gXj0gaDtcbiAgICAgIHNbMjldIF49IGw7XG4gICAgICBzWzM4XSBePSBoO1xuICAgICAgc1szOV0gXj0gbDtcbiAgICAgIHNbNDhdIF49IGg7XG4gICAgICBzWzQ5XSBePSBsO1xuXG4gICAgICBiMCA9IHNbMF07XG4gICAgICBiMSA9IHNbMV07XG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcbiAgICAgIGIzMyA9IChzWzEwXSA8PCA0KSB8IChzWzExXSA+Pj4gMjgpO1xuICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcbiAgICAgIGI0NiA9IChzWzMxXSA8PCA5KSB8IChzWzMwXSA+Pj4gMjMpO1xuICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XG4gICAgICBiMjkgPSAoc1s0MV0gPDwgMTgpIHwgKHNbNDBdID4+PiAxNCk7XG4gICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XG4gICAgICBiMiA9IChzWzEzXSA8PCAxMikgfCAoc1sxMl0gPj4+IDIwKTtcbiAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xuICAgICAgYjM1ID0gKHNbMjNdIDw8IDEwKSB8IChzWzIyXSA+Pj4gMjIpO1xuICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xuICAgICAgYjQ4ID0gKHNbNDJdIDw8IDIpIHwgKHNbNDNdID4+PiAzMCk7XG4gICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcbiAgICAgIGI0MSA9IChzWzRdIDw8IDMwKSB8IChzWzVdID4+PiAyKTtcbiAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XG4gICAgICBiNCA9IChzWzI1XSA8PCAxMSkgfCAoc1syNF0gPj4+IDIxKTtcbiAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xuICAgICAgYjM3ID0gKHNbMzVdIDw8IDE1KSB8IChzWzM0XSA+Pj4gMTcpO1xuICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcbiAgICAgIGIxMCA9IChzWzZdIDw8IDI4KSB8IChzWzddID4+PiA0KTtcbiAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xuICAgICAgYjQzID0gKHNbMTZdIDw8IDIzKSB8IChzWzE3XSA+Pj4gOSk7XG4gICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xuICAgICAgYjYgPSAoc1szNl0gPDwgMjEpIHwgKHNbMzddID4+PiAxMSk7XG4gICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xuICAgICAgYjM5ID0gKHNbNDZdIDw8IDI0KSB8IChzWzQ3XSA+Pj4gOCk7XG4gICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XG4gICAgICBiMTIgPSAoc1sxOF0gPDwgMjApIHwgKHNbMTldID4+PiAxMik7XG4gICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcbiAgICAgIGI0NSA9IChzWzI4XSA8PCA3KSB8IChzWzI5XSA+Pj4gMjUpO1xuICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcbiAgICAgIGI4ID0gKHNbNDhdIDw8IDE0KSB8IChzWzQ5XSA+Pj4gMTgpO1xuICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XG5cbiAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XG4gICAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpO1xuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XG4gICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcbiAgICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpO1xuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XG4gICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcbiAgICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpO1xuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XG4gICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcbiAgICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7XG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xuICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XG4gICAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTtcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xuICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XG4gICAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTtcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xuICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XG4gICAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTtcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XG4gICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xuICAgICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7XG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcbiAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xuICAgICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7XG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcbiAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xuICAgICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7XG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcbiAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XG4gICAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpO1xuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XG4gICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcbiAgICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApO1xuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XG4gICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcbiAgICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpO1xuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XG4gICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcbiAgICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7XG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xuICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XG4gICAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTtcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xuICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XG4gICAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTtcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xuICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XG4gICAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTtcblxuICAgICAgc1swXSBePSBSQ1tuXTtcbiAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcbiAgICB9XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJTlZBTElEX1VURjE2ID0gXCJ1dGY4OiBpbnZhbGlkIHN0cmluZ1wiO1xudmFyIElOVkFMSURfVVRGOCA9IFwidXRmODogaW52YWxpZCBzb3VyY2UgZW5jb2RpbmdcIjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTggYnl0ZSBhcnJheS5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlc3VsdCBsZW5ndGggYW5kIGFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAvLyBlbmNvZGVkTGVuZ3RoKCkgYWxzbyB2YWxpZGF0ZXMgc3RyaW5nIGFuZCB0aHJvd3MgZXJyb3JzLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgcmVwZWF0IHZhbGlkYXRpb24gaGVyZS5cbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZExlbmd0aChzKSk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4YzAgfCBjID4+IDY7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGUwIHwgYyA+PiAxMjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKzsgLy8gZ2V0IG9uZSBtb3JlIGNoYXJhY3RlclxuICAgICAgICAgICAgYyA9IChjICYgMHgzZmYpIDw8IDEwO1xuICAgICAgICAgICAgYyB8PSBzLmNoYXJDb2RlQXQoaSkgJiAweDNmZjtcbiAgICAgICAgICAgIGMgKz0gMHgxMDAwMDtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGYwIHwgYyA+PiAxODtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gMTIpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZExlbmd0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKzsgLy8gXCJlYXRcIiBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgZnJvbSBVVEYtOCBpbnRvIGEgc3RyaW5nLlxuICogVGhyb3dzIGlmIGVuY29kaW5nIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShhcnIpIHtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGFycltpXTtcbiAgICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGIgPCAweGUwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAxIG1vcmUgYnl0ZS5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MWYpIDw8IDYgfCAobjEgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDIgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxMiB8IChuMSAmIDB4M2YpIDw8IDYgfCAobjIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGY4KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAzIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMyA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCB8fCAobjMgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTggfCAobjEgJiAweDNmKSA8PCAxMiB8IChuMiAmIDB4M2YpIDw8IDYgfCAobjMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA8IG1pbiB8fCAoYiA+PSAweGQ4MDAgJiYgYiA8PSAweGRmZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+PSAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgaWYgKGIgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgfCAoYiA+PiAxMCkpKTtcbiAgICAgICAgICAgICAgICBiID0gMHhkYzAwIHwgKGIgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvYmFzZTY0dXJsJykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgSWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JylcbmNvbnN0IE9yYml0REJJZGVudGl0eVByb3ZpZGVyID0gcmVxdWlyZSgnLi9vcmJpdC1kYi1pZGVudGl0eS1wcm92aWRlcicpXG5jb25zdCBLZXlzdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWtleXN0b3JlJylcbmNvbnN0IHR5cGUgPSAnb3JiaXRkYidcbmNvbnN0IGlkZW50aXR5S2V5c1BhdGggPSAnLi9vcmJpdGRiL2lkZW50aXR5L2lkZW50aXR5a2V5cydcbmNvbnN0IHN1cHBvcnRlZFR5cGVzID0ge1xuICBvcmJpdGRiOiBPcmJpdERCSWRlbnRpdHlQcm92aWRlclxufVxuXG5jb25zdCBnZXRIYW5kbGVyRm9yID0gKHR5cGUpID0+IHtcbiAgaWYgKCFJZGVudGl0aWVzLmlzU3VwcG9ydGVkKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJZGVudGl0eVByb3ZpZGVyIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKVxuICB9XG4gIHJldHVybiBzdXBwb3J0ZWRUeXBlc1t0eXBlXVxufVxuXG5jbGFzcyBJZGVudGl0aWVzIHtcbiAgY29uc3RydWN0b3IgKGtleXN0b3JlKSB7XG4gICAgdGhpcy5fa2V5c3RvcmUgPSBrZXlzdG9yZVxuICB9XG5cbiAgYXN5bmMgc2lnbiAoaWRlbnRpdHksIGRhdGEpIHtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgdGhpcy5fa2V5c3RvcmUuZ2V0S2V5KGlkZW50aXR5LmlkKVxuICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcml2YXRlIHNpZ25pbmcga2V5IG5vdCBmb3VuZCBmcm9tIEtleXN0b3JlYClcbiAgICB9XG4gICAgY29uc3Qgc2lnID0gYXdhaXQgdGhpcy5fa2V5c3RvcmUuc2lnbihzaWduaW5nS2V5LCBkYXRhKVxuICAgIHJldHVybiBzaWdcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSAoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHZlcmlmaWVyID0gJ3YxJykge1xuICAgIHJldHVybiB0aGlzLl9rZXlzdG9yZS52ZXJpZnkoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHZlcmlmaWVyKVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlSWRlbnRpdHkgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IElkZW50aXR5UHJvdmlkZXIgPSBnZXRIYW5kbGVyRm9yKG9wdGlvbnMudHlwZSlcbiAgICBjb25zdCBpZGVudGl0eVByb3ZpZGVyID0gbmV3IElkZW50aXR5UHJvdmlkZXIob3B0aW9ucylcbiAgICBjb25zdCBpZCA9IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIuZ2V0SWQob3B0aW9ucylcbiAgICBpZiAob3B0aW9ucy5taWdyYXRlKSB7XG4gICAgICBhd2FpdCBvcHRpb25zLm1pZ3JhdGUoeyB0YXJnZXRQYXRoOiB0aGlzLl9rZXlzdG9yZS5wYXRoLCB0YXJnZXRJZDogaWQgfSlcbiAgICB9XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIGlkU2lnbmF0dXJlIH0gPSBhd2FpdCB0aGlzLnNpZ25JZChpZClcbiAgICBjb25zdCBwdWJLZXlJZFNpZ25hdHVyZSA9IGF3YWl0IGlkZW50aXR5UHJvdmlkZXIuc2lnbklkZW50aXR5KHB1YmxpY0tleSArIGlkU2lnbmF0dXJlLCBvcHRpb25zKVxuICAgIHJldHVybiBuZXcgSWRlbnRpdHkoaWQsIHB1YmxpY0tleSwgaWRTaWduYXR1cmUsIHB1YktleUlkU2lnbmF0dXJlLCBJZGVudGl0eVByb3ZpZGVyLnR5cGUsIHRoaXMpXG4gIH1cblxuICBhc3luYyBzaWduSWQgKGlkKSB7XG4gICAgY29uc3Qga2V5c3RvcmUgPSB0aGlzLl9rZXlzdG9yZVxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleXN0b3JlLmdldEtleShpZCkgfHwgYXdhaXQga2V5c3RvcmUuY3JlYXRlS2V5KGlkKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGtleXN0b3JlLmdldFB1YmxpYyhrZXkpXG4gICAgY29uc3QgaWRTaWduYXR1cmUgPSBhd2FpdCBrZXlzdG9yZS5zaWduKGtleSwgaWQpXG4gICAgcmV0dXJuIHsgcHVibGljS2V5LCBpZFNpZ25hdHVyZSB9XG4gIH1cblxuICBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IHRoaXMuX2tleXN0b3JlLnZlcmlmeShcbiAgICAgIGlkZW50aXR5LnNpZ25hdHVyZXMuaWQsXG4gICAgICBpZGVudGl0eS5wdWJsaWNLZXksXG4gICAgICBpZGVudGl0eS5pZFxuICAgIClcbiAgICByZXR1cm4gdmVyaWZpZWQgJiYgSWRlbnRpdGllcy52ZXJpZnlJZGVudGl0eShpZGVudGl0eSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnlJZGVudGl0eSAoaWRlbnRpdHkpIHtcbiAgICBjb25zdCBJZGVudGl0eVByb3ZpZGVyID0gZ2V0SGFuZGxlckZvcihpZGVudGl0eS50eXBlKVxuICAgIHJldHVybiBJZGVudGl0eVByb3ZpZGVyLnZlcmlmeUlkZW50aXR5KGlkZW50aXR5KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUlkZW50aXR5IChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBrZXlzdG9yZSA9IG9wdGlvbnMua2V5c3RvcmUgfHwgS2V5c3RvcmUuY3JlYXRlKG9wdGlvbnMuaWRlbnRpdHlLZXlzUGF0aCB8fCBpZGVudGl0eUtleXNQYXRoKVxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7IHR5cGUgfSwgb3B0aW9ucylcbiAgICBjb25zdCBpZGVudGl0aWVzID0gbmV3IElkZW50aXRpZXMoa2V5c3RvcmUpXG4gICAgcmV0dXJuIGlkZW50aXRpZXMuY3JlYXRlSWRlbnRpdHkob3B0aW9ucylcbiAgfVxuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCAodHlwZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdXBwb3J0ZWRUeXBlcykuaW5jbHVkZXModHlwZSlcbiAgfVxuXG4gIHN0YXRpYyBhZGRJZGVudGl0eVByb3ZpZGVyIChJZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgaWYgKCFJZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5UHJvdmlkZXIgY2xhc3MgbmVlZHMgdG8gYmUgZ2l2ZW4gYXMgYW4gb3B0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoIUlkZW50aXR5UHJvdmlkZXIudHlwZSB8fFxuICAgICAgdHlwZW9mIElkZW50aXR5UHJvdmlkZXIudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gSWRlbnRpdHlQcm92aWRlciBjbGFzcyBuZWVkcyB0byBpbXBsZW1lbnQ6IHN0YXRpYyBnZXQgdHlwZSgpIHsgLyogcmV0dXJuIGEgc3RyaW5nICovfS4nKVxuICAgIH1cblxuICAgIHN1cHBvcnRlZFR5cGVzW0lkZW50aXR5UHJvdmlkZXIudHlwZV0gPSBJZGVudGl0eVByb3ZpZGVyXG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlSWRlbnRpdHlQcm92aWRlciAodHlwZSkge1xuICAgIGRlbGV0ZSBzdXBwb3J0ZWRUeXBlc1t0eXBlXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpdGllc1xuIiwiY29uc3QgWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Jhc2U2NHVybCcpLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfU2ltcGxlU2lnbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9TaW1wbGVTaWduZXJcIikpO1xuXG52YXIgX05hY2xTaWduZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL05hY2xTaWduZXJcIikpO1xuXG52YXIgX0pXVCA9IHJlcXVpcmUoXCIuL0pXVFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNpbXBsZVNpZ25lcjogX1NpbXBsZVNpZ25lci5kZWZhdWx0LFxuICBOYWNsU2lnbmVyOiBfTmFjbFNpZ25lci5kZWZhdWx0LFxuICB2ZXJpZnlKV1Q6IF9KV1QudmVyaWZ5SldULFxuICBjcmVhdGVKV1Q6IF9KV1QuY3JlYXRlSldULFxuICBkZWNvZGVKV1Q6IF9KV1QuZGVjb2RlSldUXG59OyIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5cbmNsYXNzIEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdCB7XG4gIGNvbnN0cnVjdG9yICh0eXBlLCBwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtc1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIHJlc29sdmUgKGlwZnMsIG1hbmlmZXN0SGFzaCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcE1hbmlmZXN0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hbmlmZXN0LCBhY2Nlc3MtY29udHJvbGxlciB0eXBlIHJlcXVpcmVkYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQWNjZXNzQ29udHJvbGxlck1hbmlmZXN0KG9wdGlvbnMudHlwZSwgeyBhZGRyZXNzOiBtYW5pZmVzdEhhc2ggfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCBtdWx0aWhhc2hcbiAgICAgIGlmIChtYW5pZmVzdEhhc2guaW5kZXhPZignL2lwZnMnKSA9PT0gMCkgeyBtYW5pZmVzdEhhc2ggPSBtYW5pZmVzdEhhc2guc3BsaXQoJy8nKVsyXSB9XG4gICAgICBjb25zdCB7IHR5cGUsIHBhcmFtcyB9ID0gYXdhaXQgaW8ucmVhZChpcGZzLCBtYW5pZmVzdEhhc2gpXG4gICAgICByZXR1cm4gbmV3IEFjY2Vzc0NvbnRyb2xsZXJNYW5pZmVzdCh0eXBlLCBwYXJhbXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSAoaXBmcywgdHlwZSwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5za2lwTWFuaWZlc3QpIHtcbiAgICAgIHJldHVybiBwYXJhbXMuYWRkcmVzc1xuICAgIH1cbiAgICBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwYXJhbXM6IHBhcmFtc1xuICAgIH1cbiAgICByZXR1cm4gaW8ud3JpdGUoaXBmcywgJ2RhZy1jYm9yJywgbWFuaWZlc3QpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NDb250cm9sbGVyTWFuaWZlc3RcbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgaW8gPSByZXF1aXJlKCdvcmJpdC1kYi1pbycpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlci8nKS5CdWZmZXJcbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjY2Vzcy1jb250cm9sbGVyLWludGVyZmFjZScpXG5jb25zdCB0eXBlID0gJ2xlZ2FjeS1pcGZzJ1xuXG5jbGFzcyBMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlciBleHRlbmRzIEFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuX3dyaXRlID0gQXJyYXkuZnJvbShvcHRpb25zLndyaXRlIHx8IFtdKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgYWNjZXNzIGNvbnRyb2xsZXJcbiAgc3RhdGljIGdldCB0eXBlICgpIHsgcmV0dXJuIHR5cGUgfVxuXG4gIC8vIFJldHVybiBhIFNldCBvZiBrZXlzIHRoYXQgaGF2ZSBgYWNjZXNzYCBjYXBhYmlsaXR5XG4gIGdldCB3cml0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRlXG4gIH1cblxuICBhc3luYyBjYW5BcHBlbmQgKGVudHJ5LCBpZGVudGl0eVByb3ZpZGVyKSB7XG4gICAgLy8gQWxsb3cgaWYgYWNjZXNzIGxpc3QgY29udGFpbiB0aGUgd3JpdGVyJ3MgcHVibGljS2V5IG9yIGlzICcqJ1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGVudHJ5LmtleVxuICAgIGlmICh0aGlzLndyaXRlLmluY2x1ZGVzKHB1YmxpY0tleSkgfHxcbiAgICAgIHRoaXMud3JpdGUuaW5jbHVkZXMoJyonKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7XG4gICAgLy8gVHJhbnNmb3JtICcvaXBmcy9RbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIC8vIHRvICdRbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIGlmIChhZGRyZXNzLmluZGV4T2YoJy9pcGZzJykgPT09IDApIHsgYWRkcmVzcyA9IGFkZHJlc3Muc3BsaXQoJy8nKVsyXSB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWNjZXNzID0gYXdhaXQgaW8ucmVhZCh0aGlzLl9pcGZzLCBhZGRyZXNzKVxuICAgICAgdGhpcy5fd3JpdGUgPSBhY2Nlc3Mud3JpdGVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZygnTGVnYWN5SVBGU0FjY2Vzc0NvbnRyb2xsZXIubG9hZCBFUlJPUjonLCBlKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNhdmUgKG9wdGlvbnMpIHtcbiAgICBsZXQgY2lkXG4gICAgY29uc3QgYWNjZXNzID0geyBhZG1pbjogW10sIHdyaXRlOiB0aGlzLndyaXRlLCByZWFkOiBbXSB9XG4gICAgdHJ5IHtcbiAgICAgIGNpZCA9IGF3YWl0IGlvLndyaXRlKHRoaXMuX2lwZnMsICdyYXcnLCBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShhY2Nlc3MsIG51bGwsIDIpKSwgeyBmb3JtYXQ6ICdkYWctcGInfSlcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlci5zYXZlIEVSUk9SOicsIGUpXG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgbWFuaWZlc3QgZGF0YVxuICAgIHJldHVybiB7IGFkZHJlc3M6IGNpZCwgc2tpcE1hbmlmZXN0OiB0cnVlIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLnsgd3JpdGU6IG9wdGlvbnMud3JpdGUgfHwgW29yYml0ZGIuaWRlbnRpdHkucHVibGljS2V5XSB9IH1cbiAgICByZXR1cm4gbmV3IExlZ2FjeUlQRlNBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIuX2lwZnMsIG9wdGlvbnMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMZWdhY3lJUEZTQWNjZXNzQ29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBNYXBTZXJpZXMgPSByZXF1aXJlKCdwLW1hcC1zZXJpZXMnKVxuY29uc3QgQWNjZXNzQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vYWNjZXNzLWNvbnRyb2xsZXItaW50ZXJmYWNlJylcbmNvbnN0IGVuc3VyZUFkZHJlc3MgPSByZXF1aXJlKCcuL3V0aWxzL2Vuc3VyZS1hYy1hZGRyZXNzJylcblxuY29uc3QgdHlwZSA9ICdvcmJpdGRiJ1xuXG5jbGFzcyBPcmJpdERCQWNjZXNzQ29udHJvbGxlciBleHRlbmRzIEFjY2Vzc0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAob3JiaXRkYiwgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcmJpdGRiID0gb3JiaXRkYlxuICAgIHRoaXMuX2RiID0gbnVsbFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBhY2Nlc3MgY29udHJvbGxlclxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgT3JiaXREQiB1c2VkIGFzIHRoZSBBQ1xuICBnZXQgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLmFkZHJlc3NcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIGVudHJ5IGlzIGFsbG93ZWQgdG8gYmUgYWRkZWQgdG8gdGhlIGRhdGFiYXNlXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICAvLyBXcml0ZSBrZXlzIGFuZCBhZG1pbnMga2V5cyBhcmUgYWxsb3dlZFxuICAgIGNvbnN0IGFjY2VzcyA9IG5ldyBTZXQoWy4uLnRoaXMuZ2V0KCd3cml0ZScpLCAuLi50aGlzLmdldCgnYWRtaW4nKV0pXG4gICAgLy8gSWYgdGhlIEFDTCBjb250YWlucyB0aGUgd3JpdGVyJ3MgcHVibGljIGtleSBvciBpdCBjb250YWlucyAnKidcbiAgICBpZiAoYWNjZXNzLmhhcyhlbnRyeS5pZGVudGl0eS5pZCkgfHwgYWNjZXNzLmhhcygnKicpKSB7XG4gICAgICBjb25zdCB2ZXJpZmllZElkZW50aXR5ID0gYXdhaXQgaWRlbnRpdHlQcm92aWRlci52ZXJpZnlJZGVudGl0eShlbnRyeS5pZGVudGl0eSlcbiAgICAgIC8vIEFsbG93IGFjY2VzcyBpZiBpZGVudGl0eSB2ZXJpZmllc1xuICAgICAgcmV0dXJuIHZlcmlmaWVkSWRlbnRpdHlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldCBjYXBhYmlsaXRpZXMgKCkge1xuICAgIGlmICh0aGlzLl9kYikge1xuICAgICAgbGV0IGNhcGFiaWxpdGllcyA9IHRoaXMuX2RiLmluZGV4XG5cbiAgICAgIGNvbnN0IHRvU2V0ID0gKGUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZVswXVxuICAgICAgICBjYXBhYmlsaXRpZXNba2V5XSA9IG5ldyBTZXQoWy4uLihjYXBhYmlsaXRpZXNba2V5XSB8fCBbXSksIC4uLmVbMV1dKVxuICAgICAgfVxuXG4gICAgICAvLyBNZXJnZSB3aXRoIHRoZSBhY2Nlc3MgY29udHJvbGxlciBvZiB0aGUgZGF0YWJhc2VcbiAgICAgIC8vIGFuZCBtYWtlIHN1cmUgYWxsIHZhbHVlcyBhcmUgU2V0c1xuICAgICAgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAuLi5jYXBhYmlsaXRpZXMsXG4gICAgICAgIC8vIEFkZCB0aGUgcm9vdCBhY2Nlc3MgY29udHJvbGxlcidzICd3cml0ZScgYWNjZXNzIGxpc3RcbiAgICAgICAgLy8gYXMgYWRtaW5zIG9uIHRoaXMgY29udHJvbGxlclxuICAgICAgICAuLi57IGFkbWluOiBuZXcgU2V0KFsuLi4oY2FwYWJpbGl0aWVzLmFkbWluIHx8IFtdKSwgLi4udGhpcy5fZGIuYWNjZXNzLndyaXRlXSlcbiAgICAgICAgfVxuICAgICAgfSkuZm9yRWFjaCh0b1NldClcblxuICAgICAgcmV0dXJuIGNhcGFiaWxpdGllc1xuICAgIH1cbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIGdldCAoY2FwYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdGllc1tjYXBhYmlsaXR5XSB8fCBuZXcgU2V0KFtdKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXMuX2RiLmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIGxvYWQgKGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5fZGIpIHsgYXdhaXQgdGhpcy5fZGIuY2xvc2UoKSB9XG5cbiAgICAvLyBGb3JjZSAnPGFkZHJlc3M+L19hY2Nlc3MnIG5hbWluZyBmb3IgdGhlIGRhdGFiYXNlXG4gICAgdGhpcy5fZGIgPSBhd2FpdCB0aGlzLl9vcmJpdGRiLmtleXZhbHVlKGVuc3VyZUFkZHJlc3MoYWRkcmVzcyksIHtcbiAgICAgIC8vIHVzZSBpcGZzIGNvbnRyb2xsZXIgYXMgYSBpbW11dGFibGUgXCJyb290IGNvbnRyb2xsZXJcIlxuICAgICAgYWNjZXNzQ29udHJvbGxlcjoge1xuICAgICAgICB0eXBlOiAnaXBmcycsXG4gICAgICAgIHdyaXRlOiB0aGlzLl9vcHRpb25zLmFkbWluIHx8IFt0aGlzLl9vcmJpdGRiLmlkZW50aXR5LmlkXVxuICAgICAgfSxcbiAgICAgIHN5bmM6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZWFkeScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCd3cml0ZScsIHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcykpXG4gICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSlcblxuICAgIGF3YWl0IHRoaXMuX2RiLmxvYWQoKVxuICB9XG5cbiAgYXN5bmMgc2F2ZSAoKSB7XG4gICAgLy8gcmV0dXJuIHRoZSBtYW5pZmVzdCBkYXRhXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IHRoaXMuX2RiLmFkZHJlc3MudG9TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdyYW50IChjYXBhYmlsaXR5LCBrZXkpIHtcbiAgICAvLyBNZXJnZSBjdXJyZW50IGtleXMgd2l0aCB0aGUgbmV3IGtleVxuICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IG5ldyBTZXQoWy4uLih0aGlzLl9kYi5nZXQoY2FwYWJpbGl0eSkgfHwgW10pLCAuLi5ba2V5XV0pXG4gICAgYXdhaXQgdGhpcy5fZGIucHV0KGNhcGFiaWxpdHksIEFycmF5LmZyb20oY2FwYWJpbGl0aWVzLnZhbHVlcygpKSlcbiAgfVxuXG4gIGFzeW5jIHJldm9rZSAoY2FwYWJpbGl0eSwga2V5KSB7XG4gICAgbGV0IGNhcGFiaWxpdGllcyA9IG5ldyBTZXQodGhpcy5fZGIuZ2V0KGNhcGFiaWxpdHkpIHx8IFtdKVxuICAgIGNhcGFiaWxpdGllcy5kZWxldGUoa2V5KVxuICAgIGlmIChjYXBhYmlsaXRpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RiLnB1dChjYXBhYmlsaXR5LCBBcnJheS5mcm9tKGNhcGFiaWxpdGllcy52YWx1ZXMoKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuX2RiLmRlbChjYXBhYmlsaXR5KVxuICAgIH1cbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuICBfb25VcGRhdGUgKCkge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpXG4gIH1cblxuICAvKiBGYWN0b3J5ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUgKG9yYml0ZGIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFjID0gbmV3IE9yYml0REJBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIsIG9wdGlvbnMpXG4gICAgYXdhaXQgYWMubG9hZChvcHRpb25zLmFkZHJlc3MgfHwgb3B0aW9ucy5uYW1lIHx8ICdkZWZhdWx0LWFjY2Vzcy1jb250cm9sbGVyJylcblxuICAgIC8vIEFkZCB3cml0ZSBhY2Nlc3MgZnJvbSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMud3JpdGUgJiYgIW9wdGlvbnMuYWRkcmVzcykge1xuICAgICAgYXdhaXQgcE1hcFNlcmllcyhvcHRpb25zLndyaXRlLCBhc3luYyAoZSkgPT4gYWMuZ3JhbnQoJ3dyaXRlJywgZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFjXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPcmJpdERCQWNjZXNzQ29udHJvbGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB7IGlvIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjY2Vzcy1jb250cm9sbGVyLWludGVyZmFjZScpXG5jb25zdCB0eXBlID0gJ2lwZnMnXG5cbmNsYXNzIElQRlNBY2Nlc3NDb250cm9sbGVyIGV4dGVuZHMgQWNjZXNzQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChpcGZzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2lwZnMgPSBpcGZzXG4gICAgdGhpcy5fd3JpdGUgPSBBcnJheS5mcm9tKG9wdGlvbnMud3JpdGUgfHwgW10pXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBhY2Nlc3MgY29udHJvbGxlclxuICBzdGF0aWMgZ2V0IHR5cGUgKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgLy8gUmV0dXJuIGEgU2V0IG9mIGtleXMgdGhhdCBoYXZlIGBhY2Nlc3NgIGNhcGFiaWxpdHlcbiAgZ2V0IHdyaXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGVcbiAgfVxuXG4gIGFzeW5jIGNhbkFwcGVuZCAoZW50cnksIGlkZW50aXR5UHJvdmlkZXIpIHtcbiAgICAvLyBBbGxvdyBpZiBhY2Nlc3MgbGlzdCBjb250YWluIHRoZSB3cml0ZXIncyBwdWJsaWNLZXkgb3IgaXMgJyonXG4gICAgY29uc3Qga2V5ID0gZW50cnkuaWRlbnRpdHkuaWRcbiAgICBpZiAodGhpcy53cml0ZS5pbmNsdWRlcyhrZXkpIHx8IHRoaXMud3JpdGUuaW5jbHVkZXMoJyonKSkge1xuICAgICAgLy9jaGVjayBpZGVudGl0eSBpcyB2YWxpZFxuICAgICAgcmV0dXJuIGlkZW50aXR5UHJvdmlkZXIudmVyaWZ5SWRlbnRpdHkoZW50cnkuaWRlbnRpdHkpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cblxuICBhc3luYyBsb2FkIChhZGRyZXNzKSB7XG4gICAgLy8gVHJhbnNmb3JtICcvaXBmcy9RbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIC8vIHRvICdRbVBGdEhpM2NtZlplcnh0SDl5U0xkenBnMXlGaG9jWURaZ0VaeXdkVVhIeEZVJ1xuICAgIGlmIChhZGRyZXNzLmluZGV4T2YoJy9pcGZzJykgPT09IDApIHsgYWRkcmVzcyA9IGFkZHJlc3Muc3BsaXQoJy8nKVsyXSB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fd3JpdGUgPSBhd2FpdCBpby5yZWFkKHRoaXMuX2lwZnMsIGFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0lQRlNBY2Nlc3NDb250cm9sbGVyLmxvYWQgRVJST1I6JywgZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlICgpIHtcbiAgICBsZXQgY2lkXG4gICAgdHJ5IHtcblxuICAgICAgY2lkID0gYXdhaXQgaW8ud3JpdGUodGhpcy5faXBmcywgJ2RhZy1jYm9yJywgeyB3cml0ZTogSlNPTi5zdHJpbmdpZnkodGhpcy53cml0ZSwgbnVsbCwgMikgfSlcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJUEZTQWNjZXNzQ29udHJvbGxlci5zYXZlIEVSUk9SOicsIGUpXG4gICAgfVxuICAgIC8vIHJldHVybiB0aGUgbWFuaWZlc3QgZGF0YVxuICAgIHJldHVybiB7IGFkZHJlc3M6IGNpZCB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlIChvcmJpdGRiLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi57IHdyaXRlOiBvcHRpb25zLndyaXRlIHx8IFtvcmJpdGRiLmlkZW50aXR5LmlkXSB9IH1cbiAgICByZXR1cm4gbmV3IElQRlNBY2Nlc3NDb250cm9sbGVyKG9yYml0ZGIuX2lwZnMsIG9wdGlvbnMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJUEZTQWNjZXNzQ29udHJvbGxlclxuIiwiY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5jb25zdCBkYWdQQiA9IHJlcXVpcmUoJ2lwbGQtZGFnLXBiJylcbmNvbnN0IGRlZmF1bHRCYXNlID0gJ2Jhc2U1OGJ0YydcblxuY29uc3QgY2lkaWZ5U3RyaW5nID0gKHN0cikgPT4ge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLm1hcChjaWRpZnlTdHJpbmcpXG4gIH1cblxuICByZXR1cm4gbmV3IENJRChzdHIpXG59XG5cbmNvbnN0IHN0cmluZ2lmeUNpZCA9IChjaWQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFjaWQpIHtcbiAgICByZXR1cm4gY2lkXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjaWQpKSB7XG4gICAgcmV0dXJuIGNpZC5tYXAoc3RyaW5naWZ5Q2lkKVxuICB9XG4gIFxuICBpZiAoY2lkWycvJ10pIHtcbiAgICByZXR1cm4gY2lkWycvJ11cbiAgfVxuXG4gIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgZGVmYXVsdEJhc2VcbiAgcmV0dXJuIGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKGJhc2UpXG59XG5cbmNvbnN0IHdyaXRlUGIgPSBhc3luYyAoaXBmcywgb2JqKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KG9iaikpXG4gIGNvbnN0IGRhZ05vZGUgPSBkYWdQQi5EQUdOb2RlLmNyZWF0ZShidWZmZXIpXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGlwZnMuZGFnLnB1dChkYWdOb2RlLCB7XG4gICAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgICBoYXNoQWxnOiAnc2hhMi0yNTYnXG4gIH0pXG5cbiAgcmV0dXJuIGNpZC50b1YwKCkudG9CYXNlRW5jb2RlZFN0cmluZygpXG59XG5cbmNvbnN0IHJlYWRQYiA9IGFzeW5jIChpcGZzLCBjaWQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXBmcy5kYWcuZ2V0KGNpZClcbiAgY29uc3QgZGFnTm9kZSA9IHJlc3VsdC52YWx1ZVxuXG4gIHJldHVybiBKU09OLnBhcnNlKGRhZ05vZGUudG9KU09OKCkuZGF0YSlcbn1cblxuY29uc3Qgd3JpdGVDYm9yID0gYXN5bmMgKGlwZnMsIG9iaiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBkYWdOb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKVxuICBjb25zdCBsaW5rcyA9IG9wdGlvbnMubGlua3MgfHwgW11cbiAgbGlua3MuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGRhZ05vZGVbcHJvcF0gPSBjaWRpZnlTdHJpbmcoZGFnTm9kZVtwcm9wXSlcbiAgfSlcblxuICBjb25zdCBiYXNlID0gb3B0aW9ucy5iYXNlIHx8IGRlZmF1bHRCYXNlXG4gIGNvbnN0IG9ubHlIYXNoID0gb3B0aW9ucy5vbmx5SGFzaCB8fCBmYWxzZVxuICBjb25zdCBjaWQgPSBhd2FpdCBpcGZzLmRhZy5wdXQoZGFnTm9kZSwgeyBvbmx5SGFzaCB9KVxuICByZXR1cm4gY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoYmFzZSlcbn1cblxuY29uc3QgcmVhZENib3IgPSBhc3luYyAoaXBmcywgY2lkLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlwZnMuZGFnLmdldChjaWQpXG4gIGNvbnN0IG9iaiA9IHJlc3VsdC52YWx1ZVxuICBjb25zdCBsaW5rcyA9IG9wdGlvbnMubGlua3MgfHwgW11cbiAgbGlua3MuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIG9ialtwcm9wXSA9IHN0cmluZ2lmeUNpZChvYmpbcHJvcF0sIG9wdGlvbnMpXG4gIH0pXG5cbiAgcmV0dXJuIG9ialxufVxuXG5jb25zdCB3cml0ZU9iaiA9IGFzeW5jIChpcGZzLCBvYmosIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgb25seUhhc2ggPSBvcHRpb25zLm9ubHlIYXNoIHx8IGZhbHNlXG4gIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgZGVmYXVsdEJhc2VcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHsgb25seUhhc2g6IG9ubHlIYXNoIH0sIG9wdGlvbnMuZm9ybWF0ID8geyBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LCBoYXNoQWxnOiAnc2hhMi0yNTYnIH0gOiB7fSlcbiAgaWYgKG9wdHMuZm9ybWF0ID09PSAnZGFnLXBiJykge1xuICAgIG9iaiA9IGRhZ1BCLkRBR05vZGUuY3JlYXRlKG9iailcbiAgfVxuXG4gIGNvbnN0IGNpZCA9IGF3YWl0IGlwZnMuZGFnLnB1dChvYmosIG9wdHMpXG4gIHJldHVybiBjaWQudG9CYXNlRW5jb2RlZFN0cmluZyhiYXNlKVxufVxuXG5jb25zdCBmb3JtYXRzID0ge1xuICAnZGFnLXBiJzogeyByZWFkOiByZWFkUGIsIHdyaXRlOiB3cml0ZVBiIH0sXG4gICdkYWctY2Jvcic6IHsgd3JpdGU6IHdyaXRlQ2JvciwgcmVhZDogcmVhZENib3IgfSxcbiAgJ3Jhdyc6IHsgd3JpdGU6IHdyaXRlT2JqIH1cbn1cblxuY29uc3Qgd3JpdGUgPSAoaXBmcywgY29kZWMsIG9iaiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHNbY29kZWNdXG4gIGlmICghZm9ybWF0KSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvZGVjJylcblxuICByZXR1cm4gZm9ybWF0LndyaXRlKGlwZnMsIG9iaiwgb3B0aW9ucylcbn1cblxuY29uc3QgcmVhZCA9IChpcGZzLCBjaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjaWQgPSBuZXcgQ0lEKGNpZClcbiAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tjaWQuY29kZWNdXG5cbiAgaWYgKCFmb3JtYXQpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29kZWMnKVxuXG4gIHJldHVybiBmb3JtYXQucmVhZChpcGZzLCBjaWQsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWFkLFxuICB3cml0ZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4vLyBNYWtlIHN1cmUgdGhlIGdpdmVuIGFkZHJlc3MgaGFzICcvX2FjY2VzcycgYXMgdGhlIGxhc3QgcGFydFxuY29uc3QgZW5zdXJlQWRkcmVzcyA9IGFkZHJlc3MgPT4ge1xuICBjb25zdCBzdWZmaXggPSBhZGRyZXNzLnRvU3RyaW5nKCkuc3BsaXQoJy8nKS5wb3AoKVxuICByZXR1cm4gc3VmZml4ID09PSAnX2FjY2VzcydcbiAgICA/IGFkZHJlc3NcbiAgICA6IHBhdGguam9pbihhZGRyZXNzLCAnL19hY2Nlc3MnKVxufVxubW9kdWxlLmV4cG9ydHMgPSBlbnN1cmVBZGRyZXNzXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgRmVlZEluZGV4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fVxuICB9XG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pbmRleCkubWFwKChmKSA9PiB0aGlzLl9pbmRleFtmXSlcbiAgfVxuXG4gIHVwZGF0ZUluZGV4KG9wbG9nKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fVxuICAgIG9wbG9nLnZhbHVlcy5yZWR1Y2UoKGhhbmRsZWQsIGl0ZW0pID0+IHtcbiAgICAgIGlmKCFoYW5kbGVkLmluY2x1ZGVzKGl0ZW0uaGFzaCkpIHtcbiAgICAgICAgaGFuZGxlZC5wdXNoKGl0ZW0uaGFzaClcbiAgICAgICAgaWYoaXRlbS5wYXlsb2FkLm9wID09PSAnQUREJykge1xuICAgICAgICAgIHRoaXMuX2luZGV4W2l0ZW0uaGFzaF0gPSBpdGVtXG4gICAgICAgIH0gZWxzZSBpZihpdGVtLnBheWxvYWQub3AgPT09ICdERUwnKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC52YWx1ZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZWRcbiAgICB9LCBbXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRJbmRleFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEV2ZW50SW5kZXgge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5faW5kZXggPSBudWxsXG4gIH1cblxuICBnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleCA/IHRoaXMuX2luZGV4LnZhbHVlcyA6IFtdXG4gIH1cblxuICB1cGRhdGVJbmRleCAob3Bsb2cpIHtcbiAgICB0aGlzLl9pbmRleCA9IG9wbG9nXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEluZGV4XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5jb25zdCBtYXBTZXJpZXMgPSByZXF1aXJlKCdwLWVhY2gtc2VyaWVzJylcbmNvbnN0IExvZyA9IHJlcXVpcmUoJ2lwZnMtbG9nJylcbmNvbnN0IEluZGV4ID0gcmVxdWlyZSgnLi9JbmRleCcpXG5jb25zdCBSZXBsaWNhdG9yID0gcmVxdWlyZSgnLi9SZXBsaWNhdG9yJylcbmNvbnN0IFJlcGxpY2F0aW9uSW5mbyA9IHJlcXVpcmUoJy4vcmVwbGljYXRpb24taW5mbycpXG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJ2xvZ3BsZWFzZScpXG5jb25zdCBsb2dnZXIgPSBMb2dnZXIuY3JlYXRlKCdvcmJpdC1kYi5zdG9yZScsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuQmx1ZSB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5jb25zdCBkYWdOb2RlID0gcmVxdWlyZSgnb3JiaXQtZGItaW8nKVxuXG5jb25zdCBEZWZhdWx0T3B0aW9ucyA9IHtcbiAgSW5kZXg6IEluZGV4LFxuICBtYXhIaXN0b3J5OiAtMSxcbiAgZGlyZWN0b3J5OiAnLi9vcmJpdGRiJyxcbiAgZmV0Y2hFbnRyeVRpbWVvdXQ6IG51bGwsXG4gIHJlcGxpY2F0ZTogdHJ1ZSxcbiAgcmVmZXJlbmNlQ291bnQ6IDY0LFxuICByZXBsaWNhdGlvbkNvbmN1cnJlbmN5OiAxMjgsXG4gIHN5bmNMb2NhbDogZmFsc2UsXG4gIHNvcnRGbjogdW5kZWZpbmVkXG59XG5cbmNsYXNzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKGlwZnMsIGlkZW50aXR5LCBhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFpZGVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eSByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBvcHRpb25zXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBEZWZhdWx0T3B0aW9ucylcbiAgICBPYmplY3QuYXNzaWduKG9wdHMsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0c1xuXG4gICAgLy8gRGVmYXVsdCB0eXBlXG4gICAgdGhpcy5fdHlwZSA9ICdzdG9yZSdcblxuICAgIC8vIENyZWF0ZSBJRHMsIG5hbWVzIGFuZCBwYXRoc1xuICAgIHRoaXMuaWQgPSBhZGRyZXNzLnRvU3RyaW5nKClcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHlcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXG4gICAgdGhpcy5kYm5hbWUgPSBhZGRyZXNzLnBhdGggfHwgJydcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuXG4gICAgLy8gRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gICAgdGhpcy5faXBmcyA9IGlwZnNcbiAgICB0aGlzLl9jYWNoZSA9IG9wdGlvbnMuY2FjaGVcblxuICAgIC8vIEFjY2VzcyBtYXBwaW5nXG4gICAgY29uc3QgZGVmYXVsdEFjY2VzcyA9IHtcbiAgICAgIGNhbkFwcGVuZDogKGVudHJ5KSA9PiAoZW50cnkuaWRlbnRpdHkucHVibGljS2V5ID09PSBpZGVudGl0eS5wdWJsaWNLZXkpXG4gICAgfVxuICAgIHRoaXMuYWNjZXNzID0gb3B0aW9ucy5hY2Nlc3NDb250cm9sbGVyIHx8IGRlZmF1bHRBY2Nlc3NcblxuICAgIC8vIENyZWF0ZSB0aGUgb3BlcmF0aW9ucyBsb2dcbiAgICB0aGlzLl9vcGxvZyA9IG5ldyBMb2codGhpcy5faXBmcywgdGhpcy5pZGVudGl0eSwgeyBsb2dJZDogdGhpcy5pZCwgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuIH0pXG5cbiAgICAvLyBDcmVhdGUgdGhlIGluZGV4XG4gICAgdGhpcy5faW5kZXggPSBuZXcgdGhpcy5vcHRpb25zLkluZGV4KHRoaXMuYWRkcmVzcy5yb290KVxuXG4gICAgLy8gUmVwbGljYXRpb24gcHJvZ3Jlc3MgaW5mb1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzID0gbmV3IFJlcGxpY2F0aW9uSW5mbygpXG5cbiAgICAvLyBTdGF0aXN0aWNzXG4gICAgdGhpcy5fc3RhdHMgPSB7XG4gICAgICBzbmFwc2hvdDoge1xuICAgICAgICBieXRlc0xvYWRlZDogLTFcbiAgICAgIH0sXG4gICAgICBzeW5jUmVxdWVzdHNSZWNlaWV2ZWQ6IDBcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fcmVwbGljYXRvciA9IG5ldyBSZXBsaWNhdG9yKHRoaXMsIHRoaXMub3B0aW9ucy5yZXBsaWNhdGlvbkNvbmN1cnJlbmN5KVxuICAgICAgLy8gRm9yIGludGVybmFsIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LFxuICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgIHRoaXMuX2xvYWRlciA9IHRoaXMuX3JlcGxpY2F0b3JcbiAgICAgIHRoaXMuX3JlcGxpY2F0b3Iub24oJ2xvYWQuYWRkZWQnLCAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXRlc3QgZW50cnkgc3RhdGUgKGxhdGVzdCBpcyB0aGUgZW50cnkgd2l0aCBsYXJnZXN0IGNsb2NrIHRpbWUpXG4gICAgICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLnF1ZXVlZCsrXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgoZW50cnkuY2xvY2sgPyBlbnRyeS5jbG9jay50aW1lIDogMClcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGA8cmVwbGljYXRlPmApXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JlcGxpY2F0ZScsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBlbnRyeSlcbiAgICAgIH0pXG4gICAgICB0aGlzLl9yZXBsaWNhdG9yLm9uKCdsb2FkLnByb2dyZXNzJywgKGlkLCBoYXNoLCBlbnRyeSwgaGF2ZSwgYnVmZmVyZWRMZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLmJ1ZmZlcmVkID4gYnVmZmVyZWRMZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3ModGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcyArIGJ1ZmZlcmVkTGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25Qcm9ncmVzcyh0aGlzLl9vcGxvZy5sZW5ndGggKyBidWZmZXJlZExlbmd0aClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXBsaWNhdGlvblN0YXR1cy5idWZmZXJlZCA9IGJ1ZmZlcmVkTGVuZ3RoXG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgodGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcylcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGA8cmVwbGljYXRlLnByb2dyZXNzPmApXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JlcGxpY2F0ZS5wcm9ncmVzcycsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBoYXNoLCBlbnRyeSwgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcywgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5tYXgpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBvbkxvYWRDb21wbGV0ZWQgPSBhc3luYyAobG9ncywgaGF2ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAobGV0IGxvZyBvZiBsb2dzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGxvZy5qb2luKGxvZylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucXVldWVkIC09IGxvZ3MubGVuZ3RoXG4gICAgICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMuYnVmZmVyZWQgPSB0aGlzLl9yZXBsaWNhdG9yLl9idWZmZXIubGVuZ3RoXG4gICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlSW5kZXgoKVxuXG4gICAgICAgICAgLy8gb25seSBzdG9yZSBoZWFkcyB0aGF0IGhhcyBiZWVuIHZlcmlmaWVkIGFuZCBtZXJnZXNcbiAgICAgICAgICBjb25zdCBoZWFkcyA9IHRoaXMuX29wbG9nLmhlYWRzXG4gICAgICAgICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0KCdfcmVtb3RlSGVhZHMnLCBoZWFkcylcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFNhdmVkIGhlYWRzICR7aGVhZHMubGVuZ3RofSBbJHtoZWFkcy5tYXAoZSA9PiBlLmhhc2gpLmpvaW4oJywgJyl9XWApXG5cbiAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYDxyZXBsaWNhdGVkPmApXG4gICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVwbGljYXRlZCcsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBsb2dzLmxlbmd0aClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVwbGljYXRvci5vbignbG9hZC5lbmQnLCBvbkxvYWRDb21wbGV0ZWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignU3RvcmUgRXJyb3I6JywgZSlcbiAgICB9XG4gIH1cblxuICBnZXQgYWxsICgpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLl9pbmRleC5faW5kZXgpXG4gICAgICA/IHRoaXMuX2luZGV4Ll9pbmRleFxuICAgICAgOiBPYmplY3Qua2V5cyh0aGlzLl9pbmRleC5faW5kZXgpLm1hcChlID0+IHRoaXMuX2luZGV4Ll9pbmRleFtlXSlcbiAgfVxuXG4gIGdldCBpbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4Ll9pbmRleFxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cblxuICBnZXQga2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YWJhc2UncyBjdXJyZW50IHJlcGxpY2F0aW9uIHN0YXR1cyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtbT2JqZWN0XX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZ2V0IHJlcGxpY2F0aW9uU3RhdHVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVwbGljYXRpb25TdGF0dXNcbiAgfVxuXG4gIHNldElkZW50aXR5IChpZGVudGl0eSkge1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eVxuICAgIHRoaXMuX29wbG9nLnNldElkZW50aXR5KGlkZW50aXR5KVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25DbG9zZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uQ2xvc2UodGhpcy5hZGRyZXNzLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gUmVwbGljYXRvciB0ZWFyZG93biBsb2dpY1xuICAgIHRoaXMuX3JlcGxpY2F0b3Iuc3RvcCgpXG5cbiAgICAvLyBSZXNldCByZXBsaWNhdGlvbiBzdGF0aXN0aWNzXG4gICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucmVzZXQoKVxuXG4gICAgLy8gUmVzZXQgZGF0YWJhc2Ugc3RhdGlzdGljc1xuICAgIHRoaXMuX3N0YXRzID0ge1xuICAgICAgc25hcHNob3Q6IHtcbiAgICAgICAgYnl0ZXNMb2FkZWQ6IC0xXG4gICAgICB9LFxuICAgICAgc3luY1JlcXVlc3RzUmVjZWlldmVkOiAwXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2xvYWQnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygnbG9hZC5wcm9ncmVzcycpXG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXBsaWNhdGUnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVwbGljYXRlLnByb2dyZXNzJylcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlcGxpY2F0ZWQnKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVhZHknKVxuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygnd3JpdGUnKVxuXG4gICAgLy8gQ2xvc2UgY2FjaGVcbiAgICBhd2FpdCB0aGlzLl9jYWNoZS5jbG9zZSgpXG5cbiAgICAvLyBEYXRhYmFzZSBpcyBub3cgY2xvc2VkXG4gICAgLy8gVE9ETzogYWZhaWsgd2UgZG9uJ3QgdXNlICdjbG9zZWQnIGV2ZW50IGFueW1vcmUsXG4gICAgLy8gdG8gYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICB0aGlzLmV2ZW50cy5lbWl0KCdjbG9zZWQnLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wcyBhIGRhdGFiYXNlIGFuZCByZW1vdmVzIGxvY2FsIGRhdGFcbiAgICogQHJldHVybiB7W05vbmVdfVxuICAgKi9cbiAgYXN5bmMgZHJvcCAoKSB7XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG4gICAgYXdhaXQgdGhpcy5fY2FjaGUuZGVzdHJveSgpXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLl9pbmRleCA9IG5ldyB0aGlzLm9wdGlvbnMuSW5kZXgodGhpcy5hZGRyZXNzLnJvb3QpXG4gICAgdGhpcy5fb3Bsb2cgPSBuZXcgTG9nKHRoaXMuX2lwZnMsIHRoaXMuaWRlbnRpdHksIHsgbG9nSWQ6IHRoaXMuaWQsIGFjY2VzczogdGhpcy5hY2Nlc3MsIHNvcnRGbjogdGhpcy5vcHRpb25zLnNvcnRGbiB9KVxuICAgIHRoaXMuX2NhY2hlID0gdGhpcy5vcHRpb25zLmNhY2hlXG4gIH1cblxuICBhc3luYyBsb2FkIChhbW91bnQsIHsgZmV0Y2hFbnRyeVRpbWVvdXQgfSA9IHt9KSB7XG4gICAgYW1vdW50ID0gYW1vdW50IHx8IHRoaXMub3B0aW9ucy5tYXhIaXN0b3J5XG4gICAgZmV0Y2hFbnRyeVRpbWVvdXQgPSBmZXRjaEVudHJ5VGltZW91dCB8fCB0aGlzLm9wdGlvbnMuZmV0Y2hFbnRyeVRpbWVvdXQ7XG5cbiAgICBjb25zdCBsb2NhbEhlYWRzID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdfbG9jYWxIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgcmVtb3RlSGVhZHMgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ19yZW1vdGVIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgaGVhZHMgPSBsb2NhbEhlYWRzLmNvbmNhdChyZW1vdGVIZWFkcylcblxuICAgIGlmIChoZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb2FkJywgdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCksIGhlYWRzKVxuICAgIH1cblxuICAgIGF3YWl0IG1hcFNlcmllcyhoZWFkcywgYXN5bmMgKGhlYWQpID0+IHtcbiAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXgoaGVhZC5jbG9jay50aW1lKVxuICAgICAgY29uc3QgbG9nID0gYXdhaXQgTG9nLmZyb21FbnRyeUhhc2godGhpcy5faXBmcywgdGhpcy5pZGVudGl0eSwgaGVhZC5oYXNoLCB7IGxvZ0lkOiB0aGlzLl9vcGxvZy5pZCwgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuLCBsZW5ndGg6IGFtb3VudCwgZXhjbHVkZTogdGhpcy5fb3Bsb2cudmFsdWVzLCBvblByb2dyZXNzQ2FsbGJhY2s6ICB0aGlzLl9vbkxvYWRQcm9ncmVzcy5iaW5kKHRoaXMpLCB0aW1lb3V0OiBmZXRjaEVudHJ5VGltZW91dCB9KVxuICAgICAgYXdhaXQgdGhpcy5fb3Bsb2cuam9pbihsb2csIGFtb3VudClcbiAgICB9KVxuXG4gICAgLy8gVXBkYXRlIHRoZSBpbmRleFxuICAgIGlmIChoZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVJbmRleCgpXG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMuZW1pdCgncmVhZHknLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgdGhpcy5fb3Bsb2cuaGVhZHMpXG4gIH1cblxuICBzeW5jIChoZWFkcykge1xuICAgIHRoaXMuX3N0YXRzLnN5bmNSZXF1ZXN0c1JlY2VpZXZlZCArPSAxXG4gICAgbG9nZ2VyLmRlYnVnKGBTeW5jIHJlcXVlc3QgIyR7dGhpcy5fc3RhdHMuc3luY1JlcXVlc3RzUmVjZWlldmVkfSAke2hlYWRzLmxlbmd0aH1gKVxuICAgIGlmIChoZWFkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRvIHNpbXVsYXRlIG5ldHdvcmsgbGF0ZW5jeSwgdW5jb21tZW50IHRoaXMgbGluZVxuICAgIC8vIGFuZCBjb21tZW50IG91dCB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAvLyBUaGF0IHdheSB0aGUgb2JqZWN0IChyZWNlaXZlZCBhcyBoZWFkIG1lc3NhZ2UgZnJvbSBwdWJzdWIpXG4gICAgLy8gZG9lc24ndCBnZXQgd3JpdHRlbiB0byBJUEZTIGFuZCBzbyB3aGVuIHRoZSBSZXBsaWNhdG9yIGlzIGZldGNoaW5nXG4gICAgLy8gdGhlIGxvZywgaXQnbGwgZmV0Y2ggaXQgZnJvbSB0aGUgbmV0d29yayBpbnN0ZWFkIGZyb20gdGhlIGRpc2suXG4gICAgLy8gcmV0dXJuIHRoaXMuX3JlcGxpY2F0b3IubG9hZChoZWFkcylcblxuICAgIGNvbnN0IHNhdmVUb0lwZnMgPSBhc3luYyAoaGVhZCkgPT4ge1xuICAgICAgaWYgKCFoZWFkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEdpdmVuIGlucHV0IGVudHJ5IHdhcyAnbnVsbCcuXCIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWRlbnRpdHlQcm92aWRlciA9IHRoaXMuaWRlbnRpdHkucHJvdmlkZXJcbiAgICAgIGlmICghaWRlbnRpdHlQcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eS1wcm92aWRlciBpcyByZXF1aXJlZCwgY2Fubm90IHZlcmlmeSBlbnRyeScpXG5cbiAgICAgIGNvbnN0IGNhbkFwcGVuZCA9IGF3YWl0IHRoaXMuYWNjZXNzLmNhbkFwcGVuZChoZWFkLCBpZGVudGl0eVByb3ZpZGVyKVxuICAgICAgaWYgKCFjYW5BcHBlbmQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBHaXZlbiBpbnB1dCBlbnRyeSBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIGxvZyBhbmQgd2FzIGRpc2NhcmRlZCAobm8gd3JpdGUgYWNjZXNzKS4nKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ0VudHJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZClcbiAgICAgIGxvZ0VudHJ5Lmhhc2ggPSBudWxsXG4gICAgICBjb25zdCBjb2RlYyA9IGxvZ0VudHJ5LnYgPT09IDAgPyAnZGFnLXBiJyA6ICdkYWctY2JvcidcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBkYWdOb2RlLndyaXRlKHRoaXMuX2lwZnMsIGNvZGVjLCBsb2dFbnRyeSwgeyBsaW5rczogWyduZXh0J10sIG9ubHlIYXNoOiB0cnVlIH0pXG5cbiAgICAgIGlmIChoYXNoICE9PSBoZWFkLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdcIldBUk5JTkchIEhlYWQgaGFzaCBkaWRuXFwndCBtYXRjaCB0aGUgY29udGVudHMnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVhZFxuICAgIH1cblxuICAgIHJldHVybiBtYXBTZXJpZXMoaGVhZHMsIHNhdmVUb0lwZnMpXG4gICAgICAudGhlbihhc3luYyAoc2F2ZWQpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGxpY2F0b3IubG9hZChzYXZlZC5maWx0ZXIoZSA9PiBlICE9PSBudWxsKSlcbiAgICAgIH0pXG4gIH1cblxuICBsb2FkTW9yZUZyb20gKGFtb3VudCwgZW50cmllcykge1xuICAgIHRoaXMuX3JlcGxpY2F0b3IubG9hZChlbnRyaWVzKVxuICB9XG5cbiAgYXN5bmMgc2F2ZVNuYXBzaG90ICgpIHtcbiAgICBjb25zdCB1bmZpbmlzaGVkID0gdGhpcy5fcmVwbGljYXRvci5nZXRRdWV1ZSgpXG5cbiAgICBsZXQgc25hcHNob3REYXRhID0gdGhpcy5fb3Bsb2cudG9TbmFwc2hvdCgpXG4gICAgbGV0IGhlYWRlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGlkOiBzbmFwc2hvdERhdGEuaWQsXG4gICAgICBoZWFkczogc25hcHNob3REYXRhLmhlYWRzLFxuICAgICAgc2l6ZTogc25hcHNob3REYXRhLnZhbHVlcy5sZW5ndGgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9KSlcbiAgICBjb25zdCBycyA9IG5ldyBSZWFkYWJsZSgpXG4gICAgbGV0IHNpemUgPSBuZXcgVWludDE2QXJyYXkoW2hlYWRlci5sZW5ndGhdKVxuICAgIGxldCBieXRlcyA9IEJ1ZmZlci5mcm9tKHNpemUuYnVmZmVyKVxuICAgIHJzLnB1c2goYnl0ZXMpXG4gICAgcnMucHVzaChoZWFkZXIpXG5cbiAgICBjb25zdCBhZGRUb1N0cmVhbSA9ICh2YWwpID0+IHtcbiAgICAgIGxldCBzdHIgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh2YWwpKVxuICAgICAgbGV0IHNpemUgPSBuZXcgVWludDE2QXJyYXkoW3N0ci5sZW5ndGhdKVxuICAgICAgcnMucHVzaChCdWZmZXIuZnJvbShzaXplLmJ1ZmZlcikpXG4gICAgICBycy5wdXNoKHN0cilcbiAgICB9XG5cbiAgICBzbmFwc2hvdERhdGEudmFsdWVzLmZvckVhY2goYWRkVG9TdHJlYW0pXG4gICAgcnMucHVzaChudWxsKSAvLyB0ZWxsIHRoZSBzdHJlYW0gd2UncmUgZmluaXNoZWRcblxuICAgIGNvbnN0IHNuYXBzaG90ID0gdGhpcy5faXBmcy5maWxlcy5hZGQgPyBhd2FpdCB0aGlzLl9pcGZzLmZpbGVzLmFkZChycykgOiBhd2FpdCB0aGlzLl9pcGZzLmFkZChycylcblxuICAgIGF3YWl0IHRoaXMuX2NhY2hlLnNldCgnc25hcHNob3QnLCBzbmFwc2hvdFtzbmFwc2hvdC5sZW5ndGggLSAxXSlcbiAgICBhd2FpdCB0aGlzLl9jYWNoZS5zZXQoJ3F1ZXVlJywgdW5maW5pc2hlZClcblxuICAgIGxvZ2dlci5kZWJ1ZyhgU2F2ZWQgc25hcHNob3Q6ICR7c25hcHNob3Rbc25hcHNob3QubGVuZ3RoIC0gMV0uaGFzaH0sIHF1ZXVlIGxlbmd0aDogJHt1bmZpbmlzaGVkLmxlbmd0aH1gKVxuXG4gICAgcmV0dXJuIHNuYXBzaG90XG4gIH1cblxuICBhc3luYyBsb2FkRnJvbVNuYXBzaG90IChvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb2FkJywgdGhpcy5hZGRyZXNzLnRvU3RyaW5nKCkpXG5cbiAgICBjb25zdCBtYXhDbG9jayA9IChyZXMsIHZhbCkgPT4gTWF0aC5tYXgocmVzLCB2YWwuY2xvY2sudGltZSlcblxuICAgIGNvbnN0IHF1ZXVlID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdxdWV1ZScpXG4gICAgdGhpcy5zeW5jKHF1ZXVlIHx8IFtdKVxuXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ3NuYXBzaG90JylcblxuICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5faXBmcy5maWxlcy5jYXRSZWFkYWJsZVN0cmVhbSA/IGF3YWl0IHRoaXMuX2lwZnMuZmlsZXMuY2F0UmVhZGFibGVTdHJlYW0oc25hcHNob3QuaGFzaCkgOiBhd2FpdCB0aGlzLl9pcGZzLmNhdFJlYWRhYmxlU3RyZWFtKHNuYXBzaG90Lmhhc2gpXG4gICAgICBjb25zdCBsb2FkU25hcHNob3REYXRhID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxldCBidWYgPSBCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICBsZXQgcSA9IFtdXG5cbiAgICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gKGQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2J5dGVTaXplICs9IGQubGVuZ3RoXG4gICAgICAgICAgICBpZiAocS5sZW5ndGggPCAyMDAwMCkge1xuICAgICAgICAgICAgICBxLnB1c2goZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBCdWZmZXIuY29uY2F0KHEpXG4gICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgYV0pXG4gICAgICAgICAgICAgIHEgPSBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBCdWZmZXIuY29uY2F0KHEpXG4gICAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgYV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1Zikge1xuICAgICAgICAgICAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmLmxlbmd0aClcbiAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYilcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gYnVmW2ldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFiXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclNpemUgPSBwYXJzZUludChuZXcgVWludDE2QXJyYXkodG9BcnJheUJ1ZmZlcihidWYuc2xpY2UoMCwgMikpKSlcbiAgICAgICAgICAgIGxldCBoZWFkZXJcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaGVhZGVyID0gSlNPTi5wYXJzZShidWYuc2xpY2UoMiwgaGVhZGVyU2l6ZSArIDIpKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXVxuICAgICAgICAgICAgbGV0IGEgPSAyICsgaGVhZGVyU2l6ZVxuICAgICAgICAgICAgd2hpbGUgKGEgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSBwYXJzZUludChuZXcgVWludDE2QXJyYXkodG9BcnJheUJ1ZmZlcihidWYuc2xpY2UoYSwgYSArIDIpKSkpXG4gICAgICAgICAgICAgIGEgKz0gMlxuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYnVmLnNsaWNlKGEsIGEgKyBzKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEgKz0gc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWVzOiB2YWx1ZXMsIGlkOiBoZWFkZXIuaWQsIGhlYWRzOiBoZWFkZXIuaGVhZHMsIHR5cGU6IGhlYWRlci50eXBlIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWVzOiB2YWx1ZXMsIGlkOiBudWxsLCBoZWFkczogbnVsbCwgdHlwZTogbnVsbCB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXMub24oJ2RhdGEnLCBidWZmZXJEYXRhKVxuICAgICAgICAgIHJlcy5vbignZW5kJywgZG9uZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IChoYXNoLCBlbnRyeSwgY291bnQsIHRvdGFsKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlUmVwbGljYXRpb25TdGF0dXMoY291bnQsIGVudHJ5LmNsb2NrLnRpbWUpXG4gICAgICAgIHRoaXMuX29uTG9hZFByb2dyZXNzKGhhc2gsIGVudHJ5KVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB0aGUgZW50cmllc1xuICAgICAgLy8gVGltZW91dCAxIHNlYyB0byBvbmx5IGxvYWQgZW50cmllcyB0aGF0IGFyZSBhbHJlYWR5IGZldGNoZWQgKGluIG9yZGVyIHRvIG5vdCBnZXQgc3R1Y2sgYXQgbG9hZGluZylcbiAgICAgIGNvbnN0IHNuYXBzaG90RGF0YSA9IGF3YWl0IGxvYWRTbmFwc2hvdERhdGEoKVxuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heChzbmFwc2hvdERhdGEudmFsdWVzLnJlZHVjZShtYXhDbG9jaywgMCkpXG4gICAgICBpZiAoc25hcHNob3REYXRhKSB7XG4gICAgICAgIGNvbnN0IGxvZyA9IGF3YWl0IExvZy5mcm9tSlNPTih0aGlzLl9pcGZzLCB0aGlzLmlkZW50aXR5LCBzbmFwc2hvdERhdGEsIHsgYWNjZXNzOiB0aGlzLmFjY2Vzcywgc29ydEZuOiB0aGlzLm9wdGlvbnMuc29ydEZuLCBsZW5ndGg6IC0xLCB0aW1lb3V0OiAxMDAwLCBvblByb2dyZXNzQ2FsbGJhY2s6IG9uUHJvZ3Jlc3MgfSlcbiAgICAgICAgYXdhaXQgdGhpcy5fb3Bsb2cuam9pbihsb2cpXG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUluZGV4KClcbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVwbGljYXRlZCcsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpKVxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHMuZW1pdCgncmVhZHknLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgdGhpcy5fb3Bsb2cuaGVhZHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcHNob3QgZm9yICR7dGhpcy5hZGRyZXNzfSBub3QgZm91bmQhYClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmMgX3VwZGF0ZUluZGV4ICgpIHtcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uTWF4KClcbiAgICBhd2FpdCB0aGlzLl9pbmRleC51cGRhdGVJbmRleCh0aGlzLl9vcGxvZylcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MoKVxuICB9XG5cbiAgYXN5bmMgc3luY0xvY2FsICgpIHtcbiAgICBjb25zdCBsb2NhbEhlYWRzID0gYXdhaXQgdGhpcy5fY2FjaGUuZ2V0KCdfbG9jYWxIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgcmVtb3RlSGVhZHMgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoJ19yZW1vdGVIZWFkcycpIHx8IFtdXG4gICAgY29uc3QgaGVhZHMgPSBsb2NhbEhlYWRzLmNvbmNhdChyZW1vdGVIZWFkcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoZWFkID0gaGVhZHNbaV1cbiAgICAgIGlmICghdGhpcy5fb3Bsb2cuaGVhZHMuaW5jbHVkZXMoaGVhZCkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkKClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfYWRkT3BlcmF0aW9uIChkYXRhLCBiYXRjaE9wZXJhdGlvbiwgbGFzdE9wZXJhdGlvbiwgb25Qcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX29wbG9nKSB7XG4gICAgICAvLyBjaGVjayBsb2NhbCBjYWNoZT9cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3luY0xvY2FsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0xvY2FsKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9vcGxvZy5hcHBlbmQoZGF0YSwgdGhpcy5vcHRpb25zLnJlZmVyZW5jZUNvdW50KVxuICAgICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvblN0YXR1cyh0aGlzLnJlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzICsgMSwgZW50cnkuY2xvY2sudGltZSlcbiAgICAgIGF3YWl0IHRoaXMuX2NhY2hlLnNldCgnX2xvY2FsSGVhZHMnLCBbZW50cnldKVxuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlSW5kZXgoKVxuICAgICAgdGhpcy5ldmVudHMuZW1pdCgnd3JpdGUnLCB0aGlzLmFkZHJlc3MudG9TdHJpbmcoKSwgZW50cnksIHRoaXMuX29wbG9nLmhlYWRzKVxuICAgICAgaWYgKG9uUHJvZ3Jlc3NDYWxsYmFjaykgb25Qcm9ncmVzc0NhbGxiYWNrKGVudHJ5KVxuICAgICAgcmV0dXJuIGVudHJ5Lmhhc2hcbiAgICB9XG4gIH1cblxuICBfYWRkT3BlcmF0aW9uQmF0Y2ggKGRhdGEsIGJhdGNoT3BlcmF0aW9uLCBsYXN0T3BlcmF0aW9uLCBvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCEnKVxuICB9XG5cbiAgX29uTG9hZFByb2dyZXNzIChoYXNoLCBlbnRyeSwgcHJvZ3Jlc3MsIHRvdGFsKSB7XG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvblN0YXR1cyhwcm9ncmVzcywgdG90YWwpXG4gICAgdGhpcy5ldmVudHMuZW1pdCgnbG9hZC5wcm9ncmVzcycsIHRoaXMuYWRkcmVzcy50b1N0cmluZygpLCBoYXNoLCBlbnRyeSwgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5wcm9ncmVzcywgdGhpcy5yZXBsaWNhdGlvblN0YXR1cy5tYXgpXG4gIH1cblxuICAvKiBSZXBsaWNhdGlvbiBTdGF0dXMgc3RhdGUgdXBkYXRlcyAqL1xuXG4gIF9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MgKG1heCkge1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzID0gTWF0aC5tYXguYXBwbHkobnVsbCwgW1xuICAgICAgdGhpcy5fcmVwbGljYXRpb25TdGF0dXMucHJvZ3Jlc3MsXG4gICAgICB0aGlzLl9vcGxvZy5sZW5ndGgsXG4gICAgICBtYXggfHwgMFxuICAgIF0pXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heCh0aGlzLnJlcGxpY2F0aW9uU3RhdHVzLnByb2dyZXNzKVxuICB9XG5cbiAgX3JlY2FsY3VsYXRlUmVwbGljYXRpb25NYXggKG1heCkge1xuICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLm1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIFtcbiAgICAgIHRoaXMuX3JlcGxpY2F0aW9uU3RhdHVzLm1heCxcbiAgICAgIHRoaXMuX29wbG9nLmxlbmd0aCxcbiAgICAgIG1heCB8fCAwXG4gICAgXSlcbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uU3RhdHVzIChtYXhQcm9ncmVzcywgbWF4VG90YWwpIHtcbiAgICB0aGlzLl9yZWNhbGN1bGF0ZVJlcGxpY2F0aW9uUHJvZ3Jlc3MobWF4UHJvZ3Jlc3MpXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVSZXBsaWNhdGlvbk1heChtYXhUb3RhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlXG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgS2V5VmFsdWVJbmRleCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luZGV4ID0ge31cbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhba2V5XVxuICB9XG5cbiAgdXBkYXRlSW5kZXgob3Bsb2cpIHtcbiAgICBvcGxvZy52YWx1ZXNcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAucmVkdWNlKChoYW5kbGVkLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmKCFoYW5kbGVkLmluY2x1ZGVzKGl0ZW0ucGF5bG9hZC5rZXkpKSB7XG4gICAgICAgICAgaGFuZGxlZC5wdXNoKGl0ZW0ucGF5bG9hZC5rZXkpXG4gICAgICAgICAgaWYoaXRlbS5wYXlsb2FkLm9wID09PSAnUFVUJykge1xuICAgICAgICAgICAgdGhpcy5faW5kZXhbaXRlbS5wYXlsb2FkLmtleV0gPSBpdGVtLnBheWxvYWQudmFsdWVcbiAgICAgICAgICB9IGVsc2UgaWYoaXRlbS5wYXlsb2FkLm9wID09PSAnREVMJykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC5rZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICB9LCBbXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVZhbHVlSW5kZXhcbiIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBEb2N1bWVudEluZGV4IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2luZGV4ID0ge31cbiAgfVxuXG4gIGdldCAoa2V5LCBmdWxsT3AgPSBmYWxzZSkge1xuICAgIHJldHVybiBmdWxsT3BcbiAgICAgID8gdGhpcy5faW5kZXhba2V5XVxuICAgICAgOiB0aGlzLl9pbmRleFtrZXldID8gdGhpcy5faW5kZXhba2V5XS5wYXlsb2FkLnZhbHVlIDogbnVsbFxuICB9XG5cbiAgdXBkYXRlSW5kZXggKG9wbG9nLCBvblByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICBjb25zdCByZWR1Y2VyID0gKGhhbmRsZWQsIGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgaWYgKGhhbmRsZWRbaXRlbS5wYXlsb2FkLmtleV0gIT09IHRydWUpIHtcbiAgICAgICAgaGFuZGxlZFtpdGVtLnBheWxvYWQua2V5XSA9IHRydWVcbiAgICAgICAgaWYoaXRlbS5wYXlsb2FkLm9wID09PSAnUFVUJykge1xuICAgICAgICAgIHRoaXMuX2luZGV4W2l0ZW0ucGF5bG9hZC5rZXldID0gaXRlbVxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ucGF5bG9hZC5vcCA9PT0gJ0RFTCcpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faW5kZXhbaXRlbS5wYXlsb2FkLmtleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9uUHJvZ3Jlc3NDYWxsYmFjaykgb25Qcm9ncmVzc0NhbGxiYWNrKGl0ZW0sIGlkeClcbiAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgfVxuXG4gICAgb3Bsb2cudmFsdWVzXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLnJlZHVjZShyZWR1Y2VyLCB7fSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50SW5kZXhcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gKGl0ZXJhYmxlLCBtYXBwZXIsIG9wdHMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGNvbmN1cnJlbmN5OiBJbmZpbml0eVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBjb25jdXJyZW5jeSA9IG9wdHMuY29uY3VycmVuY3k7XG5cblx0aWYgKGNvbmN1cnJlbmN5IDwgMSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBjb25jdXJyZW5jeWAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCcpO1xuXHR9XG5cblx0Y29uc3QgcmV0ID0gW107XG5cdGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXHRsZXQgaXNSZWplY3RlZCA9IGZhbHNlO1xuXHRsZXQgaXRlcmFibGVEb25lID0gZmFsc2U7XG5cdGxldCByZXNvbHZpbmdDb3VudCA9IDA7XG5cdGxldCBjdXJyZW50SWR4ID0gMDtcblxuXHRjb25zdCBuZXh0ID0gKCkgPT4ge1xuXHRcdGlmIChpc1JlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV4dEl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0Y29uc3QgaSA9IGN1cnJlbnRJZHg7XG5cdFx0Y3VycmVudElkeCsrO1xuXG5cdFx0aWYgKG5leHRJdGVtLmRvbmUpIHtcblx0XHRcdGl0ZXJhYmxlRG9uZSA9IHRydWU7XG5cblx0XHRcdGlmIChyZXNvbHZpbmdDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXNvbHZlKHJldCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXNvbHZpbmdDb3VudCsrO1xuXG5cdFx0UHJvbWlzZS5yZXNvbHZlKG5leHRJdGVtLnZhbHVlKVxuXHRcdFx0LnRoZW4oZWwgPT4gbWFwcGVyKGVsLCBpKSlcblx0XHRcdC50aGVuKFxuXHRcdFx0XHR2YWwgPT4ge1xuXHRcdFx0XHRcdHJldFtpXSA9IHZhbDtcblx0XHRcdFx0XHRyZXNvbHZpbmdDb3VudC0tO1xuXHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyID0+IHtcblx0XHRcdFx0XHRpc1JlamVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0fTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbmN1cnJlbmN5OyBpKyspIHtcblx0XHRuZXh0KCk7XG5cblx0XHRpZiAoaXRlcmFibGVEb25lKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGlzRGVmaW5lZCA9IChhcmcpID0+IGFyZyAhPT0gdW5kZWZpbmVkICYmIGFyZyAhPT0gbnVsbFxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGVmaW5lZFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBQUk9UT0NPTCA9IHJlcXVpcmUoJy4vcHJvdG9jb2wnKVxuY29uc3QgZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGluZycpXG5jb25zdCB3YWl0Rm9yUGVlcnMgPSByZXF1aXJlKCcuL3dhaXQtZm9yLXBlZXJzJylcbmNvbnN0IGdldFBlZXJJRCA9IHJlcXVpcmUoJy4vZ2V0LXBlZXItaWQnKVxuXG4vKipcbiAqIENvbW11bmljYXRpb24gY2hhbm5lbCBvdmVyIFB1YnN1YiBiZXR3ZWVuIHR3byBJUEZTIG5vZGVzXG4gKi9cbmNsYXNzIERpcmVjdENoYW5uZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaXBmcywgcmVjZWl2ZXJJRCkge1xuICAgIHN1cGVyKClcblxuICAgIC8vIElQRlMgaW5zdGFuY2UgdG8gdXNlIGludGVybmFsbHlcbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuXG4gICAgaWYgKCFpcGZzLnB1YnN1Yikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIElQRlMgbm9kZSBkb2VzIG5vdCBzdXBwb3J0IHB1YnN1Yi4nKVxuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVySUQgPSByZWNlaXZlcklEXG5cbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVySUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZXIgSUQgd2FzIHVuZGVmaW5lZCcpXG4gICAgfVxuICAgIC8vIFNlZSBfc2V0dXAoKSBmb3IgbW9yZSBzdGF0ZSBpbml0aWFsaXphdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5uZWwgSURcbiAgICogQHJldHVybiB7W1N0cmluZ119IENoYW5uZWwncyBJRFxuICAgKi9cbiAgZ2V0IGlkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRcbiAgfVxuXG4gIC8qKlxuICAgKiBQZWVycyBwYXJ0aWNpcGF0aW5nIGluIHRoaXMgY2hhbm5lbFxuICAgKiBAcmV0dXJuIHtbQXJyYXldfSBBcnJheSBvZiBwZWVyIElEcyBwYXJ0aWNpcGF0aW5nIGluIHRoaXMgY2hhbm5lbFxuICAgKi9cbiAgZ2V0IHBlZXJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVlcnNcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QgKCkge1xuICAgIGF3YWl0IHdhaXRGb3JQZWVycyh0aGlzLl9pcGZzLCBbdGhpcy5fcmVjZWl2ZXJJRF0sIHRoaXMuX2lkKVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyXG4gICAqIEBwYXJhbSAge1tBbnldfSBtZXNzYWdlIFBheWxvYWRcbiAgICovXG4gIGFzeW5jIHNlbmQgKG1lc3NhZ2UpIHtcbiAgICBsZXQgbSA9IGVuY29kZShtZXNzYWdlKVxuICAgIGF3YWl0IHRoaXMuX2lwZnMucHVic3ViLnB1Ymxpc2godGhpcy5faWQsIG0pXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIGNoYW5uZWxcbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnbWVzc2FnZScpXG4gICAgdGhpcy5faXBmcy5wdWJzdWIudW5zdWJzY3JpYmUodGhpcy5faWQsIHRoaXMuX21lc3NhZ2VIYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgX3NldHVwICgpIHtcbiAgICB0aGlzLl9zZW5kZXJJRCA9IGF3YWl0IGdldFBlZXJJRCh0aGlzLl9pcGZzKVxuXG4gICAgLy8gQ2hhbm5lbCdzIHBhcnRpY2lwYW50c1xuICAgIHRoaXMuX3BlZXJzID0gQXJyYXkuZnJvbShbdGhpcy5fc2VuZGVySUQsIHRoaXMuX3JlY2VpdmVySURdKS5zb3J0KClcblxuICAgIC8vIElEIG9mIHRoZSBjaGFubmVsIGlzIFwiPHBlZXIxIGlkPi88cGVlciAyIGlkPlwiXCJcbiAgICB0aGlzLl9pZCA9ICcvJyArICcnICsgUFJPVE9DT0wgKyAnLycgKyB0aGlzLl9wZWVycy5qb2luKCcvJylcblxuICAgIC8vIEZ1bmN0aW9uIHRvIHVzZSB0byBoYW5kbGUgaW5jb21pbmcgbWVzc2FnZXNcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2UgPT4ge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBtZXNzYWdlIGlzIGNvbWluZyBmcm9tIHRoZSBjb3JyZWN0IHBlZXJcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZnJvbSA9PT0gdGhpcy5fcmVjZWl2ZXJJRFxuICAgICAgLy8gRmlsdGVyIG91dCBhbGwgbWVzc2FnZXMgdGhhdCBkaWRuJ3QgY29tZSBmcm9tIHRoZSBzZWNvbmQgcGVlclxuICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfb3BlbkNoYW5uZWwgKCkge1xuICAgIGF3YWl0IHRoaXMuX3NldHVwKClcbiAgICBhd2FpdCB0aGlzLl9pcGZzLnB1YnN1Yi5zdWJzY3JpYmUodGhpcy5faWQsIHRoaXMuX21lc3NhZ2VIYW5kbGVyKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIG9wZW4gKGlwZnMsIHJlY2VpdmVySUQpIHtcbiAgICBjb25zdCBjaGFubmVsID0gbmV3IERpcmVjdENoYW5uZWwoaXBmcywgcmVjZWl2ZXJJRClcbiAgICBhd2FpdCBjaGFubmVsLl9vcGVuQ2hhbm5lbCgpXG4gICAgcmV0dXJuIGNoYW5uZWxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdENoYW5uZWxcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDb3VudGVyID0gcmVxdWlyZSgnY3JkdHMvc3JjL0ctQ291bnRlcicpXG5cbmNsYXNzIENvdW50ZXJJbmRleCB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5faW5kZXggPSBuZXcgQ291bnRlcihpZClcbiAgfVxuXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfVxuXG4gIHVwZGF0ZUluZGV4KG9wbG9nKSB7XG4gICAgaWYodGhpcy5faW5kZXgpIHtcbiAgICAgIGNvbnN0IGNyZWF0ZUNvdW50ZXIgPSBlID0+IENvdW50ZXIuZnJvbShlLnBheWxvYWQudmFsdWUpXG4gICAgICBjb25zdCBtZXJnZVRvSW5kZXggPSBlID0+IHRoaXMuX2luZGV4Lm1lcmdlKGUpXG4gICAgICBvcGxvZy52YWx1ZXMuZmlsdGVyKGUgPT4gZSAmJiBlLnBheWxvYWQub3AgPT09ICdDT1VOVEVSJylcbiAgICAgICAgLm1hcChjcmVhdGVDb3VudGVyKVxuICAgICAgICAuZm9yRWFjaChtZXJnZVRvSW5kZXgpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ291bnRlckluZGV4XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBkZWVwRXF1YWwgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc3VtID0gKGFjYywgdmFsKSA9PiBhY2MgKyB2YWxcblxuLyoqXG4gKiBHLUNvdW50ZXJcbiAqXG4gKiBPcGVyYXRpb24tYmFzZWQgSW5jcmVtZW50LU9ubHkgQ291bnRlciBDUkRUXG4gKlxuICogU291cmNlczogXG4gKiBcIkEgY29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBDb252ZXJnZW50IGFuZCBDb21tdXRhdGl2ZSBSZXBsaWNhdGVkIERhdGEgVHlwZXNcIlxuICogaHR0cDovL2hhbC51cG1jLmZyL2lucmlhLTAwNTU1NTg4L2RvY3VtZW50LCBcIjMuMS4xIE9wLWJhc2VkIGNvdW50ZXIgYW5kIDMuMS4yICBTdGF0ZS1iYXNlZCBpbmNyZW1lbnQtb25seSBDb3VudGVyIChHLUNvdW50ZXIpXCJcbiAqL1xuXG5jbGFzcyBHQ291bnRlciB7XG4gIGNvbnN0cnVjdG9yIChpZCwgY291bnRlcikge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMuX2NvdW50ZXJzID0gY291bnRlciA/IGNvdW50ZXIgOiB7fVxuICAgIHRoaXMuX2NvdW50ZXJzW3RoaXMuaWRdID0gdGhpcy5fY291bnRlcnNbdGhpcy5pZF0gPyB0aGlzLl9jb3VudGVyc1t0aGlzLmlkXSA6IDBcbiAgfVxuXG4gIGdldCB2YWx1ZSAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY291bnRlcnMpLnJlZHVjZShzdW0sIDApXG4gIH1cblxuICBpbmNyZW1lbnQgKGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgJiYgYW1vdW50IDwgMSkgXG4gICAgICByZXR1cm5cblxuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCB8fCBhbW91bnQgPT09IG51bGwpXG4gICAgICBhbW91bnQgPSAxXG5cbiAgICB0aGlzLl9jb3VudGVyc1t0aGlzLmlkXSA9IHRoaXMuX2NvdW50ZXJzW3RoaXMuaWRdICsgYW1vdW50XG4gIH1cblxuICBtZXJnZSAob3RoZXIpIHtcbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggY291bnRlciBpbiB0aGUgb3RoZXIgY291bnRlclxuICAgIE9iamVjdC5lbnRyaWVzKG90aGVyLl9jb3VudGVycykuZm9yRWFjaCgoW2lkLCB2YWx1ZV0pID0+IHtcbiAgICAgIC8vIFRha2UgdGhlIG1heGltdW0gb2YgdGhlIGNvdW50ZXIgdmFsdWUgd2UgaGF2ZSBvciB0aGUgY291bnRlciB2YWx1ZSB0aGV5IGhhdmVcbiAgICAgIHRoaXMuX2NvdW50ZXJzW2lkXSA9IE1hdGgubWF4KHRoaXMuX2NvdW50ZXJzW2lkXSB8fCAwLCB2YWx1ZSlcbiAgICB9KVxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4geyBcbiAgICAgIGlkOiB0aGlzLmlkLCBcbiAgICAgIGNvdW50ZXJzOiB0aGlzLl9jb3VudGVycyBcbiAgICB9XG4gIH1cblxuICBpc0VxdWFsIChvdGhlcikge1xuICAgIHJldHVybiBHQ291bnRlci5pc0VxdWFsKHRoaXMsIG90aGVyKVxuICB9XG5cbiAgc3RhdGljIGZyb20gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEdDb3VudGVyKGpzb24uaWQsIGpzb24uY291bnRlcnMpXG4gIH1cblxuICBzdGF0aWMgaXNFcXVhbCAoYSwgYikge1xuICAgIGlmKGEuaWQgIT09IGIuaWQpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiBkZWVwRXF1YWwoYS5fY291bnRlcnMsIGIuX2NvdW50ZXJzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR0NvdW50ZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJ2xvZ3BsZWFzZScpXG5jb25zdCBsb2dnZXIgPSBMb2dnZXIuY3JlYXRlKCdjYWNoZScsIHsgY29sb3I6IExvZ2dlci5Db2xvcnMuTWFnZW50YSB9KVxuTG9nZ2VyLnNldExvZ0xldmVsKCdFUlJPUicpXG5cbmxldCBjYWNoZXMgPSB7fVxuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChzdG9yYWdlLCBkaXJlY3RvcnkpIHtcbiAgICB0aGlzLnBhdGggPSBkaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZVxuICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICB9XG5cbiAgLy8gU2V0dXAgc3RvcmFnZSBiYWNrZW5kXG4gIGFzeW5jIG9wZW4gKCkge1xuICAgIGxvZ2dlci5kZWJ1Zygnb3BlbicsIHRoaXMucGF0aClcblxuICAgIGlmICh0aGlzLnN0b3JlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLl9zdG9yYWdlKHRoaXMucGF0aClcbiAgICAgIHN0b3JlLm9wZW4oKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUgPSBzdG9yZVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlJywgdGhpcy5wYXRoKVxuXG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLmNsb3NlKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgICAgICBkZWxldGUgY2FjaGVzW3RoaXMucGF0aF1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBkZXN0cm95ICgpIHtcbiAgICBsb2dnZXIuZGVidWcoJ2Rlc3Ryb3knLCB0aGlzLnBhdGgpXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc3RvcmFnZS5kZXN0cm95KHRoaXMucGF0aCwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBnZXQgKGtleSkge1xuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yZS5nZXQoa2V5LCAoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSA/IEpTT04ucGFyc2UodmFsdWUpIDogbnVsbClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIFNldCB2YWx1ZSBpbiB0aGUgY2FjaGUgYW5kIHJldHVybiB0aGUgbmV3IHZhbHVlXG4gIGFzeW5jIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLnB1dChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBSZW1vdmUgYSB2YWx1ZSBhbmQga2V5IGZyb20gdGhlIGNhY2hlXG4gIGFzeW5jIGRlbCAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuKClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc3RvcmUuZGVsKGtleSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGtleSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kRXJyb3I6IEtleSBub3QgZm91bmQgaW4gZGF0YWJhc2UnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGVyci50b1N0cmluZygpLmluZGV4T2YoJ05vdEZvdW5kJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc3RvcmFnZSwgbWtkaXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBhc3luYyAoZGlyZWN0b3J5LCBkYkFkZHJlc3MpID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCwgZGF0YWJhc2U6JywgZGJBZGRyZXNzLnRvU3RyaW5nKCkpXG5cbiAgICAgIGNvbnN0IGRiUGF0aCA9IHBhdGguam9pbihkYkFkZHJlc3Mucm9vdCwgZGJBZGRyZXNzLnBhdGgpXG4gICAgICBjb25zdCBkYXRhUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIGRiUGF0aClcbiAgICAgIGxldCBjYWNoZSA9IGNhY2hlc1tkYXRhUGF0aF1cbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgaWYgKG1rZGlyICYmIG1rZGlyLnN5bmMpIHtcbiAgICAgICAgICBta2Rpci5zeW5jKGRhdGFQYXRoKVxuICAgICAgICB9XG4gICAgICAgIGNhY2hlID0gbmV3IENhY2hlKHN0b3JhZ2UsIGRhdGFQYXRoKVxuICAgICAgICBhd2FpdCBjYWNoZS5vcGVuKClcbiAgICAgICAgY2FjaGVzW2RhdGFQYXRoXSA9IGNhY2hlXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVcbiAgICB9LFxuICAgIGNsb3NlOiBhc3luYyAoKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlIGFsbCcpXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoY2FjaGVzKSwgY2FjaGUgPT4gY2FjaGUuY2xvc2UoKSlcbiAgICAgIGNhY2hlcyA9IHt9XG4gICAgfVxuICB9XG59XG4iLCIvKiBnbG9iYWwgaW5kZXhlZERCICovXG5cbid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsXG5cbnZhciBBYnN0cmFjdExldmVsRE9XTiA9IHJlcXVpcmUoJ2Fic3RyYWN0LWxldmVsZG93bicpLkFic3RyYWN0TGV2ZWxET1dOXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSXRlcmF0b3IgPSByZXF1aXJlKCcuL2l0ZXJhdG9yJylcbnZhciBtaXhlZFRvQnVmZmVyID0gcmVxdWlyZSgnLi91dGlsL21peGVkLXRvLWJ1ZmZlcicpXG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnLi91dGlsL2ltbWVkaWF0ZScpXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdXBwb3J0JylcblxudmFyIERFRkFVTFRfUFJFRklYID0gJ2xldmVsLWpzLSdcblxuZnVuY3Rpb24gTGV2ZWwgKGxvY2F0aW9uLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMZXZlbCkpIHJldHVybiBuZXcgTGV2ZWwobG9jYXRpb24sIG9wdHMpXG4gIEFic3RyYWN0TGV2ZWxET1dOLmNhbGwodGhpcylcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY29uc3RydWN0b3IgcmVxdWlyZXMgYSBsb2NhdGlvbiBzdHJpbmcgYXJndW1lbnQnKVxuICB9XG5cbiAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uXG4gIHRoaXMucHJlZml4ID0gb3B0cy5wcmVmaXggfHwgREVGQVVMVF9QUkVGSVhcbiAgdGhpcy52ZXJzaW9uID0gcGFyc2VJbnQob3B0cy52ZXJzaW9uIHx8IDEsIDEwKVxufVxuXG5pbmhlcml0cyhMZXZlbCwgQWJzdHJhY3RMZXZlbERPV04pXG5cbi8vIERldGVjdCBiaW5hcnkgYW5kIGFycmF5IGtleSBzdXBwb3J0IChJbmRleGVkREIgU2Vjb25kIEVkaXRpb24pXG5MZXZlbC5iaW5hcnlLZXlzID0gc3VwcG9ydC5iaW5hcnlLZXlzKGluZGV4ZWREQilcbkxldmVsLmFycmF5S2V5cyA9IHN1cHBvcnQuYXJyYXlLZXlzKGluZGV4ZWREQilcblxuTGV2ZWwucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZXEgPSBpbmRleGVkREIub3Blbih0aGlzLnByZWZpeCArIHRoaXMubG9jYXRpb24sIHRoaXMudmVyc2lvbilcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2socmVxLmVycm9yIHx8IG5ldyBFcnJvcigndW5rbm93biBlcnJvcicpKVxuICB9XG5cbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRiID0gcmVxLnJlc3VsdFxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgZGIgPSBldi50YXJnZXQucmVzdWx0XG5cbiAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoc2VsZi5sb2NhdGlvbikpIHtcbiAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHNlbGYubG9jYXRpb24pXG4gICAgfVxuICB9XG59XG5cbkxldmVsLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMubG9jYXRpb25dLCBtb2RlKVxuICByZXR1cm4gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5sb2NhdGlvbilcbn1cblxuTGV2ZWwucHJvdG90eXBlLmF3YWl0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IHJlcXVlc3QudHJhbnNhY3Rpb25cblxuICAvLyBUYWtlIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGEgbm9uLWNhbmNlbGVkIHJlcXVlc3QgZXJyb3IgYWJvcnRzXG4gIC8vIHRoZSB0cmFuc2FjdGlvbi4gSS5lLiBubyBuZWVkIHRvIGxpc3RlbiBmb3IgXCJyZXF1ZXN0Lm9uZXJyb3JcIi5cbiAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayh0cmFuc2FjdGlvbi5lcnJvciB8fCBuZXcgRXJyb3IoJ2Fib3J0ZWQgYnkgdXNlcicpKVxuICB9XG5cbiAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3VsdClcbiAgfVxufVxuXG5MZXZlbC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmUoJ3JlYWRvbmx5JylcblxuICB0cnkge1xuICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5hd2FpdChyZXEsIGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAnTm90Rm91bmQnIGVycm9yLCBjb25zaXN0ZW50IHdpdGggTGV2ZWxET1dOIEFQSVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignTm90Rm91bmQnKSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hc0J1ZmZlcikge1xuICAgICAgdmFsdWUgPSBtaXhlZFRvQnVmZmVyKHZhbHVlKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKVxuICB9KVxufVxuXG5MZXZlbC5wcm90b3R5cGUuX2RlbCA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmUoJ3JlYWR3cml0ZScpXG5cbiAgdHJ5IHtcbiAgICB2YXIgcmVxID0gc3RvcmUuZGVsZXRlKGtleSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuYXdhaXQocmVxLCBjYWxsYmFjaylcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZSgncmVhZHdyaXRlJylcblxuICB0cnkge1xuICAgIC8vIFdpbGwgdGhyb3cgYSBEYXRhRXJyb3Igb3IgRGF0YUNsb25lRXJyb3IgaWYgdGhlIGVudmlyb25tZW50XG4gICAgLy8gZG9lcyBub3Qgc3VwcG9ydCBzZXJpYWxpemluZyB0aGUga2V5IG9yIHZhbHVlIHJlc3BlY3RpdmVseS5cbiAgICB2YXIgcmVxID0gc3RvcmUucHV0KHZhbHVlLCBrZXkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmF3YWl0KHJlcSwgY2FsbGJhY2spXG59XG5cbi8vIFZhbGlkIGtleSB0eXBlcyBpbiBJbmRleGVkREIgU2Vjb25kIEVkaXRpb246XG4vL1xuLy8gLSBOdW1iZXIsIGV4Y2VwdCBOYU4uIEluY2x1ZGVzIEluZmluaXR5IGFuZCAtSW5maW5pdHlcbi8vIC0gRGF0ZSwgZXhjZXB0IGludmFsaWQgKE5hTilcbi8vIC0gU3RyaW5nXG4vLyAtIEFycmF5QnVmZmVyIG9yIGEgdmlldyB0aGVyZW9mICh0eXBlZCBhcnJheXMpLiBJbiBsZXZlbC1qcyB3ZSBhbHNvIHN1cHBvcnRcbi8vICAgQnVmZmVyICh3aGljaCBpcyBhbiBVaW50OEFycmF5KSAoYW5kIHRoZSBwcmltYXJ5IGJpbmFyeSB0eXBlIG9mIExldmVsKS5cbi8vIC0gQXJyYXksIGV4Y2VwdCBjeWNsaWNhbCBhbmQgZW1wdHkgKGUuZy4gQXJyYXkoMTApKS4gRWxlbWVudHMgbXVzdCBiZSB2YWxpZFxuLy8gICB0eXBlcyB0aGVtc2VsdmVzLlxuTGV2ZWwucHJvdG90eXBlLl9zZXJpYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIHJldHVybiBMZXZlbC5iaW5hcnlLZXlzID8ga2V5IDoga2V5LnRvU3RyaW5nKClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICByZXR1cm4gTGV2ZWwuYXJyYXlLZXlzID8ga2V5Lm1hcCh0aGlzLl9zZXJpYWxpemVLZXksIHRoaXMpIDogU3RyaW5nKGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5XG4gIH1cbn1cblxuTGV2ZWwucHJvdG90eXBlLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgdGhpcy5sb2NhdGlvbiwgb3B0aW9ucylcbn1cblxuTGV2ZWwucHJvdG90eXBlLl9iYXRjaCA9IGZ1bmN0aW9uIChvcGVyYXRpb25zLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG5cbiAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZSgncmVhZHdyaXRlJylcbiAgdmFyIHRyYW5zYWN0aW9uID0gc3RvcmUudHJhbnNhY3Rpb25cbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgZXJyb3JcblxuICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKGVycm9yIHx8IHRyYW5zYWN0aW9uLmVycm9yIHx8IG5ldyBFcnJvcignYWJvcnRlZCBieSB1c2VyJykpXG4gIH1cblxuICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8vIFdhaXQgZm9yIGEgcmVxdWVzdCB0byBjb21wbGV0ZSBiZWZvcmUgbWFraW5nIHRoZSBuZXh0LCBzYXZpbmcgQ1BVLlxuICBmdW5jdGlvbiBsb29wICgpIHtcbiAgICB2YXIgb3AgPSBvcGVyYXRpb25zW2luZGV4KytdXG4gICAgdmFyIGtleSA9IG9wLmtleVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXEgPSBvcC50eXBlID09PSAnZGVsJyA/IHN0b3JlLmRlbGV0ZShrZXkpIDogc3RvcmUucHV0KG9wLnZhbHVlLCBrZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgb3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBsb29wXG4gICAgfVxuICB9XG5cbiAgbG9vcCgpXG59XG5cbkxldmVsLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy5kYi5jbG9zZSgpXG4gIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbn1cblxuTGV2ZWwuZGVzdHJveSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgcHJlZml4LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHByZWZpeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcHJlZml4XG4gICAgcHJlZml4ID0gREVGQVVMVF9QUkVGSVhcbiAgfVxuICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShwcmVmaXggKyBsb2NhdGlvbilcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soKVxuICB9XG4gIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgbGV2ZWx1cCA9IHJlcXVpcmUoJ2xldmVsdXAnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1JylcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyLycpLkJ1ZmZlclxuY29uc3QgeyB2ZXJpZmllciB9ID0gcmVxdWlyZSgnLi92ZXJpZmllcnMnKVxuXG5jbGFzcyBLZXlzdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChzdG9yYWdlLCBkaXJlY3RvcnkpIHtcbiAgICB0aGlzLnBhdGggPSBkaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICB0aGlzLl9zdG9yYWdlID0gc3RvcmFnZVxuICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgIHRoaXMuX2NhY2hlID0gbmV3IExSVSgxMDApXG4gIH1cblxuICBhc3luYyBvcGVuICgpIHtcbiAgICBpZiAodGhpcy5zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gbGV2ZWx1cCh0aGlzLl9zdG9yYWdlKHRoaXMucGF0aCkpXG4gICAgICBzdG9yZS5vcGVuKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gc3RvcmVcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlLmNsb3NlKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbnVsbFxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9zdG9yYWdlLmRlc3Ryb3kodGhpcy5wYXRoLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGhhc0tleSAoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIG5lZWRlZCB0byBjaGVjayBhIGtleScpXG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZS5zdGF0dXMgJiYgdGhpcy5fc3RvcmUuc3RhdHVzICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICB9XG5cbiAgICBsZXQgaGFzS2V5ID0gZmFsc2VcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3JlZEtleSA9IHRoaXMuX2NhY2hlLmdldChpZCkgfHwgYXdhaXQgdGhpcy5fc3RvcmUuZ2V0KGlkKVxuICAgICAgaGFzS2V5ID0gc3RvcmVkS2V5ICE9PSB1bmRlZmluZWQgJiYgc3RvcmVkS2V5ICE9PSBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gQ2F0Y2hlcyAnRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgb3BlbiA8cGF0aD4nXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JylcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG5cbiAgICByZXR1cm4gaGFzS2V5XG4gIH1cblxuICBhc3luYyBjcmVhdGVLZXkgKGlkKSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBuZWVkZWQgdG8gY3JlYXRlIGEga2V5JylcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdG9yZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlLnN0YXR1cyAmJiB0aGlzLl9zdG9yZS5zdGF0dXMgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgIH1cblxuICAgIGNvbnN0IGdlbktleVBhaXIgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjcnlwdG8ua2V5cy5nZW5lcmF0ZUtleVBhaXIoJ3NlY3AyNTZrMScsIDI1NiwgKGVyciwga2V5KSA9PiB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzb2x2ZShrZXkpXG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IGtleXMgPSBhd2FpdCBnZW5LZXlQYWlyKClcbiAgICBjb25zdCBkZWNvbXByZXNzZWRLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChrZXlzLnB1YmxpYy5tYXJzaGFsKCksIGZhbHNlKVxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgIHB1YmxpY0tleTogZGVjb21wcmVzc2VkS2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHByaXZhdGVLZXk6IGtleXMubWFyc2hhbCgpLnRvU3RyaW5nKCdoZXgnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9zdG9yZS5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSlcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG4gICAgdGhpcy5fY2FjaGUuc2V0KGlkLCBrZXkpXG5cbiAgICByZXR1cm4ga2V5c1xuICB9XG5cbiAgYXN5bmMgZ2V0S2V5IChpZCkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWQgbmVlZGVkIHRvIGdldCBhIGtleScpXG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgIGF3YWl0IHRoaXMub3BlbigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZS5zdGF0dXMgJiYgdGhpcy5fc3RvcmUuc3RhdHVzICE9PSAnb3BlbicpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZWRLZXkgPSB0aGlzLl9jYWNoZS5nZXQoaWQpXG4gICAgbGV0IHN0b3JlZEtleVxuICAgIHRyeSB7XG4gICAgICBzdG9yZWRLZXkgPSBjYWNoZWRLZXkgfHwgYXdhaXQgdGhpcy5fc3RvcmUuZ2V0KGlkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBFTk9FTlQgZXJyb3JcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoIXN0b3JlZEtleSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGVzZXJpYWxpemVkS2V5ID0gY2FjaGVkS2V5IHx8IEpTT04ucGFyc2Uoc3RvcmVkS2V5KVxuICAgIGlmICghZGVzZXJpYWxpemVkS2V5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWNhY2hlZEtleSkge1xuICAgICAgdGhpcy5fY2FjaGUuc2V0KGlkLCBkZXNlcmlhbGl6ZWRLZXkpXG4gICAgfVxuXG5cbiAgICBjb25zdCBnZW5Qcml2S2V5ID0gKHBrKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjcnlwdG8ua2V5cy5zdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQcml2YXRlS2V5KHBrLCAoZXJyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXNvbHZlKGtleSlcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIGdlblByaXZLZXkoQnVmZmVyLmZyb20oZGVzZXJpYWxpemVkS2V5LnByaXZhdGVLZXksICdoZXgnKSlcbiAgfVxuXG4gIGFzeW5jIHNpZ24gKGtleSwgZGF0YSkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25pbmcga2V5IGdpdmVuJylcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gaW5wdXQgZGF0YSB3YXMgdW5kZWZpbmVkJylcbiAgICB9XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGtleS5zaWduKGRhdGEsIChlcnIsIHNpZ25hdHVyZSkgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZ2V0UHVibGljKGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBbJ2hleCcsICdidWZmZXInXVxuICAgIGNvbnN0IGRlY29tcHJlc3MgPSBvcHRpb25zLmRlY29tcHJlc3MgfHwgdHJ1ZVxuICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHNbb3B0aW9ucy5mb3JtYXQgfHwgJ2hleCddXG4gICAgbGV0IHB1YktleSA9IGtleXMucHVibGljLm1hcnNoYWwoKVxuICAgIGlmIChkZWNvbXByZXNzKSB7XG4gICAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0ID09PSAnYnVmZmVyJyA/IHB1YktleSA6IHB1YktleS50b1N0cmluZygnaGV4JylcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSAoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEsIHYgPSAndjEnKSB7XG4gICAgcmV0dXJuIEtleXN0b3JlLnZlcmlmeShzaWduYXR1cmUsIHB1YmxpY0tleSwgZGF0YSwgdilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2ZXJpZnkgKHNpZ25hdHVyZSwgcHVibGljS2V5LCBkYXRhLCB2ID0gJ3YxJykge1xuICAgIHJldHVybiB2ZXJpZmllcih2KS52ZXJpZnkoc2lnbmF0dXJlLCBwdWJsaWNLZXksIGRhdGEpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc3RvcmFnZSwgbWtkaXIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IChkaXJlY3RvcnkgPSAnLi9rZXlzdG9yZScpID0+IHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIE5vZGUuanMsIG1rZGlyIG1vZHVsZSBpcyBleHBlY3RlZCB0byBwYXNzZWRcbiAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgaWYgKG1rZGlyICYmIG1rZGlyLnN5bmMpIHtcbiAgICAgICAgbWtkaXIuc3luYyhkaXJlY3RvcnkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgS2V5c3RvcmUoc3RvcmFnZSwgZGlyZWN0b3J5KVxuICAgIH0sXG4gICAgdmVyaWZ5OiBLZXlzdG9yZS52ZXJpZnlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5cbi8qXG4gKiBWYWxpZCBjb21iaW5hdGlvbnNcbiAqL1xuY29uc3QgRE5TNCA9IGJhc2UoJ2RuczQnKVxuY29uc3QgRE5TNiA9IGJhc2UoJ2RuczYnKVxuY29uc3QgX0ROUyA9IG9yKFxuICBiYXNlKCdkbnNhZGRyJyksXG4gIEROUzQsXG4gIEROUzZcbilcblxuY29uc3QgSVAgPSBvcihiYXNlKCdpcDQnKSwgYmFzZSgnaXA2JykpXG5jb25zdCBUQ1AgPSBvcihcbiAgYW5kKElQLCBiYXNlKCd0Y3AnKSksXG4gIGFuZChfRE5TLCBiYXNlKCd0Y3AnKSlcbilcbmNvbnN0IFVEUCA9IGFuZChJUCwgYmFzZSgndWRwJykpXG5jb25zdCBVVFAgPSBhbmQoVURQLCBiYXNlKCd1dHAnKSlcblxuY29uc3QgRE5TID0gb3IoXG4gIGFuZChfRE5TLCBiYXNlKCd0Y3AnKSksXG4gIF9ETlNcbilcblxuY29uc3QgV2ViU29ja2V0cyA9IG9yKFxuICBhbmQoVENQLCBiYXNlKCd3cycpKSxcbiAgYW5kKEROUywgYmFzZSgnd3MnKSlcbilcblxuY29uc3QgV2ViU29ja2V0c1NlY3VyZSA9IG9yKFxuICBhbmQoVENQLCBiYXNlKCd3c3MnKSksXG4gIGFuZChETlMsIGJhc2UoJ3dzcycpKVxuKVxuXG5jb25zdCBIVFRQID0gb3IoXG4gIGFuZChUQ1AsIGJhc2UoJ2h0dHAnKSksXG4gIGFuZChJUCwgYmFzZSgnaHR0cCcpKSxcbiAgYW5kKEROUywgYmFzZSgnaHR0cCcpKSxcbiAgYW5kKEROUylcbilcblxuY29uc3QgSFRUUFMgPSBvcihcbiAgYW5kKFRDUCwgYmFzZSgnaHR0cHMnKSksXG4gIGFuZChJUCwgYmFzZSgnaHR0cHMnKSksXG4gIGFuZChETlMsIGJhc2UoJ2h0dHBzJykpXG4pXG5cbmNvbnN0IFdlYlJUQ1N0YXIgPSBvcihcbiAgYW5kKFdlYlNvY2tldHMsIGJhc2UoJ3AycC13ZWJydGMtc3RhcicpLCBiYXNlKCdpcGZzJykpLFxuICBhbmQoV2ViU29ja2V0c1NlY3VyZSwgYmFzZSgncDJwLXdlYnJ0Yy1zdGFyJyksIGJhc2UoJ2lwZnMnKSlcbilcblxuY29uc3QgV2ViU29ja2V0U3RhciA9IG9yKFxuICBhbmQoV2ViU29ja2V0cywgYmFzZSgncDJwLXdlYnNvY2tldC1zdGFyJyksIGJhc2UoJ2lwZnMnKSksXG4gIGFuZChXZWJTb2NrZXRzU2VjdXJlLCBiYXNlKCdwMnAtd2Vic29ja2V0LXN0YXInKSwgYmFzZSgnaXBmcycpKSxcbiAgYW5kKFdlYlNvY2tldHMsIGJhc2UoJ3AycC13ZWJzb2NrZXQtc3RhcicpKSxcbiAgYW5kKFdlYlNvY2tldHNTZWN1cmUsIGJhc2UoJ3AycC13ZWJzb2NrZXQtc3RhcicpKVxuKVxuXG5jb25zdCBXZWJSVENEaXJlY3QgPSBvcihcbiAgYW5kKEhUVFAsIGJhc2UoJ3AycC13ZWJydGMtZGlyZWN0JykpLFxuICBhbmQoSFRUUFMsIGJhc2UoJ3AycC13ZWJydGMtZGlyZWN0JykpXG4pXG5cbmNvbnN0IFJlbGlhYmxlID0gb3IoXG4gIFdlYlNvY2tldHMsXG4gIFdlYlNvY2tldHNTZWN1cmUsXG4gIEhUVFAsXG4gIEhUVFBTLFxuICBXZWJSVENTdGFyLFxuICBXZWJSVENEaXJlY3QsXG4gIFRDUCxcbiAgVVRQXG4pXG5cbi8vIFVubGlrZSB3cy1zdGFyLCBzdGFyZHVzdCBjYW4gcnVuIG92ZXIgYW55IHRyYW5zcG9ydCB0aHVzIHJlbW92aW5nIHRoZSByZXF1aXJlbWVudCBmb3Igd2Vic29ja2V0cyAoYnV0IGRvbid0IGV2ZW4gdGhpbmsgYWJvdXQgcnVubmluZyBhIHN0YXJkdXN0IHNlcnZlciBvdmVyIHdlYnJ0Yy1zdGFyIDspIClcbmNvbnN0IFN0YXJkdXN0ID0gb3IoXG4gIGFuZChSZWxpYWJsZSwgYmFzZSgncDJwLXN0YXJkdXN0JyksIGJhc2UoJ2lwZnMnKSksXG4gIGFuZChSZWxpYWJsZSwgYmFzZSgncDJwLXN0YXJkdXN0JykpXG4pXG5cbmxldCBfSVBGUyA9IG9yKFxuICBhbmQoUmVsaWFibGUsIGJhc2UoJ2lwZnMnKSksXG4gIFdlYlJUQ1N0YXIsXG4gIGJhc2UoJ2lwZnMnKVxuKVxuXG5jb25zdCBfQ2lyY3VpdCA9IG9yKFxuICBhbmQoX0lQRlMsIGJhc2UoJ3AycC1jaXJjdWl0JyksIF9JUEZTKSxcbiAgYW5kKF9JUEZTLCBiYXNlKCdwMnAtY2lyY3VpdCcpKSxcbiAgYW5kKGJhc2UoJ3AycC1jaXJjdWl0JyksIF9JUEZTKSxcbiAgYW5kKFJlbGlhYmxlLCBiYXNlKCdwMnAtY2lyY3VpdCcpKSxcbiAgYW5kKGJhc2UoJ3AycC1jaXJjdWl0JyksIFJlbGlhYmxlKSxcbiAgYmFzZSgncDJwLWNpcmN1aXQnKVxuKVxuXG5jb25zdCBDaXJjdWl0UmVjdXJzaXZlID0gKCkgPT4gb3IoXG4gIGFuZChfQ2lyY3VpdCwgQ2lyY3VpdFJlY3Vyc2l2ZSksXG4gIF9DaXJjdWl0XG4pXG5cbmNvbnN0IENpcmN1aXQgPSBDaXJjdWl0UmVjdXJzaXZlKClcblxuY29uc3QgSVBGUyA9IG9yKFxuICBhbmQoQ2lyY3VpdCwgX0lQRlMsIENpcmN1aXQpLFxuICBhbmQoX0lQRlMsIENpcmN1aXQpLFxuICBhbmQoQ2lyY3VpdCwgX0lQRlMpLFxuICBDaXJjdWl0LFxuICBfSVBGU1xuKVxuXG5leHBvcnRzLkROUyA9IEROU1xuZXhwb3J0cy5ETlM0ID0gRE5TNFxuZXhwb3J0cy5ETlM2ID0gRE5TNlxuZXhwb3J0cy5JUCA9IElQXG5leHBvcnRzLlRDUCA9IFRDUFxuZXhwb3J0cy5VRFAgPSBVRFBcbmV4cG9ydHMuVVRQID0gVVRQXG5leHBvcnRzLkhUVFAgPSBIVFRQXG5leHBvcnRzLkhUVFBTID0gSFRUUFNcbmV4cG9ydHMuV2ViU29ja2V0cyA9IFdlYlNvY2tldHNcbmV4cG9ydHMuV2ViU29ja2V0c1NlY3VyZSA9IFdlYlNvY2tldHNTZWN1cmVcbmV4cG9ydHMuV2ViU29ja2V0U3RhciA9IFdlYlNvY2tldFN0YXJcbmV4cG9ydHMuV2ViUlRDU3RhciA9IFdlYlJUQ1N0YXJcbmV4cG9ydHMuV2ViUlRDRGlyZWN0ID0gV2ViUlRDRGlyZWN0XG5leHBvcnRzLlJlbGlhYmxlID0gUmVsaWFibGVcbmV4cG9ydHMuU3RhcmR1c3QgPSBTdGFyZHVzdFxuZXhwb3J0cy5DaXJjdWl0ID0gQ2lyY3VpdFxuZXhwb3J0cy5JUEZTID0gSVBGU1xuXG4vKlxuICogVmFsaWRhdGlvbiBmdW5jc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VNYXRjaGVzRnVuY3Rpb24gKHBhcnRpYWxNYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hlcyAoYSkge1xuICAgIGlmICghbXVsdGlhZGRyLmlzTXVsdGlhZGRyKGEpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhID0gbXVsdGlhZGRyKGEpXG4gICAgICB9IGNhdGNoIChlcnIpIHsgLy8gY2F0Y2ggZXJyb3JcbiAgICAgICAgcmV0dXJuIGZhbHNlIC8vIGFsc28gaWYgaXQncyBpbnZhbGlkIGl0J3MgcHJvcGFibHkgbm90IG1hdGNoaW5nIGFzIHdlbGwgc28gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvdXQgPSBwYXJ0aWFsTWF0Y2goYS5wcm90b05hbWVzKCkpXG4gICAgaWYgKG91dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBvdXQubGVuZ3RoID09PSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gYW5kICgpIHtcbiAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKVxuICBmdW5jdGlvbiBwYXJ0aWFsTWF0Y2ggKGEpIHtcbiAgICBpZiAoYS5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgYXJncy5zb21lKChhcmcpID0+IHtcbiAgICAgIGEgPSB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gYXJnKCkucGFydGlhbE1hdGNoKGEpXG4gICAgICAgIDogYXJnLnBhcnRpYWxNYXRjaChhKVxuXG4gICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gYVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3sgJyArIGFyZ3Muam9pbignICcpICsgJyB9JyB9LFxuICAgIGlucHV0OiBhcmdzLFxuICAgIG1hdGNoZXM6IG1ha2VNYXRjaGVzRnVuY3Rpb24ocGFydGlhbE1hdGNoKSxcbiAgICBwYXJ0aWFsTWF0Y2g6IHBhcnRpYWxNYXRjaFxuICB9XG59XG5cbmZ1bmN0aW9uIG9yICgpIHtcbiAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxNYXRjaCAoYSkge1xuICAgIGxldCBvdXQgPSBudWxsXG4gICAgYXJncy5zb21lKChhcmcpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBhcmcoKS5wYXJ0aWFsTWF0Y2goYSlcbiAgICAgICAgOiBhcmcucGFydGlhbE1hdGNoKGEpXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIG91dCA9IHJlc1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd7ICcgKyBhcmdzLmpvaW4oJyAnKSArICcgfScgfSxcbiAgICBpbnB1dDogYXJncyxcbiAgICBtYXRjaGVzOiBtYWtlTWF0Y2hlc0Z1bmN0aW9uKHBhcnRpYWxNYXRjaCksXG4gICAgcGFydGlhbE1hdGNoOiBwYXJ0aWFsTWF0Y2hcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gYmFzZSAobikge1xuICBjb25zdCBuYW1lID0gblxuXG4gIGZ1bmN0aW9uIG1hdGNoZXMgKGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhID0gbXVsdGlhZGRyKGEpXG4gICAgICB9IGNhdGNoIChlcnIpIHsgLy8gY2F0Y2ggZXJyb3JcbiAgICAgICAgcmV0dXJuIGZhbHNlIC8vIGFsc28gaWYgaXQncyBpbnZhbGlkIGl0J3MgcHJvcGFibHkgbm90IG1hdGNoaW5nIGFzIHdlbGwgc28gcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG5hbWVzID0gYS5wcm90b05hbWVzKClcbiAgICBpZiAocG5hbWVzLmxlbmd0aCA9PT0gMSAmJiBwbmFtZXNbMF0gPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFydGlhbE1hdGNoIChwcm90b3MpIHtcbiAgICBpZiAocHJvdG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAocHJvdG9zWzBdID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gcHJvdG9zLnNsaWNlKDEpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lIH0sXG4gICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICBwYXJ0aWFsTWF0Y2g6IHBhcnRpYWxNYXRjaFxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHZhciBwcm90b3R5cGU7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAocHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLCBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pKTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IHNlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IGVhY2ggPSByZXF1aXJlKCdhc3luYy9lYWNoJylcbmNvbnN0IF9nZXQgPSByZXF1aXJlKCdkbHYnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgQmlnID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHJlZHVjZSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NpbmtzL3JlZHVjZScpXG5cbmNvbnN0IGJhY2tlbmRzID0gcmVxdWlyZSgnLi9iYWNrZW5kcycpXG5jb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJylcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJylcbmNvbnN0IHNwZWMgPSByZXF1aXJlKCcuL3NwZWMnKVxuY29uc3QgYXBpQWRkciA9IHJlcXVpcmUoJy4vYXBpLWFkZHInKVxuY29uc3QgYmxvY2tzdG9yZSA9IHJlcXVpcmUoJy4vYmxvY2tzdG9yZScpXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1vcHRpb25zJylcbmNvbnN0IGRlZmF1bHREYXRhc3RvcmUgPSByZXF1aXJlKCcuL2RlZmF1bHQtZGF0YXN0b3JlJylcbmNvbnN0IEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuY29uc3QgbG9nID0gZGVidWcoJ3JlcG8nKVxuXG5jb25zdCBub0xpbWl0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcblxuY29uc3QgbG9ja2VycyA9IHtcbiAgbWVtb3J5OiByZXF1aXJlKCcuL2xvY2stbWVtb3J5JyksXG4gIGZzOiByZXF1aXJlKCcuL2xvY2snKVxufVxuXG5jb25zdCByZXBvVmVyc2lvbiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykucmVwb1ZlcnNpb25cblxuLyoqXG4gKiBJcGZzUmVwbyBpbXBsZW1lbnRzIGFsbCByZXF1aXJlZCBmdW5jdGlvbmFsaXR5IHRvIHJlYWQgYW5kIHdyaXRlIHRvIGFuIGlwZnMgcmVwby5cbiAqXG4gKi9cbmNsYXNzIElwZnNSZXBvIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBvUGF0aCAtIHBhdGggd2hlcmUgdGhlIHJlcG8gaXMgc3RvcmVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlcG9QYXRoLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiByZXBvUGF0aCwgJ3N0cmluZycsICdtaXNzaW5nIHJlcG9QYXRoJylcblxuICAgIHRoaXMub3B0aW9ucyA9IGJ1aWxkT3B0aW9ucyhvcHRpb25zKVxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZVxuICAgIHRoaXMucGF0aCA9IHJlcG9QYXRoXG5cbiAgICB0aGlzLl9sb2NrZXIgPSB0aGlzLl9nZXRMb2NrZXIoKVxuXG4gICAgdGhpcy5yb290ID0gYmFja2VuZHMuY3JlYXRlKCdyb290JywgdGhpcy5wYXRoLCB0aGlzLm9wdGlvbnMpXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbih0aGlzLnJvb3QpXG4gICAgdGhpcy5jb25maWcgPSBjb25maWcodGhpcy5yb290KVxuICAgIHRoaXMuc3BlYyA9IHNwZWModGhpcy5yb290KVxuICAgIHRoaXMuYXBpQWRkciA9IGFwaUFkZHIodGhpcy5yb290KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgcmVwby5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIGNvbmZpZyB0byB3cml0ZSBpbnRvIGBjb25maWdgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBpbml0IChjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdpbml0aWFsaXppbmcgYXQ6ICVzJywgdGhpcy5wYXRoKVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gdGhpcy5yb290Lm9wZW4oaWdub3JpbmdBbHJlYWR5T3BlbmVkKGNiKSksXG4gICAgICAoY2IpID0+IHRoaXMuY29uZmlnLnNldChidWlsZENvbmZpZyhjb25maWcpLCBjYiksXG4gICAgICAoY2IpID0+IHRoaXMuc3BlYy5zZXQoYnVpbGREYXRhc3RvcmVTcGVjKGNvbmZpZyksIGNiKSxcbiAgICAgIChjYikgPT4gdGhpcy52ZXJzaW9uLnNldChyZXBvVmVyc2lvbiwgY2IpXG4gICAgXSwgY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgcmVwby4gSWYgdGhlIHJlcG8gaXMgYWxyZWFkeSBvcGVuIG5vIGFjdGlvbiB3aWxsIGJlIHRha2VuLlxuICAgKiBJZiB0aGUgcmVwbyBpcyBub3QgaW5pdGlhbGl6ZWQgaXQgd2lsbCByZXR1cm4gYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIG9wZW4gKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG5ldyBFcnJvcigncmVwbyBpcyBhbHJlYWR5IG9wZW4nKSkpXG4gICAgICByZXR1cm4gLy8gZWFybHlcbiAgICB9XG4gICAgbG9nKCdvcGVuaW5nIGF0OiAlcycsIHRoaXMucGF0aClcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXBvIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB0aGlzLnJvb3Qub3BlbihpZ25vcmluZ0FscmVhZHlPcGVuZWQoY2IpKSxcbiAgICAgIChjYikgPT4gdGhpcy5faXNJbml0aWFsaXplZChjYiksXG4gICAgICAoY2IpID0+IHRoaXMuX29wZW5Mb2NrKHRoaXMucGF0aCwgY2IpLFxuICAgICAgKGxjaywgY2IpID0+IHtcbiAgICAgICAgbG9nKCdhcXVpcmVkIHJlcG8ubG9jaycpXG4gICAgICAgIHRoaXMubG9ja2ZpbGUgPSBsY2tcbiAgICAgICAgY2IoKVxuICAgICAgfSxcbiAgICAgIChjYikgPT4ge1xuICAgICAgICBsb2coJ2NyZWF0aW5nIGRhdGFzdG9yZScpXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gYmFja2VuZHMuY3JlYXRlKCdkYXRhc3RvcmUnLCBwYXRoLmpvaW4odGhpcy5wYXRoLCAnZGF0YXN0b3JlJyksIHRoaXMub3B0aW9ucylcbiAgICAgICAgbG9nKCdjcmVhdGluZyBibG9ja3MnKVxuICAgICAgICBjb25zdCBibG9ja3NCYXNlU3RvcmUgPSBiYWNrZW5kcy5jcmVhdGUoJ2Jsb2NrcycsIHBhdGguam9pbih0aGlzLnBhdGgsICdibG9ja3MnKSwgdGhpcy5vcHRpb25zKVxuICAgICAgICBibG9ja3N0b3JlKFxuICAgICAgICAgIGJsb2Nrc0Jhc2VTdG9yZSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zLmJsb2NrcyxcbiAgICAgICAgICBjYilcbiAgICAgIH0sXG4gICAgICAoYmxvY2tzLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2Nrc1xuICAgICAgICBjYigpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGxvZygnY3JlYXRpbmcga2V5c3RvcmUnKVxuICAgICAgICB0aGlzLmtleXMgPSBiYWNrZW5kcy5jcmVhdGUoJ2tleXMnLCBwYXRoLmpvaW4odGhpcy5wYXRoLCAna2V5cycpLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgIGNiKClcbiAgICAgIH0sXG5cbiAgICAgIChjYikgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gICAgICAgIGxvZygnYWxsIG9wZW5lZCcpXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICBdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICYmIHRoaXMubG9ja2ZpbGUpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VMb2NrKChlcnIyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIyKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2tmaWxlID0gbnVsbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2coJ2Vycm9yIHJlbW92aW5nIGxvY2snLCBlcnIyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvIGxvY2tlciB0byBiZSB1c2VkLiBOdWxsIHdpbGwgYmUgcmV0dXJuZWQgaWYgbm8gbG9ja2VyIGlzIHJlcXVlc3RlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7TG9ja2VyfVxuICAgKi9cbiAgX2dldExvY2tlciAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubG9jayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFzc2VydChsb2NrZXJzW3RoaXMub3B0aW9ucy5sb2NrXSwgJ1Vua25vd24gbG9jayB0eXBlOiAnICsgdGhpcy5vcHRpb25zLmxvY2spXG4gICAgICByZXR1cm4gbG9ja2Vyc1t0aGlzLm9wdGlvbnMubG9ja11cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5vcHRpb25zLmxvY2ssICdObyBsb2NrIHByb3ZpZGVkJylcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxvY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbG9jayBvbiB0aGUgcmVwbyBpZiBhIGxvY2tlciBpcyBzcGVjaWZpZWQuIFRoZSBsb2NrZmlsZSBvYmplY3Qgd2lsbFxuICAgKiBiZSByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2sgaWYgb25lIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGxvY2tmaWxlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb3BlbkxvY2sgKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9ja2VyLmxvY2socGF0aCwgKGVyciwgbG9ja2ZpbGUpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbClcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBsb2NrZmlsZS5jbG9zZSwgJ2Z1bmN0aW9uJywgJ0xvY2tzIG11c3QgaGF2ZSBhIGNsb3NlIG1ldGhvZCcpXG4gICAgICBjYWxsYmFjayhudWxsLCBsb2NrZmlsZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbG9jayBvbiB0aGUgcmVwb1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfY2xvc2VMb2NrIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmxvY2tmaWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NrZmlsZS5jbG9zZShjYWxsYmFjaylcbiAgICB9XG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXBvIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9pc0luaXRpYWxpemVkIChjYWxsYmFjaykge1xuICAgIGxvZygnaW5pdCBjaGVjaycpXG4gICAgcGFyYWxsZWwoXG4gICAgICB7XG4gICAgICAgIGNvbmZpZzogKGNiKSA9PiB0aGlzLmNvbmZpZy5leGlzdHMoY2IpLFxuICAgICAgICBzcGVjOiAoY2IpID0+IHRoaXMuc3BlYy5leGlzdHMoY2IpLFxuICAgICAgICB2ZXJzaW9uOiAoY2IpID0+IHRoaXMudmVyc2lvbi5jaGVjayhyZXBvVmVyc2lvbiwgY2IpXG4gICAgICB9LFxuICAgICAgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgIGxvZygnaW5pdCcsIGVyciwgcmVzKVxuICAgICAgICBpZiAoZXJyICYmICFyZXMuY29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdyZXBvIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQnKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29kZTogRVJST1JTLkVSUl9SRVBPX05PVF9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSByZXBvIGFuZCBjbGVhbnVwLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3JlcG8gaXMgYWxyZWFkeSBjbG9zZWQnKSlcbiAgICB9XG5cbiAgICBsb2coJ2Nsb3NpbmcgYXQ6ICVzJywgdGhpcy5wYXRoKVxuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHRoaXMuYXBpQWRkci5kZWxldGUoaWdub3JpbmdOb3RGb3VuZChjYikpLFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGVhY2goXG4gICAgICAgICAgW3RoaXMuYmxvY2tzLCB0aGlzLmtleXMsIHRoaXMuZGF0YXN0b3JlXSxcbiAgICAgICAgICAoc3RvcmUsIGNhbGxiYWNrKSA9PiBzdG9yZS5jbG9zZShjYWxsYmFjayksXG4gICAgICAgICAgY2IpXG4gICAgICB9LFxuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGxvZygndW5sb2NraW5nJylcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuX2Nsb3NlTG9jayhjYilcbiAgICAgIH0sXG4gICAgICAoY2IpID0+IHtcbiAgICAgICAgdGhpcy5sb2NrZmlsZSA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIF0sIChlcnIpID0+IGNhbGxiYWNrKGVycikpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSByZXBvIGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgYm9vbCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZXhpc3RzIChjYWxsYmFjaykge1xuICAgIHRoaXMudmVyc2lvbi5leGlzdHMoY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlcG8gc3RhdHVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmh1bWFuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE9iamVjdCl9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0IChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBodW1hbjogZmFsc2UgfSwgb3B0aW9ucylcblxuICAgIHBhcmFsbGVsKHtcbiAgICAgIHN0b3JhZ2VNYXg6IChjYikgPT4gdGhpcy5jb25maWcuZ2V0KCdEYXRhc3RvcmUuU3RvcmFnZU1heCcsIChlcnIsIG1heCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IobnVsbCwgbmV3IEJpZyhub0xpbWl0KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCBuZXcgQmlnKG1heCkpXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdmVyc2lvbjogKGNiKSA9PiB0aGlzLnZlcnNpb24uZ2V0KGNiKSxcbiAgICAgIGJsb2NrczogKGNiKSA9PiB0aGlzLmJsb2Nrcy5xdWVyeSh7fSwgKGVyciwgbGlzdCkgPT4ge1xuICAgICAgICBsaXN0ID0gbGlzdCB8fCBbXVxuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gbmV3IEJpZyhsaXN0Lmxlbmd0aClcbiAgICAgICAgbGV0IHNpemUgPSBuZXcgQmlnKDApXG5cbiAgICAgICAgbGlzdC5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICBzaXplID0gc2l6ZVxuICAgICAgICAgICAgLnBsdXMoYmxvY2sudmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIC5wbHVzKGJsb2NrLmtleS5fYnVmLmJ5dGVMZW5ndGgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2IoZXJyLCB7XG4gICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgZGF0YXN0b3JlOiAoY2IpID0+IGdldFNpemUodGhpcy5kYXRhc3RvcmUsIGNiKSxcbiAgICAgIGtleXM6IChjYikgPT4gZ2V0U2l6ZSh0aGlzLmtleXMsIGNiKVxuICAgIH0sIChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICAgIGxldCBzaXplID0gcmVzdWx0cy5ibG9ja3Muc2l6ZVxuICAgICAgICAucGx1cyhyZXN1bHRzLmRhdGFzdG9yZSlcbiAgICAgICAgLnBsdXMocmVzdWx0cy5rZXlzKVxuXG4gICAgICBpZiAob3B0aW9ucy5odW1hbikge1xuICAgICAgICBzaXplID0gc2l6ZS5kaXYoMTA0ODU3NilcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICByZXBvUGF0aDogdGhpcy5wYXRoLFxuICAgICAgICBzdG9yYWdlTWF4OiByZXN1bHRzLnN0b3JhZ2VNYXgsXG4gICAgICAgIHZlcnNpb246IHJlc3VsdHMudmVyc2lvbixcbiAgICAgICAgbnVtT2JqZWN0czogcmVzdWx0cy5ibG9ja3MuY291bnQsXG4gICAgICAgIHJlcG9TaXplOiBzaXplXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZSAocXVlcnlGbiwgY2FsbGJhY2spIHtcbiAgcHVsbChcbiAgICBxdWVyeUZuLnF1ZXJ5KHt9KSxcbiAgICByZWR1Y2UoKHN1bSwgYmxvY2spID0+IHtcbiAgICAgIHJldHVybiBzdW1cbiAgICAgICAgLnBsdXMoYmxvY2sudmFsdWUuYnl0ZUxlbmd0aClcbiAgICAgICAgLnBsdXMoYmxvY2sua2V5Ll9idWYuYnl0ZUxlbmd0aClcbiAgICB9LCBuZXcgQmlnKDApLCBjYWxsYmFjaykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSXBmc1JlcG9cbm1vZHVsZS5leHBvcnRzLnJlcG9WZXJzaW9uID0gcmVwb1ZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IEVSUk9SU1xuXG5mdW5jdGlvbiBpZ25vcmluZ0lmIChjb25kLCBjYikge1xuICByZXR1cm4gKGVycikgPT4ge1xuICAgIGNiKGVyciAmJiAhY29uZChlcnIpID8gZXJyIDogbnVsbClcbiAgfVxufVxuZnVuY3Rpb24gaWdub3JpbmdBbHJlYWR5T3BlbmVkIChjYikge1xuICByZXR1cm4gaWdub3JpbmdJZigoZXJyKSA9PiBlcnIubWVzc2FnZSA9PT0gJ0FscmVhZHkgb3BlbicsIGNiKVxufVxuXG5mdW5jdGlvbiBpZ25vcmluZ05vdEZvdW5kIChjYikge1xuICByZXR1cm4gaWdub3JpbmdJZigoZXJyKSA9PiB7XG4gICAgcmV0dXJuIGVyciAmJiAoZXJyLmNvZGUgPT09IEVSUk9SUy5FUlJfUkVQT19OT1RfSU5JVElBTElaRUQgfHwgZXJyLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnRU5PRU5UJykpXG4gIH0sIGNiKVxufVxuXG5mdW5jdGlvbiBidWlsZE9wdGlvbnMgKF9vcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgX29wdGlvbnMpXG5cbiAgb3B0aW9ucy5zdG9yYWdlQmFja2VuZHMgPSBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIGRlZmF1bHRPcHRpb25zLnN0b3JhZ2VCYWNrZW5kcyxcbiAgICBvcHRpb25zLnN0b3JhZ2VCYWNrZW5kcylcblxuICBvcHRpb25zLnN0b3JhZ2VCYWNrZW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAge30sXG4gICAgZGVmYXVsdE9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zLFxuICAgIG9wdGlvbnMuc3RvcmFnZUJhY2tlbmRPcHRpb25zKVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8vIFRPRE8gdGhpcyBzaG91bGQgY29tZSBmcm9tIGpzLWlwZnMgaW5zdGVhZFxuZnVuY3Rpb24gYnVpbGRDb25maWcgKF9jb25maWcpIHtcbiAgX2NvbmZpZy5kYXRhc3RvcmUgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YXN0b3JlLCBfZ2V0KF9jb25maWcsICdkYXRhc3RvcmUnLCB7fSkpXG5cbiAgcmV0dXJuIF9jb25maWdcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRhc3RvcmVTcGVjIChfY29uZmlnKSB7XG4gIGNvbnN0IHNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YXN0b3JlLlNwZWMsIF9nZXQoX2NvbmZpZywgJ2RhdGFzdG9yZS5TcGVjJywge30pKVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogc3BlYy50eXBlLFxuICAgIG1vdW50czogc3BlYy5tb3VudHMubWFwKChtb3VudGluZykgPT4gKHtcbiAgICAgIG1vdW50cG9pbnQ6IG1vdW50aW5nLm1vdW50cG9pbnQsXG4gICAgICB0eXBlOiBtb3VudGluZy5jaGlsZC50eXBlLFxuICAgICAgcGF0aDogbW91bnRpbmcuY2hpbGQucGF0aCxcbiAgICAgIHNoYXJkRnVuYzogbW91bnRpbmcuY2hpbGQuc2hhcmRGdW5jXG4gICAgfSkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zZXRJbW1lZGlhdGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3NldEltbWVkaWF0ZScpO1xuXG52YXIgX3NldEltbWVkaWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRJbW1lZGlhdGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBzZXRJbW1lZGlhdGVgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWZcbiAqIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKWAsIHdoaWNoIG1lYW5zIG90aGVyIGhpZ2hlclxuICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBmb3IgYnJvd3Nlci1jb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBuYW1lIHNldEltbWVkaWF0ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMubmV4dFRpY2tde0BsaW5rIG1vZHVsZTpVdGlscy5uZXh0VGlja31cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmRcbiAqIHRoZSBldmVudCBsb29wLiBJbnZva2VkIHdpdGggKGFyZ3MuLi4pLlxuICogQHBhcmFtIHsuLi4qfSBhcmdzLi4uIC0gYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZVxuICogY2FsbGJhY2sgb24gdGhlIG5leHQgdGljay5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGNhbGxfb3JkZXIgPSBbXTtcbiAqIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICogICAgIGNhbGxfb3JkZXIucHVzaCgndHdvJyk7XG4gKiAgICAgLy8gY2FsbF9vcmRlciBub3cgZXF1YWxzIFsnb25lJywndHdvJ11cbiAqIH0pO1xuICogY2FsbF9vcmRlci5wdXNoKCdvbmUnKTtcbiAqXG4gKiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAqICAgICAvLyBhLCBiLCBhbmQgYyBlcXVhbCAxLCAyLCBhbmQgM1xuICogfSwgMSwgMiwgMyk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IF9zZXRJbW1lZGlhdGUyLmRlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmc20nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZzbUV2ZW50XG5cbi8vIGNyZWF0ZSBhbiBmc21FdmVudCBpbnN0YW5jZVxuLy8gb2JqIC0+IGZuXG5mdW5jdGlvbiBmc21FdmVudCAoc3RhcnQsIGV2ZW50cykge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnb2JqZWN0Jykge1xuICAgIGV2ZW50cyA9IHN0YXJ0XG4gICAgc3RhcnQgPSAnU1RBUlQnXG4gIH1cbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBzdGFydCwgJ3N0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgZXZlbnRzLCAnb2JqZWN0JylcbiAgYXNzZXJ0Lm9rKGV2ZW50c1tzdGFydF0sICdpbnZhbGlkIHN0YXJ0aW5nIHN0YXRlICcgKyBzdGFydClcbiAgYXNzZXJ0Lm9rKGZzbS52YWxpZGF0ZShldmVudHMpKVxuXG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKClcbiAgZW1pdC5fZ3JhcGggPSBmc20ucmVhY2hhYmxlKGV2ZW50cylcbiAgZW1pdC5fZW1pdHRlciA9IGVtaXR0ZXJcbiAgZW1pdC5fZXZlbnRzID0gZXZlbnRzXG4gIGVtaXQuX3N0YXRlID0gc3RhcnRcbiAgZW1pdC5lbWl0ID0gZW1pdFxuICBlbWl0Lm9uID0gb25cblxuICByZXR1cm4gZW1pdFxuXG4gIC8vIHNldCBhIHN0YXRlIGxpc3RlbmVyXG4gIC8vIHN0ciwgZm4gLT4gbnVsbFxuICBmdW5jdGlvbiBvbiAoZXZlbnQsIGNiKSB7XG4gICAgZW1pdHRlci5vbihldmVudCwgY2IpXG4gIH1cblxuICAvLyBjaGFuZ2UgdGhlIHN0YXRlXG4gIC8vIHN0ciAtPiBudWxsXG4gIGZ1bmN0aW9uIGVtaXQgKHN0cikge1xuICAgIGNvbnN0IG53U3RhdGUgPSBlbWl0Ll9ldmVudHNbZW1pdC5fc3RhdGVdW3N0cl1cbiAgICBpZiAoIXJlYWNoKGVtaXQuX3N0YXRlLCBud1N0YXRlLCBlbWl0Ll9ncmFwaCkpIHtcbiAgICAgIGNvbnN0IGVyciA9ICdpbnZhbGlkIHRyYW5zaXRpb246ICcgKyBlbWl0Ll9zdGF0ZSArICcgLT4gJyArIHN0clxuICAgICAgcmV0dXJuIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgY29uc3QgbGVhdmVFdiA9IGVtaXQuX3N0YXRlICsgJzpsZWF2ZSdcbiAgICBjb25zdCBlbnRlckV2ID0gbndTdGF0ZSArICc6ZW50ZXInXG5cbiAgICBpZiAoIWVtaXQuX3N0YXRlKSByZXR1cm4gZW50ZXIoKVxuICAgIHJldHVybiBsZWF2ZSgpXG5cbiAgICBmdW5jdGlvbiBsZWF2ZSAoKSB7XG4gICAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tsZWF2ZUV2XSkgZW50ZXIoKVxuICAgICAgZWxzZSBlbWl0dGVyLmVtaXQobGVhdmVFdiwgZW50ZXIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW50ZXIgKCkge1xuICAgICAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZW50ZXJFdl0pIGRvbmUoKVxuICAgICAgZWxzZSBlbWl0dGVyLmVtaXQoZW50ZXJFdiwgZG9uZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICAgIGVtaXQuX3N0YXRlID0gbndTdGF0ZVxuICAgICAgZW1pdHRlci5lbWl0KG53U3RhdGUpXG4gICAgICBlbWl0dGVyLmVtaXQoJ2RvbmUnKVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBpZiBzdGF0ZSBjYW4gcmVhY2ggaW4gcmVhY2hcbi8vIHN0ciwgc3RyLCBvYmogLT4gYm9vbFxuZnVuY3Rpb24gcmVhY2ggKGN1cnIsIG5leHQsIHJlYWNoYWJsZSkge1xuICBpZiAoIW5leHQpIHJldHVybiBmYWxzZVxuICBpZiAoIWN1cnIpIHJldHVybiB0cnVlXG5cbiAgY29uc3QgaGVyZSA9IHJlYWNoYWJsZVtjdXJyXVxuICBpZiAoIWhlcmUgfHwgIWhlcmVbbmV4dF0pIHJldHVybiBmYWxzZVxuICByZXR1cm4gaGVyZVtuZXh0XS5sZW5ndGggPT09IDFcbn1cbiIsIi8vIFRISVMgRklMRSBJUyBHRU5FUkFURUQsIERPIE5PIEVESVQgTUFOVUFMTFlcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgUkVBRE1FLm1kXG4vKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcblxuICAvLyBzZXJpYWxpemF0aW9uXG4gIDB4NTA6ICdwcm90b2J1ZicsXG4gIDB4NTE6ICdjYm9yJyxcbiAgMHg2MDogJ3JscCcsXG4gIDB4NjM6ICdiZW5jb2RlJyxcbiAgMHgwMjAwOiAnanNvbicsXG4gIDB4MDIwMTogJ21lc3NhZ2VwYWNrJyxcblxuICAvLyBtdWx0aWZvcm1hdFxuICAweDMwOiAnbXVsdGljb2RlYycsXG4gIDB4MzE6ICdtdWx0aWhhc2gnLFxuICAweDMyOiAnbXVsdGlhZGRyJyxcbiAgMHgzMzogJ211bHRpYmFzZScsXG5cbiAgLy8gbXVsdGloYXNoXG4gIDB4MDA6ICdpZGVudGl0eScsXG4gIDB4MTE6ICdzaGExJyxcbiAgMHgxMjogJ3NoYTItMjU2JyxcbiAgMHgxMzogJ3NoYTItNTEyJyxcbiAgMHgxNDogJ3NoYTMtNTEyJyxcbiAgMHgxNTogJ3NoYTMtMzg0JyxcbiAgMHgxNjogJ3NoYTMtMjU2JyxcbiAgMHgxNzogJ3NoYTMtMjI0JyxcbiAgMHgxODogJ3NoYWtlLTEyOCcsXG4gIDB4MTk6ICdzaGFrZS0yNTYnLFxuICAweDFhOiAna2VjY2FrLTIyNCcsXG4gIDB4MWI6ICdrZWNjYWstMjU2JyxcbiAgMHgxYzogJ2tlY2Nhay0zODQnLFxuICAweDFkOiAna2VjY2FrLTUxMicsXG4gIDB4MjI6ICdtdXJtdXIzLTEyOCcsXG4gIDB4MjM6ICdtdXJtdXIzLTMyJyxcbiAgMHg1NjogJ2RibC1zaGEyLTI1NicsXG4gIDB4ZDQ6ICdtZDQnLFxuICAweGQ1OiAnbWQ1JyxcbiAgMHhkNjogJ2JtdCcsXG4gIDB4MTEwMDogJ3gxMScsXG4gIDB4YjIwMTogJ2JsYWtlMmItOCcsXG4gIDB4YjIwMjogJ2JsYWtlMmItMTYnLFxuICAweGIyMDM6ICdibGFrZTJiLTI0JyxcbiAgMHhiMjA0OiAnYmxha2UyYi0zMicsXG4gIDB4YjIwNTogJ2JsYWtlMmItNDAnLFxuICAweGIyMDY6ICdibGFrZTJiLTQ4JyxcbiAgMHhiMjA3OiAnYmxha2UyYi01NicsXG4gIDB4YjIwODogJ2JsYWtlMmItNjQnLFxuICAweGIyMDk6ICdibGFrZTJiLTcyJyxcbiAgMHhiMjBhOiAnYmxha2UyYi04MCcsXG4gIDB4YjIwYjogJ2JsYWtlMmItODgnLFxuICAweGIyMGM6ICdibGFrZTJiLTk2JyxcbiAgMHhiMjBkOiAnYmxha2UyYi0xMDQnLFxuICAweGIyMGU6ICdibGFrZTJiLTExMicsXG4gIDB4YjIwZjogJ2JsYWtlMmItMTIwJyxcbiAgMHhiMjEwOiAnYmxha2UyYi0xMjgnLFxuICAweGIyMTE6ICdibGFrZTJiLTEzNicsXG4gIDB4YjIxMjogJ2JsYWtlMmItMTQ0JyxcbiAgMHhiMjEzOiAnYmxha2UyYi0xNTInLFxuICAweGIyMTQ6ICdibGFrZTJiLTE2MCcsXG4gIDB4YjIxNTogJ2JsYWtlMmItMTY4JyxcbiAgMHhiMjE2OiAnYmxha2UyYi0xNzYnLFxuICAweGIyMTc6ICdibGFrZTJiLTE4NCcsXG4gIDB4YjIxODogJ2JsYWtlMmItMTkyJyxcbiAgMHhiMjE5OiAnYmxha2UyYi0yMDAnLFxuICAweGIyMWE6ICdibGFrZTJiLTIwOCcsXG4gIDB4YjIxYjogJ2JsYWtlMmItMjE2JyxcbiAgMHhiMjFjOiAnYmxha2UyYi0yMjQnLFxuICAweGIyMWQ6ICdibGFrZTJiLTIzMicsXG4gIDB4YjIxZTogJ2JsYWtlMmItMjQwJyxcbiAgMHhiMjFmOiAnYmxha2UyYi0yNDgnLFxuICAweGIyMjA6ICdibGFrZTJiLTI1NicsXG4gIDB4YjIyMTogJ2JsYWtlMmItMjY0JyxcbiAgMHhiMjIyOiAnYmxha2UyYi0yNzInLFxuICAweGIyMjM6ICdibGFrZTJiLTI4MCcsXG4gIDB4YjIyNDogJ2JsYWtlMmItMjg4JyxcbiAgMHhiMjI1OiAnYmxha2UyYi0yOTYnLFxuICAweGIyMjY6ICdibGFrZTJiLTMwNCcsXG4gIDB4YjIyNzogJ2JsYWtlMmItMzEyJyxcbiAgMHhiMjI4OiAnYmxha2UyYi0zMjAnLFxuICAweGIyMjk6ICdibGFrZTJiLTMyOCcsXG4gIDB4YjIyYTogJ2JsYWtlMmItMzM2JyxcbiAgMHhiMjJiOiAnYmxha2UyYi0zNDQnLFxuICAweGIyMmM6ICdibGFrZTJiLTM1MicsXG4gIDB4YjIyZDogJ2JsYWtlMmItMzYwJyxcbiAgMHhiMjJlOiAnYmxha2UyYi0zNjgnLFxuICAweGIyMmY6ICdibGFrZTJiLTM3NicsXG4gIDB4YjIzMDogJ2JsYWtlMmItMzg0JyxcbiAgMHhiMjMxOiAnYmxha2UyYi0zOTInLFxuICAweGIyMzI6ICdibGFrZTJiLTQwMCcsXG4gIDB4YjIzMzogJ2JsYWtlMmItNDA4JyxcbiAgMHhiMjM0OiAnYmxha2UyYi00MTYnLFxuICAweGIyMzU6ICdibGFrZTJiLTQyNCcsXG4gIDB4YjIzNjogJ2JsYWtlMmItNDMyJyxcbiAgMHhiMjM3OiAnYmxha2UyYi00NDAnLFxuICAweGIyMzg6ICdibGFrZTJiLTQ0OCcsXG4gIDB4YjIzOTogJ2JsYWtlMmItNDU2JyxcbiAgMHhiMjNhOiAnYmxha2UyYi00NjQnLFxuICAweGIyM2I6ICdibGFrZTJiLTQ3MicsXG4gIDB4YjIzYzogJ2JsYWtlMmItNDgwJyxcbiAgMHhiMjNkOiAnYmxha2UyYi00ODgnLFxuICAweGIyM2U6ICdibGFrZTJiLTQ5NicsXG4gIDB4YjIzZjogJ2JsYWtlMmItNTA0JyxcbiAgMHhiMjQwOiAnYmxha2UyYi01MTInLFxuICAweGIyNDE6ICdibGFrZTJzLTgnLFxuICAweGIyNDI6ICdibGFrZTJzLTE2JyxcbiAgMHhiMjQzOiAnYmxha2Uycy0yNCcsXG4gIDB4YjI0NDogJ2JsYWtlMnMtMzInLFxuICAweGIyNDU6ICdibGFrZTJzLTQwJyxcbiAgMHhiMjQ2OiAnYmxha2Uycy00OCcsXG4gIDB4YjI0NzogJ2JsYWtlMnMtNTYnLFxuICAweGIyNDg6ICdibGFrZTJzLTY0JyxcbiAgMHhiMjQ5OiAnYmxha2Uycy03MicsXG4gIDB4YjI0YTogJ2JsYWtlMnMtODAnLFxuICAweGIyNGI6ICdibGFrZTJzLTg4JyxcbiAgMHhiMjRjOiAnYmxha2Uycy05NicsXG4gIDB4YjI0ZDogJ2JsYWtlMnMtMTA0JyxcbiAgMHhiMjRlOiAnYmxha2Uycy0xMTInLFxuICAweGIyNGY6ICdibGFrZTJzLTEyMCcsXG4gIDB4YjI1MDogJ2JsYWtlMnMtMTI4JyxcbiAgMHhiMjUxOiAnYmxha2Uycy0xMzYnLFxuICAweGIyNTI6ICdibGFrZTJzLTE0NCcsXG4gIDB4YjI1MzogJ2JsYWtlMnMtMTUyJyxcbiAgMHhiMjU0OiAnYmxha2Uycy0xNjAnLFxuICAweGIyNTU6ICdibGFrZTJzLTE2OCcsXG4gIDB4YjI1NjogJ2JsYWtlMnMtMTc2JyxcbiAgMHhiMjU3OiAnYmxha2Uycy0xODQnLFxuICAweGIyNTg6ICdibGFrZTJzLTE5MicsXG4gIDB4YjI1OTogJ2JsYWtlMnMtMjAwJyxcbiAgMHhiMjVhOiAnYmxha2Uycy0yMDgnLFxuICAweGIyNWI6ICdibGFrZTJzLTIxNicsXG4gIDB4YjI1YzogJ2JsYWtlMnMtMjI0JyxcbiAgMHhiMjVkOiAnYmxha2Uycy0yMzInLFxuICAweGIyNWU6ICdibGFrZTJzLTI0MCcsXG4gIDB4YjI1ZjogJ2JsYWtlMnMtMjQ4JyxcbiAgMHhiMjYwOiAnYmxha2Uycy0yNTYnLFxuICAweGIzMDE6ICdza2VpbjI1Ni04JyxcbiAgMHhiMzAyOiAnc2tlaW4yNTYtMTYnLFxuICAweGIzMDM6ICdza2VpbjI1Ni0yNCcsXG4gIDB4YjMwNDogJ3NrZWluMjU2LTMyJyxcbiAgMHhiMzA1OiAnc2tlaW4yNTYtNDAnLFxuICAweGIzMDY6ICdza2VpbjI1Ni00OCcsXG4gIDB4YjMwNzogJ3NrZWluMjU2LTU2JyxcbiAgMHhiMzA4OiAnc2tlaW4yNTYtNjQnLFxuICAweGIzMDk6ICdza2VpbjI1Ni03MicsXG4gIDB4YjMwYTogJ3NrZWluMjU2LTgwJyxcbiAgMHhiMzBiOiAnc2tlaW4yNTYtODgnLFxuICAweGIzMGM6ICdza2VpbjI1Ni05NicsXG4gIDB4YjMwZDogJ3NrZWluMjU2LTEwNCcsXG4gIDB4YjMwZTogJ3NrZWluMjU2LTExMicsXG4gIDB4YjMwZjogJ3NrZWluMjU2LTEyMCcsXG4gIDB4YjMxMDogJ3NrZWluMjU2LTEyOCcsXG4gIDB4YjMxMTogJ3NrZWluMjU2LTEzNicsXG4gIDB4YjMxMjogJ3NrZWluMjU2LTE0NCcsXG4gIDB4YjMxMzogJ3NrZWluMjU2LTE1MicsXG4gIDB4YjMxNDogJ3NrZWluMjU2LTE2MCcsXG4gIDB4YjMxNTogJ3NrZWluMjU2LTE2OCcsXG4gIDB4YjMxNjogJ3NrZWluMjU2LTE3NicsXG4gIDB4YjMxNzogJ3NrZWluMjU2LTE4NCcsXG4gIDB4YjMxODogJ3NrZWluMjU2LTE5MicsXG4gIDB4YjMxOTogJ3NrZWluMjU2LTIwMCcsXG4gIDB4YjMxYTogJ3NrZWluMjU2LTIwOCcsXG4gIDB4YjMxYjogJ3NrZWluMjU2LTIxNicsXG4gIDB4YjMxYzogJ3NrZWluMjU2LTIyNCcsXG4gIDB4YjMxZDogJ3NrZWluMjU2LTIzMicsXG4gIDB4YjMxZTogJ3NrZWluMjU2LTI0MCcsXG4gIDB4YjMxZjogJ3NrZWluMjU2LTI0OCcsXG4gIDB4YjMyMDogJ3NrZWluMjU2LTI1NicsXG4gIDB4YjMyMTogJ3NrZWluNTEyLTgnLFxuICAweGIzMjI6ICdza2VpbjUxMi0xNicsXG4gIDB4YjMyMzogJ3NrZWluNTEyLTI0JyxcbiAgMHhiMzI0OiAnc2tlaW41MTItMzInLFxuICAweGIzMjU6ICdza2VpbjUxMi00MCcsXG4gIDB4YjMyNjogJ3NrZWluNTEyLTQ4JyxcbiAgMHhiMzI3OiAnc2tlaW41MTItNTYnLFxuICAweGIzMjg6ICdza2VpbjUxMi02NCcsXG4gIDB4YjMyOTogJ3NrZWluNTEyLTcyJyxcbiAgMHhiMzJhOiAnc2tlaW41MTItODAnLFxuICAweGIzMmI6ICdza2VpbjUxMi04OCcsXG4gIDB4YjMyYzogJ3NrZWluNTEyLTk2JyxcbiAgMHhiMzJkOiAnc2tlaW41MTItMTA0JyxcbiAgMHhiMzJlOiAnc2tlaW41MTItMTEyJyxcbiAgMHhiMzJmOiAnc2tlaW41MTItMTIwJyxcbiAgMHhiMzMwOiAnc2tlaW41MTItMTI4JyxcbiAgMHhiMzMxOiAnc2tlaW41MTItMTM2JyxcbiAgMHhiMzMyOiAnc2tlaW41MTItMTQ0JyxcbiAgMHhiMzMzOiAnc2tlaW41MTItMTUyJyxcbiAgMHhiMzM0OiAnc2tlaW41MTItMTYwJyxcbiAgMHhiMzM1OiAnc2tlaW41MTItMTY4JyxcbiAgMHhiMzM2OiAnc2tlaW41MTItMTc2JyxcbiAgMHhiMzM3OiAnc2tlaW41MTItMTg0JyxcbiAgMHhiMzM4OiAnc2tlaW41MTItMTkyJyxcbiAgMHhiMzM5OiAnc2tlaW41MTItMjAwJyxcbiAgMHhiMzNhOiAnc2tlaW41MTItMjA4JyxcbiAgMHhiMzNiOiAnc2tlaW41MTItMjE2JyxcbiAgMHhiMzNjOiAnc2tlaW41MTItMjI0JyxcbiAgMHhiMzNkOiAnc2tlaW41MTItMjMyJyxcbiAgMHhiMzNlOiAnc2tlaW41MTItMjQwJyxcbiAgMHhiMzNmOiAnc2tlaW41MTItMjQ4JyxcbiAgMHhiMzQwOiAnc2tlaW41MTItMjU2JyxcbiAgMHhiMzQxOiAnc2tlaW41MTItMjY0JyxcbiAgMHhiMzQyOiAnc2tlaW41MTItMjcyJyxcbiAgMHhiMzQzOiAnc2tlaW41MTItMjgwJyxcbiAgMHhiMzQ0OiAnc2tlaW41MTItMjg4JyxcbiAgMHhiMzQ1OiAnc2tlaW41MTItMjk2JyxcbiAgMHhiMzQ2OiAnc2tlaW41MTItMzA0JyxcbiAgMHhiMzQ3OiAnc2tlaW41MTItMzEyJyxcbiAgMHhiMzQ4OiAnc2tlaW41MTItMzIwJyxcbiAgMHhiMzQ5OiAnc2tlaW41MTItMzI4JyxcbiAgMHhiMzRhOiAnc2tlaW41MTItMzM2JyxcbiAgMHhiMzRiOiAnc2tlaW41MTItMzQ0JyxcbiAgMHhiMzRjOiAnc2tlaW41MTItMzUyJyxcbiAgMHhiMzRkOiAnc2tlaW41MTItMzYwJyxcbiAgMHhiMzRlOiAnc2tlaW41MTItMzY4JyxcbiAgMHhiMzRmOiAnc2tlaW41MTItMzc2JyxcbiAgMHhiMzUwOiAnc2tlaW41MTItMzg0JyxcbiAgMHhiMzUxOiAnc2tlaW41MTItMzkyJyxcbiAgMHhiMzUyOiAnc2tlaW41MTItNDAwJyxcbiAgMHhiMzUzOiAnc2tlaW41MTItNDA4JyxcbiAgMHhiMzU0OiAnc2tlaW41MTItNDE2JyxcbiAgMHhiMzU1OiAnc2tlaW41MTItNDI0JyxcbiAgMHhiMzU2OiAnc2tlaW41MTItNDMyJyxcbiAgMHhiMzU3OiAnc2tlaW41MTItNDQwJyxcbiAgMHhiMzU4OiAnc2tlaW41MTItNDQ4JyxcbiAgMHhiMzU5OiAnc2tlaW41MTItNDU2JyxcbiAgMHhiMzVhOiAnc2tlaW41MTItNDY0JyxcbiAgMHhiMzViOiAnc2tlaW41MTItNDcyJyxcbiAgMHhiMzVjOiAnc2tlaW41MTItNDgwJyxcbiAgMHhiMzVkOiAnc2tlaW41MTItNDg4JyxcbiAgMHhiMzVlOiAnc2tlaW41MTItNDk2JyxcbiAgMHhiMzVmOiAnc2tlaW41MTItNTA0JyxcbiAgMHhiMzYwOiAnc2tlaW41MTItNTEyJyxcbiAgMHhiMzYxOiAnc2tlaW4xMDI0LTgnLFxuICAweGIzNjI6ICdza2VpbjEwMjQtMTYnLFxuICAweGIzNjM6ICdza2VpbjEwMjQtMjQnLFxuICAweGIzNjQ6ICdza2VpbjEwMjQtMzInLFxuICAweGIzNjU6ICdza2VpbjEwMjQtNDAnLFxuICAweGIzNjY6ICdza2VpbjEwMjQtNDgnLFxuICAweGIzNjc6ICdza2VpbjEwMjQtNTYnLFxuICAweGIzNjg6ICdza2VpbjEwMjQtNjQnLFxuICAweGIzNjk6ICdza2VpbjEwMjQtNzInLFxuICAweGIzNmE6ICdza2VpbjEwMjQtODAnLFxuICAweGIzNmI6ICdza2VpbjEwMjQtODgnLFxuICAweGIzNmM6ICdza2VpbjEwMjQtOTYnLFxuICAweGIzNmQ6ICdza2VpbjEwMjQtMTA0JyxcbiAgMHhiMzZlOiAnc2tlaW4xMDI0LTExMicsXG4gIDB4YjM2ZjogJ3NrZWluMTAyNC0xMjAnLFxuICAweGIzNzA6ICdza2VpbjEwMjQtMTI4JyxcbiAgMHhiMzcxOiAnc2tlaW4xMDI0LTEzNicsXG4gIDB4YjM3MjogJ3NrZWluMTAyNC0xNDQnLFxuICAweGIzNzM6ICdza2VpbjEwMjQtMTUyJyxcbiAgMHhiMzc0OiAnc2tlaW4xMDI0LTE2MCcsXG4gIDB4YjM3NTogJ3NrZWluMTAyNC0xNjgnLFxuICAweGIzNzY6ICdza2VpbjEwMjQtMTc2JyxcbiAgMHhiMzc3OiAnc2tlaW4xMDI0LTE4NCcsXG4gIDB4YjM3ODogJ3NrZWluMTAyNC0xOTInLFxuICAweGIzNzk6ICdza2VpbjEwMjQtMjAwJyxcbiAgMHhiMzdhOiAnc2tlaW4xMDI0LTIwOCcsXG4gIDB4YjM3YjogJ3NrZWluMTAyNC0yMTYnLFxuICAweGIzN2M6ICdza2VpbjEwMjQtMjI0JyxcbiAgMHhiMzdkOiAnc2tlaW4xMDI0LTIzMicsXG4gIDB4YjM3ZTogJ3NrZWluMTAyNC0yNDAnLFxuICAweGIzN2Y6ICdza2VpbjEwMjQtMjQ4JyxcbiAgMHhiMzgwOiAnc2tlaW4xMDI0LTI1NicsXG4gIDB4YjM4MTogJ3NrZWluMTAyNC0yNjQnLFxuICAweGIzODI6ICdza2VpbjEwMjQtMjcyJyxcbiAgMHhiMzgzOiAnc2tlaW4xMDI0LTI4MCcsXG4gIDB4YjM4NDogJ3NrZWluMTAyNC0yODgnLFxuICAweGIzODU6ICdza2VpbjEwMjQtMjk2JyxcbiAgMHhiMzg2OiAnc2tlaW4xMDI0LTMwNCcsXG4gIDB4YjM4NzogJ3NrZWluMTAyNC0zMTInLFxuICAweGIzODg6ICdza2VpbjEwMjQtMzIwJyxcbiAgMHhiMzg5OiAnc2tlaW4xMDI0LTMyOCcsXG4gIDB4YjM4YTogJ3NrZWluMTAyNC0zMzYnLFxuICAweGIzOGI6ICdza2VpbjEwMjQtMzQ0JyxcbiAgMHhiMzhjOiAnc2tlaW4xMDI0LTM1MicsXG4gIDB4YjM4ZDogJ3NrZWluMTAyNC0zNjAnLFxuICAweGIzOGU6ICdza2VpbjEwMjQtMzY4JyxcbiAgMHhiMzhmOiAnc2tlaW4xMDI0LTM3NicsXG4gIDB4YjM5MDogJ3NrZWluMTAyNC0zODQnLFxuICAweGIzOTE6ICdza2VpbjEwMjQtMzkyJyxcbiAgMHhiMzkyOiAnc2tlaW4xMDI0LTQwMCcsXG4gIDB4YjM5MzogJ3NrZWluMTAyNC00MDgnLFxuICAweGIzOTQ6ICdza2VpbjEwMjQtNDE2JyxcbiAgMHhiMzk1OiAnc2tlaW4xMDI0LTQyNCcsXG4gIDB4YjM5NjogJ3NrZWluMTAyNC00MzInLFxuICAweGIzOTc6ICdza2VpbjEwMjQtNDQwJyxcbiAgMHhiMzk4OiAnc2tlaW4xMDI0LTQ0OCcsXG4gIDB4YjM5OTogJ3NrZWluMTAyNC00NTYnLFxuICAweGIzOWE6ICdza2VpbjEwMjQtNDY0JyxcbiAgMHhiMzliOiAnc2tlaW4xMDI0LTQ3MicsXG4gIDB4YjM5YzogJ3NrZWluMTAyNC00ODAnLFxuICAweGIzOWQ6ICdza2VpbjEwMjQtNDg4JyxcbiAgMHhiMzllOiAnc2tlaW4xMDI0LTQ5NicsXG4gIDB4YjM5ZjogJ3NrZWluMTAyNC01MDQnLFxuICAweGIzYTA6ICdza2VpbjEwMjQtNTEyJyxcbiAgMHhiM2ExOiAnc2tlaW4xMDI0LTUyMCcsXG4gIDB4YjNhMjogJ3NrZWluMTAyNC01MjgnLFxuICAweGIzYTM6ICdza2VpbjEwMjQtNTM2JyxcbiAgMHhiM2E0OiAnc2tlaW4xMDI0LTU0NCcsXG4gIDB4YjNhNTogJ3NrZWluMTAyNC01NTInLFxuICAweGIzYTY6ICdza2VpbjEwMjQtNTYwJyxcbiAgMHhiM2E3OiAnc2tlaW4xMDI0LTU2OCcsXG4gIDB4YjNhODogJ3NrZWluMTAyNC01NzYnLFxuICAweGIzYTk6ICdza2VpbjEwMjQtNTg0JyxcbiAgMHhiM2FhOiAnc2tlaW4xMDI0LTU5MicsXG4gIDB4YjNhYjogJ3NrZWluMTAyNC02MDAnLFxuICAweGIzYWM6ICdza2VpbjEwMjQtNjA4JyxcbiAgMHhiM2FkOiAnc2tlaW4xMDI0LTYxNicsXG4gIDB4YjNhZTogJ3NrZWluMTAyNC02MjQnLFxuICAweGIzYWY6ICdza2VpbjEwMjQtNjMyJyxcbiAgMHhiM2IwOiAnc2tlaW4xMDI0LTY0MCcsXG4gIDB4YjNiMTogJ3NrZWluMTAyNC02NDgnLFxuICAweGIzYjI6ICdza2VpbjEwMjQtNjU2JyxcbiAgMHhiM2IzOiAnc2tlaW4xMDI0LTY2NCcsXG4gIDB4YjNiNDogJ3NrZWluMTAyNC02NzInLFxuICAweGIzYjU6ICdza2VpbjEwMjQtNjgwJyxcbiAgMHhiM2I2OiAnc2tlaW4xMDI0LTY4OCcsXG4gIDB4YjNiNzogJ3NrZWluMTAyNC02OTYnLFxuICAweGIzYjg6ICdza2VpbjEwMjQtNzA0JyxcbiAgMHhiM2I5OiAnc2tlaW4xMDI0LTcxMicsXG4gIDB4YjNiYTogJ3NrZWluMTAyNC03MjAnLFxuICAweGIzYmI6ICdza2VpbjEwMjQtNzI4JyxcbiAgMHhiM2JjOiAnc2tlaW4xMDI0LTczNicsXG4gIDB4YjNiZDogJ3NrZWluMTAyNC03NDQnLFxuICAweGIzYmU6ICdza2VpbjEwMjQtNzUyJyxcbiAgMHhiM2JmOiAnc2tlaW4xMDI0LTc2MCcsXG4gIDB4YjNjMDogJ3NrZWluMTAyNC03NjgnLFxuICAweGIzYzE6ICdza2VpbjEwMjQtNzc2JyxcbiAgMHhiM2MyOiAnc2tlaW4xMDI0LTc4NCcsXG4gIDB4YjNjMzogJ3NrZWluMTAyNC03OTInLFxuICAweGIzYzQ6ICdza2VpbjEwMjQtODAwJyxcbiAgMHhiM2M1OiAnc2tlaW4xMDI0LTgwOCcsXG4gIDB4YjNjNjogJ3NrZWluMTAyNC04MTYnLFxuICAweGIzYzc6ICdza2VpbjEwMjQtODI0JyxcbiAgMHhiM2M4OiAnc2tlaW4xMDI0LTgzMicsXG4gIDB4YjNjOTogJ3NrZWluMTAyNC04NDAnLFxuICAweGIzY2E6ICdza2VpbjEwMjQtODQ4JyxcbiAgMHhiM2NiOiAnc2tlaW4xMDI0LTg1NicsXG4gIDB4YjNjYzogJ3NrZWluMTAyNC04NjQnLFxuICAweGIzY2Q6ICdza2VpbjEwMjQtODcyJyxcbiAgMHhiM2NlOiAnc2tlaW4xMDI0LTg4MCcsXG4gIDB4YjNjZjogJ3NrZWluMTAyNC04ODgnLFxuICAweGIzZDA6ICdza2VpbjEwMjQtODk2JyxcbiAgMHhiM2QxOiAnc2tlaW4xMDI0LTkwNCcsXG4gIDB4YjNkMjogJ3NrZWluMTAyNC05MTInLFxuICAweGIzZDM6ICdza2VpbjEwMjQtOTIwJyxcbiAgMHhiM2Q0OiAnc2tlaW4xMDI0LTkyOCcsXG4gIDB4YjNkNTogJ3NrZWluMTAyNC05MzYnLFxuICAweGIzZDY6ICdza2VpbjEwMjQtOTQ0JyxcbiAgMHhiM2Q3OiAnc2tlaW4xMDI0LTk1MicsXG4gIDB4YjNkODogJ3NrZWluMTAyNC05NjAnLFxuICAweGIzZDk6ICdza2VpbjEwMjQtOTY4JyxcbiAgMHhiM2RhOiAnc2tlaW4xMDI0LTk3NicsXG4gIDB4YjNkYjogJ3NrZWluMTAyNC05ODQnLFxuICAweGIzZGM6ICdza2VpbjEwMjQtOTkyJyxcbiAgMHhiM2RkOiAnc2tlaW4xMDI0LTEwMDAnLFxuICAweGIzZGU6ICdza2VpbjEwMjQtMTAwOCcsXG4gIDB4YjNkZjogJ3NrZWluMTAyNC0xMDE2JyxcbiAgMHhiM2UwOiAnc2tlaW4xMDI0LTEwMjQnLFxuXG4gIC8vIG11bHRpYWRkclxuICAweDA0OiAnaXA0JyxcbiAgMHgwNjogJ3RjcCcsXG4gIDB4MjE6ICdkY2NwJyxcbiAgMHgyOTogJ2lwNicsXG4gIDB4MmE6ICdpcDZ6b25lJyxcbiAgMHgzNTogJ2RucycsXG4gIDB4MzY6ICdkbnM0JyxcbiAgMHgzNzogJ2RuczYnLFxuICAweDM4OiAnZG5zYWRkcicsXG4gIDB4ODQ6ICdzY3RwJyxcbiAgMHgwMTExOiAndWRwJyxcbiAgMHgwMTEzOiAncDJwLXdlYnJ0Yy1zdGFyJyxcbiAgMHgwMTE0OiAncDJwLXdlYnJ0Yy1kaXJlY3QnLFxuICAweDAxMTU6ICdwMnAtc3RhcmR1c3QnLFxuICAweDAxMjI6ICdwMnAtY2lyY3VpdCcsXG4gIDB4MDEyZDogJ3VkdCcsXG4gIDB4MDEyZTogJ3V0cCcsXG4gIDB4MDE5MDogJ3VuaXgnLFxuICAweDAxYTU6ICdwMnAnLFxuICAweDAxYmI6ICdodHRwcycsXG4gIDB4MDFiYzogJ29uaW9uJyxcbiAgMHgwMWJkOiAnb25pb24zJyxcbiAgMHgwMWJlOiAnZ2FybGljNjQnLFxuICAweDAxYmY6ICdnYXJsaWMzMicsXG4gIDB4MDFjYzogJ3F1aWMnLFxuICAweDAxZGQ6ICd3cycsXG4gIDB4MDFkZTogJ3dzcycsXG4gIDB4MDFkZjogJ3AycC13ZWJzb2NrZXQtc3RhcicsXG4gIDB4MDFlMDogJ2h0dHAnLFxuXG4gIC8vIGlwbGRcbiAgMHg1NTogJ3JhdycsXG4gIDB4NzA6ICdkYWctcGInLFxuICAweDcxOiAnZGFnLWNib3InLFxuICAweDcyOiAnbGlicDJwLWtleScsXG4gIDB4Nzg6ICdnaXQtcmF3JyxcbiAgMHg3YjogJ3RvcnJlbnQtaW5mbycsXG4gIDB4N2M6ICd0b3JyZW50LWZpbGUnLFxuICAweDgxOiAnbGVvZmNvaW4tYmxvY2snLFxuICAweDgyOiAnbGVvZmNvaW4tdHgnLFxuICAweDgzOiAnbGVvZmNvaW4tcHInLFxuICAweDkwOiAnZXRoLWJsb2NrJyxcbiAgMHg5MTogJ2V0aC1ibG9jay1saXN0JyxcbiAgMHg5MjogJ2V0aC10eC10cmllJyxcbiAgMHg5MzogJ2V0aC10eCcsXG4gIDB4OTQ6ICdldGgtdHgtcmVjZWlwdC10cmllJyxcbiAgMHg5NTogJ2V0aC10eC1yZWNlaXB0JyxcbiAgMHg5NjogJ2V0aC1zdGF0ZS10cmllJyxcbiAgMHg5NzogJ2V0aC1hY2NvdW50LXNuYXBzaG90JyxcbiAgMHg5ODogJ2V0aC1zdG9yYWdlLXRyaWUnLFxuICAweGIwOiAnYml0Y29pbi1ibG9jaycsXG4gIDB4YjE6ICdiaXRjb2luLXR4JyxcbiAgMHhjMDogJ3pjYXNoLWJsb2NrJyxcbiAgMHhjMTogJ3pjYXNoLXR4JyxcbiAgMHhkMDogJ3N0ZWxsYXItYmxvY2snLFxuICAweGQxOiAnc3RlbGxhci10eCcsXG4gIDB4ZTA6ICdkZWNyZWQtYmxvY2snLFxuICAweGUxOiAnZGVjcmVkLXR4JyxcbiAgMHhmMDogJ2Rhc2gtYmxvY2snLFxuICAweGYxOiAnZGFzaC10eCcsXG4gIDB4ZmE6ICdzd2FybS1tYW5pZmVzdCcsXG4gIDB4ZmI6ICdzd2FybS1mZWVkJyxcbiAgMHgwMTI5OiAnZGFnLWpzb24nLFxuXG4gIC8vIG5hbWVzcGFjZVxuICAweDJmOiAncGF0aCcsXG4gIDB4ZTI6ICdpcGxkLW5zJyxcbiAgMHhlMzogJ2lwZnMtbnMnLFxuICAweGU0OiAnc3dhcm0tbnMnLFxuICAweGU1OiAnaXBucy1ucycsXG4gIDB4ZTY6ICd6ZXJvbmV0JyxcblxuICAvLyBrZXlcbiAgMHhlZDogJ2VkMjU1MTktcHViJyxcblxuICAvLyBob2xvY2hhaW5cbiAgMHg4MDcxMjQ6ICdob2xvY2hhaW4tYWRyLXYwJyxcbiAgMHg4MTcxMjQ6ICdob2xvY2hhaW4tYWRyLXYxJyxcbiAgMHg5NDcxMjQ6ICdob2xvY2hhaW4ta2V5LXYwJyxcbiAgMHg5NTcxMjQ6ICdob2xvY2hhaW4ta2V5LXYxJyxcbiAgMHhhMjcxMjQ6ICdob2xvY2hhaW4tc2lnLXYwJyxcbiAgMHhhMzcxMjQ6ICdob2xvY2hhaW4tc2lnLXYxJ1xufSlcbiIsIi8vIFRISVMgRklMRSBJUyBHRU5FUkFURUQsIERPIE5PIEVESVQgTUFOVUFMTFlcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgUkVBRE1FLm1kXG4vKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcblxuICAvLyBzZXJpYWxpemF0aW9uXG4gIFBST1RPQlVGOiAweDUwLFxuICBDQk9SOiAweDUxLFxuICBSTFA6IDB4NjAsXG4gIEJFTkNPREU6IDB4NjMsXG4gIEpTT046IDB4MDIwMCxcbiAgTUVTU0FHRVBBQ0s6IDB4MDIwMSxcblxuICAvLyBtdWx0aWZvcm1hdFxuICBNVUxUSUNPREVDOiAweDMwLFxuICBNVUxUSUhBU0g6IDB4MzEsXG4gIE1VTFRJQUREUjogMHgzMixcbiAgTVVMVElCQVNFOiAweDMzLFxuXG4gIC8vIG11bHRpaGFzaFxuICBJREVOVElUWTogMHgwMCxcbiAgU0hBMTogMHgxMSxcbiAgU0hBMl8yNTY6IDB4MTIsXG4gIFNIQTJfNTEyOiAweDEzLFxuICBTSEEzXzUxMjogMHgxNCxcbiAgU0hBM18zODQ6IDB4MTUsXG4gIFNIQTNfMjU2OiAweDE2LFxuICBTSEEzXzIyNDogMHgxNyxcbiAgU0hBS0VfMTI4OiAweDE4LFxuICBTSEFLRV8yNTY6IDB4MTksXG4gIEtFQ0NBS18yMjQ6IDB4MWEsXG4gIEtFQ0NBS18yNTY6IDB4MWIsXG4gIEtFQ0NBS18zODQ6IDB4MWMsXG4gIEtFQ0NBS181MTI6IDB4MWQsXG4gIE1VUk1VUjNfMTI4OiAweDIyLFxuICBNVVJNVVIzXzMyOiAweDIzLFxuICBEQkxfU0hBMl8yNTY6IDB4NTYsXG4gIE1ENDogMHhkNCxcbiAgTUQ1OiAweGQ1LFxuICBCTVQ6IDB4ZDYsXG4gIFgxMTogMHgxMTAwLFxuICBCTEFLRTJCXzg6IDB4YjIwMSxcbiAgQkxBS0UyQl8xNjogMHhiMjAyLFxuICBCTEFLRTJCXzI0OiAweGIyMDMsXG4gIEJMQUtFMkJfMzI6IDB4YjIwNCxcbiAgQkxBS0UyQl80MDogMHhiMjA1LFxuICBCTEFLRTJCXzQ4OiAweGIyMDYsXG4gIEJMQUtFMkJfNTY6IDB4YjIwNyxcbiAgQkxBS0UyQl82NDogMHhiMjA4LFxuICBCTEFLRTJCXzcyOiAweGIyMDksXG4gIEJMQUtFMkJfODA6IDB4YjIwYSxcbiAgQkxBS0UyQl84ODogMHhiMjBiLFxuICBCTEFLRTJCXzk2OiAweGIyMGMsXG4gIEJMQUtFMkJfMTA0OiAweGIyMGQsXG4gIEJMQUtFMkJfMTEyOiAweGIyMGUsXG4gIEJMQUtFMkJfMTIwOiAweGIyMGYsXG4gIEJMQUtFMkJfMTI4OiAweGIyMTAsXG4gIEJMQUtFMkJfMTM2OiAweGIyMTEsXG4gIEJMQUtFMkJfMTQ0OiAweGIyMTIsXG4gIEJMQUtFMkJfMTUyOiAweGIyMTMsXG4gIEJMQUtFMkJfMTYwOiAweGIyMTQsXG4gIEJMQUtFMkJfMTY4OiAweGIyMTUsXG4gIEJMQUtFMkJfMTc2OiAweGIyMTYsXG4gIEJMQUtFMkJfMTg0OiAweGIyMTcsXG4gIEJMQUtFMkJfMTkyOiAweGIyMTgsXG4gIEJMQUtFMkJfMjAwOiAweGIyMTksXG4gIEJMQUtFMkJfMjA4OiAweGIyMWEsXG4gIEJMQUtFMkJfMjE2OiAweGIyMWIsXG4gIEJMQUtFMkJfMjI0OiAweGIyMWMsXG4gIEJMQUtFMkJfMjMyOiAweGIyMWQsXG4gIEJMQUtFMkJfMjQwOiAweGIyMWUsXG4gIEJMQUtFMkJfMjQ4OiAweGIyMWYsXG4gIEJMQUtFMkJfMjU2OiAweGIyMjAsXG4gIEJMQUtFMkJfMjY0OiAweGIyMjEsXG4gIEJMQUtFMkJfMjcyOiAweGIyMjIsXG4gIEJMQUtFMkJfMjgwOiAweGIyMjMsXG4gIEJMQUtFMkJfMjg4OiAweGIyMjQsXG4gIEJMQUtFMkJfMjk2OiAweGIyMjUsXG4gIEJMQUtFMkJfMzA0OiAweGIyMjYsXG4gIEJMQUtFMkJfMzEyOiAweGIyMjcsXG4gIEJMQUtFMkJfMzIwOiAweGIyMjgsXG4gIEJMQUtFMkJfMzI4OiAweGIyMjksXG4gIEJMQUtFMkJfMzM2OiAweGIyMmEsXG4gIEJMQUtFMkJfMzQ0OiAweGIyMmIsXG4gIEJMQUtFMkJfMzUyOiAweGIyMmMsXG4gIEJMQUtFMkJfMzYwOiAweGIyMmQsXG4gIEJMQUtFMkJfMzY4OiAweGIyMmUsXG4gIEJMQUtFMkJfMzc2OiAweGIyMmYsXG4gIEJMQUtFMkJfMzg0OiAweGIyMzAsXG4gIEJMQUtFMkJfMzkyOiAweGIyMzEsXG4gIEJMQUtFMkJfNDAwOiAweGIyMzIsXG4gIEJMQUtFMkJfNDA4OiAweGIyMzMsXG4gIEJMQUtFMkJfNDE2OiAweGIyMzQsXG4gIEJMQUtFMkJfNDI0OiAweGIyMzUsXG4gIEJMQUtFMkJfNDMyOiAweGIyMzYsXG4gIEJMQUtFMkJfNDQwOiAweGIyMzcsXG4gIEJMQUtFMkJfNDQ4OiAweGIyMzgsXG4gIEJMQUtFMkJfNDU2OiAweGIyMzksXG4gIEJMQUtFMkJfNDY0OiAweGIyM2EsXG4gIEJMQUtFMkJfNDcyOiAweGIyM2IsXG4gIEJMQUtFMkJfNDgwOiAweGIyM2MsXG4gIEJMQUtFMkJfNDg4OiAweGIyM2QsXG4gIEJMQUtFMkJfNDk2OiAweGIyM2UsXG4gIEJMQUtFMkJfNTA0OiAweGIyM2YsXG4gIEJMQUtFMkJfNTEyOiAweGIyNDAsXG4gIEJMQUtFMlNfODogMHhiMjQxLFxuICBCTEFLRTJTXzE2OiAweGIyNDIsXG4gIEJMQUtFMlNfMjQ6IDB4YjI0MyxcbiAgQkxBS0UyU18zMjogMHhiMjQ0LFxuICBCTEFLRTJTXzQwOiAweGIyNDUsXG4gIEJMQUtFMlNfNDg6IDB4YjI0NixcbiAgQkxBS0UyU181NjogMHhiMjQ3LFxuICBCTEFLRTJTXzY0OiAweGIyNDgsXG4gIEJMQUtFMlNfNzI6IDB4YjI0OSxcbiAgQkxBS0UyU184MDogMHhiMjRhLFxuICBCTEFLRTJTXzg4OiAweGIyNGIsXG4gIEJMQUtFMlNfOTY6IDB4YjI0YyxcbiAgQkxBS0UyU18xMDQ6IDB4YjI0ZCxcbiAgQkxBS0UyU18xMTI6IDB4YjI0ZSxcbiAgQkxBS0UyU18xMjA6IDB4YjI0ZixcbiAgQkxBS0UyU18xMjg6IDB4YjI1MCxcbiAgQkxBS0UyU18xMzY6IDB4YjI1MSxcbiAgQkxBS0UyU18xNDQ6IDB4YjI1MixcbiAgQkxBS0UyU18xNTI6IDB4YjI1MyxcbiAgQkxBS0UyU18xNjA6IDB4YjI1NCxcbiAgQkxBS0UyU18xNjg6IDB4YjI1NSxcbiAgQkxBS0UyU18xNzY6IDB4YjI1NixcbiAgQkxBS0UyU18xODQ6IDB4YjI1NyxcbiAgQkxBS0UyU18xOTI6IDB4YjI1OCxcbiAgQkxBS0UyU18yMDA6IDB4YjI1OSxcbiAgQkxBS0UyU18yMDg6IDB4YjI1YSxcbiAgQkxBS0UyU18yMTY6IDB4YjI1YixcbiAgQkxBS0UyU18yMjQ6IDB4YjI1YyxcbiAgQkxBS0UyU18yMzI6IDB4YjI1ZCxcbiAgQkxBS0UyU18yNDA6IDB4YjI1ZSxcbiAgQkxBS0UyU18yNDg6IDB4YjI1ZixcbiAgQkxBS0UyU18yNTY6IDB4YjI2MCxcbiAgU0tFSU4yNTZfODogMHhiMzAxLFxuICBTS0VJTjI1Nl8xNjogMHhiMzAyLFxuICBTS0VJTjI1Nl8yNDogMHhiMzAzLFxuICBTS0VJTjI1Nl8zMjogMHhiMzA0LFxuICBTS0VJTjI1Nl80MDogMHhiMzA1LFxuICBTS0VJTjI1Nl80ODogMHhiMzA2LFxuICBTS0VJTjI1Nl81NjogMHhiMzA3LFxuICBTS0VJTjI1Nl82NDogMHhiMzA4LFxuICBTS0VJTjI1Nl83MjogMHhiMzA5LFxuICBTS0VJTjI1Nl84MDogMHhiMzBhLFxuICBTS0VJTjI1Nl84ODogMHhiMzBiLFxuICBTS0VJTjI1Nl85NjogMHhiMzBjLFxuICBTS0VJTjI1Nl8xMDQ6IDB4YjMwZCxcbiAgU0tFSU4yNTZfMTEyOiAweGIzMGUsXG4gIFNLRUlOMjU2XzEyMDogMHhiMzBmLFxuICBTS0VJTjI1Nl8xMjg6IDB4YjMxMCxcbiAgU0tFSU4yNTZfMTM2OiAweGIzMTEsXG4gIFNLRUlOMjU2XzE0NDogMHhiMzEyLFxuICBTS0VJTjI1Nl8xNTI6IDB4YjMxMyxcbiAgU0tFSU4yNTZfMTYwOiAweGIzMTQsXG4gIFNLRUlOMjU2XzE2ODogMHhiMzE1LFxuICBTS0VJTjI1Nl8xNzY6IDB4YjMxNixcbiAgU0tFSU4yNTZfMTg0OiAweGIzMTcsXG4gIFNLRUlOMjU2XzE5MjogMHhiMzE4LFxuICBTS0VJTjI1Nl8yMDA6IDB4YjMxOSxcbiAgU0tFSU4yNTZfMjA4OiAweGIzMWEsXG4gIFNLRUlOMjU2XzIxNjogMHhiMzFiLFxuICBTS0VJTjI1Nl8yMjQ6IDB4YjMxYyxcbiAgU0tFSU4yNTZfMjMyOiAweGIzMWQsXG4gIFNLRUlOMjU2XzI0MDogMHhiMzFlLFxuICBTS0VJTjI1Nl8yNDg6IDB4YjMxZixcbiAgU0tFSU4yNTZfMjU2OiAweGIzMjAsXG4gIFNLRUlONTEyXzg6IDB4YjMyMSxcbiAgU0tFSU41MTJfMTY6IDB4YjMyMixcbiAgU0tFSU41MTJfMjQ6IDB4YjMyMyxcbiAgU0tFSU41MTJfMzI6IDB4YjMyNCxcbiAgU0tFSU41MTJfNDA6IDB4YjMyNSxcbiAgU0tFSU41MTJfNDg6IDB4YjMyNixcbiAgU0tFSU41MTJfNTY6IDB4YjMyNyxcbiAgU0tFSU41MTJfNjQ6IDB4YjMyOCxcbiAgU0tFSU41MTJfNzI6IDB4YjMyOSxcbiAgU0tFSU41MTJfODA6IDB4YjMyYSxcbiAgU0tFSU41MTJfODg6IDB4YjMyYixcbiAgU0tFSU41MTJfOTY6IDB4YjMyYyxcbiAgU0tFSU41MTJfMTA0OiAweGIzMmQsXG4gIFNLRUlONTEyXzExMjogMHhiMzJlLFxuICBTS0VJTjUxMl8xMjA6IDB4YjMyZixcbiAgU0tFSU41MTJfMTI4OiAweGIzMzAsXG4gIFNLRUlONTEyXzEzNjogMHhiMzMxLFxuICBTS0VJTjUxMl8xNDQ6IDB4YjMzMixcbiAgU0tFSU41MTJfMTUyOiAweGIzMzMsXG4gIFNLRUlONTEyXzE2MDogMHhiMzM0LFxuICBTS0VJTjUxMl8xNjg6IDB4YjMzNSxcbiAgU0tFSU41MTJfMTc2OiAweGIzMzYsXG4gIFNLRUlONTEyXzE4NDogMHhiMzM3LFxuICBTS0VJTjUxMl8xOTI6IDB4YjMzOCxcbiAgU0tFSU41MTJfMjAwOiAweGIzMzksXG4gIFNLRUlONTEyXzIwODogMHhiMzNhLFxuICBTS0VJTjUxMl8yMTY6IDB4YjMzYixcbiAgU0tFSU41MTJfMjI0OiAweGIzM2MsXG4gIFNLRUlONTEyXzIzMjogMHhiMzNkLFxuICBTS0VJTjUxMl8yNDA6IDB4YjMzZSxcbiAgU0tFSU41MTJfMjQ4OiAweGIzM2YsXG4gIFNLRUlONTEyXzI1NjogMHhiMzQwLFxuICBTS0VJTjUxMl8yNjQ6IDB4YjM0MSxcbiAgU0tFSU41MTJfMjcyOiAweGIzNDIsXG4gIFNLRUlONTEyXzI4MDogMHhiMzQzLFxuICBTS0VJTjUxMl8yODg6IDB4YjM0NCxcbiAgU0tFSU41MTJfMjk2OiAweGIzNDUsXG4gIFNLRUlONTEyXzMwNDogMHhiMzQ2LFxuICBTS0VJTjUxMl8zMTI6IDB4YjM0NyxcbiAgU0tFSU41MTJfMzIwOiAweGIzNDgsXG4gIFNLRUlONTEyXzMyODogMHhiMzQ5LFxuICBTS0VJTjUxMl8zMzY6IDB4YjM0YSxcbiAgU0tFSU41MTJfMzQ0OiAweGIzNGIsXG4gIFNLRUlONTEyXzM1MjogMHhiMzRjLFxuICBTS0VJTjUxMl8zNjA6IDB4YjM0ZCxcbiAgU0tFSU41MTJfMzY4OiAweGIzNGUsXG4gIFNLRUlONTEyXzM3NjogMHhiMzRmLFxuICBTS0VJTjUxMl8zODQ6IDB4YjM1MCxcbiAgU0tFSU41MTJfMzkyOiAweGIzNTEsXG4gIFNLRUlONTEyXzQwMDogMHhiMzUyLFxuICBTS0VJTjUxMl80MDg6IDB4YjM1MyxcbiAgU0tFSU41MTJfNDE2OiAweGIzNTQsXG4gIFNLRUlONTEyXzQyNDogMHhiMzU1LFxuICBTS0VJTjUxMl80MzI6IDB4YjM1NixcbiAgU0tFSU41MTJfNDQwOiAweGIzNTcsXG4gIFNLRUlONTEyXzQ0ODogMHhiMzU4LFxuICBTS0VJTjUxMl80NTY6IDB4YjM1OSxcbiAgU0tFSU41MTJfNDY0OiAweGIzNWEsXG4gIFNLRUlONTEyXzQ3MjogMHhiMzViLFxuICBTS0VJTjUxMl80ODA6IDB4YjM1YyxcbiAgU0tFSU41MTJfNDg4OiAweGIzNWQsXG4gIFNLRUlONTEyXzQ5NjogMHhiMzVlLFxuICBTS0VJTjUxMl81MDQ6IDB4YjM1ZixcbiAgU0tFSU41MTJfNTEyOiAweGIzNjAsXG4gIFNLRUlOMTAyNF84OiAweGIzNjEsXG4gIFNLRUlOMTAyNF8xNjogMHhiMzYyLFxuICBTS0VJTjEwMjRfMjQ6IDB4YjM2MyxcbiAgU0tFSU4xMDI0XzMyOiAweGIzNjQsXG4gIFNLRUlOMTAyNF80MDogMHhiMzY1LFxuICBTS0VJTjEwMjRfNDg6IDB4YjM2NixcbiAgU0tFSU4xMDI0XzU2OiAweGIzNjcsXG4gIFNLRUlOMTAyNF82NDogMHhiMzY4LFxuICBTS0VJTjEwMjRfNzI6IDB4YjM2OSxcbiAgU0tFSU4xMDI0XzgwOiAweGIzNmEsXG4gIFNLRUlOMTAyNF84ODogMHhiMzZiLFxuICBTS0VJTjEwMjRfOTY6IDB4YjM2YyxcbiAgU0tFSU4xMDI0XzEwNDogMHhiMzZkLFxuICBTS0VJTjEwMjRfMTEyOiAweGIzNmUsXG4gIFNLRUlOMTAyNF8xMjA6IDB4YjM2ZixcbiAgU0tFSU4xMDI0XzEyODogMHhiMzcwLFxuICBTS0VJTjEwMjRfMTM2OiAweGIzNzEsXG4gIFNLRUlOMTAyNF8xNDQ6IDB4YjM3MixcbiAgU0tFSU4xMDI0XzE1MjogMHhiMzczLFxuICBTS0VJTjEwMjRfMTYwOiAweGIzNzQsXG4gIFNLRUlOMTAyNF8xNjg6IDB4YjM3NSxcbiAgU0tFSU4xMDI0XzE3NjogMHhiMzc2LFxuICBTS0VJTjEwMjRfMTg0OiAweGIzNzcsXG4gIFNLRUlOMTAyNF8xOTI6IDB4YjM3OCxcbiAgU0tFSU4xMDI0XzIwMDogMHhiMzc5LFxuICBTS0VJTjEwMjRfMjA4OiAweGIzN2EsXG4gIFNLRUlOMTAyNF8yMTY6IDB4YjM3YixcbiAgU0tFSU4xMDI0XzIyNDogMHhiMzdjLFxuICBTS0VJTjEwMjRfMjMyOiAweGIzN2QsXG4gIFNLRUlOMTAyNF8yNDA6IDB4YjM3ZSxcbiAgU0tFSU4xMDI0XzI0ODogMHhiMzdmLFxuICBTS0VJTjEwMjRfMjU2OiAweGIzODAsXG4gIFNLRUlOMTAyNF8yNjQ6IDB4YjM4MSxcbiAgU0tFSU4xMDI0XzI3MjogMHhiMzgyLFxuICBTS0VJTjEwMjRfMjgwOiAweGIzODMsXG4gIFNLRUlOMTAyNF8yODg6IDB4YjM4NCxcbiAgU0tFSU4xMDI0XzI5NjogMHhiMzg1LFxuICBTS0VJTjEwMjRfMzA0OiAweGIzODYsXG4gIFNLRUlOMTAyNF8zMTI6IDB4YjM4NyxcbiAgU0tFSU4xMDI0XzMyMDogMHhiMzg4LFxuICBTS0VJTjEwMjRfMzI4OiAweGIzODksXG4gIFNLRUlOMTAyNF8zMzY6IDB4YjM4YSxcbiAgU0tFSU4xMDI0XzM0NDogMHhiMzhiLFxuICBTS0VJTjEwMjRfMzUyOiAweGIzOGMsXG4gIFNLRUlOMTAyNF8zNjA6IDB4YjM4ZCxcbiAgU0tFSU4xMDI0XzM2ODogMHhiMzhlLFxuICBTS0VJTjEwMjRfMzc2OiAweGIzOGYsXG4gIFNLRUlOMTAyNF8zODQ6IDB4YjM5MCxcbiAgU0tFSU4xMDI0XzM5MjogMHhiMzkxLFxuICBTS0VJTjEwMjRfNDAwOiAweGIzOTIsXG4gIFNLRUlOMTAyNF80MDg6IDB4YjM5MyxcbiAgU0tFSU4xMDI0XzQxNjogMHhiMzk0LFxuICBTS0VJTjEwMjRfNDI0OiAweGIzOTUsXG4gIFNLRUlOMTAyNF80MzI6IDB4YjM5NixcbiAgU0tFSU4xMDI0XzQ0MDogMHhiMzk3LFxuICBTS0VJTjEwMjRfNDQ4OiAweGIzOTgsXG4gIFNLRUlOMTAyNF80NTY6IDB4YjM5OSxcbiAgU0tFSU4xMDI0XzQ2NDogMHhiMzlhLFxuICBTS0VJTjEwMjRfNDcyOiAweGIzOWIsXG4gIFNLRUlOMTAyNF80ODA6IDB4YjM5YyxcbiAgU0tFSU4xMDI0XzQ4ODogMHhiMzlkLFxuICBTS0VJTjEwMjRfNDk2OiAweGIzOWUsXG4gIFNLRUlOMTAyNF81MDQ6IDB4YjM5ZixcbiAgU0tFSU4xMDI0XzUxMjogMHhiM2EwLFxuICBTS0VJTjEwMjRfNTIwOiAweGIzYTEsXG4gIFNLRUlOMTAyNF81Mjg6IDB4YjNhMixcbiAgU0tFSU4xMDI0XzUzNjogMHhiM2EzLFxuICBTS0VJTjEwMjRfNTQ0OiAweGIzYTQsXG4gIFNLRUlOMTAyNF81NTI6IDB4YjNhNSxcbiAgU0tFSU4xMDI0XzU2MDogMHhiM2E2LFxuICBTS0VJTjEwMjRfNTY4OiAweGIzYTcsXG4gIFNLRUlOMTAyNF81NzY6IDB4YjNhOCxcbiAgU0tFSU4xMDI0XzU4NDogMHhiM2E5LFxuICBTS0VJTjEwMjRfNTkyOiAweGIzYWEsXG4gIFNLRUlOMTAyNF82MDA6IDB4YjNhYixcbiAgU0tFSU4xMDI0XzYwODogMHhiM2FjLFxuICBTS0VJTjEwMjRfNjE2OiAweGIzYWQsXG4gIFNLRUlOMTAyNF82MjQ6IDB4YjNhZSxcbiAgU0tFSU4xMDI0XzYzMjogMHhiM2FmLFxuICBTS0VJTjEwMjRfNjQwOiAweGIzYjAsXG4gIFNLRUlOMTAyNF82NDg6IDB4YjNiMSxcbiAgU0tFSU4xMDI0XzY1NjogMHhiM2IyLFxuICBTS0VJTjEwMjRfNjY0OiAweGIzYjMsXG4gIFNLRUlOMTAyNF82NzI6IDB4YjNiNCxcbiAgU0tFSU4xMDI0XzY4MDogMHhiM2I1LFxuICBTS0VJTjEwMjRfNjg4OiAweGIzYjYsXG4gIFNLRUlOMTAyNF82OTY6IDB4YjNiNyxcbiAgU0tFSU4xMDI0XzcwNDogMHhiM2I4LFxuICBTS0VJTjEwMjRfNzEyOiAweGIzYjksXG4gIFNLRUlOMTAyNF83MjA6IDB4YjNiYSxcbiAgU0tFSU4xMDI0XzcyODogMHhiM2JiLFxuICBTS0VJTjEwMjRfNzM2OiAweGIzYmMsXG4gIFNLRUlOMTAyNF83NDQ6IDB4YjNiZCxcbiAgU0tFSU4xMDI0Xzc1MjogMHhiM2JlLFxuICBTS0VJTjEwMjRfNzYwOiAweGIzYmYsXG4gIFNLRUlOMTAyNF83Njg6IDB4YjNjMCxcbiAgU0tFSU4xMDI0Xzc3NjogMHhiM2MxLFxuICBTS0VJTjEwMjRfNzg0OiAweGIzYzIsXG4gIFNLRUlOMTAyNF83OTI6IDB4YjNjMyxcbiAgU0tFSU4xMDI0XzgwMDogMHhiM2M0LFxuICBTS0VJTjEwMjRfODA4OiAweGIzYzUsXG4gIFNLRUlOMTAyNF84MTY6IDB4YjNjNixcbiAgU0tFSU4xMDI0XzgyNDogMHhiM2M3LFxuICBTS0VJTjEwMjRfODMyOiAweGIzYzgsXG4gIFNLRUlOMTAyNF84NDA6IDB4YjNjOSxcbiAgU0tFSU4xMDI0Xzg0ODogMHhiM2NhLFxuICBTS0VJTjEwMjRfODU2OiAweGIzY2IsXG4gIFNLRUlOMTAyNF84NjQ6IDB4YjNjYyxcbiAgU0tFSU4xMDI0Xzg3MjogMHhiM2NkLFxuICBTS0VJTjEwMjRfODgwOiAweGIzY2UsXG4gIFNLRUlOMTAyNF84ODg6IDB4YjNjZixcbiAgU0tFSU4xMDI0Xzg5NjogMHhiM2QwLFxuICBTS0VJTjEwMjRfOTA0OiAweGIzZDEsXG4gIFNLRUlOMTAyNF85MTI6IDB4YjNkMixcbiAgU0tFSU4xMDI0XzkyMDogMHhiM2QzLFxuICBTS0VJTjEwMjRfOTI4OiAweGIzZDQsXG4gIFNLRUlOMTAyNF85MzY6IDB4YjNkNSxcbiAgU0tFSU4xMDI0Xzk0NDogMHhiM2Q2LFxuICBTS0VJTjEwMjRfOTUyOiAweGIzZDcsXG4gIFNLRUlOMTAyNF85NjA6IDB4YjNkOCxcbiAgU0tFSU4xMDI0Xzk2ODogMHhiM2Q5LFxuICBTS0VJTjEwMjRfOTc2OiAweGIzZGEsXG4gIFNLRUlOMTAyNF85ODQ6IDB4YjNkYixcbiAgU0tFSU4xMDI0Xzk5MjogMHhiM2RjLFxuICBTS0VJTjEwMjRfMTAwMDogMHhiM2RkLFxuICBTS0VJTjEwMjRfMTAwODogMHhiM2RlLFxuICBTS0VJTjEwMjRfMTAxNjogMHhiM2RmLFxuICBTS0VJTjEwMjRfMTAyNDogMHhiM2UwLFxuXG4gIC8vIG11bHRpYWRkclxuICBJUDQ6IDB4MDQsXG4gIFRDUDogMHgwNixcbiAgRENDUDogMHgyMSxcbiAgSVA2OiAweDI5LFxuICBJUDZaT05FOiAweDJhLFxuICBETlM6IDB4MzUsXG4gIEROUzQ6IDB4MzYsXG4gIEROUzY6IDB4MzcsXG4gIEROU0FERFI6IDB4MzgsXG4gIFNDVFA6IDB4ODQsXG4gIFVEUDogMHgwMTExLFxuICBQMlBfV0VCUlRDX1NUQVI6IDB4MDExMyxcbiAgUDJQX1dFQlJUQ19ESVJFQ1Q6IDB4MDExNCxcbiAgUDJQX1NUQVJEVVNUOiAweDAxMTUsXG4gIFAyUF9DSVJDVUlUOiAweDAxMjIsXG4gIFVEVDogMHgwMTJkLFxuICBVVFA6IDB4MDEyZSxcbiAgVU5JWDogMHgwMTkwLFxuICBQMlA6IDB4MDFhNSxcbiAgSVBGUzogMHgwMWE1LFxuICBIVFRQUzogMHgwMWJiLFxuICBPTklPTjogMHgwMWJjLFxuICBPTklPTjM6IDB4MDFiZCxcbiAgR0FSTElDNjQ6IDB4MDFiZSxcbiAgR0FSTElDMzI6IDB4MDFiZixcbiAgUVVJQzogMHgwMWNjLFxuICBXUzogMHgwMWRkLFxuICBXU1M6IDB4MDFkZSxcbiAgUDJQX1dFQlNPQ0tFVF9TVEFSOiAweDAxZGYsXG4gIEhUVFA6IDB4MDFlMCxcblxuICAvLyBpcGxkXG4gIFJBVzogMHg1NSxcbiAgREFHX1BCOiAweDcwLFxuICBEQUdfQ0JPUjogMHg3MSxcbiAgTElCUDJQX0tFWTogMHg3MixcbiAgR0lUX1JBVzogMHg3OCxcbiAgVE9SUkVOVF9JTkZPOiAweDdiLFxuICBUT1JSRU5UX0ZJTEU6IDB4N2MsXG4gIExFT0ZDT0lOX0JMT0NLOiAweDgxLFxuICBMRU9GQ09JTl9UWDogMHg4MixcbiAgTEVPRkNPSU5fUFI6IDB4ODMsXG4gIEVUSF9CTE9DSzogMHg5MCxcbiAgRVRIX0JMT0NLX0xJU1Q6IDB4OTEsXG4gIEVUSF9UWF9UUklFOiAweDkyLFxuICBFVEhfVFg6IDB4OTMsXG4gIEVUSF9UWF9SRUNFSVBUX1RSSUU6IDB4OTQsXG4gIEVUSF9UWF9SRUNFSVBUOiAweDk1LFxuICBFVEhfU1RBVEVfVFJJRTogMHg5NixcbiAgRVRIX0FDQ09VTlRfU05BUFNIT1Q6IDB4OTcsXG4gIEVUSF9TVE9SQUdFX1RSSUU6IDB4OTgsXG4gIEJJVENPSU5fQkxPQ0s6IDB4YjAsXG4gIEJJVENPSU5fVFg6IDB4YjEsXG4gIFpDQVNIX0JMT0NLOiAweGMwLFxuICBaQ0FTSF9UWDogMHhjMSxcbiAgU1RFTExBUl9CTE9DSzogMHhkMCxcbiAgU1RFTExBUl9UWDogMHhkMSxcbiAgREVDUkVEX0JMT0NLOiAweGUwLFxuICBERUNSRURfVFg6IDB4ZTEsXG4gIERBU0hfQkxPQ0s6IDB4ZjAsXG4gIERBU0hfVFg6IDB4ZjEsXG4gIFNXQVJNX01BTklGRVNUOiAweGZhLFxuICBTV0FSTV9GRUVEOiAweGZiLFxuICBEQUdfSlNPTjogMHgwMTI5LFxuXG4gIC8vIG5hbWVzcGFjZVxuICBQQVRIOiAweDJmLFxuICBJUExEX05TOiAweGUyLFxuICBJUEZTX05TOiAweGUzLFxuICBTV0FSTV9OUzogMHhlNCxcbiAgSVBOU19OUzogMHhlNSxcbiAgWkVST05FVDogMHhlNixcblxuICAvLyBrZXlcbiAgRUQyNTUxOV9QVUI6IDB4ZWQsXG5cbiAgLy8gaG9sb2NoYWluXG4gIEhPTE9DSEFJTl9BRFJfVjA6IDB4ODA3MTI0LFxuICBIT0xPQ0hBSU5fQURSX1YxOiAweDgxNzEyNCxcbiAgSE9MT0NIQUlOX0tFWV9WMDogMHg5NDcxMjQsXG4gIEhPTE9DSEFJTl9LRVlfVjE6IDB4OTU3MTI0LFxuICBIT0xPQ0hBSU5fU0lHX1YwOiAweGEyNzEyNCxcbiAgSE9MT0NIQUlOX1NJR19WMTogMHhhMzcxMjRcbn0pXG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGJhc2VUYWJsZSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5jb25zdCB2YXJpbnRCdWZmZXJFbmNvZGUgPSByZXF1aXJlKCcuL3V0aWwnKS52YXJpbnRCdWZmZXJFbmNvZGVcblxuLy8gdGhpcyBjcmVhdGVzIGEgbWFwIGZvciBjb2RlY05hbWUgLT4gY29kZVZhcmludEJ1ZmZlclxuXG5jb25zdCB2YXJpbnRUYWJsZSA9IHt9XG5tb2R1bGUuZXhwb3J0cyA9IHZhcmludFRhYmxlXG5cbmZvciAobGV0IGVuY29kaW5nTmFtZSBpbiBiYXNlVGFibGUpIHtcbiAgbGV0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICB2YXJpbnRUYWJsZVtlbmNvZGluZ05hbWVdID0gdmFyaW50QnVmZmVyRW5jb2RlKGNvZGUpXG59XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IGJhc2VUYWJsZSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbi8vIHRoaXMgY3JlYXRlcyBhIG1hcCBmb3IgY29kZSBhcyBoZXhTdHJpbmcgLT4gY29kZWNOYW1lXG5cbmNvbnN0IG5hbWVUYWJsZSA9IHt9XG5tb2R1bGUuZXhwb3J0cyA9IG5hbWVUYWJsZVxuXG5mb3IgKGxldCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGxldCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgbmFtZVRhYmxlW2NvZGUudG9TdHJpbmcoJ2hleCcpXSA9IGVuY29kaW5nTmFtZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9CdWZmZXIsXG4gIGJ1ZmZlclRvTnVtYmVyLFxuICB2YXJpbnRCdWZmZXJFbmNvZGUsXG4gIHZhcmludEJ1ZmZlckRlY29kZVxufVxuXG5mdW5jdGlvbiBidWZmZXJUb051bWJlciAoYnVmKSB7XG4gIHJldHVybiBwYXJzZUludChidWYudG9TdHJpbmcoJ2hleCcpLCAxNilcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9CdWZmZXIgKG51bSkge1xuICBsZXQgaGV4U3RyaW5nID0gbnVtLnRvU3RyaW5nKDE2KVxuICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICBoZXhTdHJpbmcgPSAnMCcgKyBoZXhTdHJpbmdcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGV4U3RyaW5nLCAnaGV4Jylcbn1cblxuZnVuY3Rpb24gdmFyaW50QnVmZmVyRW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShidWZmZXJUb051bWJlcihpbnB1dCkpKVxufVxuXG5mdW5jdGlvbiB2YXJpbnRCdWZmZXJEZWNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBudW1iZXJUb0J1ZmZlcih2YXJpbnQuZGVjb2RlKGlucHV0KSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gd2l0aElzKENsYXNzLCB7IGNsYXNzTmFtZSwgc3ltYm9sTmFtZSB9KSB7XG4gICAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihzeW1ib2xOYW1lKTtcblxuICAgIGNvbnN0IENsYXNzSXNXcmFwcGVyID0ge1xuICAgICAgICAvLyBUaGUgY29kZSBiZWxvdyBhc3NpZ25zIHRoZSBjbGFzcyB3cmFwcGVyIHRvIGFuIG9iamVjdCB0byB0cmlja1xuICAgICAgICAvLyBKYXZhU2NyaXB0IGVuZ2luZXMgdG8gc2hvdyB0aGUgbmFtZSBvZiB0aGUgZXh0ZW5kZWQgY2xhc3Mgd2hlblxuICAgICAgICAvLyBsb2dnaW5nIGFuIGluc3RhbmNlcy5cbiAgICAgICAgLy8gV2UgYXJlIGFzc2lnbmluZyBhbiBhbm9ueW1vdXMgY2xhc3MgKGNsYXNzIHdyYXBwZXIpIHRvIHRoZSBvYmplY3RcbiAgICAgICAgLy8gd2l0aCBrZXkgYGNsYXNzTmFtZWAgdG8ga2VlcCB0aGUgY29ycmVjdCBuYW1lLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgaXQgZmFsbHMgYmFjayB0byBsb2dnaW5nIGBDbGFzc0lzV3JhcHBlcmAuXG4gICAgICAgIFtjbGFzc05hbWVdOiBjbGFzcyBleHRlbmRzIENsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9W2NsYXNzTmFtZV07XG5cbiAgICBDbGFzc0lzV3JhcHBlcltgaXMke2NsYXNzTmFtZX1gXSA9IChvYmopID0+ICEhKG9iaiAmJiBvYmpbc3ltYm9sXSk7XG5cbiAgICByZXR1cm4gQ2xhc3NJc1dyYXBwZXI7XG59XG5cbmZ1bmN0aW9uIHdpdGhJc1Byb3RvKENsYXNzLCB7IGNsYXNzTmFtZSwgc3ltYm9sTmFtZSwgd2l0aG91dE5ldyB9KSB7XG4gICAgY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihzeW1ib2xOYW1lKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgICBjb25zdCBDbGFzc0lzV3JhcHBlciA9IHtcbiAgICAgICAgW2NsYXNzTmFtZV06IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAod2l0aG91dE5ldyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBDbGFzc0lzV3JhcHBlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzSXNXcmFwcGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IENsYXNzLmNhbGwodGhpcywgLi4uYXJncykgfHwgdGhpcztcblxuICAgICAgICAgICAgaWYgKF90aGlzICYmICFfdGhpc1tzeW1ib2xdKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSxcbiAgICB9W2NsYXNzTmFtZV07XG4gICAgLyogZXNsaW50LWVuYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG5cbiAgICBDbGFzc0lzV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSk7XG4gICAgQ2xhc3NJc1dyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3NJc1dyYXBwZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3NJc1dyYXBwZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIENsYXNzSXNXcmFwcGVyW2BpcyR7Y2xhc3NOYW1lfWBdID0gKG9iaikgPT4gISEob2JqICYmIG9ialtzeW1ib2xdKTtcblxuICAgIHJldHVybiBDbGFzc0lzV3JhcHBlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXM7XG5tb2R1bGUuZXhwb3J0cy5wcm90byA9IHdpdGhJc1Byb3RvO1xuIiwiLy8gVEhJUyBGSUxFIElTIEdFTkVSQVRFRCwgRE8gTk8gRURJVCBNQU5VQUxMWVxuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHRoZSBSRUFETUUubWRcbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8vIHNlcmlhbGl6YXRpb25cbmV4cG9ydHNbJ3Byb3RvYnVmJ10gPSBCdWZmZXIuZnJvbSgnNTAnLCAnaGV4JylcbmV4cG9ydHNbJ2Nib3InXSA9IEJ1ZmZlci5mcm9tKCc1MScsICdoZXgnKVxuZXhwb3J0c1sncmxwJ10gPSBCdWZmZXIuZnJvbSgnNjAnLCAnaGV4JylcbmV4cG9ydHNbJ2JlbmNvZGUnXSA9IEJ1ZmZlci5mcm9tKCc2MycsICdoZXgnKVxuZXhwb3J0c1snanNvbiddID0gQnVmZmVyLmZyb20oJzAyMDAnLCAnaGV4JylcbmV4cG9ydHNbJ21lc3NhZ2VwYWNrJ10gPSBCdWZmZXIuZnJvbSgnMDIwMScsICdoZXgnKVxuXG4vLyBtdWx0aWZvcm1hdFxuZXhwb3J0c1snbXVsdGljb2RlYyddID0gQnVmZmVyLmZyb20oJzMwJywgJ2hleCcpXG5leHBvcnRzWydtdWx0aWhhc2gnXSA9IEJ1ZmZlci5mcm9tKCczMScsICdoZXgnKVxuZXhwb3J0c1snbXVsdGlhZGRyJ10gPSBCdWZmZXIuZnJvbSgnMzInLCAnaGV4JylcbmV4cG9ydHNbJ211bHRpYmFzZSddID0gQnVmZmVyLmZyb20oJzMzJywgJ2hleCcpXG5cbi8vIG11bHRpaGFzaFxuZXhwb3J0c1snaWRlbnRpdHknXSA9IEJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKVxuZXhwb3J0c1snc2hhMSddID0gQnVmZmVyLmZyb20oJzExJywgJ2hleCcpXG5leHBvcnRzWydzaGEyLTI1NiddID0gQnVmZmVyLmZyb20oJzEyJywgJ2hleCcpXG5leHBvcnRzWydzaGEyLTUxMiddID0gQnVmZmVyLmZyb20oJzEzJywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTUxMiddID0gQnVmZmVyLmZyb20oJzE0JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTM4NCddID0gQnVmZmVyLmZyb20oJzE1JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTI1NiddID0gQnVmZmVyLmZyb20oJzE2JywgJ2hleCcpXG5leHBvcnRzWydzaGEzLTIyNCddID0gQnVmZmVyLmZyb20oJzE3JywgJ2hleCcpXG5leHBvcnRzWydzaGFrZS0xMjgnXSA9IEJ1ZmZlci5mcm9tKCcxOCcsICdoZXgnKVxuZXhwb3J0c1snc2hha2UtMjU2J10gPSBCdWZmZXIuZnJvbSgnMTknLCAnaGV4JylcbmV4cG9ydHNbJ2tlY2Nhay0yMjQnXSA9IEJ1ZmZlci5mcm9tKCcxYScsICdoZXgnKVxuZXhwb3J0c1sna2VjY2FrLTI1NiddID0gQnVmZmVyLmZyb20oJzFiJywgJ2hleCcpXG5leHBvcnRzWydrZWNjYWstMzg0J10gPSBCdWZmZXIuZnJvbSgnMWMnLCAnaGV4JylcbmV4cG9ydHNbJ2tlY2Nhay01MTInXSA9IEJ1ZmZlci5mcm9tKCcxZCcsICdoZXgnKVxuZXhwb3J0c1snbXVybXVyMy0xMjgnXSA9IEJ1ZmZlci5mcm9tKCcyMicsICdoZXgnKVxuZXhwb3J0c1snbXVybXVyMy0zMiddID0gQnVmZmVyLmZyb20oJzIzJywgJ2hleCcpXG5leHBvcnRzWydkYmwtc2hhMi0yNTYnXSA9IEJ1ZmZlci5mcm9tKCc1NicsICdoZXgnKVxuZXhwb3J0c1snbWQ0J10gPSBCdWZmZXIuZnJvbSgnZDQnLCAnaGV4JylcbmV4cG9ydHNbJ21kNSddID0gQnVmZmVyLmZyb20oJ2Q1JywgJ2hleCcpXG5leHBvcnRzWydibXQnXSA9IEJ1ZmZlci5mcm9tKCdkNicsICdoZXgnKVxuZXhwb3J0c1sneDExJ10gPSBCdWZmZXIuZnJvbSgnMTEwMCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi04J10gPSBCdWZmZXIuZnJvbSgnYjIwMScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNiddID0gQnVmZmVyLmZyb20oJ2IyMDInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjAzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTMyJ10gPSBCdWZmZXIuZnJvbSgnYjIwNCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MCddID0gQnVmZmVyLmZyb20oJ2IyMDUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjA2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTU2J10gPSBCdWZmZXIuZnJvbSgnYjIwNycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi02NCddID0gQnVmZmVyLmZyb20oJ2IyMDgnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNzInXSA9IEJ1ZmZlci5mcm9tKCdiMjA5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTgwJ10gPSBCdWZmZXIuZnJvbSgnYjIwYScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi04OCddID0gQnVmZmVyLmZyb20oJ2IyMGInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjBjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTEwNCddID0gQnVmZmVyLmZyb20oJ2IyMGQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjIwZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMjBmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTEyOCddID0gQnVmZmVyLmZyb20oJ2IyMTAnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTM2J10gPSBCdWZmZXIuZnJvbSgnYjIxMScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjEyJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTE1MiddID0gQnVmZmVyLmZyb20oJ2IyMTMnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjIxNCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMjE1JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTE3NiddID0gQnVmZmVyLmZyb20oJ2IyMTYnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMTg0J10gPSBCdWZmZXIuZnJvbSgnYjIxNycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0xOTInXSA9IEJ1ZmZlci5mcm9tKCdiMjE4JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTIwMCddID0gQnVmZmVyLmZyb20oJ2IyMTknLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjA4J10gPSBCdWZmZXIuZnJvbSgnYjIxYScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjFiJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTIyNCddID0gQnVmZmVyLmZyb20oJ2IyMWMnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjIxZCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjFlJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI0OCddID0gQnVmZmVyLmZyb20oJ2IyMWYnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjU2J10gPSBCdWZmZXIuZnJvbSgnYjIyMCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjIxJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI3MiddID0gQnVmZmVyLmZyb20oJ2IyMjInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMjgwJ10gPSBCdWZmZXIuZnJvbSgnYjIyMycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0yODgnXSA9IEJ1ZmZlci5mcm9tKCdiMjI0JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTI5NiddID0gQnVmZmVyLmZyb20oJ2IyMjUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzA0J10gPSBCdWZmZXIuZnJvbSgnYjIyNicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zMTInXSA9IEJ1ZmZlci5mcm9tKCdiMjI3JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTMyMCddID0gQnVmZmVyLmZyb20oJ2IyMjgnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzI4J10gPSBCdWZmZXIuZnJvbSgnYjIyOScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMjJhJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM0NCddID0gQnVmZmVyLmZyb20oJ2IyMmInLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzUyJ10gPSBCdWZmZXIuZnJvbSgnYjIyYycsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMjJkJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM2OCddID0gQnVmZmVyLmZyb20oJ2IyMmUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItMzc2J10gPSBCdWZmZXIuZnJvbSgnYjIyZicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi0zODQnXSA9IEJ1ZmZlci5mcm9tKCdiMjMwJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTM5MiddID0gQnVmZmVyLmZyb20oJ2IyMzEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDAwJ10gPSBCdWZmZXIuZnJvbSgnYjIzMicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjMzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQxNiddID0gQnVmZmVyLmZyb20oJ2IyMzQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDI0J10gPSBCdWZmZXIuZnJvbSgnYjIzNScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00MzInXSA9IEJ1ZmZlci5mcm9tKCdiMjM2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ0MCddID0gQnVmZmVyLmZyb20oJ2IyMzcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDQ4J10gPSBCdWZmZXIuZnJvbSgnYjIzOCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00NTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjM5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ2NCddID0gQnVmZmVyLmZyb20oJ2IyM2EnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDcyJ10gPSBCdWZmZXIuZnJvbSgnYjIzYicsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi00ODAnXSA9IEJ1ZmZlci5mcm9tKCdiMjNjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTQ4OCddID0gQnVmZmVyLmZyb20oJ2IyM2QnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMmItNDk2J10gPSBCdWZmZXIuZnJvbSgnYjIzZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2UyYi01MDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjNmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJiLTUxMiddID0gQnVmZmVyLmZyb20oJ2IyNDAnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtOCddID0gQnVmZmVyLmZyb20oJ2IyNDEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMjQyJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTI0J10gPSBCdWZmZXIuZnJvbSgnYjI0MycsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0zMiddID0gQnVmZmVyLmZyb20oJ2IyNDQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjQ1JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTQ4J10gPSBCdWZmZXIuZnJvbSgnYjI0NicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy01NiddID0gQnVmZmVyLmZyb20oJ2IyNDcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjQ4JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTcyJ10gPSBCdWZmZXIuZnJvbSgnYjI0OScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy04MCddID0gQnVmZmVyLmZyb20oJ2IyNGEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtODgnXSA9IEJ1ZmZlci5mcm9tKCdiMjRiJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTk2J10gPSBCdWZmZXIuZnJvbSgnYjI0YycsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMjRkJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTExMiddID0gQnVmZmVyLmZyb20oJ2IyNGUnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTIwJ10gPSBCdWZmZXIuZnJvbSgnYjI0ZicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMjUwJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTEzNiddID0gQnVmZmVyLmZyb20oJ2IyNTEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTQ0J10gPSBCdWZmZXIuZnJvbSgnYjI1MicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMjUzJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTE2MCddID0gQnVmZmVyLmZyb20oJ2IyNTQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTY4J10gPSBCdWZmZXIuZnJvbSgnYjI1NScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMjU2JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTE4NCddID0gQnVmZmVyLmZyb20oJ2IyNTcnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMTkyJ10gPSBCdWZmZXIuZnJvbSgnYjI1OCcsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMjU5JywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTIwOCddID0gQnVmZmVyLmZyb20oJ2IyNWEnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMjE2J10gPSBCdWZmZXIuZnJvbSgnYjI1YicsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMjVjJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTIzMiddID0gQnVmZmVyLmZyb20oJ2IyNWQnLCAnaGV4JylcbmV4cG9ydHNbJ2JsYWtlMnMtMjQwJ10gPSBCdWZmZXIuZnJvbSgnYjI1ZScsICdoZXgnKVxuZXhwb3J0c1snYmxha2Uycy0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMjVmJywgJ2hleCcpXG5leHBvcnRzWydibGFrZTJzLTI1NiddID0gQnVmZmVyLmZyb20oJ2IyNjAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTgnXSA9IEJ1ZmZlci5mcm9tKCdiMzAxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni0xNiddID0gQnVmZmVyLmZyb20oJ2IzMDInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTI0J10gPSBCdWZmZXIuZnJvbSgnYjMwMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMzInXSA9IEJ1ZmZlci5mcm9tKCdiMzA0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni00MCddID0gQnVmZmVyLmZyb20oJ2IzMDUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTQ4J10gPSBCdWZmZXIuZnJvbSgnYjMwNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtNTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzA3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni02NCddID0gQnVmZmVyLmZyb20oJ2IzMDgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTcyJ10gPSBCdWZmZXIuZnJvbSgnYjMwOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzBhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjI1Ni04OCddID0gQnVmZmVyLmZyb20oJ2IzMGInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMjU2LTk2J10gPSBCdWZmZXIuZnJvbSgnYjMwYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTA0J10gPSBCdWZmZXIuZnJvbSgnYjMwZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjMwZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTIwJ10gPSBCdWZmZXIuZnJvbSgnYjMwZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTI4J10gPSBCdWZmZXIuZnJvbSgnYjMxMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTM2J10gPSBCdWZmZXIuZnJvbSgnYjMxMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTQ0J10gPSBCdWZmZXIuZnJvbSgnYjMxMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTUyJ10gPSBCdWZmZXIuZnJvbSgnYjMxMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjMxNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTY4J10gPSBCdWZmZXIuZnJvbSgnYjMxNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTc2J10gPSBCdWZmZXIuZnJvbSgnYjMxNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTg0J10gPSBCdWZmZXIuZnJvbSgnYjMxNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMTkyJ10gPSBCdWZmZXIuZnJvbSgnYjMxOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjAwJ10gPSBCdWZmZXIuZnJvbSgnYjMxOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjA4J10gPSBCdWZmZXIuZnJvbSgnYjMxYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjE2J10gPSBCdWZmZXIuZnJvbSgnYjMxYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjI0J10gPSBCdWZmZXIuZnJvbSgnYjMxYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjMxZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjQwJ10gPSBCdWZmZXIuZnJvbSgnYjMxZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjQ4J10gPSBCdWZmZXIuZnJvbSgnYjMxZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4yNTYtMjU2J10gPSBCdWZmZXIuZnJvbSgnYjMyMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItOCddID0gQnVmZmVyLmZyb20oJ2IzMjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTE2J10gPSBCdWZmZXIuZnJvbSgnYjMyMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzIzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMiddID0gQnVmZmVyLmZyb20oJ2IzMjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTQwJ10gPSBCdWZmZXIuZnJvbSgnYjMyNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzI2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01NiddID0gQnVmZmVyLmZyb20oJ2IzMjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTY0J10gPSBCdWZmZXIuZnJvbSgnYjMyOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzI5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi04MCddID0gQnVmZmVyLmZyb20oJ2IzMmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluNTEyLTg4J10gPSBCdWZmZXIuZnJvbSgnYjMyYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW41MTItOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzJjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzJkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMTInXSA9IEJ1ZmZlci5mcm9tKCdiMzJlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzJmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzMwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzMxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzMyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzMzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzM0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzM1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzM2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xODQnXSA9IEJ1ZmZlci5mcm9tKCdiMzM3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0xOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzM4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzM5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzNhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzNiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzNjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yMzInXSA9IEJ1ZmZlci5mcm9tKCdiMzNkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzNlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzNmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzQwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzQxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzQyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzQzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0yOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMTInXSA9IEJ1ZmZlci5mcm9tKCdiMzQ3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzQ5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zMzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzRhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzRiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzRjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzRkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzRlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzRmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zODQnXSA9IEJ1ZmZlci5mcm9tKCdiMzUwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi0zOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzUxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzUyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzUzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzU0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzU1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00MzInXSA9IEJ1ZmZlci5mcm9tKCdiMzU2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzU3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzU4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzU5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzVhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00NzInXSA9IEJ1ZmZlci5mcm9tKCdiMzViJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00ODAnXSA9IEJ1ZmZlci5mcm9tKCdiMzVjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00ODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzVkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi00OTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzVlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01MDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzVmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjUxMi01MTInXSA9IEJ1ZmZlci5mcm9tKCdiMzYwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOCddID0gQnVmZmVyLmZyb20oJ2IzNjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNiddID0gQnVmZmVyLmZyb20oJ2IzNjInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNCddID0gQnVmZmVyLmZyb20oJ2IzNjMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zMiddID0gQnVmZmVyLmZyb20oJ2IzNjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00MCddID0gQnVmZmVyLmZyb20oJ2IzNjUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00OCddID0gQnVmZmVyLmZyb20oJ2IzNjYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01NiddID0gQnVmZmVyLmZyb20oJ2IzNjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02NCddID0gQnVmZmVyLmZyb20oJ2IzNjgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MiddID0gQnVmZmVyLmZyb20oJ2IzNjknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MCddID0gQnVmZmVyLmZyb20oJ2IzNmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04OCddID0gQnVmZmVyLmZyb20oJ2IzNmInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NiddID0gQnVmZmVyLmZyb20oJ2IzNmMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzZkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTEyJ10gPSBCdWZmZXIuZnJvbSgnYjM2ZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTEyMCddID0gQnVmZmVyLmZyb20oJ2IzNmYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzcwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTM2J10gPSBCdWZmZXIuZnJvbSgnYjM3MScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE0NCddID0gQnVmZmVyLmZyb20oJ2IzNzInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNTInXSA9IEJ1ZmZlci5mcm9tKCdiMzczJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTYwJ10gPSBCdWZmZXIuZnJvbSgnYjM3NCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE2OCddID0gQnVmZmVyLmZyb20oJ2IzNzUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xNzYnXSA9IEJ1ZmZlci5mcm9tKCdiMzc2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTg0J10gPSBCdWZmZXIuZnJvbSgnYjM3NycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTE5MiddID0gQnVmZmVyLmZyb20oJ2IzNzgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yMDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzc5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjA4J10gPSBCdWZmZXIuZnJvbSgnYjM3YScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTIxNiddID0gQnVmZmVyLmZyb20oJ2IzN2InLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yMjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzdjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjMyJ10gPSBCdWZmZXIuZnJvbSgnYjM3ZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI0MCddID0gQnVmZmVyLmZyb20oJ2IzN2UnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNDgnXSA9IEJ1ZmZlci5mcm9tKCdiMzdmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjU2J10gPSBCdWZmZXIuZnJvbSgnYjM4MCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI2NCddID0gQnVmZmVyLmZyb20oJ2IzODEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yNzInXSA9IEJ1ZmZlci5mcm9tKCdiMzgyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMjgwJ10gPSBCdWZmZXIuZnJvbSgnYjM4MycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTI4OCddID0gQnVmZmVyLmZyb20oJ2IzODQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0yOTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzg1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzA0J10gPSBCdWZmZXIuZnJvbSgnYjM4NicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTMxMiddID0gQnVmZmVyLmZyb20oJ2IzODcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zMjAnXSA9IEJ1ZmZlci5mcm9tKCdiMzg4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzI4J10gPSBCdWZmZXIuZnJvbSgnYjM4OScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTMzNiddID0gQnVmZmVyLmZyb20oJ2IzOGEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zNDQnXSA9IEJ1ZmZlci5mcm9tKCdiMzhiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzUyJ10gPSBCdWZmZXIuZnJvbSgnYjM4YycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTM2MCddID0gQnVmZmVyLmZyb20oJ2IzOGQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zNjgnXSA9IEJ1ZmZlci5mcm9tKCdiMzhlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMzc2J10gPSBCdWZmZXIuZnJvbSgnYjM4ZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTM4NCddID0gQnVmZmVyLmZyb20oJ2IzOTAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0zOTInXSA9IEJ1ZmZlci5mcm9tKCdiMzkxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDAwJ10gPSBCdWZmZXIuZnJvbSgnYjM5MicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQwOCddID0gQnVmZmVyLmZyb20oJ2IzOTMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00MTYnXSA9IEJ1ZmZlci5mcm9tKCdiMzk0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDI0J10gPSBCdWZmZXIuZnJvbSgnYjM5NScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQzMiddID0gQnVmZmVyLmZyb20oJ2IzOTYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00NDAnXSA9IEJ1ZmZlci5mcm9tKCdiMzk3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDQ4J10gPSBCdWZmZXIuZnJvbSgnYjM5OCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQ1NiddID0gQnVmZmVyLmZyb20oJ2IzOTknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00NjQnXSA9IEJ1ZmZlci5mcm9tKCdiMzlhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDcyJ10gPSBCdWZmZXIuZnJvbSgnYjM5YicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTQ4MCddID0gQnVmZmVyLmZyb20oJ2IzOWMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC00ODgnXSA9IEJ1ZmZlci5mcm9tKCdiMzlkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNDk2J10gPSBCdWZmZXIuZnJvbSgnYjM5ZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTUwNCddID0gQnVmZmVyLmZyb20oJ2IzOWYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01MTInXSA9IEJ1ZmZlci5mcm9tKCdiM2EwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTIwJ10gPSBCdWZmZXIuZnJvbSgnYjNhMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTUyOCddID0gQnVmZmVyLmZyb20oJ2IzYTInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01MzYnXSA9IEJ1ZmZlci5mcm9tKCdiM2EzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTQ0J10gPSBCdWZmZXIuZnJvbSgnYjNhNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTU1MiddID0gQnVmZmVyLmZyb20oJ2IzYTUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01NjAnXSA9IEJ1ZmZlci5mcm9tKCdiM2E2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTY4J10gPSBCdWZmZXIuZnJvbSgnYjNhNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTU3NiddID0gQnVmZmVyLmZyb20oJ2IzYTgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC01ODQnXSA9IEJ1ZmZlci5mcm9tKCdiM2E5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNTkyJ10gPSBCdWZmZXIuZnJvbSgnYjNhYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTYwMCddID0gQnVmZmVyLmZyb20oJ2IzYWInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02MDgnXSA9IEJ1ZmZlci5mcm9tKCdiM2FjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjE2J10gPSBCdWZmZXIuZnJvbSgnYjNhZCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTYyNCddID0gQnVmZmVyLmZyb20oJ2IzYWUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02MzInXSA9IEJ1ZmZlci5mcm9tKCdiM2FmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjQwJ10gPSBCdWZmZXIuZnJvbSgnYjNiMCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY0OCddID0gQnVmZmVyLmZyb20oJ2IzYjEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02NTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2IyJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjY0J10gPSBCdWZmZXIuZnJvbSgnYjNiMycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY3MiddID0gQnVmZmVyLmZyb20oJ2IzYjQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC02ODAnXSA9IEJ1ZmZlci5mcm9tKCdiM2I1JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNjg4J10gPSBCdWZmZXIuZnJvbSgnYjNiNicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTY5NiddID0gQnVmZmVyLmZyb20oJ2IzYjcnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MDQnXSA9IEJ1ZmZlci5mcm9tKCdiM2I4JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzEyJ10gPSBCdWZmZXIuZnJvbSgnYjNiOScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTcyMCddID0gQnVmZmVyLmZyb20oJ2IzYmEnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03MjgnXSA9IEJ1ZmZlci5mcm9tKCdiM2JiJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzM2J10gPSBCdWZmZXIuZnJvbSgnYjNiYycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc0NCddID0gQnVmZmVyLmZyb20oJ2IzYmQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03NTInXSA9IEJ1ZmZlci5mcm9tKCdiM2JlJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzYwJ10gPSBCdWZmZXIuZnJvbSgnYjNiZicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc2OCddID0gQnVmZmVyLmZyb20oJ2IzYzAnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC03NzYnXSA9IEJ1ZmZlci5mcm9tKCdiM2MxJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtNzg0J10gPSBCdWZmZXIuZnJvbSgnYjNjMicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTc5MiddID0gQnVmZmVyLmZyb20oJ2IzYzMnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MDAnXSA9IEJ1ZmZlci5mcm9tKCdiM2M0JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODA4J10gPSBCdWZmZXIuZnJvbSgnYjNjNScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTgxNiddID0gQnVmZmVyLmZyb20oJ2IzYzYnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04MjQnXSA9IEJ1ZmZlci5mcm9tKCdiM2M3JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODMyJ10gPSBCdWZmZXIuZnJvbSgnYjNjOCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg0MCddID0gQnVmZmVyLmZyb20oJ2IzYzknLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04NDgnXSA9IEJ1ZmZlci5mcm9tKCdiM2NhJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODU2J10gPSBCdWZmZXIuZnJvbSgnYjNjYicsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg2NCddID0gQnVmZmVyLmZyb20oJ2IzY2MnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04NzInXSA9IEJ1ZmZlci5mcm9tKCdiM2NkJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtODgwJ10gPSBCdWZmZXIuZnJvbSgnYjNjZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTg4OCddID0gQnVmZmVyLmZyb20oJ2IzY2YnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC04OTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2QwJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTA0J10gPSBCdWZmZXIuZnJvbSgnYjNkMScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTkxMiddID0gQnVmZmVyLmZyb20oJ2IzZDInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05MjAnXSA9IEJ1ZmZlci5mcm9tKCdiM2QzJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTI4J10gPSBCdWZmZXIuZnJvbSgnYjNkNCcsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTkzNiddID0gQnVmZmVyLmZyb20oJ2IzZDUnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NDQnXSA9IEJ1ZmZlci5mcm9tKCdiM2Q2JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTUyJ10gPSBCdWZmZXIuZnJvbSgnYjNkNycsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTk2MCddID0gQnVmZmVyLmZyb20oJ2IzZDgnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05NjgnXSA9IEJ1ZmZlci5mcm9tKCdiM2Q5JywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtOTc2J10gPSBCdWZmZXIuZnJvbSgnYjNkYScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTk4NCddID0gQnVmZmVyLmZyb20oJ2IzZGInLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC05OTInXSA9IEJ1ZmZlci5mcm9tKCdiM2RjJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTAwMCddID0gQnVmZmVyLmZyb20oJ2IzZGQnLCAnaGV4JylcbmV4cG9ydHNbJ3NrZWluMTAyNC0xMDA4J10gPSBCdWZmZXIuZnJvbSgnYjNkZScsICdoZXgnKVxuZXhwb3J0c1snc2tlaW4xMDI0LTEwMTYnXSA9IEJ1ZmZlci5mcm9tKCdiM2RmJywgJ2hleCcpXG5leHBvcnRzWydza2VpbjEwMjQtMTAyNCddID0gQnVmZmVyLmZyb20oJ2IzZTAnLCAnaGV4JylcblxuLy8gbXVsdGlhZGRyXG5leHBvcnRzWydpcDQnXSA9IEJ1ZmZlci5mcm9tKCcwNCcsICdoZXgnKVxuZXhwb3J0c1sndGNwJ10gPSBCdWZmZXIuZnJvbSgnMDYnLCAnaGV4JylcbmV4cG9ydHNbJ2RjY3AnXSA9IEJ1ZmZlci5mcm9tKCcyMScsICdoZXgnKVxuZXhwb3J0c1snaXA2J10gPSBCdWZmZXIuZnJvbSgnMjknLCAnaGV4JylcbmV4cG9ydHNbJ2lwNnpvbmUnXSA9IEJ1ZmZlci5mcm9tKCcyYScsICdoZXgnKVxuZXhwb3J0c1snZG5zJ10gPSBCdWZmZXIuZnJvbSgnMzUnLCAnaGV4JylcbmV4cG9ydHNbJ2RuczQnXSA9IEJ1ZmZlci5mcm9tKCczNicsICdoZXgnKVxuZXhwb3J0c1snZG5zNiddID0gQnVmZmVyLmZyb20oJzM3JywgJ2hleCcpXG5leHBvcnRzWydkbnNhZGRyJ10gPSBCdWZmZXIuZnJvbSgnMzgnLCAnaGV4JylcbmV4cG9ydHNbJ3NjdHAnXSA9IEJ1ZmZlci5mcm9tKCc4NCcsICdoZXgnKVxuZXhwb3J0c1sndWRwJ10gPSBCdWZmZXIuZnJvbSgnMDExMScsICdoZXgnKVxuZXhwb3J0c1sncDJwLXdlYnJ0Yy1zdGFyJ10gPSBCdWZmZXIuZnJvbSgnMDExMycsICdoZXgnKVxuZXhwb3J0c1sncDJwLXdlYnJ0Yy1kaXJlY3QnXSA9IEJ1ZmZlci5mcm9tKCcwMTE0JywgJ2hleCcpXG5leHBvcnRzWydwMnAtc3RhcmR1c3QnXSA9IEJ1ZmZlci5mcm9tKCcwMTE1JywgJ2hleCcpXG5leHBvcnRzWydwMnAtY2lyY3VpdCddID0gQnVmZmVyLmZyb20oJzAxMjInLCAnaGV4JylcbmV4cG9ydHNbJ3VkdCddID0gQnVmZmVyLmZyb20oJzAxMmQnLCAnaGV4JylcbmV4cG9ydHNbJ3V0cCddID0gQnVmZmVyLmZyb20oJzAxMmUnLCAnaGV4JylcbmV4cG9ydHNbJ3VuaXgnXSA9IEJ1ZmZlci5mcm9tKCcwMTkwJywgJ2hleCcpXG5leHBvcnRzWydwMnAnXSA9IEJ1ZmZlci5mcm9tKCcwMWE1JywgJ2hleCcpXG5leHBvcnRzWydpcGZzJ10gPSBCdWZmZXIuZnJvbSgnMDFhNScsICdoZXgnKVxuZXhwb3J0c1snaHR0cHMnXSA9IEJ1ZmZlci5mcm9tKCcwMWJiJywgJ2hleCcpXG5leHBvcnRzWydvbmlvbiddID0gQnVmZmVyLmZyb20oJzAxYmMnLCAnaGV4JylcbmV4cG9ydHNbJ29uaW9uMyddID0gQnVmZmVyLmZyb20oJzAxYmQnLCAnaGV4JylcbmV4cG9ydHNbJ2dhcmxpYzY0J10gPSBCdWZmZXIuZnJvbSgnMDFiZScsICdoZXgnKVxuZXhwb3J0c1snZ2FybGljMzInXSA9IEJ1ZmZlci5mcm9tKCcwMWJmJywgJ2hleCcpXG5leHBvcnRzWydxdWljJ10gPSBCdWZmZXIuZnJvbSgnMDFjYycsICdoZXgnKVxuZXhwb3J0c1snd3MnXSA9IEJ1ZmZlci5mcm9tKCcwMWRkJywgJ2hleCcpXG5leHBvcnRzWyd3c3MnXSA9IEJ1ZmZlci5mcm9tKCcwMWRlJywgJ2hleCcpXG5leHBvcnRzWydwMnAtd2Vic29ja2V0LXN0YXInXSA9IEJ1ZmZlci5mcm9tKCcwMWRmJywgJ2hleCcpXG5leHBvcnRzWydodHRwJ10gPSBCdWZmZXIuZnJvbSgnMDFlMCcsICdoZXgnKVxuXG4vLyBpcGxkXG5leHBvcnRzWydyYXcnXSA9IEJ1ZmZlci5mcm9tKCc1NScsICdoZXgnKVxuZXhwb3J0c1snZGFnLXBiJ10gPSBCdWZmZXIuZnJvbSgnNzAnLCAnaGV4JylcbmV4cG9ydHNbJ2RhZy1jYm9yJ10gPSBCdWZmZXIuZnJvbSgnNzEnLCAnaGV4JylcbmV4cG9ydHNbJ2xpYnAycC1rZXknXSA9IEJ1ZmZlci5mcm9tKCc3MicsICdoZXgnKVxuZXhwb3J0c1snZ2l0LXJhdyddID0gQnVmZmVyLmZyb20oJzc4JywgJ2hleCcpXG5leHBvcnRzWyd0b3JyZW50LWluZm8nXSA9IEJ1ZmZlci5mcm9tKCc3YicsICdoZXgnKVxuZXhwb3J0c1sndG9ycmVudC1maWxlJ10gPSBCdWZmZXIuZnJvbSgnN2MnLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnODEnLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLXR4J10gPSBCdWZmZXIuZnJvbSgnODInLCAnaGV4JylcbmV4cG9ydHNbJ2xlb2Zjb2luLXByJ10gPSBCdWZmZXIuZnJvbSgnODMnLCAnaGV4JylcbmV4cG9ydHNbJ2V0aC1ibG9jayddID0gQnVmZmVyLmZyb20oJzkwJywgJ2hleCcpXG5leHBvcnRzWydldGgtYmxvY2stbGlzdCddID0gQnVmZmVyLmZyb20oJzkxJywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgtdHJpZSddID0gQnVmZmVyLmZyb20oJzkyJywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgnXSA9IEJ1ZmZlci5mcm9tKCc5MycsICdoZXgnKVxuZXhwb3J0c1snZXRoLXR4LXJlY2VpcHQtdHJpZSddID0gQnVmZmVyLmZyb20oJzk0JywgJ2hleCcpXG5leHBvcnRzWydldGgtdHgtcmVjZWlwdCddID0gQnVmZmVyLmZyb20oJzk1JywgJ2hleCcpXG5leHBvcnRzWydldGgtc3RhdGUtdHJpZSddID0gQnVmZmVyLmZyb20oJzk2JywgJ2hleCcpXG5leHBvcnRzWydldGgtYWNjb3VudC1zbmFwc2hvdCddID0gQnVmZmVyLmZyb20oJzk3JywgJ2hleCcpXG5leHBvcnRzWydldGgtc3RvcmFnZS10cmllJ10gPSBCdWZmZXIuZnJvbSgnOTgnLCAnaGV4JylcbmV4cG9ydHNbJ2JpdGNvaW4tYmxvY2snXSA9IEJ1ZmZlci5mcm9tKCdiMCcsICdoZXgnKVxuZXhwb3J0c1snYml0Y29pbi10eCddID0gQnVmZmVyLmZyb20oJ2IxJywgJ2hleCcpXG5leHBvcnRzWyd6Y2FzaC1ibG9jayddID0gQnVmZmVyLmZyb20oJ2MwJywgJ2hleCcpXG5leHBvcnRzWyd6Y2FzaC10eCddID0gQnVmZmVyLmZyb20oJ2MxJywgJ2hleCcpXG5leHBvcnRzWydzdGVsbGFyLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZDAnLCAnaGV4JylcbmV4cG9ydHNbJ3N0ZWxsYXItdHgnXSA9IEJ1ZmZlci5mcm9tKCdkMScsICdoZXgnKVxuZXhwb3J0c1snZGVjcmVkLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZTAnLCAnaGV4JylcbmV4cG9ydHNbJ2RlY3JlZC10eCddID0gQnVmZmVyLmZyb20oJ2UxJywgJ2hleCcpXG5leHBvcnRzWydkYXNoLWJsb2NrJ10gPSBCdWZmZXIuZnJvbSgnZjAnLCAnaGV4JylcbmV4cG9ydHNbJ2Rhc2gtdHgnXSA9IEJ1ZmZlci5mcm9tKCdmMScsICdoZXgnKVxuZXhwb3J0c1snc3dhcm0tbWFuaWZlc3QnXSA9IEJ1ZmZlci5mcm9tKCdmYScsICdoZXgnKVxuZXhwb3J0c1snc3dhcm0tZmVlZCddID0gQnVmZmVyLmZyb20oJ2ZiJywgJ2hleCcpXG5leHBvcnRzWydkYWctanNvbiddID0gQnVmZmVyLmZyb20oJzAxMjknLCAnaGV4JylcblxuLy8gbmFtZXNwYWNlXG5leHBvcnRzWydwYXRoJ10gPSBCdWZmZXIuZnJvbSgnMmYnLCAnaGV4JylcbmV4cG9ydHNbJ2lwbGQtbnMnXSA9IEJ1ZmZlci5mcm9tKCdlMicsICdoZXgnKVxuZXhwb3J0c1snaXBmcy1ucyddID0gQnVmZmVyLmZyb20oJ2UzJywgJ2hleCcpXG5leHBvcnRzWydzd2FybS1ucyddID0gQnVmZmVyLmZyb20oJ2U0JywgJ2hleCcpXG5leHBvcnRzWydpcG5zLW5zJ10gPSBCdWZmZXIuZnJvbSgnZTUnLCAnaGV4JylcbmV4cG9ydHNbJ3plcm9uZXQnXSA9IEJ1ZmZlci5mcm9tKCdlNicsICdoZXgnKVxuXG4vLyBrZXlcbmV4cG9ydHNbJ2VkMjU1MTktcHViJ10gPSBCdWZmZXIuZnJvbSgnZWQnLCAnaGV4JylcblxuLy8gaG9sb2NoYWluXG5leHBvcnRzWydob2xvY2hhaW4tYWRyLXYwJ10gPSBCdWZmZXIuZnJvbSgnODA3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tYWRyLXYxJ10gPSBCdWZmZXIuZnJvbSgnODE3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4ta2V5LXYwJ10gPSBCdWZmZXIuZnJvbSgnOTQ3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4ta2V5LXYxJ10gPSBCdWZmZXIuZnJvbSgnOTU3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tc2lnLXYwJ10gPSBCdWZmZXIuZnJvbSgnYTI3MTI0JywgJ2hleCcpXG5leHBvcnRzWydob2xvY2hhaW4tc2lnLXYxJ10gPSBCdWZmZXIuZnJvbSgnYTM3MTI0JywgJ2hleCcpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5cbnZhciBDSURVdGlsID0ge1xuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSB2YWxpZCBDSUQgb2JqZWN0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgaWYgaXQgaXMgbm90LlxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBpdCBpcyBhIHZhbGlkIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG90aGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjaGVja0NJRENvbXBvbmVudHM6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwgdmFsdWVzIGFyZSBub3QgdmFsaWQgQ0lEcydcbiAgICB9XG5cbiAgICBpZiAoIShvdGhlci52ZXJzaW9uID09PSAwIHx8IG90aGVyLnZlcnNpb24gPT09IDEpKSB7XG4gICAgICByZXR1cm4gJ0ludmFsaWQgdmVyc2lvbiwgbXVzdCBiZSBhIG51bWJlciBlcXVhbCB0byAxIG9yIDAnXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdGhlci5jb2RlYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnY29kZWMgbXVzdCBiZSBzdHJpbmcnXG4gICAgfVxuXG4gICAgaWYgKG90aGVyLnZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChvdGhlci5jb2RlYyAhPT0gJ2RhZy1wYicpIHtcbiAgICAgICAgcmV0dXJuIGBjb2RlYyBtdXN0IGJlICdkYWctcGInIGZvciBDSUR2MGBcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5tdWx0aWJhc2VOYW1lICE9PSAnYmFzZTU4YnRjJykge1xuICAgICAgICByZXR1cm4gYG11bHRpYmFzZU5hbWUgbXVzdCBiZSAnYmFzZTU4YnRjJyBmb3IgQ0lEdjBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3RoZXIubXVsdGloYXNoKSkge1xuICAgICAgcmV0dXJuICdtdWx0aWhhc2ggbXVzdCBiZSBhIEJ1ZmZlcidcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbWgudmFsaWRhdGUob3RoZXIubXVsdGloYXNoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbGV0IGVycm9yTXNnID0gZXJyLm1lc3NhZ2VcbiAgICAgIGlmICghZXJyb3JNc2cpIHsgLy8gSnVzdCBpbiBjYXNlIG1oLnZhbGlkYXRlKCkgdGhyb3dzIGFuIGVycm9yIHdpdGggZW1wdHkgZXJyb3IgbWVzc2FnZVxuICAgICAgICBlcnJvck1zZyA9ICdNdWx0aWhhc2ggdmFsaWRhdGlvbiBmYWlsZWQnXG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JNc2dcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDSURVdGlsXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcblxuZnVuY3Rpb24gZW5zdXJlTXVsdGlhZGRyIChtYSkge1xuICBpZiAobXVsdGlhZGRyLmlzTXVsdGlhZGRyKG1hKSkge1xuICAgIHJldHVybiBtYVxuICB9XG5cbiAgcmV0dXJuIG11bHRpYWRkcihtYSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuc3VyZU11bHRpYWRkcjogZW5zdXJlTXVsdGlhZGRyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBlbnN1cmVNdWx0aWFkZHIgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgdW5pcUJ5ID0gcmVxdWlyZSgndW5pcXVlLWJ5JylcblxuLy8gQmVjYXVzZSBKYXZhU2NyaXB0IGRvZXNuJ3QgbGV0IHlvdSBvdmVybG9hZCB0aGUgY29tcGFyZSBpbiBTZXQoKS4uXG5jbGFzcyBNdWx0aWFkZHJTZXQge1xuICBjb25zdHJ1Y3RvciAobXVsdGlhZGRycykge1xuICAgIHRoaXMuX211bHRpYWRkcnMgPSBtdWx0aWFkZHJzIHx8IFtdXG4gICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzID0gW11cbiAgfVxuXG4gIGFkZCAobWEpIHtcbiAgICBtYSA9IGVuc3VyZU11bHRpYWRkcihtYSlcblxuICAgIGlmICghdGhpcy5oYXMobWEpKSB7XG4gICAgICB0aGlzLl9tdWx0aWFkZHJzLnB1c2gobWEpXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkU2FmZSAtIHByZXZlbnQgbXVsdGlhZGRyIGV4cGxvc2lvbuKEolxuICAvLyBNdWx0aWFkZHIgZXhwbG9zaW9uIGlzIHdoZW4geW91IGRpYWwgdG8gYSBidW5jaCBvZiBub2RlcyBhbmQgZXZlcnkgbm9kZVxuICAvLyBnaXZlcyB5b3UgYSBkaWZmZXJlbnQgb2JzZXJ2ZWQgYWRkcmVzcyBhbmQgeW91IHN0YXJ0IHN0b3JpbmcgdGhlbSBhbGwgdG9cbiAgLy8gc2hhcmUgd2l0aCBvdGhlciBwZWVycy4gVGhpcyBzZWVtcyBsaWtlIGEgZ29vZCBpZGVhIHVudGlsIHlvdSByZWFsaXplIHRoYXRcbiAgLy8gbW9zdCBvZiB0aG9zZSBhZGRyZXNzZXMgYXJlIHVuaXF1ZSB0byB0aGUgc3VibmV0IHRoYXQgcGVlciBpcyBpbiBhbmQgc28sXG4gIC8vIHRoZXkgYXJlIGNvbXBsZXRlbHkgd29ydGhsZXNzIGZvciBhbGwgdGhlIG90aGVyIHBlZXJzLiBUaGlzIG1ldGhvZCBpc1xuICAvLyBleGNsdXNpdmVseSB1c2VkIGJ5IGlkZW50aWZ5LlxuICBhZGRTYWZlIChtYSkge1xuICAgIG1hID0gZW5zdXJlTXVsdGlhZGRyKG1hKVxuXG4gICAgY29uc3QgY2hlY2sgPSB0aGlzLl9vYnNlcnZlZE11bHRpYWRkcnMuc29tZSgobSwgaSkgPT4ge1xuICAgICAgaWYgKG0uZXF1YWxzKG1hKSkge1xuICAgICAgICB0aGlzLmFkZChtYSlcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzLnNwbGljZShpLCAxKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgdGhpcy5fb2JzZXJ2ZWRNdWx0aWFkZHJzLnB1c2gobWEpXG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuc2xpY2UoKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl9tdWx0aWFkZHJzLmxlbmd0aFxuICB9XG5cbiAgZm9yRWFjaCAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fbXVsdGlhZGRycy5mb3JFYWNoKGZuKVxuICB9XG5cbiAgZmlsdGVyQnkgKG1hRm10KSB7XG4gICAgaWYgKHR5cGVvZiBtYUZtdCAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHR5cGVvZiBtYUZtdC5tYXRjaGVzICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgbWFGbXQucGFydGlhbE1hdGNoICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgbWFGbXQudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHJldHVybiBbXVxuXG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuZmlsdGVyKChtYSkgPT4gbWFGbXQubWF0Y2hlcyhtYSkpXG4gIH1cblxuICBoYXMgKG1hKSB7XG4gICAgbWEgPSBlbnN1cmVNdWx0aWFkZHIobWEpXG4gICAgcmV0dXJuIHRoaXMuX211bHRpYWRkcnMuc29tZSgobSkgPT4gbS5lcXVhbHMobWEpKVxuICB9XG5cbiAgZGVsZXRlIChtYSkge1xuICAgIG1hID0gZW5zdXJlTXVsdGlhZGRyKG1hKVxuXG4gICAgdGhpcy5fbXVsdGlhZGRycy5zb21lKChtLCBpKSA9PiB7XG4gICAgICBpZiAobS5lcXVhbHMobWEpKSB7XG4gICAgICAgIHRoaXMuX211bHRpYWRkcnMuc3BsaWNlKGksIDEpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHJlcGxhY2VzIHNlbGVjdGVkIGV4aXN0aW5nIG11bHRpYWRkcnMgd2l0aCBuZXcgb25lc1xuICByZXBsYWNlIChleGlzdGluZywgZnJlc2gpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICBleGlzdGluZyA9IFtleGlzdGluZ11cbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZyZXNoKSkge1xuICAgICAgZnJlc2ggPSBbZnJlc2hdXG4gICAgfVxuICAgIGV4aXN0aW5nLmZvckVhY2goKG0pID0+IHRoaXMuZGVsZXRlKG0pKVxuICAgIGZyZXNoLmZvckVhY2goKG0pID0+IHRoaXMuYWRkKG0pKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuX211bHRpYWRkcnMgPSBbXVxuICB9XG5cbiAgLy8gdGhpcyBvbmx5IHJlYWxseSBoZWxwcyBtYWtlIGlwNiBhbmQgaXA0IG11bHRpYWRkcnMgZGlzdGluY3QgaWYgdGhleSBhcmVcbiAgLy8gZGlmZmVyZW50XG4gIC8vIFRPRE8gdGhpcyBpcyBub3QgYW4gaWRlYWwgc29sdXRpb24sIHByb2JhYmx5IHRoaXMgY29kZSBzaG91bGQganVzdCBiZVxuICAvLyBpbiBsaWJwMnAtdGNwXG4gIGRpc3RpbmN0ICgpIHtcbiAgICByZXR1cm4gdW5pcUJ5KHRoaXMuX211bHRpYWRkcnMsIChtYSkgPT4ge1xuICAgICAgcmV0dXJuIFttYS50b09wdGlvbnMoKS5wb3J0LCBtYS50b09wdGlvbnMoKS50cmFuc3BvcnRdLmpvaW4oKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aWFkZHJTZXRcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBEZWZpbmUgYSBzdHJ1Y3QgZXJyb3IuXG4gKlxuICogQHR5cGUge1N0cnVjdEVycm9yfVxuICovXG5cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgc3RhdGljIGZvcm1hdChhdHRycykge1xuICAgIGNvbnN0IHsgdHlwZSwgcGF0aCwgdmFsdWUgfSA9IGF0dHJzO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3BhdGgubGVuZ3RoID8gYCBmb3IgXFxgJHtwYXRoLmpvaW4oJy4nKX1cXGBgIDogJyd9IGJ1dCByZWNlaXZlZCBcXGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXGAuYDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFN0cnVjdEVycm9yLmZvcm1hdChhdHRycyk7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIHZhbHVlLCByZWFzb24sIHR5cGUsIGVycm9ycyA9IFtdIH0gPSBhdHRycztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG5cbiAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGVycm9ycy5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9XG4gIH1cbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGtpbmRPZiA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gJ2Jvb2xlYW4nO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiAnc3RyaW5nJztcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ251bWJlcic7XG4gIGlmICh0eXBlID09PSAnc3ltYm9sJykgcmV0dXJuICdzeW1ib2wnO1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpc0dlbmVyYXRvckZuKHZhbCkgPyAnZ2VuZXJhdG9yZnVuY3Rpb24nIDogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNCdWZmZXIodmFsKSkgcmV0dXJuICdidWZmZXInO1xuICBpZiAoaXNBcmd1bWVudHModmFsKSkgcmV0dXJuICdhcmd1bWVudHMnO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICBpZiAoaXNSZWdleHAodmFsKSkgcmV0dXJuICdyZWdleHAnO1xuXG4gIHN3aXRjaCAoY3Rvck5hbWUodmFsKSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6IHJldHVybiAnc3ltYm9sJztcbiAgICBjYXNlICdQcm9taXNlJzogcmV0dXJuICdwcm9taXNlJztcblxuICAgIC8vIFNldCwgTWFwLCBXZWFrU2V0LCBXZWFrTWFwXG4gICAgY2FzZSAnV2Vha01hcCc6IHJldHVybiAnd2Vha21hcCc7XG4gICAgY2FzZSAnV2Vha1NldCc6IHJldHVybiAnd2Vha3NldCc7XG4gICAgY2FzZSAnTWFwJzogcmV0dXJuICdtYXAnO1xuICAgIGNhc2UgJ1NldCc6IHJldHVybiAnc2V0JztcblxuICAgIC8vIDgtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDhBcnJheSc6IHJldHVybiAnaW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OEFycmF5JzogcmV0dXJuICd1aW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6IHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuXG4gICAgLy8gMTYtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDE2QXJyYXknOiByZXR1cm4gJ2ludDE2YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzogcmV0dXJuICd1aW50MTZhcnJheSc7XG5cbiAgICAvLyAzMi1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50MzJBcnJheSc6IHJldHVybiAnaW50MzJhcnJheSc7XG4gICAgY2FzZSAnVWludDMyQXJyYXknOiByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOiByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzogcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yT2JqKHZhbCkpIHtcbiAgICByZXR1cm4gJ2dlbmVyYXRvcic7XG4gIH1cblxuICAvLyBOb24tcGxhaW4gb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiByZXR1cm4gJ29iamVjdCc7XG4gICAgLy8gaXRlcmF0b3JzXG4gICAgY2FzZSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzogcmV0dXJuICdtYXBpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJzogcmV0dXJuICdzZXRpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzogcmV0dXJuICdzdHJpbmdpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nOiByZXR1cm4gJ2FycmF5aXRlcmF0b3InO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSkgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgKHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSAnbnVtYmVyJyk7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhwKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuZmxhZ3MgPT09ICdzdHJpbmcnXG4gICAgJiYgdHlwZW9mIHZhbC5pZ25vcmVDYXNlID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLm11bHRpbGluZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5nbG9iYWwgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JGbihuYW1lLCB2YWwpIHtcbiAgcmV0dXJuIGN0b3JOYW1lKG5hbWUpID09PSAnR2VuZXJhdG9yRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iaih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB2YWwubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsLmNhbGxlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignY2FsbGVlJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU2FmYXJpIDUtNyAoOC0xMCB5ci1vbGQgYnJvd3NlciksXG4gKiB0YWtlIGEgbG9vayBhdCBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICBpZiAodmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcHJpdmF0ZSBzdHJpbmcgdG8gaWRlbnRpZnkgc3RydWN0cyBieS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5cbmNvbnN0IElTX1NUUlVDVCA9ICdAQF9fU1RSVUNUX19AQCc7XG5cbi8qKlxuICogQSBwcml2YXRlIHN0cmluZyB0byByZWZlciB0byBhIHN0cnVjdCdzIGtpbmQuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuXG5jb25zdCBLSU5EID0gJ0BAX19LSU5EX19AQCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBgdmFsdWVgIGlzIGEgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1N0cnVjdCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbSVNfU1RSVUNUXSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBgZGVmYXVsdHNgLCBmb3IgYW4gb3B0aW9uYWwgYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEFueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7QW55fVxuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cywgdmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0cyA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRzKHZhbHVlKSA6IGRlZmF1bHRzO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBLaW5kLlxuICpcbiAqIEB0eXBlIHtLaW5kfVxuICovXG5cbmNsYXNzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCB2YWxpZGF0ZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBBbnkuXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBzY2hlbWFcbiAqIEBwYXJhbSB7QW55fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBhbnkoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoaXNTdHJ1Y3Qoc2NoZW1hKSkge1xuICAgIHJldHVybiBzY2hlbWFbS0lORF07XG4gIH1cblxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgS2luZCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cblxuICBzd2l0Y2ggKGtpbmRPZihzY2hlbWEpKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmxlbmd0aCA+IDEgPyB0dXBsZShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSA6IGxpc3Qoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBmdW5jKHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIGxldCByZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIGxldCB0eXBlO1xuXG4gICAgICAgIGlmIChzY2hlbWEuZW5kc1dpdGgoJz8nKSkge1xuICAgICAgICAgIHJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuaW5jbHVkZXMoJ3wnKSkge1xuICAgICAgICAgIGNvbnN0IHNjYWxhcnMgPSBzY2hlbWEuc3BsaXQoL1xccypcXHxcXHMqL2cpO1xuICAgICAgICAgIHR5cGUgPSB1bmlvbihzY2FsYXJzLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLmluY2x1ZGVzKCcmJykpIHtcbiAgICAgICAgICBjb25zdCBzY2FsYXJzID0gc2NoZW1hLnNwbGl0KC9cXHMqJlxccyovZyk7XG4gICAgICAgICAgdHlwZSA9IGludGVyc2VjdGlvbihzY2FsYXJzLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHNjYWxhcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICB0eXBlID0gb3B0aW9uYWwodHlwZSwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIHNjaGVtYSBkZWZpbml0aW9uIG11c3QgYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nIG9yIGZ1bmN0aW9uLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGRpY3Qoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScgfHwgc2NoZW1hLmxlbmd0aCAhPT0gMikge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9iaiA9IHNjYWxhcignb2JqZWN0JywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgY29uc3Qga2V5cyA9IGFueShzY2hlbWFbMF0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IHZhbHVlcyA9IGFueShzY2hlbWFbMV0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAnZGljdCc7XG4gIGNvbnN0IHR5cGUgPSBgZGljdDwke2tleXMudHlwZX0sJHt2YWx1ZXMudHlwZX0+YDtcbiAgY29uc3QgdmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpO1xuICAgIHZhbHVlID0gcmVzb2x2ZWQgPyBfZXh0ZW5kcyh7fSwgcmVzb2x2ZWQsIHZhbHVlKSA6IHZhbHVlO1xuICAgIGNvbnN0IFtlcnJvcl0gPSBvYmoudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgayBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgY29uc3QgW2UsIHJdID0ga2V5cy52YWxpZGF0ZShrKTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrXS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrID0gcjtcbiAgICAgIGNvbnN0IFtlMiwgcjJdID0gdmFsdWVzLnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZTIpIHtcbiAgICAgICAgY29uc3QgYWxsRTIgPSBlMi5lcnJvcnMgfHwgW2UyXTtcbiAgICAgICAgYWxsRTIuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba10uY29uY2F0KHNpbmdsZUUucGF0aCk7XG4gICAgICAgICAgc2luZ2xlRS5kYXRhID0gdmFsdWU7XG4gICAgICAgICAgZXJyb3JzLnB1c2goc2luZ2xlRSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0W2tdID0gcjI7XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBFbnVtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGVuKHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudW0gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdlbnVtJztcbiAgY29uc3QgdHlwZSA9IHNjaGVtYS5tYXAocyA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHMpO1xuICAgIH1cbiAgfSkuam9pbignIHwgJyk7XG5cbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgcmV0dXJuIHNjaGVtYS5pbmNsdWRlcyh2YWx1ZSkgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbeyBkYXRhOiB2YWx1ZSwgcGF0aDogW10sIHZhbHVlLCB0eXBlIH1dO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogRW51bXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZW51bXMoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBlID0gZW4oc2NoZW1hLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICBjb25zdCBsID0gbGlzdChbZV0sIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZnVuYyhzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAnZnVuY3Rpb24nO1xuICBjb25zdCB0eXBlID0gJzxmdW5jdGlvbj4nO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSksIGRhdGEpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEodmFsdWUsIGRhdGEpO1xuICAgIGxldCBmYWlsdXJlID0geyBwYXRoOiBbXSwgcmVhc29uOiBudWxsIH07XG4gICAgbGV0IGlzVmFsaWQ7XG5cbiAgICBzd2l0Y2ggKGtpbmRPZihyZXN1bHQpKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAge1xuICAgICAgICAgIGlzVmFsaWQgPSByZXN1bHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgZmFpbHVyZS5yZWFzb24gPSByZXN1bHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgZmFpbHVyZSA9IF9leHRlbmRzKHt9LCBmYWlsdXJlLCByZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRvciBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSBib29sZWFuLCBhbiBlcnJvciByZWFzb24gc3RyaW5nIG9yIGFuIGVycm9yIHJlYXNvbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3VsdDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbX2V4dGVuZHMoeyB0eXBlLCB2YWx1ZSwgZGF0YTogdmFsdWUgfSwgZmFpbHVyZSldO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2Uoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBuYW1lID0gJ2luc3RhbmNlJztcbiAgY29uc3QgdHlwZSA9IGBpbnN0YW5jZTwke3NjaGVtYS5uYW1lfT5gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBzY2hlbWEgPyBbdW5kZWZpbmVkLCB2YWx1ZV0gOiBbeyBkYXRhOiB2YWx1ZSwgcGF0aDogW10sIHZhbHVlLCB0eXBlIH1dO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBpbnRlcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJmYWNlIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBrcyA9IFtdO1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpO1xuICAgIGNvbnN0IHMgPSBzY2hlbWFba2V5XTtcbiAgICBjb25zdCBraW5kID0gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1trZXldID0ga2luZDtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAnaW50ZXJmYWNlJztcbiAgY29uc3QgdHlwZSA9IGB7JHtrcy5qb2luKCl9fWA7XG4gIGNvbnN0IHZhbGlkYXRlID0gdmFsdWUgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzJCQxKTtcbiAgICB2YWx1ZSA9IHJlc29sdmVkID8gX2V4dGVuZHMoe30sIHJlc29sdmVkLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCByZXQgPSB2YWx1ZTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGxldCB2ID0gdmFsdWVba2V5XTtcbiAgICAgIGNvbnN0IGtpbmQgPSBwcm9wZXJ0aWVzW2tleV07XG5cbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZCA9IGRlZmF1bHRzJCQxICYmIGRlZmF1bHRzJCQxW2tleV07XG4gICAgICAgIHYgPSByZXNvbHZlRGVmYXVsdHMoZCwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbZSwgcl0gPSBraW5kLnZhbGlkYXRlKHYsIHZhbHVlKTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtrZXldLmNvbmNhdChzaW5nbGVFLnBhdGgpO1xuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW4gdmFsdWUgfHwgciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldFtrZXldID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZmlyc3QgPSBlcnJvcnNbMF07XG4gICAgICBmaXJzdC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICByZXR1cm4gW2ZpcnN0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmV0XTtcbiAgfTtcblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpO1xufVxuXG4vKipcbiAqIExhenkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gbGF6eShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXp5IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNjaGVtYSwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBsZXQga2luZDtcbiAgbGV0IHN0cnVjdDtcbiAgY29uc3QgbmFtZSA9ICdsYXp5JztcbiAgY29uc3QgdHlwZSA9IGBsYXp5Li4uYDtcbiAgY29uc3QgY29tcGlsZSA9IHZhbHVlID0+IHtcbiAgICBzdHJ1Y3QgPSBzY2hlbWEoKTtcbiAgICBraW5kLm5hbWUgPSBzdHJ1Y3Qua2luZDtcbiAgICBraW5kLnR5cGUgPSBzdHJ1Y3QudHlwZTtcbiAgICBraW5kLnZhbGlkYXRlID0gc3RydWN0LnZhbGlkYXRlO1xuICAgIHJldHVybiBraW5kLnZhbGlkYXRlKHZhbHVlKTtcbiAgfTtcblxuICBraW5kID0gbmV3IEtpbmQobmFtZSwgdHlwZSwgY29tcGlsZSk7XG4gIHJldHVybiBraW5kO1xufVxuXG4vKipcbiAqIER5bmFtaWMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRlU2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhjcmVhdGVTY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2YoY3JlYXRlU2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEeW5hbWljIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiAke2NyZWF0ZVNjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtjcmVhdGVTY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdkeW5hbWljJztcbiAgY29uc3QgdHlwZSA9ICdkeW5hbWljLi4uJztcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpLCBkYXRhKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gY3JlYXRlU2NoZW1hKHZhbHVlLCBkYXRhKTtcblxuICAgIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHluYW1pYyBzdHJ1Y3RzIG11c3QgcmV0dXJuIGEgc2NoZW1hLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBzY2hlbWEudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gW2Vycm9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmVzdWx0XTtcbiAgfTtcblxuICByZXR1cm4gbmV3IEtpbmQobmFtZSwgdHlwZSwgdmFsaWRhdGUpO1xufVxuXG4vKipcbiAqIExpc3QuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBsaXN0KHNjaGVtYSwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpIHtcbiAgaWYgKGtpbmRPZihzY2hlbWEpICE9PSAnYXJyYXknIHx8IHNjaGVtYS5sZW5ndGggIT09IDEpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSB3aXRoIGEgc2luZ2xlIGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXJyYXkgPSBzY2FsYXIoJ2FycmF5JywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgY29uc3QgZWxlbWVudCA9IGFueShzY2hlbWFbMF0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAnbGlzdCc7XG4gIGNvbnN0IHR5cGUgPSBgWyR7ZWxlbWVudC50eXBlfV1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBhcnJheS52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBbZSwgcl0gPSBlbGVtZW50LnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBhbGxFID0gZS5lcnJvcnMgfHwgW2VdO1xuICAgICAgICBhbGxFLmZvckVhY2goc2luZ2xlRSA9PiB7XG4gICAgICAgICAgc2luZ2xlRS5wYXRoID0gW2ldLmNvbmNhdChzaW5nbGVFLnBhdGgpO1xuICAgICAgICAgIHNpbmdsZUUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIGVycm9ycy5wdXNoKHNpbmdsZUUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldFtpXSA9IHI7XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGxpdGVyYWwoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBjb25zdCBuYW1lID0gJ2xpdGVyYWwnO1xuICBjb25zdCB0eXBlID0gYGxpdGVyYWw6ICR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHNjaGVtYSA/IFt1bmRlZmluZWQsIHZhbHVlXSA6IFt7IGRhdGE6IHZhbHVlLCBwYXRoOiBbXSwgdmFsdWUsIHR5cGUgfV07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBvYmogPSBzY2FsYXIoJ29iamVjdCcsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGtzID0gW107XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBrcy5wdXNoKGtleSk7XG4gICAgY29uc3QgcyA9IHNjaGVtYVtrZXldO1xuICAgIGNvbnN0IGtpbmQgPSBhbnkocywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBwcm9wZXJ0aWVzW2tleV0gPSBraW5kO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9ICdvYmplY3QnO1xuICBjb25zdCB0eXBlID0gYHske2tzLmpvaW4oKX19YDtcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IG9iai52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY29uc3QgdmFsdWVLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHByb3BlcnRpZXNLZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQodmFsdWVLZXlzLmNvbmNhdChwcm9wZXJ0aWVzS2V5cykpO1xuXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgdiA9IHZhbHVlW2tleV07XG4gICAgICBjb25zdCBraW5kID0gcHJvcGVydGllc1trZXldO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyQkMSAmJiBkZWZhdWx0cyQkMVtrZXldO1xuICAgICAgICB2ID0gcmVzb2x2ZURlZmF1bHRzKGQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7IGRhdGE6IHZhbHVlLCBwYXRoOiBba2V5XSwgdmFsdWU6IHYgfTtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV07XG4gICAgICAgIGFsbEUuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba2V5XS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiB2YWx1ZSB8fCByICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0W2tleV0gPSByO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBPcHRpb25hbC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uYWwoc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICByZXR1cm4gdW5pb24oW3NjaGVtYSwgJ3VuZGVmaW5lZCddLCBkZWZhdWx0cyQkMSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGFydGlhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFydGlhbCBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb2JqID0gc2NhbGFyKCdvYmplY3QnLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICBjb25zdCBrcyA9IFtdO1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAga3MucHVzaChrZXkpO1xuICAgIGNvbnN0IHMgPSBzY2hlbWFba2V5XTtcbiAgICBjb25zdCBraW5kID0gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1trZXldID0ga2luZDtcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSAncGFydGlhbCc7XG4gIGNvbnN0IHR5cGUgPSBgeyR7a3Muam9pbigpfSwuLi59YDtcbiAgY29uc3QgdmFsaWRhdGUgPSAodmFsdWUgPSByZXNvbHZlRGVmYXVsdHMoZGVmYXVsdHMkJDEpKSA9PiB7XG4gICAgY29uc3QgW2Vycm9yXSA9IG9iai52YWxpZGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIFtlcnJvcl07XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgcmV0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBsZXQgdiA9IHZhbHVlW2tleV07XG4gICAgICBjb25zdCBraW5kID0gcHJvcGVydGllc1trZXldO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWZhdWx0cyQkMSAmJiBkZWZhdWx0cyQkMVtrZXldO1xuICAgICAgICB2ID0gcmVzb2x2ZURlZmF1bHRzKGQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGFsbEUgPSBlLmVycm9ycyB8fCBbZV07XG4gICAgICAgIGFsbEUuZm9yRWFjaChzaW5nbGVFID0+IHtcbiAgICAgICAgICBzaW5nbGVFLnBhdGggPSBba2V5XS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluIHZhbHVlIHx8IHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXRba2V5XSA9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gZXJyb3JzWzBdO1xuICAgICAgZmlyc3QuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgcmV0dXJuIFtmaXJzdF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHJldF07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBTY2FsYXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHNjYWxhcihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2NhbGFyIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZDogJHtzY2hlbWF9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlbWE6ICR7c2NoZW1hfWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgdHlwZXMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZuID0gdHlwZXNbc2NoZW1hXTtcblxuICBpZiAoa2luZE9mKGZuKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdHJ1Y3QgdmFsaWRhdG9yIGZ1bmN0aW9uIGZvdW5kIGZvciB0eXBlIFwiJHtzY2hlbWF9XCIuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBraW5kID0gZnVuYyhmbiwgZGVmYXVsdHMkJDEsIG9wdGlvbnMpO1xuICBjb25zdCBuYW1lID0gJ3NjYWxhcic7XG4gIGNvbnN0IHR5cGUgPSBzY2hlbWE7XG4gIGNvbnN0IHZhbGlkYXRlID0gdmFsdWUgPT4ge1xuICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGtpbmQudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogVHVwbGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiB0dXBsZShzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2FycmF5Jykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUdXBsZSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSwgYnV0IHlvdSBwYXNzZWQ6ICR7c2NoZW1hfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZW1hOiAke3NjaGVtYX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBraW5kcyA9IHNjaGVtYS5tYXAocyA9PiBhbnkocywgdW5kZWZpbmVkLCBvcHRpb25zKSk7XG4gIGNvbnN0IGFycmF5ID0gc2NhbGFyKCdhcnJheScsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIGNvbnN0IG5hbWUgPSAndHVwbGUnO1xuICBjb25zdCB0eXBlID0gYFske2tpbmRzLm1hcChrID0+IGsudHlwZSkuam9pbigpfV1gO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBjb25zdCBbZXJyb3JdID0gYXJyYXkudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBlcnJvci50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBbZXJyb3JdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KHZhbHVlLmxlbmd0aCwga2luZHMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtpbmQgPSBraW5kc1tpXTtcbiAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpXTtcblxuICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7IGRhdGE6IHZhbHVlLCBwYXRoOiBbaV0sIHZhbHVlOiB2IH07XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2UsIHJdID0ga2luZC52YWxpZGF0ZSh2KTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgYWxsRSA9IGUuZXJyb3JzIHx8IFtlXTtcbiAgICAgICAgYWxsRS5mb3JFYWNoKHNpbmdsZUUgPT4ge1xuICAgICAgICAgIHNpbmdsZUUucGF0aCA9IFtpXS5jb25jYXQoc2luZ2xlRS5wYXRoKTtcbiAgICAgICAgICBzaW5nbGVFLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgICBlcnJvcnMucHVzaChzaW5nbGVFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRbaV0gPSByO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IGVycm9yc1swXTtcbiAgICAgIGZpcnN0LmVycm9ycyA9IGVycm9ycztcbiAgICAgIHJldHVybiBbZmlyc3RdO1xuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXRdO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogVW5pb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gdW5pb24oc2NoZW1hLCBkZWZhdWx0cyQkMSwgb3B0aW9ucykge1xuICBpZiAoa2luZE9mKHNjaGVtYSkgIT09ICdhcnJheScpIHtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qga2luZHMgPSBzY2hlbWEubWFwKHMgPT4gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucykpO1xuICBjb25zdCBuYW1lID0gJ3VuaW9uJztcbiAgY29uc3QgdHlwZSA9IGtpbmRzLm1hcChrID0+IGsudHlwZSkuam9pbignIHwgJyk7XG4gIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlID0gcmVzb2x2ZURlZmF1bHRzKGRlZmF1bHRzJCQxKSkgPT4ge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBrIG9mIGtpbmRzKSB7XG4gICAgICBjb25zdCBbZSwgcl0gPSBrLnZhbGlkYXRlKHZhbHVlKTtcblxuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCByXTtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgfVxuICAgIGVycm9yc1swXS50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9O1xuXG4gIHJldHVybiBuZXcgS2luZChuYW1lLCB0eXBlLCB2YWxpZGF0ZSk7XG59XG5cbi8qKlxuICogSW50ZXJzZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IGRlZmF1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSB7XG4gIGlmIChraW5kT2Yoc2NoZW1hKSAhPT0gJ2FycmF5Jykge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcnNlY3Rpb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiAke3NjaGVtYX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVtYTogJHtzY2hlbWF9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHlwZXMgPSBzY2hlbWEubWFwKHMgPT4gYW55KHMsIHVuZGVmaW5lZCwgb3B0aW9ucykpO1xuICBjb25zdCBuYW1lID0gJ2ludGVyc2VjdGlvbic7XG4gIGNvbnN0IHR5cGUgPSB0eXBlcy5tYXAodCA9PiB0LnR5cGUpLmpvaW4oJyAmICcpO1xuICBjb25zdCB2YWxpZGF0ZSA9ICh2YWx1ZSA9IHJlc29sdmVEZWZhdWx0cyhkZWZhdWx0cyQkMSkpID0+IHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuXG4gICAgZm9yIChjb25zdCB0IG9mIHR5cGVzKSB7XG4gICAgICBjb25zdCBbZSwgcl0gPSB0LnZhbGlkYXRlKHYpO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnR5cGUgPSB0eXBlO1xuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcjtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBLaW5kKG5hbWUsIHR5cGUsIHZhbGlkYXRlKTtcbn1cblxuLyoqXG4gKiBLaW5kcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IEtpbmRzID0ge1xuICBhbnksXG4gIGRpY3QsXG4gIGVudW06IGVuLFxuICBlbnVtcyxcbiAgZnVuY3Rpb246IGZ1bmMsXG4gIGluc3RhbmNlLFxuICBpbnRlcmZhY2U6IGludGVyLFxuICBsYXp5LFxuICBsaXN0LFxuICBsaXRlcmFsLFxuICBvYmplY3QsXG4gIG9wdGlvbmFsLFxuICBwYXJ0aWFsLFxuICBzY2FsYXIsXG4gIHR1cGxlLFxuICB1bmlvbixcbiAgaW50ZXJzZWN0aW9uLFxuICBkeW5hbWljXG5cbiAgLyoqXG4gICAqIEV4cG9ydC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbn07XG5cbi8qKlxuICogVGhlIHR5cGVzIHRoYXQgYGtpbmQtb2ZgIHN1cHBvcnRzLlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5jb25zdCBUWVBFUyA9IFsnYXJndW1lbnRzJywgJ2FycmF5JywgJ2Jvb2xlYW4nLCAnYnVmZmVyJywgJ2Vycm9yJywgJ2Zsb2F0MzJhcnJheScsICdmbG9hdDY0YXJyYXknLCAnZnVuY3Rpb24nLCAnZ2VuZXJhdG9yZnVuY3Rpb24nLCAnaW50MTZhcnJheScsICdpbnQzMmFycmF5JywgJ2ludDhhcnJheScsICdtYXAnLCAnbnVsbCcsICdudW1iZXInLCAnb2JqZWN0JywgJ3Byb21pc2UnLCAncmVnZXhwJywgJ3NldCcsICdzdHJpbmcnLCAnc3ltYm9sJywgJ3VpbnQxNmFycmF5JywgJ3VpbnQzMmFycmF5JywgJ3VpbnQ4YXJyYXknLCAndWludDhjbGFtcGVkYXJyYXknLCAndW5kZWZpbmVkJywgJ3dlYWttYXAnLCAnd2Vha3NldCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHR5cGVzIHRoYXQgU3VwZXJzdHJ1Y3Qgc2hpcHMgd2l0aC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IFR5cGVzID0ge1xuICBhbnk6IHZhbHVlID0+IHZhbHVlICE9PSB1bmRlZmluZWRcbn07XG5cblRZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gIFR5cGVzW3R5cGVdID0gdmFsdWUgPT4ga2luZE9mKHZhbHVlKSA9PT0gdHlwZTtcbn0pO1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgJ2RhdGUnIGNhc2Ugc3BlY2lhbGx5LCB0byB0aHJvdyBvdXQgaW52YWxpZCBgRGF0ZWAgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5UeXBlcy5kYXRlID0gdmFsdWUgPT4ga2luZE9mKHZhbHVlKSA9PT0gJ2RhdGUnICYmICFpc05hTih2YWx1ZSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IGZhY3Rvcnkgd2l0aCBhIGBjb25maWdgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHN1cGVyc3RydWN0KGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHR5cGVzID0gX2V4dGVuZHMoe30sIFR5cGVzLCBjb25maWcudHlwZXMgfHwge30pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBga2luZGAgc3RydWN0IHdpdGggYHNjaGVtYWAsIGBkZWZhdWx0c2AgYW5kIGBvcHRpb25zYC5cbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IHNjaGVtYVxuICAgKiBAcGFyYW0ge0FueX0gZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0cnVjdChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoaXNTdHJ1Y3Qoc2NoZW1hKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCBraW5kID0gS2luZHMuYW55KHNjaGVtYSwgZGVmYXVsdHMkJDEsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IHR5cGVzIH0pKTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdChkYXRhKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cnVjdCkge1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgU3RydWN0YCBjcmVhdGlvbiBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYG5ld2Aga2V5d29yZCEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RydWN0LmFzc2VydChkYXRhKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RydWN0LCBJU19TVFJVQ1QsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cnVjdCwgS0lORCwgeyB2YWx1ZToga2luZCB9KTtcblxuICAgIFN0cnVjdC5raW5kID0ga2luZC5uYW1lO1xuICAgIFN0cnVjdC50eXBlID0ga2luZC50eXBlO1xuICAgIFN0cnVjdC5zY2hlbWEgPSBzY2hlbWE7XG4gICAgU3RydWN0LmRlZmF1bHRzID0gZGVmYXVsdHMkJDE7XG4gICAgU3RydWN0Lm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgU3RydWN0LmFzc2VydCA9IHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGtpbmQudmFsaWRhdGUodmFsdWUpO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0cnVjdEVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgU3RydWN0LnRlc3QgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3JdID0ga2luZC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gIWVycm9yO1xuICAgIH07XG5cbiAgICBTdHJ1Y3QudmFsaWRhdGUgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSBraW5kLnZhbGlkYXRlKHZhbHVlKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFN0cnVjdEVycm9yKGVycm9yKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RydWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1peCBpbiBhIGZhY3RvcnkgZm9yIGVhY2ggc3BlY2lmaWMga2luZCBvZiBzdHJ1Y3QuXG4gICAqL1xuXG4gIE9iamVjdC5rZXlzKEtpbmRzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGtpbmQgPSBLaW5kc1tuYW1lXTtcblxuICAgIHN0cnVjdFtuYW1lXSA9IChzY2hlbWEsIGRlZmF1bHRzJCQxLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0ga2luZChzY2hlbWEsIGRlZmF1bHRzJCQxLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyB0eXBlcyB9KSk7XG4gICAgICBjb25zdCBzID0gc3RydWN0KHR5cGUsIGRlZmF1bHRzJCQxLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cnVjdCBmYWN0b3J5LlxuICAgKi9cblxuICByZXR1cm4gc3RydWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnZlbmllbmNlIGBzdHJ1Y3RgIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IHR5cGVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5jb25zdCBzdHJ1Y3QgPSBzdXBlcnN0cnVjdCgpO1xuXG5leHBvcnRzLnN0cnVjdCA9IHN0cnVjdDtcbmV4cG9ydHMuc3VwZXJzdHJ1Y3QgPSBzdXBlcnN0cnVjdDtcbmV4cG9ydHMuaXNTdHJ1Y3QgPSBpc1N0cnVjdDtcbmV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvYnVmID0gcmVxdWlyZSgncHJvdG9ucycpXG5jb25zdCBrZXlzUEJNID0gcHJvdG9idWYocmVxdWlyZSgnLi9rZXlzLnByb3RvJykpXG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9hc24xJylcbnJlcXVpcmUoJ25vZGUtZm9yZ2UvbGliL3JzYScpXG5yZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9wYmUnKVxuY29uc3QgZm9yZ2UgPSByZXF1aXJlKCdub2RlLWZvcmdlL2xpYi9mb3JnZScpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5jb25zdCBzdXBwb3J0ZWRLZXlzID0ge1xuICByc2E6IHJlcXVpcmUoJy4vcnNhLWNsYXNzJyksXG4gIGVkMjU1MTk6IHJlcXVpcmUoJy4vZWQyNTUxOS1jbGFzcycpLFxuICBzZWNwMjU2azE6IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8tc2VjcDI1NmsxJykoa2V5c1BCTSwgcmVxdWlyZSgnLi4vcmFuZG9tLWJ5dGVzJykpXG59XG5cbmV4cG9ydHMuc3VwcG9ydGVkS2V5cyA9IHN1cHBvcnRlZEtleXNcbmV4cG9ydHMua2V5c1BCTSA9IGtleXNQQk1cblxuZnVuY3Rpb24gaXNWYWxpZEtleVR5cGUgKGtleVR5cGUpIHtcbiAgY29uc3Qga2V5ID0gc3VwcG9ydGVkS2V5c1trZXlUeXBlLnRvTG93ZXJDYXNlKCldXG4gIHJldHVybiBrZXkgIT09IHVuZGVmaW5lZFxufVxuXG5leHBvcnRzLmtleVN0cmV0Y2hlciA9IHJlcXVpcmUoJy4va2V5LXN0cmV0Y2hlcicpXG5leHBvcnRzLmdlbmVyYXRlRXBoZW1lcmFsS2V5UGFpciA9IHJlcXVpcmUoJy4vZXBoZW1lcmFsLWtleXMnKVxuXG4vLyBHZW5lcmF0ZXMgYSBrZXlwYWlyIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBiaXRzaXplXG5leHBvcnRzLmdlbmVyYXRlS2V5UGFpciA9ICh0eXBlLCBiaXRzLCBjYikgPT4ge1xuICBsZXQga2V5ID0gc3VwcG9ydGVkS2V5c1t0eXBlLnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJykpXG4gIH1cblxuICBrZXkuZ2VuZXJhdGVLZXlQYWlyKGJpdHMsIGNiKVxufVxuXG4vLyBHZW5lcmF0ZXMgYSBrZXlwYWlyIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBiaXRzaXplXG4vLyBzZWVkIGlzIGEgMzIgYnl0ZSB1aW50OGFycmF5XG5leHBvcnRzLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gKHR5cGUsIHNlZWQsIGJpdHMsIGNiKSA9PiB7XG4gIGxldCBrZXkgPSBzdXBwb3J0ZWRLZXlzW3R5cGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJykpXG4gIH1cbiAgaWYgKHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gJ2VkMjU1MTknKSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU2VlZCBrZXkgZGVyaXZhdGlvbiBpcyB1bmltcGxlbWVudGVkIGZvciBSU0Egb3Igc2VjcDI1NmsxJykpXG4gIH1cbiAga2V5LmdlbmVyYXRlS2V5UGFpckZyb21TZWVkKHNlZWQsIGJpdHMsIGNiKVxufVxuXG4vLyBDb252ZXJ0cyBhIHByb3RvYnVmIHNlcmlhbGl6ZWQgcHVibGljIGtleSBpbnRvIGl0c1xuLy8gcmVwcmVzZW50YXRpdmUgb2JqZWN0XG5leHBvcnRzLnVubWFyc2hhbFB1YmxpY0tleSA9IChidWYpID0+IHtcbiAgY29uc3QgZGVjb2RlZCA9IGtleXNQQk0uUHVibGljS2V5LmRlY29kZShidWYpXG4gIGNvbnN0IGRhdGEgPSBkZWNvZGVkLkRhdGFcblxuICBzd2l0Y2ggKGRlY29kZWQuVHlwZSkge1xuICAgIGNhc2Uga2V5c1BCTS5LZXlUeXBlLlJTQTpcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnJzYS51bm1hcnNoYWxSc2FQdWJsaWNLZXkoZGF0YSlcbiAgICBjYXNlIGtleXNQQk0uS2V5VHlwZS5FZDI1NTE5OlxuICAgICAgcmV0dXJuIHN1cHBvcnRlZEtleXMuZWQyNTUxOS51bm1hcnNoYWxFZDI1NTE5UHVibGljS2V5KGRhdGEpXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuU2VjcDI1NmsxOlxuICAgICAgaWYgKHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQdWJsaWNLZXkoZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VjcDI1NmsxIHN1cHBvcnQgcmVxdWlyZXMgbGlicDJwLWNyeXB0by1zZWNwMjU2azEgcGFja2FnZScpXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvciB1bnN1cHBvcnRlZCBrZXkgdHlwZScpXG4gIH1cbn1cblxuLy8gQ29udmVydHMgYSBwdWJsaWMga2V5IG9iamVjdCBpbnRvIGEgcHJvdG9idWYgc2VyaWFsaXplZCBwdWJsaWMga2V5XG5leHBvcnRzLm1hcnNoYWxQdWJsaWNLZXkgPSAoa2V5LCB0eXBlKSA9PiB7XG4gIHR5cGUgPSAodHlwZSB8fCAncnNhJykudG9Mb3dlckNhc2UoKVxuICBpZiAoIWlzVmFsaWRLZXlUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGtleSB0eXBlJylcbiAgfVxuXG4gIHJldHVybiBrZXkuYnl0ZXNcbn1cblxuLy8gQ29udmVydHMgYSBwcm90b2J1ZiBzZXJpYWxpemVkIHByaXZhdGUga2V5IGludG8gaXRzXG4vLyByZXByZXNlbnRhdGl2ZSBvYmplY3RcbmV4cG9ydHMudW5tYXJzaGFsUHJpdmF0ZUtleSA9IChidWYsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCBkZWNvZGVkXG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGtleXNQQk0uUHJpdmF0ZUtleS5kZWNvZGUoYnVmKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICB9XG5cbiAgY29uc3QgZGF0YSA9IGRlY29kZWQuRGF0YVxuXG4gIHN3aXRjaCAoZGVjb2RlZC5UeXBlKSB7XG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuUlNBOlxuICAgICAgcmV0dXJuIHN1cHBvcnRlZEtleXMucnNhLnVubWFyc2hhbFJzYVByaXZhdGVLZXkoZGF0YSwgY2FsbGJhY2spXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuRWQyNTUxOTpcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLmVkMjU1MTkudW5tYXJzaGFsRWQyNTUxOVByaXZhdGVLZXkoZGF0YSwgY2FsbGJhY2spXG4gICAgY2FzZSBrZXlzUEJNLktleVR5cGUuU2VjcDI1NmsxOlxuICAgICAgaWYgKHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS51bm1hcnNoYWxTZWNwMjU2azFQcml2YXRlS2V5KGRhdGEsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignc2VjcDI1NmsxIHN1cHBvcnQgcmVxdWlyZXMgbGlicDJwLWNyeXB0by1zZWNwMjU2azEgcGFja2FnZScpKVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQga2V5IHR5cGUnKSlcbiAgfVxufVxuXG4vLyBDb252ZXJ0cyBhIHByaXZhdGUga2V5IG9iamVjdCBpbnRvIGEgcHJvdG9idWYgc2VyaWFsaXplZCBwcml2YXRlIGtleVxuZXhwb3J0cy5tYXJzaGFsUHJpdmF0ZUtleSA9IChrZXksIHR5cGUpID0+IHtcbiAgdHlwZSA9ICh0eXBlIHx8ICdyc2EnKS50b0xvd2VyQ2FzZSgpXG4gIGlmICghaXNWYWxpZEtleVR5cGUodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQga2V5IHR5cGUnKVxuICB9XG5cbiAgcmV0dXJuIGtleS5ieXRlc1xufVxuXG5leHBvcnRzLmltcG9ydCA9IChwZW0sIHBhc3N3b3JkLCBjYWxsYmFjaykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGZvcmdlLnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleShwZW0sIHBhc3N3b3JkKVxuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgdGhlIGtleSwgbW9zdCBsaWtlbHkgdGhlIHBhc3N3b3JkIGlzIHdyb25nIG9yIG5vdCBhIFJTQSBrZXknKVxuICAgIH1cbiAgICBsZXQgZGVyID0gZm9yZ2UuYXNuMS50b0Rlcihmb3JnZS5wa2kucHJpdmF0ZUtleVRvQXNuMShrZXkpKVxuICAgIGRlciA9IEJ1ZmZlci5mcm9tKGRlci5nZXRCeXRlcygpLCAnYmluYXJ5JylcbiAgICByZXR1cm4gc3VwcG9ydGVkS2V5cy5yc2EudW5tYXJzaGFsUnNhUHJpdmF0ZUtleShkZXIsIGNhbGxiYWNrKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmZpcnN0ID0gYXN5bmMgKGl0ZXJhdG9yKSA9PiB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG5leHBvcnRzLmxhc3QgPSBhc3luYyAoaXRlcmF0b3IpID0+IHtcbiAgbGV0IHZhbHVlXG4gIGZvciBhd2FpdCAodmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmV4cG9ydHMuYWxsID0gYXN5bmMgKGl0ZXJhdG9yKSA9PiB7XG4gIGNvbnN0IHZhbHVlcyA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVzXG59XG5cbmV4cG9ydHMuZXh0ZW5kSXRlcmF0b3IgPSAoaXRlcmF0b3IpID0+IHtcbiAgaXRlcmF0b3IuZmlyc3QgPSAoKSA9PiBleHBvcnRzLmZpcnN0KGl0ZXJhdG9yKVxuICBpdGVyYXRvci5sYXN0ID0gKCkgPT4gZXhwb3J0cy5sYXN0KGl0ZXJhdG9yKVxuICBpdGVyYXRvci5hbGwgPSAoKSA9PiBleHBvcnRzLmFsbChpdGVyYXRvcilcbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5EQUdOb2RlID0gcmVxdWlyZSgnLi9kYWctbm9kZScpXG5leHBvcnRzLkRBR0xpbmsgPSByZXF1aXJlKCcuL2RhZy1saW5rJylcblxuLypcbiAqIEZ1bmN0aW9ucyB0byBmdWxmaWwgSVBMRCBGb3JtYXQgaW50ZXJmYWNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaXBsZC9pbnRlcmZhY2UtaXBsZC1mb3JtYXRcbiAqL1xuZXhwb3J0cy5yZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXInKVxuZXhwb3J0cy51dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmV4cG9ydHMuY29kZWMgPSBleHBvcnRzLnV0aWwuY29kZWNcbmV4cG9ydHMuZGVmYXVsdEhhc2hBbGcgPSBleHBvcnRzLnV0aWwuZGVmYXVsdEhhc2hBbGdcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKVxuZXhwb3J0cy5yZXNvbHZlciA9IHJlcXVpcmUoJy4vcmVzb2x2ZXIuanMnKVxuZXhwb3J0cy5jb2RlYyA9IGV4cG9ydHMudXRpbC5jb2RlY1xuZXhwb3J0cy5kZWZhdWx0SGFzaEFsZyA9IGV4cG9ydHMudXRpbC5kZWZhdWx0SGFzaEFsZ1xuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IG11bHRpaGFzaGluZyA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG5cbi8vIGJpbmFyeSByZXNvbHZlclxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvZGVjOiBtdWx0aWNvZGVjLlJBVyxcbiAgZGVmYXVsdEhhc2hBbGc6IG11bHRpY29kZWMuU0hBMl8yNTYsXG4gIHJlc29sdmVyOiB7XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBwYXRoIHdpdGhpbiBhIFJhdyBibG9jay5cbiAgICAgKlxuICAgICAqIEFsd2F5cyByZXR1cm5zIHRoZSByYXcgZGF0YSBhcyB2YWx1ZSB3aXRob3V0IGFueSByZW1haW5kZXJQYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJpbmFyeUJsb2IgLSBCaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgYSBQQiBibG9ja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aD0nLyddIC0gUGF0aCB0aGF0IHNob3VsZCBiZSByZXNvbHZlZCAodGhhdCB2YWx1ZSBpcyBpZ25vcmVkKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCAtIFJlc3VsdCBvZiB0aGUgcGF0aCBpdCBpdCB3YXMgcmVzb2x2ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICogQHJldHVybnMgeyp9IHJlc3VsdC52YWx1ZSAtIFRoZSByYXcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJlc3VsdC5yZW1haW5kZXJQYXRoIC0gQW4gZW1wdHkgc3RyaW5nXG4gICAgICovXG4gICAgcmVzb2x2ZTogKGJpbmFyeUJsb2IsIHBhdGgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBiaW5hcnlCbG9iLFxuICAgICAgICByZW1haW5kZXJQYXRoOiAnJ1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBhdmFpbGFibGUgcGF0aHMgb2YgYSBibG9jay5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0b3JcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYmluYXJ5QmxvYiAtIFRoZSByYXcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gRmluaXNoZWQgZ2VuZXJhdG9yIHdpdGggYGRvbmU6IHRydWVgXG4gICAgICovXG4gICAgdHJlZTogKGJpbmFyeUJsb2IpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHV0aWw6IHtcbiAgICBkZXNlcmlhbGl6ZTogKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSxcbiAgICBzZXJpYWxpemU6IChkYXRhKSA9PiB7XG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBDSUQgb2YgdGhlIGJpbmFyeSBibG9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJpbmFyeUJsb2IgLSBFbmNvZGVkIElQTEQgTm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlck9wdGlvbnNdIC0gT3B0aW9ucyB0byBjcmVhdGUgdGhlIENJRFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXNlck9wdGlvbnMuY2lkVmVyc2lvbj0xXSAtIENJRCB2ZXJzaW9uIG51bWJlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbVXNlck9wdGlvbnMuaGFzaEFsZ10gLSBEZWZhdWx0cyB0byB0aGUgZGVmYXVsdEhhc2hBbGcgb2YgdGhlIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxDSUQ+fVxuICAgICAqL1xuICAgIGNpZDogYXN5bmMgKGJpbmFyeUJsb2IsIHVzZXJPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHsgY2lkVmVyc2lvbjogMSwgaGFzaEFsZzogbW9kdWxlLmV4cG9ydHMuZGVmYXVsdEhhc2hBbGcgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKVxuXG4gICAgICBjb25zdCBtdWx0aWhhc2ggPSBhd2FpdCBtdWx0aWhhc2hpbmcoYmluYXJ5QmxvYiwgb3B0aW9ucy5oYXNoQWxnKVxuICAgICAgY29uc3QgY29kZWNOYW1lID0gbXVsdGljb2RlYy5wcmludFttb2R1bGUuZXhwb3J0cy5jb2RlY11cbiAgICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQob3B0aW9ucy5jaWRWZXJzaW9uLCBjb2RlY05hbWUsIG11bHRpaGFzaClcblxuICAgICAgcmV0dXJuIGNpZFxuICAgIH1cbiAgfVxufVxuIiwiLyoqIFBST01JU0lGWSBDQUxMQkFDSy1TVFlMRSBGVU5DVElPTlMgVE8gRVM2IFBST01JU0VTXHJcbipcclxuKiBFWEFNUExFOlxyXG4qIGNvbnN0IGZuID0gcHJvbWlzaWZ5KCAoY2FsbGJhY2spID0+IGNhbGxiYWNrKG51bGwsIFwiSGVsbG8gd29ybGQhXCIpICk7XHJcbiogZm4oKGVyciwgc3RyKSA9PiBjb25zb2xlLmxvZyhzdHIpKTtcclxuKiBmbigpLnRoZW4oKHN0cikgPT4gY29uc29sZS5sb2coc3RyKSk7XHJcbiogLy9Cb3RoIGZ1bmN0aW9ucywgd2lsbCBsb2cgJ0hlbGxvIHdvcmxkISdcclxuKlxyXG4qIE5vdGU6IFRoZSBmdW5jdGlvbiB5b3UgcGFzcywgbWF5IGhhdmUgYW55IGFyZ3VtZW50cyB5b3Ugd2FudCwgYnV0IHRoZSBsYXRlc3RcclxuKiBoYXZlIHRvIGJlIHRoZSBjYWxsYmFjaywgd2hpY2ggeW91IHdpbGwgY2FsbCB3aXRoOiBuZXh0KGVyciwgdmFsdWUpXHJcbipcclxuKiBAcGFyYW0gbWV0aG9kOiBGdW5jdGlvbi9BcnJheS9NYXAgPSBUaGUgZnVuY3Rpb24ocykgdG8gcHJvbWlzaWZ5XHJcbiogQHBhcmFtIG9wdGlvbnM6IE1hcCA9XHJcbiogIFwiY29udGV4dFwiIChkZWZhdWx0IGlzIGZ1bmN0aW9uKTogVGhlIGNvbnRleHQgd2hpY2ggdG8gYXBwbHkgdGhlIGNhbGxlZCBmdW5jdGlvblxyXG4qICBcInJlcGxhY2VcIiAoZGVmYXVsdCBpcyBmYWxzeSk6IFdoZW4gcGFzc2VkIGFuIGFycmF5L21hcCwgaWYgdG8gcmVwbGFjZSB0aGUgb3JpZ2luYWwgb2JqZWN0XHJcbipcclxuKiBAcmV0dXJuOiBBIHByb21pc2UgaWYgcGFzc2VkIGEgZnVuY3Rpb24sIG90aGVyd2lzZSB0aGUgb2JqZWN0IHdpdGggdGhlIHByb21pc2VzXHJcbipcclxuKiBAbGljZW5zZTogTUlUXHJcbiogQHZlcnNpb246IDEuMC4zXHJcbiogQGF1dGhvcjogTWFudWVsIERpIElvcmlvXHJcbioqL1xyXG5cclxudmFyIGNyZWF0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGFyZ3MubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbGFzdEFyZyA9IGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwID8gYXJnc1tsYXN0SW5kZXhdIDogbnVsbDtcclxuICAgICAgICB2YXIgY2IgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3RBcmcgOiBudWxsO1xyXG5cclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZSA9IHt9OyAvLyBCcm93c2VyaWZ5IHRoaXMgbW9kdWxlXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2RzLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1ldGhvZHMpO1xyXG5cclxuICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiIHx8IHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xyXG4gICAgICAgIHZhciBvYmogPSBvcHRpb25zLnJlcGxhY2UgPyBtZXRob2RzIDoge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KGtleSkpIG9ialtrZXldID0gY3JlYXRlQ2FsbGJhY2sobWV0aG9kc1trZXldKTtcclxuICAgICAgICB9cmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3JlYXRlQ2FsbGJhY2sobWV0aG9kcywgb3B0aW9ucy5jb250ZXh0IHx8IG1ldGhvZHMpO1xyXG59O1xyXG5cclxuLy8gQnJvd3NlcmlmeSB0aGlzIG1vZHVsZVxyXG5pZiAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHRoaXNbXCJwcm9taXNpZnlcIl0gPSBtb2R1bGUuZXhwb3J0cztcclxufVxyXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwudHlwaWNhbCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRm9yIHR5cGUtY2hlY2tpbmcgSmF2YXNjcmlwdCB2YWx1ZXMuXG4gICAqIEBtb2R1bGUgdHlwaWNhbFxuICAgKiBAdHlwaWNhbG5hbWUgdFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB0ID0gcmVxdWlyZSgndHlwaWNhbCcpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaW5wdXQgaXMgYSBudW1iZXJcbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqID4gdC5pc051bWJlcigwKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc051bWJlcigxKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc051bWJlcigxLjEpXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKDB4ZmYpXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKDA2NDQpXG4gICAqIHRydWVcbiAgICogPiB0LmlzTnVtYmVyKDYuMmU1KVxuICAgKiB0cnVlXG4gICAqID4gdC5pc051bWJlcihOYU4pXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc051bWJlcihJbmZpbml0eSlcbiAgICogZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzTnVtYmVyIChuKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcGxhaW4gb2JqZWN0IGlzIGEgc2ltcGxlIG9iamVjdCBsaXRlcmFsLCBpdCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBgdHlwZW9mYCBpcyBgb2JqZWN0YCBhbmQgZGlyZWN0bHkgZGVjZW5kcyBmcm9tIGBPYmplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoeyBzb21ldGhpbmc6ICdvbmUnIH0pXG4gICAqIHRydWVcbiAgICogPiB0LmlzUGxhaW5PYmplY3QobmV3IERhdGUoKSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoWyAwLCAxIF0pXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc1BsYWluT2JqZWN0KC90ZXN0LylcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoMSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzUGxhaW5PYmplY3QoJ29uZScpXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc1BsYWluT2JqZWN0KG51bGwpXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc1BsYWluT2JqZWN0KChmdW5jdGlvbiAqICgpIHt9KSgpKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNQbGFpbk9iamVjdChmdW5jdGlvbiAqICgpIHt9KVxuICAgKiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXktbGlrZSB2YWx1ZSBoYXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIGFycmF5LCBidXQgaXMgbm90IGFuIGFycmF5IGluc3RhbmNlLiBFeGFtcGxlcyBpbiB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGFuIG9iamVjdCwgbm90IG51bGwgYW5kIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IHdpdGggYSBudW1lcmljIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogZnVuY3Rpb24gc3VtKHgsIHkpe1xuICAgKiAgIGNvbnNvbGUubG9nKHQuaXNBcnJheUxpa2UoYXJndW1lbnRzKSlcbiAgICogICAvLyBwcmludHMgYHRydWVgXG4gICAqIH1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlIChpbnB1dCkge1xuICAgIHJldHVybiBpc09iamVjdChpbnB1dCkgJiYgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gJ251bWJlcidcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR5cGVvZiBpbnB1dCBpcyBgJ29iamVjdCdgIGJ1dCBub3QgbnVsbC5cbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCAoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCAhPT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgZGVmaW5lZC5cbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBmdW5jdGlvbiBpc0RlZmluZWQgKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCAhPT0gJ3VuZGVmaW5lZCdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGFuIEVTMjAxNSBgY2xhc3NgLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzQ2xhc3MgKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIC9eY2xhc3MgLy50ZXN0KEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYSBzdHJpbmcsIG51bWJlciwgc3ltYm9sLCBib29sZWFuLCBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBmdW5jdGlvbiBpc1ByaW1pdGl2ZSAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHJldHVybiB0cnVlXG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXQpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIGEgUHJvbWlzZS5cbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBmdW5jdGlvbiBpc1Byb21pc2UgKGlucHV0KSB7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBjb25zdCBpc1Byb21pc2UgPSBpc0RlZmluZWQoUHJvbWlzZSkgJiYgaW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgICAgY29uc3QgaXNUaGVuYWJsZSA9IGlucHV0LnRoZW4gJiYgdHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbic7XG4gICAgICByZXR1cm4gISEoaXNQcm9taXNlIHx8IGlzVGhlbmFibGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIGFuIGl0ZXJhYmxlIChgTWFwYCwgYFNldGAsIGBBcnJheWAsIEdlbmVyYXRvciBldGMuKS5cbiAgICogQHBhcmFtIHsqfSAtIHRoZSBpbnB1dCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqID4gdC5pc0l0ZXJhYmxlKCdzdHJpbmcnKVxuICAgKiB0cnVlXG4gICAqID4gdC5pc0l0ZXJhYmxlKG5ldyBNYXAoKSlcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNJdGVyYWJsZShbXSlcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNJdGVyYWJsZSgoZnVuY3Rpb24gKiAoKSB7fSkoKSlcbiAgICogdHJ1ZVxuICAgKiA+IHQuaXNJdGVyYWJsZShQcm9taXNlLnJlc29sdmUoKSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoUHJvbWlzZSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUodHJ1ZSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoe30pXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc0l0ZXJhYmxlKDApXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc0l0ZXJhYmxlKDEuMSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoTmFOKVxuICAgKiBmYWxzZVxuICAgKiA+IHQuaXNJdGVyYWJsZShJbmZpbml0eSlcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoZnVuY3Rpb24gKCkge30pXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc0l0ZXJhYmxlKERhdGUpXG4gICAqIGZhbHNlXG4gICAqID4gdC5pc0l0ZXJhYmxlKClcbiAgICogZmFsc2VcbiAgICogPiB0LmlzSXRlcmFibGUoeyB0aGVuOiBmdW5jdGlvbiAoKSB7fSB9KVxuICAgKiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNJdGVyYWJsZSAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgIWlzRGVmaW5lZChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSBzdHJpbmcuIFRoZSBlcXVpdmFsZW50IG9mIGB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnYGAgZm9yIHVzZSBpbiBmdW5jaXRvbmFsIGNvbnRleHRzLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzU3RyaW5nIChpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLiBUaGUgZXF1aXZhbGVudCBvZiBgdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nYGAgZm9yIHVzZSBpbiBmdW5jaXRvbmFsIGNvbnRleHRzLlxuICAgKiBAcGFyYW0geyp9IC0gdGhlIGlucHV0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICB9XG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIGlzTnVtYmVyLFxuICAgIGlzUGxhaW5PYmplY3QsXG4gICAgaXNBcnJheUxpa2UsXG4gICAgaXNPYmplY3QsXG4gICAgaXNEZWZpbmVkLFxuICAgIGlzQ2xhc3MsXG4gICAgaXNQcmltaXRpdmUsXG4gICAgaXNQcm9taXNlLFxuICAgIGlzSXRlcmFibGUsXG4gICAgaXNTdHJpbmcsXG4gICAgaXNGdW5jdGlvblxuICB9O1xuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IGluZGV4O1xuICBleHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gIGV4cG9ydHMuaXNDbGFzcyA9IGlzQ2xhc3M7XG4gIGV4cG9ydHMuaXNEZWZpbmVkID0gaXNEZWZpbmVkO1xuICBleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICBleHBvcnRzLmlzSXRlcmFibGUgPSBpc0l0ZXJhYmxlO1xuICBleHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gIGV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbiAgZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuICBleHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbiAgZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IHdpdGhJcyA9IHJlcXVpcmUoJ2NsYXNzLWlzJylcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGltbXV0YWJsZSBibG9jayBvZiBkYXRhIHRoYXQgaXMgdW5pcXVlbHkgcmVmZXJlbmNlZCB3aXRoIGEgY2lkLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgLSBUaGUgZGF0YSB0byBiZSBzdG9yZWQgaW4gdGhlIGJsb2NrIGFzIGEgYnVmZmVyLlxuICogQHBhcmFtIHtDSUR9IGNpZCAtIFRoZSBjaWQgb2YgdGhlIGRhdGFcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYmxvY2sgPSBuZXcgQmxvY2sobmV3IEJ1ZmZlcignYTAxMmQ4M2IyMGY5MzcxLi4uJykpXG4gKi9cbmNsYXNzIEJsb2NrIHtcbiAgY29uc3RydWN0b3IgKGRhdGEsIGNpZCkge1xuICAgIGlmICghZGF0YSB8fCAhQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50ICBtdXN0IGJlIGEgYnVmZmVyJylcbiAgICB9XG5cbiAgICBpZiAoIWNpZCB8fCAhQ0lELmlzQ0lEKGNpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBDSUQnKVxuICAgIH1cblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgdGhpcy5fY2lkID0gY2lkXG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgb2YgdGhpcyBibG9jay5cbiAgICpcbiAgICogQHR5cGUge0J1ZmZlcn1cbiAgICovXG4gIGdldCBkYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG5cbiAgc2V0IGRhdGEgKHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY2hhbmdlIGFuIGltbXV0YWJsZSBibG9jaycpXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNpZCBvZiB0aGUgZGF0YSB0aGlzIGJsb2NrIHJlcHJlc2VudHMuXG4gICAqXG4gICAqIEB0eXBlIHtDSUR9XG4gICAqL1xuICBnZXQgY2lkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2lkXG4gIH1cblxuICBzZXQgY2lkICh2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNoYW5nZSBhbiBpbW11dGFibGUgYmxvY2snKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aElzKEJsb2NrLCB7IGNsYXNzTmFtZTogJ0Jsb2NrJywgc3ltYm9sTmFtZTogJ0BpcGZzL2pzLWlwZnMtYmxvY2svYmxvY2snIH0pXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBiYXNlMTYgPSByZXF1aXJlKCcuL2Jhc2UxNicpXG5jb25zdCBiYXNlMzIgPSByZXF1aXJlKCcuL2Jhc2UzMicpXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpXG5cbi8vIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2Jhc2UxJywgJzEnLCAnJywgJzEnXSxcbiAgWydiYXNlMicsICcwJywgYmFzZVgsICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCBiYXNlWCwgJzAxMjM0NTY3J10sXG4gIFsnYmFzZTEwJywgJzknLCBiYXNlWCwgJzAxMjM0NTY3ODknXSxcbiAgWydiYXNlMTYnLCAnZicsIGJhc2UxNiwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMzInLCAnYicsIGJhc2UzMiwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCBiYXNlMzIsICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIGJhc2UzMiwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4cGFkJywgJ3QnLCBiYXNlMzIsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCBiYXNlMzIsICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OSddLFxuICBbJ2Jhc2U1OGZsaWNrcicsICdaJywgYmFzZVgsICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNjQnLCAnbScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIGJhc2U2NCwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J10sXG4gIFsnYmFzZTY0dXJsJywgJ3UnLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCBiYXNlNjQsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzOiBuYW1lcyxcbiAgY29kZXM6IGNvZGVzXG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gUHJvdG9jb2xzIChwcm90bykge1xuICBpZiAodHlwZW9mIChwcm90bykgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKFByb3RvY29scy5jb2Rlc1twcm90b10pIHtcbiAgICAgIHJldHVybiBQcm90b2NvbHMuY29kZXNbcHJvdG9dXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcm90b2NvbCB3aXRoIGNvZGU6ICcgKyBwcm90bylcbiAgfSBlbHNlIGlmICh0eXBlb2YgKHByb3RvKSA9PT0gJ3N0cmluZycgfHwgcHJvdG8gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBpZiAoUHJvdG9jb2xzLm5hbWVzW3Byb3RvXSkge1xuICAgICAgcmV0dXJuIFByb3RvY29scy5uYW1lc1twcm90b11cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3RvY29sIHdpdGggbmFtZTogJyArIHByb3RvKVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByb3RvY29sIGlkIHR5cGU6ICcgKyBwcm90bylcbn1cblxuY29uc3QgViA9IC0xXG5Qcm90b2NvbHMubGVuZ3RoUHJlZml4ZWRWYXJTaXplID0gVlxuUHJvdG9jb2xzLlYgPSBWXG5cblByb3RvY29scy50YWJsZSA9IFtcbiAgWzQsIDMyLCAnaXA0J10sXG4gIFs2LCAxNiwgJ3RjcCddLFxuICBbMzMsIDE2LCAnZGNjcCddLFxuICBbNDEsIDEyOCwgJ2lwNiddLFxuICBbNDIsIFYsICdpcDZ6b25lJ10sXG4gIFs1MywgViwgJ2RucycsICdyZXNvbHZhYmxlJ10sXG4gIFs1NCwgViwgJ2RuczQnLCAncmVzb2x2YWJsZSddLFxuICBbNTUsIFYsICdkbnM2JywgJ3Jlc29sdmFibGUnXSxcbiAgWzU2LCBWLCAnZG5zYWRkcicsICdyZXNvbHZhYmxlJ10sXG4gIFsxMzIsIDE2LCAnc2N0cCddLFxuICBbMjczLCAxNiwgJ3VkcCddLFxuICBbMjc1LCAwLCAncDJwLXdlYnJ0Yy1zdGFyJ10sXG4gIFsyNzYsIDAsICdwMnAtd2VicnRjLWRpcmVjdCddLFxuICBbMjc3LCAwLCAncDJwLXN0YXJkdXN0J10sXG4gIFsyOTAsIDAsICdwMnAtY2lyY3VpdCddLFxuICBbMzAxLCAwLCAndWR0J10sXG4gIFszMDIsIDAsICd1dHAnXSxcbiAgWzQwMCwgViwgJ3VuaXgnLCBmYWxzZSwgJ3BhdGgnXSxcbiAgLy8gYHAycGAgaXMgdGhlIHByZWZlcnJlZCBuYW1lIGZvciA0MjFcbiAgWzQyMSwgViwgJ3AycCddLFxuICAvLyBgaXBmc2AgaGFzIGJlZW4gYWRkZWQgYWZ0ZXIgYHAycGAgc28gdGhhdCBpdCBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdG8gcHJvdmlkZSBiZXR0ZXIgYmFja3dhcmRzIHN1cHBvcnQgZm9yXG4gIC8vIGNvZGUgYmFzZXMgdGhhdCBkbyBub3QgeWV0IHN1cHBvcnQgdGhlIGBwMnBgIHByb3RvIG5hbWUuIEV2ZW50dWFsbHlcbiAgLy8gYHAycGAgc2hvdWxkIGJlY29tZSB0aGUgZGVmYXVsdC5cbiAgWzQyMSwgViwgJ2lwZnMnXSxcbiAgWzQ0MywgMCwgJ2h0dHBzJ10sXG4gIFs0NDQsIDk2LCAnb25pb24nXSxcbiAgWzQ0NSwgMjk2LCAnb25pb24zJ10sXG4gIFs0NDYsIFYsICdnYXJsaWM2NCddLFxuICBbNDYwLCAwLCAncXVpYyddLFxuICBbNDc3LCAwLCAnd3MnXSxcbiAgWzQ3OCwgMCwgJ3dzcyddLFxuICBbNDc5LCAwLCAncDJwLXdlYnNvY2tldC1zdGFyJ10sXG4gIFs0ODAsIDAsICdodHRwJ11cbl1cblxuUHJvdG9jb2xzLm5hbWVzID0ge31cblByb3RvY29scy5jb2RlcyA9IHt9XG5cbi8vIHBvcHVsYXRlIHRhYmxlc1xuUHJvdG9jb2xzLnRhYmxlLm1hcChyb3cgPT4ge1xuICBjb25zdCBwcm90byA9IHAuYXBwbHkobnVsbCwgcm93KVxuICBQcm90b2NvbHMuY29kZXNbcHJvdG8uY29kZV0gPSBwcm90b1xuICBQcm90b2NvbHMubmFtZXNbcHJvdG8ubmFtZV0gPSBwcm90b1xufSlcblxuUHJvdG9jb2xzLm9iamVjdCA9IHBcblxuZnVuY3Rpb24gcCAoY29kZSwgc2l6ZSwgbmFtZSwgcmVzb2x2YWJsZSwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIGNvZGU6IGNvZGUsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJlc29sdmFibGU6IEJvb2xlYW4ocmVzb2x2YWJsZSksXG4gICAgcGF0aDogQm9vbGVhbihwYXRoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG9jb2xzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpXG5jb25zdCBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scy10YWJsZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG4vLyBleHBvcnQgY29kZWNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmdUb1N0cmluZ1R1cGxlczogc3RyaW5nVG9TdHJpbmdUdXBsZXMsXG4gIHN0cmluZ1R1cGxlc1RvU3RyaW5nOiBzdHJpbmdUdXBsZXNUb1N0cmluZyxcblxuICB0dXBsZXNUb1N0cmluZ1R1cGxlczogdHVwbGVzVG9TdHJpbmdUdXBsZXMsXG4gIHN0cmluZ1R1cGxlc1RvVHVwbGVzOiBzdHJpbmdUdXBsZXNUb1R1cGxlcyxcblxuICBidWZmZXJUb1R1cGxlczogYnVmZmVyVG9UdXBsZXMsXG4gIHR1cGxlc1RvQnVmZmVyOiB0dXBsZXNUb0J1ZmZlcixcblxuICBidWZmZXJUb1N0cmluZzogYnVmZmVyVG9TdHJpbmcsXG4gIHN0cmluZ1RvQnVmZmVyOiBzdHJpbmdUb0J1ZmZlcixcblxuICBmcm9tU3RyaW5nOiBmcm9tU3RyaW5nLFxuICBmcm9tQnVmZmVyOiBmcm9tQnVmZmVyLFxuICB2YWxpZGF0ZUJ1ZmZlcjogdmFsaWRhdGVCdWZmZXIsXG4gIGlzVmFsaWRCdWZmZXI6IGlzVmFsaWRCdWZmZXIsXG4gIGNsZWFuUGF0aDogY2xlYW5QYXRoLFxuXG4gIFBhcnNlRXJyb3I6IFBhcnNlRXJyb3IsXG4gIHByb3RvRnJvbVR1cGxlOiBwcm90b0Zyb21UdXBsZSxcblxuICBzaXplRm9yQWRkcjogc2l6ZUZvckFkZHJcbn1cblxuLy8gc3RyaW5nIC0+IFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdXG5mdW5jdGlvbiBzdHJpbmdUb1N0cmluZ1R1cGxlcyAoc3RyKSB7XG4gIGNvbnN0IHR1cGxlcyA9IFtdXG4gIGNvbnN0IHBhcnRzID0gc3RyLnNwbGl0KCcvJykuc2xpY2UoMSkgLy8gc2tpcCBmaXJzdCBlbXB0eSBlbGVtXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEgJiYgcGFydHNbMF0gPT09ICcnKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBmb3IgKGxldCBwID0gMDsgcCA8IHBhcnRzLmxlbmd0aDsgcCsrKSB7XG4gICAgY29uc3QgcGFydCA9IHBhcnRzW3BdXG4gICAgY29uc3QgcHJvdG8gPSBwcm90b2NvbHMocGFydClcblxuICAgIGlmIChwcm90by5zaXplID09PSAwKSB7XG4gICAgICB0dXBsZXMucHVzaChbcGFydF0pXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHArKyAvLyBhZHZhbmNlIGFkZHIgcGFydFxuICAgIGlmIChwID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgUGFyc2VFcnJvcignaW52YWxpZCBhZGRyZXNzOiAnICsgc3RyKVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3MgYSBwYXRoIHByb3RvLCB0YWtlIHRoZSByZXN0XG4gICAgaWYgKHByb3RvLnBhdGgpIHtcbiAgICAgIHR1cGxlcy5wdXNoKFtcbiAgICAgICAgcGFydCxcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIG5lZWQgdG8gY2hlY2sgZWFjaCBwYXRoIHBhcnQgdG8gc2VlIGlmIGl0J3MgYSBwcm90bz9cbiAgICAgICAgLy8gVGhpcyB3b3VsZCBhbGxvdyBmb3Igb3RoZXIgcHJvdG9jb2xzIHRvIGJlIGFkZGVkIGFmdGVyIGEgdW5peCBwYXRoLFxuICAgICAgICAvLyBob3dldmVyIGl0IHdvdWxkIGhhdmUgaXNzdWVzIGlmIHRoZSBwYXRoIGhhZCBhIHByb3RvY29sIG5hbWUgaW4gdGhlIHBhdGhcbiAgICAgICAgY2xlYW5QYXRoKHBhcnRzLnNsaWNlKHApLmpvaW4oJy8nKSlcbiAgICAgIF0pXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHR1cGxlcy5wdXNoKFtwYXJ0LCBwYXJ0c1twXV0pXG4gIH1cblxuICByZXR1cm4gdHVwbGVzXG59XG5cbi8vIFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdIC0+IHN0cmluZ1xuZnVuY3Rpb24gc3RyaW5nVHVwbGVzVG9TdHJpbmcgKHR1cGxlcykge1xuICBjb25zdCBwYXJ0cyA9IFtdXG4gIHR1cGxlcy5tYXAodHVwID0+IHtcbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBwYXJ0cy5wdXNoKHByb3RvLm5hbWUpXG4gICAgaWYgKHR1cC5sZW5ndGggPiAxKSB7XG4gICAgICBwYXJ0cy5wdXNoKHR1cFsxXSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGNsZWFuUGF0aChwYXJ0cy5qb2luKCcvJykpXG59XG5cbi8vIFtbc3RyIG5hbWUsIHN0ciBhZGRyXS4uLiBdIC0+IFtbaW50IGNvZGUsIEJ1ZmZlcl0uLi4gXVxuZnVuY3Rpb24gc3RyaW5nVHVwbGVzVG9UdXBsZXMgKHR1cGxlcykge1xuICByZXR1cm4gdHVwbGVzLm1hcCh0dXAgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0dXApKSB7XG4gICAgICB0dXAgPSBbdHVwXVxuICAgIH1cbiAgICBjb25zdCBwcm90byA9IHByb3RvRnJvbVR1cGxlKHR1cClcbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBbcHJvdG8uY29kZSwgY29udmVydC50b0J1ZmZlcihwcm90by5jb2RlLCB0dXBbMV0pXVxuICAgIH1cbiAgICByZXR1cm4gW3Byb3RvLmNvZGVdXG4gIH0pXG59XG5cbi8vIFtbaW50IGNvZGUsIEJ1ZmZlcl0uLi4gXSAtPiBbW3N0ciBuYW1lLCBzdHIgYWRkcl0uLi4gXVxuZnVuY3Rpb24gdHVwbGVzVG9TdHJpbmdUdXBsZXMgKHR1cGxlcykge1xuICByZXR1cm4gdHVwbGVzLm1hcCh0dXAgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gcHJvdG9Gcm9tVHVwbGUodHVwKVxuICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIFtwcm90by5jb2RlLCBjb252ZXJ0LnRvU3RyaW5nKHByb3RvLmNvZGUsIHR1cFsxXSldXG4gICAgfVxuICAgIHJldHVybiBbcHJvdG8uY29kZV1cbiAgfSlcbn1cblxuLy8gW1tpbnQgY29kZSwgQnVmZmVyIF0uLi4gXSAtPiBCdWZmZXJcbmZ1bmN0aW9uIHR1cGxlc1RvQnVmZmVyICh0dXBsZXMpIHtcbiAgcmV0dXJuIGZyb21CdWZmZXIoQnVmZmVyLmNvbmNhdCh0dXBsZXMubWFwKHR1cCA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBwcm90b0Zyb21UdXBsZSh0dXApXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHZhcmludC5lbmNvZGUocHJvdG8uY29kZSkpXG5cbiAgICBpZiAodHVwLmxlbmd0aCA+IDEpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgdHVwWzFdXSkgLy8gYWRkIGFkZHJlc3MgYnVmZmVyXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9KSkpXG59XG5cbmZ1bmN0aW9uIHNpemVGb3JBZGRyIChwLCBhZGRyKSB7XG4gIGlmIChwLnNpemUgPiAwKSB7XG4gICAgcmV0dXJuIHAuc2l6ZSAvIDhcbiAgfSBlbHNlIGlmIChwLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpemUgPSB2YXJpbnQuZGVjb2RlKGFkZHIpXG4gICAgcmV0dXJuIHNpemUgKyB2YXJpbnQuZGVjb2RlLmJ5dGVzXG4gIH1cbn1cblxuLy8gQnVmZmVyIC0+IFtbaW50IGNvZGUsIEJ1ZmZlciBdLi4uIF1cbmZ1bmN0aW9uIGJ1ZmZlclRvVHVwbGVzIChidWYpIHtcbiAgY29uc3QgdHVwbGVzID0gW11cbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgYnVmLmxlbmd0aCkge1xuICAgIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZiwgaSlcbiAgICBjb25zdCBuID0gdmFyaW50LmRlY29kZS5ieXRlc1xuXG4gICAgY29uc3QgcCA9IHByb3RvY29scyhjb2RlKVxuXG4gICAgY29uc3Qgc2l6ZSA9IHNpemVGb3JBZGRyKHAsIGJ1Zi5zbGljZShpICsgbikpXG5cbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgdHVwbGVzLnB1c2goW2NvZGVdKVxuICAgICAgaSArPSBuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHIgPSBidWYuc2xpY2UoaSArIG4sIGkgKyBuICsgc2l6ZSlcblxuICAgIGkgKz0gKHNpemUgKyBuKVxuXG4gICAgaWYgKGkgPiBidWYubGVuZ3RoKSB7IC8vIGRpZCBub3QgZW5kIF9leGFjdGx5XyBhdCBidWZmZXIubGVuZ3RoXG4gICAgICB0aHJvdyBQYXJzZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgYnVmZmVyOiAnICsgYnVmLnRvU3RyaW5nKCdoZXgnKSlcbiAgICB9XG5cbiAgICAvLyBvaywgdHVwbGUgc2VlbXMgZ29vZC5cbiAgICB0dXBsZXMucHVzaChbY29kZSwgYWRkcl0pXG4gIH1cblxuICByZXR1cm4gdHVwbGVzXG59XG5cbi8vIEJ1ZmZlciAtPiBTdHJpbmdcbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nIChidWYpIHtcbiAgY29uc3QgYSA9IGJ1ZmZlclRvVHVwbGVzKGJ1ZilcbiAgY29uc3QgYiA9IHR1cGxlc1RvU3RyaW5nVHVwbGVzKGEpXG4gIHJldHVybiBzdHJpbmdUdXBsZXNUb1N0cmluZyhiKVxufVxuXG4vLyBTdHJpbmcgLT4gQnVmZmVyXG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlciAoc3RyKSB7XG4gIHN0ciA9IGNsZWFuUGF0aChzdHIpXG4gIGNvbnN0IGEgPSBzdHJpbmdUb1N0cmluZ1R1cGxlcyhzdHIpXG4gIGNvbnN0IGIgPSBzdHJpbmdUdXBsZXNUb1R1cGxlcyhhKVxuXG4gIHJldHVybiB0dXBsZXNUb0J1ZmZlcihiKVxufVxuXG4vLyBTdHJpbmcgLT4gQnVmZmVyXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0cmluZ1RvQnVmZmVyKHN0cilcbn1cblxuLy8gQnVmZmVyIC0+IEJ1ZmZlclxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAoYnVmKSB7XG4gIGNvbnN0IGVyciA9IHZhbGlkYXRlQnVmZmVyKGJ1ZilcbiAgaWYgKGVycikgdGhyb3cgZXJyXG4gIHJldHVybiBCdWZmZXIuZnJvbShidWYpIC8vIGNvcHlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCdWZmZXIgKGJ1Zikge1xuICB0cnkge1xuICAgIGJ1ZmZlclRvVHVwbGVzKGJ1ZikgLy8gdHJ5IHRvIHBhcnNlLiB3aWxsIHRocm93IGlmIGJyZWFrc1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZEJ1ZmZlciAoYnVmKSB7XG4gIHJldHVybiB2YWxpZGF0ZUJ1ZmZlcihidWYpID09PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChzdHIpIHtcbiAgcmV0dXJuICcvJyArIHN0ci50cmltKCkuc3BsaXQoJy8nKS5maWx0ZXIoYSA9PiBhKS5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gUGFyc2VFcnJvciAoc3RyKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgYWRkcmVzczogJyArIHN0cilcbn1cblxuZnVuY3Rpb24gcHJvdG9Gcm9tVHVwbGUgKHR1cCkge1xuICBjb25zdCBwcm90byA9IHByb3RvY29scyh0dXBbMF0pXG4gIHJldHVybiBwcm90b1xufVxuIiwiY29uc3QgTXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcbmNvbnN0IHJlZHVjZVZhbHVlID0gKF8sIHYpID0+IHZcblxuY29uc3QgUmVkdWNlcnMgPSB7XG4gIGlwNDogcmVkdWNlVmFsdWUsXG4gIGlwNjogKHN0ciwgY29udGVudCwgaSwgcGFydHMpID0+IChcbiAgICBwYXJ0cy5sZW5ndGggPT09IDEgJiYgcGFydHNbMF0ucHJvdG9jb2wgPT09ICdpcDYnXG4gICAgICA/IGNvbnRlbnRcbiAgICAgIDogYFske2NvbnRlbnR9XWBcbiAgKSxcbiAgdGNwOiAoc3RyLCBjb250ZW50LCBpLCBwYXJ0cykgPT4gKFxuICAgIHBhcnRzLnNvbWUocCA9PiBbJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLCAnd3NzJ10uaW5jbHVkZXMocC5wcm90b2NvbCkpXG4gICAgICA/IGAke3N0cn06JHtjb250ZW50fWBcbiAgICAgIDogYHRjcDovLyR7c3RyfToke2NvbnRlbnR9YFxuICApLFxuICB1ZHA6IChzdHIsIGNvbnRlbnQpID0+IGB1ZHA6Ly8ke3N0cn06JHtjb250ZW50fWAsXG4gIGRuc2FkZHI6IHJlZHVjZVZhbHVlLFxuICBkbnM0OiByZWR1Y2VWYWx1ZSxcbiAgZG5zNjogcmVkdWNlVmFsdWUsXG4gIGlwZnM6IChzdHIsIGNvbnRlbnQpID0+IGAke3N0cn0vaXBmcy8ke2NvbnRlbnR9YCxcbiAgcDJwOiAoc3RyLCBjb250ZW50KSA9PiBgJHtzdHJ9L3AycC8ke2NvbnRlbnR9YCxcbiAgaHR0cDogc3RyID0+IGBodHRwOi8vJHtzdHJ9YCxcbiAgaHR0cHM6IHN0ciA9PiBgaHR0cHM6Ly8ke3N0cn1gLFxuICB3czogc3RyID0+IGB3czovLyR7c3RyfWAsXG4gIHdzczogc3RyID0+IGB3c3M6Ly8ke3N0cn1gLFxuICAncDJwLXdlYnNvY2tldC1zdGFyJzogc3RyID0+IGAke3N0cn0vcDJwLXdlYnNvY2tldC1zdGFyYCxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJydGMtc3RhcmAsXG4gICdwMnAtd2VicnRjLWRpcmVjdCc6IHN0ciA9PiBgJHtzdHJ9L3AycC13ZWJydGMtZGlyZWN0YFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChtdWx0aWFkZHIpID0+IChcbiAgTXVsdGlhZGRyKG11bHRpYWRkcilcbiAgICAuc3RyaW5nVHVwbGVzKClcbiAgICAubWFwKHR1cGxlID0+ICh7XG4gICAgICBwcm90b2NvbDogTXVsdGlhZGRyLnByb3RvY29scy5jb2Rlc1t0dXBsZVswXV0ubmFtZSxcbiAgICAgIGNvbnRlbnQ6IHR1cGxlWzFdXG4gICAgfSkpXG4gICAgLnJlZHVjZSgoc3RyLCBwYXJ0LCBpLCBwYXJ0cykgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlID0gUmVkdWNlcnNbcGFydC5wcm90b2NvbF1cbiAgICAgIGlmICghcmVkdWNlKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb3RvY29sICR7cGFydC5wcm90b2NvbH1gKVxuICAgICAgcmV0dXJuIHJlZHVjZShzdHIsIHBhcnQuY29udGVudCwgaSwgcGFydHMpXG4gICAgfSwgJycpXG4pXG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2lwZnM6cHJlbG9hZCcpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnaXBmczpwcmVsb2FkOmVycm9yJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmVsb2FkICh1cmwsIGNhbGxiYWNrKSB7XG4gIGxvZyh1cmwpXG5cbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICBjb25zdCBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuXG4gIGZldGNoKHVybCwgeyBzaWduYWwgfSlcbiAgICAudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgbG9nLmVycm9yKCdmYWlsZWQgdG8gcHJlbG9hZCcsIHVybCwgcmVzLnN0YXR1cywgcmVzLnN0YXR1c1RleHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIHByZWxvYWQgJHt1cmx9YClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMudGV4dCgpXG4gICAgfSlcbiAgICAudGhlbigoKSA9PiBjYWxsYmFjaygpKVxuICAgIC5jYXRjaChjYWxsYmFjaylcblxuICByZXR1cm4ge1xuICAgIGNhbmNlbDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmV0cnk7XG5cbnZhciBfbm9vcCA9IHJlcXVpcmUoJ2xvZGFzaC9ub29wJyk7XG5cbnZhciBfbm9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub29wKTtcblxudmFyIF9jb25zdGFudCA9IHJlcXVpcmUoJ2xvZGFzaC9jb25zdGFudCcpO1xuXG52YXIgX2NvbnN0YW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnN0YW50KTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXNcbiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCBhdHRlbXB0cyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHJldHJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gQ2FuIGJlIGVpdGhlciBhblxuICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci5cbiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHRcbiAqICAgaXMgYDVgLlxuICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZVxuICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZVxuICogICByZXRyeSBjb3VudCAoc2VlIGV4YW1wbGUpLlxuICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uXG4gKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlO1xuICogICBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIHRoZSByZXRyeSBmbG93IGlzIGFib3J0ZWQgd2l0aCB0aGUgY3VycmVudFxuICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suXG4gKiAgIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqICogSWYgYG9wdHNgIGlzIGEgbnVtYmVyLCB0aGUgbnVtYmVyIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5LFxuICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LlxuICogSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgXG4gKiBhbmQgYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZ1xuICogLy8gYSBjYWxsYmFjaywgYXMgc2hvd24gYmVsb3c6XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXNcbiAqIGFzeW5jLnJldHJ5KDMsIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDEwIHRpbWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcylcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgdGltZXM6IDEwLFxuICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkge1xuICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeShhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXJcbiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFja1xuICogYXN5bmMucmV0cnkoe1xuICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yXG4gKiAgIH1cbiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0byByZXRyeSBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlIHdpdGhpbiBvdGhlclxuICogLy8gY29udHJvbCBmbG93IGZ1bmN0aW9ucywgdXNlIHRoZSBgcmV0cnlhYmxlYCB3cmFwcGVyOlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksXG4gKiAgICAgcGF5bWVudHM6IGFzeW5jLnJldHJ5YWJsZSgzLCBhcGkuZ2V0UGF5bWVudHMuYmluZChhcGkpKVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHNcbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gcmV0cnkob3B0cywgdGFzaywgY2FsbGJhY2spIHtcbiAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgdmFyIERFRkFVTFRfSU5URVJWQUwgPSAwO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLFxuICAgICAgICBpbnRlcnZhbEZ1bmM6ICgwLCBfY29uc3RhbnQyLmRlZmF1bHQpKERFRkFVTFRfSU5URVJWQUwpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHQuaW50ZXJ2YWwgOiAoMCwgX2NvbnN0YW50Mi5kZWZhdWx0KSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBfbm9vcDIuZGVmYXVsdDtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VUaW1lcyhvcHRpb25zLCBvcHRzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBfbm9vcDIuZGVmYXVsdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgIH1cblxuICAgIHZhciBfdGFzayA9ICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KSh0YXNrKTtcblxuICAgIHZhciBhdHRlbXB0ID0gMTtcbiAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQoKSB7XG4gICAgICAgIF90YXNrKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJiAodHlwZW9mIG9wdGlvbnMuZXJyb3JGaWx0ZXIgIT0gJ2Z1bmN0aW9uJyB8fCBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXRyeUF0dGVtcHQsIG9wdGlvbnMuaW50ZXJ2YWxGdW5jKGF0dGVtcHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0cnlBdHRlbXB0KCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGVOcG1TbmFwUGFja2FnZUpzb24uanMubWFwIn0=
